

        private void InitConfig()
        {
            Tags = GetConfig(new List<string>
            {
                "★"
            }, "Tags");
            Commands = GetConfig(new List<string>
            {
                "tags",
                "tag"
            }, "Commands");

            if (ConfigChanged)
            {
                PrintWarning("Updated the configuration file with new/updated values.");
                SaveConfig();
            }
        }

        private T GetConfig<T>(T defaultVal, params string[] path)
        {
            var data = Config.Get(path);
            if (data != null)
            {
                return Config.ConvertValue<T>(data);
            }

            Config.Set(path.Concat(new object[] { defaultVal }).ToArray());
            ConfigChanged = true;
            return defaultVal;
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["Permission"] = "You don't have permission to use that command",
                ["Tags.Disabled"] = "You have disabled your tags from showing in chat.",
                ["Tags.Enabled"] = "You have enabled your tags. They will now show in chat."
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Methods

        private void LoadData()
        {
            TagData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, bool>>(Name);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, TagData);
        }

        private void RegisterCommands()
        {
            if (!Commands.Any())
            {
                PrintWarning("No commands registered in the config. Registering default commands...");
                Commands = new List<string>
                {
                    "tags",
                    "tag"
                };
            }

            AddCovalenceCommand(Commands.ToArray(), nameof(TagCommand));
        }

        #endregion

        #region Hooks

        private void Init()
        {
            InitConfig();
            LoadData();
            RegisterCommands();
            permission.RegisterPermission(UsePerm, this);
        }

        private void Unload()
        {
            SaveData();
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            var titles = (List<string>) data["Titles"];
            var player = (IPlayer) data["Player"];

            if (!titles.Any() || player == null)
            {
                return null;
            }

            bool value;
            if (!TagData.TryGetValue(player.Id, out value) || value)
            {
                return null;
            }

            foreach (var title in titles.ToList())
            {
                var formattedTitle = Formatter.ToPlaintext(title);

                if (!Tags.Contains(formattedTitle))
                {
                    continue;
                }

                titles.Remove(title);
            }

            data["Titles"] = titles;
            return data;
        }

        #endregion

        #region Commands

        private void TagCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(UsePerm))
            {
                player.Message(Lang("Permission", player.Id));
                return;
            }

            bool value;
            if (!TagData.TryGetValue(player.Id, out value) || !value)
            {
                player.Message(Lang("Tags.Enabled", player.Id));
                TagData[player.Id] = true;
                return;
            }

            player.Message(Lang("Tags.Disabled", player.Id));
            TagData[player.Id] = false;
            SaveData();
        }

        #endregion
    }
}

// --- End of file: BetterChatToggle.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/build ---
// --- Original File Path: B/Build/Build.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Facepunch;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Build", "Gonzi", "2.2.2")]
    [Description("Build, spawn, plant, upgrade, deploy anything the way that you want it")]
    public class Build : RustPlugin
    {
        #region UI
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string parent, string panelName, string color, string aMin, string aMax, bool useCursor)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateImage(ref CuiElementContainer container, string panel, string url, string name, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Url = url
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = aMin,
                            AnchorMax = aMax
                        }
                    }
                });
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        }
        #endregion

        bool permBuildForAll = false;

        private static float mdist = 9999f;

        private static int generalColl = LayerMask.GetMask("Construction", "Deployable", "Default", "Prevent Building", "Deployed", "Resource", "Terrain", "Water", "World", "Tree");
        private static int constructionColl = UnityEngine.LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });

        private string green = "0 1 0 0.5";
        private string red = "1 0 0 0.5";
        private string gray = "0.5 0.5 0.5 0.5";
        private string lightgray = "1 1 1 0.8";
        private string permBuild = "build.perm";

        private static Vector3 newPos = new Vector3(0f, 0f, 0f);
        private static Quaternion newRot = new Quaternion(0f, 0f, 0f, 0f);
        private static Quaternion defaultQuaternion = Quaternion.Euler(0f, 45f, 0f);
        private static BuildingConstruction sourcebuild = null;
        private static BuildingConstruction targetbuild = null;
        private static Dictionary<string, BuildingConstruction> buildings = new Dictionary<string, BuildingConstruction>();
        private static Dictionary<Building, string> BuildingToPrefab = new Dictionary<Building, string>();
        private static Dictionary<string, uint> deployables = new Dictionary<string, uint>();
        private static List<string> resourcesList = new List<string>();
        private static Dictionary<string, string> resourcesDictionary = new Dictionary<string, string>();
        private static List<string> resourcesListSortedKeys = new List<string>();
        private static List<object> houseList = new List<object>();
        private static List<Vector3> checkFrom = new List<Vector3>();

        private Dictionary<ulong, PlayerBuild> playerBuild = new Dictionary<ulong, PlayerBuild>();
        private Dictionary<ulong, bool> buildToggled = new Dictionary<ulong, bool>();

        static Build build = null;

        private enum Placement
        {
            Auto,
            Up,
            Force
        }

        private enum PlayerBuildType
        {
            Build,
            Deploy,
            Spawn,
            Grade,
            Heal,
            Rotate,
            Erase,
            None
        }

        private enum Building
        {
            Foundation,
            FoundationTriangle,
            FoundationSteps,
            Floor,
            FloorTriangle,
            FloorFrame,
            Wall,
            WallDoorway,
            WallWindow,
            WallFrame,
            WallHalf,
            WallLow,
            StairsLShaped,
            StairsUShaped,
            Roof,
            RoofTriangle
        }

        private enum Selection
        {
            Select,
            All
        }

        private enum SocketType
        {
            Wall,
            Floor,
            Steps,
            FloorTriangle,
            Block,
            Roof,
            RoofTriangle
        }

        bool hasAuth(BasePlayer player)
        {
            return (permBuildForAll || (permission.UserHasPermission(player.userID.ToString(), permBuild)));
        }

        void OnServerInitialized()
        {
            build = this;
            permission.RegisterPermission(permBuild, this);

            BuildingToPrefab = new Dictionary<Building, string>
            {
                {Building.Foundation, "assets/prefabs/building core/foundation/foundation.prefab" },
                {Building.Floor, "assets/prefabs/building core/floor/floor.prefab" },
                {Building.FloorFrame, "assets/prefabs/building core/floor.frame/floor.frame.prefab" },
                {Building.FoundationSteps, "assets/prefabs/building core/foundation.steps/foundation.steps.prefab" },
                {Building.Wall,"assets/prefabs/building core/wall/wall.prefab" },
                {Building.WallDoorway,"assets/prefabs/building core/wall.doorway/wall.doorway.prefab" },
                {Building.WallFrame,"assets/prefabs/building core/wall.frame/wall.frame.prefab" },
                {Building.WallHalf,"assets/prefabs/building core/wall.half/wall.half.prefab" },
                {Building.WallLow,"assets/prefabs/building core/wall.low/wall.low.prefab" },
                {Building.WallWindow,"assets/prefabs/building core/wall.window/wall.window.prefab" },
                {Building.FoundationTriangle,"assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab"},
                {Building.FloorTriangle,"assets/prefabs/building core/floor.triangle/floor.triangle.prefab" },
                {Building.StairsLShaped,"assets/prefabs/building core/stairs.l/block.stair.lshape.prefab" },
                {Building.Roof,"assets/prefabs/building core/roof/roof.prefab" },
                {Building.RoofTriangle,"assets/prefabs/building core/roof.triangle/roof.triangle.prefab" },
                {Building.StairsUShaped,"assets/prefabs/building core/stairs.u/block.stair.ushape.prefab" }
            };

            buildings.Clear();

            var foundationSockets = new BuildingSocket(SocketType.Floor);
            foundationSockets.AddTargetSock(SocketType.Floor, new Vector3(0, 0, -3f), new Quaternion(0, 1f, 0, 0));
            foundationSockets.AddTargetSock(SocketType.Floor, new Vector3(-3f, 0, 0), new Quaternion(0, 0f, 0, 1f));
            foundationSockets.AddTargetSock(SocketType.Floor, new Vector3(0f, 0f, 3f), new Quaternion(0f, 0f, 0f, 1f));
            foundationSockets.AddTargetSock(SocketType.Floor, new Vector3(3f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            foundationSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 1f, 0f, 0f));
            foundationSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(-1.5f, 0f, 0f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(0f, 0f, 1.5f), new Quaternion(0f, 0f, 0f, 1f));
            foundationSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(1.5f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            foundationSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, 1.5f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.Wall, new Vector3(-1.5f, 0f, 0f), new Quaternion(0f, 1f, 0f, 0f));
            foundationSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.Wall, new Vector3(1.5f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            foundationSockets.AddTargetSock(SocketType.Roof, new Vector3(0f, 0f, 3f), new Quaternion(0f, 1f, 0f, 0f));
            foundationSockets.AddTargetSock(SocketType.Roof, new Vector3(-3f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.Roof, new Vector3(0f, 0f, -3f), new Quaternion(0f, 0f, 0f, 1f));
            foundationSockets.AddTargetSock(SocketType.Roof, new Vector3(3f, 0f, 0f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));

            foundationSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(0f, 0f, 2.366f), new Quaternion(0f, 1f, 0f, 0f));
            foundationSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(-2.366f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(0f, 0f, -2.366f), new Quaternion(0f, 0f, 0f, 1f));
            foundationSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(2.366f, 0f, 0f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));

            foundationSockets.AddTargetSock(SocketType.Block, new Vector3(0f, 0.1f, 0f), new Quaternion(0f, 1f, 0f, 0f));

            foundationSockets.AddTargetSock(SocketType.Steps, new Vector3(0f, 0f, 1.5f), new Quaternion(0f, -0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.Steps, new Vector3(-1.5f, 0f, 0f), new Quaternion(0f, 1f, 0f, 0f));
            foundationSockets.AddTargetSock(SocketType.Steps, new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            foundationSockets.AddTargetSock(SocketType.Steps, new Vector3(1.5f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            buildings.Add("assets/prefabs/building core/foundation/foundation.prefab", new BuildingConstruction("assets/prefabs/building core/foundation/foundation.prefab", foundationSockets, Building.Foundation));
            buildings.Add("assets/prefabs/building core/floor/floor.prefab", new BuildingConstruction("assets/prefabs/building core/floor/floor.prefab", foundationSockets, Building.Floor));
            buildings.Add("assets/prefabs/building core/floor.frame/floor.frame.prefab", new BuildingConstruction("assets/prefabs/building core/floor.frame/floor.frame.prefab", foundationSockets, Building.FloorFrame));


            //TODO wallHalfSocket
            var wallSockets = new BuildingSocket(SocketType.Wall);
            wallSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, -3f), new Quaternion(0f, 0f, 0f, 1f));
            wallSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, 3f), new Quaternion(0f, 0f, 0f, 1f));

            wallSockets.AddTargetSock(SocketType.Floor, new Vector3(1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, -0.7071068f));
            wallSockets.AddTargetSock(SocketType.Floor, new Vector3(-1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            wallSockets.AddTargetSock(SocketType.Roof, new Vector3(1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, -0.7071068f));
            wallSockets.AddTargetSock(SocketType.Roof, new Vector3(-1.5f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            wallSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(0.866f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, -0.7071068f));
            wallSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(-0.866f, 3f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));


            buildings.Add("assets/prefabs/building core/wall/wall.prefab", new BuildingConstruction("assets/prefabs/building core/wall/wall.prefab", wallSockets, Building.Wall));
            buildings.Add("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", new BuildingConstruction("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", wallSockets, Building.Wall));
            buildings.Add("assets/prefabs/building core/wall.frame/wall.frame.prefab", new BuildingConstruction("assets/prefabs/building core/wall.frame/wall.frame.prefab", wallSockets, Building.WallFrame));
            buildings.Add("assets/prefabs/building core/wall.half/wall.half.prefab", new BuildingConstruction("assets/prefabs/building core/wall.half/wall.half.prefab", wallSockets, Building.WallHalf));
            buildings.Add("assets/prefabs/building core/wall.low/wall.low.prefab", new BuildingConstruction("assets/prefabs/building core/wall.low/wall.low.prefab", wallSockets, Building.WallLow));
            buildings.Add("assets/prefabs/building core/wall.window/wall.window.prefab", new BuildingConstruction("assets/prefabs/building core/wall.window/wall.window.prefab", wallSockets, Building.WallWindow));

            var stepsSockets = new BuildingSocket(SocketType.Steps);

            stepsSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));
            stepsSockets.AddTargetSock(SocketType.Wall, new Vector3(3f, 1.5f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            stepsSockets.AddTargetSock(SocketType.Floor, new Vector3(4.5f, 1.5f, 0f), new Quaternion(0f, 0.7071068f, 0f, -0.7071068f));
            stepsSockets.AddTargetSock(SocketType.Floor, new Vector3(-1.5f, 0f, 0f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            buildings.Add("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", new BuildingConstruction("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", stepsSockets, Building.FoundationSteps));

            var trianglesSockets = new BuildingSocket(SocketType.FloorTriangle);
            trianglesSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(0f, 0f, 0f), new Quaternion(0f, 1f, 0f, 0.0000001629207f));
            trianglesSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(-0.75f, 0f, 1.299038f), new Quaternion(0f, 0.4999998f, 0f, -0.8660255f));
            trianglesSockets.AddTargetSock(SocketType.FloorTriangle, new Vector3(0.75f, 0f, 1.299038f), new Quaternion(0f, 0.5000001f, 0f, 0.8660254f));

            trianglesSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 0f, 0f), new Quaternion(0f, 0.7f, 0f, 0.7000001629207f));
            trianglesSockets.AddTargetSock(SocketType.Wall, new Vector3(-0.75f, 0f, 1.299038f), new Quaternion(0f, 0.96593f, 0f, -0.25882f));
            trianglesSockets.AddTargetSock(SocketType.Wall, new Vector3(0.75f, 0f, 1.299038f), new Quaternion(0f, -0.25882f, 0f, 0.96593f));

            trianglesSockets.AddTargetSock(SocketType.Roof, new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 0f, 0f, 1f));
            trianglesSockets.AddTargetSock(SocketType.Roof, new Vector3(-2.0490381f, 0f, 2.0490381f), new Quaternion(0f, 0.8660254f, 0f, 0.5f));
            trianglesSockets.AddTargetSock(SocketType.Roof, new Vector3(2.0490381f, 0f, 2.0490381f), new Quaternion(0f, -0.8660254f, 0f, 0.5f));

            trianglesSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(0f, 0f, -0.8659995f), new Quaternion(0f, 0f, 0f, 1f));
            trianglesSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(-1.4999810f, 0f, 1.7329830f), new Quaternion(0f, 0.8660254f, 0f, 0.5f));
            trianglesSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(1.4999810f, 0f, 1.7329830f), new Quaternion(0f, -0.8660254f, 0f, 0.5f));

            trianglesSockets.AddTargetSock(SocketType.Floor, new Vector3(0f, 0f, -1.5f), new Quaternion(0f, 1f, 0f, 0f));
            trianglesSockets.AddTargetSock(SocketType.Floor, new Vector3(-2.0490381f, 0f, 2.0490381f), new Quaternion(0f, 0.5f, 0f, -0.8660254f));
            trianglesSockets.AddTargetSock(SocketType.Floor, new Vector3(2.0490381f, 0f, 2.0490381f), new Quaternion(0f, 0.5f, 0f, 0.8660254f));

            buildings.Add("assets/prefabs/building core/floor.triangle/floor.triangle.prefab", new BuildingConstruction("assets/prefabs/building core/floor.triangle/floor.triangle.prefab", trianglesSockets, Building.FloorTriangle));
            buildings.Add("assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab", new BuildingConstruction("assets/prefabs/building core/foundation.triangle/foundation.triangle.prefab", trianglesSockets, Building.FoundationTriangle));

            buildings.Add("assets/prefabs/building core/stairs.l/block.stair.lshape.prefab", new BuildingConstruction("assets/prefabs/building core/stairs.l/block.stair.lshape.prefab", new BuildingSocket(SocketType.Block), Building.StairsLShaped));
            buildings.Add("assets/prefabs/building core/stairs.u/block.stair.ushape.prefab", new BuildingConstruction("assets/prefabs/building core/stairs.u/block.stair.ushape.prefab", new BuildingSocket(SocketType.Block), Building.StairsUShaped));

            var roofSockets = new BuildingSocket(SocketType.Roof);
            roofSockets.AddTargetSock(SocketType.Roof, new Vector3(0f, 3f, -3f), new Quaternion(0f, 0f, 0f, 1f));
            roofSockets.AddTargetSock(SocketType.Roof, new Vector3(-3f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));
            roofSockets.AddTargetSock(SocketType.Roof, new Vector3(3f, 0f, 0f), new Quaternion(0f, 0f, 0f, 1f));

            roofSockets.AddTargetSock(SocketType.RoofTriangle, new Vector3(0f, 3f, -2.3642493f), new Quaternion(0f, 0f, 0f, 1f));

            roofSockets.AddTargetSock(SocketType.Wall, new Vector3(0f, 3f, -1.5f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            roofSockets.AddTargetSock(SocketType.Floor, new Vector3(0f, 3f, -3f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));
            roofSockets.AddTargetSock(SocketType.Floor, new Vector3(0f, 0f, 3f), new Quaternion(0f, 0.7071068f, 0f, 0.7071068f));

            buildings.Add("assets/prefabs/building core/roof/roof.prefab", new BuildingConstruction("assets/prefabs/building core/roof/roof.prefab", roofSockets, Building.Roof));

            var roofTriangleSockets = new BuildingSocket(SocketType.RoofTriangle);

            //Nobody can attach to roofTriangle directly
            //Correction of 0.2326169 for socket lock.

            buildings.Add(BuildingToPrefab[Building.RoofTriangle], new BuildingConstruction(BuildingToPrefab[Building.RoofTriangle], roofTriangleSockets, Building.RoofTriangle));

            foreach (var d in GetAllPrefabs<Construction>())
            {
                if (d.deployable != null && d.isServer)
                {
                    string name = d.hierachyName.Replace("_deployed", "").Replace(".deployed", "");
                    if (!deployables.ContainsKey(name))
                        deployables.Add(name, d.prefabID);
                }
            }
            deployables = deployables.OrderBy(w => w.Key).ToDictionary(t => t.Key, t => t.Value);

            resourcesList.Clear();

            foreach (var str in FileSystem.Backend.cache.Keys)
            {
                if (str.EndsWith(".prefab"))
                {
                    if (str.Contains(".worldmodel.")
                    || str.Contains("/fx/")
                    || str.Contains("/effects/")
                    || str.Contains("/build/skins/")
                    || str.Contains("/_unimplemented/")
                    || str.Contains("/ui/")
                    || str.Contains("/sound/")
                    || str.Contains("/footsteps/")
                    || str.Contains("/sounds/")
                    || str.Contains("/world/")
                    || str.Contains("/env/")
                    || str.Contains("/clothing/")
                    || str.Contains("/skins/")
                    || str.Contains("/decor/")
                    || str.Contains("/monument/")
                    || str.Contains("/projectiles/")
                    || str.Contains("/meat_")
                    || str.EndsWith(".skin.prefab")
                    || str.EndsWith(".viewmodel.prefab")
                    || str.EndsWith("_test.prefab")
                    || str.EndsWith("_collision.prefab")
                    || str.EndsWith("_ragdoll.prefab")
                    || str.EndsWith("_skin.prefab")
                    || str.Contains("localization")
                    || str.Contains("/skin/")
                    || str.Contains("/materials/")
                    || str.Contains("/system/")
                    || str.Contains("/physicmaterials/")
                    || str.Contains("/image effects/")
                    || str.Contains("/icons/")
                    || str.Contains("/system/")
                    || str.Contains("/server/")
                    || str.Contains("/clutter/"))
                        continue;

                    var gmobj = GameManager.server.FindPrefab(str);

                    if (gmobj?.GetComponent<BaseEntity>() != null && !resourcesList.Contains(str))
                    {
                        resourcesList.Add(str);
                    }
                }
            }
        }

        void OnPlayerInput(BasePlayer player, InputState state)
        {
            if (state.WasJustPressed(BUTTON.FIRE_THIRD))
            {
                if (hasAuth(player))
                {
                    if (!buildToggled.ContainsKey(player.userID))
                    {
                        if (!playerBuild.ContainsKey(player.userID))
                        {
                            playerBuild.Add(player.userID, new PlayerBuild(player));
                        }
                        BuildMenu_Toggle(player);
                        buildToggled.Add(player.userID, true);
                    }
                    else
                    {
                        BuildMenu_UnToggle(player);
                        buildToggled.Remove(player.userID);
                    }
                }
            }
            else if (playerBuild.ContainsKey(player.userID) && state.IsDown(BUTTON.FIRE_SECONDARY))
            {
                PlayerBuild pB = playerBuild[player.userID];
                if (!state.WasJustPressed(BUTTON.FIRE_SECONDARY))
                {
                    if ((Time.realtimeSinceStartup - pB.lastClick) < 0.5f)
                    {
                        return;
                    }
                }
                pB.lastClick = Time.realtimeSinceStartup;

                pB.Execute();
            }
        }

        #region BuildMenu
        void BuildMenu_Toggle(BasePlayer player)
        {
            PlayerBuild pB = playerBuild[player.userID];

            BuildMenu_UnToggle(player);

            CuiElementContainer page_container = UI.CreateElementContainer("Overlay", "BuildMenuContainer", "0.1 0.1 0.1 0.8", "0.1 0.3", "0.9 0.5", true);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Build ? green : gray, "Build", 16, "0.01 0.05", "0.11 0.5", "build.select build", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Deploy ? green : gray, "Deploy", 16, "0.12 0.05", "0.22 0.5", "build.select deploy", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Spawn ? green : gray, "Spawn", 16, "0.23 0.05", "0.33 0.5", "build.select spawn", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Grade ? green : gray, "Grade", 16, "0.34 0.05", "0.44 0.5", "build.select grade", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Rotate ? green : gray, "Rotate", 16, "0.45 0.05", "0.55 0.5", "build.select rotate", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Heal ? green : gray, "Heal", 16, "0.56 0.05", "0.66 0.5", "build.select heal", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.Erase ? green : gray, "Erase", 16, "0.67 0.05", "0.77 0.5", "build.select erase", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.buildType == PlayerBuildType.None ? green : gray, "None", 16, "0.78 0.05", "0.88 0.5", "build.select none", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", red, "Undo", 16, "0.89 0.05", "0.99 0.5", "build.select undo", TextAnchor.MiddleCenter);

            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.crosshair ? green : gray, "Crosshair", 10, "0.78 0.80", "0.99 0.99", "build.select crosshair", TextAnchor.MiddleCenter);
            UI.CreateButton(ref page_container, "BuildMenuContainer", pB.player.modelState.flying ? green : gray, "Noclip", 10, "0.78 0.60", "0.99 0.79", "build.select noclip", TextAnchor.MiddleCenter);

            CuiHelper.AddUi(player, page_container);

            BuildMenu_Sub(player);
        }

        void BuildMenu_UnToggle(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "BuildMenuContainer");
            CuiHelper.DestroyUi(player, "BuildMenuContainerSub");
        }

        void BuildMenu_Sub(BasePlayer player)
        {
            PlayerBuild pB = playerBuild[player.userID];

            if (pB.buildType == PlayerBuildType.None || pB.buildType == PlayerBuildType.Erase) return;

            string sizeFrom = (pB.buildType == PlayerBuildType.Grade) || (pB.buildType == PlayerBuildType.Heal) || (pB.buildType == PlayerBuildType.Rotate) ? "0.1 0.20" : "0.1 0.05";
            string sizeTo = "0.9 0.30";
            CuiElementContainer page_container = UI.CreateElementContainer("Overlay", "BuildMenuContainerSub", "0.1 0.1 0.1 0.8", sizeFrom, sizeTo, true);

            if ((pB.buildType == PlayerBuildType.Grade) || (pB.buildType == PlayerBuildType.Heal) || (pB.buildType == PlayerBuildType.Rotate))
            {
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.select == Selection.Select ? green : gray, "Select", 16, "0.01 0.50", "0.20 0.95", "build.select select select", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.select == Selection.All ? green : gray, "All", 16, "0.21 0.50", "0.40 0.95", "build.select select all", TextAnchor.MiddleCenter);
            }

            if ((pB.buildType == PlayerBuildType.Build) || (pB.buildType == PlayerBuildType.Spawn) || (pB.buildType == PlayerBuildType.Deploy))
            {
                UI.CreateLabel(ref page_container, "BuildMenuContainerSub", lightgray, "Height:", 12, "0.36 0.90", "0.40 0.99", TextAnchor.MiddleCenter);

                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "-3", 12, "0.41 0.90", "0.45 0.99", "build.select height minus 3", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "-1.5", 12, "0.45 0.90", "0.49 0.99", "build.select height minus 1.5", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "0", 12, "0.49 0.90", "0.53 0.99", "build.select height reset", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+1.5", 12, "0.53 0.90", "0.57 0.99", "build.select height plus 1.5", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+3", 12, "0.57 0.90", "0.61 0.99", "build.select height plus 3", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "----", 9, "0.62 0.92", "0.65 0.97", "build.select height minus 10", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "---", 9, "0.65 0.92", "0.68 0.97", "build.select height minus 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "--", 9, "0.68 0.92", "0.71 0.97", "build.select height minus 0.1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "-", 9, "0.71 0.92", "0.74 0.97", "build.select height minus 0.01", TextAnchor.MiddleCenter);
                UI.CreateLabel(ref page_container, "BuildMenuContainerSub", lightgray, pB.height.ToString(), 12, "0.75 0.90", "0.80 0.99", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+", 9, "0.81 0.92", "0.84 0.97", "build.select height plus 0.01", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "++", 9, "0.84 0.92", "0.87 0.97", "build.select height plus 0.1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+++", 9, "0.87 0.92", "0.90 0.97", "build.select height plus 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "++++", 9, "0.90 0.92", "0.93 0.97", "build.select height plus 10", TextAnchor.MiddleCenter);
            }

            if (pB.buildType == PlayerBuildType.Spawn || pB.buildType == PlayerBuildType.Deploy)
            {
                UI.CreateLabel(ref page_container, "BuildMenuContainerSub", lightgray, "Rotation:", 12, "0.00 0.90", "0.05 0.99", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "-90", 12, "0.05 0.90", "0.10 0.99", "build.select rotation minus 90", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "-45", 12, "0.10 0.90", "0.15 0.99", "build.select rotation minus 45", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "0", 12, "0.15 0.90", "0.19 0.99", "build.select rotation reset", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+45", 12, "0.19 0.90", "0.23 0.99", "build.select rotation plus 45", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "+90", 12, "0.23 0.90", "0.27 0.99", "build.select rotation plus 90", TextAnchor.MiddleCenter);

                UI.CreateLabel(ref page_container, "BuildMenuContainerSub", lightgray, pB.rotation.ToString(), 12, "0.27 0.90", "0.31 0.99", TextAnchor.MiddleCenter);


            }

            if (pB.buildType == PlayerBuildType.Build)
            {
                UI.CreateLabel(ref page_container, "BuildMenuContainerSub", lightgray, "Placement:", 16, "0.01 0.80", "0.10 0.99", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.placement == Placement.Auto ? green : gray, "Auto", 16, "0.11 0.80", "0.15 0.99", "build.select placement auto", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.placement == Placement.Force ? green : gray, "Force", 16, "0.16 0.80", "0.20 0.99", "build.select placement force", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.placement == Placement.Up ? green : gray, "Up", 16, "0.21 0.80", "0.25 0.99", "build.select placement up", TextAnchor.MiddleCenter);

                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Twigs ? green : gray, "Twig", 16, "0.01 0.60", "0.20 0.79", "build.select grade 0", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Wood ? green : gray, "Wood", 16, "0.21 0.60", "0.40 0.79", "build.select grade 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Stone ? green : gray, "Stone", 16, "0.41 0.60", "0.60 0.79", "build.select grade 2", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Metal ? green : gray, "Metal", 16, "0.61 0.60", "0.80 0.79", "build.select grade 3", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.TopTier ? green : gray, "TopTier", 16, "0.81 0.60", "0.99 0.79", "build.select grade 4", TextAnchor.MiddleCenter);

                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.Foundation ? green : gray, "Foundation", 12, "0.01 0.05", "0.0753 0.5", "build.select build foundation", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.FoundationTriangle ? green : gray, "Foundation Triangle", 12, "0.0753 0.05", "0.1406 0.5", "build.select build foundation.triangle", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.FoundationSteps ? green : gray, "Foundation Steps", 12, "0.1406 0.05", "0.206 0.5", "build.select build foundation.steps", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.Floor ? green : gray, "Floor", 12, "0.206 0.05", "0.271 0.5", "build.select build floor", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.FloorTriangle ? green : gray, "Floor Triangle", 12, "0.271 0.05", "0.337 0.5", "build.select build floor.triangle", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.FloorFrame ? green : gray, "Floor Frame", 12, "0.337 0.05", "0.402 0.5", "build.select build floor.frame", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.Wall ? green : gray, "Wall", 12, "0.402 0.05", "0.467 0.5", "build.select build wall", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.WallDoorway ? green : gray, "Wall Doorway", 12, "0.467 0.05", "0.533 0.5", "build.select build wall.doorway", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.WallWindow ? green : gray, "Wall Window", 12, "0.533 0.05", "0.598 0.5", "build.select build wall.window", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.WallFrame ? green : gray, "Wall Frame", 12, "0.598 0.05", "0.663 0.5", "build.select build wall.frame", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.WallHalf ? green : gray, "Wall Half", 12, "0.663 0.05", "0.729 0.5", "build.select build wall.half", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.WallLow ? green : gray, "Wall Low", 12, "0.729 0.05", "0.794 0.5", "build.select build wall.low", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.StairsLShaped ? green : gray, "Stairs L Shapred", 12, "0.794 0.05", "0.859 0.5", "build.select build stairs.l.shaped", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.StairsUShaped ? green : gray, "Stairs U Shapred", 12, "0.859 0.05", "0.925 0.5", "build.select build stairs.u.shaped", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.Roof ? green : gray, "Roof", 12, "0.925 0.25", "0.99 0.50", "build.select build roof", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.constructionBuild == Building.RoofTriangle ? green : gray, "RoofTriangle", 12, "0.925 0.05", "0.99 0.25", "build.select build roof.triangle", TextAnchor.MiddleCenter);

            }
            else if (pB.buildType == PlayerBuildType.Deploy)
            {
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "<<", 12, "0.01 0.01", "0.50 0.10", "build.select deploy page previous", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, ">>", 12, "0.5 0.01", "0.99 0.10", "build.select deploy page next", TextAnchor.MiddleCenter);

                int startid = pB.deploypage * 80;

                float px = 0f;
                float py = 0.9f;
                int i = 0;
                foreach (KeyValuePair<string, uint> deployable in deployables)
                {
                    if (i >= startid)
                    {
                        var ButtonShowValue = deployable.Key.Substring(deployable.Key.LastIndexOf("/") + 1).Replace(".prefab", "");
                        UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.currentConstruction != null ? pB.currentConstruction.prefabID == deployable.Value ? green : gray : gray, ButtonShowValue, 9, string.Format("{0} {1}", px.ToString(), (py - 0.09f).ToString()), string.Format("{0} {1}", (px + 0.1f).ToString(), py.ToString()), "build.select deploy select " + deployable.Value.ToString(), TextAnchor.MiddleLeft);
                        px += 0.1f;
                        if (px > 0.91f)
                        {
                            py -= 0.1f;
                            px = 0f;
                            if (py < 0.19f)
                            {
                                break;
                            }
                        }
                    }

                    i++;
                }
            }
            else if (pB.buildType == PlayerBuildType.Grade)
            {
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Twigs ? green : gray, "Twig", 16, "0.01 0.05", "0.20 0.49", "build.select grade 0", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Wood ? green : gray, "Wood", 16, "0.21 0.05", "0.40 0.49", "build.select grade 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Stone ? green : gray, "Stone", 16, "0.41 0.05", "0.60 0.49", "build.select grade 2", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.Metal ? green : gray, "Metal", 16, "0.61 0.05", "0.80 0.49", "build.select grade 3", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.grade == BuildingGrade.Enum.TopTier ? green : gray, "TopTier", 16, "0.81 0.05", "0.99 0.49", "build.select grade 4", TextAnchor.MiddleCenter);
            }
            else if (pB.buildType == PlayerBuildType.Spawn)
            {
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, "<<", 12, "0.01 0.01", "0.50 0.10", "build.select spawn page previous", TextAnchor.MiddleCenter);
                UI.CreateButton(ref page_container, "BuildMenuContainerSub", gray, ">>", 12, "0.5 0.01", "0.99 0.10", "build.select spawn page next", TextAnchor.MiddleCenter);

                int startid = pB.spawnpage * 40;

                float px = 0f;
                float py = 0.9f;
                int i = 0;
                SortResourcesList();
                foreach (string r in resourcesListSortedKeys)
                {
                    if (i >= startid)
                    {
                        UI.CreateButton(ref page_container, "BuildMenuContainerSub", pB.currentSpawn != string.Empty ? pB.currentSpawn == r ? green : gray : gray, r.Substring(0, r.Length - 3), 9, string.Format("{0} {1}", px.ToString(), (py - 0.09f).ToString()), string.Format("{0} {1}", (px + 0.2f).ToString(), py.ToString()), "build.select spawn select " + resourcesDictionary[r].ToString(), TextAnchor.MiddleLeft);
                        px += 0.2f;
                        if (px > 0.91f)
                        {
                            py -= 0.1f;
                            px = 0f;
                            if (py < 0.19f)
                            {
                                break;
                            }
                        }
                    }

                    i++;
                }
            }
            CuiHelper.AddUi(player, page_container);
        }

        private void SortResourcesList()
        {
            resourcesDictionary.Clear();
            resourcesListSortedKeys.Clear();
            string shortString = "";
            int index = 0;

            foreach (string r in resourcesList)
            {
                shortString = r.Substring(r.LastIndexOf("/") + 1).Replace(".prefab", "");

                if (r.Contains("/easter/"))
                {
                    shortString = "Easter: " + shortString;
                }
                else if (r.Contains("/halloween/"))
                {
                    shortString = "Halloween: " + shortString;
                }
                else if (r.Contains("/xmas/"))
                {
                    shortString = "Xmas: " + shortString;
                }
                else if ((r.Contains("crate")
                    || r.Contains("supply_drop")
                    || r.Contains("barrel")
                    || r.Contains("/divesite/")
                    || r.Contains("barrel")
                    || r.Contains("junkpile")
                    || r.Contains("minecart")
                    || r.Contains("item drop")
                    || r.Contains("trash-pile")
                    || r.Contains("foodbox")
                    || r.Contains("/dmloot/")) && (!r.Contains("scientist")))
                {
                    shortString = "Crate: " + shortString;
                }
                else if (r.Contains("/resource/") || r.Contains("ore_"))
                {
                    shortString = "Res: " + shortString;
                }
                else if (r.Contains("/vehicles/") || r.Contains("/vehicle/"))
                {
                    shortString = "Vehicle: " + shortString;
                }
                else if (r.Contains("/weapons/") && !r.Contains("waterball"))
                {
                    shortString = "Weapon: " + shortString;
                }
                else if (r.Contains("/electric/") || r.Contains("/playerioents/"))
                {
                    shortString = "Electric: " + shortString;
                }
                else if (r.Contains("/building core/") || r.Contains("/building/") || r.Contains("/deployable/") || r.Contains("vendingmachine") || r.Contains("/static/") || r.Contains("/structures/"))
                {
                    shortString = "Build: " + shortString;
                }
                else if (r.Contains("/collectable/") || r.Contains("/tools/"))
                {
                    shortString = "Item: " + shortString;
                }
                else if (r.Contains("/plants/"))
                {
                    shortString = "Plants: " + shortString;
                }
                else if (r.Contains("fireball") || r.Contains("napalm") || r.Contains("waterball") || r.Contains("/ammo/") || r.Contains("rocket_"))
                {
                    shortString = "Effect: " + shortString;
                }
                else if (r.Contains("/npc/") || r.Contains("/agents/") || r.Contains("player_corpse") || r.Contains("player.prefab"))
                {
                    shortString = "NPC: " + shortString;
                }
                else if (r.Contains("test"))
                {
                    shortString = "Test: " + shortString;
                }
                else
                {
                    shortString = "Misc: " + shortString;
                }
                shortString += index++.ToString("000");
                resourcesListSortedKeys.Add(shortString);
                resourcesDictionary.Add(shortString, r);
            }
            resourcesListSortedKeys.Sort();
        }

        void BuildGUI_Refresh(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "BuildTop");

            PlayerBuild pB = playerBuild[player.userID];

            if (pB.buildType == PlayerBuildType.None) return;

            CuiElementContainer page_container = UI.CreateElementContainer("Overlay", "BuildTop", "0.1 0.1 0.1 0.8", "0.2 0.95", "0.8 1", false);
            string text = string.Empty;

            text = string.Format("{0}", pB.buildType == PlayerBuildType.Rotate ? "Rotate: " + pB.select.ToString() : pB.buildType == PlayerBuildType.Heal ? "Heal: " + pB.select.ToString() : pB.buildType == PlayerBuildType.Grade ? string.Format("Grade: {0} - {1}", pB.select.ToString(), pB.grade.ToString()) : pB.buildType == PlayerBuildType.Spawn ? string.Format("Spawn: {0} - Height: {1}", pB.currentSpawn, pB.height.ToString()) : pB.buildType == PlayerBuildType.Build ? string.Format("Build: {0} - {1} - Height: {2}", pB.placement.ToString(), pB.constructionBuild, pB.height.ToString()) : pB.buildType == PlayerBuildType.Deploy ? string.Format("Deploy: {0} - Height: {1}", pB.currentConstruction == null ? string.Empty : pB.currentConstruction.ToString(), pB.height.ToString()) : pB.buildType == PlayerBuildType.Erase ? "Erasing" : "Error");

            UI.CreateLabel(ref page_container, "BuildTop", "1 1 1 1", text, 16, "0 0", "1 1", TextAnchor.MiddleCenter);
            CuiHelper.AddUi(player, page_container);
        }
        #endregion

        class BuildLog
        {
            public GameObject go;
            public PlayerBuildType e;
            public string svalue1;
            public float fvalue1;
            public int ivalue1;
            public Vector3 vvalue1;
            public Quaternion qvalue1;
            public BuildingGrade.Enum bvalue1;

            public BuildLog(GameObject go, PlayerBuildType e) { this.go = go; this.e = e; }
            public BuildLog(GameObject go, PlayerBuildType e, float value1) { this.go = go; this.e = e; this.fvalue1 = value1; }
            public BuildLog(GameObject go, PlayerBuildType e, int value1) { this.go = go; this.e = e; this.ivalue1 = value1; }
            public BuildLog(GameObject go, PlayerBuildType e, Vector3 value1) { this.go = go; this.e = e; this.vvalue1 = value1; }
            public BuildLog(GameObject go, PlayerBuildType e, Quaternion value1) { this.go = go; this.e = e; this.qvalue1 = value1; }
            public BuildLog(string value1, PlayerBuildType e, Vector3 value2, Quaternion value3, BuildingGrade.Enum value4 = BuildingGrade.Enum.Twigs) { this.svalue1 = value1; this.e = e; this.vvalue1 = value2; this.qvalue1 = value3; this.bvalue1 = value4; }
        }

        class PlayerBuild
        {
            public bool crosshair = false;
            public int spawnpage = 0;
            public int deploypage = 0;
            public float height = 0f;
            public float rotation = 0f;
            public float lastClick = Time.realtimeSinceStartup;
            public string currentSpawn = string.Empty;
            public object closestEnt = null;
            public Vector3 closestHitpoint = new Vector3();
            public Quaternion currentRot = new Quaternion();
            public Quaternion currentRotate = Quaternion.Euler(0f, 45f, 0f);
            public Quaternion rotate = Quaternion.Euler(0f, 0f, 0f);

            public BasePlayer player;
            public BaseNetworkable currentBaseNet = null;
            public Collider currentCollider = null;
            public Construction currentConstruction;

            public Building constructionBuild = Building.Foundation;
            public BuildingGrade.Enum grade = BuildingGrade.Enum.Twigs;
            public Selection select = Selection.Select;
            public Placement placement = Placement.Auto;
            public PlayerBuildType buildType = PlayerBuildType.None;

            public List<List<BuildLog>> logs = new List<List<BuildLog>>();

            public PlayerBuild(BasePlayer player)
            {
                this.player = player;
            }

            public void Execute()
            {
                if (!TryGetPlayerView(player, out currentRot))
                    return;

                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint))
                    return;

                if (closestEnt == null)
                    return;
                currentCollider = closestEnt as Collider;

                switch (buildType)
                {
                    case PlayerBuildType.Erase:
                        currentBaseNet = currentCollider.GetComponentInParent<BaseNetworkable>();
                        BuildingGrade.Enum currGrade = currentCollider.GetComponentInParent<BuildingBlock>() != null ? (BuildingGrade.Enum)currentCollider.GetComponentInParent<BuildingBlock>().grade : BuildingGrade.Enum.Twigs;
                        currentBaseNet?.Kill(BaseNetworkable.DestroyMode.Gib);
                        if (!currentBaseNet || !currentBaseNet.IsDestroyed) return;
                        logs.Add(new List<BuildLog>() { new BuildLog(currentBaseNet.PrefabName, PlayerBuildType.Erase, currentCollider.transform.position, currentCollider.transform.rotation, currGrade) });
                        break;
                    case PlayerBuildType.Build:
                        DoBuild(this, player, currentCollider, placement);
                        break;
                    case PlayerBuildType.Deploy:
                        DoDeploy(this, player, currentCollider);
                        break;
                    case PlayerBuildType.Spawn:
                        DoSpawn(this, player, currentCollider);
                        break;
                    case PlayerBuildType.Grade:
                        DoGrade(this, player, currentCollider);
                        break;
                    case PlayerBuildType.Heal:
                        DoHeal(this, player, currentCollider);
                        break;
                    case PlayerBuildType.Rotate:
                        DoRotation(this, player, currentCollider);
                        break;
                    case PlayerBuildType.None:
                        break;
                }
            }
        }

        class VectorQuaternion
        {
            public Vector3 vector3;
            public Quaternion quaternion;

            public VectorQuaternion(Vector3 vector3, Quaternion quaternion)
            {
                this.vector3 = vector3;
                this.quaternion = quaternion;
            }
        }

        class BuildingSocket
        {
            public SocketType sock;

            public Dictionary<SocketType, List<VectorQuaternion>> sockets = new Dictionary<SocketType, List<VectorQuaternion>>();

            public BuildingSocket(SocketType sock)
            {
                this.sock = sock;
            }

            public void AddTargetSock(SocketType s, Vector3 v, Quaternion q)
            {
                if (!sockets.ContainsKey(s))
                {
                    sockets.Add(s, new List<VectorQuaternion>());
                }
                sockets[s].Add(new VectorQuaternion(v, q));
            }
        }

        class BuildingConstruction
        {
            public string prefab;
            public BuildingSocket socket;
            public Building build;
            public BuildingConstruction(string prefab, BuildingSocket socket, Building build)
            {
                this.prefab = prefab;
                this.socket = socket;
                this.build = build;
            }
        }

        private static bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = Quaternion.identity;

            if (player.serverInput.current == null)
                return false;

            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);

            return true;
        }
        private static bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            float closestdist = 999999f;

            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            closestHitpoint = sourcePos;
            closestEnt = false;

            foreach (var hit in Physics.RaycastAll(ray, mdist, generalColl))
            {
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                {
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.GetCollider();
                        closestHitpoint = hit.point;
                    }
                }
            }

            if (closestEnt is bool)
                return false;

            return true;
        }

        static private void DoHeal(PlayerBuild buildplayer, BasePlayer player, Collider baseentity)
        {
            BaseCombatEntity ent = baseentity.GetComponentInParent<BaseCombatEntity>();
            if (ent == null)
                return;

            List<BuildLog> bl = new List<BuildLog>();
            bl.Add(new BuildLog(baseentity.gameObject, PlayerBuildType.Heal, ent.health));

            ent.health = ent.MaxHealth();

            if (buildplayer.select == Selection.All)
            {
                if (GetAllBaseEntities<BaseCombatEntity>(baseentity.GetComponentInParent<BaseEntity>()))
                {
                    foreach (BaseCombatEntity fent in houseList)
                    {
                        bl.Add(new BuildLog(fent.gameObject, PlayerBuildType.Heal, fent.health));
                        fent.health = fent.MaxHealth();
                    }
                }
            }

            buildplayer.logs.Add(bl);
        }

        static bool GetAllBaseEntities<T>(BaseEntity initialEntity)
        {
            try
            {
                houseList = new List<object>();
                checkFrom = new List<Vector3>();

                houseList.Add(initialEntity);
                checkFrom.Add(initialEntity.transform.position);

                int current = 0;


                while (true)
                {
                    current++;

                    if (current > checkFrom.Count)
                        break;

                    List<BaseEntity> list = Pool.GetList<BaseEntity>();

                    Vis.Entities<BaseEntity>(checkFrom[current - 1], 3f, list, constructionColl);

                    for (int i = 0; i < list.Count; i++)
                    {
                        BaseEntity hit = list[i];

                        var fent = hit.GetComponentInParent<T>();

                        if (fent != null && !(houseList.Contains(hit)))
                        {
                            houseList.Add(hit);
                            checkFrom.Add(hit.transform.position);
                        }
                    }
                }
                checkFrom.Clear();
                return true;
            }
            catch (Exception e)
            {
                Interface.Oxide.LogError(e.Message);
                Interface.Oxide.LogError(e.StackTrace);
                return false;
            }
        }

        private static void DoSpawn(PlayerBuild buildplayer, BasePlayer player, Collider baseentity)
        {
            newPos = buildplayer.closestHitpoint + (Vector3.up * buildplayer.height);
            newRot = buildplayer.currentRot;
            newRot.x = 0f;
            newRot.z = 0f;
            newRot = newRot * Quaternion.Euler(0, buildplayer.rotation - 180, 0);
            SpawnEntity(buildplayer, buildplayer.currentSpawn, newPos, newRot);
        }

        private static void DoBuild(PlayerBuild buildplayer, BasePlayer player, Collider baseentity, Placement placement)
        {
            uint bid = 0u;
            if (placement == Placement.Force)
            {
                newPos = buildplayer.closestHitpoint + (Vector3.up * buildplayer.height);
                newRot = buildplayer.currentRot;
                newRot.x = 0f;
                newRot.z = 0f;
            }
            else
            {
                var fbuildingblock = baseentity.GetComponentInParent<BuildingBlock>();

                if (fbuildingblock == null)
                {
                    return;
                }

                if (placement == Placement.Up)
                {
                    newPos = fbuildingblock.transform.position + (Vector3.up * buildplayer.height);
                    newRot = fbuildingblock.transform.rotation;
                }
                else
                {
                    float distance = 999999f;
                    newPos = new Vector3(0f, 0f, 0f);
                    newRot = new Quaternion(0f, 0f, 0f, 0f);
                    if (buildings.ContainsKey(fbuildingblock.blockDefinition.fullName))
                    {
                        sourcebuild = buildings[fbuildingblock.blockDefinition.fullName];
                        targetbuild = buildings[BuildingToPrefab[buildplayer.constructionBuild]];
                        if (sourcebuild.socket.sockets.ContainsKey(targetbuild.socket.sock))
                        {
                            foreach (VectorQuaternion vq in sourcebuild.socket.sockets[targetbuild.socket.sock])
                            {
                                var currentrelativepos = (fbuildingblock.transform.rotation * vq.vector3) + fbuildingblock.transform.position;
                                if (Vector3.Distance(currentrelativepos, buildplayer.closestHitpoint) < distance)
                                {
                                    distance = Vector3.Distance(currentrelativepos, buildplayer.closestHitpoint);
                                    newPos = currentrelativepos + (Vector3.up * buildplayer.height);
                                    newRot = (fbuildingblock.transform.rotation * vq.quaternion);
                                }
                            }
                        }
                    }
                    if (newPos.x == 0f)
                        return;

                }

                if (IsColliding(BuildingToPrefab[buildplayer.constructionBuild], newPos, 1f))
                    return;

                bid = fbuildingblock.buildingID;
            }

            SpawnStructure(buildplayer, BuildingToPrefab[buildplayer.constructionBuild], newPos, newRot, buildplayer.grade, 0f, bid);
        }

        private static bool IsColliding(string prefabname, Vector3 position, float radius)
        {
            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(position, radius, ents);

            foreach (BaseEntity ent in ents)
            {
                if (ent.PrefabName == prefabname && ent.transform.position == position)
                    return true;
            }
            return false;
        }

        private static GameObject SpawnPrefab(string prefabname, Vector3 pos, Quaternion angles, bool active)
        {
            GameObject prefab = GameManager.server.CreatePrefab(prefabname, pos, angles, active);

            if (prefab == null)
                return null;

            prefab.transform.position = pos;
            prefab.transform.rotation = angles;
            prefab.gameObject.SetActive(active);

            return prefab;
        }

        private static void SpawnStructure(PlayerBuild bp, string prefabname, Vector3 pos, Quaternion angles, BuildingGrade.Enum grade, float health, uint buildingID = 0)
        {
            GameObject prefab = SpawnPrefab(prefabname, pos, angles, true);

            if (prefab == null)
                return;

            BuildingBlock block = prefab.GetComponent<BuildingBlock>();

            if (block == null)
                return;

            block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);

            if (buildingID > 0)
                block.AttachToBuilding(buildingID);

            block.SetGrade(grade);
            block.OwnerID = bp.player.userID;
            block.Spawn();

            if (health <= 0f)
                block.health = block.MaxHealth();
            else
                block.health = health;

            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            bp.logs.Add(new List<BuildLog>() { new BuildLog(prefab, PlayerBuildType.Build) });
        }

        private static void SpawnEntity(PlayerBuild bp, string prefabname, Vector3 pos, Quaternion angles)
        {
            GameObject prefab = SpawnPrefab(prefabname, pos, angles, true);

            if (prefab == null)
                return;

            BaseEntity entity = prefab?.GetComponent<BaseEntity>();
            if (entity)
            {
                entity.OwnerID = bp.player.userID;
                entity.Spawn();
            }

            bp.logs.Add(new List<BuildLog>() { new BuildLog(prefab, PlayerBuildType.Spawn) });
        }

        private static void DoDeploy(PlayerBuild buildplayer, BasePlayer player, Collider baseentity)
        {
            Quaternion rotationOffSet = buildplayer.currentRot;
            rotationOffSet.x = 0f;
            rotationOffSet.z = 0f;
            rotationOffSet = rotationOffSet * new Quaternion(0f, 1f, 0f, 0f);

            GameObject go = SpawnPrefab(buildplayer.currentConstruction.fullName, buildplayer.currentConstruction.socketHandle ? Vector3.zero : (buildplayer.closestHitpoint + (Vector3.up * buildplayer.height)), buildplayer.currentConstruction.socketHandle ? Quaternion.identity : rotationOffSet, false);

            BaseEntity ent = go.ToBaseEntity();
            BaseEntity sent = baseentity.GetComponentInParent<BaseEntity>();

            if (buildplayer.currentConstruction.socketHandle)
                ent.SetParent(sent, (uint)buildplayer.currentConstruction.deployable.slot);

            if ((buildplayer.currentConstruction.deployable.setSocketParent && (sent != null)) && (ent != null))
            {
                ent.SetParent(sent, (uint)0);
                ent.transform.position = sent.transform.InverseTransformPoint(ent.transform.position);
            }

            DecayEntity entity2 = ent as DecayEntity;
            if (entity2 != null)
            {
                entity2.AttachToBuilding(sent as DecayEntity);
            }
            ent.OwnerID = player.userID;
            ent.Spawn();
            go.AwakeFromInstantiate();

            buildplayer.logs.Add(new List<BuildLog>() { new BuildLog(go, PlayerBuildType.Deploy) });
        }

        private static void DoGrade(PlayerBuild buildplayer, BasePlayer player, Collider baseentity)
        {
            var fbuildingblock = baseentity.GetComponentInParent<BuildingBlock>();

            if (fbuildingblock == null)
                return;

            List<BuildLog> bl = new List<BuildLog>();
            bl.Add(new BuildLog(baseentity.gameObject, PlayerBuildType.Grade, (int)fbuildingblock.grade));

            SetGrade(fbuildingblock, buildplayer.grade);

            if (buildplayer.select == Selection.All)
            {
                if (GetAllBaseEntities<BuildingBlock>(baseentity.GetComponentInParent<BaseEntity>()))
                {
                    foreach (BuildingBlock fent in houseList)
                    {
                        bl.Add(new BuildLog(fent.gameObject, PlayerBuildType.Grade, (int)fent.grade));
                        SetGrade(fent, buildplayer.grade);
                    }
                }
            }

            buildplayer.logs.Add(bl);
        }
        private static void SetGrade(BuildingBlock block, BuildingGrade.Enum level)
        {
            block.SetGrade(level);
            block.health = block.MaxHealth();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        private static void DoRotation(PlayerBuild buildplayer, BasePlayer player, Collider baseentity)
        {
            if (!baseentity.GetComponentInParent<BaseEntity>()) return;
            BuildingBlock buildingblock = baseentity.GetComponentInParent<BuildingBlock>();
            buildplayer.logs.Add(new List<BuildLog>() { new BuildLog(baseentity.gameObject, PlayerBuildType.Rotate, baseentity.GetComponentInParent<BaseEntity>().transform.localRotation) });

            SetRotation(baseentity.GetComponentInParent<BaseEntity>(), baseentity.GetComponentInParent<BaseEntity>().transform.localRotation * ( ( buildplayer.currentRotate != defaultQuaternion ) ?
                                                                         buildplayer.currentRotate
                                                                       : ( buildingblock != null ) ?
                                                                            ( buildingblock.blockDefinition.rotationAmount != Vector3.zero ) ?
                                                                                Quaternion.Euler(buildingblock.blockDefinition.rotationAmount)
                                                                              : buildplayer.currentRotate
                                                                          : buildplayer.currentRotate));
        }

        private static void SetRotation(BaseEntity baseentity, Quaternion rotation)
        {
            baseentity.transform.localRotation = rotation;

            BuildingBlock buildingblock = baseentity.GetComponent<BuildingBlock>();
            if (buildingblock != null && buildingblock.blockDefinition != null)
            {
                buildingblock.RefreshEntityLinks();
                buildingblock.UpdateSurroundingEntities();
                buildingblock.SendNetworkUpdateImmediate(false);
                buildingblock.ClientRPC(null, "RefreshSkin");
            }
            else
            {
                baseentity.SendNetworkUpdateImmediate(false);
                baseentity.ClientRPC(null, "RefreshSkin");
            }
        }


        [ConsoleCommand("build.select")]
        private void cmdBuildSelect(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
            {
                arg.ReplyWith("Only a player can use this command.");
                return;
            }

            if (!hasAuth(player))
            {
                arg.ReplyWith("You are not allowed to use this command.");
                return;
            }

            PlayerBuild pB = playerBuild[player.userID];

            switch (arg.Args[0])
            {
                case "build":
                    if (arg.Args.Length > 1)
                    {
                        Building targetBuilding = Building.Foundation;
                        switch (arg.Args[1])
                        {
                            case "foundation":
                                targetBuilding = Building.Foundation;
                                break;
                            case "foundation.triangle":
                                targetBuilding = Building.FoundationTriangle;
                                break;
                            case "foundation.steps":
                                targetBuilding = Building.FoundationSteps;
                                break;
                            case "floor":
                                targetBuilding = Building.Floor;
                                break;
                            case "floor.triangle":
                                targetBuilding = Building.FloorTriangle;
                                break;
                            case "floor.frame":
                                targetBuilding = Building.FloorFrame;
                                break;
                            case "wall":
                                targetBuilding = Building.Wall;
                                break;
                            case "wall.doorway":
                                targetBuilding = Building.WallDoorway;
                                break;
                            case "wall.window":
                                targetBuilding = Building.WallWindow;
                                break;
                            case "wall.frame":
                                targetBuilding = Building.WallFrame;
                                break;
                            case "wall.half":
                                targetBuilding = Building.WallHalf;
                                break;
                            case "wall.low":
                                targetBuilding = Building.WallLow;
                                break;
                            case "stairs.l.shaped":
                                targetBuilding = Building.StairsLShaped;
                                break;
                            case "stairs.u.shaped":
                                targetBuilding = Building.StairsUShaped;
                                break;
                            case "roof":
                                targetBuilding = Building.Roof;
                                break;
                            case "roof.triangle":
                                targetBuilding = Building.RoofTriangle;
                                break;
                        }
                        pB.constructionBuild = targetBuilding;
                    }
                    else
                    {
                        pB.buildType = PlayerBuildType.Build;
                    }
                    break;
                case "deploy":
                    if (arg.Args.Length > 1)
                    {
                        if (arg.Args[1] == "page")
                        {
                            if (arg.Args[2] == "previous")
                            {
                                pB.deploypage -= 1;
                                if (pB.deploypage < 0) pB.deploypage = 0;
                            }
                            else
                            {
                                pB.deploypage += 1;
                                if (pB.deploypage * 80 > deployables.Count)
                                {
                                    pB.deploypage -= 1;
                                }
                            }
                        }
                        else if (arg.Args[1] == "select")
                        {
                            pB.currentConstruction = PrefabAttribute.server.Find<Construction>(uint.Parse(arg.Args[2]));
                        }
                    }
                    else
                        pB.buildType = PlayerBuildType.Deploy;
                    break;
                case "spawn":
                    if (arg.Args.Length > 1)
                    {
                        if (arg.Args[1] == "page")
                        {
                            if (arg.Args[2] == "previous")
                            {
                                pB.spawnpage -= 1;
                                if (pB.spawnpage < 0) pB.spawnpage = 0;
                            }
                            else
                            {
                                pB.spawnpage += 1;
                                if (pB.spawnpage * 40 > resourcesList.Count)
                                {
                                    pB.spawnpage -= 1;
                                }
                            }
                        }
                        else if (arg.Args[1] == "select")
                        {
                            pB.currentSpawn = String.Join(" ", arg.Args.Skip(2));
                        }
                    }
                    else
                        pB.buildType = PlayerBuildType.Spawn;
                    break;
                case "grade":
                    if (arg.Args.Length > 1)
                    {
                        pB.grade = (BuildingGrade.Enum)int.Parse(arg.Args[1]);
                    }
                    else
                    {
                        pB.buildType = PlayerBuildType.Grade;
                    }
                    break;
                case "heal":
                    pB.buildType = PlayerBuildType.Heal;
                    break;
                case "select":
                    if (arg.Args[1] == "all")
                    {
                        pB.select = Selection.All;
                    }
                    else
                    {
                        pB.select = Selection.Select;
                    }
                    break;
                case "height":
                    if (arg.Args[1] == "reset")
                    {
                        pB.height = 0f;
                    }
                    else
                    {
                        float dif = float.Parse(arg.Args[2]);
                        if (arg.Args[1] == "plus")
                        {
                            pB.height += dif;
                        }
                        else if (arg.Args[1] == "minus")
                        {
                            pB.height -= dif;
                        }
                    }

                    break;
                case "rotation":
                    if (arg.Args[1] == "reset")
                    {
                        pB.rotation = 0f;
                    }
                    else
                    {
                        float dif = float.Parse(arg.Args[2]);
                        if (arg.Args[1] == "plus")
                        {
                            pB.rotation += dif;
                        }
                        else if (arg.Args[1] == "minus")
                        {
                            pB.rotation -= dif;
                        }
                    }

                    break;
                case "noclip":
                    pB.player.SendConsoleCommand("noclip", new object[] { });
                    break;
                case "crosshair":
                    pB.crosshair = !pB.crosshair;
                    if (pB.crosshair)
                    {
                        CuiElementContainer crosshair_container = UI.CreateElementContainer("Overlay", "BuildCrosshair", "0.1 0.1 0.1 1", "0.499 0.499", "0.501 0.501", false);
                        CuiHelper.AddUi(player, crosshair_container);
                    }
                    else
                    {
                        CuiHelper.DestroyUi(player, "BuildCrosshair");
                    }

                    break;
                case "rotate":
                    pB.buildType = PlayerBuildType.Rotate;
                    break;
                case "erase":
                    pB.buildType = PlayerBuildType.Erase;
                    break;
                case "placement":
                    pB.placement = arg.Args[1] == "force" ? Placement.Force : arg.Args[1] == "up" ? Placement.Up : Placement.Auto;
                    break;
                case "undo":
                    if (pB.logs.Count == 0)
                    {
                        return;
                    }
                    List<BuildLog> logs = pB.logs[pB.logs.Count - 1];
                    for (int i = 0; i < logs.Count; i++)
                    {
                        try
                        {
                            BuildLog log = logs[i];
                            if (log.e == PlayerBuildType.Build || log.e == PlayerBuildType.Deploy || log.e == PlayerBuildType.Spawn)
                            {
                                log.go?.GetComponentInParent<BaseNetworkable>()?.Kill(BaseNetworkable.DestroyMode.Gib);
                            }
                            else if (log.e == PlayerBuildType.Rotate)
                            {
                                if (log.go?.ToBaseEntity() != null)
                                    SetRotation(log.go?.ToBaseEntity(), log.qvalue1);
                            }
                            else if (log.e == PlayerBuildType.Grade)
                            {
                                BuildingBlock bblock = log.go?.ToBaseEntity()?.GetComponent<BuildingBlock>();
                                if (bblock != null)
                                    SetGrade(bblock, (BuildingGrade.Enum)log.ivalue1);
                            }
                            else if (log.e == PlayerBuildType.Heal)
                            {
                                BaseCombatEntity bcentity = log.go?.ToBaseEntity()?.GetComponent<BaseCombatEntity>();
                                if (bcentity != null)
                                    bcentity.health = log.fvalue1;
                            }
                            else if (log.e == PlayerBuildType.Erase)
                            {
                                GameObject prefab = SpawnPrefab(log.svalue1, log.vvalue1, log.qvalue1, true);
                                BaseEntity ent = prefab?.GetComponent<BaseEntity>();
                                ent.OwnerID = player.userID;
                                ent.Spawn();

                                BuildingBlock block = ent?.GetComponent<BuildingBlock>();
                                if (block != null)
                                {
                                    block.SetGrade(log.bvalue1);
                                }

                                BaseCombatEntity bcentity = ent?.GetComponent<BaseCombatEntity>();
                                if (bcentity != null)
                                {
                                    bcentity.health = bcentity.MaxHealth();
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Interface.Oxide.LogWarning(e.Message);
                            Interface.Oxide.LogWarning(e.StackTrace);
                        }
                    }
                    pB.logs.RemoveAt(pB.logs.Count - 1);
                    break;
                case "none":
                    pB.buildType = PlayerBuildType.None;
                    break;
            }
            BuildMenu_Toggle(player);
            BuildGUI_Refresh(player);
        }

        private T[] GetAllPrefabs<T>()
        {
            var prefabs = PrefabAttribute.server.prefabs;
            if (prefabs == null || prefabs.Any() == false)
            {
                return new T[0];
            }

            var results = new List<T>();
            foreach (var prefab in prefabs.Values)
            {
                var arrayCache = prefab.Find<T>();
                if (arrayCache == null || !arrayCache.Any())
                {
                    continue;
                }

                results.AddRange(arrayCache);
            }

            return results.ToArray();
        }
    }
}

// --- End of file: Build.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-box-placement ---
// --- Original File Path: B/BlockBoxPlacement/BlockBoxPlacement.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("BlockBoxPlacement", "wazzzup", "0.0.3", ResourceId = 2312)]
    [Description("Blocks box and oven placement under foundations")]
    public class BlockBoxPlacement : RustPlugin
    {

        private object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum iGrade)
        {
            if (DeployVolume.Check(block.transform.position, block.transform.rotation, PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID), ~(1 << block.gameObject.layer)))
            {
                return false;
            }
            return null;
        }
    }
}

// --- End of file: BlockBoxPlacement.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/build-cost ---
// --- Original File Path: B/BuildCost/BuildCost.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
	[Info("BuildCost", "Lincoln & ignignokt84", "1.0.4")]
	[Description("Calculates the cost of building a structure and its deployables")]
	class BuildCost : CovalencePlugin
	{
		const string PermCanUse = "buildcost.use";
		private static readonly int WOOD_ID = -151838493;
		private static readonly int STONE_ID = -2099697608;
		private static readonly int METAL_ID = 69511070;
		private static readonly int HQM_ID = 317398316;

		CostAggregator aggregator = new CostAggregator();
		Dictionary<uint, int> deployableLookup = new Dictionary<uint, int>();

		void Init()
		{
			permission.RegisterPermission(PermCanUse, this);
			AddCovalenceCommand("cost", "CalculateCost");
			AddCovalenceCommand("bcost", "CalculateCost");
			AddCovalenceCommand("buildcost", "CalculateCost");
		}

		void OnServerInitialized()
		{
			BuildDeployableLookups();
		}

		void BuildDeployableLookups()
		{
			foreach (var item in ItemManager.GetItemDefinitions())
			{
				var deployable = item.GetComponent<ItemModDeployable>();
				if (deployable != null)
				{
					deployableLookup[deployable.entityPrefab.resourceID] = item.itemid;
				}
			}
		}

		void CalculateCost(IPlayer player, string command, string[] args)
		{
			Puts($"Command triggered by: {player.Name}");

			if (!player.HasPermission(PermCanUse))
			{
				player.Reply("<color=#ff0000>You do not have permission to use this command.</color>");
				return;
			}

			var basePlayer = player.Object as BasePlayer;
			if (basePlayer == null)
			{
				player.Reply("<color=#ff0000>An error occurred. Could not retrieve player.</color>");
				return;
			}

			aggregator.Reset();

			// Check if an extra argument ("twig") was provided to include twig cost on top of the current grade cost.
			bool includeTwigCost = args.Any(arg => arg.ToLower() == "twig");

			if (!GetRaycastTarget(basePlayer, out var closestEntity))
			{
				player.Reply("<color=#ff0000>No building found.</color>");
				return;
			}

			if (closestEntity is BaseEntity initialBlock)
			{
				HashSet<BuildingBlock> buildingBlocks;
				HashSet<BaseEntity> deployables;

				if (GetStructure(initialBlock, out buildingBlocks, out deployables))
				{
					CalculateBuildingBlockCost(buildingBlocks, includeTwigCost);
					player.Reply("<color=#ffc34d>【Building Block Costs】</color>");
					player.Reply(aggregator.GetFormattedCost());

					aggregator.Reset();
					CalculateDeployableCost(deployables);
					player.Reply("\n<color=#ffc34d>【Deployable Costs】</color>");
					player.Reply(aggregator.GetFormattedCost());
				}
			}
		}

		bool GetRaycastTarget(BasePlayer player, out BaseEntity closestEntity)
		{
			closestEntity = null;
			RaycastHit hit;
			if (Physics.Raycast(player.eyes.HeadRay(), out hit, 100f))
			{
				closestEntity = hit.GetEntity();
				return closestEntity != null;
			}
			return false;
		}

		bool GetStructure(BaseEntity initialBlock, out HashSet<BuildingBlock> structure, out HashSet<BaseEntity> deployables)
		{
			structure = new HashSet<BuildingBlock>();
			deployables = new HashSet<BaseEntity>();
			var checkedPositions = new List<Vector3> { initialBlock.transform.position };

			if (initialBlock is BuildingBlock)
				structure.Add(initialBlock as BuildingBlock);

			int index = 0;
			while (index < checkedPositions.Count)
			{
				var entities = new List<BaseEntity>();
				Vis.Entities(checkedPositions[index], 3f, entities);

				foreach (var entity in entities)
				{
					if (entity is BuildingBlock block && !structure.Contains(block))
					{
						structure.Add(block);
						checkedPositions.Add(block.transform.position);
					}
					else if (entity != null)
					{
						deployables.Add(entity);
					}
				}
				index++;
			}
			return true;
		}

		void CalculateBuildingBlockCost(HashSet<BuildingBlock> blocks, bool includeTwigCost)
		{
			foreach (var block in blocks)
			{
				var currentGrade = block.grade;
				List<ItemAmount> costs = new List<ItemAmount>();

				// Optionally add the basic twig cost.
				if (includeTwigCost)
				{
					var twigItem = ItemManager.FindItemDefinition(WOOD_ID);
					if (twigItem != null)
						costs.Add(new ItemAmount(twigItem, 50));
				}

				// Then add the cost for the actual grade of the block.
				switch (currentGrade)
				{
					case BuildingGrade.Enum.Twigs:
						if (!includeTwigCost)
						{
							var twigItem = ItemManager.FindItemDefinition(WOOD_ID);
							if (twigItem != null)
								costs.Add(new ItemAmount(twigItem, 50));
						}
						break;

					case BuildingGrade.Enum.Wood:
						{
							var woodItem = ItemManager.FindItemDefinition(WOOD_ID);
							if (woodItem != null)
								costs.Add(new ItemAmount(woodItem, 200));
						}
						break;

					case BuildingGrade.Enum.Stone:
						{
							var stoneItem = ItemManager.FindItemDefinition(STONE_ID);
							if (stoneItem != null)
								costs.Add(new ItemAmount(stoneItem, 300));
						}
						break;

					case BuildingGrade.Enum.Metal:
						{
							var metalItem = ItemManager.FindItemDefinition(METAL_ID);
							if (metalItem != null)
								costs.Add(new ItemAmount(metalItem, 200));
						}
						break;

					case BuildingGrade.Enum.TopTier:
						{
							var hqmItem = ItemManager.FindItemDefinition(HQM_ID);
							if (hqmItem != null)
								costs.Add(new ItemAmount(hqmItem, 25));
						}
						break;

					default:
						continue;
				}

				aggregator.AddCosts(costs);
			}
		}

		void CalculateDeployableCost(HashSet<BaseEntity> deployables)
		{
			foreach (var deployable in deployables)
			{
				if (!deployableLookup.TryGetValue(deployable.prefabID, out int itemId))
					continue;

				var blueprint = ItemManager.FindItemDefinition(itemId)?.Blueprint;
				if (blueprint != null)
				{
					aggregator.AddCosts(blueprint.ingredients);
				}
			}
		}

		class CostAggregator
		{
			public Dictionary<int, float> materialCosts = new Dictionary<int, float>
			{
				{ WOOD_ID, 0 },
				{ STONE_ID, 0 },
				{ METAL_ID, 0 },
				{ HQM_ID, 0 }
			};

			public void Reset()
			{
				materialCosts[WOOD_ID] = 0;
				materialCosts[STONE_ID] = 0;
				materialCosts[METAL_ID] = 0;
				materialCosts[HQM_ID] = 0;
			}

			public void AddCosts(List<ItemAmount> costs)
			{
				foreach (var cost in costs)
				{
					if (materialCosts.ContainsKey(cost.itemid))
					{
						materialCosts[cost.itemid] += cost.amount;
					}
				}
			}

			public string GetFormattedCost()
			{
				var formattedCost = new List<string>();

				if (materialCosts[WOOD_ID] > 0)
					formattedCost.Add($"<color=#cd9575>Wood:</color> <color=#ffffff>{materialCosts[WOOD_ID]:N0}</color>");
				if (materialCosts[STONE_ID] > 0)
					formattedCost.Add($"<color=#808080>Stone:</color> <color=#ffffff>{materialCosts[STONE_ID]:N0}</color>");
				if (materialCosts[METAL_ID] > 0)
					formattedCost.Add($"<color=#a9a9a9>Metal Fragments:</color> <color=#ffffff>{materialCosts[METAL_ID]:N0}</color>");
				if (materialCosts[HQM_ID] > 0)
					formattedCost.Add($"<color=#4682b4>High Quality Metal:</color> <color=#ffffff>{materialCosts[HQM_ID]:N0}</color>");

				return string.Join("\n", formattedCost);
			}

			public bool IsEmpty() => materialCosts.Values.All(v => v == 0);
		}
	}
}


// --- End of file: BuildCost.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-elevators ---
// --- Original File Path: B/BetterElevators/BetterElevators.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Elevators", "WhiteThunder", "1.2.11")]
    [Description("Allows elevators to be taller, faster, powerless, and more.")]
    internal class BetterElevators : CovalencePlugin
    {
        #region Fields

        private const string PermissionPowerless = "betterelevators.powerless";
        private const string PermissionLiftCounter = "betterelevators.liftcounter";

        private const string PermissionMaxFloorsPrefix = "betterelevators.maxfloors";
        private const string PermissionSpeedPrefix = "betterelevators.speed";

        private const string PrefabElevator = "assets/prefabs/deployable/elevator/elevator.prefab";
        private const string PrefabPowerCounter = "assets/prefabs/deployable/playerioents/counter/counter.prefab";

        private const int VanillaMaxFloors = 6;
        private const float ElevatorHeight = 3;
        private const float ElevatorLiftLocalOffsetY = 1;
        private const float MaxCounterUpdateFrequency = 0.4f;

        private static readonly PropertyInfo ElevatorLiftOwnerProperty = typeof(ElevatorLift).GetProperty("owner", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

        private readonly object False = false;

        private readonly Vector3 LiftCounterPosition = new(-1.18f, -0.16f, -0.1f);
        private readonly Quaternion LiftCounterRotation = Quaternion.Euler(0, 90, 0);

        private readonly Vector3 StaticLiftCounterPosition = new(1.183f, -0.09f, -0.92f);
        private readonly Quaternion StaticLiftCounterRotation = Quaternion.Euler(0, -90, 0);

        private readonly Dictionary<NetworkableId, Action> _liftTimerActions = new();
        private ProtectionProperties _immortalProtection;
        private Configuration _config;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionPowerless, this);
            permission.RegisterPermission(PermissionLiftCounter, this);

            foreach (var maxFloorsAmount in _config.MaxFloorsRequiringPermission)
            {
                permission.RegisterPermission(GetMaxFloorsPermission(maxFloorsAmount), this);
            }

            foreach (var speedConfig in _config.SpeedsRequiringPermission)
            {
                if (!string.IsNullOrWhiteSpace(speedConfig.Name))
                {
                    permission.RegisterPermission(GetSpeedPermission(speedConfig.Name), this);
                }
            }

            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "BetterElevatorsCounterProtection";
            _immortalProtection.Add(1);

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var elevator = entity as Elevator;
                if (elevator != null)
                {
                    OnEntitySpawned(elevator);
                    continue;
                }

                var elevatorIoEntity = entity as ElevatorIOEntity;
                if (elevatorIoEntity != null)
                {
                    OnEntitySpawned(elevatorIoEntity);
                    continue;
                }

                var lift = entity as ElevatorLift;
                if (lift != null)
                {
                    OnEntitySpawned(lift);

                    if (lift is ElevatorLiftStatic)
                    {
                        var ownerElevator = GetOwnerElevator(lift);
                        if (ownerElevator != null)
                        {
                            // Fix issue caused by previous version where elevators could not move.
                            if (ownerElevator.IsBusy())
                            {
                                lift.SetFlag(BaseEntity.Flags.Reserved3, true);
                                lift.SetFlag(BaseEntity.Flags.Reserved4, true);
                            }
                            else
                            {
                                lift.NotifyNewFloor(ownerElevator.LiftPositionToFloor(), ownerElevator.Floor);
                            }
                        }
                    }

                    continue;
                }
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(_immortalProtection);

            var liftCounters = new List<PowerCounter>();

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var lift = entity as ElevatorLift;
                if (lift != null)
                {
                    if (lift is not ElevatorLiftStatic)
                    {
                        CustomParentTrigger.RemoveFromLift(lift);
                    }

                    continue;
                }

                var counter = entity as PowerCounter;
                if (counter != null)
                {
                    if (IsLiftCounter(counter))
                    {
                        liftCounters.Add(counter);
                    }

                    continue;
                }
            }

            foreach (var counter in liftCounters)
            {
                counter.Kill();
            }
        }

        private void OnEntitySpawned(Elevator elevator)
        {
            // This is required to allow placement to succeed above 6 floors
            // Note: This doesn't contribute to the placement guides appearing client-side
            var elevatorSockets = elevator.GetEntityLinks().Select(link => link.socket).OfType<ConstructionSocket_Elevator>();
            foreach (var socket in elevatorSockets)
            {
                socket.MaxFloor = 999;
            }
        }

        private void OnEntitySpawned(ElevatorLift lift)
        {
            var topElevator = GetOwnerElevator(lift);
            if (topElevator == null)
                return;

            if (lift is not ElevatorLiftStatic)
            {
                CustomParentTrigger.AddToLift(lift);
            }

            // Add a counter to the lift when it spawns
            // Check for an existing counter since this is also called when loading a save
            if (AllowLiftCounter(lift, topElevator) && GetLiftCounter(lift) == null)
            {
                AddLiftCounter(lift, topElevator.LiftPositionToFloor() + 1, topElevator.OwnerID, startPowered: ElevatorHasPower(topElevator));
            }
        }

        private void OnEntitySpawned(ElevatorIOEntity ioEntity)
        {
            var topElevator = ioEntity.GetParentEntity() as Elevator;
            if (topElevator == null)
                return;

            if (IsPowerlessElevator(topElevator))
            {
                ioEntity.SetFlag(IOEntity.Flag_HasPower, true);
            }

            MaybeToggleLiftCounter(topElevator);
        }

        private object CanBuild(Planner planner, Construction construction, Construction.Target target)
        {
            if (planner == null || construction == null)
                return null;

            var elevatorBelow = target.entity as Elevator;
            if (elevatorBelow == null)
                return null;

            if (construction.deployable?.fullName != PrefabElevator)
                return null;

            var deployingPlayer = planner.GetOwnerPlayer();
            if (deployingPlayer == null)
                return null;

            var maxFloors = GetPlayerMaxFloors(deployingPlayer.UserIDString);
            if (elevatorBelow.Floor + 1 >= maxFloors)
            {
                ChatMessage(deployingPlayer, Lang.NoPermissionToFloor, maxFloors);
                return False;
            }

            return null;
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();
            if (entity == null)
                return;

            var topElevator = entity as Elevator;
            if (topElevator == null)
                return;

            var elevatorBelow = topElevator.GetElevatorInDirection(Elevator.Direction.Down);
            if (elevatorBelow == null)
                return;

            if (_config.EnsureConsistentOwner && elevatorBelow.OwnerID != 0)
            {
                topElevator.OwnerID = elevatorBelow.OwnerID;
            }

            if (!_config.MaintainLiftPositionWhenHeightChanges
                || !elevatorBelow.liftEntity.TryGet(true, out var lift)
                || lift == null)
                return;

            var didStopMovement = TryStopLiftMovement(lift, elevatorBelow, out var targetFloor);

            lift.SetParent(topElevator, worldPositionStays: true, sendImmediate: true);
            lift.SetOwnerElevator(topElevator);
            topElevator.liftEntity.Set(lift);
            elevatorBelow.liftEntity.Set(null);
            topElevator.ClearBusy();

            if (didStopMovement)
            {
                NextTick(() =>
                {
                    if (topElevator == null)
                        return;

                    topElevator.RequestMoveLiftTo(targetFloor, out _, topElevator);
                });
            }
        }

        private void OnEntityKill(Elevator elevator)
        {
            if (!_config.MaintainLiftPositionWhenHeightChanges || elevator == null || elevator.Floor == 0)
                return;

            var elevatorBelow = elevator.GetElevatorInDirection(Elevator.Direction.Down);
            if (elevatorBelow == null)
                return;

            var topElevator = GetTopElevator(elevator);
            if (!topElevator.liftEntity.TryGet(true, out var lift))
                return;

            // One reason for the lift being null is that another OnEntityKill call removed it from the top elevator
            if (lift == null)
                return;

            var liftFloor = topElevator.LiftPositionToFloor();

            // If the lift is above the next top elevator, allow it to be destroyed and recreated like normal
            if (liftFloor > elevatorBelow.Floor)
                return;

            var didStopMovement = TryStopLiftMovement(lift, topElevator, out var targetFloor);

            lift.SetParent(elevatorBelow, worldPositionStays: true, sendImmediate: true);
            elevatorBelow.liftEntity.Set(lift);
            topElevator.liftEntity.Set(null);
            topElevator.ClearBusy();

            if (didStopMovement)
            {
                CancelHorseDropToGround(lift);
                elevatorBelow.RequestMoveLiftTo(Math.Min(targetFloor, elevatorBelow.Floor), out _, elevator);
            }
        }

        private void OnEntityKill(ElevatorLift lift)
        {
            _liftTimerActions.Remove(lift.net.ID);
        }

        private object OnElevatorMove(Elevator topElevator, int targetFloor)
        {
            if (!topElevator.liftEntity.TryGet(true, out var lift)
                || lift == null)
                return null;

            var liftFloor = topElevator.LiftPositionToFloor();
            if (targetFloor == liftFloor)
                return null;

            if (!CanElevatorMoveToFloor(topElevator, targetFloor))
                return null;

            var worldSpaceFloorPosition = topElevator.GetWorldSpaceFloorPosition(targetFloor);
            var distance = Mathf.Abs(lift.transform.position.y - worldSpaceFloorPosition.y);
            var timeToTravel = distance / topElevator.LiftSpeedPerMetre;

            if (!TryGetSpeedConfig(topElevator, out var speedConfig))
            {
                if (GetLiftCounter(lift) != null && timeToTravel > 0)
                    StartUpdatingLiftCounter(lift, timeToTravel);

                return null;
            }

            // Custom movement starts here.
            topElevator.OnMoveBegin();

            LeanTweenType leanTweenType;
            switch (speedConfig.EaseType)
            {
                case EaseType.Quadratic:
                    timeToTravel = Convert.ToSingle(Math.Sqrt(distance)) / speedConfig.BaseSpeed;
                    leanTweenType = LeanTweenType.easeInOutQuad;
                    break;

                case EaseType.Cubic:
                    timeToTravel = Convert.ToSingle(Math.Pow(distance, 1.0 / 3.0)) / speedConfig.BaseSpeed;
                    leanTweenType = LeanTweenType.easeInOutCubic;
                    break;

                default:
                    timeToTravel = distance / speedConfig.GetSpeedForLevels(Math.Abs(targetFloor - liftFloor));
                    leanTweenType = LeanTweenType.linear;
                    break;
            }

            LeanTween.moveY(lift.gameObject, worldSpaceFloorPosition.y, timeToTravel).setEase(leanTweenType);

            // Duplicating vanilla logic since this is replacing default movement
            topElevator.SetFlag(BaseEntity.Flags.Busy, true);
            if (targetFloor < topElevator.Floor)
            {
                lift.ToggleHurtTrigger(true);
            }

            lift.SetFlag(BaseEntity.Flags.Busy, true);
            topElevator.Invoke(topElevator.ClearBusy, timeToTravel);
            lift.NotifyNewFloor(targetFloor, topElevator.Floor);

            if (topElevator.ioEntity != null)
            {
                topElevator.ioEntity.SetFlag(BaseEntity.Flags.Busy, true);
                topElevator.ioEntity.SendChangedToRoot(forceUpdate: true);
            }

            if (GetLiftCounter(lift) != null && timeToTravel > 0)
            {
                StartUpdatingLiftCounter(lift, timeToTravel);
            }

            return False;
        }

        private void OnEntitySaved(Elevator elevator, BaseNetworkable.SaveInfo info)
        {
            // This is where the magic happens... thanks to @JakeRich
            if (!info.forDisk)
            {
                info.msg.elevator.floor = 1;
            }
        }

        private object OnCounterTargetChange(PowerCounter counter, BasePlayer player, int amount)
        {
            var lift = counter.GetParentEntity() as ElevatorLift;
            if (lift == null)
                return null;

            var topElevator = GetOwnerElevator(lift);
            if (topElevator == null)
                return null;

            // After this point, we return false to disable the default action since we know the counter is attached to an elevator
            if (topElevator.IsBusy())
                return False;

            if (!ElevatorHasPower(topElevator))
                return False;

            // The lift is parented to the top elevator so elevator.Floor is always the top floor
            var targetFloor = Math.Min(Math.Max(0, amount - 1), topElevator.Floor);
            if (player.IsBuildingBlocked() || FloorSelectionWasBlocked(lift, player, targetFloor))
                return False;

            topElevator.RequestMoveLiftTo(targetFloor, out _, topElevator);

            return False;
        }

        private object OnCounterModeToggle(PowerCounter counter, BasePlayer player, bool doShowPassthrough)
        {
            // Prevent lift counter from being toggled to "show passthrough" mode
            if (doShowPassthrough && IsLiftCounter(counter))
                return False;

            return null;
        }

        private void OnInputUpdate(ElevatorIOEntity ioEntity, int inputAmount)
        {
            if (ioEntity == null)
                return;

            var topElevator = ioEntity.GetParentEntity() as Elevator;
            if (topElevator != null)
            {
                var ioEntity2 = ioEntity;
                if (!topElevator.liftEntity.TryGet(true, out var lift))
                    return;

                var isPowerless = IsPowerlessElevator(topElevator);

                NextTick(() =>
                {
                    if (isPowerless)
                    {
                        // Allow electricity to function normally when there is a wire plugged in
                        // For example, so trap base designs can prevent players from using the buttons
                        // When no wire is connected, force power to be on
                        if (ioEntity2.inputs[0].connectedTo.Get() == null)
                        {
                            ioEntity2.SetFlag(IOEntity.Flag_HasPower, true);
                        }
                    }

                    if (lift != null)
                    {
                        // Get the elevator again since the lift could have changed parent
                        var nextTopElevator = GetOwnerElevator(lift);
                        if (nextTopElevator == null)
                            return;

                        // Update the power state of the lift counter to match elevator power state
                        MaybeToggleLiftCounter(nextTopElevator);
                    }
                });
            }
        }

        #endregion

        #region Helper Methods

        public static void LogDebug(string message) => Interface.Oxide.LogDebug($"[Better Elevators] {message}");
        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Better Elevators] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Better Elevators] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Better Elevators] {message}");

        private bool FloorSelectionWasBlocked(ElevatorLift lift, BasePlayer player, int targetFloor)
        {
            return Interface.CallHook("OnElevatorFloorSelect", lift, player, targetFloor) is false;
        }

        private string GetSpeedPermission(string permissionName) => $"{PermissionSpeedPrefix}.{permissionName}";

        private string GetMaxFloorsPermission(int maxFloors) => $"{PermissionMaxFloorsPrefix}.{maxFloors}";

        private static Elevator GetOwnerElevator(ElevatorLift lift)
        {
            return ElevatorLiftOwnerProperty?.GetValue(lift) as Elevator;
        }

        private void CancelHorseDropToGround(ElevatorLift lift)
        {
            foreach (var child in lift.children)
            {
                var horse = child as RidableHorse;
                if (horse != null)
                {
                    horse.Invoke(() => horse.CancelInvoke(horse.DelayedDropToGround), 0);
                }
            }
        }

        private bool CanElevatorMoveToFloor(Elevator topElevator, int targetFloor)
        {
            // Duplicating vanilla logic.
            if (topElevator.IsBusy())
                return false;

            if (!topElevator.IsStatic && topElevator.ioEntity != null && !topElevator.ioEntity.IsPowered())
                return false;

            if (!topElevator.IsValidFloor(targetFloor))
                return false;

            if (!topElevator.liftEntity.TryGet(true, out var topElevatorLiftEntity)
                || !topElevatorLiftEntity.CanMove())
                return false;

            if (topElevator.LiftPositionToFloor() == targetFloor)
            {
                (topElevator as ElevatorStatic)?.OnLiftArrivedAtFloor();
                return false;
            }

            return true;
        }

        private bool TryStopLiftMovement(ElevatorLift lift, Elevator topElevator, out int targetFloor)
        {
            var tweens = LeanTween.descriptions(lift.gameObject);
            targetFloor = 0;

            if (tweens.Length == 0)
                return false;

            // we only expect one tween to be running for each elevator at a time
            var tween = tweens[0];
            var originalY = tween.to.x;

            var totalElevatorHeight = ElevatorHeight * (topElevator.Floor + 1);
            var bottomElevatorLiftPosition = topElevator.transform.position.y - totalElevatorHeight + ElevatorLiftLocalOffsetY;
            var localHeight = originalY - bottomElevatorLiftPosition;

            targetFloor = (int)(localHeight / ElevatorHeight) - 1;

            LeanTween.cancel(tween.uniqueId);
            return true;
        }

        private bool AllowLiftCounter(ElevatorLift lift, Elevator topElevator)
        {
            if (topElevator.IsStatic)
                return _config.StaticElevators.EnableLiftCounter
                    && !lift.ShortPrefabName.Contains("elevator_office_lift.static");

            var ownerId = topElevator.OwnerID;
            return !_config.RequirePermissionForLiftCounter
                || ownerId != 0 && permission.UserHasPermission(ownerId.ToString(), PermissionLiftCounter);
        }

        private bool AllowPowerless(Elevator topElevator)
        {
            if (topElevator.IsStatic)
                return false;

            var ownerId = topElevator.OwnerID;
            return !_config.RequirePermissionForPowerless
                || ownerId != 0 && permission.UserHasPermission(ownerId.ToString(), PermissionPowerless);
        }

        private Elevator GetTopElevator(Elevator elevator)
        {
            return GetFarthestElevatorInDirection(elevator, Elevator.Direction.Up);
        }

        private bool IsPowerlessElevator(Elevator elevator)
        {
            return AllowPowerless(elevator);
        }

        private bool IsLiftCounter(PowerCounter counter)
        {
            return counter.GetParentEntity() is ElevatorLift;
        }

        private bool ElevatorHasPower(Elevator topElevator)
        {
            return topElevator.IsStatic || topElevator.ioEntity != null && topElevator.ioEntity.IsPowered();
        }

        private void RemoveGroundWatch(BaseEntity entity)
        {
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
        }

        private void HideInputsAndOutputs(IOEntity ioEntity)
        {
            // Trick to hide the inputs and outputs on the client
            foreach (var input in ioEntity.inputs)
            {
                input.type = IOEntity.IOType.Generic;
            }

            foreach (var output in ioEntity.outputs)
            {
                output.type = IOEntity.IOType.Generic;
            }
        }

        private void AddLiftCounter(ElevatorLift lift, int currentDisplayFloor, ulong ownerId, bool startPowered = false)
        {
            var position = LiftCounterPosition;
            var rotation = LiftCounterRotation;

            if (lift is ElevatorLiftStatic)
            {
                position = StaticLiftCounterPosition;
                rotation = StaticLiftCounterRotation;
            }

            var counter = GameManager.server.CreateEntity(PrefabPowerCounter, position, rotation) as PowerCounter;
            if (counter == null)
                return;

            RemoveGroundWatch(counter);
            HideInputsAndOutputs(counter);

            counter.pickup.enabled = false;
            counter.baseProtection = _immortalProtection;
            counter.OwnerID = ownerId;
            counter.SetParent(lift);
            counter.Spawn();

            if (startPowered)
            {
                InitializeCounter(counter, currentDisplayFloor);
            }
        }

        private PowerCounter GetLiftCounter(ElevatorLift lift)
        {
            foreach (var child in lift.children)
            {
                var counter = child as PowerCounter;
                if (counter != null)
                    return counter;
            }

            return null;
        }

        private void UpdateFloorCounter(ElevatorLift lift, PowerCounter counter)
        {
            // Get the elevator on every update, since the lift can be re-parented
            var topElevator = GetOwnerElevator(lift);
            if (topElevator == null || counter == null)
                return;

            var floor = topElevator.LiftPositionToFloor() + 1;

            if (counter.counterNumber == floor)
                return;

            counter.counterNumber = floor;
            counter.targetCounterNumber = floor;
            counter.SendNetworkUpdate();
        }

        private void StartUpdatingLiftCounter(ElevatorLift lift, float timeToTravel)
        {
            var liftCounter = GetLiftCounter(lift);
            if (liftCounter == null)
                return;

            if (_liftTimerActions.TryGetValue(lift.net.ID, out var existingTimerAction))
            {
                lift.CancelInvoke(existingTimerAction);
            }

            var lastCounterUpdateTime = Time.time;
            Action timerAction = null;
            var stepsRemaining = timeToTravel / MaxCounterUpdateFrequency;
            timerAction = () =>
            {
                stepsRemaining--;

                var reachedEnd = stepsRemaining <= 0;
                if (reachedEnd || Time.time >= lastCounterUpdateTime + MaxCounterUpdateFrequency)
                {
                    UpdateFloorCounter(lift, liftCounter);
                    lastCounterUpdateTime = Time.time;
                }

                if (reachedEnd)
                {
                    lift.CancelInvoke(timerAction);
                    _liftTimerActions.Remove(lift.net.ID);
                }
            };
            lift.InvokeRepeating(timerAction, MaxCounterUpdateFrequency, MaxCounterUpdateFrequency);
            _liftTimerActions[lift.net.ID] = timerAction;
        }

        private Elevator GetFarthestElevatorInDirection(Elevator elevator, Elevator.Direction direction)
        {
            var currentElevator = elevator;

            Elevator nextElevator;
            while ((nextElevator = currentElevator.GetElevatorInDirection(direction)) != null)
            {
                currentElevator = nextElevator;
            }

            return currentElevator;
        }

        private void InitializeCounter(PowerCounter counter, int floor)
        {
            counter.SetFlag(IOEntity.Flag_HasPower, true);
            counter.SetFlag(BaseEntity.Flags.Busy, false);
            counter.counterNumber = floor;
            counter.targetCounterNumber = floor;
            counter.SendNetworkUpdate();
        }

        private void ResetCounter(PowerCounter counter)
        {
            counter.SetFlag(IOEntity.Flag_HasPower, false);
            counter.SetFlag(BaseEntity.Flags.Busy, true);
            counter.counterNumber = 0;
            counter.targetCounterNumber = 0;
            counter.SendNetworkUpdate();
        }

        private void MaybeToggleLiftCounter(Elevator topElevator)
        {
            if (!topElevator.liftEntity.TryGet(true, out var lift)
                || lift == null)
                return;

            var liftCounter = GetLiftCounter(lift);
            if (liftCounter == null)
                return;

            if (ElevatorHasPower(topElevator))
            {
                InitializeCounter(liftCounter, topElevator.LiftPositionToFloor() + 1);
            }
            else
            {
                ResetCounter(liftCounter);
            }
        }

        #endregion

        #region Custom Parent Trigger

        private class CustomParentTrigger : TriggerParentElevator
        {
            public static void AddToLift(ElevatorLift lift)
            {
                var originalTrigger = GetChildComponent<TriggerParentElevator>(lift);
                if (originalTrigger == null)
                    return;

                var customTrigger = originalTrigger.gameObject.AddComponent<CustomParentTrigger>();
                customTrigger._original = originalTrigger;

                customTrigger.contents = originalTrigger.contents?.ToHashSet();
                customTrigger.entityContents = originalTrigger.entityContents?.ToHashSet();

                // TriggerBase fields.
                customTrigger.interestLayers = originalTrigger.interestLayers;

                // TriggerParent fields.
                customTrigger.associatedMountable = originalTrigger.associatedMountable;
                customTrigger.parentMountedPlayers = originalTrigger.parentMountedPlayers;
                customTrigger.ParentNPCPlayers = originalTrigger.ParentNPCPlayers;
                customTrigger.overrideOtherTriggers = originalTrigger.overrideOtherTriggers;

                // TriggerParentEnclosed fields.
                customTrigger.Padding = originalTrigger.Padding;
                customTrigger.intersectionMode = originalTrigger.intersectionMode;
                customTrigger.CheckBoundsOnUnparent = originalTrigger.CheckBoundsOnUnparent;

                if (customTrigger.entityContents != null)
                {
                    foreach (var entity in customTrigger.entityContents)
                    {
                        if (entity == null)
                            continue;

                        customTrigger.OnEntityEnter(entity);
                    }
                }

                originalTrigger.enabled = false;
            }

            public static void RemoveFromLift(ElevatorLift lift)
            {
                var customTrigger = GetChildComponent<CustomParentTrigger>(lift);
                if (customTrigger == null)
                    return;

                var originalTrigger = customTrigger._original;
                originalTrigger.enabled = true;

                originalTrigger.contents = customTrigger.contents?.ToHashSet();
                originalTrigger.entityContents = customTrigger.entityContents?.ToHashSet();

                if (originalTrigger.entityContents != null)
                {
                    foreach (var entity in originalTrigger.entityContents)
                    {
                        if (entity == null)
                            continue;

                        originalTrigger.OnEntityEnter(entity);
                    }
                }

                DestroyImmediate(customTrigger);
            }

            private static T GetChildComponent<T>(UnityEngine.Component component) where T : UnityEngine.Component
            {
                foreach (Transform child in component.transform)
                {
                    var childComponent = child.GetComponent<T>();
                    if (childComponent != null && childComponent.GetType() == typeof(T))
                        return childComponent;
                }

                return null;
            }

            // Remove the Deployed layer from the clip mask to avoid issues with clipping through the elavator at high speed.
            private const int ClipMask = CLIP_CHECK_MASK & ~Rust.Layers.Mask.Deployed;

            private TriggerParentEnclosed _original;

            #if OXIDE_PUBLICIZED
            public override bool IsClipping(BaseEntity ent)
            #else
            protected override bool IsClipping(BaseEntity ent)
            #endif
            {
                if (AllowHorsesToBypassClippingChecks && ent is BaseRidableAnimal)
                    return false;

                return GamePhysics.CheckOBB(ent.WorldSpaceBounds(), ClipMask, QueryTriggerInteraction.Ignore);
            }
        }

        #endregion

        #region Configuration

        private int GetPlayerMaxFloors(string userIdString)
        {
            if (_config.MaxFloorsRequiringPermission == null || _config.MaxFloorsRequiringPermission.Length == 0)
                return _config.DefaultMaxFloors;

            for (var i = _config.MaxFloorsRequiringPermission.Length - 1; i >= 0; i--)
            {
                var floorAmount = _config.MaxFloorsRequiringPermission[i];
                if (permission.UserHasPermission(userIdString, GetMaxFloorsPermission(floorAmount)))
                    return floorAmount;
            }

            return _config.DefaultMaxFloors;
        }

        private SpeedConfig GetPlayerSpeedConfig(ulong ownerId)
        {
            if (ownerId == 0 || _config.SpeedsRequiringPermission == null || _config.SpeedsRequiringPermission.Length == 0)
                return _config.DefaultSpeed;

            var userIdString = ownerId.ToString();

            for (var i = _config.SpeedsRequiringPermission.Length - 1; i >= 0; i--)
            {
                var speedConfig = _config.SpeedsRequiringPermission[i];
                if (!string.IsNullOrWhiteSpace(speedConfig.Name) &&
                    permission.UserHasPermission(userIdString, GetSpeedPermission(speedConfig.Name)))
                {
                    return speedConfig;
                }
            }

            return _config.DefaultSpeed;
        }

        private bool TryGetSpeedConfig(Elevator topElevator, out SpeedConfig speedConfig)
        {
            if (topElevator is ElevatorStatic)
            {
                if (_config.StaticElevators.EnableCustomSpeed)
                {
                    speedConfig = _config.StaticElevators.Speed;
                    return true;
                }
            }
            else if (_config.EnableSpeedOptions)
            {
                speedConfig = GetPlayerSpeedConfig(topElevator.OwnerID);
                return true;
            }

            speedConfig = null;
            return false;
        }

        // Don't rename these since they are used in the config.
        private enum EaseType { Linear, Quadratic, Cubic }

        private class SpeedConfig
        {
            [JsonProperty("Name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Name;

            [JsonProperty("BaseSpeed")]
            public float BaseSpeed = 1.5f;

            [JsonProperty("SpeedIncreasePerFloor", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float SpeedPerAdditionalFloor = 0;

            [JsonProperty("MaxSpeed", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(1.5f)]
            public float MaxSpeed = 1.5f;

            [JsonProperty("EaseType")]
            [JsonConverter(typeof(StringEnumConverter))]
            public EaseType EaseType = EaseType.Linear;

            public float GetSpeedForLevels(int levels)
            {
                return Math.Min(Math.Max(BaseSpeed, MaxSpeed), BaseSpeed + (levels - 1) * SpeedPerAdditionalFloor);
            }
        }

        private class StaticElevatorConfig
        {
            [JsonProperty("EnableCustomSpeed")]
            public bool EnableCustomSpeed = false;

            [JsonProperty("Speed")]
            public SpeedConfig Speed = new()
            {
                BaseSpeed = 3.5f,
            };

            [JsonProperty("EnableLiftCounter")]
            public bool EnableLiftCounter = false;
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("DefaultMaxFloors")]
            public int DefaultMaxFloors = VanillaMaxFloors;

            [JsonProperty("MaxFloorsRequiringPermission")]
            public int[] MaxFloorsRequiringPermission = { 10, 15, 20, 100 };

            [JsonProperty("RequirePermissionForPowerless")]
            public bool RequirePermissionForPowerless = true;

            [JsonProperty("RequirePermissionForLiftCounter")]
            public bool RequirePermissionForLiftCounter = true;

            [JsonProperty("MaintainLiftPositionWhenHeightChanges")]
            public bool MaintainLiftPositionWhenHeightChanges = false;

            [JsonProperty("EnsureConsistentOwner")]
            public bool EnsureConsistentOwner = true;

            [JsonProperty("EnableSpeedOptions")]
            public bool EnableSpeedOptions = true;

            [JsonProperty("DefaultSpeed")]
            public SpeedConfig DefaultSpeed = new()
            {
                BaseSpeed = 1.5f,
            };

            [JsonProperty("SpeedsRequiringPermission")]
            public SpeedConfig[] SpeedsRequiringPermission =
            {
                new()
                {
                    Name = "2x",
                    BaseSpeed = 3f,
                },
                new()
                {
                    Name = "4x",
                    BaseSpeed = 6,
                },
                new()
                {
                    Name = "1x.quadratic",
                    BaseSpeed = 0.86f,
                    EaseType = EaseType.Quadratic,
                },
                new()
                {
                    Name = "1.5x.quadratic",
                    BaseSpeed = 1.29f,
                    EaseType = EaseType.Quadratic,
                },
                new()
                {
                    Name = "2x.quadratic",
                    BaseSpeed = 1.72f,
                    EaseType = EaseType.Quadratic,
                },
                new()
                {
                    Name = "1x.cubic",
                    BaseSpeed = 0.72f,
                    EaseType = EaseType.Cubic,
                },
                new()
                {
                    Name = "2x.cubic",
                    BaseSpeed = 1.44f,
                    EaseType = EaseType.Cubic,
                },
            };

            [JsonProperty("StaticElevators")]
            public StaticElevatorConfig StaticElevators = new();
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private void ChatMessage(BasePlayer player, string messageName, params object[] args)
        {
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));
        }

        private static class Lang
        {
            public const string NoPermissionToFloor = "Deploy.Error.NoPermissionToFloor";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.NoPermissionToFloor] = "Error: You don't have permission to build elevators taller than {0} floors.",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.NoPermissionToFloor] = "Erro: você não tem permissão para construir elevadores com mais de {0} andares.",
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: BetterElevators.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backpack-swap ---
// --- Original File Path: B/BackpackSwap/BackpackSwap.cs ---

namespace Oxide.Plugins
{
    [Info("BackpackSwap", "Whispers88", "1.0.1")]
    [Description("Allows you to swap your backpacks without moving items manually")]
    public class BackpackSwap : CovalencePlugin
    {
        #region Hooks

        private object CanWearItem(PlayerInventory inventory, Item targetItem, int slot)
        {
            if (inventory == null || targetItem == null || !targetItem.IsBackpack() || slot != ItemContainer.BackpackSlotIndex) return null;
            Item currentitem = inventory.containerWear.GetSlot(slot);
            if (currentitem == null || !currentitem.IsBackpack()) return null;
            if (currentitem.contents.itemList.Count < 1 || currentitem.contents.itemList.Count > targetItem.contents.capacity) return null;

            targetItem.RemoveFromContainer();
            currentitem.RemoveFromContainer();

            targetItem.position = ItemContainer.BackpackSlotIndex;
            targetItem.SetParent(inventory.containerWear);

            for (int i = currentitem.contents.itemList.Count - 1; i >= 0; i--)
            {
                var item2move = currentitem.contents.itemList[i];
                if (item2move == null) continue;
                item2move.MoveToContainer(targetItem.contents);
            }

            inventory.GiveItem(currentitem);               

            return false;
        }

        #endregion Hooks

    }
}

// --- End of file: BackpackSwap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bradley-cctv ---
// --- Original File Path: B/BradleyCCTV/BradleyCCTV.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Bradley CCTV", "Dana", "2.0.1")]
    [Description("The ultimate surveillance upgrade for your Bradley APCs.")]
    public class BradleyCCTV : RustPlugin
    {
        #region Fields

        private static BradleyCCTV instance;
        private static Configuration config;

        private Dictionary<BradleyAPC, List<string>> surveilledBradleys = new Dictionary<BradleyAPC, List<string>>();

        private const string cctvCameraPrefab = "assets/prefabs/deployable/cctvcamera/cctv_deployed.prefab";

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty(PropertyName = "Version")]
            public string Version { get; set; }

            [JsonProperty(PropertyName = "Front Camera")]
            public CameraOptions FrontCamera { get; set; }

            [JsonProperty(PropertyName = "Back Camera")]
            public CameraOptions BackCamera { get; set; }
        }

        private class CameraOptions
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Static")]
            public bool Static { get; set; }

            [JsonProperty(PropertyName = "Up Down Rotation")]
            public float UpDownRotation { get; set; }

            [JsonProperty(PropertyName = "Right Left Rotation")]
            public float RightLeftRotation { get; set; }

            [JsonProperty(PropertyName = "Position")]
            public Vector3 Position { get; set; }

            [JsonProperty(PropertyName = "Rotation")]
            public Vector3 Rotation { get; set; }
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                FrontCamera = new CameraOptions
                {
                    Enabled = true,
                    Static = true,
                    UpDownRotation = 4f,
                    RightLeftRotation = 0f,
                    Position = new Vector3(-0.03f, 1.8f, 2.15f),
                    Rotation = Quaternion.Euler(0, 0, 0).eulerAngles
                },
                BackCamera = new CameraOptions
                {
                    Enabled = true,
                    Static = true,
                    UpDownRotation = -3f,
                    RightLeftRotation = 0f,
                    Position = new Vector3(0.0f, 1.7f, -2.93f),
                    Rotation = Quaternion.Euler(13, 180, 0).eulerAngles
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();

            if (string.Compare(config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(config.Version, "1.0.0") < 0)
                config = defaultConfig;

            PrintWarning("Configuration update complete! Updated from version " + config.Version + " to " + Version.ToString());
            config.Version = Version.ToString();
        }

        #endregion Configuration

        #region Oxide Hooks

        /// <summary>
        /// Hook: Called after server startup is complete or when the plugin is hotloaded while the server is running.
        /// </summary>
        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                BradleyAPC bradley = entity as BradleyAPC;

                if (!bradley.IsValid() || HasCamerasAttached(bradley))
                    continue;

                surveilledBradleys.Add(bradley, new List<string>());
                SetupCameras(bradley);
            }
        }

        /// <summary>
        /// Hook: Called when a plugin is being initialized.
        /// </summary>
        private void Init()
        {
            instance = this;
            Permission.Register();
        }

        /// <summary>
        /// Hook: Called when a plugin is being unloaded.
        /// </summary>
        private void Unload()
        {
            CleanupCameras();
            instance = null;
            config = null;
        }

        /// <summary>
        /// Hook: Called after any networked entity has spawned.
        /// </summary>
        /// <param name="bradley"> The bradley apc that was spawned. </param>
        private void OnEntitySpawned(BradleyAPC bradley)
        {
            if (!bradley.IsValid() || bradley.IsDestroyed)
                return;

            surveilledBradleys.Add(bradley, new List<string>());
            SetupCameras(bradley);
        }

        private void OnEntityKill(BradleyAPC bradley)
        {
            if (bradley != null && surveilledBradleys.ContainsKey(bradley))
            {
                List<string> cameraIdentifiers = surveilledBradleys[bradley];
                if (cameraIdentifiers.Count > 0)
                {
                    List<string> identifiersToRemove = Pool.GetList<string>();
                    foreach (string identifier in cameraIdentifiers)
                        identifiersToRemove.Add(identifier);

                    Puts("Bradley killed. " + identifiersToRemove.Count + " camera identifiers removed!");
                    identifiersToRemove.Clear();

                    Pool.FreeList(ref identifiersToRemove);
                }

                surveilledBradleys.Remove(bradley);
            }
        }

        #endregion Oxide Hooks

        #region Functions

        private void SetupCameras(BradleyAPC bradley)
        {
            if (!bradley.IsValid())
                return;

            SpawnCamera(bradley, config.FrontCamera);
            SpawnCamera(bradley, config.BackCamera);
        }

        private void SpawnCamera(BradleyAPC bradley, CameraOptions cameraOptions)
        {
            if (!cameraOptions.Enabled)
                return;

            CCTV_RC cctvCamera = GameManager.server.CreateEntity(cctvCameraPrefab, bradley.transform.position, bradley.transform.rotation, true) as CCTV_RC;
            if (cctvCamera)
            {
                UnityEngine.Object.DestroyImmediate(cctvCamera.GetComponent<DestroyOnGroundMissing>());

                cctvCamera.SetParent(bradley);
                cctvCamera.Spawn();

                cctvCamera.transform.localPosition = cameraOptions.Position;
                cctvCamera.transform.localRotation = Quaternion.Euler(cameraOptions.Rotation);
                cctvCamera.pitchAmount = cameraOptions.UpDownRotation;
                cctvCamera.yawAmount = cameraOptions.RightLeftRotation;
                cctvCamera.isStatic = cameraOptions.Static;

                string identifier = GenerateIdentifier();

                cctvCamera.UpdateIdentifier(identifier);
                cctvCamera.UpdateHasPower(5, 1);
                cctvCamera.SendNetworkUpdate();

                surveilledBradleys[bradley].Add(identifier);
                Puts("Camera '" + identifier + "' successfully attached to Bradley!");
            }
        }

        private void CleanupCameras()
        {
            if (!surveilledBradleys.Any())
                return;

            int removedCameras = 0;
            foreach (BradleyAPC bradley in surveilledBradleys.Keys)
            {
                if (bradley.IsValid() && !bradley.IsDestroyed)
                {
                    List<CCTV_RC> cctvCameras = Pool.GetList<CCTV_RC>();
                    cctvCameras = GetCamerasAttached(bradley, cctvCameras);

                    if (cctvCameras.Any())
                    {
                        foreach (CCTV_RC cctvCamera in cctvCameras)
                        {
                            cctvCamera?.Kill();
                            removedCameras++;
                        }
                    }
                    Pool.FreeList(ref cctvCameras);
                }
            }
            Puts("Cleanup complete. " + removedCameras + " cctv cameras removed!");
            surveilledBradleys.Clear();
        }

        private bool HasCamerasAttached(BradleyAPC bradley)
        {
            List<CCTV_RC> cctvCameras = Pool.GetList<CCTV_RC>();
            cctvCameras = GetCamerasAttached(bradley, cctvCameras);

            bool result = false;
            if (cctvCameras.Any())
                result = true;

            Pool.FreeList(ref cctvCameras);
            return result;
        }

        private List<CCTV_RC> GetCamerasAttached(BradleyAPC bradley, List<CCTV_RC> cctvCameras)
        {
            foreach (BaseEntity child in bradley.children)
            {
                CCTV_RC cctvCamera = child as CCTV_RC;
                if (cctvCamera != null && child.PrefabName == cctvCameraPrefab)
                {
                    cctvCameras.Add(cctvCamera);
                }
            }
            return cctvCameras;
        }

        private string GenerateIdentifier()
        {
            const int maxLength = 12;
            const string prefix = "BRADLEY";

            string identifier = prefix + Random.Range(0, int.MaxValue).ToString();
            if (identifier.Length > maxLength)
                identifier = identifier.Substring(0, maxLength);

            return identifier;
        }

        #endregion Functions

        #region Permissions

        /// <summary>
        /// Contains utility methods for checking and registering plugin permissions.
        /// </summary>
        private static class Permission
        {
            // Permission required to use commands.
            public const string Use = "bradleycctv.use";

            /// <summary>
            /// Registers permissions used by the plugin.
            /// </summary>
            public static void Register()
            {
                instance.permission.RegisterPermission(Use, instance);
            }

            /// <summary>
            /// Determines whether the given player has the specified permission.
            /// </summary>
            /// <param name="player"> The player to check. </param>
            /// <param name="permissionName"> The name of the permission to check. </param>
            /// <returns> True if the player has the permission, false otherwise. </returns>
            public static bool Verify(BasePlayer player, string permissionName)
            {
                if (instance.permission.UserHasPermission(player.UserIDString, permissionName))
                    return true;

                instance.SendReply(player, "You do not have the necessary permission to use the command.");
                return false;
            }
        }

        #endregion Permissions

        #region Commands

        private static class Command
        {
            public const string Identifier = "bradley.cctv";
        }

        [ChatCommand(Command.Identifier)]
        private void cmdIdentifier(BasePlayer player, string cmd, string[] args)
        {
            // Don't proceed if the player does not have permission to use the command.
            if (!Permission.Verify(player, Permission.Use))
                return;

            Item note = ItemManager.CreateByName("note", 1);
            if (note != null)
            {
                note.text = "Camera Identifiers:\n\n";
                foreach (BradleyAPC bradley in surveilledBradleys.Keys)
                {
                    List<string> cameraIdentifiers = surveilledBradleys[bradley];
                    note.text += string.Format("Bradley [{0}]\n", bradley.net.ID);
                    foreach (string identifier in cameraIdentifiers)
                    {
                        note.text += string.Format("- {0}\n", identifier);
                    }
                    note.text += "\n";
                }
                note.MarkDirty();
                player.GiveItem(note, BaseEntity.GiveItemReason.PickedUp);
            }
        }

        #endregion Commands
    }
}

// --- End of file: BradleyCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backpack-button ---
// --- Original File Path: B/BackpackButton/BackpackButton.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Network;
using Newtonsoft.Json.Converters;
using UnityEngine;
using UnityEngine.UI;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("Backpack Button", "WhiteThunder", "1.1.2")]
    [Description("Adds a button which allows players to open their backpack, with multiple advanced features.")]
    internal class BackpackButton : CovalencePlugin
    {
        #region Fields

        private const string UsagePermission = "backpackbutton.use";

        private const int SaddleBagItemId = 1400460850;

        private Configuration _config;
        private SavedData _data;
        private BackpacksApi _backpacksApi;
        private readonly HashSet<ulong> _uiViewers = new HashSet<ulong>();
        private readonly UiUpdateManager _uiUpdateManager;

        [PluginReference]
        private readonly Plugin Backpacks;

        private static readonly VersionNumber RequiredBackpacksVersion = new VersionNumber(3, 11, 0);

        public BackpackButton()
        {
            _uiUpdateManager = new UiUpdateManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init();
            _data = SavedData.Load();

            permission.RegisterPermission(UsagePermission, this);

            AddCovalenceCommand(_config.Commands, nameof(BackpackButtonCommand));

            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerSleepEnded));
        }

        private void OnServerInitialized()
        {
            if (Backpacks == null)
            {
                LogError($"Backpacks is not loaded. Get it at https://umod.org.");
            }

            HandleBackpacksLoaded();

            timer.Every(900, _data.SaveIfChanged);

            Subscribe(nameof(OnPlayerSleep));
            Subscribe(nameof(OnPlayerSleepEnded));
        }

        private void Unload()
        {
            _uiUpdateManager.Unload();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUiIfActive(player);
            }

            _data.SaveIfChanged();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == nameof(Backpacks))
            {
                HandleBackpacksLoaded();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == nameof(Backpacks))
            {
                _backpacksApi = null;

                foreach (var player in BasePlayer.activePlayerList)
                {
                    DestroyUiIfActive(player);
                }
            }
        }

        private void OnGroupPermissionGranted(string groupName, string perm)
        {
            if (!perm.Equals(UsagePermission))
                return;

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!permission.UserHasGroup(player.UserIDString, groupName))
                    continue;

                HandlePermissionChanged(player);
            }
        }

        private void OnGroupPermissionRevoked(string groupName, string perm)
        {
            OnGroupPermissionGranted(groupName, perm);
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (!perm.Equals(UsagePermission))
                return;

            var player = BasePlayer.Find(userId);
            if (player != null)
            {
                HandlePermissionChanged(player);
            }
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            OnUserPermissionGranted(userId, perm);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            CreateUiIfEnabled(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            CreateUiIfEnabled(player);
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            CreateUiIfEnabled(player);
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            DestroyUiIfActive(player);
        }

        // Handle player death while sleeping in a safe zone.
        private void OnEntityKill(BasePlayer player)
        {
            if (player.IsNpc)
                return;

            DestroyUiIfActive(player);
        }

        // Handle player death by normal means.
        private void OnEntityDeath(BasePlayer player, HitInfo info) => OnEntityKill(player);

        private void OnEntityMounted(ComputerStation station, BasePlayer player) => DestroyUiIfActive(player);

        private void OnEntityDismounted(ComputerStation station, BasePlayer player) => CreateUiIfEnabled(player);

        private void OnNpcConversationStart(NPCTalking npcTalking, BasePlayer player, ConversationData conversationData)
        {
            // This delay can be removed in the future if an OnNpcConversationStarted hook is created.
            NextTick(() =>
            {
                // Verify the conversation started, since another plugin may have blocked it.
                if (!npcTalking.conversingPlayers.Contains(player))
                    return;

                DestroyUiIfActive(player);
            });
        }

        private void OnNpcConversationEnded(NPCTalking npcTalking, BasePlayer player) => CreateUiIfEnabled(player);

        #endregion

        #region Dependencies

        private class BackpacksApi
        {
            public static BackpacksApi Parse(Dictionary<string, object> dict)
            {
                var backpacksApi = new BackpacksApi();

                GetOption(dict, "IsBackpackLoaded", out backpacksApi.IsBackpackLoaded);
                GetOption(dict, "GetBackpackCapacity", out backpacksApi.GetBackpackCapacity);
                GetOption(dict, "IsBackpackGathering", out backpacksApi.IsBackpackGathering);
                GetOption(dict, "IsBackpackRetrieving", out backpacksApi.IsBackpackRetrieving);
                GetOption(dict, "CountBackpackItems", out backpacksApi.CountBackpackItems);

                return backpacksApi;
            }

            public Func<BasePlayer, bool> IsBackpackLoaded;
            public Func<BasePlayer, int> GetBackpackCapacity;
            public Func<BasePlayer, bool> IsBackpackGathering;
            public Func<BasePlayer, bool> IsBackpackRetrieving;
            public Func<ulong, Dictionary<string, object>, int> CountBackpackItems;

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                object value;
                result = dict.TryGetValue(key, out value) && value is T
                    ? (T)value
                    : default(T);
            }
        }

        #endregion

        #region Commands

        private void BackpackButtonCommand(IPlayer player, string command, string[] args)
        {
            BasePlayer basePlayer;
            if (!VerifyPlayer(player, out basePlayer)
                || !VerifyHasPermission(player, UsagePermission)
                || _config.NumValidPositions == 0)
                return;

            var positionNameArg = args.FirstOrDefault();
            if (string.IsNullOrWhiteSpace(positionNameArg) || IsKeyBindArg(positionNameArg))
            {
                PrintCommandUsage(player, basePlayer, command);
                return;
            }

            var localizedToggleOption = GetMessage(player.Id, "Toggle");
            if (StringUtils.EqualsIgnoreCase(positionNameArg, localizedToggleOption))
            {
                var enabled = _data.GetEnabledPreference(basePlayer.userID) ?? _config.DefaultButtonPosition != null;
                _data.SetEnabledPreference(basePlayer.userID, !enabled);

                DestroyUiIfActive(basePlayer);
                CreateUiIfEnabled(basePlayer);
                return;
            }

            var localizedOffOption = GetMessage(player.Id, "Off");
            if (StringUtils.EqualsIgnoreCase(positionNameArg, localizedOffOption))
            {
                DestroyUiIfActive(basePlayer);

                if (_config.DefaultButtonPosition == null)
                {
                    _data.RemoveEnabledPreference(basePlayer.userID);
                }
                else
                {
                    _data.SetEnabledPreference(basePlayer.userID, false);
                }

                _data.RemovePositionPreference(basePlayer.userID);
                return;
            }

            var buttonPosition = GetMatchingButtonPosition(basePlayer, positionNameArg);
            if (buttonPosition == null)
            {
                PrintCommandUsage(player, basePlayer, command);
                return;
            }

            var defaultEnabled = _config.DefaultButtonPosition != null;
            var defaultPositionName = _config.DefaultButtonPosition?.Name;

            if (defaultEnabled)
            {
                _data.RemoveEnabledPreference(basePlayer.userID);
            }
            else
            {
                _data.SetEnabledPreference(basePlayer.userID, true);
            }

            if (defaultEnabled && StringUtils.EqualsIgnoreCase(buttonPosition.Name, defaultPositionName))
            {
                _data.RemovePositionPreference(basePlayer.userID);
            }
            else
            {
                _data.SetPositionPreference(basePlayer.userID, buttonPosition.Name);
            }

            CreateUiIfEnabled(basePlayer);
        }

        #endregion

        #region Helpers

        private static class StringUtils
        {
            public static bool EqualsIgnoreCase(string a, string b) =>
                string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
        }

        private static void LogDebug(string message) => Interface.Oxide.LogDebug($"[Backpack Button] {message}");
        private static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Backpack Button] {message}");
        private static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Backpack Button] {message}");
        private static void LogError(string message) => Interface.Oxide.LogError($"[Backpack Button] {message}");

        private static bool IsKeyBindArg(string arg)
        {
            return arg == "True";
        }

        private static bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private bool VerifyBackpacksVersion()
        {
            if (Backpacks == null)
                return false;

            if (Backpacks.Version >= RequiredBackpacksVersion)
                return true;

            LogError($"Backpacks v{Backpacks.Version} is loaded, but this plugin requires Backpacks v{RequiredBackpacksVersion}+");
            return false;
        }

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            player.Reply(GetMessage(player, "No Permission"));
            return false;
        }

        private ButtonPosition GetPlayerButtonPosition(BasePlayer player)
        {
            var enabled = _data.GetEnabledPreference(player.userID) ?? _config.DefaultButtonPosition != null;
            if (!enabled)
                return null;

            var positionName = _data.GetPositionPreference(player.userID) ?? _config.DefaultButtonPosition?.Name;
            if (positionName == null)
                return null;

            return _config.GetButtonPosition(positionName);
        }

        private void PrintCommandUsage(IPlayer player, BasePlayer basePlayer, string command)
        {
            var currentButtonPosition = GetPlayerButtonPosition(basePlayer);
            var localizedButtonNameList = new List<string>();

            foreach (var buttonPosition in _config.ButtonPositions)
            {
                if (!buttonPosition.Enabled || buttonPosition.LangKey == null)
                    continue;

                var localizedButtonName = GetMessage(player.Id, buttonPosition.LangKey);
                localizedButtonNameList.Add(buttonPosition == currentButtonPosition
                    ? $"<color=#5bf>{localizedButtonName}</color>"
                    : localizedButtonName);
            }

            localizedButtonNameList.Add(GetMessage(player.Id, "Toggle"));

            var localizedOffName = GetMessage(player.Id, "Off");
            localizedButtonNameList.Add(currentButtonPosition == null
                ? $"<color=#5bf>{localizedOffName}</color>"
                : localizedOffName);

            if (player.LastCommand == CommandType.Chat)
            {
                command = $"/{command}";
            }

            var localizedUsageTemplate = GetMessage(player.Id, "Usage");
            player.Reply(string.Format(localizedUsageTemplate, command, string.Join(" | ", localizedButtonNameList)));
        }

        private void HandleBackpacksLoaded()
        {
            if (!VerifyBackpacksVersion())
                return;

            var apiDict = Backpacks.Call("API_GetApi") as Dictionary<string, object>;
            _backpacksApi = BackpacksApi.Parse(apiDict);
            if (_backpacksApi == null)
            {
                LogError("Failed to integrate with Backpacks Api.");
                return;
            }

            var hooks = new Dictionary<string, object>
            {
                ["OnBackpackLoaded"] = new Action<BasePlayer, int, int>((player, occupiedSlots, totalSlots) =>
                {
                    if (_uiViewers.Contains(player.userID))
                    {
                        ButtonUi.UpdateUi(this, player);
                    }
                    else
                    {
                        CreateUiIfEnabled(player);
                    }
                })
            };

            if (_config.FillBar.Enabled || _config.Slots.Enabled)
            {
                hooks["OnBackpackItemCountChanged"] = new Action<BasePlayer, int, int>((player, occupiedSlots, totalSlots) =>
                {
                    if (_uiViewers.Contains(player.userID))
                    {
                        _uiUpdateManager.ScheduleUpdate(player);
                    }
                });
            }

            if (_config.GatherMode.Enabled)
            {
                hooks["OnBackpackGatherChanged"] = new Action<BasePlayer, bool>((player, enabled) =>
                {
                    if (_uiViewers.Contains(player.userID))
                    {
                        _uiUpdateManager.ScheduleUpdate(player);
                    }
                });
            }

            if (_config.RetrieveMode.Enabled)
            {
                hooks["OnBackpackRetrieveChanged"] = new Action<BasePlayer, bool>((player, enabled) =>
                {
                    if (_uiViewers.Contains(player.userID))
                    {
                        _uiUpdateManager.ScheduleUpdate(player);
                    }
                });
            }

            Backpacks.Call("API_AddSubscriber", this, hooks);

            foreach (var player in BasePlayer.activePlayerList)
            {
                CreateUiIfEnabled(player);
            }
        }

        private bool ShouldDisplayUi(BasePlayer player, out ButtonPosition buttonPosition)
        {
            buttonPosition = null;

            if (_backpacksApi == null)
                return false;

            if (player == null || player.IsNpc || !player.IsAlive() || player.IsSleeping())
                return false;

            if (!permission.UserHasPermission(player.UserIDString, UsagePermission))
                return false;

            var enabled = _data.GetEnabledPreference(player.userID) ?? _config.DefaultButtonPosition != null;
            if (!enabled)
                return false;

            buttonPosition = GetPlayerButtonPosition(player);
            return buttonPosition != null;
        }

        private bool ShouldDisplayUi(BasePlayer player)
        {
            ButtonPosition buttonPosition;
            return ShouldDisplayUi(player, out buttonPosition);
        }

        private void CreateUiIfEnabled(BasePlayer player)
        {
            ButtonPosition buttonPosition;
            if (!ShouldDisplayUi(player, out buttonPosition))
                return;

            _uiViewers.Add(player.userID);
            ButtonUi.CreateUi(this, player, buttonPosition);
        }

        private void DestroyUiIfActive(BasePlayer player)
        {
            if (!_uiViewers.Remove(player.userID))
                return;

            ButtonUi.DestroyUi(player);
        }

        private void HandlePermissionChanged(BasePlayer player)
        {
            if (ShouldDisplayUi(player))
            {
                CreateUiIfEnabled(player);
            }
            else
            {
                DestroyUiIfActive(player);
            }
        }

        private ButtonPosition GetMatchingButtonPosition(BasePlayer player, string positionName)
        {
            foreach (var buttonPosition in _config.ButtonPositions)
            {
                if (!buttonPosition.Enabled || buttonPosition.LangKey == null)
                    continue;

                var localizedPositionName = GetMessage(player.UserIDString, buttonPosition.LangKey);
                if (StringUtils.EqualsIgnoreCase(positionName, localizedPositionName))
                    return buttonPosition;
            }

            return null;
        }

        #endregion

        #region UI Update Manager

        private class UiUpdateManager
        {
            private const float UpdateDelaySeconds = 0.5f;
            private const float ProcessFrequencySeconds = 0.1f;

            private BackpackButton _plugin;
            private Action _updateAction;
            private Dictionary<BasePlayer, float> _scheduledUpdates = new Dictionary<BasePlayer, float>();
            private List<BasePlayer> _playersProcessed = new List<BasePlayer>();

            public UiUpdateManager(BackpackButton plugin)
            {
                _plugin = plugin;
                _updateAction = ProcessUpdates;
            }

            public void ScheduleUpdate(BasePlayer player)
            {
                var currentlyRunning = _scheduledUpdates.Count > 0;
                _scheduledUpdates[player] = Time.time + UpdateDelaySeconds;

                if (!currentlyRunning)
                {
                    ServerMgr.Instance.InvokeRepeating(_updateAction, ProcessFrequencySeconds, ProcessFrequencySeconds);
                }
            }

            public void Unload()
            {
                ServerMgr.Instance.CancelInvoke(_updateAction);
                _scheduledUpdates.Clear();
            }

            private void ProcessUpdates()
            {
                _playersProcessed.Clear();

                var now = Time.time;

                foreach (var entry in _scheduledUpdates)
                {
                    if (entry.Value > now)
                        continue;

                    var player = entry.Key;
                    _playersProcessed.Add(player);

                    if (_plugin._uiViewers.Contains(player.userID))
                    {
                        ButtonUi.UpdateUi(_plugin, player);
                    }
                }

                foreach (var player in _playersProcessed)
                {
                    _scheduledUpdates.Remove(player);
                }

                _playersProcessed.Clear();

                if (_scheduledUpdates.Count == 0)
                {
                    ServerMgr.Instance.CancelInvoke(_updateAction);
                }
            }
        }

        #endregion

        #region String Cache

        private interface IStringCache
        {
            string Get<T>(T value);
            string Get<T>(T value, Func<T, string> createString);
            string Get(bool value);
        }

        private sealed class DefaultStringCache : IStringCache
        {
            public static readonly DefaultStringCache Instance = new DefaultStringCache();

            private static class StaticStringCache<T>
            {
                private static readonly Dictionary<T, string> _cacheByValue = new Dictionary<T, string>();

                public static string Get(T value)
                {
                    string str;
                    if (!_cacheByValue.TryGetValue(value, out str))
                    {
                        str = value.ToString();
                        _cacheByValue[value] = str;
                    }

                    return str;
                }
            }

            private static class StaticStringCacheWithFactory<T>
            {
                private static readonly Dictionary<Func<T, string>, Dictionary<T, string>> _cacheByDelegate =
                    new Dictionary<Func<T, string>, Dictionary<T, string>>();

                public static string Get(T value, Func<T, string> createString)
                {
                    if (createString.Target != null)
                        throw new InvalidOperationException($"{typeof(StaticStringCacheWithFactory<T>).Name} only accepts open delegates");

                    Dictionary<T, string> cache;
                    if (!_cacheByDelegate.TryGetValue(createString, out cache))
                    {
                        cache = new Dictionary<T, string>();
                        _cacheByDelegate[createString] = cache;
                    }

                    string str;
                    if (!cache.TryGetValue(value, out str))
                    {
                        str = createString(value);
                        cache[value] = str;
                    }

                    return str;
                }
            }

            private DefaultStringCache() {}

            public string Get<T>(T value)
            {
                return StaticStringCache<T>.Get(value);
            }

            public string Get(bool value)
            {
                return value ? "true" : "false";
            }

            public string Get<T>(T value, Func<T, string> createString)
            {
                return StaticStringCacheWithFactory<T>.Get(value, createString);
            }
        }

        #endregion

        #region UI Builder

        private interface IUiSerializable
        {
            void Serialize(IUiBuilder uiBuilder);
        }

        private interface IUiBuilder
        {
            IStringCache StringCache { get; }
            void Start();
            void End();
            void StartElement();
            void EndElement();
            void StartComponent();
            void EndComponent();
            void AddField<T>(string key, T value);
            void AddField(string key, string value);
            void AddXY(string key, float x, float y);
            void AddSerializable<T>(T serializable) where T : IUiSerializable;
            void AddComponents<T>(T components) where T : IUiComponentCollection;
            string ToJson();
            byte[] GetBytes();
            void AddUi(SendInfo sendInfo);
            void AddUi(BasePlayer player);
        }

        private class UiBuilder : IUiBuilder
        {
            private static NetWrite ClientRPCStart(BaseEntity entity, string funcName)
            {
                if (Net.sv.IsConnected() && entity.net != null)
                {
                    var write = Net.sv.StartWrite();
                    write.PacketID(Message.Type.RPCMessage);
                    write.EntityID(entity.net.ID);
                    write.UInt32(StringPool.Get(funcName));
                    return write;
                }
                return null;
            }

            public static readonly UiBuilder Default = new UiBuilder(65536);

            private enum State
            {
                Empty,
                ElementList,
                Element,
                ComponentList,
                Component,
                Complete
            }

            public int Length { get; private set; }

            private const char Delimiter = ',';
            private const char Quote = '"';
            private const char Colon = ':';
            private const char Space = ' ';
            private const char OpenBracket = '[';
            private const char CloseBracket = ']';
            private const char OpenCurlyBrace = '{';
            private const char CloseCurlyBrace = '}';

            private const int MinCapacity = 1024;
            private const int DefaultCapacity = 4096;

            public IStringCache StringCache { get; }
            private char[] _chars;
            private byte[] _bytes;
            private State _state;
            private bool _needsDelimiter;

            public UiBuilder(int capacity, IStringCache stringCache)
            {
                if (capacity < MinCapacity)
                    throw new InvalidOperationException($"Capacity must be at least {MinCapacity}");

                Resize(capacity);
                StringCache = stringCache;
            }

            public UiBuilder(int capacity = DefaultCapacity) : this(capacity, DefaultStringCache.Instance) {}

            public void Start()
            {
                Reset();
                StartArray();
                _state = State.ElementList;
            }

            public void End()
            {
                ValidateState(State.ElementList);
                EndArray();
                _state = State.Complete;
            }

            public void StartElement()
            {
                ValidateState(State.ElementList);
                StartObject();
                _state = State.Element;
            }

            public void EndElement()
            {
                ValidateState(State.Element);
                EndObject();
                _state = State.ElementList;
            }

            public void StartComponent()
            {
                ValidateState(State.ComponentList);
                StartObject();
                _state = State.Component;
            }

            public void EndComponent()
            {
                ValidateState(State.Component);
                EndObject();
                _state = State.ComponentList;
            }

            public void AddField<T>(string key, T value)
            {
                AddKey(key);
                Append(StringCache.Get(value));
                _needsDelimiter = true;
            }

            public void AddField(string key, string value)
            {
                if (value == null)
                    return;

                AddKey(key);
                Append(Quote);
                Append(value);
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddXY(string key, float x, float y)
            {
                AddKey(key);
                Append(Quote);
                Append(StringCache.Get(x));
                Append(Space);
                Append(StringCache.Get(y));
                Append(Quote);
                _needsDelimiter = true;
            }

            public void AddSerializable<T>(T serializable) where T : IUiSerializable
            {
                serializable.Serialize(this);
            }

            public void AddComponents<T>(T components) where T : IUiComponentCollection
            {
                ValidateState(State.Element);
                AddKey("components");
                StartArray();
                _state = State.ComponentList;
                components.Serialize(this);
                EndArray();
                _state = State.Element;
            }

            public string ToJson()
            {
                ValidateState(State.Complete);
                return new string(_chars, 0, Length);
            }

            public byte[] GetBytes()
            {
                ValidateState(State.Complete);
                var bytes = new byte[Length];
                Buffer.BlockCopy(_bytes, 0, bytes, 0, Length);
                return bytes;
            }

            public void AddUi(SendInfo sendInfo)
            {
                var write = ClientRPCStart(CommunityEntity.ServerInstance, "AddUI");
                if (write != null)
                {
                    var byteCount = Encoding.UTF8.GetBytes(_chars, 0, Length, _bytes, 0);
                    write.BytesWithSize(_bytes, byteCount);
                    write.Send(sendInfo);
                }
            }

            public void AddUi(BasePlayer player)
            {
                AddUi(new SendInfo(player.Connection));
            }

            private void ValidateState(State desiredState)
            {
                if (_state != desiredState)
                    throw new InvalidOperationException($"Expected state {desiredState} but found {_state}");
            }

            private void ValidateState(State desiredState, State alternateState)
            {
                if (_state != desiredState && _state != alternateState)
                    throw new InvalidOperationException($"Expected state {desiredState} or {alternateState} but found {_state}");
            }

            private void Resize(int length)
            {
                Array.Resize(ref _chars, length);
                Array.Resize(ref _bytes, length * 2);
            }

            private void ResizeIfApproachingLength()
            {
                if (Length + 1024 > _chars.Length)
                {
                    Resize(_chars.Length * 2);
                }
            }

            private void Append(char @char)
            {
                _chars[Length++] = @char;
            }

            private void Append(string str)
            {
                for (var i = 0; i < str.Length; i++)
                {
                    _chars[Length + i] = str[i];
                }

                Length += str.Length;
            }

            private void AddDelimiter()
            {
                Append(Delimiter);
            }

            private void AddDelimiterIfNeeded()
            {
                if (_needsDelimiter)
                {
                    AddDelimiter();
                }
            }

            private void StartObject()
            {
                AddDelimiterIfNeeded();
                Append(OpenCurlyBrace);
                _needsDelimiter = false;
            }

            private void EndObject()
            {
                Append(CloseCurlyBrace);
                _needsDelimiter = true;
            }

            private void StartArray()
            {
                Append(OpenBracket);
                _needsDelimiter = false;
            }

            private void EndArray()
            {
                Append(CloseBracket);
                _needsDelimiter = true;
            }

            private void AddKey(string key)
            {
                ValidateState(State.Element, State.Component);
                ResizeIfApproachingLength();
                AddDelimiterIfNeeded();
                Append(Quote);
                Append(key);
                Append(Quote);
                Append(Colon);
            }

            private void Reset()
            {
                Length = 0;
                _state = State.Empty;
                _needsDelimiter = false;
            }
        }

        #endregion

        #region UI Layout

        private struct UiRect
        {
            public string Anchor;
            public float XMin;
            public float XMax;
            public float YMin;
            public float YMax;
        }

        private static class Layout
        {
            [Flags]
            public enum Option
            {
                AnchorBottom = 1 << 0,
                AnchorRight = 1 << 1,
                Vertical = 1 << 2
            }

            public const string AnchorBottomLeft = "0 0";
            public const string AnchorBottomRight = "1 0";
            public const string AnchorTopLeft = "0 1";
            public const string AnchorTopRight = "1 1";

            public const string AnchorBottomCenter = "0.5 0";
            public const string AnchorTopCenter = "0.5 1";
            public const string AnchorCenterLeft = "0 0.5";
            public const string AnchorCenterRight = "1 0.5";

            public static string DetermineAnchor(Option options)
            {
                return options.HasFlag(Option.AnchorBottom)
                    ? options.HasFlag(Option.AnchorRight) ? AnchorBottomRight : AnchorBottomLeft
                    : options.HasFlag(Option.AnchorRight) ? AnchorTopRight : AnchorTopLeft;
            }
        }

        private interface ILayoutProvider {}

        private struct StatelessLayoutProvider : ILayoutProvider
        {
            public static UiRect GetRect(int index, Layout.Option options, Vector2 size, float spacing = 0, Vector2 offset = default(Vector2))
            {
                var xMin = !options.HasFlag(Layout.Option.Vertical)
                    ? offset.x + index * (spacing + size.x)
                    : offset.x;

                var xMax = xMin + size.x;

                var yMin = options.HasFlag(Layout.Option.Vertical)
                    ? offset.y + index * (spacing + size.y)
                    : offset.y;

                var yMax = yMin + size.y;

                if (options.HasFlag(Layout.Option.AnchorRight))
                {
                    var temp = xMin;
                    xMin = -xMax;
                    xMax = -temp;
                }

                if (!options.HasFlag(Layout.Option.AnchorBottom))
                {
                    var temp = yMin;
                    yMin = -yMax;
                    yMax = -temp;
                }

                return new UiRect
                {
                    Anchor = Layout.DetermineAnchor(options),
                    XMin = xMin,
                    XMax = xMax,
                    YMin = yMin,
                    YMax = yMax,
                };
            }

            public Layout.Option Options;
            public Vector2 Offset;
            public Vector2 Size;
            public float Spacing;

            public UiRect this[int index] => GetRect(index, Options, Size, Spacing, Offset);

            public static StatelessLayoutProvider operator +(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset += vector;
                return layoutProvider;
            }

            public static StatelessLayoutProvider operator -(StatelessLayoutProvider layoutProvider, Vector2 vector)
            {
                layoutProvider.Offset -= vector;
                return layoutProvider;
            }
        }

        #endregion

        #region UI Components

        private interface IUiComponent : IUiSerializable {}

        private struct UiButtonComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Button";

            private const string DefaultCommand = null;
            private const string DefaultClose = null;
            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const float DefaultFadeIn = 0;

            public string Command;
            public string Close;
            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Material == default(string))
                    Material = DefaultMaterial;

                if (Color == default(string))
                    Color = DefaultColor;

                if (ImageType == default(Image.Type))
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Command != DefaultCommand)
                    builder.AddField("command", Command);

                if (Close != DefaultClose)
                    builder.AddField("close", Close);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Image";

            private const string DefaultSprite = "Assets/Content/UI/UI.Background.Tile.psd";
            private const string DefaultMaterial = "Assets/Icons/IconMaterial.mat";
            private const string DefaultColor = "1 1 1 1";
            private const Image.Type DefaultImageType = Image.Type.Simple;
            private const string DefaultPng = null;
            private const int DefaultItemId = 0;
            private const ulong DefaultSkinId = 0;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Material;
            public string Color;
            public Image.Type ImageType;
            public string Png;
            public int ItemId;
            public ulong SkinId;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Material == default(string))
                    Material = DefaultMaterial;

                if (Color == default(string))
                    Color = DefaultColor;

                if (ImageType == default(Image.Type))
                    ImageType = DefaultImageType;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (ImageType != DefaultImageType)
                    builder.AddField("imagetype", builder.StringCache.Get(ImageType));

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (ItemId != DefaultItemId)
                    builder.AddField("itemid", ItemId);

                if (SkinId != DefaultSkinId)
                    builder.AddField("skinid", SkinId);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRawImageComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.RawImage";

            private const string DefaultSprite = "Assets/Icons/rust.png";
            private const string DefaultColor = "1 1 1 1";
            private const string DefaultMaterial = null;
            private const string DefaultUrl = null;
            private const string DefaultPng = null;
            private const float DefaultFadeIn = 0;

            public string Sprite;
            public string Color;
            public string Material;
            public string Url;
            public string Png;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Sprite == default(string))
                    Sprite = DefaultSprite;

                if (Color == default(string))
                    Color = DefaultColor;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Sprite != DefaultSprite)
                    builder.AddField("sprite", Sprite);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (Material != DefaultMaterial)
                    builder.AddField("material", Material);

                if (Url != DefaultUrl)
                    builder.AddField("url", Url);

                if (Png != DefaultPng)
                    builder.AddField("png", Png);

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiRectTransformComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";
            public const string DefaultAnchorMax = "1.0 1.0";
            public const string DefaultOffsetMin = "0.0 0.0";
            public const string DefaultOffsetMax = "1.0 1.0";

            public string AnchorMin;
            public string AnchorMax;
            public string OffsetMin;
            public string OffsetMax;

            public void Serialize(IUiBuilder builder)
            {
                if (AnchorMin == default(string))
                    AnchorMin = DefaultAnchorMin;

                if (AnchorMax == default(string))
                    AnchorMax = DefaultAnchorMax;

                if (OffsetMin == default(string))
                    OffsetMin = DefaultOffsetMin;

                if (OffsetMax == default(string))
                    OffsetMax = DefaultOffsetMax;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (AnchorMin != DefaultAnchorMin)
                    builder.AddField("anchormin", AnchorMin);

                if (AnchorMax != DefaultAnchorMax)
                    builder.AddField("anchormax", AnchorMax);

                if (OffsetMin != DefaultOffsetMin)
                    builder.AddField("offsetmin", OffsetMin);

                if (OffsetMax != DefaultOffsetMax)
                    builder.AddField("offsetmax", OffsetMax);

                builder.EndComponent();
            }
        }

        private struct UiTextComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Text";

            private const string DefaultText = "Text";
            private const int DefaultFontSize = 14;
            private const string DefaultFont = "RobotoCondensed-Bold.ttf";
            private const TextAnchor DefaultTextAlign = TextAnchor.UpperLeft;
            private const string DefaultColor = "1 1 1 1";
            private const VerticalWrapMode DefaultVerticalWrapMode = VerticalWrapMode.Truncate;
            private const float DefaultFadeIn = 0;

            public string Text;
            public int FontSize;
            public string Font;
            public TextAnchor TextAlign;
            public string Color;
            public VerticalWrapMode VerticalWrapMode;
            public float FadeIn;

            public void Serialize(IUiBuilder builder)
            {
                if (Text == default(string))
                    Text = DefaultText;

                if (FontSize == default(int))
                    FontSize = DefaultFontSize;

                if (Font == default(string))
                    Font = DefaultFont;

                if (TextAlign == default(TextAnchor))
                    TextAlign = DefaultTextAlign;

                if (Color == default(string))
                    Color = DefaultColor;

                if (VerticalWrapMode == default(VerticalWrapMode))
                    VerticalWrapMode = DefaultVerticalWrapMode;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Text != DefaultText)
                    builder.AddField("text", Text);

                if (FontSize != DefaultFontSize)
                    builder.AddField("fontSize", FontSize);

                if (Font != DefaultFont)
                    builder.AddField("font", Font);

                if (TextAlign != DefaultTextAlign)
                    builder.AddField("align", builder.StringCache.Get(TextAlign));

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (VerticalWrapMode != DefaultVerticalWrapMode)
                    builder.AddField("verticalOverflow", builder.StringCache.Get(VerticalWrapMode));

                if (FadeIn != DefaultFadeIn)
                    builder.AddField("fadeIn", FadeIn);

                builder.EndComponent();
            }
        }

        private struct UiOutlineComponent : IUiComponent
        {
            private const string Type = "UnityEngine.UI.Outline";

            private const string DefaultColor = "1 1 1 1";
            private const string DefaultDistance = "1.0 -1.0";
            private const bool DefaultUseGraphicAlpha = false;

            public string Color;
            public string Distance;
            public bool UseGraphicAlpha;

            public void Serialize(IUiBuilder builder)
            {
                if (Color == default(string))
                    Color = DefaultColor;

                if (Distance == default(string))
                    Distance = DefaultDistance;

                builder.StartComponent();
                builder.AddField("type", Type);

                if (Color != DefaultColor)
                    builder.AddField("color", Color);

                if (Distance != DefaultDistance)
                    builder.AddField("distance", Distance);

                if (UseGraphicAlpha != DefaultUseGraphicAlpha)
                    builder.AddField("useGraphicAlpha", UseGraphicAlpha);

                builder.EndComponent();
            }
        }

        // Custom component for handling positions.
        private struct UiRectComponent : IUiComponent
        {
            private const string Type = "RectTransform";

            public const string DefaultAnchorMin = "0.0 0.0";

            private const string DefaultAnchor = "0 0";

            public UiRect Rect;

            public UiRectComponent(UiRect rect)
            {
                Rect = rect;
            }

            public UiRectComponent(float x, float y, string anchor = DefaultAnchor)
            {
                Rect = new UiRect
                {
                    Anchor = anchor,
                    XMin = x,
                    XMax = x,
                    YMin = y,
                    YMax = y
                };
            }

            public void Serialize(IUiBuilder builder)
            {
                builder.StartComponent();
                builder.AddField("type", Type);

                if (Rect.Anchor != DefaultAnchorMin)
                {
                    builder.AddField("anchormin", Rect.Anchor);
                    builder.AddField("anchormax", Rect.Anchor);
                }

                builder.AddXY("offsetmin", Rect.XMin, Rect.YMin);
                builder.AddXY("offsetmax", Rect.XMax, Rect.YMax);

                builder.EndComponent();
            }
        }

        #endregion

        #region UI Elements

        private interface IUiComponentCollection : IUiSerializable {}

        private struct UiComponents<T1> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
        {
            public T1 Component1;

            public void Add(T1 item) => Component1 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiComponents<T1, T2> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
            where T2 : IUiComponent
        {
            public T1 Component1;
            public T2 Component2;

            public void Add(T1 item) => Component1 = item;
            public void Add(T2 item) => Component2 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
                Component2.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiComponents<T1, T2, T3> : IUiComponentCollection, IEnumerable<IUiComponentCollection>
            where T1 : IUiComponent
            where T2 : IUiComponent
            where T3 : IUiComponent
        {
            public T1 Component1;
            public T2 Component2;
            public T3 Component3;

            public void Add(T1 item) => Component1 = item;
            public void Add(T2 item) => Component2 = item;
            public void Add(T3 item) => Component3 = item;

            public void Serialize(IUiBuilder builder)
            {
                Component1.Serialize(builder);
                Component2.Serialize(builder);
                Component3.Serialize(builder);
            }

            public IEnumerator<IUiComponentCollection> GetEnumerator()
            {
                throw new NotImplementedException();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                throw new NotImplementedException();
            }
        }

        private struct UiElement<T> : IUiSerializable
            where T : IUiComponentCollection
        {
            public string Name;
            public string Parent;
            public string DestroyName;
            public float FadeOut;
            public T Components;

            public void Serialize(IUiBuilder builder)
            {
                builder.StartElement();
                builder.AddField("name", Name);
                builder.AddField("parent", Parent);

                if (DestroyName != default(string))
                    builder.AddField("destroyUi", DestroyName);

                if (FadeOut != default(float))
                    builder.AddField("fadeOut", FadeOut);

                builder.AddComponents(Components);
                builder.EndElement();
            }
        }

        #endregion

        #region UI

        private static class ButtonUi
        {
            private const string Name = nameof(BackpackButton);
            private static readonly string ButtonName = $"{Name}.Button";

            private const float YMin = 18;
            private const float ButtonSize = 60;

            public static void CreateUi(BackpackButton plugin, BasePlayer player, ButtonPosition buttonPosition)
            {
                var builder = UiBuilder.Default;
                builder.Start();

                var uiRectComponent = new UiRectComponent(new UiRect
                {
                    Anchor = Layout.AnchorBottomCenter,
                    XMin = buttonPosition.OffsetX,
                    XMax = buttonPosition.OffsetX + ButtonSize,
                    YMin = YMin,
                    YMax = YMin + ButtonSize,
                });

                var config = plugin._config;
                if (config.Background.Enabled)
                {
                    var rawImageComponent = new UiRawImageComponent
                    {
                        Color = config.Background.Color,
                        Sprite = config.Background.Sprite,
                    };

                    builder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectComponent>>
                    {
                        Name = Name,
                        DestroyName = Name,
                        Parent = "Hud.Menu",
                        Components = { rawImageComponent, uiRectComponent },
                    });
                }
                else
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiRectComponent>>
                    {
                        Name = Name,
                        DestroyName = Name,
                        Parent = "Hud.Menu",
                        Components = { uiRectComponent },
                    });
                }

                var imageSize = buttonPosition.ImageSize;
                var imageOffset = (ButtonSize - imageSize) / 2f;

                var rectTransformComponent = new UiRectComponent(new UiRect
                {
                    Anchor = "0 0",
                    XMin = imageOffset,
                    XMax = imageOffset + imageSize,
                    YMin = imageOffset,
                    YMax = imageOffset + imageSize
                });

                if (buttonPosition.SkinId != 0)
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiImageComponent, UiRectComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiImageComponent { ItemId = SaddleBagItemId, SkinId = buttonPosition.SkinId },
                            rectTransformComponent
                        }
                    });
                }
                else
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectComponent>>
                    {
                        Parent = Name,
                        Components =
                        {
                            new UiRawImageComponent { Url = buttonPosition.Url, },
                            rectTransformComponent
                        }
                    });
                }

                AddButton(builder, plugin, player);

                builder.End();
                builder.AddUi(player);
            }

            public static void UpdateUi(BackpackButton plugin, BasePlayer player)
            {
                var builder = UiBuilder.Default;
                builder.Start();
                AddButton(builder, plugin, player);
                builder.End();
                builder.AddUi(player);
            }

            public static void DestroyUi(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }

            private static void AddButton(UiBuilder builder, BackpackButton plugin, BasePlayer player)
            {
                builder.AddSerializable(new UiElement<UiComponents<UiButtonComponent, UiRectTransformComponent>>
                {
                    Parent = Name,
                    Name = ButtonName,
                    DestroyName = ButtonName,
                    Components =
                    {
                        new UiButtonComponent { Command = "backpack.open", Color = "0 0 0 0" },
                        new UiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", }
                    }
                });

                var backpacksApi = plugin._backpacksApi;
                if (!backpacksApi.IsBackpackLoaded(player))
                    return;

                var occupiedSlots = plugin._backpacksApi.CountBackpackItems(player.userID, null);
                var capacity = plugin._backpacksApi.GetBackpackCapacity(player);
                var fullFraction = (float)occupiedSlots / capacity;
                var fullPercent = Mathf.CeilToInt(fullFraction * 100);

                var config = plugin._config;
                if (config.FillBar.Enabled)
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiRawImageComponent, UiRectComponent>>
                    {
                        Parent = ButtonName,
                        Components =
                        {
                            new UiRawImageComponent
                            {
                                Sprite = config.FillBar.Sprite,
                                Color = config.FillBar.GetColor(fullPercent)
                            },
                            new UiRectComponent(new UiRect
                            {
                                Anchor = "0 0",
                                XMax = config.FillBar.Width,
                                YMax = ButtonSize * fullFraction,
                            })
                        }
                    });
                }

                if (config.Slots.Enabled)
                {
                    var text = config.Slots.ShowOccupiedSlots && config.Slots.ShowTotalSlots
                        ? $"{DefaultStringCache.Instance.Get(occupiedSlots)}/{DefaultStringCache.Instance.Get(capacity)}"
                        : config.Slots.ShowOccupiedSlots
                            ? DefaultStringCache.Instance.Get(occupiedSlots)
                            : DefaultStringCache.Instance.Get(capacity);

                    builder.AddSerializable(new UiElement<UiComponents<UiRectTransformComponent, UiTextComponent, UiOutlineComponent>>
                    {
                        Parent = ButtonName,
                        Components =
                        {
                            new UiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0 0",
                                OffsetMin = config.Slots.OffsetMin,
                                OffsetMax = config.Slots.OffsetMax,
                            },
                            new UiTextComponent
                            {
                                Text = text,
                                FontSize = 14,
                                Color = config.Slots.GetColor(fullPercent),
                                TextAlign = TextAnchor.MiddleCenter,
                                VerticalWrapMode = VerticalWrapMode.Overflow
                            },
                            new UiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "0.5 0",
                            },
                        }
                    });
                }

                var arrowSize = new Vector2(ButtonSize / 2, ButtonSize / 2);

                if (config.RetrieveMode.Enabled && backpacksApi.IsBackpackRetrieving(player))
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                    {
                        Parent = ButtonName,
                        Components =
                        {
                            new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: new Vector2(3, 0))),
                            new UiTextComponent
                            {
                                Text = "↑",
                                FontSize = 16,
                                TextAlign = TextAnchor.UpperRight,
                                Color = config.RetrieveMode.Color,
                                VerticalWrapMode = VerticalWrapMode.Overflow
                            },
                        }
                    });
                }

                if (config.GatherMode.Enabled && backpacksApi.IsBackpackGathering(player))
                {
                    builder.AddSerializable(new UiElement<UiComponents<UiRectComponent, UiTextComponent>>
                    {
                        Parent = ButtonName,
                        Components =
                        {
                            new UiRectComponent(StatelessLayoutProvider.GetRect(0, Layout.Option.AnchorBottom | Layout.Option.AnchorRight | Layout.Option.Vertical, arrowSize, offset: new Vector2(3, 3))),
                            new UiTextComponent
                            {
                                Text = "↓",
                                FontSize = 16,
                                TextAlign = TextAnchor.LowerRight,
                                Color = config.GatherMode.Color,
                                VerticalWrapMode = VerticalWrapMode.Overflow
                            },
                        }
                    });
                }
            }
        }

        #endregion

        #region Data

        [JsonObject(MemberSerialization.OptIn)]
        private class SavedData
        {
            public static SavedData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<SavedData>(nameof(BackpackButton)) ?? new SavedData { _dirty = true };
                data.SaveIfChanged();
                return data;
            }

            [JsonIgnore]
            private bool _dirty;

            [JsonProperty("OverridePositionByPlayer")]
            private Dictionary<ulong, string> _overridePositionByPlayer = new Dictionary<ulong, string>();

            [JsonProperty("OverrideEnabledByPlayer")]
            private Dictionary<ulong, bool> _overrideEnabledByPlayer = new Dictionary<ulong, bool>();

            public bool? GetEnabledPreference(ulong userId)
            {
                bool enabled;
                return _overrideEnabledByPlayer.TryGetValue(userId, out enabled)
                    ? enabled as bool?
                    : null;
            }

            public void SetEnabledPreference(ulong userId, bool enabled)
            {
                bool currentlyEnabled;
                if (_overrideEnabledByPlayer.TryGetValue(userId, out currentlyEnabled)
                    && currentlyEnabled == enabled)
                    return;

                _overrideEnabledByPlayer[userId] = enabled;
                _dirty = true;
            }

            public void RemoveEnabledPreference(ulong userId)
            {
                _dirty |= _overrideEnabledByPlayer.Remove(userId);
            }

            public string GetPositionPreference(ulong userId)
            {
                string positionName;
                return _overridePositionByPlayer.TryGetValue(userId, out positionName)
                    ? positionName
                    : null;
            }

            public void SetPositionPreference(ulong userId, string positionName)
            {
                string currentPosition;
                if (_overridePositionByPlayer.TryGetValue(userId, out currentPosition)
                    && StringUtils.EqualsIgnoreCase(currentPosition, positionName))
                    return;

                _overridePositionByPlayer[userId] = positionName;
                _dirty = true;
            }

            public void RemovePositionPreference(ulong userId)
            {
                _dirty |= _overridePositionByPlayer.Remove(userId);
            }

            public void SaveIfChanged()
            {
                if (!_dirty)
                    return;

                Interface.Oxide.DataFileSystem.WriteObject(nameof(BackpackButton), this);
                _dirty = false;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class ButtonPosition
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Offset X")]
            public float OffsetX;

            [JsonProperty("URL")]
            public string Url;

            [JsonProperty("Skin ID")]
            public ulong SkinId;

            [JsonProperty("Image size")]
            public float ImageSize = 60;

            public string LangKey
            {
                get
                {
                    if (_langKey == null)
                    {
                        _langKey = string.IsNullOrWhiteSpace(Name) ? null : $"Position.{Name}";
                    }

                    return _langKey;
                }
            }

            private string _langKey;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class BackgroundSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Color")]
            public string Color = "0.969 0.922 0.882 0.035";

            [JsonProperty("Sprite")]
            public string Sprite = "assets/content/ui/ui.background.tiletex.psd";
        }

        [JsonObject(MemberSerialization.OptIn)]
        private abstract class DynamicColorConfig
        {
            [JsonProperty("Default color")]
            protected abstract string DefaultColor { get; set; }

            [JsonProperty("Enable dynamic color")]
            protected abstract bool EnableDynamicColor { get; set; }

            [JsonProperty("Dynamic color by fullness percent", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            protected abstract Dictionary<int, string> ColorByFullPercent { get; set; }

            private List<Tuple<int, string>> _sortedColorByFullPercent = new List<Tuple<int, string>>();

            public void Init()
            {
                foreach (var fullPercent in ColorByFullPercent.Keys.OrderBy(amount => amount))
                {
                    _sortedColorByFullPercent.Add(new Tuple<int, string>(fullPercent, ColorByFullPercent[fullPercent]));
                }
            }

            public string GetColor(int fullPercent)
            {
                if (EnableDynamicColor)
                {
                    for (var i = _sortedColorByFullPercent.Count - 1; i >= 0; i--)
                    {
                        var entry = _sortedColorByFullPercent[i];
                        if (fullPercent >= entry.Item1)
                            return entry.Item2;
                    }
                }

                return DefaultColor;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SlotSettings : DynamicColorConfig
        {
            [JsonProperty("Show occupied slots")]
            public bool ShowOccupiedSlots = true;

            [JsonProperty("Show total slots")]
            public bool ShowTotalSlots = true;

            [JsonProperty("Offset min")]
            public string OffsetMin = "0 -18";

            [JsonProperty("Offset max")]
            public string OffsetMax = "60 0";

            [JsonProperty("Text align")]
            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor = TextAnchor.MiddleCenter;

            public bool Enabled => ShowOccupiedSlots || ShowTotalSlots;

            protected override string DefaultColor { get; set; } = "0.4 0.8 0.4 1";

            protected override bool EnableDynamicColor { get; set; } = true;

            protected override Dictionary<int, string> ColorByFullPercent { get; set; } = new Dictionary<int, string>
            {
                [70] = "0.8 0.8 0.2 1",
                [80] = "0.8 0.4 0.2 1",
                [90] = "0.8 0.2 0.2 1",
            };
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class FillBarSettings : DynamicColorConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Width")]
            public float Width = 4;

            [JsonProperty("Sprite")]
            public string Sprite = "assets/content/ui/ui.background.tiletex.psd";

            // private string DefaultColor = "0.792 0.459 0.251 1";
            protected override string DefaultColor { get; set; } = "0.4 0.8 0.4 1";

            protected override bool EnableDynamicColor { get; set; } = true;

            protected override Dictionary<int, string> ColorByFullPercent { get; set; } = new Dictionary<int, string>
            {
                [70] = "0.8 0.8 0.2 1",
                [80] = "0.8 0.4 0.2 1",
                [90] = "0.8 0.2 0.2 1",
            };
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class GatherModeSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Color")]
            public string Color = "0.4 0.8 1 1";
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RetrieveModeSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;

            [JsonProperty("Color")]
            public string Color = "0.4 0.8 1 1";
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Commands")]
            public string[] Commands =
            {
                "backpackui",
                "backpackbutton"
            };

            [JsonProperty("Background")]
            public BackgroundSettings Background = new BackgroundSettings();

            [JsonProperty("Gather mode indicator")]
            public GatherModeSettings GatherMode = new GatherModeSettings();

            [JsonProperty("Retrieve mode indicator")]
            public RetrieveModeSettings RetrieveMode = new RetrieveModeSettings();

            [JsonProperty("Occupied & total slots")]
            public SlotSettings Slots = new SlotSettings();

            [JsonProperty("Fill bar")]
            public FillBarSettings FillBar = new FillBarSettings();

            [JsonProperty("Default button position")]
            public string DefaultButtonPositionName = "Right";

            [JsonProperty("Button positions")]
            public ButtonPosition[] ButtonPositions =
            {
                new ButtonPosition
                {
                    Name = "Left",
                    OffsetX = -263.5f,
                    Url = "",
                    SkinId = 3050420442,
                    ImageSize = 56,
                },
                new ButtonPosition
                {
                    Name = "Right",
                    OffsetX = 185,
                    Url = "",
                    SkinId = 3050420772,
                    ImageSize = 56,
                },
            };

            public ButtonPosition DefaultButtonPosition { get; private set; }
            public int NumValidPositions { get; private set; }

            public void Init()
            {
                Slots.Init();
                FillBar.Init();

                var defaultIsValid = false;

                foreach (var position in ButtonPositions)
                {
                    if (!position.Enabled || position.LangKey == null)
                        continue;

                    NumValidPositions++;

                    if (StringUtils.EqualsIgnoreCase(position.Name, DefaultButtonPositionName))
                    {
                        defaultIsValid = true;
                        DefaultButtonPosition = position;
                    }
                }

                if (!string.IsNullOrWhiteSpace(DefaultButtonPositionName))
                {
                    if (!defaultIsValid)
                    {
                        LogError($"Default button position '{DefaultButtonPositionName}' does not have a corresponding enabled configuration.");
                    }

                    DefaultButtonPositionName = null;
                }

                if (NumValidPositions == 0)
                {
                    LogError("No button positions are enabled and valid. No backpack button will be displayed. Please correct your config if you intend to use this plugin.");
                }
            }

            public ButtonPosition GetButtonPosition(string positionName)
            {
                foreach (var buttonPosition in ButtonPositions)
                {
                    if (StringUtils.EqualsIgnoreCase(buttonPosition.Name, positionName))
                        return buttonPosition;
                }

                return null;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                var changed = MaybeUpdateConfig(_config);

                foreach (var buttonPosition in _config.ButtonPositions)
                {
                    if (buttonPosition.Url == "https://i.imgur.com/wLR9Z6V.png"
                        || buttonPosition.Url == "https://i.imgur.com/1Tep5Ad.png")
                    {
                        buttonPosition.SkinId = 3050420442;
                        buttonPosition.Url = "";
                        changed = true;
                    }
                    else if (buttonPosition.Url == "https://i.imgur.com/h1HQEAB.png"
                             || buttonPosition.Url == "https://i.imgur.com/wleeQkt.png")
                    {
                        buttonPosition.SkinId = 3050420772;
                        buttonPosition.Url = "";
                        changed = true;
                    }
                }

                if (changed)
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        private string GetMessage(string playerId, string langKey) =>
            lang.GetMessage(langKey, this, playerId);

        private string GetMessage(IPlayer player, string langKey) =>
            GetMessage(player.Id, langKey);

        private string GetMessage(BasePlayer basePlayer, string langKey) =>
            GetMessage(basePlayer.UserIDString, langKey);

        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                ["Usage"] = "Usage: <color=#fd4>{0}</color> <position>\n\nPositions: {1}",
                ["Off"] = "Off",
                ["Toggle"] = "Toggle",
                ["No Permission"] = "You don't have permission to use this command.",
            };

            foreach (var position in _config.ButtonPositions)
            {
                if (string.IsNullOrWhiteSpace(position.LangKey))
                    continue;

                messages[position.LangKey] = position.Name;
            }

            lang.RegisterMessages(messages, this);
        }
    }
}


// --- End of file: BackpackButton.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/build-scanner ---
// --- Original File Path: B/BuildScanner/BuildScanner.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Build Scanner", "Mevent", "1.0.5")]
    [Description("Allows to scan entities (codelocks/autoturrets/cupboards and house)")]
    public class BuildScanner : CovalencePlugin
    {
        #region Fields

        [PluginReference] private Plugin ImageLibrary;

        private const string Layer = "UI.Scanner";

        private static BuildScanner _instance;

        private const string PermUse = "buildscanner.use";

        private const string PermUnlimited = "buildscanner.unlimited";

        private const string PermCupboard = "buildscanner.cupboard";
        private const string PermCodeLock = "buildscanner.codelock";
        private const string PermAutoTurret = "buildscanner.autoturret";

        private const string PermHome = "buildscanner.home";

        private readonly Dictionary<BasePlayer, ScanData> _scanByPlayer = new Dictionary<BasePlayer, ScanData>();

        private class ScanData
        {
            public ScanPlayerData OwnerId;

            public List<ScanPlayerData> Members = new List<ScanPlayerData>();

            public static ScanData Get(IPlayer player, BaseEntity entity)
            {
                var cupboard = entity as BuildingPrivlidge;
                if (cupboard != null && player.HasPermission(PermCupboard))
                    return new ScanData
                    {
                        OwnerId = new ScanPlayerData(cupboard.OwnerID),
                        Members = cupboard.authorizedPlayers.Select(x => new ScanPlayerData(x)).ToList()
                    };

                var turret = entity as AutoTurret;
                if (turret != null && player.HasPermission(PermAutoTurret))
                    return new ScanData
                    {
                        OwnerId = new ScanPlayerData(turret.OwnerID),
                        Members = turret.authorizedPlayers.Select(x => new ScanPlayerData(x)).ToList()
                    };

                var codeLock = entity as CodeLock;
                if (codeLock != null && player.HasPermission(PermCodeLock))
                    return new ScanData
                    {
                        OwnerId = new ScanPlayerData(codeLock.OwnerID),
                        Members = codeLock.whitelistPlayers.Select(x => new ScanPlayerData(x)).ToList()
                    };

                var buildingPrivilege = entity.GetBuildingPrivilege();
                if (buildingPrivilege != null && player.HasPermission(PermHome))
                    return new ScanData
                    {
                        OwnerId = new ScanPlayerData(buildingPrivilege.OwnerID),
                        Members = buildingPrivilege.authorizedPlayers.Select(x => new ScanPlayerData(x)).ToList()
                    };

                return null;
            }
        }

        private class ScanPlayerData
        {
            public readonly string Name;

            public readonly ulong UserID;

            public readonly bool Online;

            public ScanPlayerData(PlayerNameID data)
            {
                var player = _instance.covalence.Players.FindPlayerById(data.userid.ToString());

                Name = data.username;
                UserID = data.userid;

                Online = player != null && player.IsConnected;
            }

            public ScanPlayerData(ulong member)
            {
                var player = _instance.covalence.Players.FindPlayerById(member.ToString());

                Name = player != null ? player.Name : "UNKNOWN";
                UserID = member;
                Online = player != null && player.IsConnected;
            }
        }

        #region Colors

        private string _color1;
        private string _color2;
        private string _color3;
        private string _color4;
        private string _color5;

        #endregion

        #endregion

        #region Config

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "scan" };

            [JsonProperty(PropertyName = "Cooldown between checks (seconds)")]
            public int Cooldown = 30;

            [JsonProperty(PropertyName = "Colors")]
            public Colors Colors = new Colors
            {
                Color1 = "#0E0E10",
                Color2 = "#161617",
                Color3 = "#4B68FF",
                Color4 = "#74884A",
                Color5 = "#B43D3D"
            };
        }

        private class Colors
        {
            [JsonProperty(PropertyName = "Color 1")]
            public string Color1;

            [JsonProperty(PropertyName = "Color 2")]
            public string Color2;

            [JsonProperty(PropertyName = "Color 3")]
            public string Color3;

            [JsonProperty(PropertyName = "Color 4")]
            public string Color4;

            [JsonProperty(PropertyName = "Color 5")]
            public string Color5;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch (Exception ex)
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
                Debug.LogException(ex);
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Data

        private PluginData _data;

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty(PropertyName = "Last Time")]
            public DateTime LastTime = new DateTime(1970, 1, 1, 0, 0, 0);

            public int GetTime()
            {
                return (int)DateTime.UtcNow.Subtract(LastTime).TotalSeconds;
            }
        }

        private PlayerData GetPlayerData(BasePlayer player)
        {
            return GetPlayerData(player.userID);
        }

        private PlayerData GetPlayerData(ulong member)
        {
            if (!_data.Players.ContainsKey(member))
                _data.Players.Add(member, new PlayerData());

            return _data.Players[member];
        }

        private bool HasCooldown(BasePlayer player)
        {
            var data = GetPlayerData(player);
            if (data == null) return true;

            if (permission.UserHasPermission(player.UserIDString, PermUnlimited))
                return false;

            var time = data.GetTime();
            return time < _config.Cooldown;
        }

        private void UpdateCooldown(BasePlayer player)
        {
            var data = GetPlayerData(player);
            if (data == null) return;

            data.LastTime = DateTime.UtcNow;
        }

        private int GetLeftTime(BasePlayer player)
        {
            var data = GetPlayerData(player);
            if (data == null) return 0;

            return _config.Cooldown - data.GetTime();
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;

            LoadData();

            RegisterPermissions();

            LoadColors();
        }

        private void OnServerInitialized()
        {
            AddCovalenceCommand(_config.Commands, nameof(CmdChatOpen));

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnServerSave()
        {
            timer.In(Random.Range(2, 7), SaveData);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

            SaveData();

            _instance = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            GetAvatar(player.userID,
                avatar => ImageLibrary?.Call("AddImage", avatar, $"avatar_{player.UserIDString}"));
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _scanByPlayer.Remove(player);
        }

        #endregion

        #region Commands

        private void CmdChatOpen(IPlayer cov, string command, string[] args)
        {
            var player = cov.Object as BasePlayer;
            if (player == null) return;

            if (!cov.HasPermission(PermUse))
            {
                Reply(cov, NoPermission);
                return;
            }

            if (HasCooldown(player))
            {
                Reply(cov, CooldownMsg, GetLeftTime(player));
                return;
            }

            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.position, player.eyes.HeadForward(), out hit, 5f))
            {
                Reply(cov, EntityNotFound);
                return;
            }

            var entity = hit.GetEntity();
            if (entity == null)
            {
                Reply(cov, EntityNotFound);
                return;
            }

            var door = entity as Door;
            if (door != null)
            {
                entity = entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
                if (entity == null)
                {
                    Reply(cov, EntityNotFound);
                    return;
                }
            }

            var hasPermission = HasPermission(cov, entity);
            if (hasPermission == null)
            {
                Reply(cov, EntityNotFound);
                return;
            }

            if (hasPermission == false)
            {
                Reply(cov, NoPermission);
                return;
            }

            var scan = ScanData.Get(cov, entity);
            if (scan == null)
            {
                Reply(cov, EntityNotFound);
                return;
            }

            _scanByPlayer[player] = scan;

            MainUi(player, first: true);

            UpdateCooldown(player);
        }

        [ConsoleCommand("UI_Scanner")]
        private void CmdConsole(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "close":
                {
                    _scanByPlayer.Remove(player);
                    break;
                }

                case "page":
                {
                    int page;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out page)) return;

                    MainUi(player, page);
                    break;
                }
            }
        }

        #endregion

        #region Interface

        private void MainUi(BasePlayer player, int page = 0, bool first = false)
        {
            ScanData scan;
            if (!_scanByPlayer.TryGetValue(player, out scan) || scan == null) return;

            var amountOnString = 3;
            var lines = 4;
            var amountOnPage = amountOnString * lines;

            var container = new CuiElementContainer();

            #region Background

            if (first)
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer,
                        Command = "UI_Scanner close"
                    }
                }, Layer);
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-330 -230",
                    OffsetMax = "330 230"
                },
                Image =
                {
                    Color = _color1
                }
            }, Layer, Layer + ".Main");

            #region Header

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = { Color = _color2 }
            }, Layer + ".Main", Layer + ".Header");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "30 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, TitleMenu),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, Layer + ".Header");

            float xSwitch = -25;
            float width = 25;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, CloseButton),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Close = Layer,
                    Color = _color3,
                    Command = "UI_Scanner close"
                }
            }, Layer + ".Header");

            #endregion

            #region Owner

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "0 1",
                    OffsetMin = "10 -80",
                    OffsetMax = "200 -60"
                },
                Text =
                {
                    Text = Msg(player, OwnerTitle),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, Layer + ".Main");

            PlayerUi(ref container, player, scan.OwnerId, "10 -145", "220 -85", true);

            #endregion

            #region List of Authorized

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "0 1",
                    OffsetMin = "10 -185",
                    OffsetMax = "200 -165"
                },
                Text =
                {
                    Text = Msg(player, ListTitle),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, Layer + ".Main");

            #region Pages

            if (scan.Members.Count > amountOnPage)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 1", AnchorMax = "0 1",
                        OffsetMin = "175 -185",
                        OffsetMax = "195 -165"
                    },
                    Text =
                    {
                        Text = Msg(player, BackBtn),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 10,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Color = HexToCuiColor(_config.Colors.Color3, 33),
                        Command = page != 0 ? $"UI_Scanner page {page - 1}" : ""
                    }
                }, Layer + ".Main");

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 1", AnchorMax = "0 1",
                        OffsetMin = "200 -185",
                        OffsetMax = "220 -165"
                    },
                    Text =
                    {
                        Text = Msg(player, NextBtn),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 10,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Color = _color3,
                        Command = scan.Members.Count > (page + 1) * amountOnPage ? $"UI_Scanner page {page + 1}" : ""
                    }
                }, Layer + ".Main");
            }

            #endregion

            #region List

            var height = 60f;
            var margin = 5f;
            width = 210f;

            var ySwitch = -190f;
            xSwitch = 10f;

            var i = 1;
            foreach (var playerData in scan.Members.Skip(page * amountOnPage).Take(amountOnPage))
            {
                PlayerUi(ref container, player, playerData, $"{xSwitch} {ySwitch - height}",
                    $"{xSwitch + width} {ySwitch}",
                    playerData.UserID == scan.OwnerId.UserID);

                if (i % amountOnString == 0)
                {
                    xSwitch = 10f;
                    ySwitch = ySwitch - height - margin;
                }
                else
                {
                    xSwitch += width + margin;
                }

                i++;
            }

            #endregion

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }

        private void PlayerUi(ref CuiElementContainer container, BasePlayer player, ScanPlayerData playerData,
            string offMin,
            string offMax, bool isOwner)
        {
            var guid = CuiHelper.GetGuid();

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "0 1",
                    OffsetMin = offMin, OffsetMax = offMax
                },
                Image =
                {
                    Color = _color2
                }
            }, Layer + ".Main", guid);

            if (ImageLibrary)
                container.Add(new CuiElement
                {
                    Parent = guid,
                    Components =
                    {
                        new CuiRawImageComponent
                            { Png = ImageLibrary.Call<string>("GetImage", $"avatar_{playerData.UserID}") },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0", AnchorMax = "0 0",
                            OffsetMin = "5 5", OffsetMax = "55 55"
                        }
                    }
                });

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0.5", AnchorMax = "1 1",
                    OffsetMin = "60 0", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = $"{playerData.Name}",
                    Align = TextAnchor.LowerLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, guid);

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 0.5",
                    OffsetMin = "60 0", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = $"{playerData.UserID}",
                    Align = TextAnchor.UpperLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.5"
                }
            }, guid);

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-20 -20", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = "•",
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 16,
                    Color = playerData.Online ? _color4 : _color5
                }
            }, guid);

            if (isOwner)
                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 0",
                        OffsetMin = "0 5", OffsetMax = "-5 20"
                    },
                    Text =
                    {
                        Text = Msg(player, OwnerSecondTitle),
                        Align = TextAnchor.LowerRight,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 12,
                        Color = "1 1 1 0.3"
                    }
                }, guid);
        }

        #endregion

        #region Utils

        private static string HexToCuiColor(string hex, float alpha = 100)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6) throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100f}";
        }

        private static bool? HasPermission(IPlayer player, BaseEntity entity)
        {
            if (entity is BuildingPrivlidge) return player.HasPermission(PermCupboard);

            if (entity is AutoTurret) return player.HasPermission(PermAutoTurret);

            if (entity is CodeLock) return player.HasPermission(PermCodeLock);

            return player.HasPermission(PermHome);
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermCupboard, this);
            permission.RegisterPermission(PermCodeLock, this);
            permission.RegisterPermission(PermAutoTurret, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermUnlimited, this);
        }

        private void LoadColors()
        {
            _color1 = HexToCuiColor(_config.Colors.Color1);
            _color2 = HexToCuiColor(_config.Colors.Color2);
            _color3 = HexToCuiColor(_config.Colors.Color3);
            _color4 = HexToCuiColor(_config.Colors.Color4);
            _color5 = HexToCuiColor(_config.Colors.Color5);
        }

        #region Avatar

        private readonly Regex _regex = new Regex(@"<avatarFull><!\[CDATA\[(.*)\]\]></avatarFull>");

        private void GetAvatar(ulong userId, Action<string> callback)
        {
            if (callback == null) return;

            webrequest.Enqueue($"http://steamcommunity.com/profiles/{userId}?xml=1", null, (code, response) =>
            {
                if (code != 200 || response == null)
                    return;

                var avatar = _regex.Match(response).Groups[1].ToString();
                if (string.IsNullOrEmpty(avatar))
                    return;

                callback.Invoke(avatar);
            }, this);
        }

        #endregion

        #endregion

        #region Lang

        private const string
            OwnerSecondTitle = "OwnerSecondTitle",
            NextBtn = "NextBtn",
            BackBtn = "BackBtn",
            ListTitle = "ListTitle",
            OwnerTitle = "OwnerTitle",
            EntityNotFound = "EntityNotFound",
            CooldownMsg = "CooldownMsg",
            CloseButton = "CloseButton",
            TitleMenu = "TitleMenu",
            NoPermission = "NoPermission";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "You don't have the required permission",
                [TitleMenu] = "Scanner",
                [CloseButton] = "✕",
                [CooldownMsg] = "You will be able to scan after {0} sec.",
                [EntityNotFound] = "Entity to scan not found!",
                [OwnerTitle] = "Owner",
                [ListTitle] = "List of Authorized",
                [NextBtn] = "▼",
                [BackBtn] = "▲",
                [OwnerSecondTitle] = "owner"
            }, this);
        }

        private string Msg(string key, string userid = null, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, userid), obj);
        }

        private string Msg(BasePlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
        }

        private string Msg(IPlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.Id), obj);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            player.ChatMessage(Msg(player, key, obj));
        }

        private void Reply(IPlayer player, string key, params object[] obj)
        {
            player.Reply(Msg(player, key, obj));
        }

        #endregion
    }
}

// --- End of file: BuildScanner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat ---
// --- Original File Path: B/BetterChat/BetterChat.cs ---

using Oxide.Plugins.BetterChatExtensions;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using System;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

#if RUST
using ConVar;
using Facepunch;
using Facepunch.CardGames;
using Facepunch.Math;
using CompanionServer;
#endif

// TODO: Reduce garbage creation
// TODO: Improve string usage by using stringbuilders
// TODO: Add "name" or "identifier" format for third-party plugins to obtain a formatted identifier

namespace Oxide.Plugins
{
    [Info("Better Chat", "LaserHydra", "5.2.14")]
    [Description("Allows to manage chat groups, customize colors and add titles.")]
    internal class BetterChat : CovalencePlugin
    {
        #region Fields

        private static BetterChat _instance;

        private Configuration _config;
        private List<ChatGroup> _chatGroups;
        private Dictionary<Plugin, Func<IPlayer, string>> _thirdPartyTitles = new Dictionary<Plugin, Func<IPlayer, string>>();

        private static readonly string[] _stringReplacements = new string[]
        {
#if RUST || HURTWORLD || UNTURNED
            "<b>", "</b>",
            "<i>", "</i>",
            "</size>",
            "</color>"
#endif
        };

        private static readonly Regex[] _regexReplacements = new Regex[]
        {
            new Regex(@"<voffset=(?:.|\s)*?>", RegexOptions.Compiled),
#if RUST || HURTWORLD || UNTURNED
            new Regex(@"<color=.+?>", RegexOptions.Compiled),
            new Regex(@"<size=.+?>", RegexOptions.Compiled),
#elif REIGNOFKINGS || SEVENDAYSTODIE
            new Regex(@"\[[\w\d]{6}\]", RegexOptions.Compiled),
#elif RUSTLEGACY
            new Regex(@"\[color #[\w\d]{6}\]", RegexOptions.Compiled),
#elif TERRARIA
            new Regex(@"\[c\/[\w\d]{6}:", RegexOptions.Compiled),
#endif
        };

        #endregion

        #region Hooks

        private void Loaded()
        {
            _instance = this;

            LoadData(ref _chatGroups);

            if (_chatGroups.Count == 0)
                _chatGroups.Add(new ChatGroup("default"));

            foreach (ChatGroup group in _chatGroups)
            {
                if (!permission.GroupExists(group.GroupName))
                    permission.CreateGroup(group.GroupName, string.Empty, 0);
            }

            SaveData(_chatGroups);
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (_thirdPartyTitles.ContainsKey(plugin))
                _thirdPartyTitles.Remove(plugin);
        }

#if RUST
        private object OnPlayerChat(BasePlayer bplayer, string message, Chat.ChatChannel chatchannel)
        {
            IPlayer player = bplayer.IPlayer;
#else
        private object OnUserChat(IPlayer player, string message)
        {
#endif
            if (message.Length > _instance._config.MaxMessageLength)
                message = message.Substring(0, _instance._config.MaxMessageLength);

            BetterChatMessage chatMessage = ChatGroup.PrepareMessage(player, message);

            if (chatMessage == null)
                return null;

#if RUST
            BetterChatMessage.CancelOptions result = SendBetterChatMessage(chatMessage, chatchannel);
#else
            BetterChatMessage.CancelOptions result = SendBetterChatMessage(chatMessage);
#endif

            switch (result)
            {
                case BetterChatMessage.CancelOptions.None:
                case BetterChatMessage.CancelOptions.BetterChatAndDefault:
                    return true;
            }

            return null;
        }

        #endregion

        #region Messaging

#if RUST
        private BetterChatMessage.CancelOptions SendBetterChatMessage(BetterChatMessage chatMessage, Chat.ChatChannel chatchannel)
#else
        private BetterChatMessage.CancelOptions SendBetterChatMessage(BetterChatMessage chatMessage)
#endif
        {
            Dictionary<string, object> chatMessageDict = chatMessage.ToDictionary();
#if RUST
            chatMessageDict.Add("ChatChannel", chatchannel);
#endif
            foreach (Plugin plugin in plugins.GetAll())
            {
                object hookResult = plugin.CallHook("OnBetterChat", chatMessageDict);

                if (hookResult is Dictionary<string, object>)
                {
                    try
                    {
                        chatMessageDict = hookResult as Dictionary<string, object>;
                    }
                    catch (Exception e)
                    {
                        PrintError($"Failed to load modified OnBetterChat hook data from plugin '{plugin.Title} ({plugin.Version})':{Environment.NewLine}{e}");
                        continue;
                    }
                }
                else if (hookResult != null)
                    return BetterChatMessage.CancelOptions.BetterChatOnly;
            }

            chatMessage = BetterChatMessage.FromDictionary(chatMessageDict);

            if (chatMessage.CancelOption != BetterChatMessage.CancelOptions.None)
            {
                return chatMessage.CancelOption;
            }

            var output = chatMessage.GetOutput();

#if RUST
            BasePlayer basePlayer = chatMessage.Player.Object as BasePlayer;

            switch (chatchannel)
            {
                case Chat.ChatChannel.Team:
                    RelationshipManager.PlayerTeam team = basePlayer.Team;
                    if (team == null || team.members.Count == 0)
                    {
                        throw new InvalidOperationException("Chat channel is set to Team, however the player is not in a team.");
                    }

                    team.BroadcastTeamChat(basePlayer.userID, chatMessage.Player.Name, chatMessage.Message, chatMessage.UsernameSettings.Color);

                    List<Network.Connection> onlineMemberConnections = team.GetOnlineMemberConnections();
                    if (onlineMemberConnections != null)
                    {
                        ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add", (int) chatchannel, chatMessage.Player.Id, output.Chat);
                    }
                    break;

                case Chat.ChatChannel.Cards:
                    BaseCardGameEntity baseCardGame = basePlayer.GetMountedVehicle() as BaseCardGameEntity;

                    if (baseCardGame == null /* || !cardTable.GameController.PlayerIsInGame(basePlayer) */)
                    {
                       throw new InvalidOperationException("Chat channel is set to Cards, however the player is not in a participating in a card game.");
                    }

                    List<Network.Connection> list = Facepunch.Pool.GetList<Network.Connection>();

                    foreach (CardPlayerData playerData in baseCardGame.GameController.PlayerData)
                    {
                        if (playerData.HasUser)
                        {
                            list.Add(BasePlayer.FindByID(playerData.UserID).net.connection);
                        }
                    }

                    if (list.Count > 0)
                    {
                        ConsoleNetwork.SendClientCommand(list, "chat.add", (int) chatchannel, chatMessage.Player.Id, output.Chat);
                    }

                    Facepunch.Pool.FreeList(ref list);
                    break;

                case Chat.ChatChannel.Local: 
                    float localRange = Chat.localChatRange * Chat.localChatRange;
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                    {
                        if (chatMessage.BlockedReceivers.Contains(player.UserIDString))
                        {
                            continue;
                        }
                        
                        if ((basePlayer.transform.position - player.transform.position).sqrMagnitude <= localRange)
                        {
                            player.SendConsoleCommand("chat.add", (int)chatchannel, chatMessage.Player.Id, output.Chat);
                        }
                    }

                    break;
                
                default:
                    foreach (BasePlayer p in BasePlayer.activePlayerList.Where(p => !chatMessage.BlockedReceivers.Contains(p.UserIDString)))
                        p.SendConsoleCommand("chat.add", (int) chatchannel, chatMessage.Player.Id, output.Chat);
                    break;
            }
#else
            foreach (IPlayer p in players.Connected.Where(p => !chatMessage.BlockedReceivers.Contains(p.Id)))
                p.Message(output.Chat);
#endif

#if RUST
            Puts($"[{chatchannel}] {output.Console}");

            var chatEntry = new Chat.ChatEntry
            {
                Channel = chatchannel,
                Message = output.Console,
                UserId = chatMessage.Player.Id,
                Username = chatMessage.Player.Name,
                Color = chatMessage.UsernameSettings.Color,
                Time = Epoch.Current
            };

            Chat.Record(chatEntry);
#else
            Puts(output.Console);
#endif

            return chatMessage.CancelOption;
        }

        #endregion

        #region API

        private bool API_AddGroup(string group)
        {
            if (ChatGroup.Find(group) != null)
                return false;

            _chatGroups.Add(new ChatGroup(group));
            SaveData(_chatGroups);

            return true;
        }

        private List<JObject> API_GetAllGroups() => _chatGroups.ConvertAll(JObject.FromObject);

        private List<JObject> API_GetUserGroups(IPlayer player) => ChatGroup.GetUserGroups(player).ConvertAll(JObject.FromObject);

        private bool API_GroupExists(string group) => ChatGroup.Find(group) != null;

        private ChatGroup.Field.SetValueResult? API_SetGroupField(string group, string field, string value) => ChatGroup.Find(group)?.SetField(field, value);

        private Dictionary<string, object> API_GetGroupFields(string group) => ChatGroup.Find(group)?.GetFields() ?? new Dictionary<string, object>();

        private Dictionary<string, object> API_GetMessageData(IPlayer player, string message) => ChatGroup.PrepareMessage(player, message).ToDictionary();

        private string API_GetFormattedUsername(IPlayer player)
        {
            var primary = ChatGroup.GetUserPrimaryGroup(player);

            // Player has no groups - this should never happen
            if (primary == null)
                return player.Name;

            return $"[#{primary.Username.GetUniversalColor()}][+{primary.Username.Size}]{player.Name}[/+][/#]";
        }

        private string API_GetFormattedMessage(IPlayer player, string message, bool console = false)
        {
            var output = ChatGroup.PrepareMessage(player, message).GetOutput();

            return console ? output.Console : output.Chat;
        }

        private BetterChatMessage.CancelOptions API_SendMessage(Dictionary<string, object> betterChatMessageDict, int chatChannel = 0)
        {
#if RUST
            return SendBetterChatMessage(BetterChatMessage.FromDictionary(betterChatMessageDict), (Chat.ChatChannel)chatChannel);
#else
            return SendBetterChatMessage(BetterChatMessage.FromDictionary(betterChatMessageDict));
#endif
        }

        private void API_RegisterThirdPartyTitle(Plugin plugin, Func<IPlayer, string> titleGetter) => _thirdPartyTitles[plugin] = titleGetter;

        #endregion

        #region Commands

        [Command("chat"), Permission("betterchat.admin")]
        private void CmdChat(IPlayer player, string cmd, string[] args)
        {
            cmd = player.LastCommand == CommandType.Console ? cmd : $"/{cmd}";

            if (args.Length == 0)
            {
                player.Reply($"{cmd} group <add|remove|set|list>");
                player.Reply($"{cmd} user <add|remove>");
                return;
            }

            string argsStr = string.Join(" ", args);

            var commands = new Dictionary<string, Action<string[]>>
            {
                ["group add"] = a => {
                    if (a.Length != 1)
                    {
                        player.Reply($"Syntax: {cmd} group add <group>");
                        return;
                    }

                    string groupName = a[0].ToLower();

                    if (ChatGroup.Find(groupName) != null)
                    {
                        player.ReplyLang("Group Already Exists", new KeyValuePair<string, string>("group", groupName));
                        return;
                    }

                    ChatGroup group = new ChatGroup(groupName);

                    _chatGroups.Add(group);

                    if (!permission.GroupExists(group.GroupName))
                        permission.CreateGroup(group.GroupName, string.Empty, 0);

                    SaveData(_chatGroups);

                    player.ReplyLang("Group Added", new KeyValuePair<string, string>("group", groupName));
                },
                ["group remove"] = a => {
                    if (a.Length != 1)
                    {
                        player.Reply($"Syntax: {cmd} group remove <group>");
                        return;
                    }

                    string groupName = a[0].ToLower();
                    ChatGroup group = ChatGroup.Find(groupName);

                    if (group == null)
                    {
                        player.ReplyLang("Group Does Not Exist", new KeyValuePair<string, string>("group", groupName));
                        return;
                    }

                    _chatGroups.Remove(group);
                    SaveData(_chatGroups);

                    player.ReplyLang("Group Removed", new KeyValuePair<string, string>("group", groupName));
                },
                ["group set"] = a => {
                    if (a.Length != 3)
                    {
                        player.Reply($"Syntax: {cmd} group set <group> <field> <value>");
                        player.Reply($"Fields:{Environment.NewLine}{string.Join(", ", ChatGroup.Fields.Select(kvp => $"({kvp.Value.UserFriendyType}) {kvp.Key}").ToArray())}");
                        return;
                    }

                    string groupName = a[0].ToLower();
                    ChatGroup group = ChatGroup.Find(groupName);

                    if (group == null)
                    {
                        player.ReplyLang("Group Does Not Exist", new KeyValuePair<string, string>("group", groupName));
                        return;
                    }

                    string field = a[1];
                    string strValue = a[2];

                    switch (group.SetField(field, strValue))
                    {
                        case ChatGroup.Field.SetValueResult.Success:
                            SaveData(_chatGroups);
                            player.ReplyLang("Group Field Changed", new Dictionary<string, string> { ["group"] = group.GroupName, ["field"] = field, ["value"] = strValue });
                            break;

                        case ChatGroup.Field.SetValueResult.InvalidField:
                            player.ReplyLang("Invalid Field", new KeyValuePair<string, string>("field", field));
                            break;

                        case ChatGroup.Field.SetValueResult.InvalidValue:
                            player.ReplyLang("Invalid Value", new Dictionary<string, string> { ["field"] = field, ["value"] = strValue, ["type"] = ChatGroup.Fields[field].UserFriendyType });
                            break;
                    }
                },
                ["group list"] = a =>
                {
                    player.Reply(string.Join(", ", _chatGroups.Select(g => g.GroupName).ToArray()));
                },
                ["group"] = a => player.Reply($"Syntax: {cmd} group <add|remove|set|list>"),
                ["user add"] = a => {
                    if (a.Length != 2)
                    {
                        player.Reply($"Syntax: {cmd} user add <username|id> <group>");
                        return;
                    }

                    string response;
                    IPlayer targetPlayer = FindPlayer(a[0], out response);

                    if (targetPlayer == null)
                    {
                        player.Reply(response);
                        return;
                    }

                    string groupName = a[1].ToLower();
                    ChatGroup group = ChatGroup.Find(groupName);

                    if (group == null)
                    {
                        player.ReplyLang("Group Does Not Exist", new KeyValuePair<string, string>("group", groupName));
                        return;
                    }

                    if (permission.UserHasGroup(targetPlayer.Id, groupName))
                    {
                        player.ReplyLang("Player Already In Group", new Dictionary<string, string> { ["player"] = targetPlayer.Name, ["group"] = groupName });
                        return;
                    }

                    group.AddUser(targetPlayer);
                    player.ReplyLang("Added To Group", new Dictionary<string, string> { ["player"] = targetPlayer.Name, ["group"] = groupName });
                },
                ["user remove"] = a => {
                    if (a.Length != 2)
                    {
                        player.Reply($"Syntax: {cmd} user remove <username|id> <group>");
                        return;
                    }

                    string response;
                    IPlayer targetPlayer = FindPlayer(a[0], out response);

                    if (targetPlayer == null)
                    {
                        player.Reply(response);
                        return;
                    }

                    string groupName = a[1].ToLower();
                    ChatGroup group = ChatGroup.Find(groupName);

                    if (group == null)
                    {
                        player.ReplyLang("Group Does Not Exist", new KeyValuePair<string, string>("group", groupName));
                        return;
                    }

                    if (!permission.UserHasGroup(targetPlayer.Id, groupName))
                    {
                        player.ReplyLang("Player Not In Group", new Dictionary<string, string> { ["player"] = targetPlayer.Name, ["group"] = groupName });
                        return;
                    }

                    group.RemoveUser(targetPlayer);
                    player.ReplyLang("Removed From Group", new Dictionary<string, string> { ["player"] = targetPlayer.Name, ["group"] = groupName });
                },
                ["user"] = a => player.Reply($"Syntax: {cmd} user <add|remove>"),
                [string.Empty] = a =>
                {
                    player.Reply($"{cmd} group <add|remove|set|list>");
                    player.Reply($"{cmd} user <add|remove>");
                }
            };

            var command = commands.First(c => argsStr.ToLower().StartsWith(c.Key));

            string remainingArgs = argsStr.Remove(0, command.Key.Length);

            command.Value(remainingArgs.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).ToArray());
        }

        #endregion

        #region Helper and Wrapper Methods

        #region Player Lookup

        private IPlayer FindPlayer(string nameOrID, out string response)
        {
            response = null;

            if (IsConvertableTo<string, ulong>(nameOrID) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                IPlayer result = players.All.ToList().Find((p) => p.Id == nameOrID);

                if (result == null)
                    response = $"Could not find player with ID '{nameOrID}'";

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    response = $"Could not find player with name '{nameOrID}'";
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    response = "Multiple matching players found: \n" + string.Join(", ", names);
                    break;
            }

            return null;
        }

        #endregion

        #region Type Conversion

        private bool IsConvertableTo<TSource, TResult>(TSource s)
        {
            TResult result;
            return TryConvert(s, out result);
        }

        private bool TryConvert<TSource, TResult>(TSource s, out TResult c)
        {
            try
            {
                c = (TResult)Convert.ChangeType(s, typeof(TResult));
                return true;
            }
            catch
            {
                c = default(TResult);
                return false;
            }
        }

        #endregion

        #region Data

        private void LoadData<T>(ref T data, string filename = null) => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? Name);

        private void SaveData<T>(T data, string filename = null) => Core.Interface.Oxide.DataFileSystem.WriteObject(filename ?? Name, data);

        #endregion

        #region Formatting

        private static string StripRichText(string text)
        {
            foreach (var replacement in _stringReplacements)
                text = text.Replace(replacement, string.Empty);

            foreach (var replacement in _regexReplacements)
                text = replacement.Replace(text, string.Empty);

            return Formatter.ToPlaintext(text);
        }

        #endregion

        #region Message Wrapper

        public static string GetMessage(string key, string id) => _instance.lang.GetMessage(key, _instance, id);

        #endregion

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Group Already Exists"] = "Group '{group}' already exists.",
                ["Group Does Not Exist"] = "Group '{group}' doesn't exist.",
                ["Group Field Changed"] = "Changed {field} to {value} for group '{group}'.",
                ["Group Added"] = "Successfully added group '{group}'.",
                ["Group Removed"] = "Successfully removed group '{group}'.",
                ["Invalid Field"] = "{field} is not a valid field. Type 'chat group set' to list all existing fields.",
                ["Invalid Value"] = "'{value}' is not a correct value for field '{field}'! Should be a '{type}'.",
                ["Player Already In Group"] = "{player} already is in group '{group}'.",
                ["Added To Group"] = "{player} was added to group '{group}'.",
                ["Player Not In Group"] = "{player} is not in group '{group}'.",
                ["Removed From Group"] = "{player} was removed from group '{group}'."
            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Maximal Titles")]
            public int MaxTitles { get; set; } = 3;

            [JsonProperty("Maximal Characters Per Message")]
            public int MaxMessageLength { get; set; } = 128;

            [JsonProperty("Reverse Title Order")]
            public bool ReverseTitleOrder { get; set; } = false;
        }

        #endregion

        #region Group Structures

        public class BetterChatMessage
        {
            public IPlayer Player;
            public string Username;
            public string Message;
            public List<string> Titles;
            public string PrimaryGroup;
            public ChatGroup.UsernameSettings UsernameSettings;
            public ChatGroup.MessageSettings MessageSettings;
            public ChatGroup.FormatSettings FormatSettings;
            public List<string> BlockedReceivers = new List<string>();
            public CancelOptions CancelOption;

            public ChatGroup.FormatSettings GetOutput()
            {
                ChatGroup.FormatSettings output = new ChatGroup.FormatSettings();

                if (Message.Contains("[#") || Message.Contains("[+"))
                    Message = Message.Replace("[", string.Empty).Replace("]", string.Empty);

                if (Username.Contains("[#") || Username.Contains("[+"))
                    Username = Username.Replace("[", string.Empty).Replace("]", string.Empty);

                Dictionary<string, string> replacements = new Dictionary<string, string>
                {
                    ["Title"] = string.Join(" ", Titles.ToArray()),
                    ["Username"] = $"[#{UsernameSettings.GetUniversalColor()}][+{UsernameSettings.Size}]{Username}[/+][/#]",
                    ["Group"] = PrimaryGroup,
                    ["Message"] = $"[#{MessageSettings.GetUniversalColor()}][+{MessageSettings.Size}]{Message}[/+][/#]",
                    ["ID"] = Player.Id,
                    ["Time"] = DateTime.Now.TimeOfDay.ToString(),
                    ["Date"] = DateTime.Now.ToString()
                };

                output.Chat = FormatSettings.Chat;
                output.Console = FormatSettings.Console;

                foreach (var replacement in replacements)
                {
                    output.Console = StripRichText(output.Console.Replace($"{{{replacement.Key}}}", replacement.Value));
                    output.Chat = _instance.covalence.FormatText(output.Chat.Replace($"{{{replacement.Key}}}", replacement.Value));
                }

                if (output.Chat.StartsWith(" "))
                    output.Chat = output.Chat.Remove(0, 1);

                if (output.Console.StartsWith(" "))
                    output.Console = output.Console.Remove(0, 1);

                return output;
            }

            public static BetterChatMessage FromDictionary(Dictionary<string, object> dictionary)
            {
                var usernameSettings = dictionary[nameof(UsernameSettings)] as Dictionary<string, object>;
                var messageSettings = dictionary[nameof(MessageSettings)] as Dictionary<string, object>;
                var formatSettings = dictionary[nameof(FormatSettings)] as Dictionary<string, object>;

                return new BetterChatMessage
                {
                    Player = dictionary[nameof(Player)] as IPlayer,
                    Message = dictionary[nameof(Message)] as string,
                    Username = dictionary[nameof(Username)] as string,
                    Titles = dictionary[nameof(Titles)] as List<string>,
                    PrimaryGroup = dictionary[nameof(PrimaryGroup)] as string,
                    BlockedReceivers = dictionary[nameof(BlockedReceivers)] as List<string>,
                    UsernameSettings = new ChatGroup.UsernameSettings
                    {
                        Color = usernameSettings[nameof(ChatGroup.UsernameSettings.Color)] as string,
                        Size = (int)usernameSettings[nameof(ChatGroup.UsernameSettings.Size)]
                    },
                    MessageSettings = new ChatGroup.MessageSettings
                    {
                        Color = messageSettings[nameof(ChatGroup.MessageSettings.Color)] as string,
                        Size = (int)messageSettings[nameof(ChatGroup.MessageSettings.Size)]
                    },
                    FormatSettings = new ChatGroup.FormatSettings
                    {
                        Chat = formatSettings[nameof(ChatGroup.FormatSettings.Chat)] as string,
                        Console = formatSettings[nameof(ChatGroup.FormatSettings.Console)] as string
                    },
                    CancelOption = (CancelOptions) dictionary[nameof(CancelOption)]
                };
            }

            public Dictionary<string, object> ToDictionary() => new Dictionary<string, object>
            {
                [nameof(Player)] = Player,
                [nameof(Message)] = Message,
                [nameof(Username)] = Username,
                [nameof(Titles)] = Titles,
                [nameof(PrimaryGroup)] = PrimaryGroup,
                [nameof(BlockedReceivers)] = BlockedReceivers,
                [nameof(UsernameSettings)] = new Dictionary<string, object>
                {
                    [nameof(ChatGroup.UsernameSettings.Color)] = UsernameSettings.Color,
                    [nameof(ChatGroup.UsernameSettings.Size)] = UsernameSettings.Size
                },
                [nameof(MessageSettings)] = new Dictionary<string, object>
                {
                    [nameof(ChatGroup.MessageSettings.Color)] = MessageSettings.Color,
                    [nameof(ChatGroup.MessageSettings.Size)] = MessageSettings.Size
                },
                [nameof(FormatSettings)] = new Dictionary<string, object>
                {
                    [nameof(ChatGroup.FormatSettings.Chat)] = FormatSettings.Chat,
                    [nameof(ChatGroup.FormatSettings.Console)] = FormatSettings.Console
                },
                [nameof(CancelOption)] = CancelOption
            };

            public enum CancelOptions
            {
                None = 0,
                BetterChatOnly = 1,
                BetterChatAndDefault = 2
            }
        }

        public class ChatGroup
        {
            private static readonly ChatGroup _fallbackGroup = new ChatGroup("default");

#if RUST
            private static readonly ChatGroup _rustDeveloperGroup = new ChatGroup("rust_developer")
            {
                Priority = 100,
                Title =
                {
                    Text  = "[Rust Developer]",
                    Color = "#ffaa55"
                }
            };
#endif

            public string GroupName;
            public int Priority = 0;

            public TitleSettings Title = new TitleSettings();
            public UsernameSettings Username = new UsernameSettings();
            public MessageSettings Message = new MessageSettings();
            public FormatSettings Format = new FormatSettings();

            public ChatGroup(string name)
            {
                GroupName = name;
                Title = new TitleSettings(name);
            }

            public static readonly Dictionary<string, Field> Fields = new Dictionary<string, Field>(StringComparer.InvariantCultureIgnoreCase)
            {
                ["Priority"] = new Field(g => g.Priority, (g, v) => g.Priority = int.Parse(v), "number"),

                ["Title"] = new Field(g => g.Title.Text, (g, v) => g.Title.Text = v, "text"),
                ["TitleColor"] = new Field(g => g.Title.Color, (g, v) => g.Title.Color = v, "color"),
                ["TitleSize"] = new Field(g => g.Title.Size, (g, v) => g.Title.Size = int.Parse(v), "number"),
                ["TitleHidden"] = new Field(g => g.Title.Hidden, (g, v) => g.Title.Hidden = bool.Parse(v), "true/false"),
                ["TitleHiddenIfNotPrimary"] = new Field(g => g.Title.HiddenIfNotPrimary, (g, v) => g.Title.HiddenIfNotPrimary = bool.Parse(v), "true/false"),

                ["UsernameColor"] = new Field(g => g.Username.Color, (g, v) => g.Username.Color = v, "color"),
                ["UsernameSize"] = new Field(g => g.Username.Size, (g, v) => g.Username.Size = int.Parse(v), "number"),

                ["MessageColor"] = new Field(g => g.Message.Color, (g, v) => g.Message.Color = v, "color"),
                ["MessageSize"] = new Field(g => g.Message.Size, (g, v) => g.Message.Size = int.Parse(v), "number"),

                ["ChatFormat"] = new Field(g => g.Format.Chat, (g, v) => g.Format.Chat = v, "text"),
                ["ConsoleFormat"] = new Field(g => g.Format.Console, (g, v) => g.Format.Console = v, "text")
            };

            public static ChatGroup Find(string name) => _instance._chatGroups.Find(g => g.GroupName == name);

            public static List<ChatGroup> GetUserGroups(IPlayer player)
            {
                string[] oxideGroups = _instance.permission.GetUserGroups(player.Id);
                var groups = _instance._chatGroups.Where(g => oxideGroups.Any(name => g.GroupName.Equals(name, StringComparison.OrdinalIgnoreCase))).ToList();

#if RUST
                BasePlayer bPlayer = BasePlayer.Find(player.Id);

                if (bPlayer.IsValid() && DeveloperList.Contains(bPlayer.userID))
                    groups.Add(_rustDeveloperGroup);
#endif

                return groups;
            }

            public static ChatGroup GetUserPrimaryGroup(IPlayer player)
            {
                List<ChatGroup> groups = GetUserGroups(player);
                ChatGroup primary = null;

                foreach (ChatGroup group in groups)
                    if (primary == null || group.Priority < primary.Priority)
                        primary = group;

                return primary;
            }

            public static BetterChatMessage PrepareMessage(IPlayer player, string message)
            {
                ChatGroup primary = GetUserPrimaryGroup(player);
                List<ChatGroup> groups = GetUserGroups(player);

                if (primary == null)
                {
                    _instance.PrintWarning($"{player.Name} ({player.Id}) does not seem to be in any BetterChat group - falling back to internal default group! This should never happen! Please make sure you have a group called 'default'.");
                    primary = _fallbackGroup;
                    groups.Add(primary);
                }

                groups.Sort((a, b) => a.Priority.CompareTo(b.Priority));

                var titles = (from g in groups
                              where !g.Title.Hidden && !(g.Title.HiddenIfNotPrimary && primary != g)
                              select $"[#{g.Title.GetUniversalColor()}][+{g.Title.Size}]{g.Title.Text}[/+][/#]")
                              .ToList();

                titles = titles.GetRange(0, Math.Min(_instance._config.MaxTitles, titles.Count));

                if (_instance._config.ReverseTitleOrder)
                {
                    titles.Reverse();
                }

                foreach (var thirdPartyTitle in _instance._thirdPartyTitles)
                {
                    try
                    {
                        string title = thirdPartyTitle.Value(player);

                        if (!string.IsNullOrEmpty(title))
                            titles.Add(title);
                    }
                    catch (Exception ex)
                    {
                        _instance.PrintError($"Error when trying to get third-party title from plugin '{thirdPartyTitle.Key}'{Environment.NewLine}{ex}");
                    }
                }

                return new BetterChatMessage
                {
                    Player = player,
                    Username = StripRichText(player.Name),
                    Message = StripRichText(message),
                    Titles = titles,
                    PrimaryGroup = primary.GroupName,
                    UsernameSettings = primary.Username,
                    MessageSettings = primary.Message,
                    FormatSettings = primary.Format
                };
            }

            public void AddUser(IPlayer player) => _instance.permission.AddUserGroup(player.Id, GroupName);

            public void RemoveUser(IPlayer player) => _instance.permission.RemoveUserGroup(player.Id, GroupName);

            public Field.SetValueResult SetField(string field, string value)
            {
                if (!Fields.ContainsKey(field))
                    return Field.SetValueResult.InvalidField;

                try
                {
                    Fields[field].Setter(this, value);
                }
                catch (FormatException)
                {
                    return Field.SetValueResult.InvalidValue;
                }

                return Field.SetValueResult.Success;
            }

            public Dictionary<string, object> GetFields() => Fields.ToDictionary(field => field.Key, field => field.Value.Getter(this));

            public override int GetHashCode() => GroupName.GetHashCode();

            public class TitleSettings
            {
                public string Text = "[Player]";
                public string Color = "#55aaff";
                public int Size = 15;
                public bool Hidden = false;
                public bool HiddenIfNotPrimary = false;

                public string GetUniversalColor() => Color.StartsWith("#") ? Color.Substring(1) : Color;

                public TitleSettings(string groupName)
                {
                    if (groupName != "default" && groupName != null)
                        Text = $"[{groupName}]";
                }

                public TitleSettings()
                {
                }
            }

            public class UsernameSettings
            {
                public string Color = "#55aaff";
                public int Size = 15;

                public string GetUniversalColor() => Color.StartsWith("#") ? Color.Substring(1) : Color;
            }

            public class MessageSettings
            {
                public string Color = "white";
                public int Size = 15;

                public string GetUniversalColor() => Color.StartsWith("#") ? Color.Substring(1) : Color;
            }

            public class FormatSettings
            {
                public string Chat = "{Title} {Username}: {Message}";
                public string Console = "{Title} {Username}: {Message}";
            }

            public class Field
            {
                public Func<ChatGroup, object> Getter { get; }
                public Action<ChatGroup, string> Setter { get; }
                public string UserFriendyType { get; }

                public enum SetValueResult
                {
                    Success,
                    InvalidField,
                    InvalidValue
                }

                public Field(Func<ChatGroup, object> getter, Action<ChatGroup, string> setter, string userFriendyType)
                {
                    Getter = getter;
                    Setter = setter;
                    UserFriendyType = userFriendyType;
                }
            }
        }

        #endregion
    }
}

#region Extension Methods

namespace Oxide.Plugins.BetterChatExtensions
{
    internal static class IPlayerExtensions
    {
        public static void ReplyLang(this IPlayer player, string key, Dictionary<string, string> replacements = null)
        {
            string message = BetterChat.GetMessage(key, player.Id);

            if (replacements != null)
                foreach (var replacement in replacements)
                    message = message.Replace($"{{{replacement.Key}}}", replacement.Value);

            replacements = null;

            player.Reply(message);
        }

        public static void ReplyLang(this IPlayer player, string key, KeyValuePair<string, string> replacement)
        {
            string message = BetterChat.GetMessage(key, player.Id);
            message = message.Replace($"{{{replacement.Key}}}", replacement.Value);

            player.Reply(message);
        }
    }
}

#endregion

// --- End of file: BetterChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/barren-plus ---
// --- Original File Path: B/BarrenPlus/BarrenPlus.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Barren Plus", "Iv Misticos", "1.0.6")]
    [Description("Let JunkPiles and DiveSites be alive on Barren!")]
    class BarrenPlus : RustPlugin
    {
        #region Variables

        private int _size;

        private readonly string[] _prefabsJunkPile = { "assets/prefabs/misc/junkpile_water/junkpile_water_a.prefab", "assets/prefabs/misc/junkpile_water/junkpile_water_b.prefab", "assets/prefabs/misc/junkpile_water/junkpile_water_c.prefab" };
        private readonly string[] _prefabsDiveSite = { "assets/prefabs/misc/divesite/divesite_a.prefab", "assets/prefabs/misc/divesite/divesite_b.prefab", "assets/prefabs/misc/divesite/divesite_c.prefab" };

        private static readonly Random Random = new Random();
        
        #endregion
        
        #region Configuration
        
        private static Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Junk Pile Spawn Frequency")]
            public float JunkPileTime = 30;

            [JsonProperty(PropertyName = "Dive Site Spawn Frequency")]
            public float DiveSiteTime = 45;
            
            [JsonProperty(PropertyName = "Minimal Distance Between Junk Piles")]
            public int JunkPileRange = 50;

            [JsonProperty(PropertyName = "Minimal Distance Between Dive Sites")]
            public int DiveSiteRange = 50;

            [JsonProperty(PropertyName = "Minimal Distance Between Water And Terrain")]
            public int BetweenWaterTerrain = 20;

            [JsonProperty(PropertyName = "Maximal Dive Site Angle")]
            public int AngleMax = 20;

            [JsonProperty(PropertyName = "Dive Sites' Lifetime")]
            public int DiveSiteLife = 600;

            [JsonProperty(PropertyName = "Junk Piles' Lifetime")]
            public int JunkPileLife = 300;

            [JsonProperty(PropertyName = "Maximum Number Of Attempts To Find A Location")]
            public int LocAttemptsMax = 500;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);
        
        #endregion
        
        #region Hooks

        // ReSharper disable once UnusedMember.Local
        private void OnServerInitialized()
        {
            LoadConfig();
            _size = ConVar.Server.worldsize;
            
            timer.Every(_config.DiveSiteTime, () =>
            {
                for (var i = 1; i < _config.LocAttemptsMax; i++)
                {
                    if (SpawnDiveSite())
                        break;
                }
            });
            timer.Every(_config.JunkPileTime, () =>
            {
                for (var i = 1; i < _config.LocAttemptsMax; i++)
                {
                    if (SpawnJunkPileWater())
                        break;
                }
            });
        }
        
        #endregion
        
        #region Helpers

        private Vector3? GetPosition(bool onWater)
        {
            var x = Random.Next(-_size / 2, _size / 2);
            var z = Random.Next(-_size / 2, _size / 2);
            var v = new Vector3(x, 0, z);
            
            var terrain = (int) TerrainMeta.HeightMap.GetHeight(v);
            if (_config.BetweenWaterTerrain > -terrain)
                return null;

            v.y = onWater ? 0 : terrain;
            return v;
        }

        private Quaternion GetRotation(bool isJunkPile)
        {
            return Quaternion.Euler(isJunkPile ? 0 : Random.Next(-_config.AngleMax, _config.AngleMax),
                Random.Next(0, 360), isJunkPile ? 0 : Random.Next(-_config.AngleMax, _config.AngleMax));
        }

        private bool SpawnDiveSite()
        {
            var position = GetPosition(false);
            if (position == null)
                return false;

            var ds = new List<DiveSite>();
            Vis.Entities(position.Value, _config.DiveSiteRange, ds);
            if (ds.Count > 0)
                return false;

            var entity =
                GameManager.server.CreateEntity(_prefabsDiveSite[Random.Next(0, _prefabsDiveSite.Length - 1)],
                    position.Value, GetRotation(false)) as DiveSite;
            if (entity == null) return true;
            
            entity.gameObject.AddComponent<DiveSiteController>();
            entity.Spawn();
            return true;
        }

        private bool SpawnJunkPileWater()
        {
            var position = GetPosition(true);
            if (position == null)
                return false;

            var jp = new List<JunkPileWater>();
            Vis.Entities(position.Value, _config.JunkPileRange, jp);
            if (jp.Count > 0)
                return false;

            var entity = GameManager.server.CreateEntity(_prefabsJunkPile[Random.Next(0, _prefabsJunkPile.Length - 1)],
                position.Value, GetRotation(true)) as JunkPileWater;
            if (entity == null) return true;
            
            entity.gameObject.AddComponent<JunkPileWaterController>();
            entity.Spawn();
            return true;
        }

        #endregion
        
        #region Controllers

        public class DiveSiteController : MonoBehaviour
        {
            private float _lastTime = Time.realtimeSinceStartup;
            private DiveSite _ent;
            private bool _isDestroyed;

            private void Awake()
            {
                _ent = gameObject.GetComponent<DiveSite>();
            }
            
            private void FixedUpdate()
            {
                if (_isDestroyed)
                    return;

                var rt = Time.realtimeSinceStartup;
                if (_lastTime + _config.DiveSiteLife > rt)
                    return;

                _isDestroyed = true;
                _ent.SinkAndDestroy();
            }
        }

        public class JunkPileWaterController : MonoBehaviour
        {
            private float _lastTime = Time.realtimeSinceStartup;
            private JunkPileWater _ent;
            private bool _isDestroyed;

            private void Awake()
            {
                _ent = gameObject.GetComponent<JunkPileWater>();
            }
            
            private void FixedUpdate()
            {
                if (_isDestroyed)
                    return;
                
                var rt = Time.realtimeSinceStartup;
                if (_lastTime + _config.JunkPileLife > rt)
                    return;

                _isDestroyed = true;
                _ent.SinkAndDestroy();
            }
        }
        
        #endregion
    }
}

// --- End of file: BarrenPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-block-safe-zone ---
// --- Original File Path: B/BuildingBlockSafeZone/BuildingBlockSafeZone.cs ---

using Oxide.Core.Libraries;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Building Block Safe Zone", "Ryz0r", "1.0.3")]
    [Description("Prevents access to items in the hotbar while in a safe zone.")]
    public class BuildingBlockSafeZone : RustPlugin
    {
        private GameObject _privController = new GameObject();
        private static BuildingBlockSafeZone _plugin;
        private const string BypassPerm = "buildingblocksafezone.bypass";

        private void OnServerInitialized()
        {
            _privController.AddComponent<PrivilegeUpdater>();
            permission.RegisterPermission(BypassPerm, this);
        }
        
        private void Init() { _plugin = this; }
        
        private void Unload()
        {
            UnityEngine.Object.Destroy(_privController);

            _privController = null;
            _plugin = null;
        }
        
        private class PrivilegeUpdater : MonoBehaviour
        {
            private void Awake()
            {
                InvokeRepeating(nameof(OnTick), 0.90f, 0.90f);
            }

            private void OnTick()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (player == null || player.IsNpc) continue;
                    if (_plugin.permission.UserHasPermission(player.UserIDString, BypassPerm)) continue;
                    
                    player.inventory.containerBelt.capacity = player.IsBuildingBlocked() ? 0 : 6;
                    player.SendNetworkUpdateImmediate();
                }
            }
        }
    }
}

// --- End of file: BuildingBlockSafeZone.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-workbench ---
// --- Original File Path: B/BuildingWorkbench/BuildingWorkbench.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Building Workbench", "MJSU", "1.4.1")]
[Description("Extends the range of the workbench to work inside the entire building")]
public class BuildingWorkbench : RustPlugin
{
    #region Class Fields
    [PluginReference] private readonly Plugin GameTipAPI;

    private PluginConfig _pluginConfig; //Plugin Config

    private WorkbenchBehavior _wb;
    private GameObject _go;
    private BuildingWorkbenchTrigger _tb;

    private const string UsePermission = "buildingworkbench.use";
    private const string CancelCraftPermission = "buildingworkbench.cancelcraft";
    private const string AccentColor = "#de8732";

    private readonly List<ulong> _notifiedPlayer = new();
    private readonly Hash<ulong, PlayerData> _playerData = new();
    private readonly Hash<uint, BuildingData> _buildingData = new();
    private float _scanRange;
    private float _halfScanRange;

    private PhysicsScene _physics;
        
    //private static BuildingWorkbench _ins;
    #endregion

    #region Setup & Loading
    private void Init()
    {
        //_ins = this;
        permission.RegisterPermission(UsePermission, this);
        permission.RegisterPermission(CancelCraftPermission, this);
            
        Unsubscribe(nameof(OnEntitySpawned));
        Unsubscribe(nameof(OnEntityKill));

        _scanRange = _pluginConfig.BaseDistance;
        _halfScanRange = _scanRange / 2f;
    }
        
    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
            [LangKeys.Notification] = "Your workbench range has been increased to work inside your building",
            [LangKeys.CraftCanceled] = "Your workbench level has changed. Crafts that required a higher level have been cancelled."
        }, this);
    }
        
    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = Config.ReadObject<PluginConfig>();
        Config.WriteObject(_pluginConfig);
    }

    private void OnServerInitialized()
    {
        _physics = Physics.defaultPhysicsScene;
        if (_pluginConfig.BaseDistance < 3f)
        {
            PrintWarning("Distance from base to be considered inside building (Meters) cannot be less than 3 meters");
            _pluginConfig.BaseDistance = 3f;
        }
            
        _go = new GameObject("BuildingWorkbenchObject");
        _wb = _go.AddComponent<WorkbenchBehavior>();
        _tb = _go.AddComponent<BuildingWorkbenchTrigger>();

        foreach (BasePlayer player in BasePlayer.activePlayerList)
        {
            OnPlayerConnected(player);
        }
            
        _wb.InvokeRepeating(StartUpdatingWorkbench, 1f, _pluginConfig.UpdateRate);
             
        Subscribe(nameof(OnEntitySpawned));
        Subscribe(nameof(OnEntityKill));
    }

    private void OnPlayerConnected(BasePlayer player)
    {
        player.nextCheckTime = float.MaxValue;
        player.EnterTrigger(_tb);
    }
        
    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
        player.nextCheckTime = 0;
        player.cachedCraftLevel = 0;
        Hash<uint, BuildingData> playerData = _playerData[player.userID]?.BuildingData;
        if (playerData != null)
        {
            foreach (BuildingData data in playerData.Values)
            {
                data.LeaveBuilding(player);
            }
        }

        _playerData.Remove(player.userID);
        player.LeaveTrigger(_tb);
    }

    private void Unload()
    {
        foreach (BasePlayer player in BasePlayer.activePlayerList)
        {
            OnPlayerDisconnected(player, null);
        }

        if (_wb)
        {
            _wb.CancelInvoke(StartUpdatingWorkbench);
            _wb.StopAllCoroutines();
        }

        GameObject.Destroy(_go);
        //_ins = null;
    }
    #endregion

    #region Workbench Handler
    public void StartUpdatingWorkbench()
    {
        if (BasePlayer.activePlayerList.Count == 0)
        {
            return;
        }
            
        _wb.StartCoroutine(HandleWorkbenchUpdate());
    }

    public IEnumerator HandleWorkbenchUpdate()
    {
        float frameWait = 0;
        for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
        {
            BasePlayer player = BasePlayer.activePlayerList[i];

            if (!HasPermission(player, UsePermission))
            {
                if (player.nextCheckTime == float.MaxValue)
                {
                    player.nextCheckTime = 0;
                    player.cachedCraftLevel = 0;
                }
                    
                continue;
            }

            PlayerData data = GetPlayerData(player.userID);
            if (Vector3.Distance(player.transform.position, data.Position) < _pluginConfig.RequiredDistance)
            {
                continue;
            }

            if (player.triggers == null)
            {
                player.EnterTrigger(_tb);
            }

            data.Position = player.transform.position;
                
            UpdatePlayerBuildings(player, data);

            float waitForFrames = Performance.report.frameRate * _pluginConfig.UpdateRate / BasePlayer.activePlayerList.Count * 0.9f;
            if (waitForFrames >= 1)
            {
                yield return null;
                continue;
            }

            frameWait += waitForFrames;
            if (frameWait >= 1)
            {
                frameWait -= 1f;
                yield return null;
            }
        }
    }

    public void UpdatePlayerBuildings(BasePlayer player, PlayerData data)
    {
        List<uint> currentBuildings = Pool.Get<List<uint>>();

        if (_pluginConfig.FastBuildingCheck)
        {
            GetNearbyAuthorizedBuildingsFast(player, currentBuildings);
        }
        else
        {
            GetNearbyAuthorizedBuildings(player, currentBuildings);
        }

        List<uint> leftBuildings = Pool.Get<List<uint>>();
        foreach (uint buildingId in data.BuildingData.Keys)
        {
            if (!currentBuildings.Contains(buildingId))
            {
                leftBuildings.Add(buildingId);
            }
        }

        for (int index = 0; index < leftBuildings.Count; index++)
        {
            uint leftBuilding = leftBuildings[index];
            OnPlayerLeftBuilding(player, leftBuilding);
        }

        for (int index = 0; index < currentBuildings.Count; index++)
        {
            uint currentBuilding = currentBuildings[index];
            if (!data.BuildingData.ContainsKey(currentBuilding))
            {
                OnPlayerEnterBuilding(player, currentBuilding);
            }
        }

        UpdatePlayerWorkbenchLevel(player);
            
        //Puts($"{nameof(BuildingData)}.{nameof(UpdatePlayerPriv)} {player.displayName} In: {string.Join(",", currentBuildings.Select(b => b.ToString().ToArray()))} Left: {string.Join(",", leftBuildings.Select(b => b.ToString().ToArray()))}");
            
        Pool.FreeUnmanaged(ref currentBuildings);
        Pool.FreeUnmanaged(ref leftBuildings);
    }

    public void OnPlayerEnterBuilding(BasePlayer player, uint buildingId)
    {
        BuildingData building = GetBuildingData(buildingId);
        building.EnterBuilding(player);
        Hash<uint, BuildingData> playerBuildings = GetPlayerData(player.userID).BuildingData;
        playerBuildings[buildingId] = building;
    }

    public void OnPlayerLeftBuilding(BasePlayer player, uint buildingId)
    {
        BuildingData building = GetBuildingData(buildingId);
        building.LeaveBuilding(player);
        Hash<uint, BuildingData> playerBuildings = GetPlayerData(player.userID).BuildingData;
        if (!playerBuildings.Remove(buildingId))
        {
            return;
        }

        if (player.inventory.crafting.queue.Count != 0 && HasPermission(player, CancelCraftPermission))
        {
            bool canceled = false;
            foreach (ItemCraftTask task in player.inventory.crafting.queue)
            {
                if (player.cachedCraftLevel < task.blueprint.workbenchLevelRequired)
                {
                    player.inventory.crafting.CancelTask(task.taskUID);
                    canceled = true;
                }
            }
                
            if (canceled && _pluginConfig.CancelCraftNotification)
            {
                Chat(player, Lang(LangKeys.CraftCanceled, player));
            }
        }
    }
    #endregion

    #region Oxide Hooks
    private void OnEntitySpawned(Workbench bench)
    {
        //Needs to be in NextTick since other plugins can spawn Workbenches
        NextTick(() =>
        {
            BuildingData building = GetBuildingData(bench.buildingID);
            building.OnBenchBuilt(bench);
            UpdateBuildingPlayers(building);
            
            if (!_pluginConfig.BuiltNotification)
            {
                return;
            }
            
            BasePlayer player = BasePlayer.FindByID(bench.OwnerID);
            if (!player)
            {
                return;
            }

            if (!HasPermission(player, UsePermission))
            {
                return;
            }
            
            if (_notifiedPlayer.Contains(player.userID))
            {
                return;
            }
            
            _notifiedPlayer.Add(player.userID);
            
            if (GameTipAPI == null)
            {
                Chat(player, Lang(LangKeys.Notification, player));
            }
            else
            {
                GameTipAPI.Call("ShowGameTip", player, Lang(LangKeys.Notification, player), 6f);
            }
        });
    }

    private void OnEntityKill(Workbench bench)
    {
        BuildingData building = GetBuildingData(bench.buildingID);
        building.OnBenchKilled(bench);
        UpdateBuildingPlayers(building);
    }
        
    private void OnEntityKill(BuildingPrivlidge tc)
    {
        OnCupboardClearList(tc);
    }
        
    private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
    {
        OnPlayerEnterBuilding(player, privilege.buildingID);
        UpdatePlayerWorkbenchLevel(player);
    }
        
    private void OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
    {
        OnPlayerLeftBuilding(player, privilege.buildingID);
        UpdatePlayerWorkbenchLevel(player);
    }

    private void OnCupboardClearList(BuildingPrivlidge privilege)
    {
        BuildingData data = GetBuildingData(privilege.buildingID);
        for (int index = data.Players.Count - 1; index >= 0; index--)
        {
            BasePlayer player = data.Players[index];
            OnPlayerLeftBuilding(player, privilege.buildingID);
            UpdatePlayerWorkbenchLevel(player);
        }
    }
        
    private void OnEntityEnter(TriggerWorkbench trigger, BasePlayer player)
    {
        if (!player.IsNpc)
        {
            UpdatePlayerWorkbenchLevel(player);
        }
    }
        
    private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player)
    {
        if (!player.IsNpc)
        {
            NextTick(() =>
            {
                UpdatePlayerWorkbenchLevel(player);
            });
        }
    }
        
    private void OnEntityLeave(BuildingWorkbenchTrigger trigger, BasePlayer player)
    {
        if (player.IsNpc)
        {
            return;
        }
            
        //_ins.Puts($"{nameof(BuildingWorkbench)}.{nameof(OnEntityLeave)} {nameof(BuildingWorkbenchTrigger)} {player.displayName}");
            
        NextTick(() =>
        {
            player.EnterTrigger(_tb);
        });
    }
    #endregion

    #region Helper Methods
    public void UpdateBuildingPlayers(BuildingData building)
    {
        for (int index = 0; index < building.Players.Count; index++)
        {
            BasePlayer player = building.Players[index];
            UpdatePlayerWorkbenchLevel(player);
        }
    }
        
    public void UpdatePlayerWorkbenchLevel(BasePlayer player)
    {
        byte level = 0;
        Hash<uint, BuildingData> playerBuildings = _playerData[player.userID]?.BuildingData;
        if (playerBuildings != null)
        {
            foreach (BuildingData building in playerBuildings.Values)
            {
                level = Math.Max(level, building.GetBuildingLevel());
            }
        }
            
        if (level != 3 && player.triggers != null)
        {
            for (int index = 0; index < player.triggers.Count; index++)
            {
                TriggerWorkbench trigger = player.triggers[index] as TriggerWorkbench;
                if (trigger)
                {
                    level = Math.Max(level, (byte)trigger.parentBench.Workbenchlevel);
                }
            }
        }

        if ((byte)player.cachedCraftLevel == level)
        {
            return;
        }

        //_ins.Puts($"{nameof(BuildingWorkbench)}.{nameof(UpdatePlayerWorkbenchLevel)} {player.displayName} -> {level}");
        player.nextCheckTime = float.MaxValue;
        player.cachedCraftLevel = level;
        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, level == 1);
        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, level == 2);
        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, level == 3);
        player.SendNetworkUpdateImmediate();
    }
        
    public PlayerData GetPlayerData(ulong playerId)
    {
        PlayerData data = _playerData[playerId];
        if (data == null)
        {
            data = new PlayerData();
            _playerData[playerId] = data;
        }

        return data;
    }
        
    public BuildingData GetBuildingData(uint buildingId)
    {
        BuildingData data = _buildingData[buildingId];
        if (data == null)
        {
            data = new BuildingData(buildingId);
            _buildingData[buildingId] = data;
        }

        return data;
    }

    private readonly RaycastHit[] _hits = new RaycastHit[256];
    private readonly List<uint> _processedBuildings = new();
        
    public void GetNearbyAuthorizedBuildingsFast(BasePlayer player, List<uint> authorizedPrivs)
    {
        OBB obb = player.WorldSpaceBounds();
        float baseDistance = _scanRange;
        int amount = _physics.Raycast(player.transform.position + Vector3.down * _halfScanRange, Vector3.up, _hits, baseDistance, Rust.Layers.Construction, QueryTriggerInteraction.Ignore);
        for (int index = 0; index < amount; index++)
        {
            BuildingBlock block = _hits[index].transform.ToBaseEntity() as BuildingBlock;
            if (!block)
            {
                continue;
            }
                
            if (_processedBuildings.Contains(block.buildingID) || obb.Distance(block.WorldSpaceBounds()) > baseDistance)
            {
                continue;
            }
                
            _processedBuildings.Add(block.buildingID);
            BuildingPrivlidge priv = block.GetBuilding()?.GetDominatingBuildingPrivilege();
            if (!priv || !priv.IsAuthed(player))
            {
                continue;
            }
                
            authorizedPrivs.Add(priv.buildingID);
        }
        _processedBuildings.Clear();
    }
        
    public void GetNearbyAuthorizedBuildings(BasePlayer player, List<uint> authorizedPrivs)
    {
        OBB obb = player.WorldSpaceBounds();
        float baseDistance = _pluginConfig.BaseDistance;
        int amount = _physics.OverlapSphere(obb.position, baseDistance + obb.extents.magnitude, Vis.colBuffer, Rust.Layers.Construction, QueryTriggerInteraction.Ignore);
        for (int index = 0; index < amount; index++)
        {
            Collider collider = Vis.colBuffer[index];
            BuildingBlock block = collider.ToBaseEntity() as BuildingBlock;
            if (!block)
            {
                continue;
            }
                
            if (_processedBuildings.Contains(block.buildingID) || obb.Distance(block.WorldSpaceBounds()) > baseDistance)
            {
                continue;
            }
                
            _processedBuildings.Add(block.buildingID);
            BuildingPrivlidge priv = block.GetBuilding()?.GetDominatingBuildingPrivilege();
            if (!priv || !priv.IsAuthed(player))
            {
                continue;
            }
                
            authorizedPrivs.Add(priv.buildingID);
        }

        _processedBuildings.Clear();
    }

    public void Chat(BasePlayer player, string message) => PrintToChat(player, Lang(LangKeys.Chat, player, message));
        
    public bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        
    private string Lang(string key, BasePlayer player = null)
    {
        return lang.GetMessage(key, this, player?.UserIDString);
    }
        
    private string Lang(string key, BasePlayer player = null, params object[] args)
    {
        try
        {
            return string.Format(Lang(key, player), args);
        }
        catch (Exception ex)
        {
            PrintError($"Lang Key '{key}' threw exception\n:{ex}");
            throw;
        }
    }
    #endregion

    #region Building Data
    public class BuildingData
    {
        public uint BuildingId { get; }
        public Workbench BestWorkbench { get; set; }
        public List<BasePlayer> Players { get; } = new();
        public List<Workbench> Workbenches { get; }

        public BuildingData(uint buildingId)
        {
            BuildingId = buildingId;
            Workbenches = BuildingManager.server.GetBuilding(buildingId)?.decayEntities.OfType<Workbench>().ToList() ?? new List<Workbench>();
            UpdateBestBench();
        }

        public void EnterBuilding(BasePlayer player)
        {
            //_ins.Puts($"{nameof(BuildingData)}.{nameof(EnterBuilding)} {player.displayName}");
            Players.Add(player);
        }

        public void LeaveBuilding(BasePlayer player)
        {
            //_ins.Puts($"{nameof(BuildingData)}.{nameof(LeaveBuilding)} {player.displayName}");
            Players.Remove(player);
        }

        public void OnBenchBuilt(Workbench workbench)
        {
            Workbenches.Add(workbench);
            UpdateBestBench();
        }

        public void OnBenchKilled(Workbench workbench)
        {
            Workbenches.Remove(workbench);
            UpdateBestBench();
        }
            
        public byte GetBuildingLevel()
        {
            if (!BestWorkbench)
            {
                return 0;
            }

            return (byte)BestWorkbench.Workbenchlevel;
        }

        private void UpdateBestBench()
        {
            BestWorkbench = null;
            for (int index = 0; index < Workbenches.Count; index++)
            {
                Workbench workbench = Workbenches[index];
                if (!BestWorkbench || BestWorkbench.Workbenchlevel < workbench.Workbenchlevel)
                {
                    BestWorkbench = workbench;
                }
            }
        }
    }
    #endregion

    #region Classes
    private class PluginConfig
    {
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Display workbench built notification")]
        public bool BuiltNotification { get; set; }

        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Display cancel craft notification")]
        public bool CancelCraftNotification { get; set; }
            
        [DefaultValue(3f)]
        [JsonProperty(PropertyName = "Inside building check frequency (Seconds)")]
        public float UpdateRate { get; set; }
            
        [DefaultValue(false)]
        [JsonProperty(PropertyName = "Enable Fast Building Check (Only checks above and below a player)")]
        public bool FastBuildingCheck { get; set; }
            
        [DefaultValue(16f)]
        [JsonProperty(PropertyName = "Distance from base to be considered inside building (Meters)")]
        public float BaseDistance { get; set; }
            
        [DefaultValue(5)]
        [JsonProperty(PropertyName = "Required distance from last update (Meters)")]
        public float RequiredDistance { get; set; }
    }

    public class PlayerData
    {
        public Vector3 Position { get; set; }
        public Hash<uint, BuildingData> BuildingData { get; } = new();
    }

    private class LangKeys
    {
        public const string Chat = nameof(Chat);
        public const string Notification = nameof(Notification);
        public const string CraftCanceled = nameof(CraftCanceled) + "V1";
    }

    public class WorkbenchBehavior : FacepunchBehaviour
    {
            
    }

    public class BuildingWorkbenchTrigger : TriggerBase
    {
            
    }
    #endregion
}

// --- End of file: BuildingWorkbench.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-root-combiners ---
// --- Original File Path: B/BetterRootCombiners/BetterRootCombiners.cs ---

﻿namespace Oxide.Plugins
{
    [Info("Better Root Combiners", "WhiteThunder", "1.0.1")]
    [Description("Allows root combiners to accept input from any electrical source.")]
    internal class BetterRootCombiners : CovalencePlugin
    {
        private const string PermissionUse = "betterrootcombiners.use";
        private const string RootCombinerPrefab = "assets/prefabs/deployable/playerioents/gates/combiner/electrical.combiner.deployed.prefab";
        private uint RootCombinerPrefabId;

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            RootCombinerPrefabId = GameManager.server.FindPrefab(RootCombinerPrefab)
                ?.GetComponent<ElectricalCombiner>()?.prefabID ?? 0;

            if (RootCombinerPrefabId == 0)
            {
                LogError($"Unable to determine prefabID of {RootCombinerPrefab}");
                return;
            }

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var rootCombiner = entity as ElectricalCombiner;
                if (rootCombiner == null)
                    continue;

                OnEntitySpawned(rootCombiner);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(ElectricalCombiner combiner)
        {
            if (combiner.prefabID != RootCombinerPrefabId)
                return;

            var rootConnectionsOnly = combiner.OwnerID == 0
                || !permission.UserHasPermission(combiner.OwnerID.ToString(), PermissionUse);

            foreach (var input in combiner.inputs)
            {
                input.rootConnectionsOnly = rootConnectionsOnly;
            }
        }
    }
}


// --- End of file: BetterRootCombiners.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-researching ---
// --- Original File Path: B/BetterResearching/BetterResearching.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Researching", "Arainrr", "1.1.5")]
    [Description("Modify research time, cost, chance")]
    public class BetterResearching : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin PopupNotifications, RustTranslationAPI;

        private static BetterResearching instance;
        private const string PREFAB_RESEARCH_TABLE = "assets/prefabs/deployable/research table/researchtable_deployed.prefab";

        private ItemDefinition researchResource;
        private ItemDefinition defaultResearchResource;
        private readonly Hash<ResearchTable, BasePlayer> researchers = new Hash<ResearchTable, BasePlayer>();
        private readonly Hash<ResearchTable, HashSet<BasePlayer>> lootingPlayers = new Hash<ResearchTable, HashSet<BasePlayer>>();

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            instance = this;
            Unsubscribe(nameof(OnItemSplit));
            Unsubscribe(nameof(CanAcceptItem));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnItemRemovedFromContainer));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            Subscribe(nameof(OnItemSplit));
            Subscribe(nameof(CanAcceptItem));
            Subscribe(nameof(OnItemRemovedFromContainer));
            if (configData.researchResource != "scrap")
            {
                researchResource = ItemManager.FindItemDefinition(configData.researchResource);
                if (researchResource != null)
                {
                    Subscribe(nameof(OnEntitySpawned));
                    foreach (var researchTable in BaseNetworkable.serverEntities.OfType<ResearchTable>())
                    {
                        if (defaultResearchResource != null)
                        {
                            defaultResearchResource = researchTable.researchResource;
                        }
                        OnEntitySpawned(researchTable);
                    }
                }
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                var researchTable = player.inventory?.loot?.entitySource as ResearchTable;
                if (researchTable != null)
                {
                    OnLootEntity(player, researchTable);
                }
            }
        }

        private void OnEntitySpawned(ResearchTable researchTable)
        {
            if (researchTable == null) return;
            researchTable.researchResource = researchResource;
            researchTable.SendNetworkUpdateImmediate();
        }

        private void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyAllUI(player);
            }
            if (configData.researchResource != "scrap")
            {
                researchResource = defaultResearchResource;
                foreach (var researchTable in BaseNetworkable.serverEntities.OfType<ResearchTable>())
                    OnEntitySpawned(researchTable);
            }
            instance = null;
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private object CanResearchItem(BasePlayer player, Item targetItem)
        {
            ConfigData.ResearchSettings researchS;
            if (configData.researchS.TryGetValue(targetItem.info.shortname, out researchS))
            {
                if (!researchS.canResearch)
                {
                    SendMessage(player, Lang("IsBlocked", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName)));
                    return false;
                }
                var scrapItem = GetScrapItem(targetItem.parent?.entityOwner as ResearchTable);
                if (scrapItem == null) return null;
                if (scrapItem.amount < researchS.scrapAmount)
                {
                    SendMessage(player, Lang("ResearchCantAfford", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName), researchS.scrapAmount));
                    return false;
                }
            }
            return null;
        }

        private void OnItemResearch(ResearchTable researchTable, Item targetItem, BasePlayer player)
        {
            researchers[researchTable] = player;
            ConfigData.ResearchSettings researchS;
            if (configData.researchS.TryGetValue(targetItem.info.shortname, out researchS))
            {
                if (!researchS.canResearch) return;
                researchTable.researchDuration = researchS.researchTime;
                if (researchS.researchTime > 0)
                {
                    float timeLeft;
                    Timer researchTimer = null;
                    researchTimer = timer.Repeat(0.1f, (int)(researchS.researchTime / 0.1f) + 10, () =>
                    {
                        if (researchTable == null || researchTable.IsDestroyed)
                        {
                            researchTimer?.Destroy();
                            return;
                        }
                        timeLeft = researchTable.researchFinishedTime - Time.realtimeSinceStartup;
                        if (timeLeft <= 0)
                        {
                            researchTimer?.Destroy();
                            UpdateUI(researchTable.inventory, null);
                            return;
                        }

                        HashSet<BasePlayer> looters;
                        if (lootingPlayers.TryGetValue(researchTable, out looters))
                        {
                            foreach (var p in looters)
                            {
                                CreateResearchUI(p, timeLeft.ToString("0.00"), configData.uiS.researchTimeleftTextSize);
                            }
                        }
                        else if (player != null && player.inventory?.loot?.entitySource == researchTable)
                        {
                            CreateResearchUI(player, timeLeft.ToString("0.00"), configData.uiS.researchTimeleftTextSize);
                        }
                    });
                }
            }
        }

        private object OnItemResearched(ResearchTable researchTable, int chance)
        {
            var targetItem = researchTable.GetTargetItem();
            ConfigData.ResearchSettings researchS;
            if (configData.researchS.TryGetValue(targetItem.info.shortname, out researchS))
            {
                if (!researchS.canResearch) return null;
                BasePlayer researcher;
                if (researchers.TryGetValue(researchTable, out researcher))
                {
                    researchers.Remove(researchTable);
                }
                else
                {
                    researcher = researchTable.user;
                }

                HashSet<BasePlayer> players;
                if (!lootingPlayers.TryGetValue(researchTable, out players))
                {
                    players = new HashSet<BasePlayer> { researcher };
                }

                if (UnityEngine.Random.Range(0f, 100f) < researchS.successChance)
                {
                    foreach (var player in players)
                    {
                        if (player == null) continue;
                        SendMessage(player, Lang("ResearchSuccess", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName)));
                    }
                    return researchS.scrapAmount;
                }
                else
                {
                    var scrapItem = researchTable.GetScrapItem();
                    TryConsumeItem(researcher, scrapItem, targetItem, researchS, players);
                    return scrapItem.amount + 1;
                }
            }
            return null;
        }

        private void OnLootEntity(BasePlayer player, ResearchTable researchTable)
        {
            if (player == null || researchTable == null) return;
            HashSet<BasePlayer> looters;
            if (!lootingPlayers.TryGetValue(researchTable, out looters))
            {
                looters = new HashSet<BasePlayer> { player };
                lootingPlayers.Add(researchTable, looters);
            }
            else
            {
                looters.Add(player);
            }
            UpdateUI(researchTable.inventory, null);
        }

        private void OnLootEntityEnd(BasePlayer player, ResearchTable researchTable)
        {
            if (player == null || researchTable == null) return;
            HashSet<BasePlayer> players;
            if (lootingPlayers.TryGetValue(researchTable, out players))
            {
                players.Remove(player);
                if (players.Count <= 0)
                {
                    lootingPlayers.Remove(researchTable);
                }
                DestroyAllUI(player);
            }
        }

        private void OnItemSplit(Item item, int splitAmount) => NextTick(() => UpdateUI(null, item));

        private void CanAcceptItem(ItemContainer itemContainer, Item item, int targetPos) => NextTick(() => UpdateUI(itemContainer, item));

        private void OnItemRemovedFromContainer(ItemContainer itemContainer, Item item) => NextTick(() => UpdateUI(itemContainer, item));

        #endregion Oxide Hooks

        #region Methods

        private void UpdateConfig()
        {
            var researchTable = GameManager.server.FindPrefab(PREFAB_RESEARCH_TABLE)?.GetComponent<ResearchTable>();
            if (researchTable == null) return;
            var newResearchS = new Dictionary<string, ConfigData.ResearchSettings>();
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var item = ItemManager.CreateByItemID(itemDefinition.itemid);
                if (researchTable.IsItemResearchable(item))
                {
                    ConfigData.ResearchSettings researchS;
                    if (configData.researchS.TryGetValue(item.info.shortname, out researchS))
                    {
                        newResearchS.Add(itemDefinition.shortname, researchS);
                    }
                    else
                    {
                        newResearchS.Add(itemDefinition.shortname, new ConfigData.ResearchSettings
                        {
                            displayName = itemDefinition.displayName.english,
                            scrapAmount = ResearchTable.ScrapForResearch(item),
                            itemConsumedSettings = new Dictionary<int, ConfigData.ConsumeSettings>
                            {
                                [1] = new ConfigData.ConsumeSettings()
                            }
                        });
                    }
                }
                item.Remove();
            }
            ItemManager.DoRemoves();
            configData.researchS = newResearchS;
            SaveConfig();
        }

        private void UpdateUI(ItemContainer itemContainer, Item item)
        {
            var researchTable = itemContainer?.entityOwner as ResearchTable;
            if (researchTable == null)
            {
                researchTable = item?.parent?.entityOwner as ResearchTable;
            }

            if (researchTable == null) return;
            int scrapAmount = 0;
            bool flag = CanResearch(researchTable, ref scrapAmount);
            HashSet<BasePlayer> looters;
            if (lootingPlayers.TryGetValue(researchTable, out looters))
            {
                foreach (var player in looters)
                {
                    CreateCostUI(player, scrapAmount);
                    if (!researchTable.IsResearching())
                        CreateResearchUI(player, flag ? string.Empty : Lang("CantResearch", player.UserIDString));
                }
            }
        }

        private bool CanResearch(ResearchTable researchTable, ref int scrapAmount)
        {
            var targetItem = researchTable.GetTargetItem();
            if (targetItem != null && targetItem.amount <= 1 && !targetItem.isBroken && researchTable.IsItemResearchable(targetItem))
            {
                ConfigData.ResearchSettings researchS;
                if (configData.researchS.TryGetValue(targetItem.info.shortname, out researchS))
                {
                    if (researchS.canResearch)
                    {
                        scrapAmount = researchS.scrapAmount;
                        var scrapItem = GetScrapItem(researchTable);
                        if (scrapItem != null && scrapItem.amount >= researchS.scrapAmount)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        private void TryConsumeItem(BasePlayer researcher, Item scrapItem, Item targetItem, ConfigData.ResearchSettings researchS, HashSet<BasePlayer> players)
        {
            var failures = GetNumberOfFailures(researcher.userID, targetItem.info.shortname);
            var consumeS = GetConsumeSettings(researchS, failures);
            if (UnityEngine.Random.Range(0f, 100f) < consumeS.scrapChance)
            {
                if (consumeS.scrapPercentage > 0)
                {
                    var amount = (int)Math.Round(researchS.scrapAmount * consumeS.scrapPercentage / 100);
                    TakeItem(scrapItem, amount);
                    foreach (var player in players)
                    {
                        if (player == null) continue;
                        CreateResearchUI(player);
                        SendMessage(player, Lang("ResearchFailedScrap", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName), amount));
                    }
                }
                else
                {
                    foreach (var player in players)
                    {
                        if (player == null) continue;
                        CreateResearchUI(player);
                        SendMessage(player, Lang("ResearchFailed", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName)));
                    }
                }
            }

            if (UnityEngine.Random.Range(0f, 100f) < consumeS.targetItemChance)
            {
                TakeItem(targetItem, targetItem.amount);
                foreach (var player in players)
                {
                    if (player == null) continue;
                    CreateResearchUI(player);
                    SendMessage(player, Lang("ResearchFailedTargetItem", player.UserIDString, GetItemDisplayName(player, targetItem.info, researchS.displayName)));
                }
            }
        }

        private int GetNumberOfFailures(ulong playerID, string shortname)
        {
            Dictionary<string, int> data;
            if (!storedData.playerResearchFailures.TryGetValue(playerID, out data))
            {
                data = new Dictionary<string, int>();
                storedData.playerResearchFailures.Add(playerID, data);
            }

            int failures;
            if (!data.TryGetValue(shortname, out failures))
            {
                failures = 1;
                data.Add(shortname, failures);
            }
            else
            {
                failures++;
                data[shortname] = failures;
            }
            return failures;
        }

        private static void DoResearch(ResearchTable researchTable, BasePlayer player)
        {
            BaseEntity.RPCMessage rpcMessage = default(BaseEntity.RPCMessage);
            rpcMessage.player = player;
            researchTable.DoResearch(rpcMessage);
        }

        private static Item GetScrapItem(ResearchTable researchTable)
        {
            var slot = researchTable?.inventory?.GetSlot(1);
            if (slot == null || slot.info != researchTable.researchResource)
                return null;
            return slot;
        }

        private static void TakeItem(Item item, int amount)
        {
            if (item.amount <= amount)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else item.UseItem(amount);
        }

        private static ConfigData.ConsumeSettings GetConsumeSettings(ConfigData.ResearchSettings researchS, int failures)
        {
            return researchS.itemConsumedSettings.OrderByDescending(x => x.Key).FirstOrDefault(x => x.Key <= failures).Value;
        }

        private void SendMessage(BasePlayer player, string message)
        {
            if (configData.chatS.usePop && PopupNotifications != null) CreatePopupNotification(message, player);
            else Print(player, message);
        }

        private void CreatePopupNotification(string message, BasePlayer player = null, float duration = 0f) => PopupNotifications?.Call("CreatePopupNotification", message, player, duration);

        #region RustTranslationAPI

        private string GetItemTranslationByShortName(string language, string itemShortName) => (string)RustTranslationAPI.Call("GetItemTranslationByShortName", language, itemShortName);

        private string GetItemDisplayName(BasePlayer player, ItemDefinition itemDefinition, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                var displayName1 = GetItemTranslationByShortName(lang.GetLanguage(player.UserIDString), itemDefinition.shortname);
                if (!string.IsNullOrEmpty(displayName1))
                {
                    return displayName1;
                }
            }

            return displayName;
        }

        #endregion RustTranslationAPI

        #endregion Methods

        #region UI

        private const string UINAME_COST = "ResearchUI_Cost";
        private const string UINAME_RESEARCH = "ResearchUI_Research";

        public class UI
        {
            public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin, string offsetMax, bool cursor = false)
            {
                return new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = backgroundColor },
                            RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax ,OffsetMin = offsetMin,OffsetMax = offsetMax},
                            CursorEnabled = cursor
                        },  parent,  panelName
                    }
                };
            }

            public static void CreateLabel(ref CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align = TextAnchor.MiddleCenter, float fadeIn = 0f)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = textColor, FontSize = fontSize, Align = align, Text = text, FadeIn = fadeIn },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
                }, panelName, CuiHelper.GetGuid());
            }

            public static void CreateButton(ref CuiElementContainer container, string panelName, string buttonColor, string command, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align = TextAnchor.MiddleCenter, float fadeIn = 0f)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = buttonColor, Command = command },
                    RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
                    Text = { Color = textColor, Text = text, FontSize = fontSize, Align = align, FadeIn = fadeIn }
                }, panelName, CuiHelper.GetGuid());
            }
        }

        private static void CreateResearchUI(BasePlayer player, string message = "", int fontSize = 0)
        {
            if (player == null) return;
            var container = UI.CreateElementContainer("Overlay", UINAME_RESEARCH, instance.configData.uiS.researchBackgroundColor, "0.5 0", "0.5 0", "436 116", "565 148");
            if (string.IsNullOrEmpty(message)) UI.CreateButton(ref container, UINAME_RESEARCH, "0 0 0 0", "ResearchUI_DoResearch", instance.configData.uiS.researchTextColor, instance.Lang("CanResearch", player.UserIDString), instance.configData.uiS.researchTextSize, "0 0", "1 1");
            else UI.CreateLabel(ref container, UINAME_RESEARCH, instance.configData.uiS.researchTextColor, message, fontSize == 0 ? instance.configData.uiS.researchTextSize : fontSize, "0 0", "1 1");
            CuiHelper.DestroyUi(player, UINAME_RESEARCH);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateCostUI(BasePlayer player, int scrapAmount)
        {
            if (player == null) return;
            string message = scrapAmount > 0 ? scrapAmount.ToString() : "N/A";
            var container = UI.CreateElementContainer("Overlay", UINAME_COST, instance.configData.uiS.researchCostBackgroundColor, "0.5 0", "0.5 0", "445 292", "572 372");
            UI.CreateLabel(ref container, UINAME_COST, instance.configData.uiS.researchCostTextColor, message, instance.configData.uiS.researchCostTextSize, "0 0", "1 1");
            CuiHelper.DestroyUi(player, UINAME_COST);
            CuiHelper.AddUi(player, container);
        }

        private static void DestroyAllUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UINAME_COST);
            CuiHelper.DestroyUi(player, UINAME_RESEARCH);
        }

        #endregion UI

        #region Commands

        [ConsoleCommand("ResearchUI_DoResearch")]
        private void CCmdDoResearch(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var researchTable = player.inventory?.loot?.entitySource as ResearchTable;
            int scrapAmount = 0;
            if (researchTable != null && CanResearch(researchTable, ref scrapAmount))
            {
                DoResearch(researchTable, player);
            }
        }

        [ConsoleCommand("br.lvl")]
        private void CCmdResearchS(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.HasArgs(3) && arg.IsAdmin)
            {
                int level;
                if (int.TryParse(arg.Args[0], out level))
                {
                    var blueprintLevels = ItemManager.GetBlueprints().GroupBy(x => x.workbenchLevelRequired).ToDictionary(x => x.Key, y => y.Select(x => x.targetItem.shortname));
                    IEnumerable<string> itemBlueprints;
                    if (blueprintLevels.TryGetValue(level, out itemBlueprints))
                    {
                        switch (arg.Args[1].ToLower())
                        {
                            case "cost":
                                int cost;
                                if (!int.TryParse(arg.Args[2], out cost) || cost <= 0) break;
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                        entry.Value.scrapAmount = cost;
                                }
                                Print(arg, $"Successfully modified the research cost of level {level} workbench items.");
                                SaveConfig();
                                return;

                            case "time":
                                float time;
                                if (!float.TryParse(arg.Args[2], out time) || time < 0) break;
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                        entry.Value.researchTime = time;
                                }
                                Print(arg, $"Successfully modified the research time of level {level} workbench items.");
                                SaveConfig();
                                return;

                            case "successchance":
                                float chance;
                                if (!float.TryParse(arg.Args[2], out chance) || chance < 0) break;
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                        entry.Value.successChance = chance;
                                }
                                Print(arg, $"Successfully modified the chance of research success of level {level} workbench items.");
                                SaveConfig();
                                return;

                            case "scrapchance":
                                var scrapChances = new Dictionary<int, float>();
                                for (int i = 2; i < arg.Args.Length; i++)
                                {
                                    float value;
                                    if (float.TryParse(arg.Args[i], out value) && value >= 0)
                                    {
                                        scrapChances.Add(i - 1, value);
                                    }
                                }
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                    {
                                        foreach (var entry1 in scrapChances)
                                        {
                                            ConfigData.ConsumeSettings consumeS;
                                            if (entry.Value.itemConsumedSettings.TryGetValue(entry1.Key, out consumeS))
                                            {
                                                consumeS.scrapChance = entry1.Value;
                                            }
                                            else
                                            {
                                                consumeS = new ConfigData.ConsumeSettings { scrapChance = entry1.Value };
                                                entry.Value.itemConsumedSettings.Add(entry1.Key, consumeS);
                                            }
                                        }
                                    }
                                }
                                Print(arg, $"Successfully modified the chance of scrap consumed when research fails in level {level} workbench items.");
                                SaveConfig();
                                return;

                            case "scrappercentage":
                                var scrapPercentages = new Dictionary<int, float>();
                                for (int i = 2; i < arg.Args.Length; i++)
                                {
                                    float value;
                                    if (float.TryParse(arg.Args[i], out value) && value >= 0)
                                    {
                                        scrapPercentages.Add(i - 1, value);
                                    }
                                }
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                    {
                                        foreach (var entry1 in scrapPercentages)
                                        {
                                            ConfigData.ConsumeSettings consumeS;
                                            if (entry.Value.itemConsumedSettings.TryGetValue(entry1.Key, out consumeS))
                                            {
                                                consumeS.scrapPercentage = entry1.Value;
                                            }
                                            else
                                            {
                                                consumeS = new ConfigData.ConsumeSettings { scrapPercentage = entry1.Value };
                                                entry.Value.itemConsumedSettings.Add(entry1.Key, consumeS);
                                            }
                                        }
                                    }
                                }
                                Print(arg, $"Successfully modified the percentage of scrap amount consumed when research fails in level {level} workbench items.");
                                SaveConfig();
                                return;

                            case "targetitemchance":
                                var targetItemChances = new Dictionary<int, float>();
                                for (int i = 2; i < arg.Args.Length; i++)
                                {
                                    float value;
                                    if (float.TryParse(arg.Args[i], out value) && value >= 0)
                                    {
                                        targetItemChances.Add(i - 1, value);
                                    }
                                }
                                foreach (var entry in configData.researchS)
                                {
                                    if (itemBlueprints.Contains(entry.Key))
                                    {
                                        foreach (var entry1 in targetItemChances)
                                        {
                                            ConfigData.ConsumeSettings consumeS;
                                            if (entry.Value.itemConsumedSettings.TryGetValue(entry1.Key, out consumeS))
                                            {
                                                consumeS.targetItemChance = entry1.Value;
                                            }
                                            else
                                            {
                                                consumeS = new ConfigData.ConsumeSettings { targetItemChance = entry1.Value };
                                                entry.Value.itemConsumedSettings.Add(entry1.Key, consumeS);
                                            }
                                        }
                                    }
                                }
                                Print(arg, $"Successfully modified the chance of target item consumed when research fails in level {level} workbench items.");
                                SaveConfig();
                                return;
                        }
                    }
                }
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.AppendLine("Syntax error");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <cost> <(cost amount)> - Modify the research cost of level N workbench items. e.g.: 'br.lvl 3 cost 750'");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <time> <(research time)> - Modify the research time of level N workbench items. e.g.: 'br.lvl 3 time 2'");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <successChance> <(success chance)> - Modify the chance of research success of level N workbench items. e.g.: 'br.lvl 3 successChance 50'");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <scrapChance> [Chance of first failure] [Chance of second failure]... - Modify the chance of scrap consumed when research fails of level N workbench items. e.g.: 'br.lvl 3 scrapChance 50' or 'br.lvl 3 scrapChance 50 20'");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <scrapPercentage> [Percentage of first failure] [Percentage of second failure]... - Modify the percentage of scrap amount consumed when research fails of level N workbench items. e.g.: 'br.lvl 3 scrapPercentage 50' or 'br.lvl 3 scrapPercentage 50 20'");
            stringBuilder.AppendLine("br.lvl <WorkBenchLevel (0~3)> <targetItemChance> [Chance of first failure] [Chance of second failure]... - Modify the chance of target item consumed when research fails of level N workbench items. e.g.: 'br.lvl 3 targetItemChance 50' or 'br.lvl 3 targetItemChance 50 20'");
            Print(arg, stringBuilder.ToString());
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Research Resource (Item Short Name)")]
            public string researchResource = "scrap";

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty(PropertyName = "Research UI Settings")]
            public UISettings uiS = new UISettings();

            [JsonProperty(PropertyName = "Research Settings")]
            public Dictionary<string, ResearchSettings> researchS = new Dictionary<string, ResearchSettings>();

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Use PopupNotifications")]
                public bool usePop;

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[BetterResearching]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon;
            }

            public class UISettings
            {
                [JsonProperty(PropertyName = "Research - Box - Background Color")]
                public string researchBackgroundColor = "0.42 0.52 0.25 0.98";

                [JsonProperty(PropertyName = "Research - Text - Text Color")]
                public string researchTextColor = "0 0 0 1";

                [JsonProperty(PropertyName = "Research - Text - Text Size")]
                public int researchTextSize = 16;

                [JsonProperty(PropertyName = "Research - Text - Timeleft Text Size")]
                public int researchTimeleftTextSize = 26;

                [JsonProperty(PropertyName = "ResearchCost - Box - Background Color")]
                public string researchCostBackgroundColor = "0 0 0 0.98";

                [JsonProperty(PropertyName = "ResearchCost - Text - Text Color")]
                public string researchCostTextColor = "1 0 0 1";

                [JsonProperty(PropertyName = "ResearchCost - Text - Text Size")]
                public int researchCostTextSize = 50;
            }

            public class ResearchSettings
            {
                [JsonProperty(PropertyName = "Can Research")]
                public bool canResearch = true;

                [JsonProperty(PropertyName = "Display Name")]
                public string displayName = string.Empty;

                [JsonProperty(PropertyName = "Research Cost")]
                public int scrapAmount;

                [JsonProperty(PropertyName = "Research Time")]
                public float researchTime = 10f;

                [JsonProperty(PropertyName = "Research Success Chance")]
                public float successChance = 100f;

                [JsonProperty(PropertyName = "Item Consumed When Research Fails")]
                public Dictionary<int, ConsumeSettings> itemConsumedSettings = new Dictionary<int, ConsumeSettings>();
            }

            public class ConsumeSettings
            {
                [JsonProperty(PropertyName = "Scrap Consumed Chance")]
                public float scrapChance = 100f;

                [JsonProperty(PropertyName = "Percentage Of Scrap Amount Consumed")]
                public float scrapPercentage = 100f;

                [JsonProperty(PropertyName = "Target Item Consumed Chance")]
                public float targetItemChance = 0f;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, Dictionary<string, int>> playerResearchFailures = new Dictionary<ulong, Dictionary<string, int>>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }

            if (storedData == null)
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void OnNewSave(string filename) => ClearData();

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);

        private void Print(ConsoleSystem.Arg arg, string message)
        {
            var player = arg?.Player();
            if (player == null) Puts(message);
            else PrintToConsole(player, message);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ResearchFailed"] = "Researching <color=#FF8C00>{0}</color> failed",
                ["ResearchFailedScrap"] = "Researching <color=#FF8C00>{0}</color> failed，Consumed {1} Scrap",
                ["ResearchFailedTargetItem"] = "Researching <color=#FF8C00>{0}</color> failed，target item is consumed",
                ["ResearchSuccess"] = "Researched <color=#7FFF00>{0}</color> successfully ",
                ["ResearchCantAfford"] = "You don't have enough Scrap to research {0}. This item's research cost is {1} Scrap",
                ["IsBlocked"] = "<color=#1E90FF>{0}</color> is blocked, cannot research",
                ["CantResearch"] = "CANT RESEARCH",
                ["CanResearch"] = "BEGIN RESEARCH",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ResearchFailed"] = "<color=#FF8C00>{0}</color> 研究失败",
                ["ResearchFailedAmount"] = "<color=#FF8C00>{0}</color> 研究失败，浪费了 {1} 个废料",
                ["ResearchFailedTargetItem"] = "<color=#FF8C00>{0}</color> 研究失败，目标物品已经破碎了",
                ["ResearchSuccess"] = "<color=#7FFF00>{0}</color> 研究成功",
                ["ResearchCantAfford"] = "您需要 {1} 个废料来研究 <color=#7FFF00>{0}</color>",
                ["IsBlocked"] = "服务器禁止您研究 <color=#1E90FF>{0}</color>",
                ["CantResearch"] = "无法研究",
                ["CanResearch"] = "开始研究",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: BetterResearching.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-electricity ---
// --- Original File Path: B/BetterElectricity/BetterElectricity.cs ---

﻿using System;
using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Electricity", "Rick", "1.2.4")]
    [Description("Allows more control over electricity.")]
    
    public class BetterElectricity : RustPlugin
    {
        private const string ADMIN_PERM = "betterelectricity.admin";

        private const int LARGE_BATTERY_MAX_DEFAULT = 100;
        private const int MEDIUM_BATTERY_MAX_DEFAULT = 50;
        private const int SMALL_BATTERY_MAX_DEFAULT = 10;

        private static ElectricityConfig config;

        #region Config

        private class ElectricityConfig
        {
            public SolarPanelConfig SolarPanelConfig { get; set; }
            public LargeBatteryConfig LargeBatteryConfig { get; set; }
            public MediumBatteryConfig MediumBatteryConfig { get; set; }
            public SmallBatteryConfig SmallBatteryConfig { get; set; }

            public SmallGeneratorConfig SmallGeneratorConfig { get; set; }

            public MillConfig MillConfig { get; set; }

            public ElectricityConfig()
            {
                SolarPanelConfig = new SolarPanelConfig();
                LargeBatteryConfig = new LargeBatteryConfig();
                MediumBatteryConfig = new MediumBatteryConfig();
                SmallBatteryConfig = new SmallBatteryConfig();
                MillConfig = new MillConfig();
                SmallGeneratorConfig = new SmallGeneratorConfig();
            }
        }

        private class SolarPanelConfig
        {
            public int MaxOutput { get; set; }

            public SolarPanelConfig()
            {
                MaxOutput = 100;
            }
        }

        private class MillConfig
        {
            public int MaxOutput { get; set; }

            public MillConfig()
            {
                MaxOutput = 150;
            }
        }

        private class LargeBatteryConfig
        {
            public int MaxOutput { get; set; }
            public float Efficiency { get; set; }
            public int MaxCapacitySeconds { get; set; }

            public LargeBatteryConfig()
            {
                MaxOutput = 100;
                Efficiency = 0.8f;
                MaxCapacitySeconds = 1440000;
            }
        }

        private class MediumBatteryConfig
        {
            public int MaxOutput { get; set; }
            public float Efficiency { get; set; }
            public int MaxCapacitySeconds { get; set; }

            public MediumBatteryConfig()
            {
                MaxOutput = 50;
                Efficiency = 0.8f;
                MaxCapacitySeconds = 540000;
            }
        }

        private class SmallBatteryConfig
        {
            public int MaxOutput { get; set; }
            public float Efficiency { get; set; }
            public int MaxCapacitySeconds { get; set; }

            public SmallBatteryConfig()
            {
                MaxOutput = 10;
                Efficiency = 0.8f;
                MaxCapacitySeconds = 9000;
            }
        }

        private class SmallGeneratorConfig
        {
            public int MaxOutput { get; set; }
            public SmallGeneratorConfig()
            {
                MaxOutput = 75;
            }

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ElectricityConfig>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning(lang.GetMessage(BetterElectricityLang.CONFIG_CREATE_OR_FIX, this));
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private ElectricityConfig GetDefaultConfig()
        {
            return new ElectricityConfig();
        }

        #endregion


        #region Oxide Hooks

        private void OnServerInitialized()
        {
            permission.RegisterPermission(ADMIN_PERM, this);
            ChangeSolarPanels();
            ChangeBatteries();
            ChangeMills();
            ChangeSmallGenerators();
        }

        private void Unload()
        {
            RevertSolarPanels();
            RevertBatteries();
            RevertMills();
            RevertSmallGenerators();
        }

        private void OnEntitySpawned(IOEntity entity)
        {
            ElectricBattery electricBattery = entity.GetComponent<ElectricBattery>();
            if (electricBattery != null)
            {
                AdjustBattery(electricBattery);
            }
            SolarPanel solarPanel = entity.GetComponent<SolarPanel>();
            if (solarPanel != null)
            {
                AdjustSolarPanel(solarPanel);
            }

            ElectricWindmill electricWindmill = entity.GetComponent<ElectricWindmill>();
            if (electricWindmill != null)
            {
                AdjustMill(electricWindmill);
            }

            FuelGenerator fuelGenerator = entity.GetComponent<FuelGenerator>();

            if (fuelGenerator != null)
            {
                AdjustGenerator(fuelGenerator);
            }

        }

        #endregion

        #region lang

        private class BetterElectricityLang
        {
            public static Dictionary<string, string> lang = new Dictionary<string, string>();
            public static string FIND_SOLAR_PANELS_ADJUST = "FindSolarPanelsAdjust";
            public static string FIND_BATTERIES_ADJUST = "FindBatteriesAdjust";
            public static string FIND_MILL_ADJUST = "FindMillAdjust";
            public static string FIND_SMALL_GEN_ADJUST = "FindSmallGenAdjust";
            public static string FIND_SOLAR_PANELS_REVERT = "FindSolarPanelsRevert";
            public static string FIND_BATTERIES_REVERT = "FindBatteriesRevert";
            public static string FIND_MILL_REVERT = "FindMillRevert";
            public static string FIND_SMALL_GEN_REVERT = "FindSmallGenRevert";
            public static string HELP_PLAYER_MENU = "HelpMenu";
            public static string BE_RELOAD_HELP = "BeReloadHelp";
            public static string NO_PERMISSION = "NoPermission";
            public static string CONFIG_CREATE_OR_FIX = "ConfigUpdateOrFix";

        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [BetterElectricityLang.FIND_SOLAR_PANELS_ADJUST] = "Finding and adjusting all Solar Panels. (This may take some time)",
                [BetterElectricityLang.FIND_BATTERIES_ADJUST] = "Finding and adjusting all Batteries. (This may take some time)",
                [BetterElectricityLang.FIND_MILL_ADJUST] = "Finding and adjusting all Mill Turbines. (This may take some time)",
                [BetterElectricityLang.FIND_SMALL_GEN_ADJUST] = "Finding and adjusting all Small Generators. (This may take some time)",
                [BetterElectricityLang.FIND_SOLAR_PANELS_REVERT] = "Finding and reverting all Solar Panels. (This may take some time)",
                [BetterElectricityLang.FIND_BATTERIES_REVERT] = "Finding and reverting all Batteries. (This may take some time)",
                [BetterElectricityLang.FIND_MILL_REVERT] = "Finding and reverting all Mill Turbines. (This may take some time)",
                [BetterElectricityLang.FIND_SMALL_GEN_REVERT] = "Finding and reverting all Small Generators. (This may take some time)",
                [BetterElectricityLang.HELP_PLAYER_MENU] = "====== Player Commands ======",
                [BetterElectricityLang.BE_RELOAD_HELP] = "/belectric reload => Reloads the config.",
                [BetterElectricityLang.NO_PERMISSION] = "No Permission!",
                [BetterElectricityLang.CONFIG_CREATE_OR_FIX] = "Configuration file is corrupt (or doesn't exists), creating new one!",
            }, this);
        }

        #endregion

        #region Utils

        private void Reload()
        {
            RevertMills();
            RevertSolarPanels();
            RevertBatteries();
            RevertSmallGenerators();
            LoadConfig();
            ChangeSolarPanels();
            ChangeBatteries();
            ChangeMills();
            ChangeSmallGenerators();
        }

        private bool HasPermission(BasePlayer player, string perm)
        {
            return player.IsAdmin || permission.UserHasPermission(player.UserIDString, perm);
        }

        #endregion

        #region Core

        private void ChangeSolarPanels()
        {
            // Heavy Initial Load
            Puts(lang.GetMessage(BetterElectricityLang.FIND_SOLAR_PANELS_ADJUST, this));
            foreach (var solarPanel in UnityEngine.Object.FindObjectsOfType<SolarPanel>())
            {
                AdjustSolarPanel(solarPanel);
            }
        }

        private void ChangeBatteries()
        {
            // Heavy Initial Load
            Puts(lang.GetMessage(BetterElectricityLang.FIND_BATTERIES_ADJUST, this));
            foreach (var electricBattery in UnityEngine.Object.FindObjectsOfType<ElectricBattery>())
            {
                AdjustBattery(electricBattery);
            }
        }

        private void ChangeMills()
        {
            // Heavy Initial Load
            Puts(lang.GetMessage(BetterElectricityLang.FIND_MILL_ADJUST, this));
            foreach (var electricWindmill in UnityEngine.Object.FindObjectsOfType<ElectricWindmill>())
            {
                AdjustMill(electricWindmill);
            }
        }

        private void ChangeSmallGenerators()
        {
            Puts(lang.GetMessage(BetterElectricityLang.FIND_SMALL_GEN_ADJUST, this));
            foreach (var fuelGenerator in UnityEngine.Object.FindObjectsOfType<FuelGenerator>())
            {
                AdjustGenerator(fuelGenerator);
            }
        }

        private void RevertBatteries()
        {
            Puts(lang.GetMessage(BetterElectricityLang.FIND_BATTERIES_REVERT, this));
            foreach (var electricBattery in UnityEngine.Object.FindObjectsOfType<ElectricBattery>())
            {
                RevertBattery(electricBattery);
            }
        }

        private void RevertSolarPanels()
        {
            Puts(lang.GetMessage(BetterElectricityLang.FIND_SOLAR_PANELS_REVERT, this));
            foreach (var solarPanel in UnityEngine.Object.FindObjectsOfType<SolarPanel>())
            {
                RevertSolarPanel(solarPanel);
            }
        }

        private void RevertMills()
        {
            Puts(lang.GetMessage(BetterElectricityLang.FIND_MILL_REVERT, this));
            foreach (var electricWindmill in UnityEngine.Object.FindObjectsOfType<ElectricWindmill>())
            {
                RevertMill(electricWindmill);
            }
        }

        private void RevertSmallGenerators()
        {
            Puts(lang.GetMessage(BetterElectricityLang.FIND_SMALL_GEN_REVERT, this));
            foreach (var fuelElectricGenerator in UnityEngine.Object.FindObjectsOfType<FuelElectricGenerator>())
            {
                RevertSmallGenerator(fuelElectricGenerator);
            }
        }

        private void AdjustBattery(ElectricBattery electricBattery)
        {
            if (electricBattery.maxOutput == LARGE_BATTERY_MAX_DEFAULT)
            {
                // Large Battery
                electricBattery.maxOutput = config.LargeBatteryConfig.MaxOutput;
                electricBattery.maxCapactiySeconds = config.LargeBatteryConfig.MaxCapacitySeconds;
                electricBattery.chargeRatio = config.LargeBatteryConfig.Efficiency;
                //battery.maximumInboundEnergyRatio = config.LargeBatteryConfig.Efficiency * 10;
            }
            else if (electricBattery.maxOutput == MEDIUM_BATTERY_MAX_DEFAULT)
            {
                electricBattery.maxOutput = config.MediumBatteryConfig.MaxOutput;
                electricBattery.maxCapactiySeconds = config.MediumBatteryConfig.MaxCapacitySeconds;
                electricBattery.chargeRatio = config.MediumBatteryConfig.Efficiency;
                //battery.maximumInboundEnergyRatio = config.MediumBatteryConfig.Efficiency * 10;
            }
            else if (electricBattery.maxOutput == SMALL_BATTERY_MAX_DEFAULT)
            {
                // Small Battery.
                electricBattery.maxOutput = config.SmallBatteryConfig.MaxOutput;
                electricBattery.maxCapactiySeconds = config.SmallBatteryConfig.MaxCapacitySeconds;
                electricBattery.chargeRatio = config.SmallBatteryConfig.Efficiency;
                //battery.maximumInboundEnergyRatio = config.SmallBatteryConfig.Efficiency * 10;
            }
            electricBattery.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        private void AdjustSolarPanel(SolarPanel solarPanel)
        {
            solarPanel.maximalPowerOutput = config.SolarPanelConfig.MaxOutput;
        }

        private void AdjustMill(ElectricWindmill electricWindmill)
        {
            electricWindmill.maxPowerGeneration = config.MillConfig.MaxOutput;
        }

        private void AdjustGenerator(FuelGenerator fuelGenerator)
        {
            fuelGenerator.outputEnergy = config.SmallGeneratorConfig.MaxOutput;
        }

        private void RevertBattery(ElectricBattery electricBattery)
        {
            // Based on these values -> https://rust.facepunch.com/blog/november-update#batteryfixes
            if (electricBattery.maxOutput == config.LargeBatteryConfig.MaxOutput)
            {
                // Large battery;
                electricBattery.maxCapactiySeconds = 1440000;
                electricBattery.chargeRatio = 0.8f;
                electricBattery.maximumInboundEnergyRatio = 4;
                electricBattery.maxOutput = LARGE_BATTERY_MAX_DEFAULT;
            }
            else if (electricBattery.maxOutput == config.MediumBatteryConfig.MaxOutput)
            {
                electricBattery.maxCapactiySeconds = 540000;
                electricBattery.chargeRatio = 0.8f;
                electricBattery.maximumInboundEnergyRatio = 4;
                electricBattery.maxOutput = MEDIUM_BATTERY_MAX_DEFAULT;
            }
            else if (electricBattery.maxOutput == config.SmallBatteryConfig.MaxOutput)
            {
                electricBattery.maxCapactiySeconds = 9000;
                electricBattery.chargeRatio = 0.8f;
                electricBattery.maximumInboundEnergyRatio = 4;
                electricBattery.maxOutput = SMALL_BATTERY_MAX_DEFAULT;
            }
            electricBattery.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        private void RevertSolarPanel(SolarPanel solarPanel)
        {
            solarPanel.maximalPowerOutput = 20;
        }

        private void RevertMill(ElectricWindmill electricWindmill)
        {
            electricWindmill.maxPowerGeneration = 150;
        }

        private void RevertSmallGenerator(FuelElectricGenerator fuelElectricGenerator)
        {
            fuelElectricGenerator.electricAmount = 40;
        }

        #endregion

        #region Commands
        [ChatCommand("belectric")]
        void OnElectricityCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, lang.GetMessage(BetterElectricityLang.HELP_PLAYER_MENU, this, player.UserIDString));
                SendReply(player, lang.GetMessage(BetterElectricityLang.BE_RELOAD_HELP, this, player.UserIDString));
            }
            else if (args.Length == 1)
            {
                if (args[0].ToLower() == "reload")
                {
                    if (HasPermission(player, ADMIN_PERM))
                    {
                        Reload();
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage(BetterElectricityLang.NO_PERMISSION, this, player.UserIDString));
                    }
                }
                else
                {
                    SendReply(player, lang.GetMessage(BetterElectricityLang.HELP_PLAYER_MENU, this, player.UserIDString));
                    SendReply(player, lang.GetMessage(BetterElectricityLang.BE_RELOAD_HELP, this, player.UserIDString));
                }
            }
        }
        #endregion

    }
}

// --- End of file: BetterElectricity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/balloon-plus ---
// --- Original File Path: B/BalloonPlus/BalloonPlus.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Balloon Plus", "Iv Misticos", "1.0.8")]
    [Description("Control your balloon's flight")]
    class BalloonPlus : RustPlugin
    {
        #region Cache
        
        private static Dictionary<string, SpeedData> _cachedSpeedData = new Dictionary<string, SpeedData>();

        private void UpdateCacheSpeedData(string id)
        {
            var highest = (SpeedData) null;
            foreach (var modifier in _config.Modifiers)
            {
                if (!CacheSpeedDataAllowed(id, modifier))
                    continue;
                
                if (highest == null || highest.Modifier < modifier.Modifier)
                    highest = modifier;
            }

            _cachedSpeedData[id] = highest;
        }

        private bool CacheSpeedDataAllowed(string id, SpeedData data)
        {
            return string.IsNullOrEmpty(data.Permission) || permission.UserHasPermission(id, data.Permission);
        }
        
        #endregion
        
        #region Configuration

        private static Configuration _config;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Speed Modifiers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<SpeedData> Modifiers = new List<SpeedData> {new SpeedData {Modifier = 250f, Permission = ""}};
            
            [JsonProperty(PropertyName = "Move Button")]
            public string MoveButton = "SPRINT";
            
            [JsonProperty(PropertyName = "Disable Wind Force")]
            public bool DisableWindForce = true;
            
            [JsonProperty(PropertyName = "Move Frequency")]
            public float Frequency = 0.2f;

            [JsonProperty(PropertyName = "Speed Modifier", NullValueHandling = NullValueHandling.Ignore)]
            public float? SpeedModifier = null;

            [JsonIgnore] public BUTTON ParsedMoveButton;
        }

        private class SpeedData
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission = "balloonplus.vip";
            
            [JsonProperty(PropertyName = "Speed Modifier")]
            public float Modifier = 300f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
        
        #region Hooks
        
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            var balloon = entity as HotAirBalloon;
            if (balloon == null)
                return;

            balloon.windForce = 0;
        }

        private void Init()
        {
            if (!Enum.TryParse(_config.MoveButton, out _config.ParsedMoveButton))
            {
                PrintError("Unable to parse the moving button");
                _config.ParsedMoveButton = BUTTON.SPRINT;
            }

            for (var i = 0; i < _config.Modifiers.Count; i++)
            {
                var modifier = _config.Modifiers[i];
                if (string.IsNullOrEmpty(modifier.Permission))
                    continue;
                
                permission.RegisterPermission(modifier.Permission, this);
            }

            if (_config.SpeedModifier.HasValue)
            {
                _config.Modifiers.Add(new SpeedData {Permission = "", Modifier = _config.SpeedModifier.Value});
                _config.SpeedModifier = null;
            }

            foreach (var player in BasePlayer.activePlayerList)
                UpdateCacheSpeedData(player.UserIDString);

            if (_config.DisableWindForce)
                return;
            
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnServerInitialized));
        }

        private void OnServerInitialized()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<HotAirBalloon>();
            for (var index = 0; index < objects.Length; index++)
            {
                OnEntitySpawned(objects[index]);
            }

            timer.Every(_config.Frequency, HandleUpdate);
        }

        private void OnPlayerConnected(BasePlayer player) => UpdateCacheSpeedData(player.UserIDString);
        private void OnUserGroupAdded(string id, string groupName) => UpdateCacheSpeedData(id);
        private void OnUserGroupRemoved(string id, string groupName) => UpdateCacheSpeedData(id);        
        private void OnUserPermissionGranted(string id, string permName) => UpdateCacheSpeedData(id);        
        private void OnUserPermissionRevoked(string id, string permName) => UpdateCacheSpeedData(id);
        
        #endregion
        
        #region Helpers

        private void HandleUpdate()
        {
            foreach (var player in BasePlayer.activePlayerList)
                HandleUpdate(player);
        }

        private void HandleUpdate(BasePlayer player)
        {
            if (!player.serverInput.IsDown(_config.ParsedMoveButton) || !player.HasParent())
                return;
            
            var balloon = player.GetParentEntity() as HotAirBalloon;
            if (balloon == null)
                return;

            var modifier = _cachedSpeedData[player.UserIDString];
            if (modifier == null)
                return;

            var direction = player.eyes.HeadForward() * modifier.Modifier;
            balloon.myRigidbody.AddForce(direction.x, 0, direction.z, ForceMode.Force); // We shouldn't move the balloon up or down, so I use 0 here as y.
        }
        
        #endregion
    }
}

// --- End of file: BalloonPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/box-looters ---
// --- Original File Path: B/BoxLooters/BoxLooters.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("BoxLooters", "4seti / k1lly0u", "0.3.6")]
    [Description("Log looters for a containers")]
    class BoxLooters : RustPlugin
    {
        #region Fields
        private StoredBoxData boxData;
        private StoredPlayerData playerData;
        private DynamicConfigFile boxdata;
        private DynamicConfigFile playerdata;

        private static BoxLooters ins;
        
        private bool eraseData = false;

        private const string PERMISSION_CHECKBOX = "boxlooters.checkbox";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {            
            permission.RegisterPermission(PERMISSION_CHECKBOX, this);

            LoadData();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(messages, this);

        private void OnServerInitialized()
        {
            ins = this;
            LoadVariables();

            if (eraseData)
                ClearAllData();
            else RemoveOldData();
        }

        private void OnNewSave(string filename) => eraseData = true;

        private void OnServerSave() => SaveData();

        private void Unload()
        {
            SaveData();
            ins = null;
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity entity)
        {
            if (looter == null || entity == null || !entity.IsValid() || !IsValidType(entity)) return;

            double time = GrabCurrentTime();
            string date = DateTime.Now.ToString("d/M @ HH:mm:ss");
            
            if (entity is BasePlayer)
            {
                if (!configData.LogPlayerLoot)
                    return;

                BasePlayer looted = entity.ToPlayer();

                if (!playerData.players.ContainsKey(looted.userID))
                    playerData.players[looted.userID] = new PlayerData(looter, time, date);
                else playerData.players[looted.userID].AddLooter(looter, time, date);                
            }
            else
            {
                if (!configData.LogBoxLoot)
                    return;

                if (!boxData.boxes.ContainsKey(entity.net.ID.Value))
                    boxData.boxes[entity.net.ID.Value] = new BoxData(looter, time, date, entity.transform.position);
                else boxData.boxes[entity.net.ID.Value].AddLooter(looter, time, date); 
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || !entity.IsValid() || !IsValidType(entity) || entity is BasePlayer)
                return;

            if (hitInfo?.Initiator is BasePlayer)
            {
                if (!boxData.boxes.ContainsKey(entity.net.ID.Value))
                    return;
                boxData.boxes[entity.net.ID.Value].OnDestroyed(hitInfo.InitiatorPlayer);
            }
        }
        #endregion

        #region Data Cleanup
        private void ClearAllData()
        {
            PrintWarning("Detected map wipe, resetting loot data!");
            boxData.boxes.Clear();
            playerData.players.Clear();
            SaveData();
        }

        private void RemoveOldData()
        {
            PrintWarning("Attempting to remove old log entries");
            int boxCount = 0;
            int playerCount = 0;
            double time = GrabCurrentTime() - (configData.RemoveHours * 3600);

            for (int i = 0; i < boxData.boxes.Count; i++)
            {
                KeyValuePair<ulong, BoxData> boxEntry = boxData.boxes.ElementAt(i);
                if (boxEntry.Value.lastAccess < time)
                {
                    boxData.boxes.Remove(boxEntry.Key);
                    ++boxCount;
                }
            }
            PrintWarning($"Removed {boxCount} old records from BoxData");

            for (int i = 0; i < playerData.players.Count; i++)
            {
                KeyValuePair<ulong, PlayerData> playerEntry = playerData.players.ElementAt(i);
                if (playerEntry.Value.lastAccess < time)
                {
                    playerData.players.Remove(playerEntry.Key);
                    ++playerCount;
                }
            }
            PrintWarning($"Removed {playerCount} old records from PlayerData");
        }
        #endregion

        #region Functions
        private object FindBoxFromRay(BasePlayer player)
        {
            Ray ray = new Ray(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward);
            RaycastHit hit;
            if (!Physics.Raycast(ray, out hit, 20))
                return null;

            BaseEntity hitEnt = hit.collider.GetComponentInParent<BaseEntity>();
            if (hitEnt != null)
            {
                if (IsValidType(hitEnt))
                    return hitEnt;
            }
            return null;            
        }

        private void ReplyInfo(BasePlayer player, ulong entityId, bool isPlayer = false, string additional = "")
        {
            string entId = entityId.ToString();
            if (!string.IsNullOrEmpty(additional))
                entId = $"{additional} - {entityId}";

            if (!isPlayer)
            {                
                if (boxData.boxes.ContainsKey(entityId))
                {
                    BoxData box = boxData.boxes[entityId];
                    SendReply(player, string.Format(msg("BoxInfo", player.userID), entId));

                    if (!string.IsNullOrEmpty(box.killerName))
                        SendReply(player, string.Format(msg("DetectDestr", player.userID), box.killerName, box.killerId));

                    int i = 1;
                    string response1 = string.Empty;
                    string response2 = string.Empty;

                    foreach (LootList.LootEntry data in box.lootList.GetLooters().Reverse().Take(10))
                    {
                        string respString = string.Format(msg("DetectedLooters", player.userID), i, data.userName, data.userId, data.firstLoot, data.lastLoot);
                        if (i < 6) response1 += respString;
                        else response2 += respString;
                        i++;                        
                    }
                    SendReply(player, response1);
                    SendReply(player, response2);
                }
                else SendReply(player, string.Format(msg("NoLooters", player.userID), entId));
            }
            else
            {
                if (playerData.players.ContainsKey(entityId))
                {
                    SendReply(player, string.Format(msg("PlayerData", player.userID), entId));

                    int i = 1;
                    string response1 = string.Empty;
                    string response2 = string.Empty;
                    foreach (LootList.LootEntry data in playerData.players[entityId].lootList.GetLooters().Reverse().Take(10))
                    {
                        string respString = string.Format(msg("DetectedLooters", player.userID), i, data.userName, data.userId, data.firstLoot, data.lastLoot);
                        if (i < 6) response1 += respString;
                        else response2 += respString;
                        i++;
                    }
                    SendReply(player, response1);
                    SendReply(player, response2);
                }
                else SendReply(player, string.Format(msg("NoLootersPlayer", player.userID), entId));
            }
        }
        #endregion

        #region Helpers
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private bool HasPermission(BasePlayer player) => permission.UserHasPermission(player.UserIDString, PERMISSION_CHECKBOX) || player.net.connection.authLevel > 0;

        private float GetDistance(Vector3 init, Vector3 target) => Vector3.Distance(init, target);

        private bool IsValidType(BaseEntity entity) => !entity.GetComponent<LootContainer>() && (entity is StorageContainer || entity is MiningQuarry || entity is ResourceExtractorFuelStorage || entity is BasePlayer);
        #endregion

        #region Commands
        [ChatCommand("box")]
        private void cmdBox(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player)) return;
            if (args == null || args.Length == 0)
            {
                object success = FindBoxFromRay(player);
                if (success is MiningQuarry)
                {
                    List<BaseEntity> children = (success as MiningQuarry).children;
                    if (children != null)
                    {
                        foreach (BaseEntity child in children)
                        {
                            if (child.GetComponent<StorageContainer>())
                            {
                                ReplyInfo(player, child.net.ID.Value, false, child.ShortPrefabName);
                            }
                        }
                    }
                    else SendReply(player, msg("Nothing", player.userID));
                }
                else if (success is BasePlayer)
                    ReplyInfo(player, (success as BasePlayer).userID, true);
                else if (success is BaseEntity)
                    ReplyInfo(player, (success as BaseEntity).net.ID.Value);

                else SendReply(player, msg("Nothing", player.userID));
                return;
            }
            switch (args[0].ToLower())
            {
                case "help":
                    {
                        SendReply(player, $"<color=#4F9BFF>{Title}  v{Version}</color>");
                        SendReply(player, "<color=#4F9BFF>/box help</color> - Display the help menu");
                        SendReply(player, "<color=#4F9BFF>/box</color> - Retrieve information on the box you are looking at");                        
                        SendReply(player, "<color=#4F9BFF>/box id <number></color> - Retrieve information on the specified box");
                        SendReply(player, "<color=#4F9BFF>/box near <opt:radius></color> - Show nearby boxes (current and destroyed) and their ID numbers");
                        SendReply(player, "<color=#4F9BFF>/box player <partialname/id></color> - Retrieve loot information about a player");
                        SendReply(player, "<color=#4F9BFF>/box clear</color> - Clears all saved data");
                        SendReply(player, "<color=#4F9BFF>/box save</color> - Saves box data");
                    }
                    return;
                case "id":
                    if (args.Length >= 2)
                    {
                        ulong id;
                        if (ulong.TryParse(args[1], out id))                        
                            ReplyInfo(player, id);                        
                        else SendReply(player, msg("NoID", player.userID));
                        return;
                    }
                    break;
                case "near":
                    {
                        float radius = 20f;
                        if (args.Length >= 2)
                        {
                            if (!float.TryParse(args[1], out radius))
                                radius = 20f;
                        }
                        foreach(KeyValuePair<ulong, BoxData> box in boxData.boxes)
                        {
                            if (GetDistance(player.transform.position, box.Value.GetPosition()) <= radius)
                            {
                                player.SendConsoleCommand("ddraw.text", 20f, Color.green, box.Value.GetPosition() + new Vector3(0, 1.5f, 0), $"<size=40>{box.Key}</size>");
                                player.SendConsoleCommand("ddraw.box", 20f, Color.green, box.Value.GetPosition(), 1f);
                            }
                        }
                    }
                    return;
                case "player":
                    if (args.Length >= 2)
                    {
                        IPlayer target = covalence.Players.FindPlayer(args[1]);
                        if (target != null)                        
                            ReplyInfo(player, ulong.Parse(target.Id), true);
                        else SendReply(player, msg("NoPlayer", player.userID));
                        return;
                    }
                    break;
                case "clear":
                    boxData.boxes.Clear();
                    playerData.players.Clear();
                    SendReply(player, msg("ClearData", player.userID));
                    return;
                case "save":
                    SaveData();
                    SendReply(player, msg("SavedData", player.userID));
                    return;
                default:
                    break;
            }
            SendReply(player, msg("SynError", player.userID));
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            public int RemoveHours { get; set; }  
            public int RecordsPerContainer { get; set; } 
            public bool LogPlayerLoot { get; set; }
            public bool LogBoxLoot { get; set; }         
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                RemoveHours = 48,
                RecordsPerContainer = 10,
                LogBoxLoot = true,
                LogPlayerLoot = true
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management        
        private class BoxData
        {
            public float x, y, z;
            public string killerId, killerName;
            public LootList lootList;
            public double lastAccess;

            public BoxData() { }
            public BoxData(BasePlayer player, double time, string date, Vector3 pos)
            {
                x = pos.x;
                y = pos.y;
                z = pos.z;
                lootList = new LootList(player, date);
                lastAccess = time;
            }
            public void AddLooter(BasePlayer looter, double time, string date)
            {
                lootList.AddEntry(looter, date);
                lastAccess = time;
            }

            public void OnDestroyed(BasePlayer killer)
            {
                killerId = killer.UserIDString;
                killerName = killer.displayName;
            }
            public Vector3 GetPosition() => new Vector3(x, y, z);            
        }

        private class PlayerData
        {
            public LootList lootList;
            public double lastAccess;

            public PlayerData() { }
            public PlayerData(BasePlayer player, double time, string date)
            {
                lootList = new LootList(player, date);
                lastAccess = time;
            }
            public void AddLooter(BasePlayer looter, double time, string date)
            {
                lootList.AddEntry(looter, date);
                lastAccess = time;
            }        
        }

        private class LootList
        {
            public List<LootEntry> looters;

            public LootList() { }
            public LootList(BasePlayer player, string date)
            {
                looters = new List<LootEntry>();
                looters.Add(new LootEntry(player, date));
            }
            public void AddEntry(BasePlayer player, string date)
            {
                LootEntry lastEntry = null;
                try { lastEntry = looters.Single(x => x.userId == player.UserIDString); } catch { }                 
                if (lastEntry != null)
                {
                    looters.Remove(lastEntry);
                    lastEntry.lastLoot = date;
                }
                else
                {
                    if (looters.Count == ins.configData.RecordsPerContainer)
                        looters.Remove(looters.ElementAt(0));
                    lastEntry = new LootEntry(player, date);
                }
                looters.Add(lastEntry);
            }
            public LootEntry[] GetLooters() => looters.ToArray();

            public class LootEntry
            {
                public string userId, userName, firstLoot, lastLoot;
                            
                public LootEntry() { }
                public LootEntry(BasePlayer player, string firstLoot)
                {
                    userId = player.UserIDString;
                    userName = player.displayName;
                    this.firstLoot = firstLoot;
                    lastLoot = firstLoot;                    
                }
            }
        }

        private void SaveData()
        {
            if (configData.LogBoxLoot)            
                boxdata.WriteObject(boxData);
            
            if (configData.LogPlayerLoot)            
                playerdata.WriteObject(playerData);
            
            PrintWarning("Saved Boxlooters data");
        }

        private void LoadData()
        {
            boxdata = Interface.Oxide.DataFileSystem.GetFile("Boxlooters/box_data");
            
            playerdata = Interface.Oxide.DataFileSystem.GetFile("Boxlooters/player_data");

            try
            {
                boxData = boxdata.ReadObject<StoredBoxData>();
            }
            catch
            {
                boxData = new StoredBoxData();
            }
            try
            {
                playerData = playerdata.ReadObject<StoredPlayerData>();
            }
            catch
            {
                playerData = new StoredPlayerData();                
            }

            if (boxData?.boxes == null)
                boxData = new StoredBoxData();

            if (playerData?.players == null)
                playerData = new StoredPlayerData();
        }

        private class StoredBoxData
        {
            public Hash<ulong, BoxData> boxes = new Hash<ulong, BoxData>();
        }

        private class StoredPlayerData
        {
            public Hash<ulong, PlayerData> players = new Hash<ulong, PlayerData>();
        }
        #endregion

        #region Localization
        private string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"BoxInfo", "List of looters for this Box [<color=#F5D400>{0}</color>]:"},
            {"PlayerData", "List of looters for this Player [<color=#F5D400>{0}</color>]:"},            
            {"DetectedLooters", "<color=#F5D400>[{0}]</color><color=#4F9BFF>{1}</color> ({2})\nF:<color=#F80>{3}</color> L:<color=#F80>{4}</color>\n"},
            {"DetectDestr", "Destoyed by: <color=#4F9BFF>{0}</color> ID:{1}"},
            {"NoLooters", "<color=#4F9BFF>The box [{0}] is clear!</color>"},
            {"NoLootersPlayer", "<color=#4F9BFF>The player [{0}] is clear!</color>"},
            {"Nothing", "<color=#4F9BFF>Unable to find a valid entity</color>"},
            {"NoID", "<color=#4F9BFF>You must enter a valid entity ID</color>"},
            {"NoPlayer",  "No players with that name/ID found!"},
            {"SynError", "<color=#F5D400>Syntax Error: Type '/box' to view available options</color>" },
            {"SavedData", "You have successfully saved loot data" },
            {"ClearData", "You have successfully cleared all loot data" }
        };
        #endregion
    }
}


// --- End of file: BoxLooters.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-charcoal ---
// --- Original File Path: B/BetterCharcoal/BetterCharcoal.cs ---

﻿using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Better Charcoal", "Dana", "2.2.0")]
    [Description("Say goodbye to charcoal shortages, hello to explosives!")]

    public class BetterCharcoal : RustPlugin
    {
        #region Fields

        private static BetterCharcoal _instance;
        private static Configuration _config;

        private CharcoalController _controller;
        private Coroutine _coroutine;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty(PropertyName = "Version")]
            public string Version { get; set; }

            [JsonProperty(PropertyName = "Enable Charcoal Production")]
            public bool EnableCharcoalProduction { get; set; }

            [JsonProperty(PropertyName = "Charcoal Yield Chance")]
            public int CharcoalYieldChance { get; set; }

            [JsonProperty(PropertyName = "Lowest Charcoal Yield")]
            public int LowestCharcoalYield { get; set; }

            [JsonProperty(PropertyName = "Highest Charcoal Yield")]
            public int HighestCharcoalYield { get; set; }

            [JsonProperty(PropertyName = "Charcoal Production Rate")]
            public int CharcoalProductionRate { get; set; }

            [JsonProperty(PropertyName = "Fuel Consumption Rate")]
            public int FuelConsumptionRate { get; set; }

            [JsonProperty(PropertyName = "Enable Electric Furnace Charcoal Production")]
            public bool EnableElectricFurnaceCharcoalProduction { get; set; }

            [JsonProperty(PropertyName = "Electric Furnace Charcoal Yield Interval")]
            public float ElectricFurnaceCharcoalYieldInterval { get; set; }
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                EnableCharcoalProduction = true,
                CharcoalYieldChance = 75,
                LowestCharcoalYield = 1,
                HighestCharcoalYield = 1,
                CharcoalProductionRate = 1,
                FuelConsumptionRate = 1,
                EnableElectricFurnaceCharcoalProduction = false,
                ElectricFurnaceCharcoalYieldInterval = 2f
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            if (string.Compare(_config.Version, "2.1.0") < 0)
            {
                _config.ElectricFurnaceCharcoalYieldInterval = defaultConfig.ElectricFurnaceCharcoalYieldInterval;
            }

            if (string.Compare(_config.Version, "2.2.0") < 0)
            {
                _config.EnableElectricFurnaceCharcoalProduction = defaultConfig.EnableElectricFurnaceCharcoalProduction;
            }

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        #endregion Configuration

        #region Oxide Hooks

        /// <summary>
        /// Hook: Called when a plugin is being initialized.
        /// </summary>
        private void Init()
        {
            _instance = this;
            _controller = new CharcoalController();

            Permission.Register();
        }

        /// <summary>
        /// Hook: Called after server startup is complete and awaits connections or when a plugin is hotloaded.
        /// </summary>
        private void OnServerInitialized()
        {
            StartCoroutine();
        }

        /// <summary>
        /// Hook: Called when a plugin is being unloaded.
        /// </summary>
        private void Unload()
        {
            StopCoroutine();
            _controller.CleanupOvens();

            _config = null;
            _instance = null;
        }

        /// <summary>
        /// Hook: Called after any entity has spawned.
        /// </summary>
        /// <param name="oven"> The oven that has spawned. </param>
        private void OnEntitySpawned(BaseOven oven)
        {
            _controller.Setup(oven);
        }

        /// <summary>
        /// Hook: Called right before fuel starts being consumed in the oven.
        /// </summary>
        /// <param name="oven"> The oven being used. </param>
        /// <param name="fuel"> The fuel item being consumed. </param>
        /// <param name="burnable"> The burnable component of the fuel item. </param>
        /// <returns> True or false if the fuel consumption should be skipped, null otherwise. </returns>
        private object OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (!OvenIsEligible(oven))
                return null;

            CharcoalComponent.GetComponent(oven)?.ConsumeFuel(fuel, burnable);
            return true;
        }

        /// <summary>
        /// Called when an oven is turned on or off.
        /// </summary>
        /// <param name="electricOven"> The electric oven being toggled. </param>
        private void OnOvenToggle(ElectricOven electricOven)
        {
            if (!OvenIsEligible(electricOven) || !_config.EnableElectricFurnaceCharcoalProduction)
                return;

            bool ovenTurnedOn = electricOven.IsOn() ? false : true;
            CharcoalComponent.GetComponent(electricOven).StateChanged(ovenTurnedOn);
        }

        #endregion Oxide Hooks

        #region Coroutine

        private void StartCoroutine()
        {
            _coroutine = ServerMgr.Instance.StartCoroutine(_controller.SetupOvens());
        }

        private void StopCoroutine()
        {
            if (!_coroutine.IsUnityNull())
            {
                ServerMgr.Instance.StopCoroutine(_coroutine);
                _coroutine = null;
            }
        }

        #endregion Coroutine

        #region Controller

        private class CharcoalController
        {
            private HashSet<CharcoalComponent> _components = new HashSet<CharcoalComponent>();

            public void Register(CharcoalComponent component)
            {
                _components.Add(component);
            }

            public void Unregister(CharcoalComponent component)
            {
                _components.Remove(component);
            }

            public void Setup(BaseOven oven)
            {
                CharcoalComponent.InstallComponent(oven, this);
            }

            public IEnumerator SetupOvens()
            {
                WaitForSeconds waitDuration = ConVar.FPS.limit > 80 ? CoroutineEx.waitForSeconds(0.01f) : null;

                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    BaseOven oven = entity as BaseOven;
                    if (!oven.IsValid())
                        continue;

                    CharcoalComponent.InstallComponent(oven, this);

                    if (oven is ElectricOven && oven.IsOn() && _config.EnableElectricFurnaceCharcoalProduction)
                        CharcoalComponent.GetComponent(oven).StateChanged(true);

                    yield return waitDuration;
                }
            }

            public void CleanupOvens()
            {
                foreach (CharcoalComponent component in _components.ToList())
                {
                    component.RemoveComponent();
                }
            }
        }

        #endregion Controller

        #region Component

        private class CharcoalComponent : FacepunchBehaviour
        {
            private BaseOven _oven;
            private CharcoalController _controller;

            private void OnDestroy()
            {
                _controller.Unregister(this);
            }

            public CharcoalComponent InitializeComponent(CharcoalController controller)
            {
                _oven = GetComponent<BaseOven>();

                _controller = controller;
                _controller.Register(this);

                return this;
            }

            public static void InstallComponent(BaseOven oven, CharcoalController controller)
            {
                oven.gameObject.AddComponent<CharcoalComponent>().InitializeComponent(controller);
            }

            public static CharcoalComponent GetComponent(BaseOven oven)
            {
                return oven.gameObject.GetComponent<CharcoalComponent>();
            }

            public void RemoveComponent()
            {
                DestroyImmediate(this);
            }

            #region Furnace Functions

            public void StateChanged(bool ovenTurnedOn)
            {
                if (ovenTurnedOn)
                    InvokeRepeating(YieldCharcoal, 1f, _config.ElectricFurnaceCharcoalYieldInterval);
                else
                    CancelInvoke(YieldCharcoal);
            }

            private void YieldCharcoal()
            {
                if (_config.EnableCharcoalProduction && Random.Range(0, 100) < _config.CharcoalYieldChance)
                {
                    Item item = ItemManager.CreateByName("charcoal", Random.Range(_config.LowestCharcoalYield, _config.HighestCharcoalYield) * _config.CharcoalProductionRate);
                    if (!item.MoveToContainer(_oven.inventory, -1, true, false, null))
                    {
                        _oven.OvenFull();
                        item.Drop(_oven.inventory.dropPosition, _oven.inventory.dropVelocity, default(Quaternion));
                        CancelInvoke(YieldCharcoal);
                    }
                }
            }

            public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (_oven.allowByproductCreation && burnable.byproductItem != null)
                    YieldCharcoal();

                if (fuel.amount <= 1)
                {
                    fuel.Remove(0f);
                    return;
                }

                fuel.UseItem(_config.FuelConsumptionRate);
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();
            }

            #endregion Furnace Functions
        }

        #endregion Component

        #region Helper Functions

        /// <summary>
        /// Finds a player by their unique player id and returns the BasePlayer object.
        /// </summary>
        /// <param name="playerId"> The  id of the player to find. </param>
        /// <returns> The BasePlayer object of the player with the specified id, or null if not found. </returns>
        private BasePlayer FindPlayerById(ulong playerId)
        {
            return RelationshipManager.FindByID(playerId) ?? null;
        }

        /// <summary>
        /// Determines if a oven is eligible for altered charcoal yield based on the owner's permission.
        /// </summary>
        /// <param name="oven"> The oven to check eligibility for. </param>
        /// <returns> True if the oven is eligible, false otherwise. </returns>
        private bool OvenIsEligible(BaseOven oven)
        {
            BasePlayer player = FindPlayerById(oven.OwnerID);

            if (!player.IsValid())
                return false;

            if (!Permission.Verify(player))
                return false;

            return true;
        }

        #endregion Helper Functions

        #region Permissions

        /// <summary>
        /// Contains utility methods for checking and registering plugin permissions.
        /// </summary>
        private static class Permission
        {
            public const string USE = "bettercharcoal.use";

            public static void Register()
            {
                _instance.permission.RegisterPermission(USE, _instance);
            }

            public static bool Verify(BasePlayer player, string permissionName = USE)
            {
                if (_instance.permission.UserHasPermission(player.UserIDString, permissionName))
                    return true;

                return false;
            }
        }

        #endregion Permissions
    }
}

// --- End of file: BetterCharcoal.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/block-bug-prevent ---
// --- Original File Path: B/BlockBugPrevent/BlockBugPrevent.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BlockBugPrevent", "sami37", "1.1.1", ResourceId = 2166)]
    [Description("Prevent foundation block build on another foundation.")]
    public class BlockBugPrevent : RustPlugin
    {
        void Loaded()
        {
			lang.RegisterMessages(new Dictionary<string,string>{
				["NotAllowed"] = "<color='#DD0000'>Your are not allowed to build foundation here.</color>"
			}, this);
        }

        private object RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }

            return target;
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            bool destroy = false;
            var player = planner.GetOwnerPlayer();
            if (player == null) return;
            BuildingBlock block = gameObject.GetComponent<BuildingBlock>();
            if (block == null) return;
            if (!block.PrefabName.Contains("foundation"))
                return;
            Vector3 sourcepos = block.transform.position;
            var entities = RaycastAll<BuildingBlock>(new Ray(sourcepos + new Vector3(0f, 0f, 0f), Vector3.up));
            if (entities.ToString() != "False")
            {
                BuildingBlock entitBlock = (BuildingBlock) entities;
                if (entitBlock.name.Contains("foundation") && !entitBlock.name.Contains("steps"))
                {
                    destroy = true;
                }
            }
            if (destroy)
            {
                block.Kill();
                SendReply(player, lang.GetMessage("NotAllowed", this));
            }
        }
    }
}

// --- End of file: BlockBugPrevent.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/booby-traps ---
// --- Original File Path: B/BoobyTraps/BoobyTraps.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Network;
using Rust;

namespace Oxide.Plugins
{
    [Info("BoobyTraps", "k1lly0u", "0.2.18")]
    [Description("Booby trap boxes and doors with a variety of traps")]
    class BoobyTraps : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Clans, Friends;

        private DynamicConfigFile datafile;

        private bool initialized;
                
        private List<ZoneList> m_RadiationZones;
        private List<Timer> m_TrapTimers;

        private Dictionary<ulong, TrapInfo> m_CurrentTraps;

        private const string GRENADE_FX = "assets/prefabs/weapons/f1 grenade/effects/bounce.prefab";
        private const string EXPLOSIVE_FX = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
        private const string BEANCAN_FX = "assets/prefabs/weapons/beancan grenade/effects/bounce.prefab";
        private const string RADIATION_FX = "assets/prefabs/weapons/beancan grenade/effects/beancan_grenade_explosion.prefab";
        private const string LANDMINE_FX = "assets/bundled/prefabs/fx/weapons/landmine/landmine_trigger.prefab";
        private const string BEARTRAP_FX = "assets/bundled/prefabs/fx/beartrap/arm.prefab";
        private const string SHOCK_FX = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";

        private const string LANDMINE_PREFAB = "assets/prefabs/deployable/landmine/landmine.prefab";
        private const string BEARTRAP_PREFAB = "assets/prefabs/deployable/bear trap/beartrap.prefab";
        private const string EXPLOSIVE_PREFAB = "assets/prefabs/tools/c4/explosive.timed.deployed.prefab";
        private const string BEANCAN_PREFAB = "assets/prefabs/weapons/beancan grenade/grenade.beancan.deployed.prefab";
        private const string GRENADE_PREFAB = "assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab";
        private const string FIRE_PREFAB = "assets/bundled/prefabs/oilfireballsmall.prefab";

        private const string EXPLOSIVE_PERMISSION = "boobytraps.explosives";
        private const string DEPLOY_PERMISSION = "boobytraps.deployables";
        private const string ELEMENT_PERMISSION = "boobytraps.elements";
        private const string ADMIN_PERMISSION = "boobytraps.admin";

        private const int PLAYER_MASK = 131072;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission(EXPLOSIVE_PERMISSION, this);
            permission.RegisterPermission(DEPLOY_PERMISSION, this);
            permission.RegisterPermission(ELEMENT_PERMISSION, this);
            permission.RegisterPermission(ADMIN_PERMISSION, this);

            LoadData();

            m_RadiationZones = new List<ZoneList>();
            m_TrapTimers = new List<Timer>();
        }

        private void OnServerInitialized()
        {
            if (!ConVar.Server.radiation)
            {
                configData.TrapTypes[Traps.Radiation].Enabled = false;
                SaveConfig();
            }

            RemoveInvalidTrapData();           
            initialized = true;           
        }
        
        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void Unload()
        {
            for (int i = 0; i < m_RadiationZones.Count; i++)
                m_RadiationZones[i].Destroy();

            m_RadiationZones.Clear();
            
            foreach (Timer trapTimer in m_TrapTimers)
                trapTimer.Destroy();

            SaveData();
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (!initialized || !entity || entity.IsDestroyed)
                return;

            if (entity is SupplyDrop)
            {
                if (configData.AutotrapSettings.UseAirdrops)
                    ProcessEntity(entity, configData.AutotrapSettings.AirdropChance);  
            }
            else if (entity is LootContainer)
            {
                if (configData.AutotrapSettings.UseLootContainers)
                    ProcessEntity(entity, configData.AutotrapSettings.LootContainerChance); 
            }
        }

        private void OnLootEntity(BasePlayer inventory, BaseEntity target)
        {
            if (!target || target.IsDestroyed)
                return;

            TryActivateTrap(target.net.ID, inventory);
        }

        private void OnEntityTakeDamage(BaseCombatEntity target, HitInfo info)
        {
            if (!target || target.IsDestroyed || info == null)
                return;

            TryActivateTrap(target.net.ID, info.InitiatorPlayer);
        }

        private void OnEntityDeath(BaseCombatEntity target, HitInfo info)
        {
            if (!target || target.IsDestroyed || info == null)
                return;

            TryActivateTrap(target.net.ID, info.InitiatorPlayer);
        }

        private void CanUseDoor(BasePlayer player, BaseLock locks)
        {
            BaseEntity target = locks.GetParentEntity();
            if (!target || target.IsDestroyed)
                return;

            TryActivateTrap(target.net.ID, player);
        }

        private void OnDoorOpened(Door target, BasePlayer player)
        {
            if (!target || target.IsDestroyed)
                return;

            TryActivateTrap(target.net.ID, player);
        }

        private void OnDoorClosed(Door target, BasePlayer player)
        {
            if (!target || target.IsDestroyed)
                return;

            TryActivateTrap(target.net.ID, player);
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!entity || entity.IsDestroyed)
                return;

            if (m_CurrentTraps.ContainsKey(entity.net.ID.Value))
                m_CurrentTraps.Remove(entity.net.ID.Value);
        }
        #endregion

        #region Functions
        private void RemoveInvalidTrapData()
        {
            List<ulong> list = Facepunch.Pool.GetList<ulong>();
            
            list.AddRange(m_CurrentTraps.Keys);

            list.ForEach((id) =>
            {
                if (BaseNetworkable.serverEntities.All(networkable => networkable.net.ID.Value != id))
                    m_CurrentTraps.Remove(id);
            });
            
            Facepunch.Pool.FreeList(ref list);
        }
        
        private void ProcessEntity(BaseEntity entity, int chance)
        {
            if (!SetRandom(chance))
                return;            

            Traps trap = configData.TrapTypes.Where(x => x.Value.Enabled).ToList().GetRandom().Key;

            SetTrap(entity, trap, string.Empty);

            if (configData.Options.NotifyRandomSetTraps)
                Puts($"Random trap has been set at {entity.transform.position} using trap {trap}");
        }

        private void SetTrap(BaseEntity entity, Traps trap, string owner) => m_CurrentTraps[entity.net.ID.Value] = 
            new TrapInfo(trap, entity.transform.position, owner, !string.IsNullOrEmpty(owner));   
        
        private bool TryPurchaseTrap(BasePlayer player, Traps trap)
        {
            if (configData.Options.OverrideCostsForAdmins && HasPermission(player.UserIDString, ADMIN_PERMISSION))
                return true;

            List<TrapCostEntry> costs = configData.TrapTypes[trap].Costs;

            Dictionary<int, int> itemToTake = new Dictionary<int, int>();

            for (int i = 0; i < costs.Count; i++)
            {
                TrapCostEntry trapCostEntry = costs[i];
                ItemDefinition itemDefinition;
                
                if (!ItemManager.itemDictionaryByName.TryGetValue(trapCostEntry.Shortname, out itemDefinition))
                {
                    PrintError($"Error finding a item with the shortname \"{trapCostEntry.Shortname}\". Please fix this mistake in your BoobyTrap config!");
                    continue;
                }

                if (!HasEnoughRes(player, itemDefinition.itemid, trapCostEntry.Amount))
                {
                    SendReply(player, Message("insufficientResources", player.UserIDString));
                    return false;
                }

                itemToTake[itemDefinition.itemid] = trapCostEntry.Amount;
            }

            foreach (KeyValuePair<int, int> item in itemToTake)
                TakeResources(player, item.Key, item.Value);

            return true;
        }

        private void TryActivateTrap(NetworkableId networkableId, BasePlayer player = null)
        {
            if (!IsBoobyTrapped(networkableId))
                return;

            TrapInfo info = m_CurrentTraps[networkableId.Value];

            if (player != null)
            {
                if (configData.Options.IgnoreTriggerForTrapOwner)
                {
                    if (info.trapOwner == player.UserIDString)
                        return;
                }

                if (configData.Options.IgnoreTriggerForFriendsOfTrapOwner)
                {
                    if (AreFriends(info.trapOwner, player.UserIDString) || IsClanmate(info.trapOwner, player.UserIDString))
                        return;
                }
            }

            string warningFX = string.Empty;
            string prefab = string.Empty;

            Vector3 location = info.location;
            
            TrapEntry trapEntry = configData.TrapTypes[info.trapType];
            
            float fuse = trapEntry.FuseTimer;
            float amount = trapEntry.DamageAmount;
            float radius = trapEntry.Radius;

            bool spawnPrefab = false;
            bool radiusSpawn = false;
            bool isRadiation = false;
            bool isFire = false;

            switch (info.trapType)
            {
                case Traps.BeancanGrenade:
                    warningFX = BEANCAN_FX;
                    prefab = BEANCAN_PREFAB;
                    spawnPrefab = true;
                    break;
                case Traps.Grenade:
                    warningFX = GRENADE_FX;
                    prefab = GRENADE_PREFAB;
                    spawnPrefab = true;
                    break;
                case Traps.Explosive:
                    warningFX = EXPLOSIVE_FX;
                    prefab = EXPLOSIVE_PREFAB;
                    spawnPrefab = true;
                    break;
                case Traps.Landmine:
                    warningFX = LANDMINE_FX;
                    prefab = LANDMINE_PREFAB;
                    amount = configData.TrapTypes[Traps.Landmine].Costs[0].Amount;
                    radiusSpawn = true;
                    break;
                case Traps.Beartrap:
                    warningFX = BEANCAN_FX;
                    prefab = BEARTRAP_PREFAB;
                    amount = configData.TrapTypes[Traps.Beartrap].Costs[0].Amount;
                    radiusSpawn = true;
                    break;
                case Traps.Radiation:
                    warningFX = EXPLOSIVE_FX;
                    prefab = RADIATION_FX;
                    isRadiation = true;
                    break;
                case Traps.Fire:
                    warningFX = BEANCAN_FX;
                    prefab = FIRE_PREFAB;
                    isFire = true;
                    break;
                case Traps.Shock:
                    warningFX = EXPLOSIVE_FX;
                    prefab = SHOCK_FX;
                    break;
            }

            m_CurrentTraps.Remove(networkableId.Value);

            if (configData.Options.PlayTrapWarningSoundFX)
                Effect.server.Run(warningFX, location);

            if (spawnPrefab)
            {
                BaseEntity entity = GameManager.server.CreateEntity(prefab, location, new Quaternion(), true);
                TimedExplosive timedExplosive = entity.GetComponent<TimedExplosive>();
                entity.Spawn();
                if (timedExplosive != null)
                {
                    timedExplosive.SetFuse(fuse);
                    timedExplosive.explosionRadius = radius;
                    timedExplosive.damageTypes = new List<DamageTypeEntry> { new DamageTypeEntry { amount = amount, type = DamageType.Explosion } };
                }
            }
            else
            {
                m_TrapTimers.Add(timer.In(fuse, () =>
                {
                    if (radiusSpawn)
                    {
                        float angle = 360 / amount;
                        for (int i = 0; i < amount; i++)
                        {
                            float ang = i * angle;
                            Vector3 position = GetPositionOnCircle(location, ang, radius);
                            BaseEntity entity = GameManager.server.CreateEntity(prefab, position, new Quaternion(), true);
                            entity.Spawn();
                        }
                    }
                    else if (isFire)
                    {
                        BaseEntity entity = GameManager.server.CreateEntity(prefab, location, new Quaternion(), true);
                        entity.Spawn();                        
                    }
                    else if (isRadiation)
                    {
                        Effect.server.Run(prefab, location);
                        InitializeZone(location, configData.TrapTypes[Traps.Radiation].DamageAmount, configData.TrapTypes[Traps.Radiation].Duration, configData.TrapTypes[Traps.Radiation].Radius);
                    }
                    else
                    {
                        Effect.server.Run(prefab, location);
                        List<BasePlayer> nearbyPlayers = new List<BasePlayer>();
                        Vis.Entities(location, radius, nearbyPlayers);
                        foreach (BasePlayer nearPlayer in nearbyPlayers)
                            nearPlayer.Hurt(amount, DamageType.ElectricShock, null, true);
                    }
                }));                
            }

            if (configData.Options.NotifyPlayersWhenTrapTriggered && player != null)
                m_TrapTimers.Add(timer.In(fuse, () => SendReply(player, string.Format(Message("triggered", player.UserIDString), info.trapType))));
        }

        private Vector3 GetPositionOnCircle(Vector3 pos, float ang, float radius)
        {
            Vector3 randPos;
            randPos.x = pos.x + radius * Mathf.Sin(ang * Mathf.Deg2Rad);
            randPos.z = pos.z + radius * Mathf.Cos(ang * Mathf.Deg2Rad);
            randPos.y = pos.y;
            
            Vector3 targetPos = GetGroundPosition(randPos);
            return targetPos;
        }

        private Vector3 GetGroundPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))            
                sourcePos.y = hitInfo.point.y;            
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        private BaseEntity FindValidEntity(BasePlayer player, bool set)
        {
            BaseEntity entity = FindEntity(player);
            if (entity == null)
            {
                SendReply(player, Message("invalidEntity", player.UserIDString));
                return null;
            }
            if (configData.Options.RequireBuildingPrivToTrap)
            {
                if (player.GetBuildingPrivilege() == null || !player.CanBuild())
                {
                    SendReply(player, Message("noPrivilege", player.UserIDString));
                    return null;
                }
            }
            if (configData.Options.RequireOwnershipToTrap)
            {
                if (entity.OwnerID != player.userID)
                {
                    SendReply(player, Message("notOwner", player.UserIDString));
                    return null;
                }
            }
            if (set && m_CurrentTraps.ContainsKey(entity.net.ID.Value))
            {
                SendReply(player, Message("hasTrap", player.UserIDString));
                return null;
            }
            return entity;
        }

        private BaseEntity FindEntity(BasePlayer player)
        {
            Vector3 currentRot = Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward;

            Vector3 eyesAdjust = new Vector3(0f, 1.5f, 0f);

            object rayResult = CastRay(player.transform.position + eyesAdjust, currentRot);

            if (rayResult is BaseEntity)
            {
                BaseEntity entity = rayResult as BaseEntity;

                if (entity.GetComponent<SupplyDrop>())
                {
                    if (!configData.Options.CanTrapSupplyDrops)
                        return null;
                }
                else if (entity.GetComponent<LootContainer>())
                {
                    if (!configData.Options.CanTrapLoot)
                        return null;
                }
                else if (entity.GetComponent<StorageContainer>())
                {
                    if (!configData.Options.CanTrapBoxes)
                        return null;
                }
                else if (entity.GetComponent<Door>())
                {
                    if (!configData.Options.CanTrapDoors)
                        return null;
                }
                
                return entity;
            }
            return null;
        }

        private object CastRay(Vector3 Pos, Vector3 Aim)
        {
            RaycastHit[] hits = Physics.RaycastAll(Pos, Aim);

            float distance = 100;
            object target = null;

            for (int i = 0; i < hits.Length; i++)
            {
                RaycastHit hit = hits[i];
           
                if (hit.collider.GetComponentInParent<BaseEntity>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BaseEntity>();
                    }
                }               
            }
            return target;
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }
        #endregion

        #region Helpers
        private bool HasPermission(string userId, string perm) => permission.UserHasPermission(userId, perm);

        private bool HasAnyPerm(string userId) => (HasPermission(userId, EXPLOSIVE_PERMISSION) || HasPermission(userId, DEPLOY_PERMISSION) || HasPermission(userId, ELEMENT_PERMISSION) || HasPermission(userId, ADMIN_PERMISSION));

        private bool IsBoobyTrapped(NetworkableId networkableId) => m_CurrentTraps.ContainsKey(networkableId.Value);

        private void RemoveTrap(NetworkableId networkableId) => m_CurrentTraps.Remove(networkableId.Value);

        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;

        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);

        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private int GetRandom(int chance) => UnityEngine.Random.Range(1, chance);

        private bool SetRandom(int chance) => GetRandom(chance) == 1;
        #endregion

        #region Radiation
        private void InitializeZone(Vector3 Location, float intensity, float duration, float radius)
        {
            RadiationZone radiationZone = new GameObject().AddComponent<RadiationZone>();
            radiationZone.Activate(Location, radius, intensity);

            ZoneList listEntry = new ZoneList { zone = radiationZone };

            listEntry.time = timer.Once(duration, () => DestroyZone(listEntry));

            m_RadiationZones.Add(listEntry);
        }

        private void DestroyZone(ZoneList zone)
        {
            if (m_RadiationZones.Contains(zone))
            {
                int index = m_RadiationZones.FindIndex(a => a.zone == zone.zone);
                m_RadiationZones[index].time.Destroy();

                UnityEngine.Object.Destroy(m_RadiationZones[index].zone.gameObject);
                m_RadiationZones.Remove(zone);
            }
        }

        public class ZoneList
        {
            public RadiationZone zone;
            public Timer time;

            public void Destroy()
            {
                time.Destroy();
                UnityEngine.Object.Destroy(zone.gameObject);
            }
        }

        public class RadiationZone : MonoBehaviour
        {
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "Radiation Zone";
            }
            public void Activate(Vector3 pos, float radius, float amount)
            {                
                transform.position = pos;

                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = radius;

                TriggerRadiation triggerRadiation = gameObject.GetComponent<TriggerRadiation>() ?? gameObject.AddComponent<TriggerRadiation>();
                triggerRadiation.RadiationAmountOverride = amount;
                triggerRadiation.interestLayers = PLAYER_MASK;
                triggerRadiation.enabled = true;

                gameObject.SetActive(true);
                enabled = true;
            }                
        }
        #endregion

        #region Commands
        [ChatCommand("trap")]
        private void cmdTrap(BasePlayer player, string command, string[] args)
        {
            if (!HasAnyPerm(player.UserIDString))
                return;

            if (args.Length == 0)
            {
                SendReply(player, string.Format(Message("help1", player.UserIDString), Title, Version, configData.Options.CanTrapDoors, configData.Options.CanTrapBoxes, configData.Options.CanTrapLoot, configData.Options.CanTrapSupplyDrops));
                SendReply(player, Message("help2", player.UserIDString));

                Dictionary<Traps, TrapEntry> types = configData.TrapTypes;

                if (HasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(player, Message("help3", player.UserIDString));
                    SendReply(player, Message("help4", player.UserIDString));
                }
                else
                {
                    List<string> trapTypes = new List<string>();
                    if (HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION))
                    {
                        if (types[Traps.BeancanGrenade].Enabled && !types[Traps.BeancanGrenade].AdminOnly)
                            trapTypes.Add("Beancan");
                        if (types[Traps.Grenade].Enabled && !types[Traps.Grenade].AdminOnly)
                            trapTypes.Add("Grenade");
                        if (types[Traps.Explosive].Enabled && !types[Traps.BeancanGrenade].AdminOnly)
                            trapTypes.Add("Explosive");
                    }
                    if (HasPermission(player.UserIDString, DEPLOY_PERMISSION))
                    {
                        if (types[Traps.Landmine].Enabled && !types[Traps.Landmine].AdminOnly)
                            trapTypes.Add("Landmine");
                        if (types[Traps.Beartrap].Enabled && !types[Traps.Beartrap].AdminOnly)
                            trapTypes.Add("Beartrap");                        
                    }
                    if (HasPermission(player.UserIDString, ELEMENT_PERMISSION))
                    {
                        if (types[Traps.Radiation].Enabled && !types[Traps.Radiation].AdminOnly && ConVar.Server.radiation)
                            trapTypes.Add("Radiation");
                        if (types[Traps.Fire].Enabled && !types[Traps.Fire].AdminOnly)
                            trapTypes.Add("Fire");
                        if (types[Traps.Shock].Enabled && !types[Traps.Shock].AdminOnly)
                            trapTypes.Add("Shock");
                    }
                    SendReply(player, $"{Message("help5", player.UserIDString)} <color=#939393>{trapTypes.ToSentence()}</color>");
                }
                return;         
            }
            switch (args[0].ToLower())
            {
                case "cost":
                    if (args.Length > 1)
                    {                        
                        Traps trap;
                        switch (args[1].ToLower())
                        {
                            case "beancan":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.BeancanGrenade;
                                    break;
                                }
                            case "grenade":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Grenade;
                                    break;
                                }
                            case "explosive":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Explosive;
                                    break;
                                }
                            case "landmine":
                                {
                                    if (!HasPermission(player.UserIDString, DEPLOY_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Landmine;
                                    break;
                                }
                            case "beartrap":
                                {
                                    if (!HasPermission(player.UserIDString, DEPLOY_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Beartrap;
                                    break;
                                }
                            case "radiation":
                                {
                                    if (!ConVar.Server.radiation || (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION)))
                                        return;
                                    trap = Traps.Radiation;
                                    break;
                                }
                            case "fire":
                                {
                                    if (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Fire;
                                    break;
                                }
                            case "shock":
                                {
                                    if (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Shock;
                                    break;
                                }
                            default:
                                SendReply(player, Message("invalidTrap", player.UserIDString));
                                return;
                        }
                        if (!configData.TrapTypes[trap].Enabled || (configData.TrapTypes[trap].AdminOnly && !HasPermission(player.UserIDString, ADMIN_PERMISSION)))
                        {
                            SendReply(player, Message("notEnabled", player.UserIDString));
                            return;
                        }

                        string costs = string.Format(Message("getCosts", player.UserIDString), trap);

                        for (int i = 0; i < configData.TrapTypes[trap].Costs.Count; i++)
                        {
                            TrapCostEntry trapCostEntry = configData.TrapTypes[trap].Costs[i];
                            ItemDefinition itemDefinition;
                            
                            if (!ItemManager.itemDictionaryByName.TryGetValue(trapCostEntry.Shortname, out itemDefinition))
                            {
                                PrintError($"Error finding a item with the shortname \"{trapCostEntry.Shortname}\". Please fix this mistake in your BoobyTrap config!");
                                continue;
                            }
                            costs += $"\n<color=#00CC00>{trapCostEntry.Amount}</color> <color=#939393>x</color> <color=#00CC00>{itemDefinition.displayName.translated}</color>";
                        }

                        SendReply(player, costs);
                    }
                    return;
                case "set":
                    if (args.Length > 1)
                    {
                        BaseEntity entity = FindValidEntity(player, true);
                        if (entity == null)                                                    
                            return;

                        Traps trap;                    
                        switch (args[1].ToLower())
                        {
                            case "beancan":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.BeancanGrenade;                                    
                                    break;
                                }
                            case "grenade":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Grenade;
                                    break;
                                }
                            case "explosive":
                                {
                                    if (!HasPermission(player.UserIDString, EXPLOSIVE_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Explosive;
                                    break;
                                }
                            case "landmine":
                                {
                                    if (!HasPermission(player.UserIDString, DEPLOY_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Landmine;
                                    break;
                                }
                            case "beartrap":
                                {
                                    if (!HasPermission(player.UserIDString, DEPLOY_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Beartrap;
                                    break;
                                }
                            case "radiation":
                                {
                                    if (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Radiation;
                                    break;
                                }
                            case "fire":
                                {
                                    if (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Fire;
                                    break;
                                }
                            case "shock":
                                {
                                    if (!HasPermission(player.UserIDString, ELEMENT_PERMISSION) && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                                        return;
                                    trap = Traps.Shock;
                                    break;
                                }
                            default:
                                SendReply(player, Message("invalidTrap", player.UserIDString));
                                return;
                        }
                        if (!configData.TrapTypes[trap].Enabled || (configData.TrapTypes[trap].AdminOnly && !HasPermission(player.UserIDString, ADMIN_PERMISSION)))
                        {
                            SendReply(player, Message("notEnabled", player.UserIDString));
                            return;
                        }
                        if (TryPurchaseTrap(player, trap))
                        {
                            SetTrap(entity, trap, player.UserIDString);
                            SendReply(player, string.Format(Message("trapSet", player.UserIDString), trap));
                        }
                    }
                    return;
                case "remove":
                    {
                        BaseEntity entity = FindValidEntity(player, false);
                        if (entity == null)
                            return;
                        if (configData.Options.RequireOwnershipToTrap && (entity.OwnerID != 0U && entity.OwnerID != player.userID))
                        {
                            SendReply(player, Message("notOwner", player.UserIDString));
                            return;
                        }
                        if (!m_CurrentTraps.ContainsKey(entity.net.ID.Value))
                        {
                            SendReply(player, Message("noTrap", player.UserIDString));
                            return;
                        }
                        else
                        {
                            m_CurrentTraps.Remove(entity.net.ID.Value);
                            SendReply(player, Message("removeSuccess", player.UserIDString));
                            return;
                        }
                    }
                case "check":
                    {
                        BaseEntity entity = FindValidEntity(player, false);
                        if (entity == null)
                            return;
                        if (configData.Options.RequireOwnershipToTrap && (entity.OwnerID != 0U && entity.OwnerID != player.userID))
                        {
                            SendReply(player, Message("notOwner", player.UserIDString));
                            return;
                        }
                        if (!m_CurrentTraps.ContainsKey(entity.net.ID.Value))
                        {
                            SendReply(player, Message("noTrap", player.UserIDString));
                            return;
                        }
                        else
                        {
                            TrapInfo info = m_CurrentTraps[entity.net.ID.Value];                            
                            SendReply(player, string.Format(Message("trapInfo", player.UserIDString), info.trapType));
                            return;
                        }
                    }
                case "removeall":
                    {
                        if (!player.IsAdmin && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                        {
                            SendReply(player, Message("noPerm", player.UserIDString));
                            return;
                        }
                        m_CurrentTraps.Clear();
                        SendReply(player, Message("removedAll", player.UserIDString));
                        return;
                    }
                case "list":
                    {
                        if (!player.IsAdmin && !HasPermission(player.UserIDString, ADMIN_PERMISSION))
                        {
                            SendReply(player, Message("noPerm", player.UserIDString));
                            return;
                        }
                        SendEchoConsole(player.net.connection, string.Format(Message("currentTraps", player.UserIDString), m_CurrentTraps.Count));
                        Puts(string.Format(Message("currentTraps", player.UserIDString), m_CurrentTraps.Count));
                        foreach(var trap in m_CurrentTraps)
                        {
                            string trapInfo = string.Format("{0} - {1} - {2}", trap.Key, trap.Value.trapType, trap.Value.location);
                            SendEchoConsole(player.net.connection, trapInfo);
                            Puts(trapInfo);
                        }
                        return;
                    }    
            }
        }

        [ConsoleCommand("trap")]
        private void ccmdTrap(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, $"-- {Title}  v{Version} --");
                SendReply(arg, Message("conHelp"));
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "removeall":
                    m_CurrentTraps.Clear();
                    SendReply(arg, Message("removedAll"));
                    return;
                case "list":
                    Puts(string.Format(Message("currentTraps"), m_CurrentTraps.Count));

                    foreach (KeyValuePair<ulong, TrapInfo> trap in m_CurrentTraps)
                    {
                        string trapInfo = string.Format("{0} - {1} - {2}", trap.Key, trap.Value.trapType, trap.Value.location);
                        Puts(trapInfo);
                    }
                    return;
                default:
                    return;
            }
        }
        #endregion

        #region Friends
        private bool AreFriends(string playerId, string friendId)
        {
            if (Friends)
                return (bool)Friends?.Call("AreFriends", playerId, friendId);
            return true;
        }

        private bool IsClanmate(string playerId, string friendId)
        {
            if (Clans)
            {
                object playerTag = Clans?.Call("GetClanOf", playerId);
                object friendTag = Clans?.Call("GetClanOf", friendId);
                if (playerTag is string && friendTag is string)
                {
                    if (!string.IsNullOrEmpty((string)playerTag) && !string.IsNullOrEmpty((string)friendTag) && (playerTag == friendTag))
                        return true;
                }
                return false;
            }
            return true;
        }
        #endregion

        #region Config 
        private ConfigData configData;

        private class TrapCostEntry
        {
            public string Shortname { get; set; }
            public int Amount { get; set; }
        }

        private class TrapEntry
        {
            public bool Enabled { get; set; }
            public bool AdminOnly { get; set; }
            public float DamageAmount { get; set; }
            public float Radius { get; set; }
            public float FuseTimer { get; set; }
            public float Duration { get; set; }
            public List<TrapCostEntry> Costs { get; set; }

        }

        private class Autotraps
        {
            public bool UseAirdrops { get; set; }
            public bool UseLootContainers { get; set; }
            public int AirdropChance { get; set; }
            public int LootContainerChance { get; set; }
        }

        private class Options
        {
            public bool NotifyRandomSetTraps { get; set; }
            public bool NotifyPlayersWhenTrapTriggered { get; set; }
            public bool PlayTrapWarningSoundFX { get; set; }
            public bool CanTrapBoxes { get; set; }
            public bool CanTrapLoot { get; set; }
            public bool CanTrapSupplyDrops { get; set; }
            public bool CanTrapDoors { get; set; }
            public bool RequireOwnershipToTrap { get; set; }
            public bool RequireBuildingPrivToTrap { get; set; }
            public bool IgnoreTriggerForTrapOwner { get; set; }
            public bool IgnoreTriggerForFriendsOfTrapOwner { get; set; }
            public bool OverrideCostsForAdmins { get; set; }
        }

        private class ConfigData
        {
            public Autotraps AutotrapSettings { get; set; }
            public Dictionary<Traps, TrapEntry> TrapTypes { get; set; }
            public Options Options { get; set; }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AutotrapSettings = new Autotraps
                {
                    AirdropChance = 40,
                    LootContainerChance = 40,
                    UseAirdrops = true,
                    UseLootContainers = true
                },
                Options = new Options
                {
                    NotifyRandomSetTraps = true,
                    NotifyPlayersWhenTrapTriggered = true,
                    PlayTrapWarningSoundFX = true,
                    CanTrapBoxes = true,
                    CanTrapDoors = true,
                    CanTrapLoot = false,
                    CanTrapSupplyDrops = false,
                    OverrideCostsForAdmins = true,
                    RequireBuildingPrivToTrap = true,
                    RequireOwnershipToTrap = true,
                    IgnoreTriggerForTrapOwner = false,
                    IgnoreTriggerForFriendsOfTrapOwner = false,
                },
                TrapTypes = new Dictionary<Traps, TrapEntry>
                {
                    {Traps.BeancanGrenade, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "grenade.beancan",
                                Amount = 2
                            }
                        },
                        DamageAmount = 30,
                        Radius = 4,
                        FuseTimer = 2,
                        Enabled = true
                    }
                    },
                    {Traps.Beartrap, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "trap.bear",
                                Amount = 10
                            }
                        },
                        DamageAmount = 0,
                        Radius = 2,
                        FuseTimer = 2,
                        Enabled = true
                    }
                    },
                    {Traps.Explosive, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "explosive.timed",
                                Amount = 2
                            }
                        },
                        DamageAmount = 110,
                        Radius = 10,
                        FuseTimer = 3,
                        Enabled = true
                    }
                    },
                    {Traps.Fire, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "lowgradefuel",
                                Amount = 50
                            }
                        },
                        DamageAmount = 1,
                        Radius = 2,
                        FuseTimer = 3,
                        Enabled = true
                    }
                    },
                    {Traps.Grenade, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "grenade.f1",
                                Amount = 2
                            }
                        },
                        DamageAmount = 75,
                        Radius = 5,
                        FuseTimer = 3,
                        Enabled = true
                    }
                    },
                    {Traps.Landmine, new TrapEntry
                    {
                        AdminOnly = false,
                        Costs = new List<TrapCostEntry>
                        {
                            new TrapCostEntry
                            {
                                Shortname = "trap.landmine",
                                Amount = 10
                            }
                        },
                        DamageAmount = 0,
                        Radius = 2,
                        FuseTimer = 2,
                        Enabled = true
                    }
                    },
                    {Traps.Radiation, new TrapEntry
                    {
                        AdminOnly = true,
                        Costs = new List<TrapCostEntry>(),
                        DamageAmount = 20,
                        Radius = 10,
                        FuseTimer = 3,
                        Duration = 20,
                        Enabled = true
                    }
                    },
                    {Traps.Shock, new TrapEntry
                    {
                        AdminOnly = true,
                        Costs = new List<TrapCostEntry>(),
                        DamageAmount = 95,
                        Radius = 2,
                        FuseTimer = 2,
                        Enabled = true
                    }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        enum Traps
        {
            BeancanGrenade,
            Grenade,
            Explosive,
            Landmine,
            Beartrap,
            Radiation,
            Fire,
            Shock
        }

        private class TrapInfo
        {            
            public Traps trapType;
            public Vector3 location;
            public string trapOwner;
            public bool saveTrap; 

            public TrapInfo() { }

            public TrapInfo(Traps trapType, Vector3 location, string trapOwner, bool saveTrap)
            {
                this.trapType = trapType;
                this.location = location;
                this.trapOwner = trapOwner;
                this.saveTrap = saveTrap;
            }
        }

        private void SaveData() => datafile.WriteObject(m_CurrentTraps);

        private void LoadData()
        {
            datafile = Interface.Oxide.DataFileSystem.GetFile("boobytrap_data");
            datafile.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };

            m_CurrentTraps = datafile.ReadObject<Dictionary<ulong, TrapInfo>>() ?? new Dictionary<ulong, TrapInfo>();

            foreach (ulong key in m_CurrentTraps.Where(x => !x.Value.saveTrap).Select(x => x.Key))
                m_CurrentTraps.Remove(key);
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion

        #region Messaging
        private string Message(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        private Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            ["insufficientResources"] = "<color=#939393>You have insufficient resources to purchase this trap!</color>" ,
            ["triggered"] = "<color=#939393>You just triggered a </color><color=#00CC00>{0}</color> <color=#939393>trap!</color>" ,
            ["invalidEntity"] = "<color=#939393>You are not looking at a valid trap-able entity!</color>",
            ["noPrivilege"] = "<color=#939393>You must have building privilege to place/remove a trap!</color>" ,
            ["notOwner"] = "<color=#939393>You must own the entity you wish to place/remove a trap on!</color>",
            ["hasTrap"] = "<color=#939393>This entity already has a trap placed on it!</color>",
            ["help1"] = "<color=#00CC00>-- {0}  v{1} --</color>\n<color=#939393>With this plugin you can set traps on a variety of objects.\nDoors : {2}\nStorage Containers : {3}\nLoot Containers : {4}\nSupply Drops : {5}</color>",
            ["help2"] = "<color=#00CC00>/trap cost <traptype></color><color=#939393> - Displays the cost to place this trap</color>\n<color=#00CC00>/trap set <traptype></color><color=#939393> - Sets a trap on the object you are looking at</color><color=#00CC00>\n/trap remove</color><color=#939393> - Removes a trap set by yourself on the object you are looking at</color><color=#00CC00>\n/trap check</color><color=#939393> - Check the object your are looking at for traps set by yourself</color>",
            ["help3"] = "<color=#00CC00>-- Available Types --</color><color=#939393>\nBeancan, Grenade, Explosive, Landmine, Beartrap, Radiation, Fire, Shock</color>",
            ["help4"] = "<color=#00CC00>/trap removeall</color><color=#939393>> - Removes all active traps on the map</color><color=#00CC00>\n/trap list</color><color=#939393> - Lists all traps in console</color>",
            ["help5"] = "<color=#00CC00>-- Available Types -- </color>\n",
            ["invalidTrap"] = "<color=#939393>Invalid trap type selected</color>",
            ["noTrap"] = "<color=#939393>The object you are looking at does not have a trap on it!</color>",
            ["removeSuccess"] = "<color=#939393>You have successfully removed the trap from this object!</color>",
            ["trapInfo"] = "<color=#939393>This object is trapped with a </color><color=#00CC00>{0}</color><color=#939393> trap!</color>",
            ["noPerm"] = "<color=#939393>You do not have permission to use this command!</color>",
            ["removedAll"] = "<color=#939393>You have successfully removed all traps!</color>",
            ["currentTraps"] = "-- There are currently {0} active traps --\n[Entity ID] - [Trap Type] - [Location]",
            ["conHelp"] = "trap removeall - Removes all active traps on the map\ntrap list - Lists all traps",
            ["trapSet"] = "<color=#939393>You have successfully set a </color><color=#00CC00>{0} </color><color=#939393>trap on this object!</color>" ,
            ["getCosts"] = "<color=#939393>Costs to set a </color><color=#00CC00>{0}</color> <color=#939393>trap:</color>" ,
            ["notEnabled"] = "<color=#939393>This trap is not enabled!</color>"
        };
        #endregion
    }
}


// --- End of file: BoobyTraps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-drone-collision ---
// --- Original File Path: B/BetterDroneCollision/BetterDroneCollision.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Better Drone Collision", "WhiteThunder", "1.1.0")]
    [Description("Overhauls drone collision damage so it's more intuitive.")]
    internal class BetterDroneCollision : CovalencePlugin
    {
        #region Fields

        private const float ReplacementHurtVelocityThreshold = float.MaxValue;

        [PluginReference]
        private readonly Plugin DroneSettings;

        private Configuration _config;
        private float? _vanillaHurtVelocityThreshold;

        #endregion

        #region Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null)
                    continue;

                OnEntitySpawned(drone);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                ResetDrone(drone);
            }
        }

        private void OnEntitySpawned(Drone drone)
        {
            if (!IsDroneEligible(drone))
                return;

            _vanillaHurtVelocityThreshold ??= drone.hurtVelocityThreshold;

            var drone2 = drone;
            NextTick(() =>
            {
                if (drone2 != null)
                {
                    TryReplaceDroneCollision(drone2);
                }
            });
        }

        #endregion

        #region Helper Methods

        private static bool DroneCollisionReplaceWasBlocked(Drone drone)
        {
            return Interface.CallHook("OnDroneCollisionReplace", drone) is false;
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return drone.skinID == 0 && drone is not DeliveryDrone;
        }

        private bool TryReplaceDroneCollision(Drone drone)
        {
            if (DroneCollisionReplaceWasBlocked(drone))
                return false;

            drone.hurtVelocityThreshold = ReplacementHurtVelocityThreshold;
            DroneCollisionReplacer.AddToDrone(this, drone);
            return true;
        }

        private void ResetDrone(Drone drone)
        {
            if (drone.hurtVelocityThreshold == ReplacementHurtVelocityThreshold
                && _vanillaHurtVelocityThreshold != null)
            {
                drone.hurtVelocityThreshold = (float)_vanillaHurtVelocityThreshold;
            }

            DroneCollisionReplacer.RemoveFromDrone(drone);
        }

        #endregion

        #region Collision Replacer

        private class DroneCollisionReplacer : FacepunchBehaviour
        {
            public static void AddToDrone(BetterDroneCollision plugin, Drone drone)
            {
                var component = drone.gameObject.AddComponent<DroneCollisionReplacer>();
                component._plugin = plugin;
                component._drone = drone;
            }

            public static void RemoveFromDrone(Drone drone)
            {
                Destroy(drone.gameObject.GetComponent<DroneCollisionReplacer>());
            }

            private BetterDroneCollision _plugin;
            private Drone _drone;
            private float _nextDamageTime;

            private Configuration _config => _plugin._config;

	        private void OnCollisionEnter(Collision collision)
            {
                if (collision == null || collision.gameObject == null)
                    return;

                if (Time.time < _nextDamageTime)
                    return;

                var magnitude = collision.relativeVelocity.magnitude;
                if (magnitude < _config.MinCollisionVelocity)
                    return;

                // Avoid damage when landing.
                if (Vector3.Dot(collision.relativeVelocity.normalized, _drone.transform.up) > 0.5f)
                    return;

                var otherEntity = collision.gameObject.ToBaseEntity();
                if (otherEntity is TimedExplosive)
                    return;

                if (otherEntity is DroppedItem)
                {
                    for (var i = 0; i < collision.contactCount; i++)
                    {
                        var contact = collision.GetContact(i);
                        Physics.IgnoreCollision(contact.thisCollider, contact.otherCollider);
                    }

                    // If the drone just had a collision, assume it was triggered by the Dropped Item and re-enable the drone.
                    if (Math.Abs(_drone.lastCollision - TimeEx.currentTimestamp) < 0.001f)
                    {
                        _drone.lastCollision = 0;
                    }

                    return;
                }

                var damage = magnitude * _config.CollisionDamageMultiplier;

                // If DroneSettings is not loaded, it's probably safe to assume that drones are using default protection properties.
                // Default protection properties make a drone immune to collision damage, so bypass protection.
                // Without this bypass, using this plugin standalone would make drones immune to collision which is not desirable.
                var useProtection = _plugin.DroneSettings != null;
                _drone.Hurt(damage, DamageType.Collision, useProtection: useProtection);

                Interface.CallHook("OnDroneCollisionImpact", _drone, collision);
                _nextDamageTime = Time.time + _config.MinTimeBetweenImpacts;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("MinCollisionVelocity")]
            public float MinCollisionVelocity = 3;

            [JsonProperty("MinTimeBetweenImpacts")]
            public float MinTimeBetweenImpacts = 0.25f;

            [JsonProperty("CollisionDamageMultiplier")]
            public float CollisionDamageMultiplier = 1;
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: BetterDroneCollision.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/boom-boom-bears ---
// --- Original File Path: B/BoomBoomBears/BoomBoomBears.cs ---

using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{ 
    [Info("Boom Boom Bears", "August", "1.0.6")]
    [Description("Bears explode with a fire rocket on death")]

    public class BoomBoomBears : RustPlugin
    {
        #region Fields/Localization/Config
        
        private PluginConfig config;
        private const string Perm = "boomboombears.use";
        private const string PermManage = "boomboombears.manage";
        private Random Num = new Random();
        
        private string[] SupportedPrefabs =
        {
            "assets/prefabs/ammo/rocket/rocket_basic.prefab",
            "assets/prefabs/ammo/rocket/rocket_fire.prefab",
            "assets/prefabs/ammo/rocket/rocket_hv.prefab",
            "assets/prefabs/ammo/rocket/rocket_smoke.prefab",
        };
            
        void Init()
        {

            permission.RegisterPermission(Perm, this);
            permission.RegisterPermission(PermManage, this);
            
            config = Config.ReadObject<PluginConfig>();

            if (!SupportedPrefabs.Contains(config.Prefab))
            {
                PrintWarning(Lang("InvalidPrefab"));
                config.Prefab = "assets/prefabs/ammo/rocket/rocket_fire.prefab";
            }
        }
        private class PluginConfig
        {
            public bool IsEnabled;
            public bool RandomEnabled;
            public int Chance;
            public string Prefab;
        }
        
        private void SaveConfig()
        {
            Config.WriteObject(config, true);
        }
        
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                IsEnabled = true,
                RandomEnabled = true,
                Chance = 5,
                Prefab = "assets/prefabs/ammo/rocket/rocket_fire.prefab"
            };
        }
        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "Error: No Permission",
                ["Syntax"] = "Error: Syntax",
                ["InvalidPrefab"] = "Error: An invalid prefab is set in the config. Please change the prefab and reload the plugin.",

                ["Status"] = "Boom boom bears: {0}; Random feature: {1}; Chance: 1/{2}",

                ["BoomEnabled"] = "Boom boom bears are now enabled.",
                ["BoomDisabled"] = "Boom boom bears are now disabled.",

                ["RandomEnabled"] = "If enabled, bears now have a chance to explode on death",
                ["RandomDisabled"] = "If enabled, bears are now guaranteed to explode on death.",

                ["NewChance"] = "If all features are enabled, bears now have a 1/{0} chance to explode on death."

            }, this);
        }
        #endregion
        
        #region Hooks
        void OnEntityDeath(Bear bear, HitInfo info)
        {
            if (!bear || !(bear.lastAttacker is BasePlayer))
            {
                return;
            }
            
            BasePlayer player = bear.lastAttacker.ToPlayer();
            
            if (!permission.UserHasPermission(player.UserIDString, Perm))
            {
                return;
            }

            if (!config.RandomEnabled && !GetRandom())
            {
                return;
            }

            BaseEntity entity = GameManager.server?.CreateEntity(config.Prefab, new Vector3(bear.ServerPosition.x,
                                                                                bear.ServerPosition.y + 1,
                                                                                   bear.ServerPosition.z));
            
            if (!entity)
            {
                return;
            }

            entity.Spawn();
        }
        #endregion
        
        #region Commands
        [ChatCommand("bbbears")]
        void BoomBearsCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermManage))
            {
                player.ChatMessage(Lang("NoPerm", player.UserIDString));
                return;
            }
            if (args.Length == 0 || args.Length > 2)
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "stat":
                case "status":
                    player.ChatMessage(Lang("Status", player.UserIDString, config.IsEnabled, config.RandomEnabled, config.Chance));
                    return;
                
                case "toggle":

                    if (args.Length != 2)
                    {
                        player.ChatMessage(Lang("Syntax", player.UserIDString));
                        return;
                    }
                    
                    switch(args[1].ToLower())
                        {
                            case "bears":
                            case "bear":
                                ToggleEnabled(player);
                                break;
                            
                            case "random":
                                ToggleRandom(player);
                                break;
                            
                            default:
                                player.ChatMessage(Lang("Syntax", player.UserIDString));
                                return;
                        }
                    break;
                
                default:
                    int chance;

                    if (int.TryParse(args[0], out chance) && chance > 0)
                    {
                        config.Chance = chance;
                        player.ChatMessage(Lang("NewChance", player.UserIDString, config.Chance));
                        return;
                    }
                    
                    player.ChatMessage(Lang("Syntax", player.UserIDString));
                    break;
            }
            SaveConfig();
        }
        #endregion
        
        #region Methods and Helpers
        bool GetRandom()
        {
            if (Num.Next(0, config.Chance) == 0)
            {
                return true;
            }
            return false;
        }

        void ToggleEnabled(BasePlayer player)
        {
            if (config.IsEnabled)
            {
                player.ChatMessage(Lang("BoomDisabled", player.UserIDString));
                Unsubscribe(nameof(OnEntityDeath));
            }
            else
            {
                player.ChatMessage(Lang("BoomEnabled", player.UserIDString));
                Subscribe(nameof(OnEntityDeath));
            }
            config.IsEnabled = !config.IsEnabled;
        }

        void ToggleRandom(BasePlayer player)
        {
            if (config.RandomEnabled)
            {
                player.ChatMessage(Lang("RandomDisabled", player.UserIDString));
            }
            else
            {
                player.ChatMessage(Lang("RandomEnabled", player.UserIDString));
            }

            config.RandomEnabled = !config.RandomEnabled;
        }
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args); 
        #endregion
    }
}

// --- End of file: BoomBoomBears.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/backup-extended ---
// --- Original File Path: B/BackupExtended/BackupExtended.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using ProtoBuf;
using Network;

namespace Oxide.Plugins
{
	[Info("Backup Extended", "Fujikura", "1.0.1")]
	class BackupExtended : RustPlugin
	{
		bool Changed;
		bool _backup;
		int currentRetry;
		bool wasShutDown;
		string [] backupFolders;
		string [] backupFoldersOxide;
		string [] backupFoldersShutdown;
		string [] backupFoldersShutdownOxide;

		int numberOfBackups;
		bool backupBroadcast;
		int backupDelay;
		bool useBroadcastDelay;
		string prefix;
		string prefixColor;
		bool useTimer;
		int timerInterval;
		int maxPlayers;
		int maxRetry;
		int delayRetrySeconds;
		string currentIdentity;
		bool includeOxideInBackups;

		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			numberOfBackups = Convert.ToInt32(GetConfig("Settings", "numberOfBackups", 8));
			includeOxideInBackups = Convert.ToBoolean(GetConfig("Settings", "includeOxideInBackups", true));
			backupBroadcast = Convert.ToBoolean(GetConfig("Notification", "backupBroadcast", false));
			backupDelay = Convert.ToInt32(GetConfig("Notification", "backupDelay", 5));
			useBroadcastDelay = Convert.ToBoolean(GetConfig("Notification", "useBroadcastDelay", true));
			prefix = Convert.ToString(GetConfig("Notification", "prefix", "BACKUP"));
			prefixColor = Convert.ToString(GetConfig("Notification", "prefixColor", "orange"));
			useTimer = Convert.ToBoolean(GetConfig("Timer", "useTimer", false));
			timerInterval = Convert.ToInt32(GetConfig("Timer", "timerInterval", 3600));
			maxPlayers = Convert.ToInt32(GetConfig("Timer", "maxPlayers", 20));
			maxRetry =  Convert.ToInt32(GetConfig("Timer", "maxRetry", 10));
			delayRetrySeconds = Convert.ToInt32(GetConfig("Timer", "delayRetrySeconds", 120));

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}

		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			                      {
									{"backupfinish", "Backup process finished."},
									{"backupannounce", "Starting server backup in {0} seconds."},
									{"backuprunning", "Running server backup."},
									{"backupautomatic", "Running automated server backup every {0} seconds."},
									{"backupdelay", "Backup delayed ({0} of {1}) for next '{2}' seconds."},
								  },this);
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}

		void Loaded()
		{
			LoadVariables();
			LoadDefaultMessages();
			wasShutDown = false;
		}

		void OnServerInitialized()
        {
			currentIdentity = ConVar.Server.rootFolder.Replace("server/", "");
			if (Interface.Oxide.CommandLine.HasVariable("server.identity"))
				currentIdentity = Interface.Oxide.CommandLine.GetVariable("server.identity");
			backupFolders = BackupFolders();
			backupFoldersShutdown = BackupFoldersShutdown();
			if (includeOxideInBackups)
			{
				backupFoldersOxide = BackupFoldersOxide();
				backupFoldersShutdownOxide = BackupFoldersShutdownOxide();
			}
			currentRetry = 0;
			if (useTimer)
			{
				timer.Once(timerInterval, TimerCheck);
				Puts(string.Format(lang.GetMessage("backupautomatic", this), timerInterval));
			}
        }

		void OnPluginUnloaded(Plugin name)
		{
			if (Interface.Oxide.IsShuttingDown && !wasShutDown)
			{
				wasShutDown = true;
				try {
					DirectoryEx.Backup(BackupFoldersShutdown());
					if (includeOxideInBackups)
						DirectoryEx.Backup(BackupFoldersShutdownOxide());
					} catch {}
			}
		}

		IEnumerator BackupCreateI(bool manual = false)
		{
			DirectoryEx.Backup(BackupFolders());
			yield return new WaitForEndOfFrame();
			DirectoryEx.CopyAll(ConVar.Server.rootFolder, backupFolders[0]);
			yield return new WaitForEndOfFrame();
			if (includeOxideInBackups)
				DirectoryEx.CopyAll("oxide", backupFoldersOxide[0]);
			if (!manual)
				Puts(lang.GetMessage("backupfinish", this));
			yield return null;
		}

		void BackupCreate(bool manual = false)
		{
			DirectoryEx.Backup(BackupFolders());
			DirectoryEx.CopyAll(ConVar.Server.rootFolder, backupFolders[0]);
			if (includeOxideInBackups)
				DirectoryEx.CopyAll("oxide", backupFoldersOxide[0]);
			if (!manual)
				Puts(lang.GetMessage("backupfinish", this));
		}

		void TimerCheck()
		{
			if (SaveRestore.IsSaving)
			{
				timer.Once(1f, TimerCheck);
				return;
			}
			if (BasePlayer.activePlayerList.Count > maxPlayers && currentRetry < maxRetry)
			{
				currentRetry++;
				Puts(string.Format(lang.GetMessage("backupdelay", this), currentRetry, maxRetry, delayRetrySeconds));
				timer.Once(delayRetrySeconds, TimerCheck);
			}
			else
			{
				currentRetry = 0;
				ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "extbackup");
				timer.Once(timerInterval, TimerCheck);
			}
		}

		[ConsoleCommand("extbackup")]
		void ccmdExtBackup(ConsoleSystem.Arg arg)
		{
			if(arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (backupBroadcast)
			{
				if (useBroadcastDelay)
				{
					SendReply(arg, string.Format(lang.GetMessage("backupannounce", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ), backupDelay));
					BroadcastChat(string.Format(lang.GetMessage("backupannounce", this), backupDelay));
					timer.Once(backupDelay, () => BackupRun(arg));
				}
				else
				{
					timer.Once(0f, () => BackupRun(arg));
				}
			}
			else
				timer.Once(0f, () => BackupRun(arg));
		}

		void BackupRun(ConsoleSystem.Arg arg)
		{
			if (backupBroadcast)
				BroadcastChat(lang.GetMessage("backuprunning", this));
			SendReply(arg, lang.GetMessage("backuprunning", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
			NextFrame( () => ServerMgr.Instance.StartCoroutine(BackupCreateI(true)));
			SendReply(arg, lang.GetMessage("backupfinish", this, arg.Connection != null ? arg.Connection.userid.ToString() : null ));
			if (backupBroadcast)
				BroadcastChat(lang.GetMessage("backupfinish", this));
		}

		string [] BackupFolders()
		{
			string [] dp = new string[numberOfBackups];
			for (int i = 0; i < numberOfBackups; i++)
				dp[i] = $"backup/{i}/"+ currentIdentity;
			return dp;
		}

		string [] BackupFoldersOxide()
		{
			string [] dp = new string[numberOfBackups];
			for (int i = 0; i < numberOfBackups; i++)
				dp[i] = $"backup/{i}/oxide";
			return dp;
		}

		string [] BackupFoldersShutdown()
		{
			string [] dp = new string[numberOfBackups];
			for (int i = 3; i < numberOfBackups; i++)
				dp[i] = $"backup/{i}/" + currentIdentity;
			return dp;
		}

		string [] BackupFoldersShutdownOxide()
		{
			string [] dp = new string[numberOfBackups];
			for (int i = 3; i < numberOfBackups; i++)
				dp[i] = $"backup/{i}/oxide";
			return dp;
		}

		void BroadcastChat(string msg = null) => PrintToChat(msg == null ? prefix : "<color=" + prefixColor + ">" + prefix + "</color>: " + msg);
	}
}


// --- End of file: BackupExtended.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-loot ---
// --- Original File Path: B/BetterLoot/BetterLoot.cs ---

using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Configuration;
using Random = System.Random;
using Oxide.Core;
using Oxide.Core.Plugins;
using ConVar;

namespace Oxide.Plugins
{
    [Info("BetterLoot", "Tryhard & Khan", "3.5.9")]
    [Description("A light loot container modification system")]
    public class BetterLoot : RustPlugin
    {
        #region Fields

        [PluginReference] Plugin CustomLootSpawns;
        
        private static BetterLoot _instance;
        private static PluginConfig _config;
        private bool Changed = true;
        private bool initialized;
        private double baseItemRarity = 2;
        private int populatedContainers;
        private const string Admin = "betterloot.admin";
        
        StoredExportNames storedExportNames = new StoredExportNames();
        StoredBlacklist storedBlacklist = new StoredBlacklist();
        Random rng = new Random();
        Dictionary<string, List<string>[]> Items = new Dictionary<string, List<string>[]>();
        Dictionary<string, List<string>[]> Blueprints = new Dictionary<string, List<string>[]>();
        Dictionary<string, int[]> itemWeights = new Dictionary<string, int[]>();
        Dictionary<string, int[]> blueprintWeights = new Dictionary<string, int[]>();
        Dictionary<string, int> totalItemWeight = new Dictionary<string, int>();
        Dictionary<string, int> totalBlueprintWeight = new Dictionary<string, int>();

        List<Item> items = new List<Item>();
        List<string> itemNames = new List<string>();
        List<int> itemBlueprints = new List<int>();

        private static int RarityIndex(Rarity rarity)
        {
            switch (rarity)
            {
                case Rarity.None: return 0;
                case Rarity.Common: return 1;
                case Rarity.Uncommon: return 2;
                case Rarity.Rare: return 3;
                case Rarity.VeryRare: return 4;
            }
            return -1;
        }

        #endregion

        #region DataFile

        DynamicConfigFile lootTable;
        Dictionary<string, object> lootTables = null;
        DynamicConfigFile getFile(string file) => Interface.Oxide.DataFileSystem.GetDatafile($"{Name}/{file}");
        bool chkFile(string file) => Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/{file}");

        private class StoredExportNames
        {
            public int version;
            public Dictionary<string, string> AllItemsAvailable = new Dictionary<string, string>();
        }
        
        private int ItemWeight(double baseRarity, int index) { return (int)(Math.Pow(baseRarity, 4 - index) * 1000); }
        
        private object GetAmounts(ItemAmount amount, int mul = 1)
        {
            if (amount.itemDef.isWearable || (amount.itemDef.condition.enabled && amount.itemDef.GetComponent<ItemModDeployable>() == null))
                mul = 1;
            object options = new Dictionary<string, object>
            {
                ["Min"] = (int)amount.amount * mul,
                ["Max"] = ((ItemAmountRanged)amount).maxAmount > 0f &&
                          ((ItemAmountRanged)amount).maxAmount > amount.amount
                    ? (int)((ItemAmountRanged)amount).maxAmount * mul
                    : (int)amount.amount * mul,
            };
            return options;
        }
        
        private void GetLootSpawn(LootSpawn lootSpawn, ref Dictionary<string, object> items)
        {
            if (lootSpawn.subSpawn != null && lootSpawn.subSpawn.Length > 0)
            {
                foreach (var entry in lootSpawn.subSpawn)
                    GetLootSpawn(entry.category, ref items);
                return;
            }
            if (lootSpawn.items != null && lootSpawn.items.Length > 0)
            {
                foreach (var amount in lootSpawn.items)
                {
                    object options = GetAmounts(amount, 1);
                    string itemName = amount.itemDef.shortname;
                    if (amount.itemDef.spawnAsBlueprint)
                        itemName += ".blueprint";
                    if (!items.ContainsKey(itemName))
                        items.Add(itemName, options);
                }
            }
        }
        
        private void LoadAllContainers()
        {
            try { lootTable = getFile("LootTables"); }
            catch (JsonReaderException e)
            {
                PrintWarning($"JSON error in 'LootTables' > Line: {e.LineNumber} | {e.Path}");
                Interface.GetMod().UnloadPlugin(Name);
                return;
            }
            lootTables = new Dictionary<string, object>();
            lootTables = lootTable["LootTables"] as Dictionary<string, object>;
            if (lootTables == null)
                lootTables = new Dictionary<string, object>();
            bool wasAdded = false;
            foreach (var lootPrefab in _config.Generic.WatchedPrefabs)
            {
                if (!lootTables.ContainsKey((string)lootPrefab))
                {
                    var loot = GameManager.server.FindPrefab((string)lootPrefab)?.GetComponent<LootContainer>();
                    if (loot == null)
                        continue;
                    var container = new Dictionary<string, object>();
                    container.Add("Enabled", !((string)lootPrefab).Contains("bradley_crate") && !((string)lootPrefab).Contains("heli_crate"));
                    container.Add("Scrap", loot.scrapAmount);
                    int slots = 0;
                    if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        for (int i = 0; i < lootSpawnSlots.Length; i++)
                            slots += lootSpawnSlots[i].numberToSpawn;
                    }
                    else
                        slots = loot.maxDefinitionsToSpawn;
                    container.Add("ItemsMin", slots);
                    container.Add("ItemsMax", slots);
                    container.Add("MaxBPs", 1);
                    var itemList = new Dictionary<string, object>();
                    if (loot.lootDefinition != null)
                        GetLootSpawn(loot.lootDefinition, ref itemList);
                    else if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        foreach (var lootSpawnSlot in lootSpawnSlots)
                        {
                            GetLootSpawn(lootSpawnSlot.definition, ref itemList);
                        }
                    }
                    container.Add("ItemList", itemList);
                    lootTables.Add((string)lootPrefab, container);
                    wasAdded = true;
                }

            }
            if (wasAdded)
            {
                lootTable.Set("LootTables", lootTables);
                lootTable.Save();
            }
            wasAdded = false;
            bool wasRemoved = false;
            int activeTypes = 0;
            foreach (var lootTable in lootTables.ToList())
            {
                var loot = GameManager.server.FindPrefab(lootTable.Key)?.GetComponent<LootContainer>();
                if (loot == null)
                {
                    lootTables.Remove(lootTable.Key);
                    wasRemoved = true;
                    continue;
                }
                var container = lootTable.Value as Dictionary<string, object>;
                if (!container.ContainsKey("Enabled"))
                {
                    container.Add("Enabled", true);
                    wasAdded = true;
                }
                if ((bool)container["Enabled"])
                    activeTypes++;
                if (!container.ContainsKey("Scrap"))
                {
                    container.Add("Scrap", loot.scrapAmount);
                    wasAdded = true;
                }

                int slots = 0;
                if (loot.LootSpawnSlots.Length > 0)
                {
                    LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                    for (int i = 0; i < lootSpawnSlots.Length; i++)
                        slots += lootSpawnSlots[i].numberToSpawn;
                }
                else
                    slots = loot.maxDefinitionsToSpawn;
                if (!container.ContainsKey("MaxBPs"))
                {
                    container.Add("MaxBPs", 1);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMin"))
                {
                    container.Add("ItemsMin", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMax"))
                {
                    container.Add("ItemsMax", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMax"))
                {
                    container.Add("ItemsMax", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemList"))
                {
                    var itemList = new Dictionary<string, object>();
                    if (loot.lootDefinition != null)
                        GetLootSpawn(loot.lootDefinition, ref itemList);
                    else if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        for (int i = 0; i < lootSpawnSlots.Length; i++)
                        {
                            LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
                            GetLootSpawn(lootSpawnSlot.definition, ref itemList);
                        }
                    }
                    container.Add("ItemList", itemList);
                    wasAdded = true;
                }
                Items.Add(lootTable.Key, new List<string>[5]);
                Blueprints.Add(lootTable.Key, new List<string>[5]);
                for (var i = 0; i < 5; ++i)
                {
                    Items[lootTable.Key][i] = new List<string>();
                    Blueprints[lootTable.Key][i] = new List<string>();
                }
                foreach (var itemEntry in container["ItemList"] as Dictionary<string, object>)
                {
                    bool isBP = itemEntry.Key.EndsWith(".blueprint") ? true : false;
                    var def = ItemManager.FindItemDefinition(itemEntry.Key.Replace(".blueprint", ""));

                    if (def != null)
                    {
                        if (isBP && def.Blueprint != null && def.Blueprint.isResearchable)
                        {
                            int index = (int)def.rarity;
                            if (!Blueprints[lootTable.Key][index].Contains(def.shortname))
                                Blueprints[lootTable.Key][index].Add(def.shortname);
                        }
                        else
                        {
                            int index = 0;
                            object indexoverride;
                            if (_config.Rare.Override.TryGetValue(def.shortname, out indexoverride))
                                index = Convert.ToInt32(indexoverride);
                            else
                                index = (int)def.rarity;
                            if (!Items[lootTable.Key][index].Contains(def.shortname))
                                Items[lootTable.Key][index].Add(def.shortname);
                        }
                    }
                }
                totalItemWeight.Add(lootTable.Key, 0);
                totalBlueprintWeight.Add(lootTable.Key, 0);
                itemWeights.Add(lootTable.Key, new int[5]);
                blueprintWeights.Add(lootTable.Key, new int[5]);
                for (var i = 0; i < 5; ++i)
                {
                    totalItemWeight[lootTable.Key] += (itemWeights[lootTable.Key][i] = ItemWeight(baseItemRarity, i) * Items[lootTable.Key][i].Count);
                    totalBlueprintWeight[lootTable.Key] += (blueprintWeights[lootTable.Key][i] = ItemWeight(baseItemRarity, i) * Blueprints[lootTable.Key][i].Count);
                }

            }
            if (wasAdded || wasRemoved)
            {
                lootTable.Set("LootTables", lootTables);
                lootTable.Save();
            }
            lootTable.Clear();
            Puts($"Using '{activeTypes}' active of '{lootTables.Count}' supported containertypes");
        }

        private void SaveExportNames()
        {
            storedExportNames = Interface.GetMod().DataFileSystem.ReadObject<StoredExportNames>("BetterLoot\\NamesList");
            if (storedExportNames.AllItemsAvailable.Count == 0 || (int)storedExportNames.version != Rust.Protocol.network)
            {
                storedExportNames = new StoredExportNames();
                var exportItems = new List<ItemDefinition>(ItemManager.itemList);
                storedExportNames.version = Rust.Protocol.network;
                foreach (var it in exportItems)
                    storedExportNames.AllItemsAvailable.Add(it.shortname, it.displayName.english);
                Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\NamesList", storedExportNames);
                Puts($"Exported {storedExportNames.AllItemsAvailable.Count} items to 'NamesList'");
            }
        }
        
        private class StoredBlacklist
        {
            public List<string> ItemList = new List<string>();
        }

        private void LoadBlacklist()
        {
            storedBlacklist = Interface.GetMod().DataFileSystem.ReadObject<StoredBlacklist>("BetterLoot\\Blacklist");
            if (storedBlacklist.ItemList.Count != 0) return;
            Puts("No Blacklist found, creating new file...");
            storedBlacklist = new StoredBlacklist();
            storedBlacklist.ItemList.Add("flare");
            Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\Blacklist", storedBlacklist);
        }

        private void SaveBlacklist() => Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\Blacklist", storedBlacklist);
        
        #endregion

        #region Config

        private class PluginConfig : SerializableConfiguration
        {
            public Generic Generic = new Generic();
            public Loot Loot = new Loot();
            [JsonProperty("Rarity")]
            public Rare Rare = new Rare();

            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }
        
        private class Generic
        {
            public double blueprintProbability = 0.11;
            public bool listUpdatesOnLoaded = true;
            public bool removeStackedContainers = true;
            public List<object> WatchedPrefabs = new List<object>();
        }

        private class Loot
        {
            public bool enableHammerLootCycle = false;
            public double hammerLootCycleTime = 3.0;
            public int lootMultiplier = 1;
            public int scrapMultiplier = 1;
        }

        private class Rare
        {
            public Dictionary<string, object> Override = new Dictionary<string, object>
            {
                {"autoturret", 4},
                {"lmg.m249", 4},
                {"targeting.computer", 3},
            };
        }
        
        private void CheckConfig()
        {
            foreach (GameManifest.PrefabProperties category in GameManifest.Current.prefabProperties)
            {
                if (!(category.name.Contains("resource/loot") || 
                      category.name.Contains("misc/supply drop/supply_drop") || 
                      category.name.Contains("/npc/m2bradley/bradley_crate") || 
                      category.name.Contains("/npc/patrol helicopter/heli_crate") || 
                      category.name.Contains("/deployable/chinooklockedcrate/chinooklocked") || 
                      category.name.Contains("/deployable/chinooklockedcrate/codelocked") || 
                      category.name.Contains("prefabs/radtown") || 
                      category.name.Contains("props/roadsigns")) ||
                    category.name.Contains("radtown/ore") || 
                    category.name.Contains("static") || 
                    category.name.Contains("/spawners") || 
                    category.name.Contains("radtown/desk") || 
                    category.name.Contains("radtown/loot_component_test")) continue;
                if (!_config.Generic.WatchedPrefabs.Contains(category.name))
                {
                    _config.Generic.WatchedPrefabs.Add(category.name);
                }
            }
            SaveConfig();
        }
        
        protected override void LoadDefaultConfig() => _config = new PluginConfig();
        
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    PrintWarning($"Generating Config File for Better Loot");
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving Better Loot");
                    SaveConfig();
                }
            }
            catch (Exception ex)
            {
                PrintWarning("Failed to load Better Loot config file (is the config file corrupt?) (" + ex.Message + ")");
            }
        }
        protected override void SaveConfig()
        {
            //PrintToConsole($"Configuration changes saved to {Name}.json");
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Updater

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>().ToDictionary(prop => prop.Name, prop => ToObject(prop.Value));
                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue) token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        #endregion

        #region Oxide

        private void Init()
        {
            CheckConfig();
            LoadBlacklist();
            _instance = this;
        }

        private void OnServerInitialized()
        {
            ItemManager.Initialize();
            permission.RegisterPermission(Admin, this);
            LoadAllContainers();
            UpdateInternals(_config.Generic.listUpdatesOnLoaded);
        }

        private void Unload()
        {
            var gameObjects = UnityEngine.Object.FindObjectsOfType<HammerHitLootCycle>().ToList();
            if (gameObjects.Count > 0) 
            {
                foreach (var objects in gameObjects) 
                {
                    UnityEngine.Object.Destroy(objects);
                }
            }
            _instance = null;
        }
        
        private object OnLootSpawn(LootContainer container)
        {
            if (!initialized || container == null)
                return null;
            if (CustomLootSpawns != null && CustomLootSpawns.Call<bool>("IsLootBox", container as BaseEntity))
                return null;
            if (PopulateContainer(container))
            {
                ItemManager.DoRemoves();
                return true;
            }
            return null;
        }
        
        //void OnLootEntity(BasePlayer player, BaseEntity target)
        //{
        //Puts($"{player.displayName} looted {target.PrefabName}");
        //}

        #endregion

        #region Core
        
        private bool PopulateContainer(LootContainer container)
        {
            Dictionary<string, object> con;
            object containerobj;
            if (!lootTables.TryGetValue(container.PrefabName, out containerobj))
                return false;
            con = containerobj as Dictionary<string, object>;
            if (!(bool)con["Enabled"])
                return false;
            var lootitemcount = (con["ItemList"] as Dictionary<string, object>)?.Count();
            int itemCount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(Mathf.Min((int)con["ItemsMin"], (int)con["ItemsMax"])) * 100f, Convert.ToSingle(Mathf.Max((int)con["ItemsMin"], (int)con["ItemsMax"])) * 100f) / 100f);
            if (lootitemcount > 0 && itemCount > lootitemcount && lootitemcount < 36)
                itemCount = (int)lootitemcount;
            if (container.inventory == null)
            {
                container.CreateInventory(true);
                container.OnInventoryFirstCreated(container.inventory);
            }
            else
            {
                container.inventory.Clear();
                container.inventory.capacity = 36;
                ItemManager.DoRemoves();
            }

            itemNames.Clear();
            items.Clear();
            itemBlueprints.Clear();

            var maxRetry = 10;
            for (int i = 0; i < itemCount; ++i)
            {
                if (maxRetry == 0)
                {
                    break;
                }
                var item = MightyRNG(container.PrefabName, itemCount, (bool)(itemBlueprints.Count >= (int)con["MaxBPs"]));

                if (item == null)
                {
                    --maxRetry;
                    --i;
                    continue;
                }
                if (itemNames.Contains(item.info.shortname) || (item.IsBlueprint() && itemBlueprints.Contains(item.blueprintTarget)))
                {
                    item.Remove();
                    --maxRetry;
                    --i;
                    continue;
                }
                else
                    if (item.IsBlueprint())
                    itemBlueprints.Add(item.blueprintTarget);
                else
                    itemNames.Add(item.info.shortname);
                items.Add(item);
                if (storedBlacklist.ItemList.Contains(item.info.shortname)) 
                {
                    items.Remove(item);
					item.Remove(); // broken item fix
                }
            }
            foreach (var item in items.Where(x => x != null && x.IsValid()))
                if (!item.MoveToContainer(container.inventory, -1, false)) { item.DoRemove(); } // broken item fix / fixes full container 
            if ((int)con["Scrap"] > 0)
            {
                int scrapCount = (int)con["Scrap"];
                Item item = ItemManager.Create(ItemManager.FindItemDefinition("scrap"), scrapCount * _config.Loot.scrapMultiplier, 0uL); 
                if (!item.MoveToContainer(container.inventory, -1, false)) { item.DoRemove(); } // broken item fix
            }
            container.inventory.capacity = container.inventory.itemList.Count;
            container.inventory.MarkDirty();
            container.SendNetworkUpdate();
            populatedContainers++;
            return true;
        }

        private void UpdateInternals(bool doLog)
        {
            SaveExportNames();
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
            Puts("Updating internals ...");
            populatedContainers = 0;
            NextTick(() =>
            {
                if (_config.Generic.removeStackedContainers)
                    FixLoot();
                foreach (var container in BaseNetworkable.serverEntities.Where(p => p != null && p as BaseEntity != null && p is LootContainer).Cast<LootContainer>().ToList())
                {
                    if (container == null)
                        continue;
                    if (CustomLootSpawns != null && CustomLootSpawns.Call<bool>("IsLootBox", container as BaseEntity))
                        continue;
                    if (PopulateContainer(container))
                        populatedContainers++;
                }
                
                Puts($"Populated '{populatedContainers}' supported containers.");
                initialized = true;
                populatedContainers = 0;
                ItemManager.DoRemoves();
            });
        }
        
        private void FixLoot()
        {
            var spawns = Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.isActiveAndEnabled).
                OrderBy(c => c.transform.position.x).ThenBy(c => c.transform.position.z).ThenBy(c => c.transform.position.z)
                .ToList();

            var count = spawns.Count();
            var racelimit = count * count;

            var antirace = 0;
            var deleted = 0;

            for (var i = 0; i < count; i++)
            {
                var box = spawns[i];
                var pos = new Vector2(box.transform.position.x, box.transform.position.z);

                if (++antirace > racelimit)
                {
                    return;
                }

                var next = i + 1;
                while (next < count)
                {
                    var box2 = spawns[next];
                    var pos2 = new Vector2(box2.transform.position.x, box2.transform.position.z);
                    var distance = Vector2.Distance(pos, pos2);

                    if (++antirace > racelimit)
                    {
                        return;
                    }

                    if (distance < 0.25f)
                    {
                        spawns.RemoveAt(next);
                        count--;
                        (box2 as BaseEntity).KillMessage();
                        deleted++;
                    }
                    else break;
                }
            }

            if (deleted > 0)
                Puts($"Removed {deleted} stacked LootContainer");
            else
                Puts($"No stacked LootContainer found.");
            ItemManager.DoRemoves();
        }
        
        private Item MightyRNG(string type, int itemCount, bool blockBPs = false)
        {
            bool asBP = rng.NextDouble() < _config.Generic.blueprintProbability && !blockBPs;
            List<string> selectFrom;
            int limit = 0;
            string itemName;
            Item item;
            int maxRetry = 10 * itemCount;
            do
            {
                selectFrom = null;
                item = null;
                if (asBP)
                {
                    var r = rng.Next(totalBlueprintWeight[type]);
                    for (var i = 0; i < 5; ++i)
                    {
                        limit += blueprintWeights[type][i];
                        if (r < limit)
                        {
                            selectFrom = Blueprints[type][i];
                            break;
                        }
                    }
                }
                else
                {
                    var r = rng.Next(totalItemWeight[type]);
                    for (var i = 0; i < 5; ++i)
                    {
                        limit += itemWeights[type][i];
                        if (r < limit)
                        {
                            selectFrom = Items[type][i];
                            break;
                        }
                    }
                }
                if (selectFrom == null)
                {
                    if (--maxRetry <= 0)
                        break;
                    continue;
                }
                itemName = selectFrom[rng.Next(0, selectFrom.Count)];
                ItemDefinition itemDef = ItemManager.FindItemDefinition(itemName);
                if (asBP && itemDef.Blueprint != null && itemDef.Blueprint.isResearchable)
                {
                    var blueprintBaseDef = ItemManager.FindItemDefinition("blueprintbase");
                    item = ItemManager.Create(blueprintBaseDef, 1, 0uL);
                    item.blueprintTarget = itemDef.itemid;
                }
                else
                    item = ItemManager.CreateByName(itemName, 1);
                if (item == null || item.info == null)
                    continue;
                break;
            } while (true);
            if (item == null)
                return null;
            object itemOptions;
            if (((lootTables[type] as Dictionary<string, object>)["ItemList"] as Dictionary<string, object>).TryGetValue(item.info.shortname, out itemOptions))
            {
                Dictionary<string, object> options = itemOptions as Dictionary<string, object>;
                item.amount = UnityEngine.Random.Range(Math.Min((int)options["Min"], (int)options["Max"]), Math.Max((int)options["Min"], (int)options["Max"])) * _config.Loot.lootMultiplier;
                //if (options.ContainsKey("SkinId"))
                    //item.skin = (uint)options["SkinId"];

            }
            item.OnVirginSpawn();
            return item;
        }
        
        private bool ItemExists(string name)
        {
            // remove useless loop
            ItemDefinition itemDef = ItemManager.itemList.Find((ItemDefinition x) => x.shortname == name);
            if (itemDef != null) return true;            
            return false;
        }
        
        private bool isSupplyDropActive()
        {
            Dictionary<string, object> con;
            object containerobj;
            if (!lootTables.TryGetValue("assets/prefabs/misc/supply drop/supply_drop.prefab", out containerobj))
                return false;
            con = containerobj as Dictionary<string, object>;
            if ((bool)con["Enabled"])
                return true;
            return false;
        }

        #endregion

        [ChatCommand("blacklist")]
        private void CmdChatBlacklistNew(BasePlayer player, string command, string[] args)
        {
            if (!initialized)
            {
                SendReply(player, BLLang( "initialized")); return;
            }
            if (!permission.UserHasPermission(player.UserIDString, Admin))
            {
                SendReply(player, BLLang("perm")); return;
            }
            if (args.Length == 0)
            {
                if (storedBlacklist.ItemList.Count == 0)
                {
                    SendReply(player, BLLang("none"));
                }
                else
                {
                    var sb = new StringBuilder();
                    foreach (var item in storedBlacklist.ItemList)
                    {
                        if (sb.Length > 0)
                            sb.Append(", ");
                        sb.Append(item);
                    }
                    SendReply(player, BLLang("blocked", player.UserIDString, sb.ToString()));
                }
                return;
            }

            switch (args[0].ToLower())
            {
                case "additem":
                    if (!ItemExists(args[1]))
                    {
                        SendReply(player, BLLang("notvalid", player.UserIDString, args[1]));
                        return;
                    }
                    if (!storedBlacklist.ItemList.Contains(args[1]))
                    {
                        storedBlacklist.ItemList.Add(args[1]);
                        UpdateInternals(false);
                        SendReply(player, BLLang("blockedpass", player.UserIDString, args[1]));
                        SaveBlacklist();
                        return;
                    }
                    SendReply(player, BLLang("blockedtrue", player.UserIDString, args[1]));
                    break;
                case "deleteitem":
                    if (!ItemExists(args[1]))
                    {
                        SendReply(player, BLLang("notvalid", player.UserIDString, args[1]));
                        return;
                    }
                    if (storedBlacklist.ItemList.Contains(args[1]))
                    {
                        storedBlacklist.ItemList.Remove(args[1]);
                        UpdateInternals(false);
                        SendReply(player, BLLang("unblacklisted", player.UserIDString, args[1]));
                        SaveBlacklist();
                        return;
                    }
                    SendReply(player, BLLang("blockedfalse", player.UserIDString, args[1]));
                    break;
                default:
                    SendReply(player, BLLang("syntax"));
                    break;
            }
        }

        #region Hammer loot cycle

        object OnMeleeAttack(BasePlayer player, HitInfo c)
        {
            //Puts($"OnMeleeAttack works! You hit {c.HitEntity.PrefabName}"); DEBUG FOR TESTING
            var item = player.GetActiveItem();
            if (item.hasCondition) return null;
            //Puts($"{item.ToString()}");
            if (!player.IsAdmin || c.HitEntity.GetComponent<LootContainer>() == null || !item.ToString().Contains("hammer") || !_config.Loot.enableHammerLootCycle)  return null;
            var inv = c.HitEntity.GetComponent<StorageContainer>();
            inv.gameObject.AddComponent<HammerHitLootCycle>();
            player.inventory.loot.StartLootingEntity(inv, false);
            player.inventory.loot.AddContainer(inv.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", inv.panelName);

            //Timer s = timer.Every(1f, () => { PopulateContainer(inv})
            return null;
            }

        private class HammerHitLootCycle : FacepunchBehaviour
        {
            private void Awake()
            {
                if (!_instance.initialized) return;
                InvokeRepeating(Repeater, (float)_config.Loot.hammerLootCycleTime, (float)_config.Loot.hammerLootCycleTime);
            }
            private void Repeater()
            {
                if (!enabled) return;
                LootContainer loot = GetComponent<LootContainer>();
                _instance.Puts($"{loot}");
                _instance.PopulateContainer(loot);
            }
            private void PlayerStoppedLooting(BasePlayer player)
            {
                //_instance.Puts($"Ended looting of the box"); Doesn't call but it works for a reason I don't quite understand
                CancelInvoke(Repeater);
                Destroy(this);
            }
        }

        #endregion

        #region Lang

        private string BLLang(string key, string id = null) => lang.GetMessage(key, this, id);
        private string BLLang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "initialized", "Plugin not enabled"},
                { "perm", "You are not authorized to use this command"},
                { "syntax", "Usage: /blacklist [additem|deleteitem] \"ITEMNAME\""},
                { "none", "There are no blacklisted items"},
                { "blocked", "Blacklisted items: {0}"},
                { "notvalid", "Not a valid item: {0}"},
                {"blockedpass", "The item '{0}' is now blacklisted"},
                {"blockedtrue", "The item '{0}' is already blacklisted}"},
                {"unblacklisted", "The item '{0}' has been unblacklisted"},
                {"blockedfalse", "The item '{0}' is not blacklisted"},
            }, this); //en
        }

        #endregion
    }
}

// --- End of file: BetterLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-actions ---
// --- Original File Path: B/BuildingActions/BuildingActions.cs ---

using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Building Actions", "Iv Misticos", "1.1.2")]
    [Description("Rotate and demolish buildings when you want!")]
    class BuildingActions : RustPlugin
    {
        #region Configuration

        private Configuration _config;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Owner Can Demolish")]
            public bool DemolishOwner = true;
            
            [JsonProperty(PropertyName = "Owner Can Repair")]
            public bool RepairOwner = true;
            
            [JsonProperty(PropertyName = "Owner Can Rotate")]
            public bool RotateOwner = true;
            
            [JsonProperty(PropertyName = "Owner Can Upgrade")]
            public bool UpgradeOwner = true;
            
            [JsonProperty(PropertyName = "In-game Friend Can Demolish")]
            public bool DemolishFriend = true;
            
            [JsonProperty(PropertyName = "In-game Friend Can Repair")]
            public bool RepairFriend = true;
            
            [JsonProperty(PropertyName = "In-game Friend Can Rotate")]
            public bool RotateFriend = true;
            
            [JsonProperty(PropertyName = "In-game Friend Can Upgrade")]
            public bool UpgradeFriend = true;
            
            [JsonProperty(PropertyName = "Authorized Can Demolish")]
            public bool DemolishAuthorized = true;
            
            [JsonProperty(PropertyName = "Authorized Can Repair")]
            public bool RepairAuthorized = true;
            
            [JsonProperty(PropertyName = "Authorized Can Rotate")]
            public bool RotateAuthorized = true;
            
            [JsonProperty(PropertyName = "Authorized Can Upgrade")]
            public bool UpgradeAuthorized = true;
            
            [JsonProperty(PropertyName = "Admin Can Demolish")]
            public bool DemolishAdmin = true;
            
            [JsonProperty(PropertyName = "Admin Can Repair")]
            public bool RepairAdmin = true;
            
            [JsonProperty(PropertyName = "Admin Can Rotate")]
            public bool RotateAdmin = true;
            
            [JsonProperty(PropertyName = "Admin Can Upgrade")]
            public bool UpgradeAdmin = true;

            [JsonProperty(PropertyName = "Ignore settings")]
            public bool IgnoreSettings = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
        
        #region Hooks
        
        private void OnServerInitialized()
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<BuildingBlock>())
            {
                TryChangeProperties(entity);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            var block = entity as BuildingBlock;
            if (block == null)
                return;
            
            TryChangeProperties(block);
        }

        private object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player, bool immediate)
        {
            var block = entity as BuildingBlock;
            if (block == null || _config.IgnoreSettings)
                return null;

            return _config.DemolishOwner && block.OwnerID == player.userID ||
                   _config.DemolishFriend && AreRelationshipFriends(player, block.OwnerID) ||
                   _config.DemolishAuthorized && IsAuthorized(player, block) ||
                   _config.DemolishAdmin && player.IsAdmin
                ? (object) null
                : false;
        }

        private object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            var block = entity as BuildingBlock;
            if (block == null || _config.IgnoreSettings)
                return null;

            return _config.RepairOwner && block.OwnerID == player.userID ||
                   _config.RepairFriend && AreRelationshipFriends(player, block.OwnerID) ||
                   _config.RepairAuthorized && IsAuthorized(player, block) ||
                   _config.RepairAdmin && player.IsAdmin
                ? (object) null
                : false;
        }

        private object OnStructureRotate(BaseCombatEntity entity, BasePlayer player)
        {
            var block = entity as BuildingBlock;
            if (block == null || _config.IgnoreSettings)
                return null;

            return _config.RotateOwner && block.OwnerID == player.userID ||
                   _config.RotateFriend && AreRelationshipFriends(player, block.OwnerID) ||
                   _config.RotateAuthorized && IsAuthorized(player, block) ||
                   _config.RotateAdmin && player.IsAdmin
                ? (object) null
                : false;
        }

        private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            var block = entity as BuildingBlock;
            if (block == null || _config.IgnoreSettings)
                return null;

            return _config.UpgradeOwner && block.OwnerID == player.userID ||
                   _config.UpgradeFriend && AreRelationshipFriends(player, block.OwnerID) ||
                   _config.UpgradeAuthorized && IsAuthorized(player, block) ||
                   _config.UpgradeAdmin && player.IsAdmin
                ? (object) null
                : false;
        }
        
        #endregion
        
        #region Helpers

        private void TryChangeProperties(BuildingBlock block)
        {
            block.CancelInvoke(block.StopBeingRotatable);
            block.CancelInvoke(block.StopBeingDemolishable);
            
            block.SetFlag(BaseEntity.Flags.Reserved1, true);
            block.SetFlag(BaseEntity.Flags.Reserved2, true);
        }

        private bool AreRelationshipFriends(BasePlayer player, ulong target) =>
            RelationshipManager.ServerInstance.FindTeam(player.currentTeam)?.members?.Contains(target) ?? false;

        private bool IsAuthorized(BasePlayer player, BaseEntity block) =>
            block.GetBuildingPrivilege()?.IsAuthed(player) ?? false;

        #endregion
    }
}

// --- End of file: BuildingActions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/better-chat-mute ---
// --- Original File Path: B/BetterChatMute/BetterChatMute.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Better Chat Mute", "LaserHydra", "1.2.1")]
    [Description("Simple mute system, made for use with Better Chat")]
    internal class BetterChatMute : CovalencePlugin
    {
        private static Dictionary<string, MuteInfo> _mutes;
        private bool _isDataDirty, _globalMute;
        
        #region Hooks

        private void Loaded()
        {
            permission.RegisterPermission("betterchatmute.permanent", this);

            LoadData(out _mutes);
            SaveData(_mutes);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
                ["No Reason"] = "Unknown reason",
                ["Muted"] = "{player} was muted by {initiator}: {reason}.",
                ["Muted Time"] = "{player} was muted by {initiator} for {time}: {reason}.",
                ["Unmuted"] = "{player} was unmuted by {initiator}.",
                ["Not Muted"] = "{player} is currently not muted.",
                ["Mute Expired"] = "{player} is no longer muted.",
                ["Invalid Time Format"] = "Invalid time format. Example: 1d2h3m4s = 1 day, 2 hours, 3 min, 4 sec",
                ["Nobody Muted"] = "There is nobody muted at the moment.",
                ["Invalid Syntax Mute"] = "/mute <player|steamid> \"[reason]\" [time: 1d1h1m1s]",
                ["Invalid Syntax Unmute"] = "/unmute <player|steamid>",
                ["Player Name Not Found"] = "Could not find player with name '{name}'",
                ["Player ID Not Found"] = "Could not find player with ID '{id}'",
                ["Multiple Players Found"] = "Multiple matching players found: \n{matches}",
                ["Time Muted Player Joined"] = "{player} is temporarily muted. Remaining time: {time}",
                ["Time Muted Player Chat"] = "You may not chat, you are temporarily muted. Remaining time: {time}",
                ["Muted Player Joined"] = "{player} is permanently muted.",
                ["Muted Player Chat"] = "You may not chat, you are permanently muted.",
                ["Global Mute Enabled"] = "Global mute was enabled. Nobody can chat while global mute is active.",
                ["Global Mute Disabled"] = "Global mute was disabled. Everybody can chat again.",
                ["Global Mute Active"] = "Global mute is active, you may not chat."
            }, this);

            timer.Repeat(10, 0, () =>
            {
                List<string> expired = _mutes.Where(m => m.Value.Expired).Select(m => m.Key).ToList();

                foreach (string id in expired)
                {
                    var player = players.FindPlayerById(id);

                    _mutes.Remove(id);
                    PublicMessage("Mute Expired", new KeyValuePair<string, string>("player", SanitizeName(player?.Name)));

                    Interface.CallHook("OnBetterChatMuteExpired", player);

                    if (!_isDataDirty)
                        _isDataDirty = true;
                }

                if (_isDataDirty)
                {
                    SaveData(_mutes);
                    _isDataDirty = false;
                }
            });
        }

#if RUST
        private object OnPlayerChat(BasePlayer bplayer, string message, ConVar.Chat.ChatChannel chatChannel)
        {
            IPlayer player = bplayer.IPlayer;
            bool isPublicMessage = chatChannel == ConVar.Chat.ChatChannel.Global;
#else
        private object OnUserChat(IPlayer player, string message)
        {
            bool isPublicMessage = true;
#endif
            if (plugins.Exists("BetterChat"))
                return null;

            return HandleChat(player, isPublicMessage);
        }

        private void OnBetterChat(Dictionary<string, object> messageData)
        {
#if RUST
            var chatChannel = (ConVar.Chat.ChatChannel)messageData["ChatChannel"];
            bool isPublicMessage = chatChannel == ConVar.Chat.ChatChannel.Global;
#else
            bool isPublicMessage = true;
#endif

            if (HandleChat((IPlayer)messageData["Player"], isPublicMessage) != null)
            {
                messageData["CancelOption"] = 2;
            }
        }

        private void OnUserInit(IPlayer player)
        {
            UpdateMuteStatus(player);

            if (MuteInfo.IsMuted(player))
            {
                if (_mutes[player.Id].Timed)
                    PublicMessage("Time Muted Player Joined",
                        new KeyValuePair<string, string>("player", SanitizeName(player.Name)), 
                        new KeyValuePair<string, string>("time", FormatTime(_mutes[player.Id].ExpireDate - DateTime.UtcNow)));
                else
                    PublicMessage("Muted Player Joined", new KeyValuePair<string, string>("player", SanitizeName(player.Name)));
            }
        }

        #endregion

        #region Commands

        [Command("toggleglobalmute", "bcm.toggleglobalmute"), Permission("betterchatmute.use.global")]
        private void CmdGlobalMute(IPlayer player, string cmd, string[] args)
        {
            _globalMute = !_globalMute;
            PublicMessage(_globalMute ? "Global Mute Enabled" : "Global Mute Disabled");
        }

        [Command("mutelist", "bcm.mutelist"), Permission("betterchatmute.use")]
        private void CmdMuteList(IPlayer player, string cmd, string[] args)
        {
            if (_mutes.Count == 0)
                player.Reply(lang.GetMessage("Nobody Muted", this, player.Id));
            else
            {
                player.Reply(string.Join(Environment.NewLine,
                    _mutes.Select(kvp =>
                        $"{SanitizeName(players.FindPlayerById(kvp.Key).Name)}: {FormatTime(kvp.Value.ExpireDate - DateTime.UtcNow)}"
                    ).ToArray()
                ));
            }
        }

        [Command("mute", "bcm.mute"), Permission("betterchatmute.use")]
        private void CmdMute(IPlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                player.Reply(lang.GetMessage("Invalid Syntax Mute", this, player.Id));
                return;
            }

            string reason = string.Empty;
            TimeSpan? timeSpan = null;

            var target = GetPlayer(args[0], player);

            if (target == null)
                return;
            
            for (var i = 1; i < args.Length; i++)
            {
                if (TryParseTimeSpan(args[i], out timeSpan))
                {
                    args[i] = null;
                    break;
                }
            }
            
            // No time given; make sure user has permanent muting permission
            if (timeSpan == null && !permission.UserHasPermission(player.Id, "betterchatmute.permanent") && player.Id != "server_console")
            {
                player.Reply(lang.GetMessage("No Permission", this, player.Id));
                return;
            }

            reason = string.Join(" ", args.Skip(1).Where(a => a != null).ToArray());
            reason = string.IsNullOrEmpty(reason) ? lang.GetMessage("No Reason", this) : reason;

            var expireDate = timeSpan == null ? MuteInfo.NonTimedExpireDate : DateTime.UtcNow + (TimeSpan) timeSpan;

            _mutes[target.Id] = new MuteInfo(expireDate, reason);
            SaveData(_mutes);

            if (timeSpan == null)
            {
                Interface.CallHook("OnBetterChatMuted", target, player, reason);

                PublicMessage("Muted",
                    new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                    new KeyValuePair<string, string>("player", SanitizeName(target.Name)),
                    new KeyValuePair<string, string>("reason", reason));
            }
            else
            {
                Interface.CallHook("OnBetterChatTimeMuted", target, player, (TimeSpan) timeSpan, reason);

                PublicMessage("Muted Time",
                    new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                    new KeyValuePair<string, string>("player", SanitizeName(target.Name)),
                    new KeyValuePair<string, string>("time", FormatTime((TimeSpan) timeSpan)),
                    new KeyValuePair<string, string>("reason", reason));
            }
        }

        [Command("unmute", "bcm.unmute"), Permission("betterchatmute.use")]
        private void CmdUnmute(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1)
            {
                player.Reply(lang.GetMessage("Invalid Syntax Unmute", this, player.Id));
                return;
            }

            IPlayer target = GetPlayer(args[0], player);

            if (target == null)
                return;

            if (!MuteInfo.IsMuted(target))
            {
                player.Reply(lang.GetMessage("Not Muted", this, player.Id).Replace("{player}", SanitizeName(target.Name)));
                return;
            }

            _mutes.Remove(target.Id);
            SaveData(_mutes);

            Interface.CallHook("OnBetterChatUnmuted", target, player);

            PublicMessage("Unmuted",
                new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                new KeyValuePair<string, string>("player", SanitizeName(target.Name)));
        }

        #endregion

        #region API Methods

        private void API_Mute(IPlayer target, IPlayer player, string reason = "", bool callHook = true, bool broadcast = true)
        {
            _mutes[target.Id] = new MuteInfo(MuteInfo.NonTimedExpireDate, reason);
            SaveData(_mutes);

            reason = string.IsNullOrEmpty(reason) ? lang.GetMessage("No Reason", this) : reason;

            if (callHook)
                Interface.CallHook("OnBetterChatMuted", target, player, reason);

            if (broadcast)
            {
                PublicMessage("Muted",
                    new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                    new KeyValuePair<string, string>("player", SanitizeName(target.Name)),
                    new KeyValuePair<string, string>("reason", reason));
            }
        }

        private void API_TimeMute(IPlayer target, IPlayer player, TimeSpan timeSpan, string reason = "", bool callHook = true, bool broadcast = true)
        {
            _mutes[target.Id] = new MuteInfo(DateTime.UtcNow + timeSpan, reason);
            SaveData(_mutes);

            reason = string.IsNullOrEmpty(reason) ? lang.GetMessage("No Reason", this) : reason;

            if (callHook)
                Interface.CallHook("OnBetterChatTimeMuted", target, player, timeSpan,
                    string.IsNullOrEmpty(reason) ? lang.GetMessage("No Reason", this) : reason);

            if (broadcast)
            {
                PublicMessage("Muted Time",
                    new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                    new KeyValuePair<string, string>("player", SanitizeName(target.Name)),
                    new KeyValuePair<string, string>("time", FormatTime(timeSpan)),
                    new KeyValuePair<string, string>("reason", reason));
            }
        }

        private bool API_Unmute(IPlayer target, IPlayer player, bool callHook = true, bool broadcast = true)
        {
            if (!MuteInfo.IsMuted(target))
                return false;

            _mutes.Remove(target.Id);
            SaveData(_mutes);

            if (callHook)
                Interface.CallHook("OnBetterChatUnmuted", target, player);

            if (broadcast)
            {
                PublicMessage("Unmuted",
                    new KeyValuePair<string, string>("initiator", SanitizeName(player.Name)),
                    new KeyValuePair<string, string>("player", SanitizeName(target.Name)));
            }

            return true;
        }

        private void API_SetGlobalMuteState(bool state, bool broadcast = true)
        {
            _globalMute = state;

            if (broadcast)
                PublicMessage(_globalMute ? "Global Mute Enabled" : "Global Mute Disabled");
        }

        private bool API_GetGlobalMuteState() => _globalMute;

        private bool API_IsMuted(IPlayer player) => _mutes.ContainsKey(player.Id);

        private List<string> API_GetMuteList() => _mutes.Keys.ToList();

        #endregion

        #region Helpers

        private string SanitizeName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return name;

            return name.Replace("<", "‹").Replace(">", "›");
        }

        private void PublicMessage(string key, params KeyValuePair<string, string>[] replacements)
        {
            var message = lang.GetMessage(key, this);

            foreach (var replacement in replacements)
                message = message.Replace($"{{{replacement.Key}}}", replacement.Value);

            server.Broadcast(message);
            Puts(message);
        }

        private object HandleChat(IPlayer player, bool isPublicChat)
        {
            if (!isPublicChat)
                return null;

            UpdateMuteStatus(player);

            var result = Interface.CallHook("OnBetterChatMuteHandle", player, MuteInfo.IsMuted(player) ? JObject.FromObject(_mutes[player.Id]) : null);

            if (result != null)
                return result;

            if (MuteInfo.IsMuted(player))
            {
                if (_mutes[player.Id].Timed)
                {
                    player.Reply(lang.GetMessage("Time Muted Player Chat", this, player.Id)
                        .Replace("{time}", FormatTime(_mutes[player.Id].ExpireDate - DateTime.UtcNow))
                    );
                }
                else
                {
                    player.Reply(lang.GetMessage("Muted Player Chat", this, player.Id));
                }

                return true;
            }

            if (_globalMute && !permission.UserHasPermission(player.Id, "betterchatmute.use.global"))
            {
                player.Reply(lang.GetMessage("Global Mute Active", this, player.Id));

                return true;
            }

            return null;
        }

        private void UpdateMuteStatus(IPlayer player)
        {
            if (MuteInfo.IsMuted(player) && _mutes[player.Id].Expired)
            {
                _mutes.Remove(player.Id);
                SaveData(_mutes);

                PublicMessage("Mute Expired", new KeyValuePair<string, string>("player", SanitizeName(players.FindPlayerById(player.Id)?.Name)));

                Interface.CallHook("OnBetterChatMuteExpired", player);
            }
        }

        private IPlayer GetPlayer(string nameOrId, IPlayer requestor)
        {
            if (nameOrId.IsSteamId())
            {
                IPlayer player = players.All.ToList().Find(p => p.Id == nameOrId);

                if (player == null)
                    requestor.Reply(lang.GetMessage("Player ID Not Found", this, requestor.Id).Replace("{id}", nameOrId));

                return player;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (var player in players.Connected)
            {
                if (string.Equals(player.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase))
                    return player;

                if (player.Name.ToLower().Contains(nameOrId.ToLower()))
                    foundPlayers.Add(player);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    requestor.Reply(lang.GetMessage("Player Name Not Found", this, requestor.Id).Replace("{name}", nameOrId));
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    var names = (from current in foundPlayers select SanitizeName(current.Name)).ToArray();
                    requestor.Reply(lang.GetMessage("Multiple Players Found", this, requestor.Id).Replace("{matches}", string.Join(", ", names)));
                    break;
            }

            return null;
        }

        #region DateTime Helper

        private static string FormatTime(TimeSpan time)
        {
            var values = new List<string>();

            if (time.Days != 0)
                values.Add($"{time.Days} day(s)");

            if (time.Hours != 0)
                values.Add($"{time.Hours} hour(s)");

            if (time.Minutes != 0)
                values.Add($"{time.Minutes} minute(s)");

            if (time.Seconds != 0)
                values.Add($"{time.Seconds} second(s)");

            return values.ToSentence();
        }

        private static bool TryParseTimeSpan(string source, out TimeSpan? timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || !(s.Success || m.Success || h.Success || d.Success))
            {
                timeSpan = null;
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);
            return true;
        }

        #endregion

        #region Data & Config Helper

        private string DataFileName => Title.Replace(" ", "");

        private void LoadData<T>(out T data, string filename = null) => data = Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? DataFileName);

        private void SaveData<T>(T data, string filename = null) => Interface.Oxide.DataFileSystem.WriteObject(filename ?? DataFileName, data);

        #endregion

        #endregion
        
        #region Classes

        public class MuteInfo
        {
            public DateTime ExpireDate = DateTime.MinValue;

            [JsonIgnore]
            public bool Timed => ExpireDate != DateTime.MinValue;

            [JsonIgnore]
            public bool Expired => Timed && ExpireDate < DateTime.UtcNow;

            public string Reason { get; set; }

            public static bool IsMuted(IPlayer player) => _mutes.ContainsKey(player.Id);

            public static readonly DateTime NonTimedExpireDate = DateTime.MinValue;

            public MuteInfo()
            {
            }

            public MuteInfo(DateTime expireDate, string reason)
            {
                ExpireDate = expireDate;
                Reason = reason;
            }
        }

        #endregion
    }
}

// --- End of file: BetterChatMute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bearrels ---
// --- Original File Path: B/Bearrels/Bearrels.cs ---

using System;
using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Bearrels", "redBDGR", "2.0.0")]
    [Description("Random chance of bears spawning when a barrel breaks")]

    class Bearrels : RustPlugin
    {

        #region Variables

        private bool Changed;

        #endregion

        #region Configuration

        private class ConfigFile
        {
            public static float chanceOfBear = 0.1f;
        }

        private void LoadVariables()
        {
            ConfigFile.chanceOfBear = Convert.ToSingle(GetConfig("Settings", "Chance of bear", 0.1f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #endregion

        #region Hooks

        void Init()
        {
            LoadVariables();

            lang.RegisterMessages(new Dictionary<string, string>
            {
                /* chat */
                ["Bearrel"] = "That wasn't just a barrel- it was a Bearrel!",
            }, this);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!entity.name.Contains("barrel"))
                return;
            if (UnityEngine.Random.Range(0f, 1f) <= ConfigFile.chanceOfBear)
            {
                SpawnBear(entity.transform.position);
                BasePlayer player = info.InitiatorPlayer;
                if (player != null)
                    PrintToChat(player, msg("Bearrel", player.UserIDString));
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        #endregion

        #region Methods

        private void SpawnBear(Vector3 pos)
        {
            BaseEntity bear = GameManager.server.CreateEntity("assets/rust.ai/agents/bear/bear.prefab", pos, new Quaternion(), true);
            bear.Spawn();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion

    }
}

// --- End of file: Bearrels.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bradley-protection ---
// --- Original File Path: B/BradleyProtection/BradleyProtection.cs ---

﻿using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Bradley Protection", "Nobu", "1.0.2")]
    [Description("Protects you from the tank and vice versa")]

    class BradleyProtection : RustPlugin
    {
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Use permissions to enable")]
            public bool perms = false;
            [JsonProperty(PropertyName = "Time on server before bradley targets them")]
            public double contime = 600;
            [JsonProperty(PropertyName = "Protect players from bradley")]
            public bool protectplayer = true;
            [JsonProperty(PropertyName = "Protect bradley from players")]
            public bool protecttank = true;
        }
        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config Issue Detected, delete file or check syntax");
                return;
            }
            permission.RegisterPermission("BradleyProtection.protect", this);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file");
            configData = new ConfigData();
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        bool? CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
        { 
            BasePlayer player = entity as BasePlayer;
            if(permission.UserHasPermission(player.UserIDString, "BradleyProtection.protect") && configData.perms == true)
            { 
              if (configData.protectplayer == true)
              {
                   if (player.Connection.GetSecondsConnected() <= configData.contime)
                   {
                        return false;
                   }
                   else
                   {
                      return null;
                   }
              }
              else
              {
                  return null;
              }
            }
            else
            {
                if (configData.protectplayer == true)
                {
                    if (player.Connection.GetSecondsConnected() <= configData.contime)
                    {
                        return false;
                    }
                    else
                    {
                        return null;
                    }
                }
                else
                {
                    return null;
                }
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            BasePlayer player = entity as BasePlayer;
            if (permission.UserHasPermission(player.UserIDString, "BradleyProtection.protect") && configData.perms == true)
            {
                if (configData.protecttank == true)
                {
                   if (info.Initiator is BasePlayer)
                   {
                       if (player.Connection.GetSecondsConnected() <= configData.contime && player != null)
                       {
                            return null;
                       }
                       else
                       {
                           return null;
                       }
                   }
                   else
                   {
                       return false;
                   }
                }
                else
                {
                   return null;
                }
            }
            else
            {
                if (configData.protecttank == true)
                {
                    if (info.Initiator is BasePlayer)
                    {
                        if (player.Connection.GetSecondsConnected() <= configData.contime && player != null)
                        {
                            return null;
                        }
                        else
                        {
                            return null;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    return null;
                }
            }
        }
    }
}

// --- End of file: BradleyProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/build-revert ---
// --- Original File Path: B/BuildRevert/BuildRevert.cs ---

﻿using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BuildRevert", "nivex", "1.2.2")]
    [Description("Prevent building in blocked area.")]
    public class BuildRevert : RustPlugin
    {
        [PluginReference] Plugin RaidableBases, AbandonedBases, ZoneManager;

        private List<ZoneInfo> excludedZones { get; set; } = new();
        private List<Construction> blocked = new();

        public class ZoneInfo
        {
            internal Vector3 origin;
            internal Vector3 extents;
            internal float distance;

            public ZoneInfo(object origin, object radius, object size)
            {
                this.origin = (Vector3)origin;

                if (radius is float r)
                {
                    distance = r;
                }

                if (size is Vector3 v && v != Vector3.zero)
                {
                    extents = v * 0.5f;
                }
            }

            public bool IsPositionInZone(Vector3 point)
            {
                if (extents != Vector3.zero)
                {
                    var v = Quaternion.Inverse(Quaternion.identity) * (point - origin);

                    return v.x <= extents.x && v.x > -extents.x && v.y <= extents.y && v.y > -extents.y && v.z <= extents.z && v.z > -extents.z;
                }
                return InRange2D(origin, point, distance);
            }

            private bool InRange2D(Vector3 a, Vector3 b, float distance)
            {
                return (new Vector3(a.x, 0f, a.z) - new Vector3(b.x, 0f, b.z)).sqrMagnitude <= distance * distance;
            }
        }

        private void Init()
        {
            permission.RegisterPermission("buildrevert.bypass", this);
            Unsubscribe(nameof(CanBuild));
        }

        private void OnServerInitialized(bool isStartup)
        {
            LoadVariables();
            SetupExcludedZones(true);
            Subscribe(nameof(CanBuild));
        }

        private object CanBuild(Planner planner, Construction construction, Construction.Target target)
        {
            if (!blocked.Contains(construction) || permission.UserHasPermission(target.player.UserIDString, "buildrevert.bypass"))
            {
                return null;
            }

            var buildPos = target.entity && target.entity.transform && target.socket ? target.GetWorldPosition() : target.position;

            if (!IsExcluded(buildPos) && target.player.IsBuildingBlocked(new OBB(buildPos, Quaternion.identity, target.player.bounds), cached: true) && !EventTerritory(buildPos))
            {
                if (useToasts) target.player.ShowToast(toastStyle, GetLang("Building is blocked: Toast", target.player.UserIDString));
                else Player.Message(target.player, GetLang("Building is blocked!", target.player.UserIDString));
                return false;
            }

            return null;
        }

        private bool EventTerritory(Vector3 buildPos)
        {
            return RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", buildPos)) || AbandonedBases != null && Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", buildPos));
        }

        private void SetupExcludedZones(bool message)
        {
            if (ZoneManager == null || !ZoneManager.IsLoaded)
            {
                return;
            }

            timer.Once(60f, () => SetupExcludedZones(false));

            var zoneIds = ZoneManager?.Call("GetZoneIDs") as string[];

            if (zoneIds == null)
            {
                return;
            }

            excludedZones.Clear();

            foreach (string zoneId in zoneIds)
            {
                var zoneLoc = ZoneManager.Call("GetZoneLocation", zoneId);

                if (!(zoneLoc is Vector3))
                {
                    continue;
                }

                var zoneName = Convert.ToString(ZoneManager.Call("GetZoneName", zoneId));

                if (!allowedZones.Exists(zone => !string.IsNullOrEmpty(zone) && zone == zoneId || !string.IsNullOrEmpty(zoneName) && zoneName.Equals(zone, StringComparison.OrdinalIgnoreCase)))
                {
                    continue;
                }

                var radius = ZoneManager.Call("GetZoneRadius", zoneId);
                var size = ZoneManager.Call("GetZoneSize", zoneId);

                excludedZones.Add(new ZoneInfo(zoneLoc, radius, size));
            }

            if (message && excludedZones.Count > 0)
            {
                Puts("{0} zones have been excluded", excludedZones.Count);
            }
        }

        private bool IsExcluded(Vector3 position)
        {
            foreach (var zone in excludedZones)
            {
                if (zone.IsPositionInZone(position))
                {
                    return true;
                }
            }
            return false;
        }

        #region Config
        private bool Changed;
        private List<string> allowedZones = new();

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Building is blocked!"] = "<color=#FF0000>Building is blocked!</color>",
                ["Building is blocked: Toast"] = "You don't have permission to build here"
            }, this);
        }

        private bool useToasts;
        private GameTip.Styles toastStyle;
        
        private void LoadVariables()
        {
            useToasts = Convert.ToBoolean(GetConfig("Messages", "Use Toasts", true));
            toastStyle = (GameTip.Styles)GetConfig("Messages", "Toast Style (0 = blue normal, 1 = red normal, 2 = blue long, 3 = blue short, 4 = server event, 5 = error)", GameTip.Styles.Error);

            //PrefabAttribute.server.Find<Construction>(2150203378).canBypassBuildingPermission = false;
            Dictionary<string, uint> pooledStrings = new();
            foreach (var p in GameManifest.Current.pooledStrings)
            {
                pooledStrings[p.str.ToLower()] = p.hash;
            }

            Dictionary<Construction, bool> constructions = new();

            foreach (string str in GameManifest.Current.entities)
            {
                if (!pooledStrings.ContainsKey(str.ToLower())) continue;

                var construction = PrefabAttribute.server.Find<Construction>(pooledStrings[str.ToLower()]);
                
                if (construction != null)
                {
                    string value = string.Format("Allow {0}", construction.hierachyName.Replace("PrefabPreProcess - Server/", string.Empty));
                    constructions[construction] = Convert.ToBoolean(GetConfig("Constructions", value, true));
                    if (!constructions[construction]) blocked.Add(construction);
                }
            }

            foreach (var zone in GetConfig("Zone Manager", "Excluded Zones", new List<object> { "pvp", "99999999" }) as List<object>)
            {
                allowedZones.Add(zone.ToString());
            }

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private string GetLang(string key, string id = null) => lang.GetMessage(key, this, id);
        #endregion
    }
}

// --- End of file: BuildRevert.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/bullet-impact ---
// --- Original File Path: B/BulletImpact/BulletImpact.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Bullet Impact", "birthdates", "1.0.3")]
    [Description("Give a more realistic impact of a bullet on death")]
    public class BulletImpact : RustPlugin
    {

        private readonly IDictionary<ulong, HitData> _directions = new Dictionary<ulong, HitData>(); 
     
        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (info == null || !info.IsProjectile()) return;
            var direction = (info.PointEnd - info.PointStart).normalized;
            _directions[player.userID] = new HitData {Direction = direction, Point = info.HitPositionWorld};
        }

        private struct HitData
        {
            public Vector3 Direction { get; set; }
            public Vector3 Point { get; set; }
        }
        
        private void OnPlayerCorpseSpawned(BasePlayer player, BaseCorpse corpse)
        {
            HitData hitData;
            if (!_directions.TryGetValue(player.userID, out hitData)) return;
            var rigidBody = corpse.GetComponent<Rigidbody>();
            if (rigidBody == null) return;
            rigidBody.velocity = default(Vector3);
            rigidBody.angularVelocity = default(Vector3);
            rigidBody.AddForceAtPosition(hitData.Direction*2.5f, hitData.Point, ForceMode.VelocityChange);
        }
        
    }
}

// --- End of file: BulletImpact.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/building-info ---
// --- Original File Path: B/BuildingInfo/BuildingInfo.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Info", "misticos", "1.0.7")]
    [Description("Scan buildings and get their owners")]
    class BuildingInfo : RustPlugin
    {
        #region Variables

        private const string PermScan = "buildinginfo.scan";
        private const string PermOwner = "buildinginfo.owner";
        private const string PermAuthed = "buildinginfo.authed";
        private const string PermBypass = "buildinginfo.bypass";
        
        #endregion
        
        #region Configuration
        
        private Configuration _config = new Configuration();

        public class Configuration
        {
            [JsonProperty(PropertyName = "Command Scan")]
            public string CommandScan = "scan";

            [JsonProperty(PropertyName = "Command Scan Owner")]
            public string CommandOwner = "owner";

            [JsonProperty(PropertyName = "Command Scan Authorized Players")]
            public string CommandAuthed = "authed";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);
        
        #endregion
        
        #region Commands

        private void CommandChatScan(BasePlayer player, string command, string[] args)
        {
            var id = player.UserIDString;
            if (!permission.UserHasPermission(id, PermScan))
            {
                player.ChatMessage(GetMsg("No Permissions", id));
                return;
            }

            var entity = GetBuilding(player);
            if (entity == null)
            {
                player.ChatMessage(GetMsg("Cannot Find", id));
                return;
            }

            var owner = BasePlayer.FindByID(entity.OwnerID);
            if (owner != null && permission.UserHasPermission(owner.UserIDString, PermBypass))
            {
                player.ChatMessage(GetMsg("Scan Unavailable", id));
                return;
            }

            var entities = entity.GetBuildingPrivilege()?.GetBuilding()?.buildingBlocks;
            if (entities == null || entities.Count == 0)
            {
                player.ChatMessage(GetMsg("Cannot Find", id));
                return;
            }

            var dict = new Dictionary<string, ushort>();
            var entitiesCount = entities.Count;
            for (var i = 0; i < entitiesCount; i++)
            {
                var ent = entities[i];
                if (permission.UserHasPermission(ent.OwnerID.ToString(), PermBypass))
                    continue;

                var shortname = ent.ShortPrefabName + $" ({ent.currentGrade.gradeBase.type})";
                if (dict.ContainsKey(shortname))
                    // ReSharper disable once RedundantAssignment
                    dict[shortname]++;
                else
                    dict[shortname] = 1;
            }

            var ex = GetMsg("Scan Info", id);
            var builder = new StringBuilder(GetMsg("Scan Title", id));
            foreach (var el in dict)
            {
                builder.Append(ex);
                builder = builder.Replace("{name}", el.Key).Replace("{amount}", el.Value.ToString());
            }

            player.ChatMessage(builder.ToString());
        }

        private void CommandChatOwner(BasePlayer player, string command, string[] args)
        {
            var id = player.UserIDString;
            if (!permission.UserHasPermission(id, PermOwner))
            {
                player.ChatMessage(GetMsg("No Permissions", id));
                return;
            }

            var entity = GetBuilding(player);
            if (entity == null)
            {
                player.ChatMessage(GetMsg("Cannot Find", id));
                return;
            }

            var owner = covalence.Players.FindPlayerById(entity.OwnerID.ToString());
            if (owner == null)
            {
                player.ChatMessage(GetMsg("Cannot Find Owner", id));
                return;
            }

            if (permission.UserHasPermission(owner.Id, PermBypass))
            {
                player.ChatMessage(GetMsg("Owner Unavailable", id));
                return;
            }

            player.ChatMessage(GetMsg("Owner Info", id).Replace("{name}", owner.Name)
                .Replace("{id}", owner.Id));
        }

        private void CommandChatAuthed(BasePlayer player, string command, string[] args)
        {
            var id = player.UserIDString;
            if (!permission.UserHasPermission(id, PermAuthed))
            {
                player.ChatMessage(GetMsg("No Permissions", id));
                return;
            }

            var entity = GetBuilding(player);
            if (entity == null)
            {
                player.ChatMessage(GetMsg("Cannot Find", id));
                return;
            }

            var privilege = entity.GetBuildingPrivilege();
            if (privilege == null)
            {
                player.ChatMessage(GetMsg("Cannot Find Authed", id));
                return;
            }

            if (!privilege.AnyAuthed())
            {
                player.ChatMessage(GetMsg("Authed Zero", id));
                return;
            }

            var ex = GetMsg("Authed Info", id);
            var builder = new StringBuilder(GetMsg("Authed Title", id));
            var i = 0;
            foreach (var authorizedPlayer in privilege.authorizedPlayers)
            {
                builder.Append(ex);
                builder = builder
                    .Replace("{number}", $"{++i}")
                    .Replace("{name}", authorizedPlayer.username)
                    .Replace("{id}", authorizedPlayer.userid.ToString());
            }
            
            player.ChatMessage(builder.ToString());
        }

        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permissions", "You don't have enough permissions." },
                { "Scan Title", "Scan result:" },
                { "Scan Info", "\n{name} x{amount}" },
                { "Scan Unavailable", "Sorry, there was an error. You cannot scan this building." },
                { "Owner Info", "Owner: {name} ({id})" },
                { "Owner Unavailable", "Sorry, there was an error. You cannot get an owner of this building." },
                { "Authed Title", "Authed Players:" },
                { "Authed Info", "\n#{number} - {name} ({id})" },
                { "Authed Unavailable", "" },
                { "Authed Zero", "Nobody is authed here." },
                { "Cannot Find", "Excuse me, where is the building you are looking for?" },
                { "Cannot Find Owner", "Sorry, I don't know who owns this building." },
                { "Cannot Find Authed", "I don't know who is authed there." }
            }, this);
        }

        // ReSharper disable once UnusedMember.Local
        private void Init()
        {
            LoadConfig();

            permission.RegisterPermission(PermScan, this);
            permission.RegisterPermission(PermOwner, this);
            permission.RegisterPermission(PermAuthed, this);
            permission.RegisterPermission(PermBypass, this);

            cmd.AddChatCommand(_config.CommandScan, this, CommandChatScan);
            cmd.AddChatCommand(_config.CommandOwner, this, CommandChatOwner);
            cmd.AddChatCommand(_config.CommandAuthed, this, CommandChatAuthed);
        }

        #endregion
        
        #region Helpers

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        private BaseEntity GetBuilding(BasePlayer player)
        {
            RaycastHit info;
            Physics.Raycast(player.eyes.HeadRay(), out info, LayerMask.GetMask("Construction"));
            return info.GetEntity();
        }

        #endregion
    }
}

// --- End of file: BuildingInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/barrelless ---
// --- Original File Path: B/Barrelless/Barrelless.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;
using Rust;
using Rust.Ai;
using HarmonyLib;

#region Changelogs and ToDo

/**********************************************************************
* 
*   1.0.0   -   initial release
*   2.0.0   -   Rewrite V2
*   2.1.0   -   Patched for compile after Rust Update removing various AI
*   3.0.0   -   Rewrite V3
*           -   Added Scarecrow Attack Behaviour to be less stuck on targets
*           -   Added scientist and scarecrows Roaming Behaviour
*           -   Added support for kits for scientist and scarecrows
*           -   Added spawn amount for for scientist and scarecrows
*           -   Added scientist and scarecrows to get their prefix(title) + random name assigned
*           -   Added Seperate prefix for scarecrow with a chainsaw
*           -   Airdrops skips spawn if the barrel is not outside
*               and will gives the player a supply.signal or drops it on the floor
*               if player inventory is full
*           -   Added amount of animals spawning per animal type
*           -   Added Health settings per animal type
*           -   If more then 1 npc or animal are set to spawn they will give a different chat message
*           -   Added F1Grenade to the explosives spawn list
*   3.0.1   -   Added support for PolarBears
*   3.0.2   -   Added Global setting to only spawn outside
*               Added animal life duration
*               Added permission system
*   3.0.3   -   Added Max range to trigger events to the config
*   3.0.4   -   Fix for overload issue
*   3.1.0   -   Removed barrelless.globaltrigger permission
*               Added permission barrelless.exclude(excludes player from event triggers)
*               Added permission barrelless.fires
*               Code Cleanup for permissions system
*               Changed BaseCombatEntity to LootContainer
*               Fix for scientists getting a kit from NPCKits plugin
*               Added event triggers per barreltype (normal,oil,diesel)
*               Improved heightChecks
*               Events can now spawn inside buildings
*               Events can now spawn Ontop structures and powerlines
*               oilrigs and waterjunkpiles could have weird placements
*               Events can now spawn inside sewers and tunnels
*               Events can now spawn inside the subway and underwaterlabs
*               Added FX in cfg that executes each time a barrel triggers a event (remove and it will not be used)
*               Added small fires
*               Added Oil fires
*               Added Fire duration (max 20 seconds)
*               Added Fire and satchelcharge messages to the language file
*               Added satchelcharge on request
*   3.1.1       Patched for Rust Changes
*   3.1.2       Added HackCrates to the cfg and lang file
*               Some minor fixes
*            
*   Todo    -   Add Mono for animals (roam and other stuff)
*           -   Add day/night spawnrates
*           -   Add damagetypes (ea radiation/poison on triggers)
*           -   Add gametips using RandomTips/RandomTipsPlus plugins
*           -   Add API
* 
**********************************************************************/

#endregion

namespace Oxide.Plugins
{
    [Info("Barrelless", "Krungh Crow", "3.1.2")]
    [Description("various events after barrel kills")]
    class Barrelless : RustPlugin
    {
        [PluginReference] Plugin Kits;

        #region Variables

        #region Plugin
        bool BlockSpawn;
        bool BlockOutside;
        bool IsSpawned;
        bool fireallreadyspawned = false;

        bool Signaldropped;
        ulong chaticon;
        string prefix;
        System.Random rnd = new System.Random();
        private ConfigData configData;
        public static Barrelless instance;

        #endregion

        #region Permissions

        const string Exclude_Perm = "barrelless.exclude";
        const string SciTrigger_Perm = "barrelless.scientist";
        const string ScareTrigger_Perm = "barrelless.scarecrow";
        const string BearTrigger_Perm = "barrelless.bear";
        const string PBearTrigger_Perm = "barrelless.polarbear";
        const string BoarTrigger_Perm = "barrelless.boar";
        const string ChickenTrigger_Perm = "barrelless.chicken";
        const string WolfTrigger_Perm = "barrelless.wolf";
        const string ExploTrigger_Perm = "barrelless.explosive";
        const string FireTrigger_Perm = "barrelless.fires";
        const string AirdropTrigger_Perm = "barrelless.airdrop";
        const string HackCrateTrigger_Perm = "barrelless.hackcrate";

        #endregion

        #region NPC
        const string zombie = "assets/prefabs/npc/scarecrow/scarecrow.prefab";
        const string _scientist = "assets/rust.ai/agents/npcplayer/humannpc/scientist/scientistnpc_roam.prefab";
        float SciDamageScale;
        int SciHealth;
        List<string> SciKit;
        float SciLifetime;
        string SciName;

        bool _UseKit;
        bool _FromHell;
        #endregion

        #region Animals
        const string bearString = "assets/rust.ai/agents/bear/bear.prefab";
        const string PBearString = "assets/rust.ai/agents/bear/polarbear.prefab";
        const string boarstring = "assets/rust.ai/agents/boar/boar.prefab";
        const string chickenString = "assets/rust.ai/agents/chicken/chicken.prefab";
        const string wolfString = "assets/rust.ai/agents/wolf/wolf.prefab";
        int _AnimalHealth;
        string _AnimalString;
        float _AnimalLife;
        #endregion

        #region Fires
        const string oilfire = "assets/bundled/prefabs/oilfireballsmall.prefab";//oil and diesel barrels
        const string fireball = "assets/bundled/prefabs/fireball.prefab";//OnFire
        #endregion

        #region Drops
        const string airdropString = "assets/prefabs/misc/supply drop/supply_drop.prefab";
        const string hackcrateString = "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab";
        const string beancanString = "assets/prefabs/weapons/beancan grenade/grenade.beancan.deployed.prefab";
        const string grenadeString = "assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab";
        const string satchelString = "assets/prefabs/weapons/satchelcharge/explosive.satchel.deployed.prefab";
        #endregion

        #region Data
        const string file_main = "barrelless_players/";
        #endregion

        #endregion

        #region Behaviours

        #region Scarecrow
        private class Zombies : FacepunchBehaviour
        {
            private ScarecrowNPC npc;
            public bool ReturningToHome = false;
            public bool isRoaming = true;
            public Vector3 SpawnPoint;

            private void Awake()
            {
                npc = GetComponent<ScarecrowNPC>();
                Invoke(nameof(_UseBrain), 0.1f);
                InvokeRepeating(Attack, 0.1f, 1.5f);
                InvokeRepeating(GoHome, 2.0f, 4.5f);
            }

            private void Attack()
            {
                BaseEntity entity = npc.Brain.Senses.GetNearestThreat(40);
                Chainsaw heldEntity = npc.GetHeldEntity() as Chainsaw;
                if (entity == null || Vector3.Distance(entity.transform.position, npc.transform.position) > 40.0f)
                {
                    npc.Brain.Navigator.ClearFacingDirectionOverride();
                    GoHome();
                }
                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) < 2.0f)
                {
                    npc.StartAttacking(entity);
                    npc.Brain.Navigator.SetFacingDirectionEntity(entity);
                    if (heldEntity is Chainsaw)
                    {
                        if (!(heldEntity as Chainsaw).EngineOn())
                        {
                            (heldEntity as Chainsaw).ServerNPCStart();
                        }
                        heldEntity.SetFlag(BaseEntity.Flags.Busy, true, false, true);
                        heldEntity.SetFlag(BaseEntity.Flags.Reserved8, true, false, true);
                    }
                }

                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) > 1.5f)
                {
                    if (heldEntity is Chainsaw)
                    {
                        if (!(heldEntity as Chainsaw).EngineOn())
                        {
                            (heldEntity as Chainsaw).ServerNPCStart();
                        }
                        heldEntity.SetFlag(BaseEntity.Flags.Busy, false, false, true);
                        heldEntity.SetFlag(BaseEntity.Flags.Reserved8, false, false, true);
                    }
                }

                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) > 2.0f)
                {
                    npc.Brain.Navigator.SetFacingDirectionEntity(entity);
                }
            }

            public void _UseBrain()
            {
                #region navigation
                npc.Brain.Navigator.Agent.agentTypeID = -1372625422;
                npc.Brain.Navigator.DefaultArea = "Walkable";
                npc.Brain.Navigator.Agent.autoRepath = true;
                npc.Brain.Navigator.enabled = true;
                npc.Brain.Navigator.CanUseNavMesh = true;
                npc.Brain.Navigator.BestRoamPointMaxDistance = instance.configData.CrowData.NPCRoamMax;
                npc.Brain.Navigator.MaxRoamDistanceFromHome = instance.configData.CrowData.NPCRoamMax;
                npc.Brain.Navigator.Init(npc, npc.Brain.Navigator.Agent);
                npc.Brain.Navigator.SetDestination(SpawnPoint, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
                #endregion

                #region senses & Targeting
                npc.Brain.ForceSetAge(0);
                npc.Brain.AllowedToSleep = false;
                npc.Brain.sleeping = false;
                npc.Brain.SenseRange = 30f;
                npc.Brain.ListenRange = 40f;
                npc.Brain.Senses.Init(npc,npc.Brain, 5f, 30, 40f, 135f, true, true, true, 60f, false, false, true, EntityType.Player, true);
                npc.Brain.TargetLostRange = 20f;
                npc.Brain.HostileTargetsOnly = false;
                npc.Brain.IgnoreSafeZonePlayers = true;
                #endregion
            }

            void GoHome()
            {
                if (npc == null || npc.IsDestroyed || npc.isMounted)
                    return;

                if (!npc.HasBrain)
                    return;
                if (npc.Brain.Senses.Memory.Targets.Count > 0)
                {
                    for (var i = 0; i < npc.Brain.Senses.Memory.Targets.Count; i++)
                    {
                        BaseEntity target = npc.Brain.Senses.Memory.Targets[i];
                        BasePlayer player = target as BasePlayer;

                        if (target == null || !player.IsAlive() || player.IsSleeping() || player.IsFlying)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                        if (npc.Distance(player.transform.position) > 25f)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                        if (player.IsSleeping() || player.IsFlying)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }

                    }
                }

                var distanceHome = Vector3.Distance(npc.transform.position, SpawnPoint);
                if (ReturningToHome == false)
                {
                    if (isRoaming == true && distanceHome > instance.configData.CrowData.NPCRoamMax)
                    {
                        ReturningToHome = true;
                        isRoaming = false;
                        return;
                    }
                    if (isRoaming == true && distanceHome < instance.configData.CrowData.NPCRoamMax)
                    {
                        Vector3 random = UnityEngine.Random.insideUnitCircle.normalized * instance.configData.CrowData.NPCRoamMax;
                        Vector3 newPos = instance.GetNavPoint(SpawnPoint + new Vector3(random.x, 0f, random.y));
                        SettargetDestination(newPos);
                        return;
                    }
                }
                if (ReturningToHome && distanceHome > 2)
                {
                    if (npc.Brain.Navigator.Destination == SpawnPoint)
                    {
                        return;
                    }

                    WipeMemory();
                    SettargetDestination(SpawnPoint);
                    return;
                }
                ReturningToHome = false;
                isRoaming = true;
            }

            private void SettargetDestination(Vector3 position)
            {
                npc.Brain.Navigator.Destination = position;
                npc.Brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
            }

            void WipeMemory()
            {
                if (!npc.HasBrain)
                {
                    return;
                }

                npc.Brain.Senses.Players.Clear();
                npc.Brain.Senses.Memory.Players.Clear();
                npc.Brain.Senses.Memory.Targets.Clear();
                npc.Brain.Senses.Memory.Threats.Clear();
                npc.Brain.Senses.Memory.LOS.Clear();
                npc.Brain.Senses.Memory.All.Clear();
            }

            void OnDestroy()
            {
                if (npc != null && !npc.IsDestroyed)
                {
                    npc.Kill();
                }
                CancelInvoke(GoHome);
                CancelInvoke(Attack);
                CancelInvoke(nameof(_UseBrain));
            }
        }
        #endregion

        #region Scientist
        public class Scientists : FacepunchBehaviour
        {
            public global::HumanNPC npc;
            public bool ReturningToHome = false;
            public bool isRoaming = true;
            public Vector3 SpawnPoint;

            void Start()
            {
                npc = GetComponent<global::HumanNPC>();

                InvokeRepeating("GoHome", 2.0f, 4.5f);
                Invoke(nameof(_UseBrain), 0.1f);
            }
            public void _UseBrain()
            {
                #region navigation
                npc.Brain.Navigator.Agent.agentTypeID = -1372625422;
                npc.Brain.Navigator.DefaultArea = "Walkable";
                npc.Brain.Navigator.Agent.autoRepath = true;
                npc.Brain.Navigator.enabled = true;
                npc.Brain.Navigator.CanUseNavMesh = true;
                npc.Brain.Navigator.BestRoamPointMaxDistance = instance.configData.SCIData.NPCRoamMax;
                npc.Brain.Navigator.MaxRoamDistanceFromHome = instance.configData.SCIData.NPCRoamMax;
                npc.Brain.Navigator.Init(npc, npc.Brain.Navigator.Agent);
                npc.Brain.Navigator.SetDestination(SpawnPoint, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
                #endregion

                #region senses & Targeting
                npc.Brain.ForceSetAge(0);
                npc.Brain.AllowedToSleep = false;
                npc.Brain.sleeping = false;
                npc.Brain.SenseRange = 30f;
                npc.Brain.ListenRange = 40f;
                npc.Brain.Senses.Init(npc,npc.Brain , 5f, 50f, 50f, -1f, true, false, true, 60f, false, false, false, EntityType.Player, false);
                npc.Brain.TargetLostRange = 25f;
                npc.Brain.HostileTargetsOnly = false;
                npc.Brain.IgnoreSafeZonePlayers = true;
                #endregion
            }

            void GoHome()
            {
                if (npc == null || npc.IsDestroyed || npc.isMounted)
                    return;

                if (!npc.HasBrain)
                    return;
                if (npc.Brain.Senses.Memory.Targets.Count > 0)
                {
                    for (var i = 0; i < npc.Brain.Senses.Memory.Targets.Count; i++)
                    {
                        BaseEntity target = npc.Brain.Senses.Memory.Targets[i];
                        BasePlayer player = target as BasePlayer;

                        if (target == null || !player.IsAlive())
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                        if (npc.Distance(player.transform.position) > 40f)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                    }
                }

                var distanceHome = Vector3.Distance(npc.transform.position, SpawnPoint);
                if (ReturningToHome == false)
                {
                    if (isRoaming == true && distanceHome > instance.configData.SCIData.NPCRoamMax)
                    {
                        ReturningToHome = true;
                        isRoaming = false;
                        return;
                    }
                    if (isRoaming == true && distanceHome < instance.configData.SCIData.NPCRoamMax)
                    {
                        Vector3 random = UnityEngine.Random.insideUnitCircle.normalized * instance.configData.SCIData.NPCRoamMax;
                        Vector3 newPos = instance.GetNavPoint(SpawnPoint + new Vector3(random.x, 0f, random.y));
                        SettargetDestination(newPos);
                        return;
                    }
                }
                if (ReturningToHome && distanceHome > 2)
                {
                    if (npc.Brain.Navigator.Destination == SpawnPoint)
                    {
                        return;
                    }

                    WipeMemory();
                    SettargetDestination(SpawnPoint);
                    return;
                }
                ReturningToHome = false;
                isRoaming = true;
            }
            private void SettargetDestination(Vector3 position)
            {
                npc.Brain.Navigator.Destination = position;
                npc.Brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
            }
            void WipeMemory()
            {
                if (!npc.HasBrain)
                {
                    return;
                }

                npc.Brain.Senses.Players.Clear();
                npc.Brain.Senses.Memory.Players.Clear();
                npc.Brain.Senses.Memory.Targets.Clear();
                npc.Brain.Senses.Memory.Threats.Clear();
                npc.Brain.Senses.Memory.LOS.Clear();
                npc.Brain.Senses.Memory.All.Clear();
            }

            void OnDestroy()
            {
                if (npc != null && !npc.IsDestroyed)
                {
                    npc.Kill();
                }
                CancelInvoke("GoHome");
                CancelInvoke(nameof(_UseBrain));

            }
        }
        #endregion

        #endregion

        #region Configuration

        class ConfigData
        {
            [JsonProperty(PropertyName = "Plugin Settings")]
            public SettingsDrop DropData = new SettingsDrop();
            [JsonProperty(PropertyName = "Airdrop Settings")]
            public SettingsAirdrop AirdropData = new SettingsAirdrop();
            [JsonProperty(PropertyName = "Hack crate Settings")]
            public SettingsHack HackData = new SettingsHack();
            [JsonProperty(PropertyName = "Scarecrow Settings")]
            public NPCSettings CrowData = new NPCSettings();
            [JsonProperty(PropertyName = "Scientist Settings")]
            public SCISettings SCIData = new SCISettings();
            [JsonProperty(PropertyName = "Animal Settings")]
            public SettingsAnimal AnimalData = new SettingsAnimal();
            [JsonProperty(PropertyName = "Explosives Settings")]
            public SettingsExplosives ExplosivesData = new SettingsExplosives();
            [JsonProperty(PropertyName = "Fire Settings")]
            public SettingsFire FireData = new SettingsFire();
        }

        #region Plugin settings
        class SettingsDrop
        {
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix = "[<color=green>Barrelles</color>] ";
            [JsonProperty(PropertyName = "Drop : Count random per x barrels")]
            public int Barrelcountdrop { get; set; } = 1;
            [JsonProperty(PropertyName = "Drop : Max range to trigger events")]
            public int RangeTrigger { get; set; } = 10;
            [JsonProperty(PropertyName = "Drop : Spawn only 1 entity on trigger")]
            public bool Trigger = false;
            [JsonProperty(PropertyName = "Only allow spawning outside")]
            public bool TriggerOut = true;
            [JsonProperty(PropertyName = "Show messages")]
            public bool ShowMsg = true;
            [JsonProperty(PropertyName = "FX on trigger")]
            public string FX = "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab";
        }
        #endregion

        #region Hackable locked crate
        class SettingsHack
        {
            [JsonProperty(PropertyName = "Spawn chance (0-100)")]
            public int HackdropRate { get; set; } = 1;
            [JsonProperty(PropertyName = "Drop height")]
            public int HackdropHeight { get; set; } = 120;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
        }
        #endregion

        #region Airdrop
        class SettingsAirdrop
        {
            [JsonProperty(PropertyName = "Spawn chance (0-100)")]
            public int AirdropRate { get; set; } = 1;
            [JsonProperty(PropertyName = "Drop height")]
            public int AirdropHeight { get; set; } = 120;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
        }
        #endregion

        #region Scarecrow
        class NPCSettings
        {
            [JsonProperty(PropertyName = "Spawn chance (0-100)")]
            public int SpawnRate  = 10;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Spawn Amount")]
            public int NPCAmount = 1;
            [JsonProperty(PropertyName = "NPC Spawns on fire")]
            public bool FromHell = false;
            [JsonProperty(PropertyName = "Max Roam Distance")]
            public int NPCRoamMax= 15;
            [JsonProperty(PropertyName = "Prefix (Title)")]
            public string NPCName = "Scarecrow";
            [JsonProperty(PropertyName = "Prefix (Title) if chainsaw equiped")]
            public string NPCName2 = "Chainsaw Murderer";
            [JsonProperty(PropertyName = "Health (HP)")]
            public int NPCHealth = 250;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float NPCLife = 5f;
            [JsonProperty(PropertyName = "Damage multiplier")]
            public float NPCDamageScale = 0.6f;
            [JsonProperty(PropertyName = "Use kit (clothing)")]
            public bool UseKit = false;
            [JsonProperty(PropertyName = "Kit ID")]
            public List<string> KitName = new List<string>();
        }
        #endregion

        #region Scientist
        class SCISettings
        {
            [JsonProperty(PropertyName = "Spawn chance (0-100)")]
            public int SpawnRate = 10;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Spawn Amount")]
            public int NPCAmount = 1;
            [JsonProperty(PropertyName = "NPC Spawns on fire")]
            public bool FromHell = false;
            [JsonProperty(PropertyName = "Max Roam Distance")]
            public int NPCRoamMax = 15;
            [JsonProperty(PropertyName = "Prefix (Title)")]
            public string NPCName = "BarrelScientist";
            [JsonProperty(PropertyName = "Health (HP)")]
            public int NPCHealth = 250;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float NPCLife = 5f;
            [JsonProperty(PropertyName = "Damage multiplier")]
            public float NPCDamageScale = 0.6f;
            [JsonProperty(PropertyName = "Use kit (clothing)")]
            public bool UseKit = false;
            [JsonProperty(PropertyName = "Kit ID")]
            public List<string> KitName = new List<string>();
        }
        #endregion

        #region Animals
        class SettingsAnimal
        {
            [JsonProperty(PropertyName = "Bear Settings")]
            public BearSettings Bear = new BearSettings();
            [JsonProperty(PropertyName = "PolarBear Settings")]
            public PBearSettings PBear = new PBearSettings();
            [JsonProperty(PropertyName = "Boar Settings")]
            public BoarSettings Boar = new BoarSettings();
            [JsonProperty(PropertyName = "Chicken Settings")]
            public ChickenSettings Chicken = new ChickenSettings();
            [JsonProperty(PropertyName = "Wolf Settings")]
            public WolfSettings Wolf = new WolfSettings();
        }

        class BearSettings
        {
            [JsonProperty(PropertyName = "Chance on spawn (0-100)")]
            public int BearRate = 5;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Amount")]
            public int BearAmount = 1;
            [JsonProperty(PropertyName = "Health")]
            public int BearHealth = 450;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float Life = 5f;
        }

        class PBearSettings
        {
            [JsonProperty(PropertyName = "Chance on spawn (0-100)")]
            public int PBearRate = 5;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Amount")]
            public int PBearAmount = 1;
            [JsonProperty(PropertyName = "Health")]
            public int PBearHealth = 450;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float Life = 5f;
        }

        class BoarSettings
        {
            [JsonProperty(PropertyName = "Chance on spawn (0-100)")]
            public int BoarRate = 10;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Amount")]
            public int BoarAmount = 1;
            [JsonProperty(PropertyName = "Health")]
            public int BoarHealth = 250;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float Life = 5f;
        }

        class ChickenSettings
        {
            [JsonProperty(PropertyName = "Chance on spawn (0-100)")]
            public int ChickenRate = 10;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Amount")]
            public int ChickenAmount = 1;
            [JsonProperty(PropertyName = "Health")]
            public int ChickenHealth = 40;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float Life = 5f;
        }

        class WolfSettings
        {
            [JsonProperty(PropertyName = "Chance on spawn (0-100)")]
            public int WolfRate = 10;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
            [JsonProperty(PropertyName = "Amount")]
            public int WolfAmount = 1;
            [JsonProperty(PropertyName = "Health")]
            public int WolfHealth = 250;
            [JsonProperty(PropertyName = "Life Duration (minutes)")]
            public float Life = 5f;
        }
        #endregion

        #region Explosives
        class SettingsExplosives
        {
            [JsonProperty(PropertyName = "Beancan : Chance on spawn (0-100)")]
            public int BeancanRate = 5;
            [JsonProperty(PropertyName = "F1 Grenade : Chance on spawn (0-100)")]
            public int GrenadeRate = 3;
            [JsonProperty(PropertyName = "Satchel Charge : Chance on spawn (0-100)")]
            public int SatchelRate = 3;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = true;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
        }
        #endregion

        #region Fires
        class SettingsFire
        {
            [JsonProperty(PropertyName = "Small fire : Chance on spawn (0-100)")]
            public int SmallfireRate = 5;
            [JsonProperty(PropertyName = "Oil fire : Chance on spawn (0-100)")]
            public int OilfireRate = 3;
            [JsonProperty(PropertyName = "Oil fire : Duration (max 20s)")]
            public float Duration = 10f;
            [JsonProperty(PropertyName = "Normal Barrels")]
            public bool Normal = false;
            [JsonProperty(PropertyName = "Diesel Barrels (diesel_barrel_world)")]
            public bool Diesel = true;
            [JsonProperty(PropertyName = "Oil Barrels")]
            public bool Oil = true;
        }
        #endregion

        #region cfg save/load
        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #endregion

        #region LanguageApi

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AirdropSpawned"] = "You lucky bastard a Airdrop is comming to your location" ,
                ["HackCrateSpawned"] = "You lucky bastard a Hackable Crate is comming to your location" ,
                ["Beancanspawned"] = "A small explosive fell out of the barrel",
                ["Grenadespawned"] = "A Grenade fell out of the barrel",
                ["Bearspawned"] = "A wild bear just apeared",
                ["MoreBearspawned"] = "Runnn... a sleuth of Bears apeared",
                ["PBearspawned"] = "A wild PolarBear just apeared",
                ["MorePBearspawned"] = "Runnn... they hungry",
                ["Boarspawned"] = "Oink...",
                ["MoreBoarspawned"] = "Oinks...A Sounder of boars apeared",
                ["Chickenspawned"] = "tok tok...",
                ["MoreChickenspawned"] = "tok...toktoktok!",
                ["Scientistspawned"] = "A Scientist was freed from his barrel prison",
                ["MoreScientistsSpawned"] = "Multiple Scientists where freed from their barrel prison",
                ["SignalDropped"] = "You found a supply signal but you dropped it on the floor",
                ["SignalRecieved"] = "Your recieved a supply signal in your inventory",
                ["Wolfspawned"] = "A wild wolf just apeared",
                ["MoreWolvesspawned"] = "Runnn... it is a pack of wolves",
                ["Zombiespawned"] = "A Zombie was freed from his barrel prison",
                ["MoreZombiesSpawned"] = "Multiple Zombies where freed from their barrel prison",
                ["Firespawned"] = "Carefull a spark set the barrel on fire",
                ["OilFirespawned"] = "Ouch a spark had the barrel lit up",
                ["Satchelspawned"] = "Run !!! A hidden satchelcharge was activated"
            } , this);
        }

        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            instance = this;
        }

        void Unload()
        {
            Zombies[] zombies = UnityEngine.Object.FindObjectsOfType<Zombies>();
            if (zombies != null)
            {
                foreach (Zombies zombie in zombies)
                    UnityEngine.Object.Destroy(zombie);
            }
            Scientists[] scientists = UnityEngine.Object.FindObjectsOfType<Scientists>();
            if (scientists != null)
            {
                foreach (Scientists scientist in scientists)
                    UnityEngine.Object.Destroy(scientist);
            }
        }

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }
            prefix = configData.DropData.Prefix;
            chaticon = 76561199200662608;
            BlockOutside = configData.DropData.TriggerOut;
            permission.RegisterPermission(Exclude_Perm , this);
            permission.RegisterPermission(SciTrigger_Perm, this);
            permission.RegisterPermission(ScareTrigger_Perm, this);
            permission.RegisterPermission(BearTrigger_Perm, this);
            permission.RegisterPermission(PBearTrigger_Perm, this);
            permission.RegisterPermission(BoarTrigger_Perm, this);
            permission.RegisterPermission(ChickenTrigger_Perm, this);
            permission.RegisterPermission(WolfTrigger_Perm, this);
            permission.RegisterPermission(ExploTrigger_Perm , this);
            permission.RegisterPermission(FireTrigger_Perm , this);
            permission.RegisterPermission(AirdropTrigger_Perm , this);
            permission.RegisterPermission(HackCrateTrigger_Perm , this);
        }

        void OnEntityDeath(LootContainer entity, HitInfo info)
        {
            if (info?.InitiatorPlayer == null) return;
            if (IsLootBarrel(entity) == false) return;
            if (CheckPlayer(info) == false) return;
            if (!entity.IsOutside() &&  BlockOutside == true) return;

            BasePlayer player = info.InitiatorPlayer;

            if (HasPerm(player, Exclude_Perm)) return;

            var BarrelDistance = Vector3.Distance(entity.transform.position, player.transform.position);

            if (BarrelDistance > configData.DropData.RangeTrigger) return;

            else
            {
                Playerinfo user = get_user(info.InitiatorPlayer);
                if (user.barrelCount < configData.DropData.Barrelcountdrop)
                {
                    user.barrelCount += 1;
                    update_user(info.InitiatorPlayer , user);
                }
                else
                {
                    user.barrelCount = 0;
                    update_user(info.InitiatorPlayer , user);

                    if (entity.transform.position != null)
                    {
                        #region Scarecrow
                        if (SpawnRate(configData.CrowData.SpawnRate) == true && HasPerm(player, ScareTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.CrowData.NPCAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.CrowData.Normal == false) continue;
                                if (IsOilBarrel(entity) && configData.CrowData.Oil == false) continue;
                                if (IsDiesel(entity) && configData.CrowData.Diesel == false) continue;
                                Spawnnpc(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.CrowData.NPCAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Zombiespawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreZombiesSpawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        #endregion

                        #region Scientists
                        if (SpawnRate(configData.SCIData.SpawnRate) == true && HasPerm(player, SciTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.SCIData.NPCAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.SCIData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.SCIData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.SCIData.Oil == false) continue;
                                _FromHell = configData.SCIData.FromHell;
                                SciHealth = configData.SCIData.NPCHealth;
                                SciDamageScale = configData.SCIData.NPCDamageScale;
                                SciLifetime = configData.SCIData.NPCLife;
                                SciName = configData.SCIData.NPCName;
                                _UseKit = configData.SCIData.UseKit;
                                SciKit = configData.SCIData.KitName;
                                SpawnScientist(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.SCIData.NPCAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Scientistspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreScientistsSpawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        #endregion

                        #region Airdrop
                        if (SpawnRate(configData.AirdropData.AirdropRate) == true && entity.IsOutside() && HasPerm(player , AirdropTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AirdropData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AirdropData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AirdropData.Oil == false) continue;

                                SpawnSupplyCrate(airdropString , entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                                if (configData.DropData.ShowMsg == true && IsSpawned == true)
                                {
                                    Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("AirdropSpawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                                }
                            }
                        }
                        else if (SpawnRate(configData.AirdropData.AirdropRate) == true && !entity.IsOutside())
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AirdropData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AirdropData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AirdropData.Oil == false) continue;

                                var _signal = ItemManager.CreateByName("supply.signal" , 1 , 0);
                                player.inventory.GiveItem(_signal , null);
                                IsSpawned = true;
                                RunFX(player);
                                if (player.inventory.containerMain.IsFull())
                                {
                                    _signal.DropAndTossUpwards(player.transform.position);
                                    if (configData.DropData.ShowMsg == true && IsSpawned == true)
                                    {
                                        Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("SignalDropped" , info.InitiatorPlayer.UserIDString)) , chaticon);
                                    }
                                    Signaldropped = true;
                                }
                                if (Signaldropped == false && configData.DropData.ShowMsg == true && IsSpawned == true)
                                {
                                    Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("SignalRecieved" , info.InitiatorPlayer.UserIDString)) , chaticon);
                                }
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        #endregion

                        #region HackCrate
                        if (SpawnRate(configData.HackData.HackdropRate) == true && entity.IsOutside() && HasPerm(player , HackCrateTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.HackData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.HackData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.HackData.Oil == false) continue;

                                SpawnHackCrate(hackcrateString , entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                                if (configData.DropData.ShowMsg == true && IsSpawned == true)
                                {
                                    Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("HackCrateSpawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                                }
                            }
                        }
                        #endregion

                        #region Animals
                        if (SpawnRate(configData.AnimalData.Bear.BearRate) == true && HasPerm(player, BearTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.AnimalData.Bear.BearAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AnimalData.Bear.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AnimalData.Bear.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AnimalData.Bear.Oil == false) continue;
                                _AnimalHealth = configData.AnimalData.Bear.BearHealth;
                                _AnimalLife = configData.AnimalData.Bear.Life;
                                _AnimalString = bearString;
                                SpawnAnimal(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.AnimalData.Bear.BearAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Bearspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreBearspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }

                        if (SpawnRate(configData.AnimalData.PBear.PBearRate) == true && HasPerm(player , PBearTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.AnimalData.PBear.PBearAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AnimalData.PBear.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AnimalData.PBear.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AnimalData.PBear.Oil == false) continue;
                                _AnimalHealth = configData.AnimalData.PBear.PBearHealth;
                                _AnimalLife = configData.AnimalData.PBear.Life;
                                _AnimalString = PBearString;
                                SpawnAnimal(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.AnimalData.PBear.PBearAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("PBearspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MorePBearspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }

                        if (SpawnRate(configData.AnimalData.Boar.BoarRate) == true && HasPerm(player , BoarTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.AnimalData.Boar.BoarAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AnimalData.Boar.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AnimalData.Boar.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AnimalData.Boar.Oil == false) continue;
                                _AnimalHealth = configData.AnimalData.Boar.BoarHealth;
                                _AnimalLife = configData.AnimalData.Boar.Life;
                                _AnimalString = boarstring;
                                SpawnAnimal(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.AnimalData.Boar.BoarAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Boarspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreBoarspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }

                        if (SpawnRate(configData.AnimalData.Chicken.ChickenRate) == true && HasPerm(player , ChickenTrigger_Perm))
                        {
                            IsSpawned = false;  
                            for (int i = 0; i < configData.AnimalData.Chicken.ChickenAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AnimalData.Chicken.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AnimalData.Chicken.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AnimalData.Chicken.Oil == false) continue;
                                _AnimalHealth = configData.AnimalData.Chicken.ChickenHealth;
                                _AnimalLife = configData.AnimalData.Chicken.Life;
                                _AnimalString = chickenString;
                                SpawnAnimal(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.AnimalData.Chicken.ChickenAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Chickenspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreChickenspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }

                        if (SpawnRate(configData.AnimalData.Wolf.WolfRate) == true && HasPerm(player , WolfTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < configData.AnimalData.Wolf.WolfAmount; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.AnimalData.Wolf.Normal == false) continue;
                                if (IsDiesel(entity) && configData.AnimalData.Wolf.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.AnimalData.Wolf.Oil == false) continue;

                                _AnimalHealth = configData.AnimalData.Wolf.WolfHealth;
                                _AnimalLife = configData.AnimalData.Wolf.Life;
                                _AnimalString = wolfString;
                                SpawnAnimal(entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.AnimalData.Wolf.WolfAmount == 1 && configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Wolfspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            else if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("MoreWolvesspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger)
                                return;
                        }
                        #endregion

                        #region explosives
                        if (SpawnRate(configData.ExplosivesData.BeancanRate) == true && HasPerm(player , ExploTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.ExplosivesData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.ExplosivesData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.ExplosivesData.Oil == false) continue;
                                SpawnThrowable(beancanString , entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Beancanspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }

                        if (SpawnRate(configData.ExplosivesData.GrenadeRate) == true && HasPerm(player , ExploTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.ExplosivesData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.ExplosivesData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.ExplosivesData.Oil == false) continue;

                                SpawnThrowable(grenadeString , entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }

                            if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Grenadespawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        if (SpawnRate(configData.ExplosivesData.SatchelRate) == true && HasPerm(player , ExploTrigger_Perm))
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.ExplosivesData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.ExplosivesData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.ExplosivesData.Oil == false) continue;

                                SpawnThrowable(satchelString , entity.transform.position);
                                IsSpawned = true;
                                RunFX(player);
                            }

                            if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Satchelspawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        #endregion

                        #region Fires

                        fireallreadyspawned = false;

                        if (SpawnRate(configData.FireData.SmallfireRate) == true && HasPerm(player , FireTrigger_Perm))
                        {
                            IsSpawned = false;
                            fireallreadyspawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.FireData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.FireData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.FireData.Oil == false) continue;
                                SpawnFire(fireball , entity.transform.position, configData.FireData.Duration);
                                IsSpawned = true;
                                fireallreadyspawned = true;
                                RunFX(player);
                            }
                            if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("Firespawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        if (SpawnRate(configData.FireData.OilfireRate) == true && HasPerm(player , FireTrigger_Perm) && fireallreadyspawned == false)
                        {
                            IsSpawned = false;
                            for (int i = 0; i < 1; i++)
                            {
                                if (IsNormalBarrel(entity) && configData.FireData.Normal == false) continue;
                                if (IsDiesel(entity) && configData.FireData.Diesel == false) continue;
                                if (IsOilBarrel(entity) && configData.FireData.Oil == false) continue;
                                SpawnFire(oilfire , entity.transform.position , configData.FireData.Duration);
                                IsSpawned = true;
                                RunFX(player);
                            }
                            if (configData.DropData.ShowMsg == true && IsSpawned == true)
                            {
                                Player.Message(info.InitiatorPlayer , prefix + string.Format(msg("OilFirespawned" , info.InitiatorPlayer.UserIDString)) , chaticon);
                            }
                            if (configData.DropData.Trigger) return;
                        }
                        #endregion
                    }
                }
            }
        }

        object OnNpcKits(BasePlayer player)
        {
            if (player?.gameObject?.GetComponent<Zombies>() != null) return true;
            if (player?.gameObject?.GetComponent<Scientists>() != null) return true;
            return null;
        }

        private object OnNpcTarget(BaseEntity attacker, BaseEntity target)
        {
            if (attacker?.gameObject?.GetComponent<Zombies>())
            {
                if (target is ScarecrowNPC|| target is BaseNpc)
                {
                    return true;
                }

                if (target is TunnelDweller || target is UnderwaterDweller)
                {
                    return true;
                }
                return null;
            }

            if (target?.gameObject?.GetComponent<Zombies>())
            {
                return true;
            }
            return null;
        }

        private object OnNpcTarget(BaseEntity attacker, BasePlayer target)
        {
            if (attacker?.gameObject?.GetComponent<Zombies>())
            {
                if (target.IsSleeping() || target.IsFlying || !(target.userID.IsSteamId()))
                    return false;
            }
            return null;
        }

        private void OnFireBallDamage(FireBall fire, ScarecrowNPC npc, HitInfo info)
        {
            if (!(npc?.gameObject?.GetComponent<Zombies>() && info.Initiator is FireBall))
            {
                return;
            }

            info.damageTypes = new DamageTypeList();
            info.DoHitEffects = false;
            info.damageTypes.ScaleAll(0f);
        }

        #endregion

        #region Event Helpers

        private void RunFX(BasePlayer player)
        {
            if (configData.DropData.FX == string.Empty) return;
            Effect.server.Run(configData.DropData.FX , player.transform.position + new Vector3(0f , 2.0f , 0f));
        }

        #region Nav & Checks
        public Vector3 GetNavPoint(Vector3 position)
        {
            NavMeshHit hit;
            if (!NavMesh.SamplePosition(position, out hit, 5, -1))
            {
                return position;
            }
            else if (Physics.RaycastAll(hit.position + new Vector3(0, 100, 0), Vector3.down, 99f, 1235288065).Any())
            {
                return position;
            }
            else if (hit.position.y < TerrainMeta.WaterMap.GetHeight(hit.position))
            {
                return position;
            }
            position = hit.position;
            return position;
        }

        private bool SpawnRate(int npcRate)
        {
        if (rnd.Next(1, 101) <= npcRate)
            {
                return true;
            }
        return false;
        }

        private bool CheckPlayer(HitInfo info)
        {
            bool Checker = false;
            BasePlayer player = info.InitiatorPlayer;
            if (player != null || player.IsValid() || info?.Initiator != null)
            {
                Checker = true;
            }
            return Checker;
        }

        private bool IsLootBarrel(BaseCombatEntity entity)
        {
            if (entity.ShortPrefabName.StartsWith("loot-barrel")) return true;
            if (entity.ShortPrefabName.StartsWith("loot_barrel")) return true;
            if (entity.ShortPrefabName.StartsWith("oil_barrel")) return true;
            if (entity.ShortPrefabName.StartsWith("diesel_barrel_world")) return true;
            return false;
        }

        private bool IsOilBarrel(BaseCombatEntity entity)
        {
            if (entity.ShortPrefabName.StartsWith("oil_barrel")) return true;
            return false;
        }

        private bool IsDiesel(BaseCombatEntity entity)
        {
            if (entity.ShortPrefabName.StartsWith("diesel_barrel_world")) return true;
            return false;
        }

        private bool IsNormalBarrel(BaseCombatEntity entity)
        {
            if (entity.ShortPrefabName.StartsWith("loot-barrel")) return true;
            if (entity.ShortPrefabName.StartsWith("loot_barrel")) return true;
            return false;
        }

        #endregion

        #region Scarecrow
        private void Spawnnpc(Vector3 position)
        {
            Vector3 pos = position + UnityEngine.Random.onUnitSphere * 1.5f;
            pos = GetNavPoint(pos);

            ScarecrowNPC npc = (ScarecrowNPC)GameManager.server.CreateEntity(zombie, pos, new Quaternion(), true);
            npc.Spawn();

            NextTick(() =>
            {
                if (npc == null)
                    return;

                var mono = npc.gameObject.AddComponent<Zombies>();
                mono.SpawnPoint = pos;

                npc.startHealth = configData.CrowData.NPCHealth;
                npc.InitializeHealth(configData.CrowData.NPCHealth, configData.CrowData.NPCHealth);
                npc.CanAttack();
                timer.Once(0.5f, () =>
                {
                Chainsaw heldEntity = npc.GetHeldEntity() as Chainsaw;
                if (heldEntity != null)
                {
                    npc.displayName = configData.CrowData.NPCName2 + " " + RandomUsernames.Get(npc.userID.Get());
                    heldEntity.SetFlag(Chainsaw.Flags.On, true);
                    heldEntity.SendNetworkUpdateImmediate();
                }
                    else
                    {
                        npc.displayName = configData.CrowData.NPCName + " " + RandomUsernames.Get(npc.userID.Get());
                    }
                });


                if (configData.CrowData.FromHell)
                {
                    var Fire = GameManager.server.CreateEntity(fireball, new Vector3(0, 1, 0), Quaternion.Euler(0, 0, 0));
                    Fire.gameObject.Identity();
                    Fire.SetParent(npc);
                    Fire.Spawn();
                    timer.Once(1f, () =>
                    {
                        if (Fire != null) Fire.Kill();
                        Puts($"{npc} spawned From Hell (on Fire)");
                    });
                }

                npc.damageScale = configData.CrowData.NPCDamageScale;

                if (configData.CrowData.UseKit && configData.CrowData.KitName.Count > 0)
                {
                    object checkKit = Kits?.CallHook("GetKitInfo", configData.CrowData.KitName[new System.Random().Next(configData.CrowData.KitName.Count())]);
                    if (checkKit == null)
                        NextTick(() =>
                        {
                            var inv_belt = npc.inventory.containerBelt;
                            var inv_wear = npc.inventory.containerWear;
                            Item eyes = ItemManager.CreateByName("gloweyes", 1, 0);
                            if (eyes != null) eyes.MoveToContainer(inv_wear);
                            PrintWarning($"Kit for {npc} does not exist - Using a default outfit.");
                        });
                    else
                    {
                        npc.inventory.Strip();
                        Kits?.Call($"GiveKit", npc, configData.CrowData.KitName[new System.Random().Next(configData.CrowData.KitName.Count())]);
                    }
                }
                if (!configData.CrowData.UseKit || configData.CrowData.KitName.Count == 0)
                {
                    var inv_belt = npc.inventory.containerBelt;
                    var inv_wear = npc.inventory.containerWear;
                    Item eyes = ItemManager.CreateByName("gloweyes", 1, 0);
                    if (eyes != null) eyes.MoveToContainer(inv_wear);
                }
            });

            if (npc.IsHeadUnderwater())
            {
                npc.Kill();
                Puts($"{npc} got destroyed for being under water!!!");
                return;
            }

            timer.Once(configData.CrowData.NPCLife * 60, () =>
            {
                if (npc != null)
                {
                    npc.Kill();
                    Puts($"{npc} Died of old age");
                }
                return;
            });
        }
        #endregion

        #region Scientist
        private void SpawnScientist(Vector3 position)
        {
            Vector3 pos = position + UnityEngine.Random.onUnitSphere * 1.5f;
            pos = GetNavPoint(pos);

            NPCPlayer npc = (NPCPlayer)GameManager.server.CreateEntity(_scientist, pos, new Quaternion(), true);
            npc.Spawn();

            NextTick(() =>
            {
                if (npc == null)
                    return;

                var mono = npc.gameObject.AddComponent<Scientists>();
                mono.SpawnPoint = pos;

                npc.startHealth = SciHealth;
                npc.InitializeHealth(SciHealth, SciHealth);
                npc.CanAttack();
                timer.Once(0.5f, () =>
                {
                    npc.displayName = SciName + " " + RandomUsernames.Get(npc.userID.Get());
                });


                if (_FromHell)
                {
                    var Fire = GameManager.server.CreateEntity(fireball, new Vector3(0, 1, 0), Quaternion.Euler(0, 0, 0));
                    Fire.gameObject.Identity();
                    Fire.SetParent(npc);
                    Fire.Spawn();
                    timer.Once(1f, () =>
                    {
                        if (Fire != null) Fire.Kill();
                        Puts($"{npc} spawned From Hell (on Fire)");
                    });
                }

                npc.damageScale = SciDamageScale;

                if (_UseKit && SciKit.Count > 0)
                {
                    object checkKit = Kits?.CallHook("GetKitInfo", SciKit[new System.Random().Next(SciKit.Count())]);
                    if (checkKit == null)
                    timer.Once(1f, () =>
                    {
                        PrintWarning($"Kit for {npc} does not exist - Using a default outfit.");
                    });
                    else
                    {
                        npc.inventory.Strip();
                        Kits?.Call($"GiveKit", npc, SciKit[new System.Random().Next(SciKit.Count())]);
                        timer.Once(1f, () =>
                        {
                            PrintWarning($"Kit for {npc} succesfully equiped.");
                        });

                    }
                }
                if (!_UseKit || SciKit.Count == 0)
                {
                    timer.Once(1f, () =>
                    {
                        PrintWarning($"{npc} spawned Using a default outfit.");
                    });
                }
            });

            if (npc.IsHeadUnderwater())
            {
                npc.Kill();
                timer.Once(1f, () =>
                {
                    PrintWarning($"{npc} got destroyed for being under water!!!");
                });
                return;
            }

            timer.Once(SciLifetime * 60, () =>
            {
                if (npc != null)
                {
                    npc.Kill();
                    Puts($"{npc} Died of old age");
                }
                return;
            });
        }

        #endregion

        #region Airdrop
        private void SpawnSupplyCrate(string prefab, Vector3 position)
        {
            Vector3 newPosition = position + new Vector3(0, configData.AirdropData.AirdropHeight, 0);
            BaseEntity SupplyCrateEntity = GameManager.server.CreateEntity(prefab, newPosition);
            if (SupplyCrateEntity != null)
            {
                SupplyDrop Drop = SupplyCrateEntity.GetComponent<SupplyDrop>();
                Drop.Spawn();
            }
        }
        #endregion

        #region hack crate
        private void SpawnHackCrate(string prefab , Vector3 position)
        {
            Vector3 newPosition = position + new Vector3(0 , configData.HackData.HackdropHeight , 0);
            BaseEntity HackCrateEntity = GameManager.server.CreateEntity(prefab , newPosition);
            if (HackCrateEntity != null)
            {
                HackableLockedCrate HackCrate = HackCrateEntity.GetComponent<HackableLockedCrate>();
                HackCrate.Spawn();
            }
        }
        #endregion

        #region Animals
        private void SpawnAnimal(Vector3 position)
        {
            Vector3 pos = position + UnityEngine.Random.onUnitSphere * 1.0f;
            pos = GetNavPoint(pos);
            BaseNpc Animal = (BaseNpc)GameManager.server.CreateEntity(_AnimalString, pos, new Quaternion(), true);
            if (Animal != null)
            {
                Animal.Spawn();
                Animal.startHealth = _AnimalHealth;
                Animal.InitializeHealth(_AnimalHealth, _AnimalHealth);
            }

            timer.Once(_AnimalLife * 60, () =>
            {
                if (Animal != null)
                {
                    Animal.Kill();
                    Puts($"The {Animal.ShortPrefabName.ToString()} Died of old age");
                }
                return;
            });
        }
        #endregion

        #region Explosives
        private void SpawnThrowable(string prefab, Vector3 position)
        {
            Vector3 newPosition = GetNavPoint(position) + new Vector3(0, 1.4f, 0);
            BaseEntity throwingitem = GameManager.server.CreateEntity(prefab , newPosition);
            if (throwingitem != null)
            {
                throwingitem.Spawn();
            }
        }

        private void SpawnFire(string prefab, Vector3 position, float Killtime)
        {
            Vector3 newPosition = GetNavPoint(position) + new Vector3(0, 1.4f, 0);
            BaseEntity fire = GameManager.server.CreateEntity(prefab , newPosition);
            if (Killtime > 20 || Killtime == 0) Killtime = 20f;
            if (fire != null)
            {
                fire.Spawn();
                timer.Once(Killtime , () =>
                {
                    fire.Kill();
                    //Puts("Killed fire"); //example
                });
            }
        }

        #endregion

        #endregion

        #region Message and helpers

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        bool HasPerm(BasePlayer player , string perm) { return permission.UserHasPermission(player.UserIDString , perm); }//Check for permission

        #endregion

        #region Data helpers
        Playerinfo get_user(BasePlayer player)
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(file_main + player.UserIDString))
            {
                Playerinfo user = new Playerinfo();
                user.userName = player.displayName.ToString();
                user.barrelCount = 0;
                update_user(player, user);
                return user;
            }
            else
            {
                string raw_player_file = Interface.Oxide.DataFileSystem.ReadObject<string>(file_main + player.UserIDString);
                return JsonConvert.DeserializeObject<Playerinfo>(raw_player_file);
            }
        }

        void update_user(BasePlayer player, Playerinfo user)
        {
            Interface.Oxide.DataFileSystem.WriteObject<string>(file_main + player.UserIDString, JsonConvert.SerializeObject(user));
        }

        public class Playerinfo
        {
            private string _userName;
            private int _barrelCount;

            public Playerinfo()
            {

            }

            public int barrelCount
            {
                get { return _barrelCount; }
                set { _barrelCount = value; }
            }

            public string userName
            {
                get { return _userName; }
                set { _userName = value; }
            }

        }
        #endregion
    }
}

// --- End of file: Barrelless.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ban-fix ---
// --- Original File Path: B/BanFix/BanFix.cs ---

﻿using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Linq;
using System.Diagnostics;
using System.Collections;
//Reference: Facepunch.Sqlite

namespace Oxide.Plugins
{
    [Info("BanFix", "Jake_Rich", "1.0.0")]
    [Description("")]

    public class BanFix : RustPlugin
    {
        private Facepunch.Sqlite.Database banDB;

        public const string TableName = "server_users";

        void SetupDatabase()
        {
            banDB = new Facepunch.Sqlite.Database();
            banDB.Open($"{ConVar.Server.rootFolder}/ServerUsers.db");
            if (!banDB.TableExists(TableName))
            {
                //group is a reserved word: using usergroup instead
                banDB.Execute($"CREATE TABLE {TableName} ( steamid INTEGER PRIMARY KEY, usergroup INTEGER, username TEXT, notes TEXT )");
                OnServerSaveUsers();
            }
        }

        private IEnumerator SaveBansToDatabase()
        {
            var bans = ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToList();
            yield return null; //Gotta have that debug message show when you first load the plguin
            Puts($"Starting To Push {bans.Count} Bans To Database");
            foreach (var user in bans)
            {
                UpdateUserGroup(user.steamid, user.group, user.username, user.notes);
                yield return null;
            }
            Puts("Finished Saving All Bans To The Database");
            yield return null;
        }


        #region Hooks

        void OnServerInitialized()
        {
            SetupDatabase();
            OnServerLoadUsers();
        }

        void Unload()
        {
            banDB?.Close();
        }

        void OnServerShutdown()
        {
            //May as well write to default file on shutdown
            ServerUsers.Save();
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.FullName == "global.ban")
            {
                if (arg.IsAdmin)
                {
                    //Need to overwrite ban command as vanilla one will save to file
                    OverwriteBanCommand(arg);
                }
                return false;
            }
            return null;
        }

        //Not really a hook but sorta as we are copy paste overwriting it
        void OverwriteBanCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = ArgEx.GetPlayer(arg, 0);
            if (!(bool)player || player.net == null || player.net.connection == null)
            {
                arg.ReplyWith("Player not found");
            }
            else
            {
                ServerUsers.User user = ServerUsers.Get(player.userID);
                if (user != null && user.group == ServerUsers.UserGroup.Banned)
                {
                    arg.ReplyWith("User " + player.userID + " is already banned");
                }
                else
                {
                    string @string = arg.GetString(1, "No Reason Given");
                    ServerUsers.Set(player.userID, ServerUsers.UserGroup.Banned, player.displayName, @string);
                    string text = string.Empty;
                    if (player.IsConnected && player.net.connection.ownerid != player.net.connection.userid)
                    {
                        text = text + " and also banned ownerid " + player.net.connection.ownerid;
                        ServerUsers.Set(player.net.connection.ownerid, ServerUsers.UserGroup.Banned, player.displayName, arg.GetString(1, "Family share owner of " + player.net.connection.userid));
                    }
                    //We don't actually have to save, because we save on user group changed
                    //OnServerSaveUsers();
                    //ServerUsers.Save();
                    arg.ReplyWith("Kickbanned User: " + player.userID + " - " + player.displayName + text);
                    PrintToChat("Kickbanning " + player.displayName + " (" + @string + ")", "SERVER", "#eee", 0uL);
                    Network.Net.sv.Kick(player.net.connection, "Banned: " + @string);
                }
            }
        }

        Coroutine saveRoutine;

        //Hook Save (Save To DB instead of File) 
        //Not used much: we're saving individual user changes instead of them all
        void OnServerSaveUsers()
        {
            //OK RYAN DO YOUR SAVE SHIT HERE

            //We needed to spread out the queries: took 16,000MS to load 4k bans
            if (saveRoutine != null)
            {
                ServerMgr.Instance.StopCoroutine(saveRoutine); //Don't let users be stupid and save multiple times and lag their server
            }
            saveRoutine = ServerMgr.Instance.StartCoroutine(SaveBansToDatabase());
        }

        //Hook Load (Load from DB instead of File)
        void OnServerLoadUsers()
        {
            //NOW DO YOUR LOAD STUFF HERE
            LoadingServerUsers = true;
            foreach (var row in banDB.Query($"SELECT * FROM {TableName}"))
            {
                //https://stackoverflow.com/questions/11226448/invalidcastexception-long-to-ulong
                //Never knew you had to cast to long then ulong in a specific situation
                ulong steamID = (ulong)((long)row.Value["steamid"]);
                ServerUsers.UserGroup group = (ServerUsers.UserGroup)row.Value.GetInt("usergroup");
                string name = row.Value.GetString("username") ?? "";
                string reason = row.Value.GetString("notes") ?? "";
                ServerUsers.Set(steamID, group, name, reason);
            }
            LoadingServerUsers = false;
        }

        void OnPlayerBanned(string name, ulong steamID, string IP, string reason)
        {
            if (LoadingServerUsers)
            {
                return;
            }
            UpdateUserGroup(steamID, ServerUsers.UserGroup.Banned, name, reason);
        }

        void OnPlayerUnbanned(string name, ulong steamID, string IP)
        {
            if (LoadingServerUsers)
            {
                return;
            }
            RemoveUserGroup(steamID);
        }

        #endregion

        private bool LoadingServerUsers = false;

        void ClearDatabase()
        {
            banDB.Execute($"DELETE FROM {TableName}");
            banDB.Execute("VACUUM");
        }

        void UpdateUserGroup(ulong steamId, ServerUsers.UserGroup group, string name, string notes)
        {
            banDB.Execute($"INSERT OR REPLACE INTO {TableName} ( steamid, usergroup, username, notes ) VALUES ( ?, ?, ?, ? )", (long)steamId, (int)group, name ?? "", notes ?? "");
        }

        void RemoveUserGroup(ulong steamId)
        {
            banDB.Execute($"DELETE FROM {TableName} WHERE steamid = ?", steamId);
        }

        #region Commands

        [ConsoleCommand("bans.save.db")]
        void SaveBansToDB_CMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            OnServerSaveUsers();
        }

        [ConsoleCommand("bans.save.file")]
        void SaveBansToFile_CMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            ServerUsers.Save();
        }

        [ConsoleCommand("bans.clear.db")]
        void ClearBansTest(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            ClearDatabase();
            Puts($"Cleared Database");
        }

        [ConsoleCommand("bans.clear.file")]
        void ClearLocalBans(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            LoadingServerUsers = true;
            foreach (var ban in ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToList())
            {
                ServerUsers.Remove(ban.steamid);
            }
            LoadingServerUsers = false;
            Puts($"Cleared Server Bans");
        }

        [ConsoleCommand("bans.load.db")]
        void LoadBansDB_CMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            OnServerLoadUsers();
            Puts("Loaded Bans From DB");
        }

        [ConsoleCommand("bans.load.file")]
        void LoadBansFile_CMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            LoadingServerUsers = true;
            ServerUsers.Load();
            LoadingServerUsers = false;
            Puts("Loaded Bans From File");
        }

        [ConsoleCommand("bans.check")]
        void ReadBansTest(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            int result = banDB.Query($"SELECT * FROM {TableName}").Count;
            Puts($"Database: {result} Server: {ServerUsers.GetAll(ServerUsers.UserGroup.Banned).Count()}");
        }

        [ConsoleCommand("bans.test")]
        void TestOldBan(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            Stopwatch watch = new Stopwatch();
            watch.Start();
            ServerUsers.Save();
            watch.Stop();
            Puts($"Took {watch.ElapsedMilliseconds} ms for old ban method");
            watch.Reset();
            watch.Start();
            UpdateUserGroup(76561198104673895u, ServerUsers.UserGroup.Moderator, "Jake", "PLEASE FUCKING WORK");
            watch.Stop();
            Puts($"Took {watch.ElapsedMilliseconds} ms for new ban method");
            watch.Reset();
            watch.Start();
            RemoveUserGroup(76561198104673895u);
            watch.Stop();
            Puts($"Took {watch.ElapsedMilliseconds} ms for new unban method");
            watch.Reset();
        }

        #endregion
    }
}

// --- End of file: BanFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/blueprint-share ---
// --- Original File Path: B/BlueprintShare/BlueprintShare.cs ---

using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Blueprint Share", "c_creep", "1.4.1")]
    [Description("Allows players to share researched blueprints with their friends, clan or team")]
    class BlueprintShare : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Clans, Friends;

        private StoredData storedData;

        private enum ShareType
        {
            Teams,
            Friends,
            Clans
        }

        private const string usePermission = "blueprintshare.use";
        private const string togglePermission = "blueprintshare.toggle";
        private const string sharePermission = "blueprintshare.share";
        private const string showPermission = "blueprintshare.show";
        private const string bypassPermission = "blueprintshare.bypass";

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            LoadData();

            permission.RegisterPermission(usePermission, this);
            permission.RegisterPermission(togglePermission, this);
            permission.RegisterPermission(sharePermission, this);
            permission.RegisterPermission(showPermission, this);
            permission.RegisterPermission(bypassPermission, this);

            if (!config.TeamsEnabled)
            {
                Unsubscribe(nameof(OnTeamAcceptInvite));
                Unsubscribe(nameof(OnTeamKick));
                Unsubscribe(nameof(OnTeamLeave));
            }

            if (!config.ClansEnabled)
            {
                Unsubscribe(nameof(OnClanMemberJoined));
                Unsubscribe(nameof(OnClanMemberGone));
            }

            if (!config.FriendsEnabled)
            {
                Unsubscribe(nameof(OnFriendAdded));
                Unsubscribe(nameof(OnFriendRemoved));
            }
        }

        private void OnNewSave(string filename)
        {
            if (!config.ClearDataOnWipe) return;

            CreateData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            EnsurePlayerDataExists(player.UserIDString);
        }

        private void OnItemAction(Item item, string action, BasePlayer player)
        {
            if (!config.PhysicalSharingEnabled) return;
            if (player == null || item == null) return;
            if (action != "study") return;

            if (TryShareBlueprint(item.blueprintTargetDef, player))
            {
                item.Remove();
            }
        }

        private void OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
        {
            if (!config.TechTreeSharingEnabled) return;
            if (workbench == null || node == null || player == null) return;

            TryShareBlueprint(node.itemDef, player);
        }

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (!config.ShareBlueprintsOnJoin && !config.ShareBlueprintsWithNewMember) return;
            if (team == null || player == null) return;

            timer.Once(1f, () =>
            {
                var teamMemberIds = team.members;

                if (teamMemberIds.Count == 0) return;

                var teamLeader = team.GetLeader();

                if (teamLeader == null) return;

                if (config.ShareBlueprintsOnJoin)
                {
                    ShareWithPlayer(teamLeader, player);
                }

                if (config.ShareBlueprintsWithNewMember)
                {
                    var teamMembers = FindPlayersFromIds(teamMemberIds, teamLeader.userID);

                    if (teamMembers.Count == 0) return;

                    foreach (var teamMember in teamMembers)
                    {
                        if (player == null || teamMember == null) continue;

                        ShareWithPlayer(player, teamMember);
                    }
                }
            });
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            PlayerLeftTeam(player);
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            PlayerLeftTeam(RustCore.FindPlayerById(target));
        }

        #endregion

        #region External Plugins

        #region Friends

        private bool HasFriends(ulong playerId)
        {
            if (Friends == null || !Friends.IsLoaded) return false;

            var friendsList = Friends.Call<ulong[]>("GetFriends", playerId);

            return friendsList != null && friendsList.Length != 0;
        }

        private List<ulong> GetFriends(ulong playerId)
        {
            if (Friends == null || !Friends.IsLoaded) return new List<ulong>();

            var friends = Friends.Call<ulong[]>("GetFriends", playerId);

            return friends.ToList();
        }

        private bool AreFriends(ulong playerId, ulong targetId)
        {
            return Friends != null && Friends.IsLoaded && Friends.Call<bool>("AreFriends", playerId, targetId);
        }

        #endregion

        #region Clan

        private bool InClan(ulong playerId)
        {
            if (Clans == null) return false;

            var clanName = Clans?.Call<string>("GetClanOf", playerId);

            return clanName != null;
        }

        private List<ulong> GetClanMembers(ulong playerId)
        {
            var clanTag = Clans?.Call<string>("GetClanOf", playerId);

            var clanInfo = Clans?.Call<JObject>("GetClan", clanTag);

            return clanInfo["members"].ToObject<List<ulong>>();
        }

        private bool SameClan(ulong playerId, ulong targetId)
        {
            var playerClanTag = Clans?.Call<string>("GetClanOf", playerId);

            if (string.IsNullOrEmpty(playerClanTag)) return false;

            var targetClanTag = Clans?.Call<string>("GetClanOf", targetId);

            if (string.IsNullOrEmpty(targetClanTag)) return false;

            return playerClanTag == targetClanTag;
        }

        #endregion

        #region Team

        private bool InTeam(ulong playerId)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;

            var playersTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);

            return playersTeam != null && playersTeam.members.Count > 1;
        }

        private List<ulong> GetTeamMembers(ulong playerId)
        {
            var playersTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);

            return playersTeam?.members;
        }

        private bool SameTeam(ulong playerId, ulong targetId)
        {
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);

            if (playerTeam == null) return false;

            var targetTeam = RelationshipManager.ServerInstance.FindPlayersTeam(targetId);

            if (targetTeam == null) return false;

            return playerTeam == targetTeam;
        }

        #endregion

        #endregion

        #region External Plugin Hooks

        private void OnFriendAdded(string playerId, string friendId)
        {
            if (!config.ShareBlueprintsOnJoin) return;

            var player = RustCore.FindPlayerByIdString(playerId);

            if (player == null) return;

            var friend = RustCore.FindPlayerByIdString(friendId);

            if (friend == null) return;

            ShareWithPlayer(player, friend);

            if (!config.ShareBlueprintsWithNewMember) return;

            ShareWithPlayer(friend, player);
        }

        private void OnFriendRemoved(string playerId, string friendId)
        {
            if (!config.LoseBlueprintsOnLeave) return;

            var learntBlueprints = GetFriendBlueprints(playerId, friendId);

            if (learntBlueprints.Count == 0) return;

            var player = RustCore.FindPlayerByIdString(playerId);

            if (player == null) return;

            RemoveBlueprints(player, learntBlueprints, ShareType.Friends, friendId);
        }

        private void OnClanMemberJoined(ulong playerId, string clanName)
        {
            if (!config.ShareBlueprintsOnJoin) return;

            var player = RustCore.FindPlayerById(playerId);

            var clanMemberIds = GetClanMembers(playerId);

            var clanMembers = FindPlayersFromIds(clanMemberIds, playerId);

            if (clanMembers.Count == 0) return;
            
            foreach (var clanMember in clanMembers)
            {
                if (player == null || clanMember == null) continue;

                ShareWithPlayer(clanMember, player);

                if (config.ShareBlueprintsWithNewMember)
                {
                    ShareWithPlayer(player, clanMember);
                }
            }
        }

        private void OnClanMemberGone(ulong playerId, string tag)
        {
            if (!config.LoseBlueprintsOnLeave) return;

            var learntBlueprints = GetClanBlueprints(playerId.ToString());

            if (learntBlueprints.Count == 0) return;

            var player = RustCore.FindPlayerById(playerId);

            if (player == null) return;

            RemoveBlueprints(player, learntBlueprints, ShareType.Clans);
        }

        #endregion

        #region Core

        private bool TryShareBlueprint(ItemDefinition item, BasePlayer player)
        {
            if (item == null || player == null) return false;
            if (!permission.UserHasPermission(player.UserIDString, usePermission)) return false;

            if (BlueprintBlocked(item))
            {
                SendMessage("BlueprintBlocked", player, true, item.displayName.translated);

                return false;
            }

            var playerId = player.userID;

            if (SharingEnabled(player.UserIDString) && HasSocialConnections(playerId) && SomeoneWillLearnBlueprint(playerId, item))
            {
                ShareWithPlayers(player, item);
                ShareAdditionalBlueprints(player, item);

                return true;
            }

            return false;
        }

        private bool HasSocialConnections(ulong playerId)
        {
            return InTeam(playerId) || InClan(playerId) || HasFriends(playerId);
        }

        private void ShareAdditionalBlueprints(BasePlayer player, ItemDefinition item)
        {
            var additionalBlueprints = item.Blueprint.additionalUnlocks;

            if (additionalBlueprints.Count == 0) return;

            foreach (var blueprint in additionalBlueprints)
            {
                UnlockBlueprint(player, null, blueprint.itemid);
                ShareWithPlayers(player, blueprint);
            }
        }

        private bool UnlockBlueprint(BasePlayer player, BasePlayer sharer, int blueprint)
        {
            if (player == null) return false;

            var playerInfo = player.PersistantPlayerInfo;

            if (playerInfo == null) return false;
            if (playerInfo.unlockedItems.Contains(blueprint)) return false;

            playerInfo.unlockedItems.Add(blueprint);

            player.PersistantPlayerInfo = playerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC(RpcTarget.Player("UnlockedBlueprint", player), blueprint);
            player.stats.Add("blueprint_studied", 1);

            PlaySoundEffect(player);

            if (config.LoseBlueprintsOnLeave && sharer != null)
            {
                AddBlueprintToDatabase(player.userID, sharer.userID, blueprint);
            }

            return true;
        }

        private int UnlockBlueprints(BasePlayer player, BasePlayer sharer, List<int> blueprints)
        {
            if (player == null) return 0;

            var playerInfo = player.PersistantPlayerInfo;

            var successfulUnlocks = 0;

            foreach (var blueprint in blueprints)
            {
                if (playerInfo.unlockedItems.Contains(blueprint)) continue;

                playerInfo.unlockedItems.Add(blueprint);
                
                player.stats.Add("blueprint_studied", 1);

                if (config.LoseBlueprintsOnLeave && sharer != null)
                {
                    AddBlueprintToDatabase(player.userID, sharer.userID, blueprint);
                }

                successfulUnlocks++;
            }

            if (successfulUnlocks > 0)
            {
                PlaySoundEffect(player);

                player.PersistantPlayerInfo = playerInfo;
                player.SendNetworkUpdateImmediate();
                player.ClientRPC(RpcTarget.Player("UnlockedBlueprint", player), 0);

                if (config.LoseBlueprintsOnLeave)
                {
                    SaveData();
                }
            }

            return successfulUnlocks;
        }

        private void ShareWithPlayers(BasePlayer player, ItemDefinition item)
        {
            if (player == null || item == null || !SharingEnabled(player.UserIDString)) return;

            var successfulUnlocks = 0;

            foreach (var target in GetPlayersToShareWith(player.userID))
            {
                if (target == null || !SharingEnabled(target.UserIDString)) return;

                if (UnlockBlueprint(target, player, item.itemid))
                {
                    successfulUnlocks++;

                    if (config.ReceiveMessagesEnabled)
                    {
                        SendMessage("TargetLearntBlueprint", target, true, player.displayName, item.displayName.translated);
                    }
                }
            }

            if (successfulUnlocks > 0)
            {
                if (config.ShareMessagesEnabled)
                {
                    SendMessage("PlayerSharedBlueprint", player, true, item.displayName.translated, successfulUnlocks);
                }

                if (config.LoseBlueprintsOnLeave)
                {
                    SaveData();
                }
            }
        }

        private void ShareWithPlayer(BasePlayer player, BasePlayer target)
        {
            if (player == null || target == null) return;

            var playerId = player.userID;
            var targetId = target.userID;

            if (!SharingEnabled(target.UserIDString))
            {
                SendMessage("TargetSharingDisabled", player, true, target.displayName);

                return;
            }

            if (!SameTeam(playerId, targetId) && !SameClan(playerId, targetId) && !AreFriends(playerId, targetId) && !permission.UserHasPermission(player.UserIDString, bypassPermission))
            {
                SendMessage("CannotShare", player, true);

                return;
            }

            var filteredBlueprints = RemoveBlockedBlueprints(player.PersistantPlayerInfo.unlockedItems);

            if (filteredBlueprints.Count == 0)
            {
                SendMessage("NoBlueprintsToShare", player, true, target.displayName);

                return;
            }

            var learntBlueprints = UnlockBlueprints(target, player, filteredBlueprints);

            if (learntBlueprints > 0)
            {
                if (config.ShareMessagesEnabled)
                {
                    SendMessage("PlayerSharedBlueprints", player, true, learntBlueprints, target.displayName);
                }
                
                if (config.ReceiveMessagesEnabled)
                {
                    SendMessage("TargetLearntBlueprints", target, true, player.displayName, learntBlueprints);
                }
            }
            else
            {
                SendMessage("NoBlueprintsToShare", player, true, target.displayName);
            }
        }

        private List<int> RemoveBlockedBlueprints(List<int> blueprints)
        {
            return blueprints.Where(blueprint =>
            {
                var item = ItemManager.FindItemDefinition(blueprint);
                return item != null && !BlueprintBlocked(item);
            }).ToList();
        }

        private bool SomeoneWillLearnBlueprint(ulong playerId, ItemDefinition item)
        {
            if (item == null) return false;

            var targets = GetPlayersToShareWith(playerId);

            if (targets.Count == 0) return false;

            var countUnlocked = targets.Count(target => target != null && !target.blueprints.HasUnlocked(item));

            return countUnlocked > 0;
        }

        private List<BasePlayer> GetPlayersToShareWith(ulong playerId)
        {
            var ids = new HashSet<ulong>();

            if (config.ClansEnabled && Clans != null && InClan(playerId))
            {
                ids.UnionWith(GetClanMembers(playerId));
            }

            if (config.FriendsEnabled && HasFriends(playerId))
            {
                ids.UnionWith(GetFriends(playerId));
            }

            if (config.TeamsEnabled && InTeam(playerId))
            {
                ids.UnionWith(GetTeamMembers(playerId));
            }

            return FindPlayersFromIds(ids.ToList(), playerId);
        }

        private void AddBlueprintToDatabase(ulong playerId, ulong sharerId, int blueprint)
        {
            if (config.TeamsEnabled && SameTeam(playerId, sharerId))
            {
                AddTeamShare(playerId.ToString(), blueprint);
            }

            if (config.ClansEnabled && SameClan(playerId, sharerId))
            {
                AddClanShare(playerId.ToString(), blueprint);
            }

            if (config.FriendsEnabled && AreFriends(playerId, sharerId))
            {
                AddFriendShare(playerId.ToString(), sharerId.ToString(), blueprint);
            }
        }

        private void RemoveBlueprintsFromDatabase(ShareType type, string playerId, string friendId)
        {
            switch (type)
            {
                case ShareType.Teams:
                    {
                        RemoveTeamShare(playerId);

                        break;
                    }
                case ShareType.Clans:
                    {
                        RemoveClanShare(playerId);

                        break;
                    }
                case ShareType.Friends:
                    {
                        RemoveFriendShare(playerId, friendId);

                        break;
                    }
                default:
                    {
                        throw new ArgumentException(nameof(type));
                    }
            }

            SaveData();
        }

        private void RemoveBlueprints(BasePlayer player, List<int> blueprints, ShareType type, string friendId = "")
        {
            if (player == null || blueprints.Count == 0) return;

            var playerInfo = player.PersistantPlayerInfo;
            var blueprintsRemoved = 0;

            foreach (var blueprint in blueprints)
            {
                if (!playerInfo.unlockedItems.Contains(blueprint)) continue;

                playerInfo.unlockedItems.Remove(blueprint);

                blueprintsRemoved++;
            }

            if (blueprintsRemoved == 0) return;

            player.PersistantPlayerInfo = playerInfo;
            player.SendNetworkUpdateImmediate();
            player.ClientRPC(RpcTarget.Player("UnlockedBlueprint", player), 0);

            RemoveBlueprintsFromDatabase(type, player.UserIDString, friendId);
            SendMessage("BlueprintsRemoved", player, true, blueprintsRemoved);
        }

        private void PlayerLeftTeam(BasePlayer player)
        {
            if (player == null || !config.LoseBlueprintsOnLeave) return;

            var learntBlueprints = GetTeamBlueprints(player.UserIDString);

            if (learntBlueprints.Count == 0) return;

            RemoveBlueprints(player, learntBlueprints, ShareType.Teams);
        }

        #endregion

        #region Utility

        private void PlaySoundEffect(BasePlayer player)
        {
            if (player == null) return;

            var soundEffect = new Effect("assets/prefabs/deployable/research table/effects/research-success.prefab", player.transform.position, Vector3.zero);

            if (soundEffect == null) return;

            EffectNetwork.Send(soundEffect, player.net.connection);
        }

        private List<BasePlayer> FindPlayersFromIds(List<ulong> ids, ulong playerId) => ids.Where(id => id != playerId).Select(id => RustCore.FindPlayerById(id)).Where(target => target != null).Distinct().ToList();
        
        private bool BlueprintBlocked(ItemDefinition item) => config.BlockedItems.Contains(item.shortname);

        private HashSet<int> GetSharedBlueprints(string playerId, ShareType type, string friendId)
        {
            var learntBlueprints = new HashSet<int>();

            switch (type)
            {
                case ShareType.Teams:
                    {
                        learntBlueprints.UnionWith(GetTeamBlueprints(playerId));

                        break;
                    }

                case ShareType.Clans:
                    {
                        learntBlueprints.UnionWith(GetClanBlueprints(playerId));

                        break;
                    }

                case ShareType.Friends:
                    {
                        learntBlueprints.UnionWith(GetFriendBlueprints(playerId, friendId));

                        break;
                    }
            }

            return learntBlueprints;
        }

        private void SortBlueprintsByWorkbenchLevel(HashSet<int> learntBlueprints, ref Dictionary<int, List<string>> workbenchTiers)
        {
            foreach (var blueprint in learntBlueprints)
            {
                var blueprintItem = ItemManager.FindItemDefinition(blueprint);

                if (blueprintItem == null) continue;

                var blueprintLevel = blueprintItem.Blueprint.workbenchLevelRequired;

                if (!workbenchTiers.ContainsKey(blueprintLevel)) continue;

                workbenchTiers[blueprintLevel].Add(blueprintItem.displayName.translated);
            }
        }

        private void DisplayLearntBlueprints(BasePlayer player, ShareType type, string friendId = "")
        {
            var playerId = player.UserIDString;
            var sharedBlueprints = GetSharedBlueprints(playerId, type, friendId);

            if (sharedBlueprints.Count == 0)
            {
                SendMessage("NoSharedBlueprints", player, true);
                return;
            }

            var workbenchTiers = new Dictionary<int, List<string>>();
            var availableTiers = sharedBlueprints.Select(bp => GetWorkbenchTierForBlueprint(bp)).Distinct();

            foreach (var tier in availableTiers)
            {
                workbenchTiers[tier] = Pool.Get<List<string>>();
            }

            SortBlueprintsByWorkbenchLevel(sharedBlueprints, ref workbenchTiers);

            var sb = new StringBuilder();

            foreach (var kvp in workbenchTiers.OrderBy(x => x.Key))
            {
                var tier = kvp.Key;
                var blueprints = kvp.Value;

                if (blueprints.Count > 0)
                {
                    sb.Append(GetLangValue($"ShowWorkBench{tier}Blueprints", playerId, string.Join(", ", blueprints)));
                    sb.AppendLine();
                }
            }

            player.ChatMessage(sb.ToString());

            SendMessage("ShowTotalBlueprintsShared", player, true, workbenchTiers.Values.Sum(tier => tier.Count));

            for (var i = 0; i < workbenchTiers.Count; i++)
            {
                var tierExists = workbenchTiers.TryGetValue(i, out var workbenchTier);

                if (tierExists)
                {
                    Pool.FreeUnmanaged(ref workbenchTier);
                }
            }
        }

        private int GetWorkbenchTierForBlueprint(int itemId)
        {
            var item = ItemManager.FindItemDefinition(itemId);

            return item != null ? item.Blueprint.workbenchLevelRequired : 0;
        }

        #endregion

        #region Chat Commands

        [ChatCommand("bs")]
        private void ChatCommands(BasePlayer player, string command, string[] args)
        {
            var playerId = player.UserIDString;

            if (args.Length == 0)
            {
                SendMessage("Help", player, false);

                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    {
                        SendMessage("Help", player, false);

                        break;
                    }

                case "toggle":
                    {
                        ToggleCommand(player, playerId);

                        break;
                    }

                case "share":
                    {
                        ShareCommand(player, playerId, args);

                        break;
                    }

                case "show":
                    {
                        ShowCommand(player, playerId, args);

                        break;
                    }

                default:
                    {
                        SendMessage("ArgumentsError", player, true);

                        break;
                    }
            }
        }

        private void ToggleCommand(BasePlayer player, string playerId)
        {
            if (!permission.UserHasPermission(playerId, togglePermission))
            {
                SendMessage("NoPermission", player, true);

                return;
            }

            EnsurePlayerDataExists(playerId);

            SendMessage(SharingEnabled(playerId) ? "ToggleOff" : "ToggleOn", player, true);

            storedData.Players[playerId].SharingEnabled = !storedData.Players[playerId].SharingEnabled;

            SaveData();
        }

        private void ShareCommand(BasePlayer player, string playerId, string[] args)
        {
            if (!permission.UserHasPermission(playerId, sharePermission))
            {
                SendMessage("NoPermission", player, true);

                return;
            }

            if (args.Length != 2)
            {
                SendMessage("NoTarget", player, true);

                return;
            }

            var target = RustCore.FindPlayerByName(args[1]);

            if (target == null)
            {
                SendMessage("PlayerNotFound", player, true);

                return;
            }

            if (target == player)
            {
                SendMessage("TargetEqualsPlayer", player, true);

                return;
            }

            ShareWithPlayer(player, target);
        }

        private void ShowCommand(BasePlayer player, string playerId, string[] args)
        {
            if (!config.LoseBlueprintsOnLeave)
            {
                SendMessage("LoseBlueprintsDisabled", player, true);

                return;
            }

            if (!permission.UserHasPermission(playerId, showPermission))
            {
                SendMessage("NoPermission", player, true);

                return;
            }

            if (args.Length < 2)
            {
                SendMessage("ShowMissingArgument", player, true);

                return;
            }

            switch (args[1])
            {
                case "clan":
                    {
                        DisplayLearntBlueprints(player, ShareType.Clans);

                        break;
                    }

                case "team":
                    {
                        DisplayLearntBlueprints(player, ShareType.Teams);

                        break;
                    }

                case "friend":
                    {
                        if (args.Length != 3)
                        {
                            SendMessage("ShowFriendArgumentMissing", player, true);

                            return;
                        }

                        var friend = RustCore.FindPlayerByName(args[2]);

                        if (friend == null)
                        {
                            SendMessage("PlayerNotFound", player, true);

                            return;
                        }

                        if (friend == player)
                        {
                            SendMessage("FriendEqualsPlayer", player, true);

                            return;
                        }

                        if (!AreFriends(friend.userID, player.userID))
                        {
                            SendMessage("NotFriends", player, true);

                            return;
                        }

                        DisplayLearntBlueprints(player, ShareType.Friends, friend.UserIDString);

                        break;
                    }

                default:
                    {
                        SendMessage("ShowMissingArgument", player, true);

                        return;
                    }
            }
        }

        #endregion

        #region Configuration File

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Teams Sharing Enabled")]
            public bool TeamsEnabled = true;

            [JsonProperty("Clans Sharing Enabled")]
            public bool ClansEnabled = true;

            [JsonProperty("Friends Sharing Enabled")]
            public bool FriendsEnabled = true;

            [JsonProperty("Share Blueprint Items")]
            public bool PhysicalSharingEnabled = true;

            [JsonProperty("Share Tech Tree Blueprints")]
            public bool TechTreeSharingEnabled = true;

            [JsonProperty("Share Blueprints on Join")]
            public bool ShareBlueprintsOnJoin;

            [JsonProperty("Share Blueprints with New Member or Friend")]
            public bool ShareBlueprintsWithNewMember;

            [JsonProperty("Lose Blueprints on Leave")]
            public bool LoseBlueprintsOnLeave;

            [JsonProperty("Clear Data File on Wipe")]
            public bool ClearDataOnWipe = true;

            [JsonProperty("Receive Messages Enabled")]
            public bool ReceiveMessagesEnabled = true;

            [JsonProperty("Share Messages Enabled")]
            public bool ShareMessagesEnabled = true;

            [JsonProperty("Items Blocked from Sharing")]
            public List<string> BlockedItems = new List<string>();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new configuration file");

            config = new Configuration();
        }

        protected override void SaveConfig()
        {
            PrintWarning("Configuration file has been saved");

            Config.WriteObject(config, true);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                {
                    throw new Exception();
                }
            }
            catch
            {
                PrintError($"An error occurred while parsing the configuration file {Name}.json; Resetting configuration to default values.");
                LoadDefaultConfig();
            }
        }

        #endregion

        #region Data File

        private class StoredData
        {
            public Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            public bool SharingEnabled;

            public ShareData LearntBlueprints;
        }

        private class ShareData
        {
            public List<int> Team = new List<int>();
            public List<int> Clan = new List<int>();
            public Dictionary<string, List<int>> Friends = new Dictionary<string, List<int>>();
        }

        private void AddClanShare(string playerId, int blueprint)
        {
            EnsurePlayerDataExists(playerId);

            if (storedData.Players[playerId].LearntBlueprints.Clan.Contains(blueprint)) return;

            storedData.Players[playerId].LearntBlueprints.Clan.Add(blueprint);
        }

        private void AddTeamShare(string playerId, int blueprint)
        {
            EnsurePlayerDataExists(playerId);

            if (storedData.Players[playerId].LearntBlueprints.Team.Contains(blueprint)) return;

            storedData.Players[playerId].LearntBlueprints.Team.Add(blueprint);
        }

        private void AddFriendShare(string playerId, string friendId, int blueprint)
        {
            EnsurePlayerDataExists(playerId);

            if (!storedData.Players[playerId].LearntBlueprints.Friends.ContainsKey(friendId))
            {
                storedData.Players[playerId].LearntBlueprints.Friends.Add(friendId, new List<int>());
            }

            if (storedData.Players[playerId].LearntBlueprints.Friends[friendId].Contains(blueprint)) return;

            storedData.Players[playerId].LearntBlueprints.Friends[friendId].Add(blueprint);
        }

        private void RemoveClanShare(string playerId)
        {
            EnsurePlayerDataExists(playerId);

            storedData.Players[playerId].LearntBlueprints.Clan.Clear();
        }

        private void RemoveTeamShare(string playerId)
        {
            EnsurePlayerDataExists(playerId);

            storedData.Players[playerId].LearntBlueprints.Team.Clear();
        }

        private void RemoveFriendShare(string playerId, string friendId)
        {
            EnsurePlayerDataExists(playerId);

            if (!storedData.Players[playerId].LearntBlueprints.Friends.ContainsKey(friendId)) return;

            storedData.Players[playerId].LearntBlueprints.Friends.Remove(friendId);
        }

        private List<int> GetClanBlueprints(string playerId)
        {
            EnsurePlayerDataExists(playerId);

            return storedData.Players[playerId].LearntBlueprints.Clan.ToList();
        }

        private List<int> GetTeamBlueprints(string playerId)
        {
            EnsurePlayerDataExists(playerId);

            return storedData.Players[playerId].LearntBlueprints.Team.ToList();
        }

        private List<int> GetFriendBlueprints(string playerId, string friendId)
        {
            EnsurePlayerDataExists(playerId);

            return storedData.Players[playerId].LearntBlueprints.Friends[friendId].ToList();
        }

        private void CreateData()
        {
            storedData = new StoredData();

            SaveData();
        }

        private void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            else
            {
                CreateData();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void EnsureDataFileExists()
        {
            if (storedData == null)
            {
                CreateData();
            }
        }

        private void EnsurePlayerDataExists(string playerId)
        {
            EnsureDataFileExists();

            if (!storedData.Players.ContainsKey(playerId))
            {
                CreatePlayerData(playerId);
            }
        }

        private void CreatePlayerData(string playerId)
        {
            storedData.Players.Add(playerId, new PlayerData
            {
                SharingEnabled = true,
                LearntBlueprints = new ShareData()
            });

            SaveData();
        }

        #endregion

        #region Localization File

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Prefix"] = "<color=#D85540>[Blueprint Share] </color>",
                ["ArgumentsError"] = "Error, incorrect arguments. Try /bs help.",
                ["Help"] = "<color=#D85540>Blueprint Share Help:</color>\n\n<color=#D85540>/bs toggle</color> - Toggles the sharing of blueprints.\n<color=#D85540>/bs share <player></color> - Shares your blueprints with other player.\n<color=#D85540>/bs show <type></color> - Displays blueprints that have been shared to you.",
                ["ToggleOn"] = "You have <color=#00ff00>enabled</color> blueprint sharing.",
                ["ToggleOff"] = "You have <color=#ff0000>disabled</color> blueprint sharing.",
                ["NoPermission"] = "You don't have permission to use this command!",
                ["CannotShare"] = "You cannot share blueprints with this player because they aren't a friend or in the same clan or team!",
                ["NoTarget"] = "You didn't specify a player to share with!",
                ["TargetEqualsPlayer"] = "You cannot share blueprints with yourself!",
                ["PlayerNotFound"] = "Could not find a player with that name!",
                ["PlayerSharedBlueprints"] = "You shared <color=#ffff00>{0}</color> blueprint(s) with <color=#ffff00>{1}</color>.",
                ["TargetLearntBlueprints"] = "<color=#ffff00>{0}</color> has shared <color=#ffff00>{1}</color> blueprint(s) with you.",
                ["NoBlueprintsToShare"] = "You don't have any new blueprints to share with <color=#ffff00>{0}</color>.",
                ["PlayerSharedBlueprint"] = "You have learned the <color=#ffff00>{0}</color> blueprint and have shared it with <color=#ffff00>{1}</color> player(s)!",
                ["TargetLearntBlueprint"] = "<color=#ffff00>{0}</color> has shared the <color=#ffff00>{1}</color> blueprint with you!",
                ["BlueprintBlocked"] = "The server administrator has blocked the <color=#ffff00>{0}</color> blueprint from being shared but you will still learn the blueprint.",
                ["TargetSharingDisabled"] = "Unable to share blueprints with <color=#ffff00>{0}</color> because they have disabled their sharing.",
                ["BlueprintsRemoved"] = "You have lost access to <color=#ffff00>{0}</color> blueprint(s).",
                ["ShowMissingArgument"] = "You didn't specify which learnt blueprints you want to view! Please choose from the following options: clan, team or friend",
                ["ShowFriendArgumentMissing"] = "You didn't specify a friend!",
                ["FriendEqualsPlayer"] = "You cannot be friends with yourself!",
                ["NotFriends"] = "You are not friends with this player!",
                ["NoSharedBlueprints"] = "No blueprints have been shared with you!",
                ["ShowWorkBench0Blueprints"] = "{0}",
                ["ShowWorkBench1Blueprints"] = "{0}",
                ["ShowWorkBench2Blueprints"] = "<color=#ADD8E6>{0}</color>",
                ["ShowWorkBench3Blueprints"] = "<color=#90EE90>{0}</color>",
                ["ShowTotalBlueprintsShared"] = "In total you have been shared <color=#ffff00>{0}</color> blueprint(s).",
                ["LoseBlueprintsDisabled"] = "This feature has been disabled by the server administrator."
            }, this);
        }

        private string GetLangValue(string key, string id = null, params object[] args)
        {
            var msg = lang.GetMessage(key, this, id);

            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void SendMessage(string key, BasePlayer player, bool prefix, params object[] args)
        {
            if (player == null || string.IsNullOrEmpty(key)) return;

            var sb = new StringBuilder(GetLangValue(key, player.UserIDString, args));

            if (prefix)
            {
                sb.Insert(0, GetLangValue("Prefix", player.UserIDString, args));
            }

            player.ChatMessage(sb.ToString());
        }

        #endregion

        #region API

        private bool SharingEnabled(string playerId)
        {
            EnsurePlayerDataExists(playerId);

            return storedData.Players[playerId].SharingEnabled;
        }

        #endregion
    }
}

// --- End of file: BlueprintShare.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-manager ---
// --- Original File Path: Z/ZoneManager/ZoneManager.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace Oxide.Plugins
{
    [Info("Zone Manager", "k1lly0u", "3.1.7")]
    [Description("An advanced management system for creating in-game zones")]
    public class ZoneManager : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Backpacks, PopupNotifications, Spawns;

        private StoredData storedData;

        private DynamicConfigFile data;


        private readonly Hash<string, Zone> zones = new Hash<string, Zone>();

        private static readonly Hash<ulong, EntityZones> zonedPlayers = new Hash<ulong, EntityZones>();

        private static readonly Hash<NetworkableId, EntityZones> zonedEntities = new Hash<NetworkableId, EntityZones>();

        private readonly Dictionary<ulong, string> lastPlayerZone = new Dictionary<ulong, string>();


        private readonly ZoneFlags globalFlags = new ZoneFlags();

        private readonly ZoneFlags adminBypass = new ZoneFlags();


        private static readonly ZoneFlags tempFlags = new ZoneFlags();

        private static readonly StringBuilder sb = new StringBuilder();


        private bool zonesInitialized = false;


        private static ZoneManager Instance { get; set; }

        private const string PERMISSION_ZONE = "zonemanager.zone";

        private const string PERMISSION_IGNORE_FLAG = "zonemanager.ignoreflag.";

        private const int PLAYER_MASK = 131072;

        private const int TARGET_LAYERS = ~(1 << 10 | 1 << 18 | 1 << 28 | 1 << 29);
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            Instance = this;

            adminBypass.SetFlags(ZoneFlags.NoBuild, ZoneFlags.NoDeploy, ZoneFlags.NoCup, ZoneFlags.NoUpgrade, ZoneFlags.NoChat, ZoneFlags.NoVoice, ZoneFlags.KillSleepers, ZoneFlags.EjectSleepers, ZoneFlags.NoSignUpdates);

            lang.RegisterMessages(Messages, this);
            
            permission.RegisterPermission(PERMISSION_ZONE, this);

            foreach (string flag in ZoneFlags.NameToIndex.Keys)
                permission.RegisterPermission(PERMISSION_IGNORE_FLAG + flag.ToLower(), this);

            LoadData();
        }

        private void OnServerInitialized() => InitializeZones();

        private void OnTerrainInitialized() => InitializeZones();

        private void OnPlayerConnected(BasePlayer player) => updateBehaviour.QueueUpdate(player);

        private void OnEntityKill(BaseEntity baseEntity)
        {
            if (!baseEntity || !baseEntity.IsValid() || baseEntity.IsDestroyed)
                return;

            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZones)) 
                return;
            
            for (int i = entityZones.Zones.Count - 1; i >= 0; i--)
            {
                Zone zone = entityZones.Zones.ElementAt(i);
                if (zone)
                    zone.OnEntityExitZone(baseEntity, false, true);
            }

            zonedEntities.Remove(baseEntity.net.ID);
        }

        private void Unload()
        {
            DestroyUpdateBehaviour();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, ZMUI);

            foreach (KeyValuePair<string, Zone> kvp in zones)
                UnityEngine.Object.DestroyImmediate(kvp.Value.gameObject);

            zones.Clear();
            zonedPlayers.Clear();
            zonedEntities.Clear();
            
            Instance = null;
            Configuration = null;
        }
        #endregion

        #region UpdateQueue
        private UpdateBehaviour m_UpdateBehaviour;
        
        private UpdateBehaviour updateBehaviour
        {
            get
            {
                if (m_UpdateBehaviour) 
                    return m_UpdateBehaviour;
                
                m_UpdateBehaviour = new GameObject("ZoneManager.UpdateBehaviour").AddComponent<UpdateBehaviour>();

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    m_UpdateBehaviour.QueueUpdate(player);

                return m_UpdateBehaviour;
            }
        }

        private void DestroyUpdateBehaviour()
        {
            if (updateBehaviour)
                UnityEngine.Object.Destroy(updateBehaviour.gameObject);
        }

        // Queue and check players for new zones and that they are still in old zones. Previously any plugin that put a player to sleep and teleports them out of a zone
        // without calling the OnPlayerSleep hook would bypass a player zone update which would result in players being registered in zones they were no longer in.
        // Options are to either continually check and update players, or have every plugin that teleports players call the hook...
        private class UpdateBehaviour : MonoBehaviour
        {
            private readonly System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();

            private readonly Queue<BasePlayer> playerUpdateQueue = new Queue<BasePlayer>();

            private const float MAX_MS = 0.25f;

            private void OnDestroy()
            {
                playerUpdateQueue.Clear();
            }

            public void QueueUpdate(BasePlayer player)
            {
                if (!playerUpdateQueue.Contains(player))
                    playerUpdateQueue.Enqueue(player);
            }

            public void Reset() => playerUpdateQueue.Clear();

            private void Update()
            {
                if (Time.frameCount % 10 != 0)
                    return;

                sw.Reset();
                sw.Start();

                while (playerUpdateQueue.Count > 0)
                {
                    if (sw.Elapsed.TotalMilliseconds >= MAX_MS)
                    {
                        sw.Stop();
                        return;
                    }

                    BasePlayer player = playerUpdateQueue.Dequeue();
                    if (!player || !player.IsConnected)
                        continue;

                    Instance?.UpdatePlayerZones(player);

                    InvokeHandler.Invoke(this, () => QueueUpdate(player), 2f);
                }
            }
        }
        #endregion

        #region Flag Hooks
        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            if (!planner || !gameObject)
                return;

            BasePlayer player = planner.GetOwnerPlayer();
            if (!player)
                return;

            BaseEntity entity = gameObject.ToBaseEntity();
            if (!entity)
                return;

            if (entity is BuildingBlock block)
            {
                if (!HasPlayerFlag(player, ZoneFlags.NoBuild)) 
                    return;
                
                List<ItemAmount> list = block.BuildCost();

                block.Invoke(() =>
                {
                    for (int i = 0; i < list?.Count; i++)
                    {
                        ItemAmount itemAmount = list[i];
                        player.GiveItem(ItemManager.Create(itemAmount.itemDef, Mathf.Clamp(Mathf.RoundToInt(itemAmount.amount), 1, int.MaxValue)));
                    }

                    if (entity && !entity.IsDestroyed)
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                }, 0.1f);

                SendMessage(player, Message("noBuild", player.UserIDString));
            }
            else if (entity is SimpleBuildingBlock)
            {
                if (!HasPlayerFlag(player, ZoneFlags.NoBuild)) 
                    return;
                
                KillEntityAndReturnItem(player, entity, planner.GetItem());
                SendMessage(player, Message("noBuild", player.UserIDString));
            }
            else
            {
                if (entity is BuildingPrivlidge)
                {
                    if (!HasPlayerFlag(player, ZoneFlags.NoCup)) 
                        return;
                    
                    KillEntityAndReturnItem(player, entity, planner.GetItem());
                    SendMessage(player, Message("noCup", player.UserIDString));
                }
                else
                {
                    if (!HasPlayerFlag(player, ZoneFlags.NoDeploy)) 
                        return;
                    
                    KillEntityAndReturnItem(player, entity, planner.GetItem());                       
                    SendMessage(player, Message("noDeploy", player.UserIDString));
                }
            }
        }

        private object OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoUpgrade))
            {
                SendMessage(player, Message("noUpgrade", player.UserIDString));
                return true;
            }
            return null;
        }

        private void OnItemDeployed(Deployer deployer, ItemModDeployable itemModDeployable, BaseEntity deployedEntity) // DoDeploy_Regular
        {
            BasePlayer player = deployer.GetOwnerPlayer();
            if (!player)
                return;

            if (HasPlayerFlag(player, ZoneFlags.NoDeploy))
            {
                KillEntityAndReturnItem(player, deployedEntity, deployer.GetItem());
                SendMessage(player, Message("noDeploy", player.UserIDString));
            }
        }
                
        private void OnItemDeployed(Deployer deployer, BaseEntity parentEntity, BaseEntity deployedEntity) // DoDeploy_Slot
        {
            BasePlayer player = deployer.GetOwnerPlayer();
            if (!player)
                return;

            if (HasPlayerFlag(player, ZoneFlags.NoDeploy))
            {
                KillEntityAndReturnItem(player, deployedEntity, deployer.GetItem());
                SendMessage(player, Message("noDeploy", player.UserIDString));
            }
        }

        private void KillEntityAndReturnItem(BasePlayer player, BaseEntity entity, Item item)
        {
            ItemDefinition itemDefinition = item?.info;
            //int amount = item.amount;
            ulong skin = item?.skin ?? 0UL;

            entity.Invoke(() =>
            {
                if (entity && !entity.IsDestroyed)
                    entity.Kill(BaseNetworkable.DestroyMode.Gib);

                if (itemDefinition != null)
                    player.GiveItem(ItemManager.Create(itemDefinition, 1, skin));

            }, 0.1f);
        }

        private void OnItemUse(Item item, int amount)
        {
            BaseEntity entity = item?.parent?.entityOwner;
            if (!entity)
                return;

            if (entity is FlameTurret or AutoTurret or GunTrap)
            {
                if (HasEntityFlag(entity, ZoneFlags.InfiniteTrapAmmo))
                    item.amount += amount;
                return;
            }

            if (entity is not SearchLight) 
                return;
            
            if (HasEntityFlag(entity, ZoneFlags.AlwaysLights))
            {
                item.amount += amount;
                return;
            }

            if (!HasEntityFlag(entity, ZoneFlags.AutoLights)) 
                return;
            
            if (TOD_Sky.Instance.Cycle.Hour > Configuration.AutoLights.OnTime || TOD_Sky.Instance.Cycle.Hour < Configuration.AutoLights.OffTime)
                item.amount += amount;
        }
               
        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (!player)
                return null;

            if (!HasPlayerFlag(player, ZoneFlags.NoChat)) 
                return null;
            
            SendMessage(player, Message("noChat", player.UserIDString));
            return true;
        }

        private object OnBetterChat(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string message)
        {
            BasePlayer player = iPlayer.Object as BasePlayer;
            return OnPlayerChat(player, message, ConVar.Chat.ChatChannel.Global);
        }

        private object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoVoice))
            {
                SendMessage(player, Message("noVoice", player.UserIDString));
                return true;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player || string.IsNullOrEmpty(arg.cmd?.Name))
                return null;

            if (arg.cmd.Name == "kill" && HasPlayerFlag(player, ZoneFlags.NoSuicide))
            {
                SendMessage(player, Message("noSuicide", player.UserIDString));
                return true;
            }
            return null;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player)
                return;

            if (HasPlayerFlag(player, ZoneFlags.KillSleepers))
            {
                player.Die();
                return;
            }

            if (HasPlayerFlag(player, ZoneFlags.EjectSleepers))
            {
                if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones) || entityZones.Count == 0)
                    return;

                for (int i = 0; i < entityZones.Count; i++)
                {
                    Zone zone = entityZones.Zones.ElementAt(i);
                    if (!zone)
                        continue;

                    if (HasFlag(zone, ZoneFlags.EjectSleepers))
                    {
                        EjectPlayer(player, zone);
                        return;
                    }
                }
            }
        }
        
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (!entity || GetEntityComponent<ResourceDispenser>(entity))
                return null;

            BasePlayer attacker = hitinfo.InitiatorPlayer;
            BasePlayer victim = entity as BasePlayer;

            if (victim)
            {                
                if (hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Fall)
                {
                    if (HasPlayerFlag(victim, ZoneFlags.NoFallDamage))
                        return true;
                }

                if (victim.IsSleeping() && HasPlayerFlag(victim, ZoneFlags.SleepGod))
                    return true;

                if (attacker)
                {
                    if (IsNpc(victim))
                        return null;

                    if (HasPlayerFlag(victim, ZoneFlags.PvpGod))
                    {
                        if (attacker == victim && hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                        {
                            if (HasPlayerFlag(victim, ZoneFlags.NoSuicide))
                                return true;
                            return null;
                        }
                        if (IsNpc(attacker) && Configuration.NPCHurtPvpGod)
                            return null;

                        return true;
                    }
                    
                    if (HasPlayerFlag(attacker, ZoneFlags.PvpGod) && !IsNpc(attacker))                    
                        return true;                    
                }
                
                else if (HasPlayerFlag(victim, ZoneFlags.PveGod) && !IsNpc(victim))
                    return true;
                
                else if (hitinfo.Initiator is FireBall && HasPlayerFlag(victim, ZoneFlags.PvpGod))
                    return true;
                
                return null;
            }

            BaseNpc baseNpc = entity as BaseNpc;
            if (baseNpc)
            {
                if (HasEntityFlag(baseNpc, ZoneFlags.NoPve))
                {
                    if (attacker && CanBypass(attacker, ZoneFlags.NoPve))
                        return null;
                    return true;
                }
                return null;
            }

            if (entity is BuildingBlock or SimpleBuildingBlock)
            {
                if (HasEntityFlag(entity, ZoneFlags.NoBuildingDamage))
                {
                    if (attacker)
                    {
                        if (CanBypass(attacker, ZoneFlags.NoBuildingDamage))
                            return null;

                        if (HasPlayerFlag(attacker, ZoneFlags.NoBuildingDamage))
                            return true;
                    }
                    
                    if (hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Decay && Configuration.DecayDamageUndestr)
                        return null;
                    
                    return true;
                }
            }

            if (entity is not LootContainer && entity is not PatrolHelicopter)
            {
                if (HasEntityFlag(entity, ZoneFlags.UnDestr))
                {
                    if (attacker)
                    {
                        if (CanBypass(attacker, ZoneFlags.UnDestr))
                            return null;

                        if (HasPlayerFlag(attacker, ZoneFlags.UnDestr))
                            return true;
                    }

                    if (hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Decay && Configuration.DecayDamageUndestr)
                        return null;

                    return true;
                }
            }

            return null;
        }

        private void OnEntitySpawned(BaseEntity baseEntity)
            => NextTick(() => CanSpawn(baseEntity));

        private void CanSpawn(BaseEntity baseEntity)
        {
            if (!baseEntity.IsValid() || baseEntity.IsDestroyed)
                return;

            if (Interface.CallHook("CanSpawnInZone", baseEntity) != null)
                return;

            if (baseEntity is BaseCorpse corpse)
            {
                if (HasEntityFlag(corpse, ZoneFlags.NoCorpse) && !CanBypass(corpse.OwnerID, ZoneFlags.NoCorpse))
                    corpse.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            if (baseEntity is LootContainer or JunkPile)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoLootSpawns))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            else if (baseEntity is BaseNpc or NPCPlayer)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoNPCSpawns))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            else if (baseEntity is DroppedItem or WorldItem)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoDrop))
                {
                    ((WorldItem)baseEntity).item.Remove(0f);
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
                }
            }
            else if (baseEntity is DroppedItemContainer)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoDrop))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
        }

        private object CanBeWounded(BasePlayer player, HitInfo hitinfo) => HasPlayerFlag(player, ZoneFlags.NoWounded) ? (object)false : null;

        private object CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoSignUpdates))
            {
                SendMessage(player, Message("noSignUpdates", player.UserIDString));
                return false;
            }
            return null;
        }

        private object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoOvenToggle))
            {
                SendMessage(player, Message("noOvenToggle", player.UserIDString));
                return true;
            }
            return null;
        }

        private object CanUseVending(BasePlayer player, VendingMachine machine)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoVending))
            {
                SendMessage(player, Message("noVending", player.UserIDString));
                return false;
            }
            return null;
        }

        private object CanHideStash(BasePlayer player, StashContainer stash)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoStash))
            {
                SendMessage(player, Message("noStash", player.UserIDString));
                return false;
            }
            return null;
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            BasePlayer player = itemCrafter.GetComponent<BasePlayer>();
            if (player && HasPlayerFlag(player, ZoneFlags.NoCraft))
            {
                SendMessage(player, Message("noCraft", player.UserIDString));
                return false;
            }
            return null;
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoDoorAccess))
            {
                SendMessage(player, Message("noDoor", player.UserIDString));
                door.CloseRequest();
            }
        }

        private object OnSprayCreate(SprayCan sprayCan, Vector3 position, Quaternion rotation)
        {
            if (!sprayCan)
                return null;

            BasePlayer player = sprayCan.GetOwnerPlayer();
            if (!player)
                return null;

            if (HasPlayerFlag(player, ZoneFlags.NoSprays))
            {
                SendMessage(player, Message("nosprays", player.UserIDString));
                return false;
            }

            return null;
        }

        #region Looting Hooks
        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => OnLootPlayerInternal(looter, target);

        private void OnLootPlayer(BasePlayer looter, BasePlayer target) => OnLootPlayerInternal(looter, target);

        private object OnLootPlayerInternal(BasePlayer looter, BasePlayer target)
        {
            if (HasPlayerFlag(looter, ZoneFlags.NoPlayerLoot) || (target != null && HasPlayerFlag(target, ZoneFlags.NoPlayerLoot)))
            {
                if (looter == target && Backpacks != null)
                {
                    object hookResult = Backpacks.Call("CanLootPlayer", target, looter);
                    if (hookResult is bool result && result)
                        return true;
                }

                SendMessage(looter, Message("noLoot", looter.UserIDString));
                NextTick(looter.EndLooting);
                return false;
            }
            return null;
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity is LootableCorpse corpse)
                OnLootCorpse(corpse, player);
            if (entity is DroppedItemContainer container)
                OnLootContainer(container, player);
            if (entity is StorageContainer)
                OnLootInternal(player, ZoneFlags.NoBoxLoot);
        }

        private object CanLootEntity(BasePlayer player, LootableCorpse corpse)
        {
            if (corpse is NPCPlayerCorpse)
            {
                if (!HasPlayerFlag(player, ZoneFlags.NoNPCLoot)) 
                    return null;
                
                SendMessage(player, Message("noLoot", player.UserIDString));
                return false;
            }

            if (corpse.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf))
                return null;
            
            return CanLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private void OnLootCorpse(LootableCorpse corpse, BasePlayer player)
        {
            if (corpse is NPCPlayerCorpse)
            {
                if (!HasPlayerFlag(player, ZoneFlags.NoNPCLoot)) 
                    return;
                
                SendMessage(player, Message("noLoot", player.UserIDString));
                NextTick(player.EndLooting);
                return;
            }

            if (corpse.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf))
                return;

            OnLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private void OnLootContainer(DroppedItemContainer container, BasePlayer player)
        {
            if (container.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf))
                return;

            OnLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            if (container.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf))
                return null;

            return CanLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container) => CanLootInternal(player, ZoneFlags.NoBoxLoot);

        private object CanLootInternal(BasePlayer player, int flag)
        {
            if (!player || !HasPlayerFlag(player, flag)) 
                return null;
            
            SendMessage(player, Message("noLoot", player.UserIDString));
            return false;
        }

        private void OnLootInternal(BasePlayer player, int flag)
        {
            if (!player || !HasPlayerFlag(player, flag)) 
                return;
            
            SendMessage(player, Message("noLoot", player.UserIDString));
            NextTick(player.EndLooting);
        }
        #endregion

        #region Pickup Hooks
        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity) => CanPickupInternal(player, ZoneFlags.NoEntityPickup);

        private object CanPickupLock(BasePlayer player, BaseLock baseLock) => CanPickupInternal(player, ZoneFlags.NoEntityPickup);

        private object OnItemPickup(Item item, BasePlayer player) => CanPickupInternal(player, ZoneFlags.NoPickup);

        private object CanPickupInternal(BasePlayer player, int flag)
        {
            if (!HasPlayerFlag(player, flag)) 
                return null;
            
            SendMessage(player, Message("noPickup", player.UserIDString));
            return false;
        }
        #endregion

        #region Gather Hooks        
        private object CanLootEntity(ResourceContainer container, BasePlayer player) => OnGatherInternal(player);

        private object OnCollectiblePickup(Item item, BasePlayer player) => OnGatherInternal(player);

        private object OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player) => OnGatherInternal(player);

        private object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item) => OnGatherInternal(player);

        private object OnGatherInternal(BasePlayer player)
        {
            if (!player || !HasPlayerFlag(player, ZoneFlags.NoGather)) 
                return null;
            
            SendMessage(player, Message("noGather", player.UserIDString));
            return true;

        }
        #endregion

        #region Targeting Hooks
        private object OnTurretTarget(AutoTurret turret, BasePlayer player) => OnTargetPlayerInternal(player, ZoneFlags.NoTurretTargeting);

        private object CanBradleyApcTarget(BradleyAPC apc, BasePlayer player)
        {
            if (player && HasPlayerFlag(player, ZoneFlags.NoAPCTargeting))
                return false;
            return null;
        }

        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            if (!player || !HasPlayerFlag(player, ZoneFlags.NoHeliTargeting)) 
                return null;
            
            heli.interestZoneOrigin = heli.GetRandomPatrolDestination();
            return false;
        }

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            if (player && HasPlayerFlag(player, ZoneFlags.NoHeliTargeting))
                return false;
            return null;
        }

        private object OnHelicopterTarget(HelicopterTurret turret, BasePlayer player) => OnTargetPlayerInternal(player, ZoneFlags.NoHeliTargeting);

        private object OnNpcTarget(BaseCombatEntity entity, BasePlayer player) => OnTargetPlayerInternal(player, ZoneFlags.NoNPCTargeting);

        private object OnTargetPlayerInternal(BasePlayer player, int flag)
        {
            if (player && HasPlayerFlag(player, flag))
                return true;
            return null;
        }
        #endregion

        #region Mounting Hooks
        private object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            if (!player || !entity)
                return null;

            if (!entity.VehicleParent())
                return null;

            if (!HasPlayerFlag(player, ZoneFlags.NoVehicleMounting)) 
                return null;
            
            SendMessage(player, Message("novehiclemounting", player.UserIDString));
            return false;
        }

        private object CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            if (!player || !entity)
                return null;

            if (!entity.VehicleParent())
                return null;

            if (!HasPlayerFlag(player, ZoneFlags.NoVehicleDismounting)) 
                return null;
            
            SendMessage(player, Message("novehicledismounting", player.UserIDString));
            return false;

        }
        #endregion

        #region Additional KillSleeper Checks
        private void OnPlayerSleep(BasePlayer player)
        {
            if (!player)
                return;

            //player.Invoke(()=> UpdatePlayerZones(player), 1f); // Manually update the zones a player is in. Sleeping players don't trigger OnTriggerEnter or OnTriggerExit            

            timer.In(2f, () =>
            {
                if (!player || !player.IsSleeping())
                    return;

                if (player.IsConnected) 
                    return;
                
                if (HasPlayerFlag(player, ZoneFlags.KillSleepers))
                {
                    player.Invoke(() => KillSleepingPlayer(player), 3f);
                    return;
                }

                if (HasPlayerFlag(player, ZoneFlags.EjectSleepers))
                {
                    player.Invoke(() =>
                    {
                        if (!player || !player.IsSleeping())
                            return;

                        if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones) || entityZones.Count == 0)
                            return;

                        for (int i = 0; i < entityZones.Count; i++)
                        {
                            Zone zone = entityZones.Zones.ElementAt(i);
                            if (!zone)
                                return;

                            if (HasFlag(zone, ZoneFlags.EjectSleepers))
                            {
                                EjectPlayer(player, zone);
                            }
                        }
                    }, 3f);
                }
            });
        }

        private void OnPlayerSleepEnd(BasePlayer player) => updateBehaviour.QueueUpdate(player);

        private void KillSleepingPlayer(BasePlayer player)
        {
            if (!player || !player.IsSleeping())
                return;

            if (!HasPlayerFlag(player, ZoneFlags.KillSleepers)) 
                return;
            
            if (player.IsConnected)
                OnPlayerSleep(player);
            else player.Die();
        }

        private void UpdatePlayerZones(BasePlayer player)
        {
            if (!player)
                return;

            if (zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones))
            {
                for (int i = entityZones.Count - 1; i >= 0; i--)
                {
                    Zone zone = entityZones.Zones.ElementAt(i);
                    if (!zone || !zone.definition.Enabled)
                        continue;

                    if (zone.definition.Size != Vector3.zero)
                    {
                        if (!IsInsideBounds(zone, player.transform.position))
                            OnPlayerExitZone(player, zone);
                    }
                    else
                    {
                        if (Vector3.Distance(player.transform.position, zone.transform.position) > zone.definition.Radius)
                            OnPlayerExitZone(player, zone);
                    }
                }
            }

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                if (entityZones != null && entityZones.Zones.Contains(zone))
                    continue;

                if (zone.definition.Size != Vector3.zero)
                {
                    if (IsInsideBounds(zone, player.transform.position))
                        OnPlayerEnterZone(player, zone);
                }
                else
                {
                    if (Vector3.Distance(player.transform.position, zone.transform.position) <= zone.definition.Radius)
                        OnPlayerEnterZone(player, zone);
                }
            }

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.SafeZone) && !player.InSafeZone())
                player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
        }

        private bool IsInsideBounds(Zone zone, Vector3 worldPos) => zone?.collider?.ClosestPoint(worldPos) == worldPos;
        #endregion
        
        private T GetEntityComponent<T>(BaseEntity entity) where T : EntityComponentBase
        {
            for (int i = 0; i < entity.Components.Count; i++)
            {
                EntityComponentBase component = entity.Components[i];
                if (component is T t)
                    return t;
            }

            return null;
        }
        #endregion

        #region Zone Functions
        private void InitializeZones()
        {
            if (zonesInitialized)
                return;

            foreach (Zone.Definition definition in storedData.definitions)
                CreateZone(definition);

            foreach (Zone zone in zones.Values)
                zone.FindZoneParent();

            zonesInitialized = true;

            UnsubscribeAll();
            UpdateHookSubscriptions();
        }

        private void CreateZone(Zone.Definition definition)
        {
            Zone zone = new GameObject().AddComponent<Zone>();
            zone.InitializeZone(definition);

            zones.Add(definition.Id, zone);
        }

        private static bool ReverseVelocity(BaseVehicle baseVehicle)
        {
            if (baseVehicle is BaseVehicleModule module)
                baseVehicle = module.Vehicle;

            if (!baseVehicle || !baseVehicle.IsVehicleRoot() || !baseVehicle.rigidBody) 
                return false;
            
            if (baseVehicle.AnyMounted() && baseVehicle is BaseHelicopter)
            {
                baseVehicle.rigidBody.velocity *= -1f;
                Vector3 euler = baseVehicle.transform.eulerAngles;
                baseVehicle.transform.rotation = Quaternion.Euler(euler.x, euler.y - 180f, euler.z);
            }
            else
            {
                Vector3 force = (baseVehicle.rigidBody.velocity.normalized * -1f) * baseVehicle.rigidBody.mass * 4f;
                baseVehicle.rigidBody.velocity = Vector3.zero;
                baseVehicle.rigidBody.AddForce(force, ForceMode.Impulse);
            }

            return true;
        }

        private void EjectPlayer(BasePlayer player, Zone zone)
        {
            if (zone.keepInList.Contains(player.userID) || zone.whitelist.Contains(player.userID))
                return;

            if (!string.IsNullOrEmpty(zone.definition.Permission))
            {
                if (HasPermission(player, zone.definition.Permission))
                    return;
            }

            if (player.isMounted && ReverseVelocity(player.GetMountedVehicle()))
            {
                SendMessage(player, Message("eject", player.UserIDString));
                return;
            }

            Vector3 position = Vector3.zero;
            if (Spawns && !string.IsNullOrEmpty(zone.definition.EjectSpawns))
            {
                object success = Spawns.Call("GetRandomSpawn", zone.definition.EjectSpawns);
                if (success is Vector3 vector3)
                    position = vector3;
            }

            if (position == Vector3.zero)
            {
                float distance = zone.definition.Size != Vector3.zero ? Mathf.Max(zone.definition.Size.x, zone.definition.Size.z) : zone.definition.Radius;

                position = zone.transform.position + (((player.transform.position.XZ3D() - zone.transform.position.XZ3D()).normalized) * (distance + 10f));

                if (Physics.Raycast(new Ray(new Vector3(position.x, position.y + 300, position.z), Vector3.down), out RaycastHit rayHit, 500, TARGET_LAYERS, QueryTriggerInteraction.Ignore))
                    position.y = rayHit.point.y;
                else position.y = TerrainMeta.HeightMap.GetHeight(position);
            }

            player.MovePosition(position);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
            player.SendNetworkUpdateImmediate();

            SendMessage(player, Message("eject", player.UserIDString));
        }

        private void AttractPlayer(BasePlayer player, Zone zone)
        {
            if (player.isMounted && ReverseVelocity(player.GetMountedVehicle()))
            {
                SendMessage(player, Message("attract", player.UserIDString));
                return;
            }

            float distance = zone.definition.Size != Vector3.zero ? Mathf.Max(zone.definition.Size.x, zone.definition.Size.z) : zone.definition.Radius;

            Vector3 position = zone.transform.position + (player.transform.position - zone.transform.position).normalized * (distance - 5f);
            position.y = TerrainMeta.HeightMap.GetHeight(position);

            player.MovePosition(position);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
            player.SendNetworkUpdateImmediate();

            SendMessage(player, Message("attract", player.UserIDString));
        }

        private void ShowZone(BasePlayer player, string zoneId, float time = 30)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (zone.definition.Size != Vector3.zero)
            {
                Vector3 center = zone.definition.Location;
                Quaternion rotation = Quaternion.Euler(zone.definition.Rotation);
                Vector3 size = zone.definition.Size / 2;
                Vector3 point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
                Vector3 point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
                Vector3 point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
                Vector3 point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
                Vector3 point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
                Vector3 point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
                Vector3 point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
                Vector3 point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point3);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point5);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point3);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point8);

                player.SendConsoleCommand("ddraw.line", time, Color.blue, point5, point6);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point5, point7);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point6, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point8, point6);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point8, point7);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point7, point3);
            }
            else player.SendConsoleCommand("ddraw.sphere", time, Color.blue, zone.definition.Location, zone.definition.Radius);
        }

        private Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation) => rotation * (point - pivot) + pivot;

        #endregion

        #region Component
        public class Zone : MonoBehaviour
        {
            public Definition definition;

            public ZoneFlags disabledFlags = new ZoneFlags();

            public Zone parent;


            public List<BasePlayer> players = Pool.Get<List<BasePlayer>>();

            public List<BaseEntity> entities = Pool.Get<List<BaseEntity>>();

            private List<IOEntity> ioEntities = Pool.Get<List<IOEntity>>();


            public List<ulong> keepInList = Pool.Get<List<ulong>>();

            public List<ulong> whitelist = Pool.Get<List<ulong>>();

            public Hash<ulong, EntityZones> entityZones = new Hash<ulong, EntityZones>();


            private Rigidbody rigidbody;

            public Collider collider;

            public Bounds colliderBounds;


            private ChildSphereTrigger<TriggerRadiation> radiation;

            private ChildSphereTrigger<TriggerComfort> comfort;

            private ChildSphereTrigger<TriggerTemperature> temperature;

            private ChildSphereTrigger<TriggerSafeZone> safeZone;


            private readonly Hash<BaseVehicle, float> lastReversedTimes = new Hash<BaseVehicle, float>();

            private int creationFrame;

            private bool isTogglingLights = false;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "ZoneManager";
                enabled = false;

                creationFrame = Time.frameCount;
            }

            private void OnDestroy()
            {
                EmptyZone();

                Pool.FreeUnmanaged(ref players);
                Pool.FreeUnmanaged(ref entities);
                Pool.FreeUnmanaged(ref ioEntities);
                Pool.FreeUnmanaged(ref keepInList);
                Pool.FreeUnmanaged(ref whitelist);
            }

            private void EmptyZone()
            {
                RemovePlayersFromTriggers();

                keepInList.Clear();

                ioEntities.Clear();

                for (int i = players.Count - 1; i >= 0; i--)
                    Instance?.OnPlayerExitZone(players[i], this);

                for (int i = entities.Count - 1; i >= 0; i--)
                    Instance?.OnEntityExitZone(entities[i], this);
            }

            #region Zone Initialization
            public void InitializeZone(Definition definition)
            {
                this.definition = definition;

                transform.position = definition.Location;

                transform.rotation = Quaternion.Euler(definition.Rotation);

                if (definition.Enabled)
                {
                    RegisterPermission();

                    InitializeCollider();

                    InitializeAutoLights();

                    InitializeRadiation();

                    InitializeSafeZone();

                    InitializeComfort();

                    InitializeTemperature();

                    RemovePlayersFromTriggers();

                    AddPlayersToTriggers();

                    OnZoneFlagsChanged();
                }
                else
                {
                    InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                    InvokeHandler.CancelInvoke(this, CheckLights);

                    if (isLightsOn)
                        ServerMgr.Instance.StartCoroutine(ToggleLights(false));

                    EmptyZone();

                    if (collider)
                        DestroyImmediate(collider);

                    if (rigidbody)
                        DestroyImmediate(rigidbody);
                }

                enabled = definition.Enabled;
            }

            public void FindZoneParent()
            {
                if (string.IsNullOrEmpty(definition.ParentID))
                    return;

                if (Instance == null)
                {
                    Debug.LogError($"[ZoneManager] Zone attempted to find parent zone, but plugin instance is null...");
                    return;
                }

                Instance.zones.TryGetValue(definition.ParentID, out parent);
            }

            public void Reset()
            {
                InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                InvokeHandler.CancelInvoke(this, CheckLights);

                if (isLightsOn)
                    ServerMgr.Instance.StartCoroutine(ToggleLights(false));

                EmptyZone();

                InitializeZone(definition);
            }

            public void OnZoneFlagsChanged()
            {
                if (HasFlag(ZoneFlags.PoweredSwitches))
                {
                    if (!InvokeHandler.IsInvoking(this, IOTick))
                        InvokeHandler.InvokeRandomized(this, IOTick, 0f, 1f, 0.1f);
                }
                else InvokeHandler.CancelInvoke(this, IOTick);
            }

            private void RegisterPermission()
            {
                if (Instance == null)
                {
                    Debug.LogError($"[ZoneManager] Zone attempted to register permission, but plugin instance is null...");
                    return;
                }

                if (!string.IsNullOrEmpty(definition.Permission) && !Instance.permission.PermissionExists(definition.Permission))
                    Instance.permission.RegisterPermission(definition.Permission, Instance);
            }

            private void InitializeCollider()
            {
                if (collider)
                    DestroyImmediate(collider);

                if (rigidbody)
                    DestroyImmediate(rigidbody);

                rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
                rigidbody.detectCollisions = true;
                rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>();
                BoxCollider boxCollider = gameObject.GetComponent<BoxCollider>();

                if (definition.Size != Vector3.zero)
                {
                    if (sphereCollider)
                        Destroy(sphereCollider);

                    if (!boxCollider)
                    {
                        boxCollider = gameObject.AddComponent<BoxCollider>();
                        boxCollider.isTrigger = true;
                    }
                    boxCollider.size = definition.Size;
                    colliderBounds = boxCollider.bounds;
                    collider = boxCollider;
                }
                else
                {
                    if (boxCollider)
                        Destroy(boxCollider);

                    if (!sphereCollider)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = definition.Radius;
                    colliderBounds = sphereCollider.bounds;
                    collider = sphereCollider;
                }
            }
            #endregion

            #region Triggers
            private void InitializeRadiation()
            {                
                if (definition.Radiation > 0)
                {
                    radiation ??= new ChildSphereTrigger<TriggerRadiation>(gameObject, "Radiation");
                    radiation.Trigger.RadiationAmountOverride = definition.Radiation;
                    radiation.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    radiation.Trigger.enabled = this.enabled;
                }
                else radiation?.Destroy();
            }

            private void InitializeComfort()
            {
                if (definition.Comfort > 0)
                {
                    comfort ??= new ChildSphereTrigger<TriggerComfort>(gameObject, "Comfort");
                    comfort.Trigger.baseComfort = definition.Comfort;
                    comfort.Trigger.triggerSize = comfort.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    comfort.Trigger.enabled = this.enabled;
                }
                else comfort?.Destroy();
            }

            private void InitializeTemperature()
            {
                if (definition.Temperature != 0)
                {
                    temperature ??= new ChildSphereTrigger<TriggerTemperature>(gameObject, "Temperature");
                    temperature.Trigger.Temperature = definition.Temperature;
                    temperature.Trigger.triggerSize = temperature.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    temperature.Trigger.enabled = this.enabled;
                }
                else temperature?.Destroy();
            }

            private void InitializeSafeZone()
            {
                if (definition.SafeZone)
                {
                    safeZone ??= new ChildSphereTrigger<TriggerSafeZone>(gameObject, "SafeZone");
                }
                else safeZone?.Destroy();
            }
                        
            private void AddToTrigger(TriggerBase triggerBase, BasePlayer player)
            {
                if (!triggerBase || !player)
                    return;

                triggerBase.entityContents ??= new HashSet<BaseEntity>();

                if (!triggerBase.entityContents.Add(player)) 
                    return;
                
                player.EnterTrigger(triggerBase);

                if (triggerBase is not TriggerSafeZone) 
                    return;
                
                if (player.IsItemHoldRestricted(player.inventory.containerBelt.FindItemByUID(player.svActiveItemID)))
                    player.UpdateActiveItem(default(ItemId));

                player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, true);
            }

            private void RemoveFromTrigger(TriggerBase triggerBase, BasePlayer player)
            {
                if (!triggerBase || !player)
                    return;

                if (triggerBase.entityContents == null || !triggerBase.entityContents.Contains(player)) 
                    return;
                
                triggerBase.entityContents.Remove(player);
                player.LeaveTrigger(triggerBase);

                if (triggerBase is not TriggerSafeZone) 
                    return;
                
                if (!player.InSafeZone())
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
            }

            private void AddPlayersToTriggers()
            {
                for (int i = 0; i < players.Count; i++)
                {
                    BasePlayer player = players[i];

                    if (safeZone != null)
                        AddToTrigger(safeZone.Trigger, player);

                    if (radiation != null)
                        AddToTrigger(radiation.Trigger, player);

                    if (comfort != null)
                        AddToTrigger(comfort.Trigger, player);

                    if (temperature != null)
                        AddToTrigger(temperature.Trigger, player);
                }
            }

            private void RemovePlayersFromTriggers()
            {
                for (int i = 0; i < players.Count; i++)                    
                {
                    BasePlayer player = players[i];

                    if (safeZone != null)
                        RemoveFromTrigger(safeZone.Trigger, player);

                    if (radiation != null)
                        RemoveFromTrigger(radiation.Trigger, player);

                    if (comfort != null)
                        RemoveFromTrigger(comfort.Trigger, player);

                    if (temperature != null)
                        RemoveFromTrigger(temperature.Trigger, player);
                }
            }

            private class ChildSphereTrigger<T> where T : TriggerBase
            {
                public GameObject Object { get; private set; }

                public SphereCollider Collider { get; private set; }

                public T Trigger { get; private set; }

                public ChildSphereTrigger(GameObject parent, string name)
                {
                    Object = parent.CreateChild();
                    Object.name = name;
                    Object.layer = (int)Layer.TransparentFX;

                    Collider = Object.AddComponent<SphereCollider>();
                    Collider.isTrigger = true;

                    Trigger = Object.AddComponent<T>();
                    Trigger.interestLayers = 0;
                }

                public void Destroy() => UnityEngine.Object.Destroy(Object);
            }
            #endregion

            #region Autolights
            private bool isLightsOn = false;

            private void InitializeAutoLights()
            {
                if (HasFlag(ZoneFlags.AlwaysLights))
                {
                    isLightsOn = true;

                    InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                    InvokeHandler.InvokeRandomized(this, CheckAlwaysLights, 5f, 60f, 10f);
                }
                else if (HasFlag(ZoneFlags.AutoLights))
                {
                    InvokeHandler.CancelInvoke(this, CheckLights);
                    InvokeHandler.InvokeRandomized(this, CheckLights, 5f, 20f, 10f);
                }
            }

            private void CheckAlwaysLights()
            {
                ServerMgr.Instance.StartCoroutine(ToggleLights(true));
            }

            private void CheckLights()
            {
                float currentTime = TOD_Sky.Instance.Cycle.Hour;

                bool shouldBeActive = currentTime > Configuration.AutoLights.OnTime || currentTime < Configuration.AutoLights.OffTime;

                if (shouldBeActive == isLightsOn) 
                    return;
                
                isLightsOn = shouldBeActive;
                ServerMgr.Instance.StartCoroutine(ToggleLights(isLightsOn));
            }

            private IEnumerator ToggleLights(bool active)
            {
                while (isTogglingLights)
                    yield return null;

                isTogglingLights = true;

                bool requiresFuel = Configuration.AutoLights.RequiresFuel;

                for (int i = 0; i < entities.Count; i++)
                {
                    if (ToggleLight(entities[i], active, requiresFuel))
                        yield return CoroutineEx.waitForEndOfFrame;
                }

                isTogglingLights = false;
            }

            private bool ToggleLight(BaseEntity baseEntity, bool active, bool requiresFuel)
            {
                BaseOven baseOven = baseEntity as BaseOven;
                if (baseOven)
                {
                    if (active)
                    {
                        if (!baseOven.IsOn())
                        {
                            if ((requiresFuel && baseOven.FindBurnable() != null) || !requiresFuel)
                                baseOven.SetFlag(BaseEntity.Flags.On, true);
                        }
                    }
                    else
                    {
                        if (baseOven.IsOn())
                            baseOven.StopCooking();
                    }

                    return true;
                }

                SearchLight searchLight = baseEntity as SearchLight;
                if (searchLight)
                {
                    if (active)
                    {
                        if (!searchLight.IsOn())
                            searchLight.SetFlag(BaseEntity.Flags.On, true);
                    }
                    else
                    {
                        if (searchLight.IsOn())
                            searchLight.SetFlag(BaseEntity.Flags.On, false);
                    }

                    return true;
                }

                return false;
            }
            #endregion

            #region Entity Detection            
            private void OnTriggerEnter(Collider col)
            {
                if (!definition.Enabled || !col || !col.gameObject)
                    return;

                BaseEntity baseEntity = col.gameObject.ToBaseEntity();
                if (!baseEntity || !baseEntity.IsValid())
                    return;

                if (baseEntity is BasePlayer { IsNpc: false } player)
                {
                    Instance?.OnPlayerEnterZone(player, this);

                    if (parent)
                        Instance?.UpdateZoneEntityFlags(this);

                    return;
                }

                Instance?.OnEntityEnterZone(baseEntity, this);
            }

            private void OnTriggerExit(Collider col)
            {
                if (!definition.Enabled || !col || !col.gameObject)
                    return;

                BaseEntity baseEntity = col.gameObject.ToBaseEntity();
                if (!baseEntity || !baseEntity.IsValid())
                    return;

                if (baseEntity is BasePlayer { IsNpc: false } player)
                {
                    Instance?.OnPlayerExitZone(player, this);

                    return;
                }

                Instance?.OnEntityExitZone(baseEntity, this);
            }

            public void OnPlayerEnterZone(BasePlayer player)
            {
                if (!players.Contains(player))
                    players.Add(player);

                if (zonedPlayers.TryGetValue(player.userID, out EntityZones entityZone))
                    entityZones[player.userID] = entityZone;
                
                if (safeZone != null)
                    AddToTrigger(safeZone.Trigger, player);

                if (radiation != null)
                    AddToTrigger(radiation.Trigger, player);

                if (comfort != null)
                    AddToTrigger(comfort.Trigger, player);

                if (temperature != null)
                    AddToTrigger(temperature.Trigger, player);
            }            

            public void OnPlayerExitZone(BasePlayer player)
            {
                players.Remove(player);
                entityZones.Remove(player.userID);
                
                if (safeZone != null)
                    RemoveFromTrigger(safeZone.Trigger, player);

                if (radiation != null)
                    RemoveFromTrigger(radiation.Trigger, player);

                if (comfort != null)
                    RemoveFromTrigger(comfort.Trigger, player);

                if (temperature != null)
                    RemoveFromTrigger(temperature.Trigger, player);
            }

            public void OnEntityEnterZone(BaseEntity baseEntity)
            {
                entities.Add(baseEntity);

                if (zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZone))
                    entityZones[baseEntity.net.ID.Value] = entityZone;

                if (HasFlag(ZoneFlags.NoDecay))
                {
                    DecayEntity decayEntity = baseEntity.GetComponentInParent<DecayEntity>();
                    if (decayEntity)
                    {
                        decayEntity.decay = null;
                    }
                }

                if (HasFlag(ZoneFlags.NoStability))
                {
                    if (baseEntity is StabilityEntity entity)
                    {
                        entity.grounded = true;
                    }
                }

                if (HasFlag(ZoneFlags.NpcFreeze) && baseEntity.IsNpc)
                {
                    if (baseEntity is BaseAnimalNPC animalNpc)
                    {
                        animalNpc.brain.SetEnabled(false);
                        return;
                    }

                    if (baseEntity is global::HumanNPC humanNpc)
                    {
                        humanNpc.Brain.SetEnabled(false);
                        return;
                    }

                    if (baseEntity is ScarecrowNPC scarecrowNpc)
                    {
                        scarecrowNpc.Brain.SetEnabled(false);
                        return;
                    }

                    if (baseEntity is BaseNpc npc)
                    {
                        npc.CancelInvoke(npc.TickAi);
                        return;
                    }
                }

                if (baseEntity is SmartSwitch or ElectricSwitch or RFReceiver)
                {
                    ioEntities.Add((IOEntity)baseEntity);

                    if (HasFlag(ZoneFlags.PoweredSwitches))
                    {
                        ((IOEntity)baseEntity).SetFlag(BaseEntity.Flags.Reserved8, true);
                        ((IOEntity)baseEntity).currentEnergy = int.MaxValue;
                    }
                }

                if (HasFlag(ZoneFlags.AlwaysLights) || (HasFlag(ZoneFlags.AutoLights) && isLightsOn))
                {
                    if (baseEntity is BaseOven or SearchLight)
                    {
                        ToggleLight(baseEntity, true, Configuration.AutoLights.RequiresFuel);
                    }
                }
            }

            public void OnEntityExitZone(BaseEntity baseEntity, bool resetDecay, bool isDead = false)
            {
                entities.Remove(baseEntity);

                entityZones.Remove(baseEntity.net.ID.Value);
                
                if (isDead)
                    return;

                if (resetDecay)
                {
                    if (HasFlag(ZoneFlags.NoDecay))
                    {
                        DecayEntity decayEntity = baseEntity.GetComponentInParent<DecayEntity>();
                        if (decayEntity)
                        {
                            decayEntity.decay = PrefabAttribute.server.Find<Decay>(decayEntity.prefabID);
                        }
                    }
                }

                if (HasFlag(ZoneFlags.NpcFreeze) && baseEntity.IsNpc)
                {                    
                    if (baseEntity is BaseAnimalNPC animalNpc)
                    {
                        animalNpc.brain.SetEnabled(true);
                        return;
                    }

                    if (baseEntity is global::HumanNPC humanNpc)
                    {
                        humanNpc.Brain.SetEnabled(true);
                        return;
                    }

                    if (baseEntity is ScarecrowNPC scarecrowNpc)
                    {
                        scarecrowNpc.Brain.SetEnabled(true);
                        return;
                    }

                    if (baseEntity is BaseNpc npc)
                    {
                        npc.InvokeRandomized(npc.TickAi, 0.1f, 0.1f, 0.00500000035f);
                        return;
                    }
                }

                if (baseEntity is SmartSwitch or ElectricSwitch or RFReceiver)
                {
                    IOEntity ioEntity = (IOEntity)baseEntity;
                    ioEntities.Remove(ioEntity);

                    if (HasFlag(ZoneFlags.PoweredSwitches))
                    {
                        ioEntity.SetFlag(BaseEntity.Flags.Reserved8, false);
                        ioEntity.currentEnergy = 0;

                        for (int i = 0; i < ioEntity.inputs.Length; i++)
                        {
                            IOEntity fromEntity = ioEntity.inputs[i].connectedTo.Get();
                            if (fromEntity)
                                fromEntity.MarkDirtyForceUpdateOutputs();
                        }
                    }
                }

                if (!HasFlag(ZoneFlags.AlwaysLights) && (!HasFlag(ZoneFlags.AutoLights) || !isLightsOn)) 
                    return;
                
                if (baseEntity is BaseOven or SearchLight)
                {
                    ToggleLight(baseEntity, false, false);
                }
            }
            #endregion

            #region IO Power            
            private void IOTick()
            {
                for (int i = 0; i < ioEntities.Count; i++)
                {
                    IOEntity ioEntity = ioEntities[i];

                    if (!ioEntity || ioEntity.IsDestroyed) 
                        continue;
                    
                    ioEntity.SetFlag(BaseEntity.Flags.Reserved8, true);
                    ioEntity.currentEnergy = int.MaxValue;
                }
            }
            #endregion

            #region Vehicle Enter/Exit
            public bool TryReverseVelocity(BaseEntity baseEntity)
            {
                if (Time.frameCount == creationFrame)
                    return false;

                if (baseEntity is not BaseVehicle baseVehicle) 
                    return false;
                
                if (baseVehicle is BaseVehicleModule module)
                    baseVehicle = module.Vehicle;

                if (!CanReverseVelocity(baseVehicle)) 
                    return false;

                if (!ReverseVelocity(baseVehicle)) 
                    return false;
                
                lastReversedTimes[baseVehicle] = Time.time;
                return true;

            }

            private bool CanReverseVelocity(BaseVehicle baseVehicle)
            {
                if (lastReversedTimes.TryGetValue(baseVehicle, out float lastReversedTime))
                    return Time.time - lastReversedTime > 0.5f;

                return true;
            }
            #endregion

            #region Helpers
            public bool HasPermission(BasePlayer player)
            {
                if (Instance == null)
                {
                    Debug.LogError($"[ZoneManager] Zone attempted to check player permission, but plugin instance is null...");
                    return false;
                }

                return string.IsNullOrEmpty(definition.Permission) || Instance.permission.UserHasPermission(player.UserIDString, definition.Permission);
            }

            public bool CanLeaveZone(BasePlayer player) => !keepInList.Contains(player.userID.Get());

            public bool CanEnterZone(BasePlayer player) => HasPermission(player) || !CanLeaveZone(player) || whitelist.Contains(player.userID.Get());
            #endregion

            #region Flags
            public void AddFlag(int flag) 
            {
                definition.Flags.AddFlag(flag);
                OnZoneFlagsChanged();
            }

            public void RemoveFlag(int flag)
            {
                definition.Flags.RemoveFlag(flag);
                OnZoneFlagsChanged();
            }

            public bool HasFlag(int flag) => definition.Flags.HasFlag(flag) && !disabledFlags.HasFlag(flag);

            public bool HasDisabledFlag(int flag) => disabledFlags.HasFlag(flag);

            public void AddDisabledFlag(int flag)
            {
                disabledFlags.AddFlag(flag);
                OnZoneFlagsChanged();
            }

            public void RemoveDisabledFlag(int flag)
            {
                disabledFlags.AddFlag(flag);
                OnZoneFlagsChanged();
            }
            #endregion

            #region Zone Definition
            public class Definition
            {
                public string Name { get; set; }

                public float Radius { get; set; }

                public float Radiation { get; set; }

                public float Comfort { get; set; }

                public float Temperature { get; set; }

                public bool SafeZone { get; set; }

                public Vector3 Location { get; set; }

                public Vector3 Size { get; set; }

                public Vector3 Rotation { get; set; }

                public string Id { get; set; }

                public string ParentID { get; set; }

                public string EnterMessage { get; set; }

                public string LeaveMessage { get; set; }

                public string Permission { get; set; }

                public string EjectSpawns { get; set; }

                public bool Enabled { get; set; } = true;

                public ZoneFlags Flags { get; set; }

                public Definition() { }

                public Definition(Vector3 position)
                {
                    Radius = 20f;
                    Location = position;

                    Flags = new ZoneFlags();
                }
            }
            #endregion
        }
        #endregion

        #region Entity Management
        private void OnPlayerEnterZone(BasePlayer player, Zone zone)
        {
            if (!player || IsNpc(player))
                return;

            if (!zone.CanEnterZone(player))
            {
                EjectPlayer(player, zone);
                return;
            }

            if (HasFlag(zone, ZoneFlags.Eject))
            {
                if (!CanBypass(player, ZoneFlags.Eject) && !IsAdmin(player))
                {
                    EjectPlayer(player, zone);
                    return;
                }
            }

            //if (HasFlag(zone, ZoneFlags.KeepVehiclesOut) && player.isMounted && ReverseVelocity(player.GetMountedVehicle()))
            //{
            //    SendMessage(player, Message("novehiclesenter", player.UserIDString));
            //    return;
            //}

            if (player.IsSleeping() && !player.IsConnected)
            {
                if (HasFlag(zone, ZoneFlags.KillSleepers))
                {
                    if (!CanBypass(player, ZoneFlags.KillSleepers) && !IsAdmin(player))
                    {
                        player.Die();
                        return;
                    }
                }

                if (HasFlag(zone, ZoneFlags.EjectSleepers))
                {
                    if (!CanBypass(player, ZoneFlags.EjectSleepers) && !IsAdmin(player))
                    {
                        EjectPlayer(player, zone);
                        return;
                    }
                }
            }

            if (HasFlag(zone, ZoneFlags.Kill))
            {
                if (!CanBypass(player, ZoneFlags.Kill) && !IsAdmin(player))
                {
                    player.Die();
                    return;
                }
            }

            if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones))
                zonedPlayers[player.userID] = entityZones = new EntityZones();

            if (!entityZones.EnterZone(zone))
                return;

            if (zone.parent)
                entityZones.UpdateFlags();
            else entityZones.AddFlags(zone.definition.Flags);

            zone.OnPlayerEnterZone(player);

            UpdateMetabolismForPlayer(player);

            if (!string.IsNullOrEmpty(zone.definition.EnterMessage))
            {
                if (PopupNotifications != null && Configuration.Notifications.Popups)
                    PopupNotifications.Call("CreatePopupNotification", string.Format(zone.definition.EnterMessage, player.displayName), player);
                else SendMessage(player, zone.definition.EnterMessage, player.displayName);
            }

            Interface.CallHook("OnEnterZone", zone.definition.Id, player);
        }

        private void OnPlayerExitZone(BasePlayer player, Zone zone)
        {
            if (!player || IsNpc(player))
                return;

            //if (HasFlag(zone, ZoneFlags.KeepVehiclesIn) && player.isMounted && ReverseVelocity(player.GetMountedVehicle()))
            //{
            //    SendMessage(player, Message("novehiclesleave", player.UserIDString));
            //    return;
            //}

            if (!zone.CanLeaveZone(player))
            {
                AttractPlayer(player, zone);
                return;
            }

            if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones))
                return;

            entityZones.LeaveZone(zone);

            if (entityZones.ShouldRemove())
                zonedPlayers.Remove(player.userID);
            else entityZones.UpdateFlags();

            zone.OnPlayerExitZone(player);

            UpdateMetabolismForPlayer(player);

            if (!string.IsNullOrEmpty(zone.definition.LeaveMessage))
            {
                if (PopupNotifications != null && Configuration.Notifications.Popups)
                    PopupNotifications.Call("CreatePopupNotification", string.Format(zone.definition.LeaveMessage, player.displayName), player);
                else SendMessage(player, zone.definition.LeaveMessage, player.displayName);
            }

            Interface.CallHook("OnExitZone", zone.definition.Id, player);
        }

        private void UpdateMetabolismForPlayer(BasePlayer player)
        {
            if (!player)
                return;

            MetabolismAttribute bleeding = player.metabolism.bleeding;
            if (HasPlayerFlag(player, ZoneFlags.NoBleed))
            {
                bleeding.value = 0f;
                bleeding.max = 0f;
            }
            else bleeding.max = 1f;

            MetabolismAttribute oxygen = player.metabolism.oxygen;
            if (HasPlayerFlag(player, ZoneFlags.NoDrown))
            {
                oxygen.value = 1f;
                oxygen.min = 1f;
            }
            else oxygen.min = 0f;

            MetabolismAttribute poison = player.metabolism.poison;
            if (HasPlayerFlag(player, ZoneFlags.NoPoison))
            {
                poison.value = 0f;
                poison.max = 0f;
            }
            else poison.max = 100f;

            MetabolismAttribute calories = player.metabolism.calories;
            if (HasPlayerFlag(player, ZoneFlags.NoStarvation))
            {
                calories.value = Mathf.Max(calories.value, 50f);
                calories.min = calories.value;
            }
            else calories.min = 0f;

            MetabolismAttribute hydration = player.metabolism.hydration;
            if (HasPlayerFlag(player, ZoneFlags.NoThirst))
            {
                hydration.value = Mathf.Max(hydration.value, 50f);
                hydration.min = hydration.value;
            }
            else hydration.min = 0f;

            MetabolismAttribute radiation_level = player.metabolism.radiation_level;
            MetabolismAttribute radiation_poison = player.metabolism.radiation_poison;
            if (HasPlayerFlag(player, ZoneFlags.NoRadiation))
            {
                radiation_level.value = 0f;
                radiation_level.max = 0f;
                radiation_poison.value = 0f;
                radiation_poison.max = 0f;
            }
            else
            {
                radiation_level.max = 100f;
                radiation_poison.max = 500f;
            }

            player.metabolism.SendChangesToClient();
        }

        private void OnEntityEnterZone(BaseEntity baseEntity, Zone zone)
        {
            if (!baseEntity || !baseEntity.IsValid())
                return;

            if (zone.HasFlag(ZoneFlags.KeepVehiclesOut) && !zone.entities.Contains(baseEntity) && zone.TryReverseVelocity(baseEntity))
            {
                BasePlayer player = (baseEntity as BaseVehicle).GetDriver();
                if (player)
                    SendMessage(player, Message("novehiclesenter", player.UserIDString));
                return;
            }

            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZones))
                zonedEntities[baseEntity.net.ID] = entityZones = new EntityZones();

            if (!entityZones.EnterZone(zone))
                return;

            if (zone.parent)
                entityZones.UpdateFlags();
            else entityZones.AddFlags(zone.definition.Flags);

            zone.OnEntityEnterZone(baseEntity);

            Interface.CallHook("OnEntityEnterZone", zone.definition.Id, baseEntity);
        }

        private void OnEntityExitZone(BaseEntity baseEntity, Zone zone)
        {
            if (!baseEntity || !baseEntity.IsValid())
                return;

            if (zone.HasFlag(ZoneFlags.KeepVehiclesOut) && zone.entities.Contains(baseEntity) && zone.TryReverseVelocity(baseEntity))
            {
                BasePlayer player = (baseEntity as BaseVehicle).GetDriver();
                if (player)
                    SendMessage(player, Message("novehiclesleave", player.UserIDString));

                return;
            }

            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZones))
                return;

            entityZones.LeaveZone(zone);

            if (entityZones.ShouldRemove())
                zonedEntities.Remove(baseEntity.net.ID);
            else entityZones.UpdateFlags();

            zone.OnEntityExitZone(baseEntity, !entityZones.HasFlag(ZoneFlags.NoDecay));

            Interface.CallHook("OnEntityExitZone", zone.definition.Id, baseEntity);
        }
        #endregion

        #region Helpers
        private bool IsAdmin(BasePlayer player) => player?.net?.connection?.authLevel > 0;

        private bool IsNpc(BasePlayer player) => player.IsNpc || player is NPCPlayer;

        private bool HasPermission(BasePlayer player, string permname) => IsAdmin(player) || permission.UserHasPermission(player.UserIDString, permname);

        private bool HasPermission(ConsoleSystem.Arg arg, string permname) => !(arg.Connection.player as BasePlayer) ? true : permission.UserHasPermission((arg.Connection.player as BasePlayer).UserIDString, permname);

        private bool CanBypass(BasePlayer player, int flag) => CanBypass(player.UserIDString, flag);

        private bool CanBypass(ulong playerId, int flag) => CanBypass(playerId.ToString(), flag);
        
        private bool CanBypass(string playerId, int flag)
        {
            if (ZoneFlags.IndexToName.TryGetValue(flag, out string flagName))
                return permission.UserHasPermission(playerId, PERMISSION_IGNORE_FLAG + flagName);
            
            Debug.LogError($"[ZoneManager] CanBypass called with invalid flag : {flag}");
            return false;
        }

        private void SendMessage(BasePlayer player, string message, params object[] args)
        {
            if (player)
            {
                if (args.Length > 0)
                    message = string.Format(message, args);
                SendReply(player, $"<color={Configuration.Notifications.Color}>{Configuration.Notifications.Prefix}</color> {message}");
            }
            else Puts(message);
        }

        private Zone GetZoneByID(string zoneId) => zones.ContainsKey(zoneId) ? zones[zoneId] : null;

        private void AddToKeepinlist(Zone zone, BasePlayer player)
        {
            zone.keepInList.Add(player.userID);

            if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones) || !entityZones.Zones.Contains(zone))
                AttractPlayer(player, zone);
        }

        private void RemoveFromKeepinlist(Zone zone, BasePlayer player) => zone.keepInList.Remove(player.userID.Get());

        private void AddToWhitelist(Zone zone, BasePlayer player)
        {
            if (!zone.whitelist.Contains(player.userID.Get()))
                zone.whitelist.Add(player.userID);
        }

        private void RemoveFromWhitelist(Zone zone, BasePlayer player) => zone.whitelist.Remove(player.userID.Get());

        private bool HasPlayerFlag(BasePlayer player, int flag)
        {
            if (!player)
                return false;

            if (adminBypass.HasFlag(flag) && IsAdmin(player))
                return false;

            if (CanBypass(player, flag))
                return false;

            if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones))
                return false;

            return entityZones.HasFlag(flag);
        }

        private bool HasEntityFlag(BaseEntity baseEntity, int flag)
        {
            if (!baseEntity.IsValid())
                return false;

            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZones))
                return false;

            return entityZones.HasFlag(flag);
        }
        #endregion

        #region API 

        #region Zone Management       

        private void SetZoneStatus(string zoneId, bool active)
        {
            Zone zone = GetZoneByID(zoneId);
            if (zone)
            {
                zone.definition.Enabled = active;
                zone.InitializeZone(zone.definition);
            }
        }

        private Vector3 GetZoneLocation(string zoneId) => GetZoneByID(zoneId)?.definition.Location ?? Vector3.zero;

        private object GetZoneRadius(string zoneID) => GetZoneByID(zoneID)?.definition.Radius;

        private object GetZoneSize(string zoneID) => GetZoneByID(zoneID)?.definition.Size;

        private object GetZoneName(string zoneID) => GetZoneByID(zoneID)?.definition.Name;

        private object CheckZoneID(string zoneID) => GetZoneByID(zoneID)?.definition.Id;

        private object GetZoneIDs() => zones.Keys.ToArray();

        private bool IsPositionInZone(string zoneID, Vector3 position)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return false;

            if (zone.definition.Size != Vector3.zero)
                return IsInsideBounds(zone, position); 
            return Vector3.Distance(position, zone.transform.position) <= zone.definition.Radius;            
        }

        private List<BasePlayer> GetPlayersInZone(string zoneID)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return new List<BasePlayer>();

            return new List<BasePlayer>(zone.players);
        }

        private List<BaseEntity> GetEntitiesInZone(string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return new List<BaseEntity>();

            return new List<BaseEntity>(zone.entities);
        }

        private bool isPlayerInZone(string zoneID, BasePlayer player) => IsPlayerInZone(zoneID, player);
        
        private bool isEntityInZone(string zoneID, BaseEntity entity) => IsEntityInZone(zoneID, entity);

        private bool IsPlayerInZone(string zoneID, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return false;

            return zone.players.Contains(player);
        }

        private bool IsEntityInZone(string zoneID, BaseEntity entity)
        {
            Zone zone = GetZoneByID(zoneID);
            return zone && zone.entities.Contains(entity);
        }

        private string[] GetPlayerZoneIDs(BasePlayer player)
        {
            if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones))
                return Array.Empty<string>();

            return entityZones.Zones.Select(x => x.definition.Id).ToArray();
        }

        private string[] GetEntityZoneIDs(BaseEntity entity)
        {
            if (!zonedEntities.TryGetValue(entity.net.ID, out EntityZones entityZones))
                return Array.Empty<string>();

            return entityZones.Zones.Select(x => x.definition.Id).ToArray();
        }

        private bool HasFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            if (!ZoneFlags.NameToIndex.TryGetValue(flagName, out int v))             
            {
                Debug.Log($"[ZoneManager] A plugin has call HasFlag with a invalid flag : {flagName}");
                return false;
            }

            return zone.HasFlag(v);
        }

        private void AddFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v))
                zone.AddFlag(v);
            else Debug.Log($"[ZoneManager] A plugin has call AddFlag with a invalid flag : {flagName}");           
        }

        private void RemoveFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v))
                zone.RemoveFlag(v);
            else Debug.Log($"[ZoneManager] A plugin has call RemoveFlag with a invalid flag : {flagName}");
        }

        private bool HasDisabledFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v)) 
                return zone.HasDisabledFlag(v);
            
            Debug.Log($"[ZoneManager] A plugin has call HasDisabledFlag with a invalid flag : {flagName}");
            return false;

        }

        private void AddDisabledFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v))
                zone.AddDisabledFlag(v);
            else Debug.Log($"[ZoneManager] A plugin has call AddDisabledFlag with a invalid flag : {flagName}");            
        }

        private void RemoveDisabledFlag(string zoneId, string flagName)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v))
                zone.RemoveDisabledFlag(v);
            else Debug.Log($"[ZoneManager] A plugin has call RemoveDisabledFlag with a invalid flag : {flagName}");            
        }

        private bool CreateOrUpdateZone(string zoneId, string[] args, Vector3 position = default(Vector3))
        {
            Zone.Definition definition;

            if (!zones.TryGetValue(zoneId, out Zone zone))
            {
                zone = new GameObject().AddComponent<Zone>();
                definition = new Zone.Definition { Id = zoneId, Radius = 20, Flags = new ZoneFlags() };

                zones[zoneId] = zone;
                zone.InitializeZone(definition);
            }
            else definition = zone.definition;

            UpdateZoneDefinition(zone, args);

            if (position != default(Vector3))
                definition.Location = position;

            zone.definition = definition;
            zone.Reset();
            zone.FindZoneParent();
            SaveData();
            return true;
        }

        private bool EraseZone(string zoneId)
        {
            if (!zones.TryGetValue(zoneId, out Zone zone))
                return false;

            zones.Remove(zoneId);

            UnityEngine.Object.DestroyImmediate(zone.gameObject);

            SaveData();
            return true;
        }


        private List<string> ZoneFieldListRaw()
        {
            List<string> list = new List<string> { "name", "ID", "radius", "rotation", "size", "Location", "enter_message", "leave_message", "radiation", "comfort", "temperature" };
            list.AddRange(ZoneFlags.NameToIndex.Keys);
            return list;
        }

        private Dictionary<string, string> ZoneFieldList(string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return null;

            Dictionary<string, string> fields = new Dictionary<string, string>
            {
                { "name", zone.definition.Name },
                { "ID", zone.definition.Id },
                { "comfort", zone.definition.Comfort.ToString() },
                { "temperature", zone.definition.Temperature.ToString() },
                { "radiation", zone.definition.Radiation.ToString() },
                { "safezone", zone.definition.SafeZone.ToString() },
                { "radius", zone.definition.Radius.ToString() },
                { "rotation", zone.definition.Rotation.ToString() },
                { "size", zone.definition.Size.ToString() },
                { "Location", zone.definition.Location.ToString() },
                { "enter_message", zone.definition.EnterMessage },
                { "leave_message", zone.definition.LeaveMessage },
                { "permission", zone.definition.Permission },
                { "ejectspawns", zone.definition.EjectSpawns }
            };

            foreach (KeyValuePair<string, int> kvp in ZoneFlags.NameToIndex)
                fields[kvp.Key] = zone.HasFlag(kvp.Value).ToString();

            return fields;
        }
        #endregion

        #region Entity Management        
        private bool AddPlayerToZoneKeepinlist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            AddToKeepinlist(zone, player);
            return true;
        }

        private bool RemovePlayerFromZoneKeepinlist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            RemoveFromKeepinlist(zone, player);
            return true;
        }

        private bool AddPlayerToZoneWhitelist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            AddToWhitelist(zone, player);
            return true;
        }

        private bool RemovePlayerFromZoneWhitelist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            RemoveFromWhitelist(zone, player);
            return true;
        }

        private bool EntityHasFlag(BaseEntity baseEntity, string flagName)
        {
            if (!baseEntity.IsValid())
                return false;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v)) 
                return HasEntityFlag(baseEntity, v);
            
            Debug.LogError($"[ZoneManager] A plugin has called EntityHasFlag with a invalid flag : {flagName}");
            return false;

        }

        private bool PlayerHasFlag(BasePlayer player, string flagName)
        {
            if (!player)
                return false;

            if (ZoneFlags.NameToIndex.TryGetValue(flagName, out int v)) 
                return HasPlayerFlag(player, v);
            
            Debug.LogError($"[ZoneManager] A plugin has called EntityHasFlag with a invalid flag : {flagName}");
            return false;

        }
        #endregion

        #region Plugin Integration
        private object CanRedeemKit(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoKits) ? "You may not redeem a kit inside this area" : null;

        private object CanTeleport(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoTp) ? "You may not teleport in this area" : null;

        private object canRemove(BasePlayer player) => CanRemove(player);

        private object CanRemove(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoRemove) ? "You may not use the remover tool in this area" : null;

        private bool CanChat(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoChat) ? false : true;

        private object CanTrade(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoTrade) ? "You may not trade in this area" : null;

        private object canShop(BasePlayer player) => CanShop(player);

        private object CanShop(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoShop) ? "You may not use the store in this area" : null;
        #endregion

        #endregion

        #region Flags
        public class ZoneFlags
        {
            public static readonly int AutoLights;
            public static readonly int AlwaysLights;

            public static readonly int NoKits;
            public static readonly int NoTrade;
            public static readonly int NoShop;
            public static readonly int NoTp;
            public static readonly int NoRemove;

            public static readonly int NoPoison;
            public static readonly int NoStarvation;
            public static readonly int NoThirst;
            public static readonly int NoRadiation;
            public static readonly int NoDrown;
            public static readonly int NoBleed;
            public static readonly int NoWounded;

            public static readonly int Eject;
            public static readonly int EjectSleepers;

            public static readonly int PvpGod;
            public static readonly int PveGod;
            public static readonly int SleepGod;
            public static readonly int NoPve;
            public static readonly int NoFallDamage;

            public static readonly int UnDestr;
            public static readonly int NoBuildingDamage;
            public static readonly int NoDecay;

            public static readonly int NoBuild;
            public static readonly int NoStability;
            public static readonly int NoUpgrade;

            public static readonly int NoSprays;
            public static readonly int NoDeploy;

            public static readonly int PoweredSwitches;

            public static readonly int LootSelf;
            public static readonly int NoPlayerLoot;
            public static readonly int NoNPCLoot;
            public static readonly int NoBoxLoot;
            public static readonly int NoPickup;
            public static readonly int NoCollect;
            public static readonly int NoDrop;
            public static readonly int NoLootSpawns;
            public static readonly int NoEntityPickup;
            public static readonly int NoGather;

            public static readonly int NoHeliTargeting;
            public static readonly int NoTurretTargeting;
            public static readonly int NoAPCTargeting;
            public static readonly int NoNPCTargeting;
            public static readonly int NpcFreeze;
            public static readonly int NoNPCSpawns;

            public static readonly int KeepVehiclesIn;
            public static readonly int KeepVehiclesOut;
            public static readonly int NoVehicleMounting;
            public static readonly int NoVehicleDismounting;

            public static readonly int NoChat;
            public static readonly int NoVoice;
            
            public static readonly int NoCorpse;
            public static readonly int NoSuicide;
            public static readonly int KillSleepers;            

            public static readonly int Kill;
            public static readonly int InfiniteTrapAmmo;

            public static readonly int NoCup;            
            public static readonly int NoSignUpdates;
            public static readonly int NoOvenToggle;
            public static readonly int NoVending;
            public static readonly int NoStash;
            public static readonly int NoCraft;  
            public static readonly int NoDoorAccess;

            public static readonly int Custom1;
            public static readonly int Custom2;
            public static readonly int Custom3;
            public static readonly int Custom4;
            public static readonly int Custom5;

            public static readonly Hash<string, int> NameToIndex;
            public static readonly Hash<int, string> IndexToName;

            private static readonly int Count;

            private readonly BitArray m_BitArray;

            static ZoneFlags()
            {
                NameToIndex = new Hash<string, int>(StringComparer.OrdinalIgnoreCase);
                IndexToName = new Hash<int, string>();

                FieldInfo[] fields = typeof(ZoneFlags).GetFields(BindingFlags.Public | BindingFlags.Static);

                int index = 0;
                for (int i = 0; i < fields.Length; i++)
                {
                    FieldInfo fieldInfo = fields[i];

                    if (fieldInfo.FieldType != typeof(int)) 
                        continue;
                    
                    fieldInfo.SetValue(null, index);

                    NameToIndex[fieldInfo.Name] = index;
                    IndexToName[index] = fieldInfo.Name;

                    index++;
                }

                Count = NameToIndex.Values.Max() + 1;
            }

            public static bool Find(string flagName, out int index)
            {
                foreach (KeyValuePair<string, int> kvp in NameToIndex)
                {
                    if (!flagName.Equals(kvp.Key, StringComparison.OrdinalIgnoreCase)) 
                        continue;
                    
                    index = kvp.Value;
                    return true;
                }

                index = 0;
                return false;
            }

            public ZoneFlags()
            {
                m_BitArray = new BitArray(Count, false);               
            }

            public bool this[int key]
            {
                get => m_BitArray[key];
                set => m_BitArray[key] = value;
            }

            public bool HasFlag(int flag) => this[flag];
            
            public void AddFlag(int flag) => this[flag] = true;

            public void RemoveFlag(int flag) => this[flag] = false;

            public void SetFlags(params int[] array)
            {
                for (int i = 0; i < m_BitArray.Length; i++)
                {
                    this[i] = array.Contains(i);
                }
            }

            public void Clear() => m_BitArray.SetAll(false);
            
            public bool HasFlag(string flagName)
            {
                if (!NameToIndex.TryGetValue(flagName, out int v))   
                {
                    Debug.LogError($"[ZoneManager] ZoneFlags.HasFlag used with invalid flag string : {flagName}");
                    return false;
                }
                return this[v];
            }

            public void AddFlag(string flagName)
            {
                if (!NameToIndex.TryGetValue(flagName, out int v))                    
                    Debug.LogError($"[ZoneManager] ZoneFlags.AddFlag used with invalid flag string : {flagName}");
                else this[v] = true;
            }

            public void RemoveFlag(string flagName)
            {
                if (!NameToIndex.TryGetValue(flagName, out int v))                   
                    Debug.LogError($"[ZoneManager] ZoneFlags.RemoveFlag used with invalid flag string : {flagName}");
                else this[v] = false;
            }

            public void SetFlags(params string[] array)
            {
                List<int> list = Pool.Get<List<int>>();
                for (int i = 0; i < array.Length; i++)
                {
                    if (NameToIndex.TryGetValue(array[i], out int v))                        
                        Debug.Log($"[ZoneManager] ZoneFlags.SetFlags used with invalid flag string : {array[i]}");
                    else list.Add(v);
                }

                for (int i = 0; i < m_BitArray.Length; i++)
                {
                    this[i] = list.Contains(i);
                }
                Pool.FreeUnmanaged(ref list);
            }

            public void AddFlags(ZoneFlags zoneFlags)
            {
                for (int i = 0; i < zoneFlags.m_BitArray.Length; i++)
                {
                    if (zoneFlags.m_BitArray[i])
                        this[i] = true;
                }                
            }

            public void RemoveFlags(ZoneFlags zoneFlags)
            {
                for (int i = 0; i < zoneFlags.m_BitArray.Length; i++)
                {
                    if (zoneFlags.m_BitArray[i])
                        this[i] = false;
                }
            }

            public bool CompareTo(ZoneFlags zoneFlags)
            {
                for (int i = 0; i < m_BitArray.Length; i++)
                {
                    if (this[i] != zoneFlags[i])
                        return false;
                }

                return true;
            }

            public override string ToString()
            {
                sb.Clear();

                foreach (KeyValuePair<string, int> flag in NameToIndex)
                {
                    if (HasFlag(flag.Value))
                    {
                        sb.Append(sb.Length == 0 ? flag.Key : ", " + flag.Key);
                    }
                }

                return sb.ToString();
            }
        }

        //[Flags]
        //public enum ZoneFlags : ulong
        //{
        //    None = 0UL,
        //    AutoLights = 1UL,
        //    Eject = 1UL << 1,
        //    PvpGod = 1UL << 2,
        //    PveGod = 1UL << 3,
        //    SleepGod = 1UL << 4,
        //    UnDestr = 1UL << 5,
        //    NoBuild = 1UL << 6,
        //    NoTp = 1UL << 7,
        //    NoChat = 1UL << 8,
        //    NoGather = 1UL << 9,
        //    NoPve = 1UL << 10,
        //    NoWounded = 1UL << 11,
        //    NoDecay = 1UL << 12,
        //    NoDeploy = 1UL << 13,
        //    NoKits = 1UL << 14,
        //    NoBoxLoot = 1UL << 15,
        //    NoPlayerLoot = 1UL << 16,
        //    NoCorpse = 1UL << 17,
        //    NoSuicide = 1UL << 18,
        //    NoRemove = 1UL << 19,
        //    NoBleed = 1UL << 20,
        //    KillSleepers = 1UL << 21,
        //    NpcFreeze = 1UL << 22,
        //    NoDrown = 1UL << 23,
        //    NoStability = 1UL << 24,
        //    NoUpgrade = 1UL << 25,
        //    EjectSleepers = 1UL << 26,
        //    NoPickup = 1UL << 27,
        //    NoCollect = 1UL << 28,
        //    NoDrop = 1UL << 29,
        //    Kill = 1UL << 30,
        //    NoCup = 1UL << 31,
        //    AlwaysLights = 1UL << 32,
        //    NoTrade = 1UL << 33,
        //    NoShop = 1UL << 34,
        //    NoSignUpdates = 1UL << 35,
        //    NoOvenToggle = 1UL << 36,
        //    NoLootSpawns = 1UL << 37,
        //    NoNPCSpawns = 1UL << 38,
        //    NoVending = 1UL << 39,
        //    NoStash = 1UL << 40,
        //    NoCraft = 1UL << 41,
        //    NoHeliTargeting = 1UL << 42,
        //    NoTurretTargeting = 1UL << 43,
        //    NoAPCTargeting = 1UL << 44,
        //    NoNPCTargeting = 1UL << 45,
        //    NoEntityPickup = 1UL << 46,
        //    NoFallDamage = 1UL << 47,
        //    InfiniteTrapAmmo = 1UL << 48,
        //    LootSelf = 1UL << 49,
        //    NoDoorAccess = 1UL << 50,
        //    NoVoice = 1UL << 51,
        //    KeepVehiclesIn = 1UL << 52,
        //    KeepVehiclesOut = 1UL << 53,
        //    NoVehicleMounting = 1UL << 54,
        //    NoVehicleDismounting = 1UL << 55,
        //    NoPoison = 1UL << 56,
        //    NoStarvation = 1UL << 57,
        //    NoThirst = 1UL << 58,
        //    NoNPCLoot = 1UL << 59,
        //    NoSprays = 1UL << 60,
        //    Custom1 = 1UL << 61,
        //    Custom2 = 1UL << 62,
        //    Custom3 = 1UL << 63,
        //}

        private void AddFlag(Zone zone, int flag)
        {
            zone.definition.Flags.AddFlag(flag);

            if (NeedsUpdateSubscriptions())
                UpdateHookSubscriptions();

            zone.Reset();
        }

        private void RemoveFlag(Zone zone, int flag)
        {
            zone.definition.Flags.RemoveFlag(flag);

            if (NeedsUpdateSubscriptions())
            {
                UnsubscribeAll();
                UpdateHookSubscriptions();
            }

            zone.Reset();
        }

        private bool HasFlag(Zone zone, int flag) => zone.definition.Flags.HasFlag(flag) && ! zone.disabledFlags.HasFlag(flag);
                
        private void UpdateZoneEntityFlags(Zone zone)
        {
            foreach (EntityZones entityZones in zone.entityZones.Values)
                entityZones?.UpdateFlags();
            
            /*for (int i = 0; i < zonedPlayers.Count; i++)
            {
                EntityZones entityZones = zonedPlayers.ElementAt(i).Value;

                if (entityZones.Zones.Contains(zone))
                {
                    entityZones.UpdateFlags();
                }
            }

            for (int i = 0; i < zonedEntities.Count; i++)
            {
                EntityZones entityZones = zonedEntities.ElementAt(i).Value;

                if (entityZones.Zones.Contains(zone))
                {
                    entityZones.UpdateFlags();
                }
            }*/
        }
        #endregion

        #region Hook Subscriptions
        private bool HasGlobalFlag(int flag) => globalFlags.HasFlag(flag);

        private void UpdateGlobalFlags()
        {
            globalFlags.Clear();

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                globalFlags.AddFlags(zone.definition.Flags);
            }
        }

        private bool NeedsUpdateSubscriptions()
        {
            tempFlags.Clear();

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                tempFlags.AddFlags(zone.definition.Flags);
            }

            bool isMatch = tempFlags.CompareTo(globalFlags);

            return !isMatch;
        }

        private void UpdateHookSubscriptions()
        {
            UpdateGlobalFlags();

            if (HasGlobalFlag(ZoneFlags.NoBuild) || HasGlobalFlag(ZoneFlags.NoCup) || HasGlobalFlag(ZoneFlags.NoDeploy))
                Subscribe(nameof(OnEntityBuilt));

            if (HasGlobalFlag(ZoneFlags.NoUpgrade))
                Subscribe(nameof(OnStructureUpgrade));

            if (HasGlobalFlag(ZoneFlags.NoDeploy))
                Subscribe(nameof(OnItemDeployed));

            if (HasGlobalFlag(ZoneFlags.InfiniteTrapAmmo) || HasGlobalFlag(ZoneFlags.AlwaysLights) || HasGlobalFlag(ZoneFlags.AutoLights))
                Subscribe(nameof(OnItemUse));

            if (HasGlobalFlag(ZoneFlags.NoChat))
                Subscribe(nameof(OnPlayerChat));

            if (HasGlobalFlag(ZoneFlags.NoSuicide))
                Subscribe(nameof(OnServerCommand));

            if (HasGlobalFlag(ZoneFlags.KillSleepers) || HasGlobalFlag(ZoneFlags.EjectSleepers))
                Subscribe(nameof(OnPlayerDisconnected));

            if (HasGlobalFlag(ZoneFlags.NoFallDamage) || HasGlobalFlag(ZoneFlags.SleepGod) || HasGlobalFlag(ZoneFlags.PvpGod) || HasGlobalFlag(ZoneFlags.PveGod) || HasGlobalFlag(ZoneFlags.NoPve) || HasGlobalFlag(ZoneFlags.UnDestr) || HasGlobalFlag(ZoneFlags.NoBuildingDamage))
                Subscribe(nameof(OnEntityTakeDamage));

            if (HasGlobalFlag(ZoneFlags.NoWounded))
                Subscribe(nameof(CanBeWounded));

            if (HasGlobalFlag(ZoneFlags.NoSignUpdates))
                Subscribe(nameof(CanUpdateSign));

            if (HasGlobalFlag(ZoneFlags.NoOvenToggle))
                Subscribe(nameof(OnOvenToggle));

            if (HasGlobalFlag(ZoneFlags.NoVending))
                Subscribe(nameof(CanUseVending));

            if (HasGlobalFlag(ZoneFlags.NoStash))
                Subscribe(nameof(CanHideStash));

            if (HasGlobalFlag(ZoneFlags.NoCraft))
                Subscribe(nameof(CanCraft));

            if (HasGlobalFlag(ZoneFlags.NoDoorAccess))
                Subscribe(nameof(OnDoorOpened));

            if (HasGlobalFlag(ZoneFlags.NoVoice))
                Subscribe(nameof(OnPlayerVoice));

            if (HasGlobalFlag(ZoneFlags.NoPlayerLoot))
            {
                Subscribe(nameof(CanLootPlayer));
                Subscribe(nameof(OnLootPlayer));
            }

            if (HasGlobalFlag(ZoneFlags.NoVehicleMounting))
                Subscribe(nameof(CanMountEntity));

            if (HasGlobalFlag(ZoneFlags.NoVehicleDismounting))
                Subscribe(nameof(CanDismountEntity));

            if (HasGlobalFlag(ZoneFlags.LootSelf) || HasGlobalFlag(ZoneFlags.NoPlayerLoot))
                Subscribe(nameof(OnLootEntity));

            if (HasGlobalFlag(ZoneFlags.LootSelf) || HasGlobalFlag(ZoneFlags.NoPlayerLoot) || HasGlobalFlag(ZoneFlags.NoBoxLoot) || HasGlobalFlag(ZoneFlags.NoGather))
                Subscribe(nameof(CanLootEntity));

            if (HasGlobalFlag(ZoneFlags.NoEntityPickup))
            {
                Subscribe(nameof(CanPickupEntity));
                Subscribe(nameof(CanPickupLock));
                Subscribe(nameof(OnItemPickup));
            }

            if (HasGlobalFlag(ZoneFlags.NoGather))
            {
                Subscribe(nameof(OnCollectiblePickup));
                Subscribe(nameof(OnGrowableGather));
                Subscribe(nameof(OnDispenserGather));
            }

            if (HasGlobalFlag(ZoneFlags.NoTurretTargeting))
                Subscribe(nameof(OnTurretTarget));

            if (HasGlobalFlag(ZoneFlags.NoAPCTargeting))
                Subscribe(nameof(CanBradleyApcTarget));

            if (HasGlobalFlag(ZoneFlags.NoHeliTargeting))
            {
                Subscribe(nameof(CanHelicopterTarget));
                Subscribe(nameof(CanHelicopterStrafeTarget));
                Subscribe(nameof(OnHelicopterTarget));
            }

            if (HasGlobalFlag(ZoneFlags.NoNPCTargeting))
                Subscribe(nameof(OnNpcTarget));
        }

        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntityBuilt));
            Unsubscribe(nameof(OnStructureUpgrade));
            Unsubscribe(nameof(OnItemDeployed));
            Unsubscribe(nameof(OnItemUse));
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnServerCommand));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(CanBeWounded));
            Unsubscribe(nameof(CanUpdateSign));
            Unsubscribe(nameof(OnOvenToggle));
            Unsubscribe(nameof(CanUseVending));
            Unsubscribe(nameof(CanHideStash));
            Unsubscribe(nameof(CanCraft));
            Unsubscribe(nameof(OnDoorOpened));
            Unsubscribe(nameof(CanLootPlayer));
            Unsubscribe(nameof(OnLootPlayer));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(CanPickupEntity));
            Unsubscribe(nameof(CanPickupLock));
            Unsubscribe(nameof(OnItemPickup));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnCollectiblePickup));
            Unsubscribe(nameof(OnGrowableGather));
            Unsubscribe(nameof(OnDispenserGather));
            Unsubscribe(nameof(OnTurretTarget));
            Unsubscribe(nameof(CanBradleyApcTarget));
            Unsubscribe(nameof(CanHelicopterTarget));
            Unsubscribe(nameof(CanHelicopterStrafeTarget));
            Unsubscribe(nameof(OnHelicopterTarget));
            Unsubscribe(nameof(OnNpcTarget));
            Unsubscribe(nameof(OnPlayerVoice));
            Unsubscribe(nameof(CanMountEntity));
            Unsubscribe(nameof(CanDismountEntity));
        }
        #endregion

        #region Zone Creation
        private void UpdateZoneDefinition(Zone zone, string[] args, BasePlayer player = null)
        {
            for (int i = 0; i < args.Length; i = i + 2)
            {
                object editvalue;
                switch (args[i].ToLower())
                {
                    case "name":
                        editvalue = zone.definition.Name = args[i + 1];
                        break;

                    case "id":
                        editvalue = zone.definition.Id = args[i + 1];
                        break;

                    case "comfort":
                        editvalue = zone.definition.Comfort = Convert.ToSingle(args[i + 1]);
                        break;

                    case "temperature":
                        editvalue = zone.definition.Temperature = Convert.ToSingle(args[i + 1]);
                        break;

                    case "radiation":
                        editvalue = zone.definition.Radiation = Convert.ToSingle(args[i + 1]);
                        break;

                    case "safezone":
                        editvalue = zone.definition.SafeZone = Convert.ToBoolean(args[i + 1]);
                        break;

                    case "radius":
                        editvalue = zone.definition.Radius = Convert.ToSingle(args[i + 1]);
                        zone.definition.Size = Vector3.zero;
                        break;

                    case "rotation":
                        if (float.TryParse(args[i + 1], out float rotation))
                            zone.definition.Rotation = Quaternion.AngleAxis(rotation, Vector3.up).eulerAngles;
                        else zone.definition.Rotation = new Vector3(0, player?.GetNetworkRotation().eulerAngles.y ?? 0, 0);

                        editvalue = zone.definition.Rotation;
                        break;

                    case "location":
                        if (player && args[i + 1].Equals("here", StringComparison.OrdinalIgnoreCase))
                        {
                            editvalue = zone.definition.Location = player.transform.position;
                            break;
                        }

                        string[] location = args[i + 1].Trim().Split(' ');
                        if (location.Length == 3)
                            editvalue = zone.definition.Location = new Vector3(Convert.ToSingle(location[0]), Convert.ToSingle(location[1]), Convert.ToSingle(location[2]));
                        else
                        {
                            if (player)
                                SendMessage(player, "Invalid location format. Correct syntax is \"/zone location \"x y z\"\" - or - \"/zone location here\"");
                            continue;
                        }
                        break;

                    case "size":
                        string[] size = args[i + 1].Trim().Split(' ');
                        if (size.Length == 3)
                            editvalue = zone.definition.Size = new Vector3(Convert.ToSingle(size[0]), Convert.ToSingle(size[1]), Convert.ToSingle(size[2]));
                        else
                        {
                            if (player)
                                SendMessage(player, "Invalid size format, Correct syntax is \"/zone size \"x y z\"\"");
                            continue;
                        }
                        break;

                    case "enter_message":
                        editvalue = zone.definition.EnterMessage = args[i + 1];
                        break;

                    case "leave_message":
                        editvalue = zone.definition.LeaveMessage = args[i + 1];
                        break;

                    case "parentid":
                        editvalue = args[i + 1];
                        if (zones.TryGetValue((string)editvalue, out Zone parent))
                        {
                            zone.definition.ParentID = (string)editvalue;
                            zone.FindZoneParent();
                            UpdateZoneEntityFlags(zone);
                        }
                        else
                        {
                            if (player)
                                SendMessage(player, $"Unable to find zone with ID {editvalue}");
                            continue;
                        }
                        break;

                    case "permission":
                        string permission = args[i + 1];

                        if (!permission.StartsWith("zonemanager."))
                            permission = $"zonemanager.{permission}";

                        editvalue = zone.definition.Permission = permission;
                        break;

                    case "ejectspawns":
                        editvalue = zone.definition.EjectSpawns = args[i + 1];
                        break;

                    case "enabled":
                    case "enable":
                        if (!bool.TryParse(args[i + 1], out bool enabled))
                            enabled = false;

                        editvalue = zone.definition.Enabled = enabled;
                        break;

                    default:
                        if (!bool.TryParse(args[i + 1], out bool active))
                            active = false;

                        editvalue = active;

                        if (ZoneFlags.Find(args[i], out int v))
                        {
                            if (active)
                                zone.AddFlag(v);
                            else zone.RemoveFlag(v);
                        }
                        else
                        {
                            if (player != null)
                                SendMessage(player, $"Invalid zone flag: {args[i]}");
                        }
                        break;
                }
                if (player)
                    SendMessage(player, $"{args[i]} set to {editvalue}");
            }
        }
        #endregion

        #region Commands
        [ChatCommand("zone_add")]
        private void cmdChatZoneAdd(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            Zone.Definition definition = new Zone.Definition(player.transform.position) { Id = UnityEngine.Random.Range(1, 99999999).ToString() };

            CreateZone(definition);

            lastPlayerZone[player.userID] = definition.Id;

            SaveData();

            ShowZone(player, definition.Id);

            SendMessage(player, "You have successfully created a new zone with ID : {0}!\nYou can edit it using the /zone_edit command", definition.Id);
        }

        [ChatCommand("zone_wipe")]
        private void cmdChatZoneReset(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            foreach (KeyValuePair<string, Zone> kvp in zones)
                UnityEngine.Object.DestroyImmediate(kvp.Value.gameObject);

            zones.Clear();

            storedData.definitions.Clear();

            updateBehaviour.Reset();

            SaveData();

            SendMessage(player, "Wiped zone data");
        }

        [ChatCommand("zone_remove")]
        private void cmdChatZoneRemove(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            if (args.Length == 0)
            {
                SendMessage(player, "Invalid syntax! /zone_remove <zone ID>");
                return;
            }

            if (!zones.TryGetValue(args[0], out Zone zone))
            {
                SendMessage(player, "A zone with the specified ID does not exist");
                return;
            }

            zones.Remove(args[0]);
            UnityEngine.Object.DestroyImmediate(zone.gameObject);
            SaveData();

            SendMessage(player, "Successfully removed zone : {0}", args[0]);
        }

        [ChatCommand("zone_stats")]
        private void cmdChatZoneStats(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            SendMessage(player, "Zones : {0}", zones.Count);
            SendMessage(player, "Players in Zones: {0}", zonedPlayers.Count);
            SendMessage(player, "Entities in Zones: {0}", zonedEntities.Count);
        }

        [ChatCommand("zone_edit")]
        private void cmdChatZoneEdit(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            string zoneId;
            if (args.Length == 0)
            {
                if (!zonedPlayers.TryGetValue(player.userID, out EntityZones entityZones) || entityZones.Count != 1)
                {
                    SendMessage(player, "You must enter a zone ID. /zone_edit <zone ID>");
                    return;
                }
                zoneId = entityZones.Zones.First().definition.Id;
            }
            else zoneId = args[0];

            if (!zones.ContainsKey(zoneId))
            {
                SendMessage(player, "The specified zone does not exist");
                return;
            }

            lastPlayerZone[player.userID] = zoneId;

            SendMessage(player, "You are now editing the zone with ID : {0}", zoneId);
            ShowZone(player, zoneId);
        }

        [ChatCommand("zone_list")]
        private void cmdChatZoneList(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            SendMessage(player, "--- Zone list ---");
            if (zones.Count == 0)
            {
                SendMessage(player, "None...");
                return;
            }

            foreach (KeyValuePair<string, Zone> zone in zones)
                SendMessage(player, $"ID: {zone.Key} - {zone.Value.definition.Name} - {zone.Value.definition.Location}");
        }

        [ChatCommand("zone")]
        private void cmdChatZone(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            if (!lastPlayerZone.TryGetValue(player.userID, out string zoneId))
            {
                SendMessage(player, "You must start editing a zone first. /zone_edit <zone ID>");
                return;
            }

            if (!zones.TryGetValue(zoneId, out Zone zone))
            {
                SendMessage(player, "Unable to find a zone with ID : {0}", zoneId);
                return;
            }

            if (args.Length == 0)
            {
                SendMessage(player, "/zone <option> <value>");
                string message = $"<color={Configuration.Notifications.Color}>Name:</color> {zone.definition.Name}";
                message += $"\n<color={Configuration.Notifications.Color}>Enabled:</color> {zone.definition.Enabled}";
                message += $"\n<color={Configuration.Notifications.Color}>ID:</color> {zone.definition.Id}";
                message += $"\n<color={Configuration.Notifications.Color}>Comfort:</color> {zone.definition.Comfort}";
                message += $"\n<color={Configuration.Notifications.Color}>Temperature:</color> {zone.definition.Temperature}";
                message += $"\n<color={Configuration.Notifications.Color}>Radiation:</color> {zone.definition.Radiation}";
                message += $"\n<color={Configuration.Notifications.Color}>Safe Zone?:</color> {zone.definition.SafeZone}";
                SendReply(player, message);

                message = $"<color={Configuration.Notifications.Color}>Radius:</color> {zone.definition.Radius}";
                message += $"\n<color={Configuration.Notifications.Color}>Location:</color> {zone.definition.Location}";
                message += $"\n<color={Configuration.Notifications.Color}>Size:</color> {zone.definition.Size}";
                message += $"\n<color={Configuration.Notifications.Color}>Rotation:</color> {zone.definition.Rotation}";
                SendReply(player, message);

                message = $"<color={Configuration.Notifications.Color}>Enter Message:</color> {zone.definition.EnterMessage}";
                message += $"\n<color={Configuration.Notifications.Color}>Leave Message:</color> {zone.definition.LeaveMessage}";
                SendReply(player, message);

                message = $"<color={Configuration.Notifications.Color}>Permission:</color> {zone.definition.Permission}";
                message += $"\n<color={Configuration.Notifications.Color}>Eject Spawnfile:</color> {zone.definition.EjectSpawns}";
                message += $"\n<color={Configuration.Notifications.Color}>Parent Zone ID:</color> {zone.definition.ParentID}";
                SendReply(player, message);

                SendReply(player, $"<color={Configuration.Notifications.Color}>Flags:</color> {zone.definition.Flags}");
                ShowZone(player, zoneId);
                return;
            }

            if (args[0].ToLower() == "flags")
            {
                OpenFlagEditor(player, zoneId);
                return;
            }

            if (args.Length % 2 != 0)
            {
                SendMessage(player, "Value missing. You must follow a option with a value");
                return;
            }
            UpdateZoneDefinition(zone, args, player);
            zone.Reset();
            SaveData();
            ShowZone(player, zoneId);
        }

        [ChatCommand("zone_flags")]
        private void cmdChatZoneFlags(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            if (!lastPlayerZone.TryGetValue(player.userID, out string zoneId))
            {
                SendMessage(player, "You must start editing a zone first. /zone_edit <zone ID>");
                return;
            }

            OpenFlagEditor(player, zoneId);
        }

        [ChatCommand("zone_player")]
        private void cmdChatZonePlayer(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            BasePlayer targetPlayer = player;
            if (args is { Length: > 0 })
            {
                targetPlayer = BasePlayer.Find(args[0]);
                if (!targetPlayer)
                {
                    SendMessage(player, "Unable to find a player with the specified information");
                    return;
                }
            }

            if (!zonedPlayers.TryGetValue(targetPlayer.userID, out EntityZones entityZones))
            {
                SendReply(player, "The specified player is not in any zone");
                return;
            }

            SendMessage(player, $"--- {targetPlayer.displayName} ---");
            SendMessage(player, $"Has Flags: {entityZones.Flags.ToString()}");
            SendMessage(player, "Is in zones:");

            foreach (Zone zone in entityZones.Zones)
                SendMessage(player, $"{zone.definition.Id}: {zone.definition.Name} - {zone.definition.Location}");
        }

        private RaycastHit[] m_RaycastBuffer = new RaycastHit[64];
        
        [ChatCommand("zone_entity")]
        private void cmdChatZoneEntity(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            BaseEntity baseEntity = null;
            int count = Physics.RaycastNonAlloc(player.eyes.HeadRay(), m_RaycastBuffer, 3f);

            for (int i = 0; i < count; i++)
            {
                RaycastHit raycastHit = m_RaycastBuffer[i];
                BaseEntity entity = raycastHit.GetEntity();
                if (entity && !entity.IsDestroyed)
                {
                    baseEntity = entity;
                    break;
                }
            }
            
            if (!baseEntity)
            {
                SendMessage(player, "No entity found");
                return;
            }

            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out EntityZones entityZones))
            {
                SendReply(player, "The specified entity is not in any zone");
                return;
            }

            SendMessage(player, $"--- {baseEntity.ShortPrefabName} ({baseEntity.net.ID}) ---");
            SendMessage(player, $"Has Flags: {entityZones.Flags.ToString()}");
            SendMessage(player, "Is in zones:");

            foreach (Zone zone in entityZones.Zones)
                SendMessage(player, $"{zone.definition.Id}: {zone.definition.Name} - {zone.definition.Location}");
        }

        [ConsoleCommand("zone")]
        private void ccmdZone(ConsoleSystem.Arg arg)
        {
            if (!HasPermission(arg, PERMISSION_ZONE))
            {
                SendReply(arg, "You don't have access to this command");
                return;
            }

            string zoneId = arg.GetString(0);
            if (!arg.HasArgs(3) || !zones.TryGetValue(zoneId, out Zone zone))
            {
                SendReply(arg, "Zone ID not found or too few arguments supplied: zone <zoneid> <arg> <value>");
                return;
            }

            string[] args = new string[arg.Args.Length - 1];
            Array.Copy(arg.Args, 1, args, 0, args.Length);

            UpdateZoneDefinition(zone, args, arg.Player());
            zone.Reset();
            SaveData();
        }
        #endregion

        #region UI
        const string ZMUI = "zmui.editor";
        #region Helper
        public static class UI
        {
            public static CuiElementContainer Container(string panel, string color, string min, string max, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = min, AnchorMax = max},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }
            public static void Panel(ref CuiElementContainer container, string panel, string color, string min, string max, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = min, AnchorMax = max },
                    CursorEnabled = cursor
                },
                panel);
            }
            public static void Label(ref CuiElementContainer container, string panel, string text, int size, string min, string max, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = min, AnchorMax = max }
                },
                panel);

            }
            public static void Button(ref CuiElementContainer container, string panel, string color, string text, int size, string min, string max, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = min, AnchorMax = max },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region Creation
        private const string COLOR1 = "0.168 0.168 0.168 0.9";
        private const string COLOR2 = "0.847 0.333 0.256 1";
        private const string COLOR3 = "0.447 0.898 0.447 1";
        
        private void OpenFlagEditor(BasePlayer player, string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
            {
                SendReply(player, $"Error getting zone object with ID: {zoneId}");
                CuiHelper.DestroyUi(player, ZMUI);
            }

            CuiElementContainer container = UI.Container(ZMUI, COLOR1, "0 0", "1 1", true);
            UI.Label(ref container, ZMUI, $"Zone Flag Editor", 18, "0 0.92", "1 1");
            UI.Label(ref container, ZMUI, $"Zone ID: {zoneId}\nName: {zone.definition.Name}\n{(zone.definition.Size != Vector3.zero ? $"Box Size: {zone.definition.Size}\nRotation: {zone.definition.Rotation}" : $"Radius: {zone.definition.Radius}\nSafe Zone: {zone.definition.SafeZone}")}", 13, "0.05 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Label(ref container, ZMUI, $"Comfort: {zone.definition.Comfort}\nRadiation: {zone.definition.Radiation}\nTemperature: {zone.definition.Temperature}\nZone Enabled: {zone.definition.Enabled}", 13, "0.25 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Label(ref container, ZMUI, $"Permission: {zone.definition.Permission}\nEject Spawnfile: {zone.definition.EjectSpawns}\nEnter Message: {zone.definition.EnterMessage}\nExit Message: {zone.definition.LeaveMessage}", 13, "0.5 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Button(ref container, ZMUI, COLOR2, "Exit", 12, "0.95 0.96", "0.99 0.99", $"zmui.editflag {zoneId} exit");

            int count = 0;

            foreach(KeyValuePair<string, int> kvp in ZoneFlags.NameToIndex.OrderBy(x => x.Key))
            {                
                bool value = zone.definition.Flags.HasFlag(kvp.Value);

                Vector4 position = GetButtonPosition(count);

                UI.Label(ref container, ZMUI, kvp.Key, 12, $"{position[0]} {position[1]}", $"{position[0] + ((position[2] - position[0]) / 2)} {position[3]}");
                UI.Button(ref container, ZMUI, value ? COLOR3 : COLOR2, value ? "Enabled" : "Disabled", 12, $"{position[0] + ((position[2] - position[0]) / 2)} {position[1]}", $"{position[2]} {position[3]}", $"zmui.editflag {zoneId} {kvp.Value} {!value}");

                count++;
            }

            CuiHelper.DestroyUi(player, ZMUI);
            CuiHelper.AddUi(player, container);
        }

        private Vector4 GetButtonPosition(int i)
        {
            int column = i == 0 ? 0 : ColumnNumber(4, i);
            int row = i - (column * 4);

            float offsetX = 0.04f + ((0.01f + 0.21f) * row);
            float offsetY = (0.76f - (column * 0.04f));

            return new Vector4(offsetX, offsetY, offsetX + 0.21f, offsetY + 0.03f);
        }

        private int ColumnNumber(int max, int count) => Mathf.FloorToInt(count / max);
        #endregion

        #region Commands
        [ConsoleCommand("zmui.editflag")]
        private void ccmdEditFlag(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;
            
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            string zoneId = arg.GetString(0);
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
            {
                SendReply(player, $"Error getting zone object with ID: {zoneId}");
                CuiHelper.DestroyUi(player, ZMUI);
            }


            if (arg.GetString(1) == "exit")
            {
                CuiHelper.DestroyUi(player, ZMUI);
                
                SaveData();

                NextTick(() =>
                {
                    if (NeedsUpdateSubscriptions())
                    {
                        UnsubscribeAll();
                        UpdateHookSubscriptions();
                    }
                    
                    UpdateZoneEntityFlags(zone);
                });
            }
            else
            {
                if (arg.GetBool(2))
                    zone.AddFlag(arg.GetInt(1));
                else zone.RemoveFlag(arg.GetInt(1));

                OpenFlagEditor(player, zoneId);
            }
        }
        #endregion
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Autolight Options")]
            public AutoLightOptions AutoLights { get; set; }

            [JsonProperty(PropertyName = "Notification Options")]
            public NotificationOptions Notifications { get; set; }

            [JsonProperty(PropertyName = "NPC players can deal player damage in zones with PvpGod flag")]
            public bool NPCHurtPvpGod { get; set; }

            [JsonProperty(PropertyName = "Allow decay damage in zones with Undestr flag")]
            public bool DecayDamageUndestr { get; set; }

            public class AutoLightOptions
            {
                [JsonProperty(PropertyName = "Time to turn lights on")]
                public float OnTime { get; set; }

                [JsonProperty(PropertyName = "Time to turn lights off")]
                public float OffTime { get; set; }

                [JsonProperty(PropertyName = "Lights require fuel to activate automatically")]
                public bool RequiresFuel { get; set; }
            }

            public class NotificationOptions
            {
                [JsonProperty(PropertyName = "Display notifications via PopupNotifications")]
                public bool Popups { get; set; }

                [JsonProperty(PropertyName = "Chat prefix")]
                public string Prefix { get; set; }

                [JsonProperty(PropertyName = "Chat color (hex)")]
                public string Color { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AutoLights = new ConfigData.AutoLightOptions
                {
                    OnTime = 18f,
                    OffTime = 6f,
                    RequiresFuel = true
                },
                Notifications = new ConfigData.NotificationOptions
                {
                    Color = "#d85540",
                    Popups = false,
                    Prefix = "[Zone Manager] :"
                },
                NPCHurtPvpGod = false,
                DecayDamageUndestr = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(3, 0, 0))
                Configuration = baseConfig;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            storedData.definitions.Clear();

            foreach (KeyValuePair<string, Zone> zone in zones)
                storedData.definitions.Add(zone.Value.definition);

            data.WriteObject(storedData);
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("ZoneManager/zone_data");
            data.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new Vector3Converter(), new ZoneFlagsConverter() };

            storedData = data.ReadObject<StoredData>();
            if (storedData == null)
                storedData = new StoredData();
        }

        private class StoredData
        {
            public HashSet<Zone.Definition> definitions = new HashSet<Zone.Definition>();
        }

        public class EntityZones
        {
            public ZoneFlags Flags { get; private set; }

            public HashSet<Zone> Zones { get; private set; }

            public EntityZones()
            {
                Zones = new HashSet<Zone>();
                Flags = new ZoneFlags();
            }

            public void AddFlags(ZoneFlags zoneFlags) => Flags.AddFlags(zoneFlags);
                        
            public void RemoveFlags(ZoneFlags zoneFlags) => Flags.RemoveFlags(zoneFlags);
                        
            public bool HasFlag(int flag) => Flags.HasFlag(flag);
            
            public void UpdateFlags()
            {
                Flags.Clear();


                foreach (Zone zone in Zones)
                {
                    if (!zone)
                        continue;

                    tempFlags.Clear();

                    tempFlags.AddFlags(zone.definition.Flags);
                    tempFlags.RemoveFlags(zone.disabledFlags);

                    AddFlags(tempFlags);
                }

                foreach (Zone zone in Zones)
                {
                    if (!zone)
                        continue;

                    if (zone.parent && Zones.Contains(zone.parent))
                        RemoveFlags(zone.parent.definition.Flags);
                }
            }

            public bool EnterZone(Zone zone)
            {
                return Zones.Add(zone);
            }

            public bool LeaveZone(Zone zone)
            {
                return Zones.Remove(zone);
            }

            public bool IsInZone(Zone zone)
            {
                return Zones.Contains(zone);
            }

            public bool IsInZone(string zoneId)
            {
                return Zones.Select(x => x.definition.Id).Contains(zoneId);
            }

            public bool ShouldRemove() => Count == 0;

            public int Count => Zones.Count;
        }

        private class Vector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class ZoneFlagsConverter : JsonConverter
        {
            private const string SEPERATOR = ", ";

            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                ZoneFlags zoneFlags = (ZoneFlags)value;

                sb.Clear();

                foreach(KeyValuePair<string, int> flag in ZoneFlags.NameToIndex)
                {
                    if (zoneFlags.HasFlag(flag.Value))
                    {
                        sb.Append(sb.Length == 0 ? flag.Key : SEPERATOR + flag.Key);
                    }
                }

                writer.WriteValue(sb.ToString());
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                ZoneFlags zoneFlags = new ZoneFlags();

                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Split(',');
                    for (int i = 0; i < values.Length; i++)
                    {
                        string value = values[i].Trim();

                        if (ZoneFlags.NameToIndex.TryGetValue(value, out int v))                        
                            zoneFlags.AddFlag(v);                       
                    }
                }
                return zoneFlags;
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(ZoneFlags);
            }
        }
        #endregion

        #region Localization
        private string Message(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["noBuild"] = "You are not allowed to build in this area!",
            ["noUpgrade"] = "You are not allowed to upgrade structures in this area!",
            ["noDeploy"] = "You are not allowed to deploy items in this area!",
            ["noCup"] = "You are not allowed to deploy cupboards in this area!",
            ["noChat"] = "You are not allowed to chat in this area!",
            ["noSuicide"] = "You are not allowed to suicide in this area!",
            ["noGather"] = "You are not allowed to gather in this area!",
            ["noLoot"] = "You are not allowed loot in this area!",
            ["noSignUpdates"] = "You can not update signs in this area!",
            ["noOvenToggle"] = "You can not toggle ovens and lights in this area!",
            ["noPickup"] = "You can not pick up objects in this area!",
            ["noVending"] = "You can not use vending machines in this area!",
            ["noStash"] = "You can not hide a stash in this area!",
            ["noCraft"] = "You can not craft in this area!",
            ["eject"] = "You are not allowed in this area!",
            ["attract"] = "You are not allowed to leave this area!",
            ["kill"] = "Access to this area is restricted!",
            ["noVoice"] = "You are not allowed to voice chat in this area!",
            ["novehiclesenter"] = "Vehicles are not allowed in this area!",
            ["novehiclesleave"] = "Vehicles are not allowed to leave this area!",
            ["novehiclemounting"] = "You are not allowed to mount vehicles in this area!",
            ["novehicledismounting"] = "You are not allowed to dismount vehicles in this area!",
            ["nosprays"] = "You are not allowed to spray paint in this area!"
        };
        #endregion
    }
}


// --- End of file: ZoneManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-perms ---
// --- Original File Path: Z/ZonePerms/ZonePerms.cs ---

﻿// Requires: ZoneManager
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Zone Perms", "MisterPixie", "1.1.0")]
    [Description("Grant players permissions when entering a zone.")]
    class ZonePerms : RustPlugin
    {
        [PluginReference] Plugin ZoneManager;

        #region Data Related
        private Dictionary<ulong, ZonePermsData> _zonePermsData = new Dictionary<ulong, ZonePermsData>();

        private class ZonePermsData
        {
            public List<string> permission, groups;

            public ZonePermsData()
            {
                permission = new List<string>();
                groups = new List<string>();
            }
        }


        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("ZonePermsData", _zonePermsData);
        }

        private void Unload()
        {
            foreach (var player in _zonePermsData)
            {
                foreach (var perm in player.Value.permission)
                {
                    permission.RevokeUserPermission(player.Key.ToString(), perm);
                }

                foreach (var group in player.Value.groups)
                {
                    permission.RemoveUserGroup(player.Key.ToString(), group);
                }
            }
            _zonePermsData.Clear();
            SaveData();
        }

        private void OnServerSave()
        {
            SaveData();
        }
        #endregion

        #region Hooks
        private void Init()
        {
            LoadVariables();
            _zonePermsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ZonePermsData>>("ZonePermsData");
        }

        private void OnEnterZone(string ZoneID, BasePlayer player)
        {
            if (!configData.Enable)
                return;

            ZoneAddons zoneaddvalue;
            ZonePermsData zonesvalue;

            if (configData.Zones.TryGetValue(ZoneID, out zoneaddvalue))
            {
                if (!zoneaddvalue.EnableZone)
                {
                    return;
                }

                if (!_zonePermsData.TryGetValue(player.userID, out zonesvalue))
                {
                    _zonePermsData.Add(player.userID, new ZonePermsData());
                }

                for (var i = 0; i < zoneaddvalue.OnZoneEnter.Permissions.Count; i++)
                {
                    permission.GrantUserPermission(player.UserIDString, zoneaddvalue.OnZoneEnter.Permissions[i], null);
                }

                for (var i = 0; i < zoneaddvalue.OnZoneEnter.Groups.Count; i++)
                {
                    permission.AddUserGroup(player.UserIDString, zoneaddvalue.OnZoneEnter.Groups[i]);
                }

                _zonePermsData[player.userID].groups.AddRange(zoneaddvalue.OnZoneExit.Groups);
                _zonePermsData[player.userID].permission.AddRange(zoneaddvalue.OnZoneExit.Permissions);

                SaveData();

            }
        }

        private void OnExitZone(string ZoneID, BasePlayer player)
        {
            if (!configData.Enable)
                return;

            ZoneAddons zoneaddvalue;
            ZonePermsData zonesvalue;

            if (configData.Zones.TryGetValue(ZoneID, out zoneaddvalue))
            {
                if (!zoneaddvalue.EnableZone)
                {
                    return;
                }

                if (_zonePermsData.TryGetValue(player.userID, out zonesvalue))
                {
                    for (var i = 0; i < zoneaddvalue.OnZoneExit.Permissions.Count; i++)
                    {
                        permission.RevokeUserPermission(player.UserIDString, zoneaddvalue.OnZoneExit.Permissions[i]);
                        zonesvalue.permission.Remove(zoneaddvalue.OnZoneExit.Permissions[i]);
                    }

                    for (var i = 0; i < zoneaddvalue.OnZoneExit.Groups.Count; i++)
                    {
                        permission.RemoveUserGroup(player.UserIDString, zoneaddvalue.OnZoneExit.Groups[i]);
                        zonesvalue.groups.Remove(zoneaddvalue.OnZoneExit.Groups[i]);
                    }
                }

                _zonePermsData.Remove(player.userID);
                SaveData();
            }
        }

        #endregion

        #region Config

        private class ZoneAddons
        {
            public bool EnableZone;
            public OnEnter OnZoneEnter;
            public OnExit OnZoneExit;
        }

        private class OnEnter
        {
            public List<string> Permissions;
            public List<string> Groups;
        }

        private class OnExit
        {
            public List<string> Permissions;
            public List<string> Groups;
        }

        private ConfigData configData;
        private class ConfigData
        {
            public bool Enable;
            public Dictionary<string, ZoneAddons> Zones;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Enable = false,
                Zones = new Dictionary<string, ZoneAddons>
                {
                    ["431235"] = new ZoneAddons()
                    {
                        EnableZone = false,
                        OnZoneEnter = new OnEnter()
                        {
                            Permissions = new List<string>
                            {
                                "permission1",
                                "permission2"
                            },
                            Groups = new List<string>
                            {
                                "group1",
                                "group2"
                            }
                        },
                        OnZoneExit = new OnExit()
                        {
                            Permissions = new List<string>
                            {
                                "permission1",
                                "permission2"
                            },
                            Groups = new List<string>
                            {
                                "group1",
                                "group2"
                            }
                        }
                    },
                    ["749261"] = new ZoneAddons()
                    {
                        EnableZone = false,
                        OnZoneEnter = new OnEnter()
                        {
                            Permissions = new List<string>
                            {
                                "permission1",
                                "permission2"
                            },
                            Groups = new List<string>
                            {
                                "group1",
                                "group2"
                            }
                        },
                        OnZoneExit = new OnExit()
                        {
                            Permissions = new List<string>
                            {
                                "permission1",
                                "permission2"
                            },
                            Groups = new List<string>
                            {
                                "group1",
                                "group2"
                            }
                        }
                    }
                }

            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: ZonePerms.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-vending ---
// --- Original File Path: Z/ZoneVending/ZoneVending.cs ---

// Requires: ZoneManager

using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
	[Info("Zone Vending", "rostov114", "0.3.5")]
	[Description("Changing the logic of work of vending machines inside the zone.")]
	class ZoneVending : RustPlugin
	{
		#region References
		[PluginReference] private Plugin ZoneManager;
		#endregion

		#region Variables
		private Dictionary<NetworkableId, bool> vendingMachineCache = new Dictionary<NetworkableId, bool>();
		#endregion


		#region Configuration 0.3.5
		private Configuration _config;
		public class Configuration
		{
			[JsonProperty("Remove payment item")]
			public bool RemovePayment = true;

			[JsonProperty("List zones")]
			public List<string> Zones = new List<string>();
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				_config = Config.ReadObject<Configuration>();
				SaveConfig();
			}
			catch
			{
				PrintError("Error reading config, please check!");

				Unsubscribe(nameof(OnGiveSoldItem));
				Unsubscribe(nameof(OnTakeCurrencyItem));
				Unsubscribe(nameof(OnEntityKill));
			}
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(_config);
		#endregion

		#region OxideHooks
		private void OnServerInitialized()
		{
			if (!_config.RemovePayment)
			{
				Unsubscribe(nameof(OnTakeCurrencyItem));
			}
		}

		private void OnGiveSoldItem(VendingMachine vending, Item soldItem, BasePlayer buyer)
		{
			if (this.CheckZone(vending) && Interface.Oxide.CallHook("CanGiveSoldItem", vending, soldItem, buyer) == null)
			{
				Item item = ItemManager.Create(soldItem.info, soldItem.amount, soldItem.skin);
				item.OnVirginSpawn();

				vending.transactionActive = true;
				if (!item.MoveToContainer(vending.inventory, -1, true))
				{
					PrintWarning(string.Concat(new string[]
					{
						"Vending machine unable to refill item :",
						soldItem.info.shortname,
						" buyer :",
						buyer.displayName
					}));
					item.Remove(0f);
				}
				vending.transactionActive = false;
			}
		}

		private object OnTakeCurrencyItem(VendingMachine vending, Item takenCurrencyItem)
		{
			if (this.CheckZone(vending) && Interface.Oxide.CallHook("CanTakeCurrencyItem", vending, takenCurrencyItem) == null)
			{
				takenCurrencyItem.MoveToContainer(vending.inventory, -1, true);
				takenCurrencyItem.RemoveFromContainer();
				takenCurrencyItem.Remove(0f);

				return true;
			}

			return null;
		}

		private void OnEntityKill(BaseNetworkable entity)
		{
			if (entity?.net?.ID != null && entity is VendingMachine && this.vendingMachineCache.ContainsKey(entity.net.ID))
				this.vendingMachineCache.Remove(entity.net.ID);
		}
		#endregion

		#region Helpers
		private bool CheckZone(VendingMachine vending)
		{
			if (vending?.net?.ID == null)
				return false;

			if (this.vendingMachineCache.ContainsKey(vending.net.ID))
				return this.vendingMachineCache[vending.net.ID];

			if (_config.Zones.Count > 0)
			{
				string[] zmloc = ZoneManager?.Call<string[]>("GetEntityZoneIDs", (vending as BaseEntity));
				if (zmloc != null && zmloc.Length > 0)
				{
					foreach (string zone in zmloc)
					{
						if (_config.Zones.Contains(zone))
						{
							this.vendingMachineCache.Add(vending.net.ID, true);
							return true;
						}
					}
				}
			}

			this.vendingMachineCache.Add(vending.net.ID, false);
			return false;
		}
		#endregion
	}
}

// --- End of file: ZoneVending.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-pvx-info ---
// --- Original File Path: Z/ZonePVxInfo/ZonePVxInfo.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

// ** Thanks to previous mantainers BuzZ[PHOQUE]/Arainrr (upto - v1.1.5) ** \\

namespace Oxide.Plugins
{
    [Info("Zone PVx Info", "Mabel", "1.1.9")]
    [Description("HUD on PVx name defined Zones")]
    public class ZonePVxInfo : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin ZoneManager, DynamicPVP, RaidableBases, AbandonedBases, TruePVE, DangerousTreasures;

        private const string UinameMain = "ZonePVxInfoUI";
        private bool _pvpAll;

        private enum PVxType { PVE, PVP, PVPDelay }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            AddCovalenceCommand("pvpall", nameof(CmdServerPVx));
            if (configData.defaultType == PVxType.PVPDelay)
            {
                configData.defaultType = PVxType.PVE;
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (_pvpAll)
            {
                CreatePVxUI(player, PVxType.PVP);
            }
            else
            {
                CheckPlayerZone(player);
            }
        }

        #endregion Oxide Hooks

        #region ZoneManager

        private string GetZoneName(string zoneId)
        {
            return (string)ZoneManager.Call("GetZoneName", zoneId);
        }

        private string[] GetPlayerZoneIDs(BasePlayer player)
        {
            return (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
        }

        private float GetZoneRadius(string zoneId)
        {
            var obj = ZoneManager.Call("GetZoneRadius", zoneId); ;
            if (obj is float)
            {
                return (float)obj;
            }
            return 0f;
        }

        private Vector3 GetZoneSize(string zoneId)
        {
            var obj = ZoneManager.Call("GetZoneSize", zoneId); ;
            if (obj is Vector3)
            {
                return (Vector3)obj;
            }
            return Vector3.zero;
        }

        private void OnEnterZone(string zoneId, BasePlayer player)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        private void OnExitZone(string zoneId, BasePlayer player)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        private void CheckPlayerZone(BasePlayer player, bool checkPVPDelay = true)
        {
            if (_pvpAll || player == null || !player.IsConnected || !player.userID.IsSteamId()) return;
            if (checkPVPDelay && IsPlayerInPVPDelay(player.userID))
            {
                CreatePVxUI(player, PVxType.PVPDelay);
                return;
            }
            if (ZoneManager != null)
            {
                var zoneName = GetSmallestZoneName(player);
                if (!string.IsNullOrEmpty(zoneName))
                {
                    if (zoneName.Contains("pvp", CompareOptions.IgnoreCase))
                    {
                        CreatePVxUI(player, PVxType.PVP);
                        return;
                    }

                    if (zoneName.Contains("pve", CompareOptions.IgnoreCase))
                    {
                        CreatePVxUI(player, PVxType.PVE);
                        return;
                    }
                }
            }

            if (configData.showDefault)
            {
                CreatePVxUI(player, configData.defaultType);
            }
            else
            {
                DestroyUI(player);
            }
        }

        private string GetSmallestZoneName(BasePlayer player)
        {
            float radius = float.MaxValue;
            string smallest = null;
            var zoneIDs = GetPlayerZoneIDs(player);
            foreach (var zoneId in zoneIDs)
            {
                var zoneName = GetZoneName(zoneId);
                if (string.IsNullOrEmpty(zoneName)) continue;
                float zoneRadius;
                var zoneSize = GetZoneSize(zoneId);
                if (zoneSize != Vector3.zero)
                {
                    zoneRadius = (zoneSize.x + zoneSize.z) / 2;
                }
                else
                {
                    zoneRadius = GetZoneRadius(zoneId);
                }
                if (zoneRadius <= 0f)
                {
                    continue;
                }
                if (radius >= zoneRadius)
                {
                    radius = zoneRadius;
                    smallest = zoneName;
                }
            }
            return smallest;
        }

        #endregion ZoneManager

        #region RaidableBases

        private void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 location, bool allowPVP)
        {
            if (_pvpAll) return;
            CreatePVxUI(player, allowPVP ? PVxType.PVP : PVxType.PVE);
        }

        private void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 location, bool allowPVP)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        private void OnRaidableBaseEnded(Vector3 raidPos, int mode, float loadingTime)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CheckPlayerZone(player);
            }
        }

        #endregion RaidableBases

        #region AbandonedBases

        void OnPlayerEnteredAbandonedBase(BasePlayer player, Vector3 eventPos, float radius, bool allowPVP)
        {
            if (_pvpAll) return;
            CreatePVxUI(player, allowPVP ? PVxType.PVP : PVxType.PVE);
        }

        void OnPlayerExitedAbandonedBase(BasePlayer player)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        void OnAbandonedBaseEnded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CheckPlayerZone(player);
            }
        }

        #endregion AbandonedBases

        #region DangerousTreasures

        void OnPlayerEnteredDangerousEvent(BasePlayer player, Vector3 containerPos, bool allowPVP)
        {
            if (_pvpAll) return;
            CreatePVxUI(player, allowPVP ? PVxType.PVP : PVxType.PVE);
        }

        void OnPlayerExitedDangerousEvent(BasePlayer player)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        #endregion DangerousTreasures

        #region Adem Events

        void OnPlayerEnterConvoy(BasePlayer player)
        {
            if (configData.AdemEventSettings.convoyEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitConvoy(BasePlayer player)
        {
            if (configData.AdemEventSettings.convoyEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterArmoredTrain(BasePlayer player)
        {
            if (configData.AdemEventSettings.armoredTrainEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitArmoredTrain(BasePlayer player)
        {
            if (configData.AdemEventSettings.armoredTrainEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterCaravan(BasePlayer player)
        {
            if (configData.AdemEventSettings.caravanEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitCaravan(BasePlayer player)
        {
            if (configData.AdemEventSettings.caravanEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterSputnik(BasePlayer player)
        {
            if (configData.AdemEventSettings.sputnikEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitSputnik(BasePlayer player)
        {
            if (configData.AdemEventSettings.sputnikEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterSpace(BasePlayer player)
        {
            if (configData.AdemEventSettings.spaceEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitSpace(BasePlayer player)
        {
            if (configData.AdemEventSettings.spaceEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterShipwreck(BasePlayer player)
        {
            if (configData.AdemEventSettings.shipwreckEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitShipwreck(BasePlayer player)
        {
            if (configData.AdemEventSettings.shipwreckEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }
        #endregion Adem Events

        #region KpucTaJl Events
        void OnPlayerEnterPowerPlantEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.powerPlantEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitPowerPlantEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.powerPlantEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterFerryTerminalEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.ferryTerminalEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitFerryTerminalEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.ferryTerminalEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterSupermarketEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.supermarketEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitSupermarketEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.supermarketEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterJunkyardEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.junkyardEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitJunkyardEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.junkyardEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterArcticBaseEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.arcticEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitArcticBaseEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.arcticEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterGasStationEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.gasStationEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitGasStationEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.gasStationEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterAirEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.airEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitAirEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.airEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterHarborEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.harborEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitHarborEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.harborEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterSatDishEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.satDishEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitSatDishEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.satDishEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterWaterEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.waterEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitWaterEvent(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.waterEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterTriangulation(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.triangulationEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitTriangulation(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.triangulationEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        void OnPlayerEnterDefendableHomes(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.defendableHomesEvent)
            {
                if (_pvpAll) return;
                CreatePVxUI(player, PVxType.PVP);
            }
        }

        void OnPlayerExitDefendableHomes(BasePlayer player)
        {
            if (configData.KpucTaJlEventSettings.defendableHomesEvent)
            {
                NextTick(() => CheckPlayerZone(player));
            }
        }

        #endregion KpucTaJl Events

        #region CargoTrainTunnel

        private void OnPlayerEnterPVPBubble(TrainEngine trainEngine, BasePlayer player)
        {
            if (_pvpAll) return;
            CreatePVxUI(player, PVxType.PVP);
        }

        private void OnPlayerExitPVPBubble(TrainEngine trainEngine, BasePlayer player)
        {
            NextTick(() => CheckPlayerZone(player));
        }

        private void OnTrainEventEnded(TrainEngine trainEngine)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CheckPlayerZone(player);
            }
        }

        #endregion CargoTrainTunnel

        #region PVPDelay

        private void OnPlayerRemovedFromPVPDelay(ulong playerId, string zoneId) // DynamicPVP
        {
            var player = BasePlayer.FindByID(playerId);
            if (player == null) return;
            CheckPlayerZone(player, false);
        }

        private void OnPlayerPvpDelayExpired(BasePlayer player) // RaidableBases
        {
            if (player == null) return;
            CheckPlayerZone(player, false);
        }

        void OnPlayerPvpDelayExpiredII(BasePlayer player) // AbandonedBases
        {
            if (player == null) return;
            CheckPlayerZone(player, false);
        }

        private bool IsPlayerInPVPDelay(ulong playerID)
        {
            if (DynamicPVP != null && Convert.ToBoolean(DynamicPVP?.Call("IsPlayerInPVPDelay", playerID))) { return true; } // DynamicPVP

            if (RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("HasPVPDelay", playerID))) { return true; } // RaidableBases

            return false;
        }

        void OnPlayerPvpDelayStart(BasePlayer player) // AbandonedBases
        {
            CreatePVxUI(player, PVxType.PVPDelay);
        }
        #endregion PVPDelay

        #region Commands

        private void CmdServerPVx(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.IsAdmin) return;
            if (args == null || args.Length < 1) return;
            switch (args[0].ToLower())
            {
                case "0":
                case "off":
                case "false":
                    _pvpAll = false;
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        CheckPlayerZone(player);
                    }
                    return;

                case "1":
                case "on":
                case "true":
                    _pvpAll = true;
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        CreatePVxUI(player, PVxType.PVP);
                    }
                    return;
            }
        }

        #endregion Commands

        #region UI

        private void CreatePVxUI(BasePlayer player, PVxType type)
        {
            UiSettings settings;
            if (!configData.UISettings.TryGetValue(type, out settings) || string.IsNullOrEmpty(settings.Json))
            {
                return;
            }
            CuiHelper.DestroyUi(player, UinameMain);
            CuiHelper.AddUi(player, settings.Json);
        }

        private static void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UinameMain);
        }

        private static string GetCuiJson(UiSettings settings)
        {
            return new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = settings.BackgroundColor, FadeIn = settings.FadeIn,},
                        RectTransform = {AnchorMin = settings.MinAnchor, AnchorMax = settings.MaxAnchor, OffsetMin = settings.MinOffset, OffsetMax = settings.MaxOffset,},
                        FadeOut = settings.FadeOut,
                    },
                    settings.Layer, UinameMain
                },
                {
                    new CuiLabel
                    {
                        Text = {Text = settings.Text, FontSize = settings.TextSize, Align = TextAnchor.MiddleCenter, Color = settings.TextColor, FadeIn = settings.FadeIn,},
                        RectTransform = {AnchorMin = "0.05 0.05", AnchorMax = "0.95 0.95"}, FadeOut = settings.FadeOut,
                    },
                    UinameMain, CuiHelper.GetGuid()
                }
            }.ToJson();
        }

        #endregion UI

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Show Default PVx UI")] public bool showDefault = true;

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Server Default PVx (pvp or pve)")] public PVxType defaultType = PVxType.PVE;

            [JsonProperty(PropertyName = "Pvx UI Settings")]
            public Dictionary<PVxType, UiSettings> UISettings { get; set; } = new Dictionary<PVxType, UiSettings>
            {
                [PVxType.PVE] = new UiSettings
                {
                    Text = "PVE",
                    TextSize = 14,
                    TextColor = "1 1 1 1",
                    BackgroundColor = "0.3 0.8 0.1 0.8"
                },
                [PVxType.PVP] = new UiSettings
                {
                    Text = "PVP",
                    TextSize = 14,
                    TextColor = "1 1 1 1",
                    BackgroundColor = "0.8 0.2 0.2 0.8"
                },
                [PVxType.PVPDelay] = new UiSettings
                {
                    Text = "PVP Delay",
                    TextSize = 12,
                    TextColor = "1 1 1 1",
                    BackgroundColor = "0.8 0.5 0.1 0.8"
                }
            };

            [JsonProperty(PropertyName = "Adem Event Settings")]
            public AdemEventSettings AdemEventSettings { get; set; } = new AdemEventSettings
            {
                convoyEvent = false,
                armoredTrainEvent = false,
                caravanEvent = false,
                sputnikEvent = false,
                spaceEvent = false,
                shipwreckEvent = false,
            };

            [JsonProperty(PropertyName = "KpucTaJl Event Settings")]
            public KpucTaJlEventSettings KpucTaJlEventSettings { get; set; } = new KpucTaJlEventSettings
            {
                powerPlantEvent = false,
                ferryTerminalEvent = false,
                supermarketEvent = false,
                junkyardEvent = false,
                arcticEvent = false,
                gasStationEvent = false,
                airEvent = false,
                harborEvent = false,
                satDishEvent = false,
                waterEvent = false,
                triangulationEvent = false,
                defendableHomesEvent = false,
            };
        }

        private class UiSettings
        {
            [JsonProperty(PropertyName = "Min Anchor")] public string MinAnchor { get; set; } = "0.5 0";

            [JsonProperty(PropertyName = "Max Anchor")] public string MaxAnchor { get; set; } = "0.5 0";

            [JsonProperty(PropertyName = "Min Offset")] public string MinOffset { get; set; } = "190 30";

            [JsonProperty(PropertyName = "Max Offset")] public string MaxOffset { get; set; } = "250 60";

            [JsonProperty(PropertyName = "Layer")] public string Layer { get; set; } = "Hud";

            [JsonProperty(PropertyName = "Text")] public string Text { get; set; } = "PVP";

            [JsonProperty(PropertyName = "Text Size")] public int TextSize { get; set; } = 12;

            [JsonProperty(PropertyName = "Text Color")] public string TextColor { get; set; } = "1 1 1 1";

            [JsonProperty(PropertyName = "Background Color")] public string BackgroundColor { get; set; } = "0.8 0.5 0.1 0.8";

            [JsonProperty(PropertyName = "Fade In")] public float FadeIn { get; set; } = 0.25f;

            [JsonProperty(PropertyName = "Fade Out")] public float FadeOut { get; set; } = 0.25f;

            private string _json;

            [JsonIgnore]
            public string Json
            {
                get
                {
                    if (string.IsNullOrEmpty(_json))
                    {
                        _json = GetCuiJson(this);
                    }
                    return _json;
                }
            }
        }

        private class AdemEventSettings
        {
            [JsonProperty(PropertyName = "Convoy Event")] public bool convoyEvent { get; set; }

            [JsonProperty(PropertyName = "Armored Train Event")] public bool armoredTrainEvent { get; set; }

            [JsonProperty(PropertyName = "Caravan Event")] public bool caravanEvent { get; set; }

            [JsonProperty(PropertyName = "Sputnik Event")] public bool sputnikEvent { get; set; }

            [JsonProperty(PropertyName = "Space Event")] public bool spaceEvent { get; set; }

            [JsonProperty(PropertyName = "Shipwreck Event")] public bool shipwreckEvent { get; set; }
        }

        private class KpucTaJlEventSettings
        {
            [JsonProperty(PropertyName = "Power Plant Event")] public bool powerPlantEvent { get; set; }

            [JsonProperty(PropertyName = "Ferry Terminal Event")] public bool ferryTerminalEvent { get; set; }

            [JsonProperty(PropertyName = "Supermarket Event")] public bool supermarketEvent { get; set; }

            [JsonProperty(PropertyName = "Junkyard Event")] public bool junkyardEvent { get; set; }

            [JsonProperty(PropertyName = "Arctic Base Event")] public bool arcticEvent { get; set; }

            [JsonProperty(PropertyName = "Gas Station Event")] public bool gasStationEvent { get; set; }

            [JsonProperty(PropertyName = "Air Event")] public bool airEvent { get; set; }

            [JsonProperty(PropertyName = "Harbor Event")] public bool harborEvent { get; set; }

            [JsonProperty(PropertyName = "Satellite Dish Event")] public bool satDishEvent { get; set; }

            [JsonProperty(PropertyName = "Water Event")] public bool waterEvent { get; set; }

            [JsonProperty(PropertyName = "Triangulation Event")] public bool triangulationEvent { get; set; }

            [JsonProperty(PropertyName = "Defendable Homes Event")] public bool defendableHomesEvent { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }
        #endregion ConfigurationFile
    }
}

// --- End of file: ZonePVxInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zlevels-remastered ---
// --- Original File Path: Z/ZLevelsRemastered/ZLevelsRemastered.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using Rust;

namespace Oxide.Plugins
{
    [Info("ZLevels Remastered", "nivex", "3.2.2")]
    [Description("Lets players level up as they harvest different resources and when crafting")]

    class ZLevelsRemastered : RustPlugin
    {
        [PluginReference]
        Plugin EventManager, CraftingController, ZoneManager, Economics, IQEconomic, ServerRewards, SkillTree;

        private StoredData data = new();
        private Dictionary<string, ItemDefinition> CraftItems;
        private CraftData _craftData = new();
        private StringBuilder _sb = new();
        private bool newSaveDetected;
        private bool bonusOn;
        private int MaxB = 10001;
        private int MinB = 10;

        public enum Skills
        {
            ACQUIRE,
            CRAFTING,
            MINING,
            SKINNING,
            WOODCUTTING,
            ALL
        }

        private Skills[] AllSkills = new Skills[] { Skills.ACQUIRE, Skills.CRAFTING, Skills.MINING, Skills.SKINNING, Skills.WOODCUTTING };

        private class CraftData
        {
            public Dictionary<string, CraftInfo> CraftList = new();
            public CraftData() { }
        }

        private class CraftInfo
        {
            public int MaxBulkCraft;
            public int MinBulkCraft;
            public string shortName;
            public bool Enabled;
            public CraftInfo() { }
        }

        private class StoredData
        {
            public Hash<ulong, PlayerInfo> PlayerInfo = new();
            public StoredData() { }
        }

        private enum LevelType
        {
            ACQUIRE_LEVEL,
            ACQUIRE_POINTS,
            CRAFTING_LEVEL,
            CRAFTING_POINTS,
            MINING_LEVEL,
            MINING_POINTS,
            WOODCUTTING_LEVEL,
            WOODCUTTING_POINTS,
            SKINNING_LEVEL,
            SKINNING_POINTS,
            LAST_DEATH,
            XP_MULTIPLIER,
        }

        private class PlayerInfo : IEquatable<PlayerInfo>
        {
            private double _acquireLevel = 1.0;
            private double _acquirePoints = 10.0;
            private double _craftingLevel = 1.0;
            private double _craftingPoints = 10.0;
            private double _miningLevel = 1.0;
            private double _miningPoints = 10.0;
            private double _skinningLevel = 1.0;
            private double _skinningPoints = 10.0;
            private double _woodcuttingLevel = 1.0;
            private double _woodcuttingPoints = 10.0;
            private double _lastDeath = 0.0;
            private double _xpMultiplier = 100.0;

            private double RoundValue(double value) => Math.Round(value, 2, MidpointRounding.AwayFromZero);

            [JsonProperty(PropertyName = "AL")]
            public double ACQUIRE_LEVEL
            {
                get => RoundValue(_acquireLevel);
                set => _acquireLevel = RoundValue(value);
            }

            [JsonProperty(PropertyName = "AP")]
            public double ACQUIRE_POINTS
            {
                get => RoundValue(_acquirePoints);
                set => _acquirePoints = RoundValue(value);
            }

            [JsonProperty(PropertyName = "CL")]
            public double CRAFTING_LEVEL
            {
                get => RoundValue(_craftingLevel);
                set => _craftingLevel = RoundValue(value);
            }

            [JsonProperty(PropertyName = "CP")]
            public double CRAFTING_POINTS
            {
                get => RoundValue(_craftingPoints);
                set => _craftingPoints = RoundValue(value);
            }

            [JsonProperty(PropertyName = "ML")]
            public double MINING_LEVEL
            {
                get => RoundValue(_miningLevel);
                set => _miningLevel = RoundValue(value);
            }

            [JsonProperty(PropertyName = "MP")]
            public double MINING_POINTS
            {
                get => RoundValue(_miningPoints);
                set => _miningPoints = RoundValue(value);
            }

            [JsonProperty(PropertyName = "SL")]
            public double SKINNING_LEVEL
            {
                get => RoundValue(_skinningLevel);
                set => _skinningLevel = RoundValue(value);
            }

            [JsonProperty(PropertyName = "SP")]
            public double SKINNING_POINTS
            {
                get => RoundValue(_skinningPoints);
                set => _skinningPoints = RoundValue(value);
            }

            [JsonProperty(PropertyName = "WCL")]
            public double WOODCUTTING_LEVEL
            {
                get => RoundValue(_woodcuttingLevel);
                set => _woodcuttingLevel = RoundValue(value);
            }

            [JsonProperty(PropertyName = "WCP")]
            public double WOODCUTTING_POINTS
            {
                get => RoundValue(_woodcuttingPoints);
                set => _woodcuttingPoints = RoundValue(value);
            }

            [JsonProperty(PropertyName = "LD")]
            public double LAST_DEATH
            {
                get => RoundValue(_lastDeath);
                set => _lastDeath = RoundValue(value);
            }

            [JsonProperty(PropertyName = "XPM")]
            public double XP_MULTIPLIER
            {
                get => RoundValue(_xpMultiplier);
                set => _xpMultiplier = RoundValue(value);
            }

            [JsonProperty(PropertyName = "CUI")]
            public bool CUI { get; set; } = true;

            [JsonProperty(PropertyName = "ONOFF")]
            public bool ENABLED { get; set; } = true;

            public PlayerInfo() { }

            public bool Equals(PlayerInfo other)
            {
                if (other == null)
                    return false;

                return ACQUIRE_LEVEL == other.ACQUIRE_LEVEL &&
                       ACQUIRE_POINTS == other.ACQUIRE_POINTS &&
                       CRAFTING_LEVEL == other.CRAFTING_LEVEL &&
                       CRAFTING_POINTS == other.CRAFTING_POINTS &&
                       MINING_LEVEL == other.MINING_LEVEL &&
                       MINING_POINTS == other.MINING_POINTS &&
                       SKINNING_LEVEL == other.SKINNING_LEVEL &&
                       SKINNING_POINTS == other.SKINNING_POINTS &&
                       WOODCUTTING_LEVEL == other.WOODCUTTING_LEVEL &&
                       WOODCUTTING_POINTS == other.WOODCUTTING_POINTS &&
                       XP_MULTIPLIER == other.XP_MULTIPLIER &&
                       CUI == other.CUI &&
                       ENABLED == other.ENABLED;
            }

            public override bool Equals(object obj)
            {
                return obj is PlayerInfo other && Equals(other);
            }

            public override int GetHashCode()
            {
                HashCode hash = new();
                hash.Add(ACQUIRE_LEVEL);
                hash.Add(ACQUIRE_POINTS);
                hash.Add(CRAFTING_LEVEL);
                hash.Add(CRAFTING_POINTS);
                hash.Add(MINING_LEVEL);
                hash.Add(MINING_POINTS);
                hash.Add(SKINNING_LEVEL);
                hash.Add(SKINNING_POINTS);
                hash.Add(WOODCUTTING_LEVEL);
                hash.Add(WOODCUTTING_POINTS);
                hash.Add(XP_MULTIPLIER);
                hash.Add(CUI);
                hash.Add(ENABLED);
                return hash.ToHashCode();
            }

            public static bool operator ==(PlayerInfo left, PlayerInfo right)
            {
                if (ReferenceEquals(left, right))
                    return true;

                if (left is null)
                    return false;

                return left.Equals(right);
            }

            public static bool operator !=(PlayerInfo left, PlayerInfo right)
            {
                return !(left == right);
            }

            internal bool IsDefault(PlayerInfo other) => Equals(other);
        }

        #region Main

        private void Init()
        {
            Unsubscribe();
            RegisterPermissions();

            int index = 0;

            foreach (Skills skill in AllSkills)
            {
                if (IsSkillEnabled(skill))
                {
                    skillIndex.Add(skill, ++index);
                }
            }
        }

        private void Unload()
        {
            Clean();
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyGUI(player);
            }
            if (TOD_Sky.Instance?.Components?.Time != null)
            {
                TOD_Sky.Instance.Components.Time.OnSunrise -= OnTimeSunrise;
                TOD_Sky.Instance.Components.Time.OnSunset -= OnTimeSunset;
            }
        }

        private void OnNewSave(string strFilename)
        {
            if (config.generic.wipeDataOnNewSave)
            {
                Puts("New save detected...");
                newSaveDetected = true;
            }
        }

        private void OnServerInitialized()
        {
            LoadData();
            if (config.nightbonus.enableNightBonus && TOD_Sky.Instance.IsNight)
            {
                pointsPerHitCurrent = config.nightbonus.pointsPerHitAtNight;
                resourceMultipliersCurrent = config.nightbonus.resourceMultipliersAtNight;
                pointsPerHitPowerToolCurrent = config.nightbonus.pointsPerPowerToolAtNight;
                bonusOn = true;
            }
            else
            {
                pointsPerHitCurrent = config.settings.pointsPerHit;
                resourceMultipliersCurrent = config.settings.resourceMultipliers;
                pointsPerHitPowerToolCurrent = config.settings.pointsPerPowerTool;
            }

            foreach (var player in BasePlayer.allPlayerList)
            {
                var pi = GetPlayerInfo(player);
                if (player.IsConnected) CreateGUI(player, pi);
            }

            Puts("Stats can be reset by > zl.reset <");
            Subscribe();
            SaveData();
            RegisterCommands();
        }

        private void OnPlayerConnected(BasePlayer player) => OnPlayerSleepEnded(player);

        private void OnPlayerDisconnected(BasePlayer player) => GetPlayerInfo(player);

        private void OnEntityKill(BasePlayer player) => OnPlayerSleep(player);

        private void OnPlayerRespawned(BasePlayer player) => OnPlayerSleepEnded(player);

        private void OnPlayerSleepEnded(BasePlayer player) => CreateGUI(player, GetPlayerInfo(player));

        private void OnPlayerSleep(BasePlayer player) => DestroyGUI(player);

        private void OnEntityDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (hitInfo == null || !IsValid(player) || isZoneExcluded(player))
            {
                return;
            }

            DestroyGUI(player);

            if (!hasRights(player.UserIDString))
            {
                return;
            }

            var pi = GetPlayerInfo(player);

            if (!pi.ENABLED || permission.UserHasPermission(player.UserIDString, config.generic.permissionNameXP))
            {
                return;
            }

            bool isSuicide = hitInfo.damageTypes.Has(DamageType.Suicide) && (player.IsAdmin || player.IsDeveloper || !player.CanSuicide());

            if (!config.generic.penaltyOnSuicide && isSuicide) return;
            if (!config.generic.penaltyOnDeath && !isSuicide) return;

            if (EventManager?.Call("IsEventPlayer", player) != null)
            {
                return;
            }

            if (Interface.CallHook("CanBePenalized", player) != null)
            {
                return;
            }

            _sb.Clear();

            foreach (Skills skill in AllSkills)
            {
                if (IsSkillEnabled(skill))
                {
                    var penalty = GetPenalty(player, pi, skill, isSuicide);

                    if (penalty > 0)
                    {
                        _sb.AppendLine("* -" + penalty + " " + _(skill + "Skill") + " XP.");
                        removePoints(pi, skill, penalty);
                    }
                }
            }
            
            if (_sb.Length > 0)
            {
                Message(player, "PenaltyText", _sb.ToString());
            }

            pi.LAST_DEATH = ToEpochTime(DateTime.UtcNow);
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (item == null || dispenser == null || !IsValid(player) || !hasRights(player.UserIDString))
            {
                return;
            }

            Skills? skill = dispenser.gatherType switch
            {
                ResourceDispenser.GatherType.Tree => Skills.WOODCUTTING,
                ResourceDispenser.GatherType.Flesh => Skills.SKINNING,
                ResourceDispenser.GatherType.Ore => Skills.MINING,
                _ => null
            };

            if (skill == null || !IsSkillEnabled(skill.Value))
            {
                return;
            }

            var pi = GetPlayerInfo(player);

            if (!pi.ENABLED)
            {
                return;
            }

            Item activeItem = player.GetActiveItem();

            if (permission.UserHasPermission(player.UserIDString, config.generic.BlockWeaponsGather) && activeItem?.info.category == ItemCategory.Weapon)
            {
                return;
            }

            if (!config.functions.ShouldAllowGather(item.info.shortname, out bool grantXPOnly))
            {
                return;
            }

            int prevAmount = item.amount;
            bool isPowerTool = false;
            
            if (skill != Skills.SKINNING && activeItem != null)
            {
                HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;

                if (heldEntity is Jackhammer || heldEntity is Chainsaw)
                {
                    if (skill == Skills.WOODCUTTING && !CanUseChainsaw(player))
                    {
                        return;
                    }

                    if (skill == Skills.MINING && !CanUseJackhammer(player))
                    {
                        return;
                    }

                    if (!config.functions.gibs && dispenser.GetComponent<ServerGib>() != null)
                    {
                        return;
                    }

                    isPowerTool = true;
                }
            }

            if (!config.functions.gibs && skill == Skills.MINING && dispenser.GetComponent<ServerGib>() != null)
            {
                return;
            }

            int amount = levelHandler(pi, player, item.amount, skill.Value, dispenser.baseEntity, isPowerTool);

            if (!grantXPOnly)
            {
                item.amount = amount;
            }

            if (item.amount != prevAmount)
            {
                Interface.CallHook("OnZLevelDispenserGather", dispenser, player, item, prevAmount, item.amount, isPowerTool);
            }
        }

        private bool CanUseJackhammer(BasePlayer player) => permission.UserHasPermission(player.UserIDString, config.generic.AllowJackhammerGather);

        private bool CanUseChainsaw(BasePlayer player) => permission.UserHasPermission(player.UserIDString, config.generic.AllowChainsawGather);

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) => OnDispenserGather(dispenser, player, item);

        private List<string> _warnings = new();

        private object OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (collectible == null || collectible.itemList.IsNullOrEmpty() || !IsValid(player) || !hasRights(player.UserIDString))
                return null;

            var pi = GetPlayerInfo(player);

            if (pi == null || !pi.ENABLED)
                return null;

            if (config.functions.enabledCollectibleEntity.TryGetValue(collectible.ShortPrefabName, out var enabled) && !enabled)
                return null;

            Skills skill;

            for (int i = 0; i < collectible.itemList.Length; i++)
            {
                ItemAmount itemAmount = collectible.itemList[i];
                if (itemAmount == null) continue;
                if (itemAmount.itemDef == null) continue;
                switch (itemAmount.itemDef.shortname)
                {
                    case "black.berry":
                    case "blue.berry":
                    case "bone.fragments":
                    case "clone.seed":
                    case "clone.orchid":
                    case "clone.rose":
                    case "clone.sunflower":
                    case "cloth":
                    case "corn":
                    case "diesel_barrel":
                    case "green.berry":
                    case "mushroom":
                    case "orchid":
                    case "potato":
                    case "pumpkin":
                    case "red.berry":
                    case "rose":
                    case "seed.black.berry":
                    case "seed.blue.berry":
                    case "seed.corn":
                    case "seed.green.berry":
                    case "seed.hemp":
                    case "seed.orchid":
                    case "seed.potato":
                    case "seed.pumpkin":
                    case "seed.red.berry":
                    case "seed.rose":
                    case "seed.sunflower":
                    case "seed.wheat":
                    case "seed.white.berry":
                    case "seed.yellow.berry":
                    case "sunflower":
                    case "wheat":
                    case "white.berry":
                    case "yellow.berry":
                        skill = IsSkillEnabled(Skills.ACQUIRE) ? Skills.ACQUIRE : Skills.SKINNING;
                        break;
                    case "metal.ore":
                    case "sulfur.ore":
                    case "stones":
                        skill = config.settings.MiningStonesOre ? Skills.MINING : Skills.ACQUIRE;
                        break;
                    case "wood":
                        skill = config.settings.AcquireWood ? Skills.ACQUIRE : Skills.WOODCUTTING;
                        break;
                    default:
                        if (IsSkillEnabled(Skills.ACQUIRE)) skill = Skills.ACQUIRE;
                        else if (IsSkillEnabled(Skills.SKINNING)) skill = Skills.SKINNING;
                        else return null;
                        if (!_warnings.Contains(itemAmount.itemDef.shortname))
                        {
                            PrintWarning($"WARNING: {player} picked up undefined item: {itemAmount.itemDef.shortname}. Defaulting to {skill} skill.");
                            _warnings.Add(itemAmount.itemDef.shortname);
                        }
                        break;
                }

                if (IsSkillEnabled(skill))
                {
                    int prevAmount = (int)itemAmount.amount;
                    itemAmount.amount = levelHandler(pi, player, prevAmount, skill, collectible);
                    if (Interface.CallHook("OnZLevelCollectiblePickup", itemAmount, player, collectible, prevAmount, itemAmount.amount) != null)
                    {
                        return true;
                    }
                }
            }
            return null;
        }

        private void OnTimeSunset()
        {
            if (!config.nightbonus.enableNightBonus || bonusOn)
            {
                return;
            }

            bonusOn = true;
            pointsPerHitCurrent = config.nightbonus.pointsPerHitAtNight;
            resourceMultipliersCurrent = config.nightbonus.resourceMultipliersAtNight;
            pointsPerHitPowerToolCurrent = config.nightbonus.pointsPerPowerToolAtNight;
            if (config.nightbonus.broadcastEnabledBonus)
            {
                foreach (var player in BasePlayer.activePlayerList)
                    Message(player, "NightBonusOn");
            }
            if (config.nightbonus.logEnabledBonusConsole)
                Puts("Nightbonus points enabled");
        }

        private void OnTimeSunrise()
        {
            if (!config.nightbonus.enableNightBonus || !bonusOn)
            {
                return;
            }
            bonusOn = false;
            pointsPerHitCurrent = config.settings.pointsPerHit;
            resourceMultipliersCurrent = config.settings.resourceMultipliers;
            pointsPerHitPowerToolCurrent = config.settings.pointsPerPowerTool;
            if (config.nightbonus.broadcastEnabledBonus)
            {
                foreach (var player in BasePlayer.activePlayerList)
                    Message(player, "NightBonusOff");
            }
            if (config.nightbonus.logEnabledBonusConsole)
                