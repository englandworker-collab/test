Puts("Nightbonus points disabled");
        }

        private object OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (item == null || player == null || !hasRights(player.UserIDString))
            {
                return true;
            }

            var pi = GetPlayerInfo(player);

            if (!pi.ENABLED)
            {
                return true;
            }

            Skills skill;
            if (IsSkillEnabled(Skills.ACQUIRE))
                skill = Skills.ACQUIRE;
            else skill = Skills.SKINNING;

            var prevAmount = item.amount;

            item.amount = levelHandler(pi, player, item.amount, skill, plant);

            Interface.CallHook("OnZLevelGrowableGathered", plant, item, player, prevAmount, item.amount);

            return null;
        }


        private object OnItemCraft(ItemCraftTask task, BasePlayer crafter, Item fromTempBlueprint)
        {
            if (!hasRights(crafter.UserIDString)) return null;

            var pi = GetPlayerInfo(crafter);

            if (!pi.ENABLED) return null;

            var bypassCraftLevelRequirement = CanInstantCraftNoLevelRequirement(crafter);
            var craftingTime = task.blueprint.time;

            if (bypassCraftLevelRequirement)
            {
                craftingTime = 0;
            }
            else if (IsSkillEnabled(Skills.CRAFTING))
            {
                if (pi.CRAFTING_LEVEL > 1)
                    craftingTime -= task.blueprint.time * (float)((pi.CRAFTING_LEVEL * config.settings.craftingDetails.percent) / 100);
            }
            else return null;

            if (craftingTime <= 0)
            {
                craftingTime = 0;

                foreach (var craftInfo in _craftData.CraftList.Values)
                {
                    if (!craftInfo.Enabled || craftInfo.shortName != task.blueprint.targetItem.shortname)
                    {
                        continue;
                    }
                    if (task.amount >= craftInfo.MinBulkCraft && task.amount <= craftInfo.MaxBulkCraft && task.amount > 0)
                    {
                        var stacks = GetStacks(task.amount * task.blueprint.amountToCreate, task.blueprint.targetItem.stackable);
                        if (!HasPlace(crafter, stacks))
                        {
                            ReturnCraft(task, crafter);
                            return true;
                        }
                        if (bypassCraftLevelRequirement || CanInstantCraft(crafter))
                        {
                            if (!task.blueprint.name.Contains("(Clone)"))
                                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
                            task.blueprint.amountToCreate *= task.amount;
                            crafter.inventory.crafting.FinishCrafting(task);
                            task.cancelled = true;
                            return true;
                        }
                    }
                }
            }

            if (!task.blueprint.name.Contains("(Clone)"))
                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);

            task.blueprint.time = craftingTime;

            return null;
        }
        private List<int> GetStacks(int amount, int maxStack)
        {
            List<int> stacks = new();
            while (amount > maxStack && amount > 0)
            {
                amount -= maxStack;
                stacks.Add(maxStack);
            }
            if (amount > 0)
            {
                stacks.Add(amount);
            }
            return stacks;
        }
        private bool HasPlace(BasePlayer crafter, List<int> stacks)
        {
            if (!config.settings.craftingDetails.slots)
            {
                return true;
            }
            var capacity = crafter.inventory.containerMain.capacity + crafter.inventory.containerBelt.capacity;
            var taken = crafter.inventory.containerMain.itemList.Count + crafter.inventory.containerBelt.itemList.Count;
            var slots = capacity - taken;
            if (slots - stacks.Count < 0)
            {
                return false;
            }
            return slots > 0;
        }
        private bool CanInstantCraftNoLevelRequirement(BasePlayer crafter)
        {
            return config.settings.craftingDetails.noLevelRequirement && permission.UserHasPermission(crafter.UserIDString, config.settings.craftingDetails.Permission);
        }
        private bool CanInstantCraft(BasePlayer crafter)
        {
            if (config.settings.craftingDetails.usePermission)
            {
                return permission.UserHasPermission(crafter.UserIDString, config.settings.craftingDetails.Permission);
            }
            return true;
        }
        private void ReturnCraft(ItemCraftTask task, BasePlayer crafter)
        {
            task.cancelled = true;
            Message(crafter, "NoSlots");
            foreach (var item in task.takenItems)
            {
                if (item.amount > 0)
                    crafter.GiveItem(item);
            }
        }
        private object OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter craft)
        {
            if (task == null) return null;
            var crafter = craft?.owner;
            if (crafter == null || !hasRights(crafter.UserIDString)) return null;
            var bypassLevelRequirement = CanInstantCraftNoLevelRequirement(crafter);
            if (!bypassLevelRequirement && !IsSkillEnabled(Skills.CRAFTING)) return null;
            var pi = GetPlayerInfo(crafter);
            var xpPercentBefore = getExperiencePercent(pi, Skills.CRAFTING);
            if (task.blueprint == null)
            {
                Puts("There is problem obtaining task.blueprint on 'OnItemCraftFinished' hook! This is usually caused by some incompatable plugins.");
                return null;
            }
            var experienceGain = (task.blueprint.time + 0.99f) / config.settings.craftingDetails.time;
            if (experienceGain == 0)
                return null;

            double Level = pi.CRAFTING_LEVEL;
            double Points = pi.CRAFTING_POINTS;
            Points += experienceGain * config.settings.craftingDetails.xp;
            if (Points >= getLevelPoints(Level + 1))
            {
                var levelCap = config.settings.levelCaps.CRAFTING;
                var maxLevel = levelCap > 0 && Level + 1 > levelCap;
                if (!maxLevel)
                {
                    Level = getPointsLevel(Points, Skills.CRAFTING);
                    string format = $"<color={config.settings.colors.CRAFTING}>{_("LevelUpText", crafter.UserIDString)}</color>";
                    string message = string.Format(format, _("CRAFTINGSkill", crafter.UserIDString), Level, Points, getLevelPoints(Level + 1), pi.CRAFTING_LEVEL * Convert.ToDouble(config.settings.craftingDetails.percent));
                    Player.Message(crafter, message, string.IsNullOrEmpty(config.generic.pluginPrefix) ? string.Empty : config.generic.pluginPrefix, config.generic.steamIDIcon);
                    GiveReward(crafter, Skills.CRAFTING, Level);
                    if (config.generic.enableLevelupBroadcast)
                    {
                        foreach (var target in BasePlayer.activePlayerList)
                        {
                            if (target != null && target.userID != crafter.userID && hasRights(target.UserIDString) && GetPlayerInfo(target).ENABLED)
                            {
                                Message(target, "LevelUpTextBroadcast", crafter.displayName, Level, config.settings.colors.CRAFTING, _("CRAFTINGSkill", crafter.UserIDString));
                            }
                        }
                    }
                }
            }
            try
            {
                if (item.info.shortname != "lantern_a" && item.info.shortname != "lantern_b")
                    setPointsAndLevel(pi, Skills.CRAFTING, Points, Level);
            }
            catch { }

            try
            {
                var xpPercentAfter = getExperiencePercent(pi, Skills.CRAFTING);
                if (xpPercentAfter != xpPercentBefore)
                    GUIUpdateSkill(crafter, Skills.CRAFTING);
            }
            catch { }

            if (task.amount > 0) return null;
            if (task.blueprint != null && task.blueprint.name.Contains("(Clone)"))
            {
                var behaviours = task.blueprint.GetComponents<MonoBehaviour>();
                foreach (var behaviour in behaviours)
                {
                    if (behaviour.name.Contains("(Clone)")) UnityEngine.Object.Destroy(behaviour);
                }
            }
            return null;
        }

        #endregion Serverhooks

        #region Commands

        [HookMethod("SendHelpText"), ChatCommand("stathelp")]
        private void SendHelpText(BasePlayer player)
        {
            _sb.Clear();
            _sb.AppendLine("<size=18><color=orange>ZLevels</color></size><size=14><color=#ce422b>REMASTERED</color></size>");
            _sb.AppendLine("/stats - Displays your stats.");
            _sb.AppendLine("/statsui - Enable/Disable stats UI.");
            _sb.AppendLine("/statsonoff - Enable/Disable whole leveling.");
            _sb.AppendLine("/statinfo - Displays information about skills.");
            _sb.AppendLine("/stathelp - Displays the help.");
            //sb.AppendLine("/topskills - Display max levels reached so far.");
            SendReply(player, _sb.ToString());
        }

        private void PointsPerHitCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;
            if (args.Length < 2)
            {
                user.Reply("Syntax: zl.pointsperhit skill number");
                user.Reply("Possible skills are: WC, M, S, A, C, *(All skills)");
                _sb.Clear();
                _sb.Append("Current points per hit:");
                foreach (var currSkill in AllSkills)
                {
                    if (!IsSkillEnabled(currSkill)) continue;
                    _sb.Append($" {currSkill} > {pointsPerHitCurrent.Get(currSkill)} |");
                }
                user.Reply(_sb.ToString().TrimEnd('|'));
                return;
            }
            if (!double.TryParse(args[1], out var points) || points < 1)
            {
                user.Reply("Incorrect number. Must be greater than or equal to 1");
                return;
            }

            var skillName = args[0].ToUpper();
            Skills skill;
            if (skillName == "*") skill = Skills.ALL;
            else if (skillName.Equals("C")) skill = Skills.CRAFTING;
            else if (skillName.Equals("WC")) skill = Skills.WOODCUTTING;
            else if (skillName.Equals("M")) skill = Skills.MINING;
            else if (skillName.Equals("A")) skill = Skills.ACQUIRE;
            else if (skillName.Equals("S")) skill = Skills.SKINNING;
            else { user.Reply("Incorrect skill. Possible skills are: WC, M, S, A, C, *(All skills)."); return; }

            if (skill == Skills.ALL)
            {
                foreach (var currSkill in AllSkills)
                {
                    if (!IsSkillEnabled(currSkill)) continue;
                    pointsPerHitCurrent.Set(currSkill, points);
                }
                _sb.Clear();
                _sb.Append("New points per hit:");
                foreach (var currSkill in AllSkills)
                {
                    if (!IsSkillEnabled(currSkill)) continue;
                    _sb.Append($" {currSkill} > {pointsPerHitCurrent.Get(currSkill)} |");
                }
                user.Reply(_sb.ToString().TrimEnd('|'));
            }
            else
            {
                pointsPerHitCurrent.Set(skill, points);
                _sb.Clear();
                _sb.Append("New points per hit:");
                foreach (var currSkill in AllSkills)
                {
                    if (!IsSkillEnabled(currSkill)) continue;
                    _sb.Append($" {currSkill} > {pointsPerHitCurrent.Get(currSkill)} |");
                }
                user.Reply(_sb.ToString().TrimEnd('|'));
            }
        }

        private void PlayerXpmCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;
            if (args.Length < 1)
            {
                user.Reply(_("XPM USE 1", user.Id));
                user.Reply(_("XPM USE 2", user.Id));
                return;
            }
            IPlayer target = covalence.Players.FindPlayer(args[0]);
            if (target == null)
            {
                user.Reply(_("PLAYER NOT FOUND", user.Id));
                return;
            }
            if (!data.PlayerInfo.TryGetValue(Convert.ToUInt64(target.Id), out var playerData))
            {
                user.Reply("PlayerData is NULL!");
                return;
            }
            if (args.Length < 2)
            {
                var bonus1 = getXpMulti(playerData, target.Id);
                var baseMultiplier = playerData.XP_MULTIPLIER;
                if (baseMultiplier != bonus1)
                {
                    user.Reply($"Current XP multiplier for player '{target.Name}' is {baseMultiplier}% with vip raising total to {bonus1}%");
                }
                else user.Reply($"Current XP multiplier for player '{target.Name}' is {baseMultiplier}%");
                return;
            }
            double multiplier = -1;
            if (double.TryParse(args[1], out multiplier))
            {
                if (multiplier <= 0)
                {
                    user.Reply("Incorrect number. Must be greater than 0");
                    return;
                }
            }
            playerData.XP_MULTIPLIER = multiplier;
            var bonus2 = getXpMulti(playerData, target.Id);
            if (multiplier != bonus2)
            {
                user.Reply($"New XP multiplier for player '{target.Name}' is {getXpMulti(playerData, target.Id)}% with vip raising total to {bonus2}%");
            }
            else user.Reply($"New XP multiplier for player '{target.Name}' is {getXpMulti(playerData, target.Id)}%");
        }

        private void InfoCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin)
            {
                return;
            }
            if (args.Length < 1)
            {
                if (!GetLookingAtPlayer(user))
                {
                    user.Reply(_("INFO USE", user.Id));
                }
                return;
            }
            IPlayer target = covalence.Players.FindPlayer(args[0]);
            if (target == null)
            {
                user.Reply(_("PLAYER NOT FOUND", user.Id));
                return;
            }
            if (!data.PlayerInfo.TryGetValue(Convert.ToUInt64(target.Id), out var playerData))
            {
                user.Reply("PlayerData is NULL!");
                return;
            }
            PrintInfo(user, target.Id, target.Name, playerData);
        }

        private bool GetLookingAtPlayer(IPlayer user)
        {
            BasePlayer player = user.Object as BasePlayer;
            if (player == null) return false;
            BasePlayer target = RelationshipManager.GetLookingAtPlayer(player);
            if (target == null) return false;
            if (!data.PlayerInfo.TryGetValue(target.userID, out var playerData)) return false;
            PrintInfo(user, target.UserIDString, target.displayName, playerData);
            return true;
        }

        private void PrintInfo(IPlayer user, string targetId, string targetName, PlayerInfo playerData)
        {
            TextTable textTable = new();
            textTable.AddColumn("FieldInfo");
            textTable.AddColumn("Level");
            textTable.AddColumn("Points");
            textTable.AddRow(new string[] { _("ACQUIRESkill", targetId), $"{playerData.ACQUIRE_LEVEL:#0.##}", $"{playerData.ACQUIRE_POINTS:#0.##}" });
            textTable.AddRow(new string[] { _("CRAFTINGSkill", targetId), $"{playerData.CRAFTING_LEVEL:#0.##}", $"{playerData.CRAFTING_POINTS:#0.##}" });
            textTable.AddRow(new string[] { _("MININGSkill", targetId), $"{playerData.MINING_LEVEL:#0.##}", $"{playerData.MINING_POINTS:#0.##}" });
            textTable.AddRow(new string[] { _("SKINNINGSkill", targetId), $"{playerData.SKINNING_LEVEL:#0.##}", $"{playerData.SKINNING_POINTS:#0.##}" });
            textTable.AddRow(new string[] { _("WOODCUTTINGSkill", targetId), $"{playerData.WOODCUTTING_LEVEL:#0.##}", $"{playerData.WOODCUTTING_POINTS:#0.##}" });
            textTable.AddRow(new string[] { _("XPM", targetId), $"{getXpMulti(playerData, targetId):#0.##}%", string.Empty });
            user.Reply($"\n{_("STATS", targetId)}{targetName}\n{textTable}");
        }

        private void ResetCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;
            if (args.Length != 1 || args[0] != "true")
            {
                user.Reply(_("RESET USE", user.Id));
                return;
            }
            WipeData();
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyGUI(player);
                CreateGUI(player, GetPlayerInfo(player));
            }
            user.Reply("Userdata was successfully reset to zero");
            Puts("{0} ({1}) reset userdata to zero", user.Name, user.Id);
        }

        private void ZlvlCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length < 3)
            {
                _sb.Clear();
                _sb.AppendLine("Syntax: zl.lvl name|steamid skill [OPERATOR]NUMBER");
                _sb.AppendLine("Example: zl.lvl Player WC /2 -- Player gets his WC level divided by 2.");
                _sb.AppendLine("Example: zl.lvl * * +3 -- Everyone currently playing in the server gets +3 for all skills.");
                _sb.AppendLine("Example: zl.lvl ** * /2 -- Everyone (including offline players) gets their level divided by 2.");
                _sb.AppendLine("Instead of names you can use wildcard(*): * - affects online players, ** - affects all players");
                _sb.AppendLine("Possible operators: *(XP Modified %), +(Adds level), -(Removes level), /(Divides level)").AppendLine();
                user.Reply(_sb.ToString());
                return;
            }
            var playerName = args[0];
            IPlayer target = covalence.Players.FindPlayer(playerName);

            if (playerName != "*" && playerName != "**" && target == null)
            {
                user.Reply(_("PLAYER NOT FOUND", user.Id));
                return;
            }
            if (playerName != "*" && playerName != "**" && !data.PlayerInfo.ContainsKey(Convert.ToUInt64(target.Id)))
            {
                user.Reply("PlayerData is NULL!");
                return;
            }

            if (target != null || playerName == "*" || playerName == "**")
            {
                var playerMode = 0; // Exact player
                if (playerName == "*")
                    playerMode = 1; // Online players
                else if (playerName == "**")
                    playerMode = 2; // All players
                var skillName = args[1].ToUpper();
                Skills skill;
                if (skillName == "*") skill = Skills.ALL;
                else if (skillName.Equals("C")) skill = Skills.CRAFTING;
                else if (skillName.Equals("WC")) skill = Skills.WOODCUTTING;
                else if (skillName.Equals("M")) skill = Skills.MINING;
                else if (skillName.Equals("A")) skill = Skills.ACQUIRE;
                else if (skillName.Equals("S")) skill = Skills.SKINNING;
                else { user.Reply("Incorrect skill. Possible skills are: WC, M, S, A, C, *(All skills)."); return; }
                var mode = 0; // 0 = SET, 1 = ADD, 2 = SUBTRACT, 3 = multiplier, 4 = divide
                int value;
                bool correct;
                if (args[2][0] == '+')
                {
                    mode = 1;
                    correct = int.TryParse(args[2].Replace("+", string.Empty), out value);
                }
                else if (args[2][0] == '-')
                {
                    mode = 2;
                    correct = int.TryParse(args[2].Replace("-", string.Empty), out value);
                }
                else if (args[2][0] == '*')
                {
                    mode = 3;
                    correct = int.TryParse(args[2].Replace("*", string.Empty), out value);
                }
                else if (args[2][0] == '/')
                {
                    mode = 4;
                    correct = int.TryParse(args[2].Replace("/", string.Empty), out value);
                }
                else
                {
                    correct = int.TryParse(args[2], out value);
                }
                if (correct)
                {
                    if (mode == 3) // Change XP Multiplier.
                    {
                        if (skill != Skills.ALL)
                        {
                            user.Reply("XPMultiplier is changeable for all skills! Use * instead of " + skill + ".");
                            return;
                        }
                        if (playerMode == 1)
                        {
                            foreach (var currPlayer in BasePlayer.activePlayerList)
                                editMultiplierForPlayer(value, currPlayer.userID);
                        }
                        else if (playerMode == 2)
                            editMultiplierForPlayer(value);
                        else if (target != null)
                            editMultiplierForPlayer(value, Convert.ToUInt64(target.Id));

                        var whom = playerMode == 1 ? "ALL ONLINE PLAYERS" : playerMode == 2 ? "ALL PLAYERS" : target.Name;
                        user.Reply($"XP rates has changed to {value}% of normal XP for {whom}");
                        return;
                    }
                    if (playerMode == 1)
                    {
                        foreach (var connPlayer in covalence.Players.Connected)
                        {
                            adminModifyPlayerStats(user, skill, value, mode, connPlayer);
                        }
                    }
                    else if (playerMode == 2)
                    {
                        foreach (var other in covalence.Players.All)
                        {
                            if (data.PlayerInfo.ContainsKey(Convert.ToUInt64(other.Id)))
                            {
                                adminModifyPlayerStats(user, skill, value, mode, other);
                            }
                        }
                    }
                    else
                    {
                        adminModifyPlayerStats(user, skill, value, mode, target);
                    }
                }
            }
        }

        private void CheckCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            int count = 0;
            var pi = CreatePlayerInfo();

            foreach (var info in data.PlayerInfo)
            {
                if (info.Value.IsDefault(pi))
                {
                    count++;
                }
            }

            user.Reply($"{count} / {data.PlayerInfo.Count} entries in datafile can be removed");
        }

        private void CleanCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            int count = data.PlayerInfo.Count;
            int cleaned = Clean();

            user.Reply($"{cleaned} / {count} entries in datafile have been removed");
            SaveData();
        }

        private int Clean()
        {
            int count = 0;

            if (data == null)
            {
                return count;
            }

            var pi = CreatePlayerInfo();

            foreach (var info in data.PlayerInfo.ToList())
            {
                if (info.Value.IsDefault(pi))
                {
                    count++;
                    data.PlayerInfo.Remove(info.Key);
                }
            }

            return count;
        }

        private void PenaltyCommand(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length == 1 && args[0] == "status")
            {
                user.Reply(config.generic.penaltyOnDeath ? "Penalty is currently enabled." : "Penalty is currently disabled.");
                return;
            }

            if (args.Length == 0) config.generic.penaltyOnDeath = !config.generic.penaltyOnDeath;
            else config.generic.penaltyOnSuicide = !config.generic.penaltyOnSuicide;

            if (config.generic.penaltyOnDeath || config.generic.penaltyOnSuicide)
            {
                Subscribe(nameof(OnEntityDeath));
                user.Reply("Penalty is now enabled.");
            }
            else
            {
                Unsubscribe(nameof(OnEntityDeath));
                user.Reply("Penalty is now disabled.");
            }

            SaveConfig();
        }

        [ChatCommand("stats")]
        private void StatsCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasRights(player.UserIDString))
            {
                Message(player, "NoPermission");
                return;
            }
            _sb.Clear();
            _sb.AppendLine("<size=18><color=orange>ZLevels</color></size><size=14><color=#ce422b>REMASTERED</color></size>");
            foreach (Skills skill in AllSkills) _sb.Append(getStatPrint(player, skill));
            var pi = GetPlayerInfo(player.userID);
            var alive = ReadableTimeSpan(DateTime.UtcNow - ToDateTimeFromEpoch(pi.LAST_DEATH));
            _sb.AppendLine().AppendLine($"Time alive: {alive}");
            _sb.AppendLine($"XP rates for you are {getXpMulti(pi, player.UserIDString)}%");
            SendReply(player, _sb.ToString());
        }

        [ChatCommand("statinfo")]
        private void StatInfoCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasRights(player.UserIDString))
            {
                Message(player, "NoPermission");
                return;
            }

            _sb.Clear();
            var colors = config.settings.colors;
            var craftingDetails = config.settings.craftingDetails;
            var xpm = getXpMulti(GetPlayerInfo(player.userID), player.UserIDString) / 100f;
            var m = player.GetHeldEntity() is Jackhammer ? pointsPerHitPowerToolCurrent.Get(Skills.MINING) : pointsPerHitCurrent.Get(Skills.MINING);
            var wc = player.GetHeldEntity() is Chainsaw ? pointsPerHitPowerToolCurrent.Get(Skills.WOODCUTTING) : pointsPerHitCurrent.Get(Skills.WOODCUTTING);

            _sb.AppendLine("<size=18><color=orange>ZLevels</color></size><size=14><color=#ce422b>REMASTERED</color></size>");

            AppendLine(colors.ACQUIRE, pointsPerHitCurrent.Get(Skills.ACQUIRE) * xpm, Skills.ACQUIRE);
            AppendLine(colors.MINING, m * xpm, Skills.MINING);
            AppendLine(colors.SKINNING, pointsPerHitCurrent.Get(Skills.SKINNING) * xpm, Skills.SKINNING);
            AppendLine(colors.WOODCUTTING, wc * xpm, Skills.WOODCUTTING);

            _sb.AppendLine($"<color={colors.CRAFTING}>Crafting</color> {(!IsSkillEnabled(Skills.CRAFTING) ? "(DISABLED)" : string.Empty)}");
            _sb.AppendLine($"XP gain: <color={colors.SKINNING}>You get {craftingDetails.xp} XP per {craftingDetails.time}s spent crafting.</color>");
            _sb.AppendLine($"Bonus: <color={colors.SKINNING}>Crafting time is decreased by {craftingDetails.percent}% per every level.</color>");

            SendReply(player, _sb.ToString());
            _sb.Clear();
        }

        private void AppendLine(string color, double xp, Skills skill)
        {
            var state = !IsSkillEnabled(skill) ? "(DISABLED)" : string.Empty;
            var bonus = (getGathMult(2, skill) - 1) * 100;

            _sb.AppendLine($"<color={color}>{skill}</color> {state}");
            _sb.AppendLine($"XP per hit: <color={color}>{xp}</color>");
            _sb.AppendLine($"Bonus materials per level: <color={color}>{bonus:#0.##} %</color>");
        }

        [ChatCommand("statsui")]
        private void StatsUICommand(BasePlayer player, string command, string[] args)
        {
            if (!hasRights(player.UserIDString)) return;
            var pi = GetPlayerInfo(player);
            if (pi.CUI)
            {
                DestroyGUI(player);
                pi.CUI = false;
            }
            else
            {
                pi.CUI = true;
                CreateGUI(player, pi);
            }
        }

        [ChatCommand("statsonoff")]
        private void StatsOnOffCommand(BasePlayer player, string command, string[] args)
        {
            if (!hasRights(player.UserIDString)) return;
            var pi = GetPlayerInfo(player);
            if (pi.ENABLED)
            {
                DestroyGUI(player);
                pi.ENABLED = false;
                Message(player, "PluginPlayerOff");
            }
            else
            {
                pi.ENABLED = true;
                Message(player, "PluginPlayerOn");
                if (pi.CUI)
                    CreateGUI(player, pi);
            }
        }

        #endregion Commands

        #region Helpers

        private void Unsubscribe()
        {
            Unsubscribe(nameof(OnCollectiblePickup));
            Unsubscribe(nameof(OnDispenserBonus));
            Unsubscribe(nameof(OnDispenserGather));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnGrowableGathered));
            Unsubscribe(nameof(OnItemCraft));
            Unsubscribe(nameof(OnItemCraftFinished));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnPlayerSleep));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnTimeSunrise));
            Unsubscribe(nameof(OnTimeSunset));
            Unsubscribe(nameof(Unload));
        }

        private void RegisterPermissions()
        {
            foreach (var name in config.generic.vip.Keys)
            {
                if (string.IsNullOrEmpty(name))
                {
                    continue;
                }
                if (name.Contains("."))
                {
                    if (!permission.PermissionExists(name))
                    {
                        permission.RegisterPermission(name, this);
                    }
                }
                else
                {
                    if (!permission.GroupExists(name))
                    {
                        permission.CreateGroup(name, name, 0);
                    }
                }
            }

            permission.RegisterPermission(config.generic.nowipe, this);
            permission.RegisterPermission(config.generic.permissionName, this);
            permission.RegisterPermission(config.generic.permissionNameXP, this);
            permission.RegisterPermission(config.generic.AllowChainsawGather, this);
            permission.RegisterPermission(config.generic.AllowJackhammerGather, this);
            permission.RegisterPermission(config.generic.BlockWeaponsGather, this);
            permission.RegisterPermission(config.settings.craftingDetails.Permission, this);
        }

        private void RegisterCommands()
        {
            AddCovalenceCommand("zl.pointsperhit", nameof(PointsPerHitCommand));
            AddCovalenceCommand("zl.playerxpm", nameof(PlayerXpmCommand));
            AddCovalenceCommand("zl.info", nameof(InfoCommand));
            AddCovalenceCommand("zl.reset", nameof(ResetCommand));
            AddCovalenceCommand("zl.lvl", nameof(ZlvlCommand));
            AddCovalenceCommand("check_zlevel_datafile", nameof(CheckCommand));
            AddCovalenceCommand("clean_zlevel_datafile", nameof(CleanCommand));
            AddCovalenceCommand("zl.toggledeathpenalty", nameof(PenaltyCommand));
        }

        private void Subscribe()
        {
            if (config.generic.penaltyOnDeath || config.generic.penaltyOnSuicide)
            {
                Subscribe(nameof(OnEntityDeath));
            }

            if (config.functions.enableCollectiblePickup)
            {
                Subscribe(nameof(OnCollectiblePickup));
            }

            if (config.functions.enableCropGather)
            {
                Subscribe(nameof(OnGrowableGathered));
            }

            if (config.functions.enableDispenserGather)
            {
                Subscribe(nameof(OnDispenserBonus));
                Subscribe(nameof(OnDispenserGather));
            }

            if (IsCraftingEnabled())
            {
                Subscribe(nameof(OnItemCraft));
                Subscribe(nameof(OnItemCraftFinished));
            }

            if (config.nightbonus.enableNightBonus)
            {
                Plugin plugin = plugins.Find("TimeOfDay");
                if (plugin != null && plugin.IsLoaded)
                {
                    Subscribe(nameof(OnTimeSunrise));
                    Subscribe(nameof(OnTimeSunset));
                }
                else if (TOD_Sky.Instance?.Components?.Time != null)
                {
                    TOD_Sky.Instance.Components.Time.OnSunrise += OnTimeSunrise;
                    TOD_Sky.Instance.Components.Time.OnSunset += OnTimeSunset;
                }
            }

            Subscribe(nameof(OnPlayerConnected));
            Subscribe(nameof(OnPlayerDisconnected));
            Subscribe(nameof(OnPlayerRespawned));
            Subscribe(nameof(OnPlayerSleep));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnEntityKill));
            Subscribe(nameof(Unload));

            timer.Repeat(300f, 0, SaveData);
        }

        private void CheckCollectible()
        {
            var collectList = Resources.FindObjectsOfTypeAll<CollectibleEntity>().Select(c => c.ShortPrefabName).Distinct().ToList();
            if (collectList == null || collectList.Count == 0)
            {
                return;
            }

            if (config.functions.enabledCollectibleEntity == null)
            {
                config.functions.enabledCollectibleEntity = new();
            }

            bool updated = false;
            foreach (var collect in collectList)
            {
                if (!config.functions.enabledCollectibleEntity.ContainsKey(collect))
                {
                    config.functions.enabledCollectibleEntity.Add(collect, true);
                    updated = true;
                }
            }

            if (updated)
            {
                SaveConfig();
            }
        }

        private void SaveData()
        {
            if (data != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, data);
            }
        }

        private void SaveDetails()
        {
            if (_craftData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject("ZLevelsCraftDetails", _craftData);
            }
        }

        private void LoadData()
        {
            try
            {
                _craftData = Interface.Oxide.DataFileSystem.ReadObject<CraftData>("ZLevelsCraftDetails");
            }
            catch (Exception ex)
            {
                Puts("CraftData threw an exception!");
                Puts(ex.ToString());
            }

            if (_craftData == null)
            {
                Puts("Crafting data is null and has been reset!");
                _craftData = new();
            }

            if (_craftData.CraftList == null)
            {
                Puts("Crafting list is null and has been reset!");
                _craftData.CraftList = new();
            }

            if (_craftData.CraftList.Count == 0)
            {
                GenerateItems(true);
            }

            CheckCollectible();

            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception ex)
            {
                Puts("StoredData threw an exception!");
                Puts(ex.ToString());
            }

            if (data == null || data.PlayerInfo == null)
            {
                Puts("Data is null, resetting to defaults!");
                data = new();
            }
            else if (newSaveDetected)
            {
                Puts("Wiping data... new save detected");
                WipeData();
            }
        }

        private void WipeData()
        {
            if (string.IsNullOrEmpty(config.generic.nowipe))
            {
                data = new();
                return;
            }
            foreach (var pair in data.PlayerInfo.ToList())
            {
                if (permission.UserHasPermission(pair.Key.ToString(), config.generic.nowipe))
                {
                    continue;
                }
                data.PlayerInfo.Remove(pair.Key);
            }
        }

        private bool hasRights(string UserIDString)
        {
            return !config.generic.enablePermission || permission.UserHasPermission(UserIDString, config.generic.permissionName);
        }

        private void editMultiplierForPlayer(double multiplier, ulong userID = ulong.MinValue)
        {
            if (userID == ulong.MinValue)
            {
                foreach (var p in data.PlayerInfo.ToList())
                    data.PlayerInfo[p.Key].XP_MULTIPLIER = multiplier;
                return;
            }
            if (data.PlayerInfo.TryGetValue(userID, out var playerData))
                playerData.XP_MULTIPLIER = multiplier;
        }

        private void adminModifyPlayerStats(IPlayer user, Skills skill, double level, int mode, IPlayer target)
        {
            var id = Convert.ToUInt64(target.Id);
            var pi = GetPlayerInfo(id);

            if (skill == Skills.ALL)
            {
                _sb.Clear();
                foreach (var currSkill in AllSkills)
                {
                    if (!IsSkillEnabled(currSkill)) continue;
                    var modifiedLevel = getLevel(pi, currSkill);
                    if (mode == 0) // SET
                        modifiedLevel = level;
                    else if (mode == 1) // ADD
                        modifiedLevel += level;
                    else if (mode == 2) // SUBTRACT
                        modifiedLevel -= level;
                    else if (mode == 4) // DIVIDE
                        modifiedLevel /= level;
                    if (modifiedLevel < 1)
                        modifiedLevel = 1;
                    var levelCap = config.settings.levelCaps.Get(currSkill);
                    if (modifiedLevel > levelCap && levelCap != 0)
                        modifiedLevel = levelCap;
                    setPointsAndLevel(pi, currSkill, getLevelPoints(modifiedLevel), modifiedLevel);
                    var basePlayer = BasePlayer.FindByID(id);
                    if (basePlayer != null) CreateGUI(basePlayer, GetPlayerInfo(basePlayer));
                    _sb.Append($"({_(currSkill + "Skill")} > {modifiedLevel}) ");
                }
                user.Reply($"\nChanges for '{target.Name}': " + _sb.ToString().TrimEnd());
            }
            else
            {
                var modifiedLevel = getLevel(pi, skill);
                if (mode == 0) // SET
                    modifiedLevel = level;
                else if (mode == 1) // ADD
                    modifiedLevel += level;
                else if (mode == 2) // SUBTRACT
                    modifiedLevel -= level;
                else if (mode == 4) // DIVIDE
                    modifiedLevel /= level;
                if (modifiedLevel < 1)
                    modifiedLevel = 1;
                var levelCap = config.settings.levelCaps.Get(skill);
                if (modifiedLevel > levelCap && levelCap != 0)
                {
                    modifiedLevel = levelCap;
                }
                setPointsAndLevel(pi, skill, getLevelPoints(modifiedLevel), modifiedLevel);
                var basePlayer = BasePlayer.FindByID(id);
                if (basePlayer != null) GUIUpdateSkill(basePlayer, skill);
                user.Reply($"{_(skill + "Skill")} Lvl for [{target.Name}] set to: [{modifiedLevel}]");
            }
        }

        private string getStatPrint(BasePlayer player, Skills skill)
        {
            if (!IsSkillEnabled(skill))
                return string.Empty;

            var pi = GetPlayerInfo(player);
            var levelCap = config.settings.levelCaps.Get(skill);
            var skillMaxed = levelCap != 0 && getLevel(pi, skill) == levelCap;

            string bonusText;
            if (skill == Skills.CRAFTING)
                bonusText = $"{(getLevel(pi, skill) * config.settings.craftingDetails.percent):#0.##}";
            else
                bonusText = $"{((getGathMult(getLevel(pi, skill), skill) - 1) * 100.0):#0.##}";

            string format = $"<color={config.settings.colors.Get(skill)}>{_("StatsText", player.UserIDString)}</color>\n";
            var skillName = _(skill + "Skill", player.UserIDString);
            var xp = $"{getLevel(pi, skill):0}" + (levelCap > 0 ? ("/" + $"{levelCap:0}") : string.Empty);
            var points = $"{getPoints(pi, skill):0}";
            var level = skillMaxed ? "∞" : $"{getLevelPoints(getLevel(pi, skill) + 1):0}";
            var percent = $"{getExperiencePercent(pi, skill):0}%";
            var penalty = $"{getPenaltyPercent(player, pi, skill, false):0}%";
            return string.Format(format, skillName, xp, points, level, bonusText, percent, penalty);
        }

        private void removePoints(PlayerInfo pi, Skills skill, double points)
        {
            switch (skill)
            {
                case Skills.ACQUIRE:
                    pi.ACQUIRE_POINTS = pi.ACQUIRE_POINTS - 10.0 > points ? pi.ACQUIRE_POINTS - points : 10.0;
                    pi.ACQUIRE_LEVEL = getPointsLevel(pi.ACQUIRE_POINTS, skill);
                    break;
                case Skills.CRAFTING:
                    pi.CRAFTING_POINTS = pi.CRAFTING_POINTS - 10.0 > points ? pi.CRAFTING_POINTS - points : 10.0;
                    pi.CRAFTING_LEVEL = getPointsLevel(pi.CRAFTING_POINTS, skill);
                    break;
                case Skills.MINING:
                    pi.MINING_POINTS = pi.MINING_POINTS - 10.0 > points ? pi.MINING_POINTS - points : 10.0;
                    pi.MINING_LEVEL = getPointsLevel(pi.MINING_POINTS, skill);
                    break;
                case Skills.SKINNING:
                    pi.SKINNING_POINTS = pi.SKINNING_POINTS - 10.0 > points ? pi.SKINNING_POINTS - points : 10.0;
                    pi.SKINNING_LEVEL = getPointsLevel(pi.SKINNING_POINTS, skill);
                    break;
                case Skills.WOODCUTTING:
                    pi.WOODCUTTING_POINTS = pi.WOODCUTTING_POINTS - 10.0 > points ? pi.WOODCUTTING_POINTS - points : 10.0;
                    pi.WOODCUTTING_LEVEL = getPointsLevel(pi.WOODCUTTING_POINTS, skill);
                    break;
            }
        }

        private double GetPenalty(BasePlayer player, PlayerInfo pi, Skills skill, bool isSuicide)
        {
            double penaltyPercent = getPenaltyPercent(player, pi, skill, isSuicide);

            return skill switch
            {
                Skills.ACQUIRE => config.generic.penaltyReset ? pi.ACQUIRE_POINTS : getPercentAmount(pi.ACQUIRE_LEVEL, penaltyPercent),
                Skills.CRAFTING => config.generic.penaltyReset ? pi.CRAFTING_POINTS : getPercentAmount(pi.CRAFTING_LEVEL, penaltyPercent),
                Skills.MINING => config.generic.penaltyReset ? pi.MINING_POINTS : getPercentAmount(pi.MINING_LEVEL, penaltyPercent),
                Skills.SKINNING => config.generic.penaltyReset ? pi.SKINNING_POINTS : getPercentAmount(pi.SKINNING_LEVEL, penaltyPercent),
                Skills.WOODCUTTING => config.generic.penaltyReset ? pi.WOODCUTTING_POINTS : getPercentAmount(pi.WOODCUTTING_LEVEL, penaltyPercent),
                _ => 0,
            };
        }

        private double getPenaltyPercent(BasePlayer player, PlayerInfo pi, Skills skill, bool isSuicide)
        {
            var penaltyPercent = 0.0;
            var details = pi.LAST_DEATH;
            var currentTime = DateTime.UtcNow;
            var lastDeath = ToDateTimeFromEpoch(details);
            var timeAlive = currentTime - lastDeath;
            if (timeAlive.TotalMinutes >= (isSuicide ? config.generic.penaltySuicideMinutes : config.generic.penaltyMinutes))
            {
                var percent = isSuicide ? config.settings.percentLostOnSuicide.Get(skill) : config.settings.percentLostOnDeath.Get(skill);
                if (percent == 0)
                    return 0;
                penaltyPercent = percent - (timeAlive.TotalHours * percent / 10.0);
                if (penaltyPercent < 0)
                    penaltyPercent = 0;
            }
            return Math.Round(penaltyPercent, 2);
        }

        private int levelHandler(PlayerInfo pi, BasePlayer player, int prevAmount, Skills skill, BaseEntity source, bool isPowerTool = false)
        {
            object extCanGainZLevelXP = Interface.CallHook("CanGainXP", new object[] { player, source });

            if (extCanGainZLevelXP is bool && !(bool)extCanGainZLevelXP)
            {
                return prevAmount;
            }

            var xpPercentBefore = getExperiencePercent(pi, skill);
            var currentLevel = getLevel(pi, skill);
            var newPoints = getPoints(pi, skill);
            var newAmount = Mathf.CeilToInt(prevAmount * (float)getGathMult(currentLevel, skill));
            var pointsToGet = isPowerTool ? pointsPerHitPowerToolCurrent.Get(skill) : pointsPerHitCurrent.Get(skill);
            newPoints += pointsToGet * (getXpMulti(pi, player.UserIDString) / 100.0);

            if (newPoints >= getLevelPoints(currentLevel + 1))
            {
                var levelCap = config.settings.levelCaps.Get(skill);
                var maxLevel = levelCap > 0 && currentLevel + 1 > levelCap;

                if (!maxLevel)
                {
                    currentLevel = getPointsLevel(newPoints, skill);

                    var levelPoints = getLevelPoints(currentLevel + 1);
                    var color = config.settings.colors.Get(skill);
                    var skillName = _(skill + "Skill", player.UserIDString);
                    var gatherMulti = ((getGathMult(currentLevel, skill) - 1) * 100.0).ToString("0.##");
                    var format = $"<color={color}>{_("LevelUpText", player.UserIDString)}</color>";

                    PrintToChat(player, string.Format(format, skillName, currentLevel, newPoints, levelPoints, gatherMulti));
                    BroadcastLevel(player, skill, color, currentLevel);
                    GiveReward(player, skill, currentLevel);
                }
            }

            setPointsAndLevel(pi, skill, newPoints, currentLevel);
            var xpPercentAfter = getExperiencePercent(pi, skill);
            if (xpPercentAfter != xpPercentBefore)
                GUIUpdateSkill(player, skill);
            return newAmount;
        }

        private void BroadcastLevel(BasePlayer player, Skills skill, string color, double Level)
        {
            if (config.generic.enableLevelupBroadcast && (int)Level % 10 == 0)
            {
                foreach (var target in BasePlayer.activePlayerList)
                {
                    if (target.userID == player.userID || !hasRights(target.UserIDString) || !GetPlayerInfo(target.userID).ENABLED)
                        continue;

                    Message(target, "LevelUpTextBroadcast", player.displayName, Level, color, _(skill + "Skill", target.UserIDString));
                }
            }
        }

        private double getExperiencePercentProc(PlayerInfo pi, Skills skill)
        {
            var Level = getLevel(pi, skill);
            var startingPoints = getLevelPoints(Level);
            var nextLevelPoints = getLevelPoints(Level + 1) - startingPoints;
            var Points = getPoints(pi, skill) - startingPoints;
            var experienceProc = Math.Round((Points / nextLevelPoints) * 100.0, 2);
            return experienceProc;
        }

        private double getExperiencePercent(PlayerInfo pi, Skills skill)
        {
            var experienceProc = getExperiencePercentProc(pi, skill);
            if (experienceProc >= 100)
                experienceProc = 99.99;
            return experienceProc;
        }

        private void setPointsAndLevel(PlayerInfo pi, Skills skill, double points, double level)
        {
            double levelPoints = getLevelPoints(level);

            switch (skill)
            {
                case Skills.ACQUIRE:
                    pi.ACQUIRE_LEVEL = level;
                    pi.ACQUIRE_POINTS = points <= 0.0 ? levelPoints : points;
                    break;
                case Skills.CRAFTING:
                    pi.CRAFTING_LEVEL = level;
                    pi.CRAFTING_POINTS = points <= 0.0 ? levelPoints : points;
                    break;
                case Skills.MINING:
                    pi.MINING_LEVEL = level;
                    pi.MINING_POINTS = points <= 0.0 ? levelPoints : points;
                    break;
                case Skills.SKINNING:
                    pi.SKINNING_LEVEL = level;
                    pi.SKINNING_POINTS = points <= 0.0 ? levelPoints : points;
                    break;
                case Skills.WOODCUTTING:
                    pi.WOODCUTTING_LEVEL = level;
                    pi.WOODCUTTING_POINTS = points <= 0.0 ? levelPoints : points;
                    break;
            }
        }

        private double getLevel(PlayerInfo pi, Skills skill)
        {
            switch (skill)
            {
                case Skills.ACQUIRE:
                    return pi.ACQUIRE_LEVEL;
                case Skills.CRAFTING:
                    return pi.CRAFTING_LEVEL;
                case Skills.MINING:
                    return pi.MINING_LEVEL;
                case Skills.SKINNING:
                    return pi.SKINNING_LEVEL;
                case Skills.WOODCUTTING:
                    return pi.WOODCUTTING_LEVEL;
            }

            return 0.0;
        }

        private double getPoints(PlayerInfo pi, Skills skill)
        {
            switch (skill)
            {
                case Skills.ACQUIRE:
                    return pi.ACQUIRE_POINTS;
                case Skills.CRAFTING:
                    return pi.CRAFTING_POINTS;
                case Skills.MINING:
                    return pi.MINING_POINTS;
                case Skills.SKINNING:
                    return pi.SKINNING_POINTS;
                case Skills.WOODCUTTING:
                    return pi.WOODCUTTING_POINTS;
            }

            return 0.0;
        }

        private double getLevelPoints(double level) => Math.Round(110 * level * level - 100 * level, 2); // TODO

        private double getPointsLevel(double points, Skills skill)
        {
            var a = 110;
            var b = 100;
            var c = -points;
            var x1 = (-b - Math.Sqrt(b * b - 4 * a * c)) / (2 * a);
            var levelCap = config.settings.levelCaps.Get(skill);
            if ((int)levelCap == 0 || (int)-x1 <= (int)levelCap)
                return (int)-x1;
            return Math.Round(levelCap, 2);
        }

        private double getGathMult(double skillLevel, Skills skill)
        {
            return Math.Round(config.settings.defaultMultipliers.Get(skill) + resourceMultipliersCurrent.Get(skill) * 0.1d * (skillLevel - 1.0), 2);
        }

        private double getXpMulti(PlayerInfo pi, string userid)
        {
            double baseMultiplier = pi.XP_MULTIPLIER;
            double highestMultiplier = double.MinValue;
            foreach (var (name, multiplier) in config.generic.vip)
            {
                if (string.IsNullOrEmpty(name) || multiplier < highestMultiplier)
                {
                    continue;
                }
                if (name.Contains('.') ? permission.UserHasPermission(userid, name) : permission.UserHasGroup(userid, name))
                {
                    highestMultiplier = multiplier;
                }
            }
            if (highestMultiplier == double.MinValue)
            {
                highestMultiplier = 1.0;
            }
            return baseMultiplier * highestMultiplier;
        }

        private bool IsCraftingEnabled()
        {
            if (CraftingController != null) return false;
            return config.settings.levelCaps.Get(Skills.CRAFTING) != -1 || config.settings.craftingDetails.noLevelRequirement;
        }

        private bool IsSkillEnabled(Skills skill)
        {
            if (skill == Skills.CRAFTING && ConVar.Craft.instant)
            {
                return false;
            }
            return config.settings.levelCaps.Get(skill) != -1;
        }

        private double getPointsNeededForNextLevel(double level)
        {
            return getLevelPoints(level + 1) - getLevelPoints(level);
        }

        private double getPercentAmount(double level, double percent)
        {
            return (getPointsNeededForNextLevel(level) * percent) / 100.0;
        }

        private bool IsValid(BasePlayer player)
        {
            return player != null && player.userID.IsSteamId();
        }

        private bool isZoneExcluded(BasePlayer player)
        {
            if (config.settings.zones.Count == 0 || ZoneManager == null)
            {
                return false;
            }

            var values = (string[])ZoneManager?.Call("GetPlayerZoneIDs", player);

            return values?.Length > 0 && config.settings.zones.Any(values.Contains);
        }

        private string ReadableTimeSpan(TimeSpan span)
        {
            var formatted = string.Format("{0}{1}{2}{3}{4}",
                (span.Days / 7) > 0 ? string.Format("{0:0} weeks, ", span.Days / 7) : string.Empty,
                span.Days % 7 > 0 ? string.Format("{0:0} days, ", span.Days % 7) : string.Empty,
                span.Hours > 0 ? string.Format("{0:0} hours, ", span.Hours) : string.Empty,
                span.Minutes > 0 ? string.Format("{0:0} minutes, ", span.Minutes) : string.Empty,
                span.Seconds > 0 ? string.Format("{0:0} seconds, ", span.Seconds) : string.Empty);

            if (formatted.EndsWith(", ")) formatted = formatted.Substring(0, formatted.Length - 2);
            return formatted;
        }

        private long ToEpochTime(DateTime dateTime)
        {
            var date = dateTime.ToUniversalTime();
            var ticks = date.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks;
            var ts = ticks / TimeSpan.TicksPerSecond;
            return ts;
        }

        private DateTime ToDateTimeFromEpoch(double intDate)
        {
            var timeInTicks = (long)intDate * TimeSpan.TicksPerSecond;
            return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddTicks(timeInTicks);
        }

        private string _(string key, string id = null) => lang.GetMessage(key, this, id);

        private void Message(BasePlayer player, string key, params object[] args)
        {
            string message = string.Format(_(key, player.UserIDString), args);

            Player.Message(player, message, string.IsNullOrEmpty(config.generic.pluginPrefix) ? string.Empty : config.generic.pluginPrefix, config.generic.steamIDIcon);
        }

        private ItemDefinition GetItem(string shortname)
        {
            if (string.IsNullOrEmpty(shortname) || CraftItems == null) return null;
            if (CraftItems.TryGetValue(shortname, out var item)) return item;
            return null;
        }

        private void GenerateItems(bool reset = false)
        {
            if (!reset)
            {
                var config_protocol = config.generic.gameProtocol;

                if (config_protocol != Protocol.network)
                {
                    config.generic.gameProtocol = Protocol.network;
                    Config["Generic", "gameProtocol"] = config.generic.gameProtocol;
                    Puts("Updating item list from protocol " + config_protocol + " to protocol " + config.generic.gameProtocol + ".");
                    GenerateItems(true);
                    SaveConfig();
                    return;
                }
            }

            if (reset)
            {
                Interface.Oxide.DataFileSystem.WriteObject("ZLevelsCraftDetails.old", _craftData);
                _craftData.CraftList.Clear();
                Puts("Generating new item list...");
            }

            CraftItems = ItemManager.GetItemDefinitions().ToDictionary(i => i.shortname);
            int loaded = 0, enabled = 0;
            foreach (var definition in CraftItems)
            {
                if (definition.Value.shortname.Length >= 1)
                {
                    if (_craftData.CraftList.TryGetValue(definition.Value.shortname, out var p))
                    {
                        if (p.Enabled) { enabled++; }
                        loaded++;
                    }
                    else
                    {
                        CraftInfo z = new()
                        {
                            shortName = definition.Value.shortname,
                            MaxBulkCraft = MaxB,
                            MinBulkCraft = MinB,
                            Enabled = true
                        };
                        _craftData.CraftList.Add(definition.Value.shortname, z);
                        loaded++;
                    }
                }
            }
            var inactive = loaded - enabled;
            Puts("Loaded {0} items (Enabled: {1} | Inactive: {2})", loaded, enabled, inactive);
            SaveDetails();
        }
        #endregion Helpers

        #region CUI

        private void GUIUpdateSkill(BasePlayer player, Skills skill)
        {
            if (!skillIndex.ContainsKey(skill)) return;
            double maxRows = skillIndex.Count;
            double rowNumber = skillIndex[skill];
            var pi = GetPlayerInfo(player);
            double level = getLevel(pi, skill);
            //If the player has the max level we don't care about the percentage
            bool isMaxLevel = level >= config.settings.levelCaps.Get(skill);
            double percent = isMaxLevel ? 100.0 : getExperiencePercent(pi, skill);
            var skillName = _(skill.ToString() + "Skill", player.UserIDString);
            var mainPanel = "ZL" + skillName;

            CuiHelper.DestroyUi(player, mainPanel);

            var value = 1 / maxRows;
            var positionMin = 1 - (value * rowNumber);
            var positionMax = 2 - (1 - (value * (1 - rowNumber)));

            var container = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = config.cui.cuiBoundsBackground},
                        RectTransform = { AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = $"1 "+ positionMax.ToString("0.####") },
                    },
                    new CuiElement().Parent = "ZLevelsUI",
                    mainPanel
                }
            };

            var innerXPBar1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                {
                    new CuiImageComponent { Color = config.cui.cuiXpBarBackground },
                    new CuiRectTransformComponent{ AnchorMin = "0.190 0.05", AnchorMax = "0.750 0.8" }
                }
            };
            container.Add(innerXPBar1);

            var innerXPBarProgress1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                {
                    new CuiImageComponent() { Color = config.cui.cuiColors.Get(skill) },
                    new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = (percent / 100.0) + " 0.95" }
                }
            };
            container.Add(innerXPBarProgress1);

            if (config.cui.cuiTextShadow)
            {
                var innerXPBarTextShadow1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerXPBar1.Name,
                    Components =
                    {
                        new CuiTextComponent { Color = "0.1 0.1 0.1 0.75", Text = skillName, FontSize = config.cui.cuiFontSizeBar, Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent{ AnchorMin = "0.035 -0.1", AnchorMax = "1 1" }
                    }
                };
                container.Add(innerXPBarTextShadow1);
            }

            var innerXPBarText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                {
                    new CuiTextComponent { Color = config.cui.cuiFontColor, Text = skillName, FontSize = config.cui.cuiFontSizeBar, Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent{ AnchorMin = "0.05 0", AnchorMax = "1 1" }
                }
            };
            container.Add(innerXPBarText1);

            if (config.cui.cuiTextShadow)
            {
                var lvShader1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components =
                    {
                        new CuiTextComponent { Text = $"{_("Lv.", player.UserIDString)}{level:0}", FontSize = config.cui.cuiFontSizeLvl , Align = TextAnchor.MiddleLeft, Color = "0.1 0.1 0.1 0.75" },
                        new CuiRectTransformComponent{ AnchorMin = "0.035 -0.1", AnchorMax = $"0.5 1" }
                    }
                };
                container.Add(lvShader1);
            }

            var lvText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                {
                    new CuiTextComponent { Text = $"{_("Lv.", player.UserIDString)}{level:0}", FontSize = config.cui.cuiFontSizeLvl, Align = TextAnchor.MiddleLeft, Color = config.cui.cuiFontColor },
                    new CuiRectTransformComponent{ AnchorMin = "0.025 0", AnchorMax = $"0.5 1" }
                }
            };

            container.Add(lvText1);

            if (config.cui.cuiTextShadow)
            {
                var percShader1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components =
                    {
                        new CuiTextComponent { Text = isMaxLevel ? _("MAX", player.UserIDString) : $"{percent:N2}%", FontSize = config.cui.cuiFontSizePercent, Align = TextAnchor.MiddleRight, Color = "0.1 0.1 0.1 0.75" },
                        new CuiRectTransformComponent{ AnchorMin = "0.5 -0.1", AnchorMax = $"1 1" }
                    }
                };
                container.Add(percShader1);
            }

            var percText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                {
                    new CuiTextComponent { Text = isMaxLevel ? _("MAX", player.UserIDString) : $"{percent:N2}%", FontSize = config.cui.cuiFontSizePercent, Align = TextAnchor.MiddleRight, Color = config.cui.cuiFontColor },
                    new CuiRectTransformComponent{ AnchorMin = "0.5 0", AnchorMax = $"1 1" }
                }
            };
            container.Add(percText1);
            CuiHelper.AddUi(player, container);
        }

        private void DestroyGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ZLevelsUI");
        }

        private void CreateGUI(BasePlayer player, PlayerInfo pi)
        {
            if (!config.cui.cuiEnabled || pi == null || !pi.ENABLED || !pi.CUI || !hasRights(player.UserIDString) || !player.IsAlive() || player.IsSleeping())
            {
                return;
            }

            var panelName = "ZLevelsUI";
            CuiHelper.DestroyUi(player, panelName);
            var mainContainer = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = "0 0 0 0"},
                        RectTransform = {AnchorMin = $"{config.cui.cuiPositioning.widthLeft} {config.cui.cuiPositioning.heightLower}", AnchorMax =$"{config.cui.cuiPositioning.widthRight} {config.cui.cuiPositioning.heightUpper}"},
                        CursorEnabled = false
                    },
                    new CuiElement().Parent = "Under",
                    panelName
                }
            };
            CuiHelper.AddUi(player, mainContainer);
            foreach (Skills skill in AllSkills)
                if (IsSkillEnabled(skill))
                    GUIUpdateSkill(player, skill);
        }

        private PlayerInfo GetPlayerInfo(BasePlayer player)
        {
            if (!player.userID.IsSteamId())
            {
                return null;
            }

            return GetPlayerInfo(player.userID);
        }

        private PlayerInfo CreatePlayerInfo()
        {
            return new()
            {
                ACQUIRE_LEVEL = config.settings.stats.acquire_level,
                ACQUIRE_POINTS = config.settings.stats.acquire_points,
                CRAFTING_LEVEL = config.settings.stats.crafting_level,
                CRAFTING_POINTS = config.settings.stats.crafting_points,
                MINING_LEVEL = config.settings.stats.mining_level,
                MINING_POINTS = config.settings.stats.mining_points,
                SKINNING_LEVEL = config.settings.stats.skinning_level,
                SKINNING_POINTS = config.settings.stats.skinning_points,
                WOODCUTTING_LEVEL = config.settings.stats.woodcutting_level,
                WOODCUTTING_POINTS = config.settings.stats.woodcutting_points,
                XP_MULTIPLIER = config.settings.stats.xpm
            };
        }

        private PlayerInfo GetPlayerInfo(ulong userID)
        {
            if (!data.PlayerInfo.TryGetValue(userID, out var pi))
            {
                data.PlayerInfo[userID] = pi = CreatePlayerInfo();

                pi.LAST_DEATH = ToEpochTime(DateTime.UtcNow);
                pi.CUI = config.generic.playerCuiDefaultEnabled;
                pi.ENABLED = config.generic.playerPluginDefaultEnabled;
            }

            return pi;
        }

        #endregion CUI

        #region Config

        private class Configuration
        {
            [JsonProperty(PropertyName = "CUI")]
            public ConfigurationCui cui { get; set; } = new();

            [JsonProperty(PropertyName = "Functions")]
            public ConfigurationFunctions functions { get; set; } = new();

            [JsonProperty(PropertyName = "Generic")]
            public ConfigurationGeneric generic { get; set; } = new();

            [JsonProperty(PropertyName = "Night Bonus")]
            public ConfigurationNightBonus nightbonus { get; set; } = new();

            [JsonProperty(PropertyName = "Settings")]
            public ConfigurationSettings settings { get; set; } = new();

            [JsonProperty(PropertyName = "Level Up Rewards (Reward * Level = Amount)")]
            public Rewards Rewards { get; set; } = new();
        }

        private class ConfigurationCui
        {
            [JsonProperty(PropertyName = "Bounds")]
            public ConfigurationCuiPositions cuiPositioning { get; set; } = new("0.725", "0.83", "0.02", "0.1225");

            [JsonProperty(PropertyName = "Xp Bar Colors")]
            public ConfigurationColors cuiColors { get; set; } = new("0.4 0 0.8 0.5", "0 1 0 0.5", "0 0 1 0.5", "1 0 0 0.5", "1 0.6 0 0.5");

            [JsonProperty(PropertyName = "Bounds Background")]
            public string cuiBoundsBackground { get; set; } = "0.1 0.1 0.1 0.1";

            [JsonProperty(PropertyName = "CUI Enabled")]
            public bool cuiEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Font Color")]
            public string cuiFontColor { get; set; } = "0.74 0.76 0.78 1";

            [JsonProperty(PropertyName = "FontSize Bar")]
            public int cuiFontSizeBar { get; set; } = 11;

            [JsonProperty(PropertyName = "FontSize Level")]
            public int cuiFontSizeLvl { get; set; } = 11;

            [JsonProperty(PropertyName = "FontSize Percent")]
            public int cuiFontSizePercent { get; set; } = 11;

            [JsonProperty(PropertyName = "Text Shadow Enabled")]
            public bool cuiTextShadow { get; set; } = true;

            [JsonProperty(PropertyName = "Xp Bar Background")]
            public string cuiXpBarBackground { get; set; } = "0.2 0.2 0.2 0.2";
        }

        private class ConfigurationFunctions
        {
            [JsonProperty(PropertyName = "Collectible Entities", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, bool> enabledCollectibleEntity { get; set; } = new();

            [JsonProperty(PropertyName = "Enable Collectible Pickup")]
            public bool enableCollectiblePickup { get; set; } = true;

            [JsonProperty(PropertyName = "Enable Crop Gather")]
            public bool enableCropGather { get; set; } = true;

            [JsonProperty(PropertyName = "Enable Wood Gather")]
            public bool wood { get; set; } = true;

            [JsonProperty(PropertyName = "Grant Wood XP Only")]
            public bool woodXpOnly { get; set; }

            [JsonProperty(PropertyName = "Enable Stone Ore Gather")]
            public bool stone { get; set; } = true;

            [JsonProperty(PropertyName = "Grant Stone XP Only")]
            public bool stoneXpOnly { get; set; }

            [JsonProperty(PropertyName = "Enable Sulfur Ore Gather")]
            public bool sulfur { get; set; } = true;

            [JsonProperty(PropertyName = "Grant Sulfur XP Only")]
            public bool sulfurXpOnly { get; set; }

            [JsonProperty(PropertyName = "Enable Metal Gather")]
            public bool metal { get; set; } = true;

            [JsonProperty(PropertyName = "Grant Metal XP Only")]
            public bool metalXpOnly { get; set; }

            [JsonProperty(PropertyName = "Enable HQM Gather")]
            public bool hqm { get; set; } = true;

            [JsonProperty(PropertyName = "Grant HQM XP Only")]
            public bool hqmXpOnly { get; set; }

            [JsonProperty(PropertyName = "Allow Mining Multiplier On Gibs")]
            public bool gibs { get; set; } = true;

            internal bool enableDispenserGather => wood || stone || sulfur || metal || hqm || woodXpOnly || stoneXpOnly || sulfurXpOnly || metalXpOnly || hqmXpOnly;

            public bool ShouldAllowGather(string shortName, out bool grantXPOnly)
            {
                (bool main, bool xpOnly) = shortName switch
                {
                    "wood" => (wood, woodXpOnly),
                    "sulfur.ore" => (sulfur, sulfurXpOnly),
                    "stones" => (stone, stoneXpOnly),
                    "metal.ore" => (metal, metalXpOnly),
                    "hq.metal.ore" => (hqm, hqmXpOnly),
                    _ => (true, false)
                };

                grantXPOnly = !main && xpOnly;
                return main || xpOnly;
            }
        }

        private class ConfigurationGeneric
        {
            [JsonProperty(PropertyName = "Enable Level Up Broadcast")]
            public bool enableLevelupBroadcast { get; set; }

            [JsonProperty(PropertyName = "Enable Permission")]
            public bool enablePermission { get; set; }

            [JsonProperty(PropertyName = "Chainsaw On Gather Permission")]
            public string AllowChainsawGather { get; set; } = "zlevelsremastered.chainsaw.allowed";

            [JsonProperty(PropertyName = "Jackhammer On Gather Permission")]
            public string AllowJackhammerGather { get; set; } = "zlevelsremastered.jackhammer.allowed";

            [JsonProperty(PropertyName = "Weapons On Gather Permission")]
            public string BlockWeaponsGather { get; set; } = "zlevelsremastered.weapons.blocked";

            [JsonProperty(PropertyName = "gameProtocol")]
            public int gameProtocol { get; set; } = Protocol.network;

            [JsonProperty(PropertyName = "Penalty Minutes")]
            public int penaltyMinutes { get; set; } = 10;

            [JsonProperty(PropertyName = "Penalty Minutes (Suicide)")]
            public int penaltySuicideMinutes { get; set; } = 10;

            [JsonProperty(PropertyName = "Penalty Resets All Levels To Default")]
            public bool penaltyReset { get; set; }

            [JsonProperty(PropertyName = "Penalty On Death")]
            public bool penaltyOnDeath { get; set; } = true;

            [JsonProperty(PropertyName = "Penalty On Suicide")]
            public bool penaltyOnSuicide { get; set; }

            [JsonProperty(PropertyName = "Permission Name")]
            public string permissionName { get; set; } = "zlevelsremastered.use";

            [JsonProperty(PropertyName = "Permission Name XP")]
            public string permissionNameXP { get; set; } = "zlevelsremastered.noxploss";

            [JsonProperty(PropertyName = "Additional Boost Multipliers")]
            public Dictionary<string, double> vip { get; set; } = new()
            {
                ["zlevelsremastered.vip1"] = 2.0,
                ["zlevelsremastered.vip2"] = 3.0,
                ["zlevelsremastered.vip3"] = 4.0,
                ["zlevelsvip1"] = 5.0,
                ["zlevelsvip2"] = 6.0,
                ["zlevelsvip3"] = 7.0,
            };

            [JsonProperty(PropertyName = "Permission Name No Wipes")]
            public string nowipe { get; set; } = "zlevelsremastered.nowipes";

            [JsonProperty(PropertyName = "Player CUI Default Enabled")]
            public bool playerCuiDefaultEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Player Plugin Default Enabled")]
            public bool playerPluginDefaultEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Plugin Prefix")]
            public string pluginPrefix { get; set; } = "<color=orange>ZLevels</color>: ";

            [JsonProperty(PropertyName = "SteamID Icon")]
            public ulong steamIDIcon { get; set; }

            [JsonProperty(PropertyName = "Wipe Data OnNewSave")]
            public bool wipeDataOnNewSave { get; set; }
        }

        private class ConfigurationNightBonus
        {
            [JsonProperty(PropertyName = "Points Per Hit At Night")]
            public ConfigurationResources pointsPerHitAtNight { get; set; } = new(60, null, 60, 60, 60);

            [JsonProperty(PropertyName = "Points Per PowerTool At Night")]
            public ConfigurationResources pointsPerPowerToolAtNight { get; set; } = new(null, null, 60, null, 60);

            [JsonProperty(PropertyName = "Resource Per Level Multiplier At Night")]
            public ConfigurationResources resourceMultipliersAtNight { get; set; } = new(2, null, 2, 2, 2);

            [JsonProperty(PropertyName = "Enable Night Bonus")]
            public bool enableNightBonus { get; set; }

            [JsonProperty(PropertyName = "Broadcast Enabled Bonus")]
            public bool broadcastEnabledBonus { get; set; } = true;

            [JsonProperty(PropertyName = "Log Enabled Bonus Console")]
            public bool logEnabledBonusConsole { get; set; }
        }

        private class ConfigurationSettings
        {
            [JsonProperty(PropertyName = "Crafting Details", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public ConfigurationCraftingDetails craftingDetails { get; set; } = new(1, 3, 5);

            [JsonProperty(PropertyName = "Default Resource Multiplier")]
            public ConfigurationResources defaultMultipliers { get; set; } = new(1, null, 1, 1, 1);

            [JsonProperty(PropertyName = "Level Caps")]
            public ConfigurationResources levelCaps { get; set; } = new(200, 20, 200, 200, 200);

            [JsonProperty(PropertyName = "Percent Lost On Death")]
            public ConfigurationResources percentLostOnDeath { get; set; } = new(50, 50, 50, 50, 50);

            [JsonProperty(PropertyName = "Percent Lost On Suicide")]
            public ConfigurationResources percentLostOnSuicide { get; set; } = new(0, 0, 0, 0, 0);

            [JsonProperty(PropertyName = "No Penalty Zones", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> zones { get; set; } = new() { "adminzone1", "999999" };

            [JsonProperty(PropertyName = "Points Per Hit")]
            public ConfigurationResources pointsPerHit { get; set; } = new(30, null, 30, 30, 30);

            [JsonProperty(PropertyName = "Points Per Power Tool")]
            public ConfigurationResources pointsPerPowerTool { get; set; } = new(null, null, 30, null, 30);

            [JsonProperty(PropertyName = "Resource Per Level Multiplier")]
            public ConfigurationResources resourceMultipliers { get; set; } = new(2, null, 2, 2, 2);

            [JsonProperty(PropertyName = "Skill Colors")]
            public ConfigurationSkillColors colors { get; set; } = new();

            [JsonProperty(PropertyName = "Starting Stats")]
            public ConfigurationStartingStats stats { get; set; } = new();

            [JsonProperty(PropertyName = "Use Mining Skill When Picking Up Stones And Ore")]
            public bool MiningStonesOre { get; set; } = true;

            [JsonProperty(PropertyName = "Use Acquire Skill When Picking Up Wood")]
            public bool AcquireWood { get; set; }
        }

        public class ConfigurationStartingStats
        {
            [JsonProperty(PropertyName = "Acquire Level")]
            public double acquire_level { get; set; } = 1.0;

            [JsonProperty(PropertyName = "Acquire Points")]
            public double acquire_points { get; set; } = 10.0;

            [JsonProperty(PropertyName = "Crafting Level")]
            public double crafting_level { get; set; } = 1.0;

            [JsonProperty(PropertyName = "Crafting Points")]
            public double crafting_points { get; set; } = 10.0;

            [JsonProperty(PropertyName = "Mining Level")]
            public double mining_level { get; set; } = 1.0;

            [JsonProperty(PropertyName = "Mining Points")]
            public double mining_points { get; set; } = 10.0;

            [JsonProperty(PropertyName = "Skinning Level")]
            public double skinning_level { get; set; } = 1.0;

            [JsonProperty(PropertyName = "Skinning Points")]
            public double skinning_points { get; set; } = 10.0;

            [JsonProperty(PropertyName = "Woodcutting Level")]
            public double woodcutting_level { get; set; } = 1.0;

            [JsonProperty(PropertyName = "Woodcutting Points")]
            public double woodcutting_points { get; set; } = 10.0;

            [JsonProperty(PropertyName = "XP Multiplier")]
            public double xpm { get; set; } = 100.0;

        }

        public class ConfigurationResources
        {
            [JsonProperty(PropertyName = nameof(Skills.ACQUIRE), NullValueHandling = NullValueHandling.Ignore)]
            public double? ACQUIRE { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.CRAFTING), NullValueHandling = NullValueHandling.Ignore)]
            public double? CRAFTING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.MINING), NullValueHandling = NullValueHandling.Ignore)]
            public double? MINING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.SKINNING), NullValueHandling = NullValueHandling.Ignore)]
            public double? SKINNING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.WOODCUTTING), NullValueHandling = NullValueHandling.Ignore)]
            public double? WOODCUTTING { get; set; }

            public ConfigurationResources(double? ACQUIRE, double? CRAFTING, double? MINING, double? SKINNING, double? WOODCUTTING)
            {
                this.ACQUIRE = ACQUIRE;
                this.CRAFTING = CRAFTING;
                this.MINING = MINING;
                this.SKINNING = SKINNING;
                this.WOODCUTTING = WOODCUTTING;
            }

            public double Get(Skills skill)
            {
                switch (skill)
                {
                    case Skills.ACQUIRE:
                        return ACQUIRE.HasValue ? ACQUIRE.Value : 0.0;
                    case Skills.CRAFTING:
                        return CRAFTING.HasValue ? CRAFTING.Value : 0.0;
                    case Skills.MINING:
                        return MINING.HasValue ? MINING.Value : 0.0;
                    case Skills.SKINNING:
                        return SKINNING.HasValue ? SKINNING.Value : 0.0;
                    case Skills.WOODCUTTING:
                        return WOODCUTTING.HasValue ? WOODCUTTING.Value : 0.0;
                }

                return 0;
            }

            public void Set(Skills skill, double value)
            {
                switch (skill)
                {
                    case Skills.ACQUIRE:
                        ACQUIRE = value;
                        break;
                    case Skills.CRAFTING:
                        CRAFTING = value;
                        break;
                    case Skills.MINING:
                        MINING = value;
                        break;
                    case Skills.SKINNING:
                        SKINNING = value;
                        break;
                    case Skills.WOODCUTTING:
                        WOODCUTTING = value;
                        break;
                }
            }
        }

        public class ConfigurationColors
        {
            [JsonProperty(PropertyName = nameof(Skills.ACQUIRE))]
            public string ACQUIRE { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.CRAFTING))]
            public string CRAFTING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.MINING))]
            public string MINING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.SKINNING))]
            public string SKINNING { get; set; }

            [JsonProperty(PropertyName = nameof(Skills.WOODCUTTING))]
            public string WOODCUTTING { get; set; }

            public ConfigurationColors(string ACQUIRE, string CRAFTING, string MINING, string SKINNING, string WOODCUTTING)
            {
                this.ACQUIRE = ACQUIRE;
                this.CRAFTING = CRAFTING;
                this.MINING = MINING;
                this.SKINNING = SKINNING;
                this.WOODCUTTING = WOODCUTTING;
            }

            public string Get(Skills skill)
            {
                switch (skill)
                {
                    case Skills.ACQUIRE:
                        return ACQUIRE;
                    case Skills.CRAFTING:
                        return CRAFTING;
                    case Skills.MINING:
                        return MINING;
                    case Skills.SKINNING:
                        return SKINNING;
                    case Skills.WOODCUTTING:
                        return WOODCUTTING;
                }

                return "1 1 1 1";
            }
        }

        public class ConfigurationCraftingDetails
        {
            [JsonProperty(PropertyName = "Time Spent")]
            public double time { get; set; }

            [JsonProperty(PropertyName = "XP Per Time Spent")]
            public double xp { get; set; }

            [JsonProperty(PropertyName = "Percent Faster Per Level")]
            public double percent { get; set; }

            [JsonProperty(PropertyName = "Require Permission For Instant Bulk Craft")]
            public bool usePermission { get; set; }

            [JsonProperty(PropertyName = "Instant Bulk Craft Permission Does Not Require Max Level")]
            public bool noLevelRequirement { get; set; }

            [JsonProperty(PropertyName = "Permission For Instant Bulk Crafting At Max Level")]
            public string Permission { get; set; } = "zlevelsremastered.crafting.instantbulk";

            [JsonProperty(PropertyName = "Require Inventory Slots")]
            public bool slots;

            public ConfigurationCraftingDetails(double time, double xp, double percent)
            {
                this.time = time;
                this.xp = xp;
                this.percent = percent;
            }
        }

        public class ConfigurationCuiPositions
        {
            [JsonProperty(PropertyName = "Width Left")]
            public string widthLeft { get; set; }

            [JsonProperty(PropertyName = "Width Right")]
            public string widthRight { get; set; }

            [JsonProperty(PropertyName = "Height Lower")]
            public string heightLower { get; set; }

            [JsonProperty(PropertyName = "Height Upper")]
            public string heightUpper { get; set; }

            public ConfigurationCuiPositions(string widthLeft, string widthRight, string heightLower, string heightUpper)
            {
                this.widthLeft = widthLeft;
                this.widthRight = widthRight;
                this.heightLower = heightLower;
                this.heightUpper = heightUpper;
            }
        }

        public class ConfigurationSkillColors
        {
            [JsonProperty(PropertyName = nameof(Skills.ACQUIRE))]
            public string ACQUIRE { get; set; } = "#7700AA";

            [JsonProperty(PropertyName = nameof(Skills.CRAFTING))]
            public string CRAFTING { get; set; } = "#00FF00";

            [JsonProperty(PropertyName = nameof(Skills.MINING))]
            public string MINING { get; set; } = "#0000FF";

            [JsonProperty(PropertyName = nameof(Skills.SKINNING))]
            public string SKINNING { get; set; } = "#FF0000";

            [JsonProperty(PropertyName = nameof(Skills.WOODCUTTING))]
            public string WOODCUTTING { get; set; } = "#FF9900";

            public string Get(Skills skill)
            {
                switch (skill)
                {
                    case Skills.ACQUIRE:
                        return ACQUIRE;
                    case Skills.CRAFTING:
                        return CRAFTING;
                    case Skills.MINING:
                        return MINING;
                    case Skills.SKINNING:
                        return SKINNING;
                    case Skills.WOODCUTTING:
                        return WOODCUTTING;
                }

                return "#FF0000";
            }
        }

        public class RewardType
        {
            [JsonProperty(PropertyName = "Acquire")]
            public double Acquire { get; set; }

            [JsonProperty(PropertyName = "Crafting")]
            public double Crafting { get; set; }

            [JsonProperty(PropertyName = "Mining")]
            public double Mining { get; set; }

            [JsonProperty(PropertyName = "Skinning")]
            public double Skinning { get; set; }

            [JsonProperty(PropertyName = "Woodcutting")]
            public double Woodcutting { get; set; }

            public double Get(Skills skill)
            {
                switch (skill)
                {
                    case Skills.ACQUIRE: return Acquire;
                    case Skills.CRAFTING: return Crafting;
                    case Skills.MINING: return Mining;
                    case Skills.SKINNING: return Skinning;
                    case Skills.WOODCUTTING: return Woodcutting;
                    default: return 0.0;
                }
            }
        }

        public class Rewards
        {
            [JsonProperty(PropertyName = "Economics Money")]
            public RewardType Money { get; set; } = new();

            [JsonProperty(PropertyName = "ServerRewards Points")]
            public RewardType Points { get; set; } = new();

            [JsonProperty(PropertyName = "SkillTree XP")]
            public RewardType XP { get; set; } = new();
        }

        public void GiveReward(BasePlayer player, Skills skill, double level)
        {
            if (Economics != null && Economics.IsLoaded)
            {
                var money = config.Rewards.Money.Get(skill) * level;
                if (money > 0)
                {
                    Economics?.Call("Deposit", player.UserIDString, money);
                    Message(player, "EconomicsDeposit", money);
                }
            }

            if (IQEconomic != null && IQEconomic.IsLoaded)
            {
                var money = config.Rewards.Money.Get(skill) * level;
                if (money > 0)
                {
                    IQEconomic?.Call("API_SET_BALANCE", player.UserIDString, (int)money);
                    Message(player, "EconomicsDeposit", (int)money);
                }
            }

            if (ServerRewards != null && ServerRewards.IsLoaded)
            {
                var points = config.Rewards.Points.Get(skill) * level;
                if (points > 0)
                {
                    ServerRewards?.Call("AddPoints", player.UserIDString, (int)points);
                    Message(player, "ServerRewardPoints", (int)points);
                }
            }

            if (SkillTree != null && SkillTree.IsLoaded)
            {
                var xp = config.Rewards.XP.Get(skill) * level;
                if (xp > 0)
                {
                    SkillTree?.Call("AwardXP", player, xp);
                    Message(player, "SkillTreeXP", xp);
                }
            }
        }

        private Configuration config = new();
        private ConfigurationResources pointsPerPowerTool;
        private ConfigurationResources pointsPerHitCurrent;
        private ConfigurationResources pointsPerPowerToolAtNight;
        private ConfigurationResources pointsPerHitPowerToolCurrent;
        private ConfigurationResources resourceMultipliersCurrent;
        private Dictionary<Skills, int> skillIndex = new();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                canSaveConfig = true;
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
                return;
            }
            CheckStartingStats();
            SaveConfig();
        }

        public void CheckStartingStats()
        {
            var pi = CreatePlayerInfo();
            var ACQUIRE = getExperiencePercentProc(pi, Skills.ACQUIRE);

            if (ACQUIRE < 0.0)
            {
                var value = Math.Ceiling(getPointsNeededForNextLevel(Math.Max(1.0, pi.ACQUIRE_LEVEL)) * (-1 * ACQUIRE) / 100);
                Puts("Invalid acquire starting points: {0} ({1}% multiplier) resulting in {2}% towards next level. Points adjusted to: {3}", pi.ACQUIRE_POINTS, pi.XP_MULTIPLIER, ACQUIRE, value);
                config.settings.stats.acquire_points += value;
                pi.ACQUIRE_POINTS += value;
            }

            var CRAFTING = getExperiencePercentProc(pi, Skills.CRAFTING);

            if (CRAFTING < 0.0)
            {
                var value = Math.Ceiling(getPointsNeededForNextLevel(Math.Max(1.0, pi.CRAFTING_LEVEL)) * (-1 * CRAFTING) / 100);
                Puts("Invalid crafting starting points: {0} ({1}% multiplier) resulting in {2}% towards next level. Points adjusted to: {3}", pi.CRAFTING_POINTS, pi.XP_MULTIPLIER, CRAFTING, value);
                config.settings.stats.crafting_points += value;
                pi.CRAFTING_POINTS += value;
            }

            var MINING = getExperiencePercentProc(pi, Skills.MINING);

            if (MINING < 0.0)
            {
                var value = Math.Ceiling(getPointsNeededForNextLevel(Math.Max(1.0, pi.MINING_LEVEL)) * (-1 * MINING) / 100);
                Puts("Invalid mining starting points: {0} ({1}% multiplier) resulting in {2}% towards next level. Points adjusted to: {3}", pi.MINING_POINTS, pi.XP_MULTIPLIER, MINING, value);
                config.settings.stats.mining_points += value;
                pi.MINING_POINTS += value;
            }

            var SKINNING = getExperiencePercentProc(pi, Skills.SKINNING);

            if (SKINNING < 0.0)
            {
                var value = Math.Ceiling(getPointsNeededForNextLevel(Math.Max(1.0, pi.SKINNING_LEVEL)) * (-1 * SKINNING) / 100);
                Puts("Invalid skinning starting points: {0} ({1}% multiplier) resulting in {2}% towards next level. Points adjusted to: {3}", pi.SKINNING_POINTS, pi.XP_MULTIPLIER, SKINNING, value);
                config.settings.stats.skinning_points += value;
                pi.SKINNING_POINTS += value;
            }

            var WOODCUTTING = getExperiencePercentProc(pi, Skills.WOODCUTTING);

            if (WOODCUTTING < 0.0)
            {
                var value = Math.Ceiling(getPointsNeededForNextLevel(Math.Max(1.0, pi.WOODCUTTING_LEVEL)) * (-1 * WOODCUTTING) / 100);
                Puts("Invalid woodcutting starting points: {0} ({1}% multiplier) resulting in {2}% towards next level. Points adjusted to: {3}", pi.WOODCUTTING_POINTS, pi.XP_MULTIPLIER, WOODCUTTING, value);
                config.settings.stats.woodcutting_points += value;
                pi.WOODCUTTING_POINTS += value;
            }
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config, true);
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                {"StatsHeadline", "Level stats (/statinfo - To get more information about skills)"},
                {"StatsText",   "-{0}\nLevel: {1} (+{4}% bonus) \nXP: {2}/{3} [{5}].\n<color=red>-{6} XP loss on death.</color>"},
                {"LevelUpText", "{0} Level up\nLevel: {1} (+{4}% bonus) \nXP: {2}/{3}"},
                {"LevelUpTextBroadcast", "<color=#5af>{0}</color> has reached level <color=#5af>{1}</color> in <color={2}>{3}</color>"},
                {"PenaltyText", "<color=orange>You have lost XP for dying:{0}</color>"},
                {"NoPermission", "You don't have permission to use this command"},
                {"WOODCUTTINGSkill", "Woodcutting"},
                {"MININGSkill", "Mining"},
                {"SKINNINGSkill", "Skinning"},
                {"CRAFTINGSkill", "Crafting" },
                {"ACQUIRESkill", "Acquire" },
                {"XPM", "XP Multiplier"},
                {"STATS", "Stats for player: "},
                {"INFO USE", "Usage: zl.info name|steamid"},
                {"RESET USE", "Usage: zl.reset true | Resets all userdata to zero"},
                {"XPM USE 1", "Syntax: zl.playerxpm name|steamid (to show current XP multiplier)"},
                {"XPM USE 2", "Syntax: zl.playerxpm name|steamid number (to set current XP multiplier >= 100)"},
                {"PLAYER NOT FOUND", "Player not found!"},
                {"NightBonusOn", "Nightbonus for points per hit enabled"},
                {"NightBonusOff", "Nightbonus for points per hit disabled"},
                {"PluginPlayerOn", "The plugin functions are now enabled again"},
                {"PluginPlayerOff", "The plugin functions are now disabled for your character"},
                {"Lv.", "Lv."},
                {"MAX", "MAX"},
                {"SkillTreeXP", "You have received <color=#FFFF00>{0} XP</color> for leveling up!"},
                {"ServerRewardPoints", "You have received <color=#FFFF00>{0} RP</color> for leveling up!"},
                {"EconomicsDeposit", "You have received <color=#FFFF00>${0}</color> for leveling up!"},
                {"NoSlots", "You don't have enough slots to craft!"},
            }, this);
        }

        #endregion Config

        #region API

        private double GetMultiplier(ulong userID, string skill = "A")
        {
            double multiplier = 1;
            if (userID.IsSteamId())
            {
                switch (skill.ToUpper())
                {
                    case "A":
                        return getGathMult(GetLevel(userID, skill), Skills.ACQUIRE);
                    case "C":
                        return getGathMult(GetLevel(userID, skill), Skills.CRAFTING);
                    case "M":
                        return getGathMult(GetLevel(userID, skill), Skills.MINING);
                    case "S":
                        return getGathMult(GetLevel(userID, skill), Skills.SKINNING);
                    case "WC":
                        return getGathMult(GetLevel(userID, skill), Skills.WOODCUTTING);
                }
            }

            return multiplier;
        }

        private double GetLevel(ulong userID, string skill = "A")
        {
            if (data.PlayerInfo.TryGetValue(userID, out var pi))
            {
                switch (skill.ToUpper())
                {
                    case "A":
                    case "ACQUIRE":
                        return pi.ACQUIRE_LEVEL;
                    case "C":
                    case "CRAFTING":
                        return pi.CRAFTING_LEVEL;
                    case "M":
                    case "MINING":
                        return pi.MINING_LEVEL;
                    case "S":
                    case "SKINNING":
                        return pi.SKINNING_LEVEL;
                    case "WC":
                    case "WOODCUTTING":
                        return pi.WOODCUTTING_LEVEL;
                }
            }

            return 0;
        }

        private string api_GetPlayerInfo(ulong playerid)
        {
            if (playerid != 0)
            {
                PlayerInfo pi = GetPlayerInfo(playerid);
                if (pi == null) return string.Empty;
                return pi.ACQUIRE_LEVEL + "|" +
                    pi.ACQUIRE_POINTS + "|" +
                    pi.CRAFTING_LEVEL + "|" +
                    pi.CRAFTING_POINTS + "|" +
                    pi.CUI + "|" +
                    pi.LAST_DEATH + "|" +
                    pi.MINING_LEVEL + "|" +
                    pi.MINING_POINTS + "|" +
                    pi.ENABLED + "|" +
                    pi.SKINNING_LEVEL + "|" +
                    pi.SKINNING_POINTS + "|" +
                    pi.WOODCUTTING_LEVEL + "|" +
                    pi.WOODCUTTING_POINTS + "|" +
                    getXpMulti(pi, playerid.ToString());
            }
            return string.Empty;
        }

        private bool api_SetPlayerInfo(ulong userid, string data)
        {
            if (userid == 0 || data == null) { return false; }
            if (!this.data.PlayerInfo.TryGetValue(userid, out var pi))
            {
                this.data.PlayerInfo[userid] = pi = CreatePlayerInfo();
                pi.LAST_DEATH = ToEpochTime(DateTime.UtcNow);
                pi.CUI = config.generic.playerCuiDefaultEnabled;
                pi.ENABLED = config.generic.playerPluginDefaultEnabled;
            }
            string[] split = data.Split('|');
            if (split.Length < 14)
            {
                return false;
            }
            pi.ACQUIRE_LEVEL = double.Parse(split[0]);
            pi.ACQUIRE_POINTS = double.Parse(split[1]);
            pi.CRAFTING_LEVEL = double.Parse(split[2]);
            pi.CRAFTING_POINTS = double.Parse(split[3]);
            pi.CUI = bool.Parse(split[4]);
            pi.LAST_DEATH = double.Parse(split[5]);
            pi.MINING_LEVEL = double.Parse(split[6]);
            pi.MINING_POINTS = double.Parse(split[7]);
            pi.ENABLED = bool.Parse(split[8]);
            pi.SKINNING_LEVEL = double.Parse(split[9]);
            pi.SKINNING_POINTS = double.Parse(split[10]);
            pi.WOODCUTTING_LEVEL = double.Parse(split[11]);
            pi.WOODCUTTING_POINTS = double.Parse(split[12]);
            pi.XP_MULTIPLIER = double.Parse(split[13]);
            BasePlayer target = BasePlayer.FindByID(userid);
            if (target != null && target.IsConnected)
            {
                DestroyGUI(target);
                CreateGUI(target, pi);
            }
            return true;
        }

        #endregion API
    }
}

// --- End of file: ZLevelsRemastered.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-chat-prefix ---
// --- Original File Path: Z/ZoneChatPrefix/ZoneChatPrefix.cs ---

// Requires: ZoneManager

using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Zone Chat Prefix", "BuzZ", "0.0.5")]
    [Description("Adds a zone prefix to player chat")]
    public class ZoneChatPrefix : RustPlugin
    {
        [PluginReference]     
        Plugin ZoneManager;
        
        bool debug = false;

        public List<BasePlayer> blabla = new List<BasePlayer>();

#region ZONEMANAGER HOOKS

        string StringZonesPlayerIsIn(BasePlayer player)
        {
            string[] array = (string[]) ZoneManager.Call("GetPlayerZoneIDs", player);
            string message = string.Empty;
            if (array == null)
            {
                return "NOPE";
            }
            else
            {
                if (debug) Puts($"Count {array.Count()} ZONE(s)");
                int round = 1;
                int Round = 1;
                for (Round = 1; round <= array.Count() ; Round++)            
                {
                    string zone_name = GetThatZoneNamePlease(array[round-1]);
                    if (string.IsNullOrEmpty(message))
                    {
                        if (zone_name == "NOTFOUND")
                        {
                            message = $"[{array[round-1]}]";
                        }
                        else message = $"[{zone_name}]";
                    }
                    else
                    {
                        if (zone_name == "NOTFOUND")
                        {
                            message = $"{message} [{array[round-1]}]";
                        }
                        else message = $"{message} [{zone_name}] ";
                    }
                    if (debug) Puts($"{player.userID} - {player.displayName}");
                    if (debug) Puts($"round {round}");
                    round = round + 1;
                }
                return message;
            }
        }

        string GetThatZoneNamePlease (string zone_id)
        {
            string zone_name = (string)ZoneManager.Call("GetZoneName", zone_id);
            if (debug) Puts($"zone_name {zone_name}");
            if (string.IsNullOrEmpty(zone_name)) return "NOTFOUND";
            else return zone_name;
        }

#endregion
#region PLAYERCHAT
        object OnPlayerChat(BasePlayer player, string message)
        {
            if (debug) Puts("OnPlayerChat");
            if (blabla.Contains(player)) return null;
            string zones = StringZonesPlayerIsIn(player);
            if (zones != "NOPE")
            {
                string playername = player.displayName + " ";
                if (player.net.connection.authLevel == 2) playername = $"<color=green>{playername}</color>";
                if (debug) Puts("OnPlayerChat - is in zone(s) !");
                Server.Broadcast(message, zones +" " + playername , player.userID);
                blabla.Add(player);
                timer.Once(1f, () =>
                {
                    blabla.Remove(player);                    
                });
                return true;
            }
            else
            {
                if (debug) Puts("Not in Zone");
                return null;
            }
        }
#endregion
    }
}


// --- End of file: ZoneChatPrefix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-command ---
// --- Original File Path: Z/ZoneCommand/ZoneCommand.cs ---

//#define DEBUG
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Zone Command", "misticos", "1.0.0")]
    [Description("Execute commands when player enters a zone")]
    class ZoneCommand : CovalencePlugin
    {
        #region Variables

        private const string PermissionCommand = "zonecommand.command";

        [PluginReference("PlaceholderAPI")]
        private Plugin _placeholders = null;

        private Action<IPlayer, StringBuilder, bool> _placeholderProcessor = null;
        private StringBuilder _builder = new StringBuilder();

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Commands")]
            public string[] Commands = { "zone", "zonecommand", "zc" };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Work with Data

        #region ZoneData

        private Dictionary<string, HashSet<ZoneAction>> _actionsPerZone = new Dictionary<string, HashSet<ZoneAction>>();
        private Dictionary<string, ZoneData> _loadedData = new Dictionary<string, ZoneData>();

        private string[] GetAllData()
        {
            try
            {
                return Interface.Oxide.DataFileSystem.GetFiles(nameof(ZoneCommand));
            }
            catch (Exception)
            {
                return Array.Empty<string>();
            }
        }

        private void SaveData(string filename)
        {
            ZoneData data;
            if (!_loadedData.TryGetValue(filename, out data))
                return;

            Interface.Oxide.DataFileSystem.WriteObject(nameof(ZoneCommand) + Path.DirectorySeparatorChar + filename,
                data);
        }

        private ZoneData GetOrLoadData(string filename)
        {
            ZoneData data;
            if (_loadedData.TryGetValue(filename, out data))
                return data;

            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<ZoneData>(nameof(ZoneCommand) +
                                                                           Path.DirectorySeparatorChar + filename);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            // 300 IQ move xd
            _loadedData[filename] = data = data ?? new ZoneData();

            HashSet<ZoneAction> actions;
            if (!_actionsPerZone.TryGetValue(data.Zone, out actions))
                _actionsPerZone[data.Zone] = actions = new HashSet<ZoneAction>();

            foreach (var action in data.Actions)
            {
                actions.Add(action);
            }

            return data;
        }

        private class ZoneData
        {
            [JsonIgnore]
            public string Filename = string.Empty;

            [JsonProperty("Zone ID")] // array?
            public string Zone = string.Empty;

            [JsonProperty("Actions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ZoneAction> Actions = new List<ZoneAction> { new ZoneAction() };
        }

        private class ZoneAction
        {
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("Frequency")]
            public FrequencyMode Frequency = FrequencyMode.Always;

            [JsonProperty("Time Frequency")]
            public TimeSpan? Time = null;

            [JsonProperty("Use Game Time")]
            public bool GameTime = false;

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("Run On")]
            public RunMode RunOn = RunMode.Enter;

            [JsonProperty("Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ZoneCommand> Commands = new List<ZoneCommand> { new ZoneCommand() };

            public class ZoneCommand
            {
                [JsonProperty("Command")]
                public string Command = string.Empty;

                [JsonProperty("Arguments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public object[] Arguments = Array.Empty<object>();

                [JsonProperty("Clientside")]
                public bool Clientside = false;

                [JsonProperty("Chat Command")]
                public bool Chat = false;

                public void Execute(BasePlayer player, Oxide.Plugins.ZoneCommand instance)
                {
                    var command = Command;
                    if (Chat && Clientside)
                        command = '/' + command;

                    command = ConsoleSystem.BuildCommand(command, Arguments);

                    // TODO: own BuildCommand with placeholders per argument? for better performance with string builder and such
                    if (instance._placeholderProcessor != null)
                    {
                        instance._builder.Append(command);
                        instance._placeholderProcessor.Invoke(player.IPlayer, instance._builder, false);

                        command = instance._builder.ToString();
                        instance._builder.Clear();
                    }

                    if (Chat && Clientside)
                        command = ConsoleSystem.BuildCommand("chat.say", command);

#if DEBUG
                    instance.Puts($"Executing (Clientside: {Clientside} / For: {player.UserIDString}): {command}");
#endif

                    if (Clientside)
                    {
                        player.SendConsoleCommand(command);
                    }
                    else
                        ConsoleSystem.Run(ConsoleSystem.Option.Server, command);
                }
            }

            public enum FrequencyMode
            {
                Once,
                Always,
                PerPlayer
            }

            public enum RunMode
            {
                Enter,
                Exit
            }
        }

        #endregion

        #region ZoneMeta

        private Dictionary<string, ZoneActionMeta> _metas = new Dictionary<string, ZoneActionMeta>();

        private string[] GetAllMeta()
        {
            try
            {
                return Interface.Oxide.DataFileSystem.GetFiles(nameof(ZoneCommand) + "Meta");
            }
            catch (Exception)
            {
                return Array.Empty<string>();
            }
        }

        private void SaveMeta(string filename)
        {
            ZoneActionMeta data;
            if (!_metas.TryGetValue(filename, out data))
                return;

            Interface.Oxide.DataFileSystem.WriteObject(
                nameof(ZoneCommand) + "Meta" + Path.DirectorySeparatorChar + filename, data);
        }

        private ZoneActionMeta GetOrLoadMeta(string filename)
        {
            ZoneActionMeta data;
            if (_metas.TryGetValue(filename, out data))
                return data;

            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<ZoneActionMeta>(nameof(ZoneCommand) + "Meta" +
                    Path.DirectorySeparatorChar + filename);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            return _metas[filename] = data ?? new ZoneActionMeta();
        }

        private class ZoneActionMeta
        {
            public Dictionary<ulong, List<DateTime>> TriggerTime = new Dictionary<ulong, List<DateTime>>();
            public Dictionary<ulong, List<DateTime>> TriggerGameTime = new Dictionary<ulong, List<DateTime>>();

            public List<DateTime> GetTriggerTime(ulong id)
            {
                List<DateTime> times;
                if (TriggerTime.TryGetValue(id, out times))
                    return times;

                return TriggerTime[id] = new List<DateTime>();
            }

            public List<DateTime> GetTriggerGameTime(ulong id)
            {
                List<DateTime> times;
                if (TriggerGameTime.TryGetValue(id, out times))
                    return times;

                return TriggerGameTime[id] = new List<DateTime>();
            }
        }

        #endregion

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You do not have enough permissions" },
                {
                    "Command: Syntax", "Syntax:\n" +
                                       "create [Zone ID] - Create a datafile"
                },
                {
                    "Command: Create: Done",
                    "Created a datafile: /oxide/data/ZoneCommand/{filename}.json (You can rename it)"
                }
            }, this);
        }

        private void Init()
        {
            permission.RegisterPermission(PermissionCommand, this);

            AddCovalenceCommand(_config.Commands, nameof(CommandZone));

            var json = ".json".Length;
            foreach (var filename in GetAllData())
            {
                var slashIndex = filename.LastIndexOf(Path.DirectorySeparatorChar);
                var name = filename.Substring(slashIndex + 1, filename.Length - slashIndex - 1 - json);
#if DEBUG
                Puts($"Found file: {filename}\nCharacter: {Path.DirectorySeparatorChar}, Index: {slashIndex}; Name: {name}");
#endif

                GetOrLoadData(name);
            }
        }

        private void OnServerSave()
        {
            var i = 1;
            foreach (var filename in _metas.Keys)
            {
                timer.Once(i++, () => SaveMeta(filename));
            }
        }

        private void OnEnterZone(string zoneId, BasePlayer player)
        {
            OnZone(zoneId, player, ZoneAction.RunMode.Enter);
        }

        private void OnExitZone(string zoneId, BasePlayer player)
        {
            OnZone(zoneId, player, ZoneAction.RunMode.Exit);
        }

        private void OnPlaceholderAPIReady()
        {
            _placeholderProcessor =
                _placeholders.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1);
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name != "PlaceholderAPI")
                return;

            _placeholderProcessor = null;
        }

        #endregion

        #region Handling

        private void OnZone(string id, BasePlayer player, ZoneAction.RunMode mode)
        {
#if DEBUG
            Puts($"OnZone called: {id} for {player.displayName}: {mode}");
#endif

            HashSet<ZoneAction> actions;
            if (!_actionsPerZone.TryGetValue(id, out actions))
            {
#if DEBUG
                Puts("No actions were found");
#endif
                return;
            }

            var meta = GetOrLoadMeta(id);

            var now = DateTime.UtcNow;
            var gameNow = TOD_Sky.Instance.Cycle.DateTime;

            var triggerTime = meta.GetTriggerTime(player.userID);
            var triggerGameTime = meta.GetTriggerGameTime(player.userID);

            foreach (var action in actions)
            {
#if DEBUG
                Puts($"Proceeding with Action.RunOn: {action.RunOn} / {action.Frequency}");
#endif
                if (action.RunOn != mode)
                    continue;

                switch (action.Frequency)
                {
                    case ZoneAction.FrequencyMode.Always:
                    {
                        break;
                    }

                    case ZoneAction.FrequencyMode.Once:
                    {
                        var list = action.GameTime ? meta.TriggerGameTime : meta.TriggerTime;
                        if (action.Time == null)
                        {
                            if (list.Count == 0)
                                break;

#if DEBUG
                            Puts("Once ded :/");
#endif
                            continue;
                        }

                        var flag = false;
                        foreach (var kvp in list)
                        {
                            if (kvp.Value.Count == 0)
                                continue;

                            if (now - kvp.Value[0] < action.Time.Value)
                                continue;

#if DEBUG
                            Puts("Once ded :/ but with time");
#endif
                            flag = true;
                            break;
                        }

                        if (flag)
                            continue;

                        break;
                    }

                    case ZoneAction.FrequencyMode.PerPlayer:
                    {
                        var list = action.GameTime
                            ? meta.GetTriggerGameTime(player.userID)
                            : meta.GetTriggerTime(player.userID);

                        if (action.Time == null)
                        {
                            if (list.Count == 0)
                                break;

#if DEBUG
                            Puts("PerPlayer ded :/");
#endif
                            continue;
                        }

                        if (list.Count != 0 && now - list[0] > action.Time.Value)
                        {
#if DEBUG
                            Puts("PerPlayer ded :/ but with time");
#endif
                            continue;
                        }

                        break;
                    }
                }

                foreach (var command in action.Commands)
                {
                    command.Execute(player, this);
                }
            }

            if (mode == ZoneAction.RunMode.Enter)
            {
                triggerTime.Add(now);
                triggerGameTime.Add(gameNow);
            }
        }

        #endregion

        #region Commands

        private void CommandZone(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionCommand))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            if (args.Length == 0)
                goto syntax;

            switch (args[0].ToLower())
            {
                case "create":
                {
                    var filename = Guid.NewGuid().ToString("N");
                    var zone = GetOrLoadData(filename);
                    if (args.Length >= 2)
                        zone.Zone = string.Join(" ", args.Skip(1));

                    SaveData(filename);
                    player.Reply(GetMsg("Command: Create: Done", player.Id).Replace("{filename}", filename));
                    return;
                }
            }

            syntax:
            player.Reply(GetMsg("Command: Syntax", player.Id));
        }

        #endregion

        #region Helpers

        private string GetMsg(string key, string id) => lang.GetMessage(key, this, id);

        #endregion
    }
}

// --- End of file: ZoneCommand.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-manager-auto-zones ---
// --- Original File Path: Z/ZoneManagerAutoZones/ZoneManagerAutoZones.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Zone Manager Auto Zones", "FastBurst", "1.4.0")]
    [Description("Adds zones and domes to monuments automatically.")]

    public class ZoneManagerAutoZones : RustPlugin
    {
        [PluginReference] Plugin ZoneManager, ZoneDomes, TruePVE, NextGenPVE;
        #region Vars
        BasePlayer player;
        #endregion

        #region Oxide Hooks
        void OnServerInitialized()
        {
            PopulateZoneLocations();
        }
        #endregion

        #region Functions
        private void PopulateZoneLocations()
        {
            ConfigData.LocationOptions.Monument config = configData.Location.Monuments;

            MonumentInfo[] monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
            int miningoutpost = 0, lighthouse = 0, gasstation = 0, supermarket = 0, compound = 0;
            for (int i = 0; i < monuments.Length; i++)
            {
                MonumentInfo monument = monuments[i];
                if (monument.name.Contains("harbor_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = "Large " + monument.displayPhrase.english;
                    string ID = "harbor_1";

                    if (config.HarborLarge.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.HarborLarge.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.HarborLarge.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.HarborLarge.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.HarborLarge.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.HarborLarge.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.HarborLarge.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.HarborLarge.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("harbor_2", CompareOptions.IgnoreCase))
                {
                    string friendlyname = "Small " + monument.displayPhrase.english;
                    string ID = "harbor_2";

                    if (config.HarborSmall.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.HarborSmall.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.HarborSmall.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.HarborSmall.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.HarborSmall.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.HarborSmall.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.HarborSmall.TruePVERules);

                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.HarborSmall.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("airfield_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "airfield_1";

                    if (config.Airfield.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Airfield.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Airfield.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Airfield.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Airfield.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Airfield.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Airfield.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Airfield.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("launch_site_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "launch_site";

                    if (config.LaunchSite.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.LaunchSite.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.LaunchSite.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.LaunchSite.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.LaunchSite.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.LaunchSite.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LaunchSite.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LaunchSite.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("oilrig_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "oilrig_1";

                    if (config.LargeOilRig.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.LargeOilRig.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.LargeOilRig.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.LargeOilRig.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.LargeOilRig.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.LargeOilRig.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LargeOilRig.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LargeOilRig.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("oilrig_2", CompareOptions.IgnoreCase))
                {
                    string friendlyname = "Small " + monument.displayPhrase.english;
                    string ID = "oilrig_2";

                    if (config.SmallOilRig.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SmallOilRig.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SmallOilRig.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SmallOilRig.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SmallOilRig.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SmallOilRig.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SmallOilRig.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SmallOilRig.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("powerplant_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "powerplant_1";

                    if (config.Powerplant.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Powerplant.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Powerplant.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Powerplant.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Powerplant.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Powerplant.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Powerplant.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Powerplant.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("military_tunnel_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "military_tunnel_1";

                    if (config.MilitaryTunnels.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.MilitaryTunnels.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.MilitaryTunnels.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.MilitaryTunnels.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.MilitaryTunnels.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.MilitaryTunnels.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MilitaryTunnels.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MilitaryTunnels.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("junkyard_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "junkyard_1";

                    if (config.Junkyard.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Junkyard.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Junkyard.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Junkyard.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Junkyard.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Junkyard.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Junkyard.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Junkyard.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("water_treatment_plant_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "water_treatment_plant_1";

                    if (config.WaterTreatment.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.WaterTreatment.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.WaterTreatment.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.WaterTreatment.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.WaterTreatment.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.WaterTreatment.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.WaterTreatment.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.WaterTreatment.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("trainyard_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "trainyard_1";

                    if (config.TrainYard.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.TrainYard.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.TrainYard.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.TrainYard.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.TrainYard.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.TrainYard.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.TrainYard.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.TrainYard.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("excavator", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "excavator";

                    if (config.Excavator.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Excavator.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Excavator.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Excavator.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Excavator.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Excavator.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Excavator.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Excavator.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);

                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("satellite_dish", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "satellite_dish";

                    if (config.SatelliteDish.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SatelliteDish.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SatelliteDish.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SatelliteDish.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SatelliteDish.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SatelliteDish.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SatelliteDish.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SatelliteDish.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("radtown_small_3", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "radtown_small_3";

                    if (config.SewerBranch.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SewerBranch.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SewerBranch.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SewerBranch.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SewerBranch.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SewerBranch.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SewerBranch.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SewerBranch.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("sphere_tank", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "sphere_tank";

                    if (config.Dome.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Dome.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Dome.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Dome.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Dome.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Dome.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Dome.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Dome.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("gas_station_1", CompareOptions.IgnoreCase) && gasstation == 0)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "gas_station_1";

                    if (config.GasStation1.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.GasStation1.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.GasStation1.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.GasStation1.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.GasStation1.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.GasStation1.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation1.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation1.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    gasstation++;
                    continue;
                }

                if (monument.name.Contains("gas_station_1", CompareOptions.IgnoreCase) && gasstation == 1)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "gas_station_2";

                    if (config.GasStation2.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.GasStation2.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.GasStation2.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.GasStation2.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.GasStation2.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.GasStation2.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation2.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation2.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    gasstation++;
                    continue;
                }

                if (monument.name.Contains("gas_station_1", CompareOptions.IgnoreCase) && gasstation == 2)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "gas_station_3";

                    if (config.GasStation3.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #3";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.GasStation3.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.GasStation3.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.GasStation3.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.GasStation3.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.GasStation3.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation3.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.GasStation3.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    gasstation++;
                    continue;
                }

                if (monument.name.Contains("mining_quarry_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "mining_quarry_a";

                    if (config.QuarryA.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.QuarryA.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.QuarryA.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.QuarryA.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.QuarryA.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.QuarryA.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryA.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryA.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("mining_quarry_b", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "mining_quarry_b";

                    if (config.QuarryB.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.QuarryB.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.QuarryB.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.QuarryB.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.QuarryB.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.QuarryB.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryB.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryB.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("mining_quarry_c", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "mining_quarry_c";

                    if (config.QuarryC.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.QuarryC.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.QuarryC.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.QuarryC.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.QuarryC.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.QuarryC.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryC.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.QuarryC.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("swamp_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "swamp_a";

                    if (config.SwampA.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SwampA.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SwampA.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SwampA.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SwampA.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SwampA.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampA.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampA.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("swamp_b", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "swamp_b";

                    if (config.SwampB.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SwampB.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SwampB.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SwampB.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SwampB.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SwampB.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampB.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampB.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("swamp_c", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "swamp_c";

                    if (config.SwampC.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.SwampC.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.SwampC.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.SwampC.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.SwampC.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.SwampC.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampC.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.SwampC.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("lighthouse", CompareOptions.IgnoreCase) && lighthouse == 0)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "lighthouse_1";

                    if (config.LightHouse1.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.LightHouse1.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.LightHouse1.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.LightHouse1.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.LightHouse1.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.LightHouse1.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LightHouse1.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LightHouse1.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    lighthouse++;
                    continue;
                }

                if (monument.name.Contains("lighthouse", CompareOptions.IgnoreCase) && lighthouse == 1)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "lighthouse_2";

                    if (config.LightHouse2.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.LightHouse2.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.LightHouse2.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.LightHouse2.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.LightHouse2.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.LightHouse2.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LightHouse2.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.LightHouse2.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    lighthouse++;
                    continue;
                }

                if (monument.name.Contains("supermarket_1", CompareOptions.IgnoreCase) && supermarket == 0)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "supermarket_1";

                    if (config.Supermarket1.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Supermarket1.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Supermarket1.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Supermarket1.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Supermarket1.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Supermarket1.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket1.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket1.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    supermarket++;
                    continue;
                }

                if (monument.name.Contains("supermarket_1", CompareOptions.IgnoreCase) && supermarket == 1)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "supermarket_2";

                    if (config.Supermarket2.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Supermarket2.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Supermarket2.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Supermarket2.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Supermarket2.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Supermarket2.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket2.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket2.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    supermarket++;
                    continue;
                }

                if (monument.name.Contains("supermarket_1", CompareOptions.IgnoreCase) && supermarket == 2)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "supermarket_3";

                    if (config.Supermarket3.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #3";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Supermarket3.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Supermarket3.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Supermarket3.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Supermarket3.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Supermarket3.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket3.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Supermarket3.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    supermarket++;
                    continue;
                }

                if (monument.name.Contains("warehouse", CompareOptions.IgnoreCase) && miningoutpost == 0)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "miningoutpost_1";

                    if (config.MiningOutpost1.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.MiningOutpost1.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.MiningOutpost1.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.MiningOutpost1.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.MiningOutpost1.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.MiningOutpost1.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost1.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost1.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    miningoutpost++;
                    continue;
                }

                if (monument.name.Contains("warehouse", CompareOptions.IgnoreCase) && miningoutpost == 1)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "miningoutpost_2";

                    if (config.MiningOutpost2.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.MiningOutpost2.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.MiningOutpost2.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.MiningOutpost2.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.MiningOutpost2.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.MiningOutpost2.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost2.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost2.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    miningoutpost++;
                    continue;
                }

                if (monument.name.Contains("warehouse", CompareOptions.IgnoreCase) && miningoutpost == 2)
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "miningoutpost_3";

                    if (config.MiningOutpost3.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #3";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.MiningOutpost3.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.MiningOutpost3.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.MiningOutpost3.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.MiningOutpost3.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.MiningOutpost3.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost3.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.MiningOutpost3.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    miningoutpost++;
                    continue;
                }

                if (monument.name.Contains("fishing_village_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "fishing_village_a";

                    if (config.FishingVillage1.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.FishingVillage1.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.FishingVillage1.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.FishingVillage1.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.FishingVillage1.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.FishingVillage1.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage1.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage1.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("fishing_village_b", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "fishing_village_b";

                    if (config.FishingVillage2.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #2";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.FishingVillage2.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.FishingVillage2.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.FishingVillage2.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.FishingVillage2.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.FishingVillage2.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage2.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage2.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("fishing_village_c", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "fishing_village_c";

                    if (config.FishingVillage3.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #3";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.FishingVillage3.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.FishingVillage3.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.FishingVillage3.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.FishingVillage3.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.FishingVillage3.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage3.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.FishingVillage3.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("compound"))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "compound_1";

                    if (config.Outpost.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.Outpost.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.Outpost.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.Outpost.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.Outpost.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.Outpost.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Outpost.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.Outpost.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("bandit_town"))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "bandit_town_1";

                    if (config.BanditCamp.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.BanditCamp.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.BanditCamp.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.BanditCamp.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.BanditCamp.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.BanditCamp.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.BanditCamp.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.BanditCamp.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("desert_military_base_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "desert_military_base_a";

                    if (config.DesertBaseA.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.DesertBaseA.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.DesertBaseA.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.DesertBaseA.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.DesertBaseA.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.DesertBaseA.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseA.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseA.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("desert_military_base_b", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "desert_military_base_b";

                    if (config.DesertBaseB.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.DesertBaseB.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.DesertBaseB.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.DesertBaseB.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.DesertBaseB.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.DesertBaseB.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseB.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseB.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("desert_military_base_c", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "desert_military_base_c";

                    if (config.DesertBaseC.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.DesertBaseC.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.DesertBaseC.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.DesertBaseC.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.DesertBaseC.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.DesertBaseC.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseC.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseC.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("desert_military_base_d", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "desert_military_base_d";

                    if (config.DesertBaseD.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname + " #1";
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.DesertBaseD.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.DesertBaseD.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.DesertBaseD.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.DesertBaseD.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.DesertBaseD.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseD.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.DesertBaseD.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("stables_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "stables_a";

                    if (config.StableA.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.StableA.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.StableA.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.StableA.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.StableA.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.StableA.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.StableA.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.StableA.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("stables_b", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "stables_b";

                    if (config.StableB.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.StableB.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.StableB.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.StableB.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.StableB.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.StableB.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.StableB.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.StableB.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("arctic_research_base_a", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "arctic_research_base_a";

                    if (config.ArticA.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.ArticA.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.ArticA.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.ArticA.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.ArticA.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.ArticA.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.ArticA.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.ArticA.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("nuclear_missile_Silo", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "nuclear_missile_Silo";

                    if (config.missileSilo.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.missileSilo.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.missileSilo.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.missileSilo.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.missileSilo.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.missileSilo.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.missileSilo.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.missileSilo.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("ferry_terminal_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "ferry_terminal_1";

                    if (config.ferryTerminal.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.ferryTerminal.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.ferryTerminal.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.ferryTerminal.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.ferryTerminal.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.ferryTerminal.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.ferryTerminal.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.ferryTerminal.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }

                if (monument.name.Contains("radtown_1", CompareOptions.IgnoreCase))
                {
                    string friendlyname = monument.displayPhrase.english;
                    string ID = "radtown_1";

                    if (config.radTown.Enabled)
                    {
                        string[] messages = new string[8];
                        messages[0] = "name";
                        messages[1] = friendlyname;
                        messages[2] = "enter_message";
                        messages[3] = configData.Location.Monuments.radTown.EnterMessage;
                        messages[4] = "leave_message";
                        messages[5] = configData.Location.Monuments.radTown.LeaveMessage;
                        messages[6] = "radius";
                        messages[7] = Convert.ToInt32(configData.Location.Monuments.radTown.Radius).ToString();

                        ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, monument.transform.position);

                        if (configData.Location.Monuments.radTown.ZoneFlags != null)
                            foreach (var flag in configData.Location.Monuments.radTown.ZoneFlags)
                                ZoneManager?.CallHook("AddFlag", ID, flag);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.radTown.TruePVERules);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("AddOrUpdateMapping", ID, configData.Location.Monuments.radTown.NextGenPVERules);

                        if (configData.ZoneOption.UseZoneDomes)
                        {
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                            ZoneDomes?.CallHook("AddNewDome", player, ID);
                        }
                    }
                    else
                    {
                        ZoneManager?.CallHook("EraseZone", ID);

                        if (configData.ZoneOption.UseTruePVE)
                            TruePVE?.CallHook("RemoveMapping", ID);
                        else if (configData.ZoneOption.UseNextGenPVE)
                            NextGenPVE?.CallHook("RemoveMapping", ID);

                        if (configData.ZoneOption.UseZoneDomes)
                            ZoneDomes?.CallHook("RemoveExistingDome", player, ID);
                    }
                    continue;
                }
            }

            if (configData.ZoneOption.UseZoneDomes)
            {
                ZoneDomes?.Call("DestroyAllSpheres", player);
                ZoneDomes?.Call("OnServerInitialized", player);
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "ZonesDome Option")]
            public Options ZoneOption { get; set; }
            public class Options
            {
                [JsonProperty(PropertyName = "Use Zone Domes Spheres over Zones")]
                public bool UseZoneDomes { get; set; }
                [JsonProperty(PropertyName = "Enable TruePVE to allow Rule Sets")]
                public bool UseTruePVE { get; set; }
                [JsonProperty(PropertyName = "Enable NextGenPVE to allow Rule Sets")]
                public bool UseNextGenPVE { get; set; }
            }

            [JsonProperty(PropertyName = "Zone Location Options")]
            public LocationOptions Location { get; set; }

            public class LocationOptions
            {
                [JsonProperty(PropertyName = "Monument Options")]
                public Monument Monuments { get; set; }

                public class Monument
                {
                    [JsonProperty(PropertyName = "Airfield")]
                    public Options Airfield { get; set; }
                    [JsonProperty(PropertyName = "Small Harbour")]
                    public Options HarborSmall { get; set; }
                    [JsonProperty(PropertyName = "Large Harbour")]
                    public Options HarborLarge { get; set; }
                    [JsonProperty(PropertyName = "Launch Site")]
                    public Options LaunchSite { get; set; }
                    [JsonProperty(PropertyName = "Large Oil Rig")]
                    public Options LargeOilRig { get; set; }
                    [JsonProperty(PropertyName = "Small Oil Rig")]
                    public Options SmallOilRig { get; set; }
                    [JsonProperty(PropertyName = "Power Plant")]
                    public Options Powerplant { get; set; }
                    [JsonProperty(PropertyName = "Junk Yard")]
                    public Options Junkyard { get; set; }
                    [JsonProperty(PropertyName = "Military Tunnels")]
                    public Options MilitaryTunnels { get; set; }
                    [JsonProperty(PropertyName = "Train Yard")]
                    public Options TrainYard { get; set; }
                    [JsonProperty(PropertyName = "Water Treatment Plant")]
                    public Options WaterTreatment { get; set; }
                    [JsonProperty(PropertyName = "Giant Excavator Pit")]
                    public Options Excavator { get; set; }
                    [JsonProperty(PropertyName = "Satellite Dish")]
                    public Options SatelliteDish { get; set; }
                    [JsonProperty(PropertyName = "Sewer Branch")]
                    public Options SewerBranch { get; set; }
                    [JsonProperty(PropertyName = "The Dome")]
                    public Options Dome { get; set; }
                    [JsonProperty(PropertyName = "Oxum's Gas Station #1")]
                    public Options GasStation1 { get; set; }
                    [JsonProperty(PropertyName = "Oxum's Gas Station #2")]
                    public Options GasStation2 { get; set; }
                    [JsonProperty(PropertyName = "Oxum's Gas Station #3")]
                    public Options GasStation3 { get; set; }
                    [JsonProperty(PropertyName = "Sulfur Quarry")]
                    public Options QuarryA { get; set; }
                    [JsonProperty(PropertyName = "Stone Quarry")]
                    public Options QuarryB { get; set; }
                    [JsonProperty(PropertyName = "HQM Quarry")]
                    public Options QuarryC { get; set; }
                    [JsonProperty(PropertyName = "Wild Swamp 1")]
                    public Options SwampA { get; set; }
                    [JsonProperty(PropertyName = "Wild Swamp 2")]
                    public Options SwampB { get; set; }
                    [JsonProperty(PropertyName = "Abandoned Cabins")]
                    public Options SwampC { get; set; }
                    [JsonProperty(PropertyName = "Light House #1")]
                    public Options LightHouse1 { get; set; }
                    [JsonProperty(PropertyName = "Light House #2")]
                    public Options LightHouse2 { get; set; }
                    [JsonProperty(PropertyName = "Abandoned Supermarket #1")]
                    public Options Supermarket1 { get; set; }
                    [JsonProperty(PropertyName = "Abandoned Supermarket #2")]
                    public Options Supermarket2 { get; set; }
                    [JsonProperty(PropertyName = "Abandoned Supermarket #3")]
                    public Options Supermarket3 { get; set; }
                    [JsonProperty(PropertyName = "Mining Outpost #1")]
                    public Options MiningOutpost1 { get; set; }
                    [JsonProperty(PropertyName = "Mining Outpost #2")]
                    public Options MiningOutpost2 { get; set; }
                    [JsonProperty(PropertyName = "Mining Outpost #3")]
                    public Options MiningOutpost3 { get; set; }
                    [JsonProperty(PropertyName = "Fishing Village #1")]
                    public Options FishingVillage1 { get; set; }
                    [JsonProperty(PropertyName = "Fishing Village #2")]
                    public Options FishingVillage2 { get; set; }
                    [JsonProperty(PropertyName = "Fishing Village #3")]
                    public Options FishingVillage3 { get; set; }
                    [JsonProperty(PropertyName = "Outpost")]
                    public Options Outpost { get; set; }
                    [JsonProperty(PropertyName = "Bandit Camp")]
                    public Options BanditCamp { get; set; }
                    [JsonProperty(PropertyName = "Desert Base 1")]
                    public Options DesertBaseA { get; set; }
                    [JsonProperty(PropertyName = "Desert Base 2")]
                    public Options DesertBaseB { get; set; }
                    [JsonProperty(PropertyName = "Desert Base 3")]
                    public Options DesertBaseC { get; set; }
                    [JsonProperty(PropertyName = "Desert Base 4")]
                    public Options DesertBaseD { get; set; }
                    [JsonProperty(PropertyName = "Stables")]
                    public Options StableA { get; set; }
                    [JsonProperty(PropertyName = "Ranch")]
                    public Options StableB { get; set; }
                    [JsonProperty(PropertyName = "Artic Research Base")]
                    public Options ArticA { get; set; }
                    [JsonProperty(PropertyName = "Nuclear Missile Silo")]
                    public Options missileSilo { get; set; }
                    [JsonProperty(PropertyName = "Ferry Terminal")]
                    public Options ferryTerminal { get; set; }
                    [JsonProperty(PropertyName = "Rad Town")]
                    public Options radTown { get; set; }
                    public class Options
                    {
                        public bool Enabled { get; set; }
                        [JsonProperty(PropertyName = "Radius")]
                        public int Radius { get; set; }

                        [JsonProperty(PropertyName = "Enter Zone Message")]
                        public string EnterMessage { get; set; }

                        [JsonProperty(PropertyName = "Leave Zone Message")]
                        public string LeaveMessage { get; set; }

                        [JsonProperty(PropertyName = "Zone Flags")]
                        public string[] ZoneFlags { get; set; }
                        [JsonProperty(PropertyName = "TruePVE RuleSet to use if TruePVE is enabled")]
                        public string TruePVERules { get; set; }
                        [JsonProperty(PropertyName = "NextGenPVE RuleSet to use if NextGenPVE is enabled")]
                        public string NextGenPVERules { get; set; }
                        [JsonIgnore]
                        public List<MonumentInfo> Monument { get; set; } = new List<MonumentInfo>();
                    }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ZoneOption = new ConfigData.Options
                {
                    UseZoneDomes = true,
                    UseTruePVE = false,
                    UseNextGenPVE = false
                },
                Location = new ConfigData.LocationOptions
                {
                    Monuments = new ConfigData.LocationOptions.Monument
                    {
                        Airfield = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 200,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        HarborLarge = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 150,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        HarborSmall = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 145,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        LaunchSite = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 295,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SmallOilRig = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        LargeOilRig = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 165,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Powerplant = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 150,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Junkyard = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 165,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        MilitaryTunnels = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 115,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        TrainYard = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 165,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        WaterTreatment = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 175,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Excavator = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 205,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SatelliteDish = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SewerBranch = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Dome = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        GasStation1 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        GasStation2 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        GasStation3 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        QuarryA = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        QuarryB = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        QuarryC = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SwampA = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 95,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SwampB = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        SwampC = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        LightHouse1 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        LightHouse2 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 80,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Supermarket1 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Supermarket2 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Supermarket3 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        MiningOutpost1 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        MiningOutpost2 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        MiningOutpost3 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        FishingVillage1 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        FishingVillage2 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        FishingVillage3 = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 50,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        Outpost = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 135,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVP Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        BanditCamp = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVP Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        DesertBaseA = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        DesertBaseB = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        DesertBaseC = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        DesertBaseD = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        StableA = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVP Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        StableB = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = false,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a Safe Zone",
                            LeaveMessage = "Returning to PVP Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        ArticA = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        missileSilo = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 100,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        ferryTerminal = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 125,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        },
                        radTown = new ConfigData.LocationOptions.Monument.Options
                        {
                            Enabled = true,
                            Radius = 85,
                            EnterMessage = "WARNING: You are now entering a PVP Zone",
                            LeaveMessage = "Returning to PVE Area",
                            ZoneFlags = new string[] { "autolights" },
                            TruePVERules = "exclude",
                            NextGenPVERules = "exclude"
                        }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(1, 0, 0))
                configData.ZoneOption.UseZoneDomes = baseConfig.ZoneOption.UseZoneDomes;

            if (configData.Version < new Core.VersionNumber(1, 2, 0))
            {
                configData.Location.Monuments = baseConfig.Location.Monuments;
            }

            if (configData.Version < new Core.VersionNumber(1, 2, 1))
            {
                configData.Location.Monuments.GasStation1 = baseConfig.Location.Monuments.GasStation1;
                configData.Location.Monuments.GasStation2 = baseConfig.Location.Monuments.GasStation2;
            }

            if (configData.Version < new Core.VersionNumber(1, 2, 2))
            {
                configData.Location.Monuments.QuarryA = baseConfig.Location.Monuments.QuarryA;
                configData.Location.Monuments.QuarryB = baseConfig.Location.Monuments.QuarryB;
                configData.Location.Monuments.QuarryC = baseConfig.Location.Monuments.QuarryC;
                configData.Location.Monuments.SwampA = baseConfig.Location.Monuments.SwampA;
                configData.Location.Monuments.SwampB = baseConfig.Location.Monuments.SwampB;
                configData.Location.Monuments.SwampC = baseConfig.Location.Monuments.SwampC;
            }

            if (configData.Version < new Core.VersionNumber(1, 2, 3))
            {
                configData.Location.Monuments.MiningOutpost1 = baseConfig.Location.Monuments.MiningOutpost1;
                configData.Location.Monuments.MiningOutpost2 = baseConfig.Location.Monuments.MiningOutpost2;
                configData.Location.Monuments.MiningOutpost3 = baseConfig.Location.Monuments.MiningOutpost3;
                configData.Location.Monuments.Supermarket1 = baseConfig.Location.Monuments.Supermarket1;
                configData.Location.Monuments.Supermarket2 = baseConfig.Location.Monuments.Supermarket2;
                configData.Location.Monuments.Supermarket3 = baseConfig.Location.Monuments.Supermarket3;
                configData.Location.Monuments.LightHouse1 = baseConfig.Location.Monuments.LightHouse1;
                configData.Location.Monuments.LightHouse2 = baseConfig.Location.Monuments.LightHouse2;
            }

            if (configData.Version < new Core.VersionNumber(1, 2, 4))
                configData.Location.Monuments.GasStation3 = baseConfig.Location.Monuments.GasStation3;

            if (configData.Version < new Core.VersionNumber(1, 2, 5))
            {
                configData.Location.Monuments.FishingVillage1 = baseConfig.Location.Monuments.FishingVillage1;
                configData.Location.Monuments.FishingVillage2 = baseConfig.Location.Monuments.FishingVillage2;
                configData.Location.Monuments.FishingVillage3 = baseConfig.Location.Monuments.FishingVillage3;
            }

            if (configData.Version < new Core.VersionNumber(1, 2, 7))
            {
                configData.Location.Monuments.HarborLarge.NextGenPVERules = "exclude";
                configData.Location.Monuments.HarborSmall.NextGenPVERules = "exclude";
                configData.Location.Monuments.Airfield.NextGenPVERules = "exclude";
                configData.Location.Monuments.LargeOilRig.NextGenPVERules = "exclude";
                configData.Location.Monuments.SmallOilRig.NextGenPVERules = "exclude";
                configData.Location.Monuments.Powerplant.NextGenPVERules = "exclude";
                configData.Location.Monuments.MilitaryTunnels.NextGenPVERules = "exclude";
                configData.Location.Monuments.Junkyard.NextGenPVERules = "exclude";
                configData.Location.Monuments.WaterTreatment.NextGenPVERules = "exclude";
                configData.Location.Monuments.TrainYard.NextGenPVERules = "exclude";
                configData.Location.Monuments.Excavator.NextGenPVERules = "exclude";
                configData.Location.Monuments.SatelliteDish.NextGenPVERules = "exclude";
                configData.Location.Monuments.SewerBranch.NextGenPVERules = "exclude";
                configData.Location.Monuments.Dome.NextGenPVERules = "exclude";
                configData.Location.Monuments.GasStation1.NextGenPVERules = "exclude";
                configData.Location.Monuments.GasStation2.NextGenPVERules = "exclude";
                configData.Location.Monuments.GasStation3.NextGenPVERules = "exclude";
                configData.Location.Monuments.QuarryA.NextGenPVERules = "exclude";
                configData.Location.Monuments.QuarryB.NextGenPVERules = "exclude";
                configData.Location.Monuments.QuarryC.NextGenPVERules = "exclude";
                configData.Location.Monuments.SwampA.NextGenPVERules = "exclude";
                configData.Location.Monuments.SwampB.NextGenPVERules = "exclude";
                configData.Location.Monuments.SwampC.NextGenPVERules = "exclude";
                configData.Location.Monuments.MiningOutpost1.NextGenPVERules = "exclude";
                configData.Location.Monuments.MiningOutpost2.NextGenPVERules = "exclude";
                configData.Location.Monuments.MiningOutpost3.NextGenPVERules = "exclude";
                configData.Location.Monuments.Supermarket1.NextGenPVERules = "exclude";
                configData.Location.Monuments.Supermarket2.NextGenPVERules = "exclude";
                configData.Location.Monuments.Supermarket3.NextGenPVERules = "exclude";
                configData.Location.Monuments.LightHouse1.NextGenPVERules = "exclude";
                configData.Location.Monuments.LightHouse2.NextGenPVERules = "exclude";
                configData.Location.Monuments.FishingVillage1.NextGenPVERules = "exclude";
                configData.Location.Monuments.FishingVillage2.NextGenPVERules = "exclude";
                configData.Location.Monuments.FishingVillage3.NextGenPVERules = "exclude";
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 0))
            {
                configData.Location.Monuments.Outpost = baseConfig.Location.Monuments.Outpost;
                configData.Location.Monuments.BanditCamp = baseConfig.Location.Monuments.BanditCamp;
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 1))
            {
                configData.Location.Monuments.DesertBaseA = baseConfig.Location.Monuments.DesertBaseA;
                configData.Location.Monuments.DesertBaseB = baseConfig.Location.Monuments.DesertBaseB;
                configData.Location.Monuments.DesertBaseC = baseConfig.Location.Monuments.DesertBaseC;
                configData.Location.Monuments.DesertBaseD = baseConfig.Location.Monuments.DesertBaseD;
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 3))
            {
                configData.Location.Monuments.StableA = baseConfig.Location.Monuments.StableA;
                configData.Location.Monuments.StableB = baseConfig.Location.Monuments.StableB;
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 5))
            {
                configData.Location.Monuments.ArticA = baseConfig.Location.Monuments.ArticA;
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 7))
            {
                configData.Location.Monuments.missileSilo = baseConfig.Location.Monuments.missileSilo;
            }

            if (configData.Version < new Core.VersionNumber(1, 3, 9))
            {
                configData.Location.Monuments.ferryTerminal = baseConfig.Location.Monuments.ferryTerminal;
            }

            if (configData.Version < new Core.VersionNumber(1, 4, 0))
            {
                configData.Location.Monuments.radTown = baseConfig.Location.Monuments.radTown;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
    }
}

// --- End of file: ZoneManagerAutoZones.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-domes ---
// --- Original File Path: Z/ZoneDomes/ZoneDomes.cs ---

﻿using Facepunch;
using System;
using System.Text;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ZoneDomes", "k1lly0u", "2.0.2")]
    [Description("Assign shaded sphere entities to physically see the border of zones")]
    class ZoneDomes : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin ZoneManager;
        
        private StoredData _storedData;
        private DynamicConfigFile _dataFile;

        private const string SHADED_SPHERE = "assets/prefabs/visualization/sphere.prefab";
        private const string BR_SPHERE_RED = "assets/bundled/prefabs/modding/events/twitch/br_sphere_red.prefab";
        private const string BR_SPHERE_BLUE = "assets/bundled/prefabs/modding/events/twitch/br_sphere.prefab";
        private const string BR_SPHERE_GREEN = "assets/bundled/prefabs/modding/events/twitch/br_sphere_green.prefab";
        private const string BR_SPHERE_PURPLE = "assets/bundled/prefabs/modding/events/twitch/br_sphere_purple.prefab";

        private const string USE_PERMISSION = "zonedomes.admin";

        private readonly Hash<string, List<SphereEntity>> _sphereEntities = new Hash<string, List<SphereEntity>>();
        
        public enum SphereType { Standard, Red, Blue, Green, Purple }
        
        #endregion

        #region Oxide Hooks

        private void Loaded()
        {
            _dataFile = Interface.Oxide.DataFileSystem.GetFile("zonedomes_data");
            _dataFile.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };
            
            LoadData();
            
            permission.RegisterPermission(USE_PERMISSION, this);
        }

        private void OnServerInitialized()
            => InitializeDomes();

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error.NoInfo"] = "Unable to find information for: ",
                ["Error.NoEntity"] = "Unable to find the sphere entity for zone ID: ",
                ["Error.InvalidID"] = "Unable to validate the zone ID from ZoneManager for: ",
                ["Error.NoLocation"] = "Unable to retrieve location data from ZoneManager for: ",
                ["Error.NoRadius"] = "Unable to retrieve radius data from ZoneManager for: ",
                ["Error.NoZoneManager"] = "Unable to find ZoneManager, unable to proceed",
                ["Error.NoPermission"] = "You do not have permission to use this command",

                ["Notification.RemoveInvalidData"] = "Removing invalid zone data",
                ["Notification.RemoveSuccess"] = "You have successfully removed the sphere from zone: ",
                ["Notification.Created"] = "You have successfully created a sphere for the zone: ",
                ["Notification.InvalidZones"] = "Found {0} invalid zones. Removing them from data",
                ["Notification.AlreadyExists"] = "This zone already has a dome",
                
                ["Chat.Title"] = "<color=#ce422b>ZoneDomes</color>",
                ["Chat.AddSyntax"] = "<color=#ce422b>/zd add <zoneId> <opt:type> <opt:stack></color><color=#939393> - Adds a sphere to a zone</color>",
                ["Chat.RemoveSyntax"] = "<color=#ce422b>/zd remove <zoneId></color><color=#939393> - Removes a sphere from a zone</color>",
                ["Chat.ListSyntax"] = "<color=#ce422b>/zd list</color><color=#939393> - Lists all current active spheres and their position</color>",
                ["Chat.Types"] = "<color=#ce422b>Sphere Types</color><color=#939393>:\n" +
                                 "0 = <color=#464646>Standard</color>\n" +
                                 "1 = <color=#ce422b>Red</color>\n" +
                                 "2 = <color=#2b7fce>Blue</color>\n" +
                                 "3 = <color=#2bce7f>Green</color>\n" +
                                 "4 = <color=#7f2bce>Purple</color>\n" +
                                 "*NOTE : Colored spheres need to interact with terrain or objects in the world to be visible!</color>",
                
                ["Format.List"] = "--- Sphere List --- \n Zone ID -- Radius -- Position -- Color -- Stack"
            }, this);
        }

        private void Unload()
        {
            foreach (List<SphereEntity> list in _sphereEntities.Values)
            {
                foreach (SphereEntity sphere in list)
                {
                    if (sphere && !sphere.IsDestroyed)
                        sphere.Kill();
                }
            }
            
            _sphereEntities.Clear();
        }

        #endregion

        #region Functions

        private void InitializeDomes()
        {
            List<string> invalidZones = Pool.Get<List<string>>();

            bool dataChanged = false;
            
            foreach (KeyValuePair<string, StoredData.Zone> kvp in _storedData.Zones)
            {
                if (!IsValidZoneID(kvp.Key))
                {
                    invalidZones.Add(kvp.Key);
                    continue;
                }

                if (TryGetZoneLocation(kvp.Key, out Vector3 position) && kvp.Value.Position != position)
                {
                    kvp.Value.Position = position;
                    dataChanged = true;
                }
                
                if (TryGetZoneRadius(kvp.Key, out float radius) && !Mathf.Approximately(kvp.Value.Radius, radius))
                {
                    kvp.Value.Radius = radius;
                    dataChanged = true;
                }

                CreateDome(kvp.Key, kvp.Value);
            }

            if (invalidZones.Count > 0)
            {
                PrintWarning(string.Format(TranslateMessage("Notification.InvalidZones"), invalidZones.Count));
                
                foreach (string zoneId in invalidZones)
                    _storedData.Zones.Remove(zoneId);

                dataChanged = true;
            }
            
            Pool.FreeUnmanaged(ref invalidZones);
            
            if (dataChanged)
                SaveData();
        }

        private void CreateDome(string zoneId, StoredData.Zone zone)
        {
            string prefab = zone.Type switch
            {
                SphereType.Red => BR_SPHERE_RED,
                SphereType.Blue => BR_SPHERE_BLUE,
                SphereType.Green => BR_SPHERE_GREEN,
                SphereType.Purple => BR_SPHERE_PURPLE,
                _ => SHADED_SPHERE
            };
            
            List<SphereEntity> sphereEntities = new List<SphereEntity>();
            _sphereEntities[zoneId] = sphereEntities;
            
            for (int i = 0; i < zone.Stack; i++)
            {
                SphereEntity sphereEntity = GameManager.server.CreateEntity(prefab, zone.Position) as SphereEntity;
                sphereEntity.currentRadius = zone.Radius * 2f;
                //sphereEntity.lerpSpeed = 0f;
                sphereEntity.lerpRadius = sphereEntity.currentRadius;

                sphereEntity.enableSaving = false;
                sphereEntity.Spawn();
                
                sphereEntities.Add(sphereEntity);
            }
        }

        private void DestroyDomeForZone(string zoneId)
        {
            if (_sphereEntities.TryGetValue(zoneId, out List<SphereEntity> sphereEntities))
            {
                foreach (SphereEntity sphereEntity in sphereEntities)
                {
                    if (sphereEntity && !sphereEntity.IsDestroyed)
                        sphereEntity.Kill();
                }
                
                _sphereEntities.Remove(zoneId);
            }
        }

        private void TranslateMessage(BasePlayer player, string key, string additional = "") 
            => player.ChatMessage($"<color=#939393>{TranslateMessage(key, player)}</color><color=#ce422b>{additional}</color>");
        
        private string TranslateMessage(string key, BasePlayer player = null) 
            => lang.GetMessage(key, this, !player ? "" : player.UserIDString);
        
        #endregion
        
        #region ZoneManager API
        
        private bool IsValidZoneID(string zoneId)
        {
            object result = ZoneManager?.Call("CheckZoneID", zoneId);
            return result is string s && !string.IsNullOrEmpty(s);
        }

        private bool TryGetZoneLocation(string zoneId, out Vector3 position)
        {
            object result = ZoneManager?.Call("GetZoneLocation", zoneId);
            if (!(result is Vector3 v))
            {
                position = default;
                return false;
            }

            position = v;
            return true;
        }

        private bool TryGetZoneRadius(string zoneId, out float radius)
        {
            object result = ZoneManager?.Call("GetZoneRadius", zoneId);
            if (!(result is float r))
            {
                radius = default;
                return false;
            }

            radius = r;
            return true;
        }
        
        #endregion
        
        #region Plugin API
        
        [HookMethod("AddNewDome")]
        public bool AddNewDome(BasePlayer player, string zoneId, int type = 0, int stack = 1)
        {
            if (!IsValidZoneID(zoneId))
            {
                TranslateMessage(player, "Error.InvalidID", zoneId);
                return false;
            }
            
            if (!TryGetZoneLocation(zoneId, out Vector3 position))
            {
                TranslateMessage(player, "Error.NoLocation", zoneId);
                return false;
            }
            
            if (!TryGetZoneRadius(zoneId, out float radius))
            {
                TranslateMessage(player, "Error.NoRadius", zoneId);
                return false;
            }
            
            if (_storedData.Zones.ContainsKey(zoneId))
            {
                TranslateMessage(player, "Notification.AlreadyExists");
                return false;
            }
            
            StoredData.Zone zone = _storedData.Zones[zoneId] = new StoredData.Zone
            {
                Position = position,
                Radius = radius,
                Type = (SphereType)type,
                Stack = stack
            };
            
            SaveData();
            CreateDome(zoneId, zone);
            
            TranslateMessage(player, "Notification.Created", zoneId);
            return true;
        }

        [HookMethod("RemoveExistingDome")]
        public bool RemoveExistingDome(BasePlayer player, string zoneId)
        {
            if (!_storedData.Zones.ContainsKey(zoneId))
            {
                TranslateMessage(player, "Error.NoEntity", zoneId);
                return false;
            }
            
            DestroyDomeForZone(zoneId);
            _storedData.Zones.Remove(zoneId);
            SaveData();
            
            TranslateMessage(player, "Notification.RemoveSuccess", zoneId);
            return true;
        }
        
        #endregion
        
        #region Commands

        [ChatCommand("zd")]
        private void CommandZoneDomes(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, USE_PERMISSION) && !player.IsAdmin)
            {
                TranslateMessage(player, "Error.NoPermission");
                return;
            }

            if (args == null || args.Length == 0)
            {
                StringBuilder sb = Pool.Get<StringBuilder>();
                sb.Clear();

                sb.AppendLine(TranslateMessage("Chat.Title", player));
                sb.AppendLine(TranslateMessage("Chat.AddSyntax", player));
                sb.AppendLine();
                sb.AppendLine(TranslateMessage("Chat.RemoveSyntax", player));
                sb.AppendLine();
                sb.AppendLine(TranslateMessage("Chat.ListSyntax", player));
                sb.AppendLine();
                sb.AppendLine(TranslateMessage("Chat.Types", player));
                
                player.ChatMessage(sb.ToString());
                sb.Clear();
                
                Pool.FreeUnmanaged(ref sb);
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                {
                    if (args.Length <= 1)
                    {
                        TranslateMessage(player, "Chat.AddSyntax");
                        return;
                    }
                    
                    if (!ZoneManager)
                    {
                        TranslateMessage(player, "Error.NoZoneManager");
                        return;
                    }

                    string zoneId = args[1];
                    int type = 0;
                    int stack = 1;
                    
                    if (args.Length > 2 && int.TryParse(args[2], out int i))
                        type = Mathf.Clamp(i, 0, 4);
                    
                    if (args.Length > 3 && int.TryParse(args[3], out int s))
                        stack = Mathf.Clamp(s, 1, 10);
                    
                    AddNewDome(player, zoneId, (int)type, stack);
                    
                    return;
                }
                
                case "remove":
                {
                    if (args.Length != 2)
                    {
                        TranslateMessage(player, "Chat.RemoveSyntax");
                        return;
                    }

                    RemoveExistingDome(player, args[1]);
                    return;
                }
                
                case "list":
                {
                    StringBuilder sb = Pool.Get<StringBuilder>();
                    sb.Clear();
                    
                    sb.AppendLine(TranslateMessage("Format.List"));
                    
                    foreach (KeyValuePair<string, StoredData.Zone> kvp in _storedData.Zones)
                        sb.AppendLine($"{kvp.Key} -- {kvp.Value.Radius} -- {kvp.Value.Position} -- {kvp.Value.Type} -- {kvp.Value.Stack}");
                    
                    SendReply(player, sb.ToString());

                    sb.Clear();
                    Pool.FreeUnmanaged(ref sb);
                    return;
                }
            }
        }
        
        #endregion

        #region Config

        private ConfigData _configData;

        private class ConfigData
        {
            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configData = Config.ReadObject<ConfigData>();

            if (_configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(_configData, true);
        }

        protected override void LoadDefaultConfig() => _configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            _configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management

        private void SaveData() => _dataFile.WriteObject(_storedData);

        private void LoadData()
        {
            try
            {
                _storedData = _dataFile.ReadObject<StoredData>();
            }
            catch
            {
                _storedData = new StoredData();
            }
            
            if (_storedData == null)
                _storedData = new StoredData();
        }

        private class StoredData
        {
            public Dictionary<string, Zone> Zones = new Dictionary<string, Zone>();
            
            public class Zone
            {
                public Vector3 Position;
                public float Radius;
                public SphereType Type;
                public int Stack;
            }
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        
        #endregion
    }
}

// --- End of file: ZoneDomes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/zone-manager-time ---
// --- Original File Path: Z/ZoneManagerTime/ZoneManagerTime.cs ---

using System;
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Zone Manager Time", "misticos", "1.0.1")]
    [Description("Set specific time for your zones")]
    class ZoneManagerTime : CovalencePlugin
    {
        #region Variables
        
        [PluginReference]
        // ReSharper disable once InconsistentNaming
        private Plugin ZoneManager = null;
        
        private Dictionary<string, string> _playerZones = new Dictionary<string, string>();
        
        #endregion
        
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Zone ID Time", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TimeSpan> ZoneTime = new Dictionary<string, TimeSpan>
                {{"Zone ID", new TimeSpan(10, 5, 37)}};

            [JsonProperty(PropertyName = "Update Frequency")]
            public float UpdateFrequency = 5f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
        
        #region Hooks

        private void OnServerInitialized()
        {
            new GameObject().AddComponent<DateController>().PluginInstance = this;

            if (ZoneManager != null && ZoneManager.IsLoaded)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var zones = ZoneManager.Call<string[]>("GetPlayerZoneIDs", player);
                    if (zones == null || zones.Length == 0)
                        continue;
                    
                    _playerZones[player.UserIDString] = zones[zones.Length - 1];
                }
            }
        }

        private void Unload()
        {
            UnityEngine.Object.DestroyImmediate(DateController.Instance.gameObject);
        }

        private void OnEnterZone(string zoneId, BasePlayer player)
        {
            _playerZones[player.UserIDString] = zoneId;
        }

        private void OnExitZone(string zoneId, BasePlayer player)
        {
            _playerZones.Remove(player.UserIDString);
        }

        #endregion
        
        #region Controller

        private class DateController : SingletonComponent<DateController>
        {
            public ZoneManagerTime PluginInstance = null;
            
            private EnvSync _timeEntity;

            private void Start()
            {
                _timeEntity = FindObjectOfType<EnvSync>();
                _timeEntity.limitNetworking = true;
                
                InvokeRepeating(DoUpdate, PluginInstance._config.UpdateFrequency, PluginInstance._config.UpdateFrequency);
            }

            protected override void OnDestroy()
            {
                base.OnDestroy();
                _timeEntity.limitNetworking = false;
            }

            private void DoUpdate()
            {
                var saveInfo = new BaseNetworkable.SaveInfo
                {
                    forDisk = false
                };

                using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
                {
                    _timeEntity.Save(saveInfo);
                    var initialDateTime = DateTime.FromBinary(saveInfo.msg.environment.dateTime);

                    for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                    {
                        var connection = BasePlayer.activePlayerList[i].net?.connection;
                        if (connection == null)
                            continue;

                        var write = Net.sv.StartWrite();

                        saveInfo.forConnection = connection;

                        connection.validate.entityUpdates += 1u;

                        write.PacketID(Message.Type.Entities);
                        write.UInt32(connection.validate.entityUpdates);

                        string zoneId;
                        TimeSpan offset;
                        if (PluginInstance._playerZones.TryGetValue(BasePlayer.activePlayerList[i].UserIDString,
                            out zoneId) && PluginInstance._config.ZoneTime.TryGetValue(zoneId, out offset))
                        {
                            saveInfo.msg.environment.dateTime = (initialDateTime.Date + offset).ToBinary();
                        }
                        else
                        {
                            saveInfo.msg.environment.dateTime = initialDateTime.ToBinary();
                        }

                        saveInfo.msg.ToProto(write);

                        write.Send(new SendInfo(connection));
                    }
                }
            }
        }
        
        #endregion
    }
}

// --- End of file: ZoneManagerTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vote-ban ---
// --- Original File Path: V/VoteBan/VoteBan.cs ---

using System;
using System.Collections.Generic;
using System.Linq;

#if RUST
using Facepunch;
#endif

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

using UnityEngine;

using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("Vote Ban", "2CHEVSKII", "1.0.1")]
    [Description("Allows players to vote for banning others")]
    class VoteBan : CovalencePlugin
    {
        #region Fields

        const string M_PREFIX                 = "Chat prefix",
                     M_VOTE_STARTED           = "Vote started",
                     M_VOTE_PROGRESS          = "Vote in progress",
                     M_VOTED                  = "Voted",
                     M_ALREADY_VOTED          = "Voted already",
                     M_NO_PERMISSION          = "No permission",
                     M_NO_VOTE                = "No active vote",
                     M_VOTE_TIMED_OUT         = "Vote timed out",
                     M_VOTE_SUCCESS           = "Vote success",
                     M_VOTE_CANCELLED         = "Vote cancelled",
                     M_VOTE_CANCELLED_PLAYERS = "Vote cancelled (insufficient player count)",
                     M_BAN_REASON             = "Ban reason",
                     M_CANNOT_START_ADMIN     = "Vote cannot be started (cannot vote-out admins)",
                     M_CANNOT_START_PLAYERS   = "Vote cannot be started (insufficient player count)",
                     M_PLAYER_NOT_FOUND       = "Player not found",
                     M_CANNOT_VOTE_SELF       = "Cannot vote-out self";

        const string PERMISSION_MANAGE = "voteban.manage",
                     PERMISSION_VOTE   = "voteban.vote";

        PluginSettings settings;
        VoteData       voteData;

        #endregion

        #region Oxide hooks

        void Init()
        {
            permission.RegisterPermission(PERMISSION_MANAGE, this);
            permission.RegisterPermission(PERMISSION_VOTE, this);

            AddCovalenceCommand("voteban", nameof(CommandHandler));
        }

        #endregion

        #region Plugin API

        void OnVoteStarted(IPlayer initiator, IPlayer target)
        {
            Interface.Oxide.CallHook("OnVotebanStarted", initiator, target, settings.VoteTime);
            Announce(M_VOTE_STARTED, initiator.Name, target.Name, settings.VoteTime);
        }

        void OnPlayerVoted(IPlayer player)
        {
            Interface.Oxide.CallHook("OnVotebanPlayerVoted", player);
            Message(player, M_VOTED, voteData.voteTarget.Name);
        }

        void OnVoteTick()
        {
            Interface.Oxide.CallHook(
                "OnVotebanTick",
                voteData.voteInitiator,
                voteData.voteTarget,
                voteData.VoteFraction,
                voteData.VotedPlayerCount,
                voteData.TimeLeft
            );

            Announce(
                M_VOTE_PROGRESS,
                voteData.voteInitiator.Name,
                voteData.voteTarget.Name,
                Mathf.FloorToInt(voteData.VoteFraction * 100),
                voteData.VotedPlayerCount,
                GetPlayersRequiredToVoteSuccess(GetPlayerCountWithoutTarget(voteData.voteTarget)),
                Mathf.CeilToInt(voteData.TimeLeft)
            );
        }

        void OnVoteCancelled(IPlayer canceller = null)
        {
            if (canceller != null)
            {
                Interface.Oxide.CallHook(
                    "OnVotebanCancelled",
                    voteData.voteInitiator,
                    voteData.voteTarget,
                    (int)VoteData.CancelReason.Manual,
                    canceller
                );

                Announce(M_VOTE_CANCELLED, canceller.Name, voteData.voteInitiator.Name, voteData.voteTarget.Name);
            }
            else
            {
                Interface.Oxide.CallHook(
                    "OnVotebanCancelled",
                    voteData.voteInitiator,
                    voteData.voteTarget,
                    (int)VoteData.CancelReason.InsufficientPlayers
                );

                Announce(
                    M_VOTE_CANCELLED_PLAYERS,
                    voteData.voteInitiator.Name,
                    voteData.voteTarget.Name,
                    GetPlayerCountWithoutTarget(voteData.voteTarget),
                    settings.MinPlayers
                );
            }
        }

        void OnVoteTimedOut()
        {
            Interface.Oxide.CallHook("OnVotebanTimedOut", voteData.voteTarget);

            Announce(M_VOTE_TIMED_OUT, voteData.voteInitiator.Name, voteData.voteTarget.Name, settings.VoteTime);
        }

        void OnVoteSuccess()
        {
            Interface.Oxide.CallHook("OnVotebanSuccess", voteData.voteInitiator, voteData.voteTarget);

            Announce(M_VOTE_SUCCESS, voteData.voteInitiator.Name, voteData.voteTarget.Name);

            voteData.voteTarget.Ban(GetMessage(voteData.voteTarget, M_BAN_REASON));
        }

        bool IsVotebanInProgress()
        {
            return voteData != null;
        }

        bool GetCurrentVotebanData(Dictionary<string, object> record)
        {
            if (record == null)
            {
                throw new ArgumentNullException();
            }

            if (!IsVotebanInProgress())
            {
                return false;
            }

            record["initiator"] = voteData.voteInitiator;
            record["target"] = voteData.voteTarget;
            record["fraction"] = voteData.VoteFraction;
            record["required_fraction"] = settings.PercentageRequired / 100f;
            record["voted_players"] = voteData.votedPlayers.ToArray();
            record["required_voted_players"] = Mathf.RoundToInt(GetPlayerCountWithoutTarget(voteData.voteTarget) * (float)record["required_fraction"]);
            record["time_left"] = voteData.TimeLeft;
            record["start_time"] = voteData.startTime;
            record["end_time"] = voteData.endTime;

            return true;
        }

        #endregion

        #region Command handlers

        void CommandHandler(IPlayer player, string _, string[] args)
        {
            if (args.Length == 0)
            {
                HandleVoteCommand(player);
            }
            else
            {
                HandleManageCommand(player, args[0]);
            }
        }

        void HandleVoteCommand(IPlayer player)
        {
            if (CheckPermission(player, PERMISSION_VOTE))
            {
                if (voteData == null)
                {
                    Message(player, M_NO_VOTE);
                    return;
                }

                if (voteData.voteTarget.Id.Equals(player.Id))
                {
                    Message(player, M_CANNOT_VOTE_SELF);
                    return;
                }

                if (!voteData.CanPlayerVote(player))
                {
                    Message(player, M_ALREADY_VOTED);
                    return;
                }

                voteData.OnPlayerVoted(player);
            }
        }

        void HandleManageCommand(IPlayer player, string arg)
        {
            if (voteData != null)
            {
                switch (arg.ToLower())
                {
                    case "end":
                    case "cancel":
                        if (CheckPermission(player, PERMISSION_MANAGE))
                        {
                            voteData.CancelVote(player);
                        }

                        break;
                    default:
                        Message(
                            player,
                            M_VOTE_PROGRESS,
                            voteData.voteInitiator.Name,
                            voteData.voteTarget.Name,
                            (int)(voteData.VoteFraction * 100),
                            voteData.VotedPlayerCount,
                            GetPlayersRequiredToVoteSuccess(GetPlayerCountWithoutTarget(voteData.voteTarget))
                        );
                        break;
                }
            }
            else if (CheckPermission(player, PERMISSION_MANAGE))
            {
                IPlayer target = players.FindPlayer(arg);

                if (target == null)
                {
                    Message(player, M_PLAYER_NOT_FOUND, arg);
                }
                else if (target.Id.Equals(player.Id))
                {
                    Message(player, M_CANNOT_VOTE_SELF);
                }
                else if (target.IsAdmin && !settings.AllowBanningAdmins)
                {
                    Message(player, M_CANNOT_START_ADMIN);
                }
                else
                {
                    int playerCount = GetPlayerCountWithoutTarget(target);
                    if (playerCount < settings.MinPlayers)
                    {
                        Message(player, M_CANNOT_START_PLAYERS, playerCount, settings.MinPlayers);
                    }
                    else
                    {
                        voteData = new VoteData(player, target, this);
                    }
                }
            }
        }

        #endregion

        #region Utility

        int GetPlayerCountWithoutTarget(IPlayer target)
        {
            return players.Connected.Count(p => p != target);
        }

        int GetPlayersRequiredToVoteSuccess(int playerCount)
        {
            return Mathf.RoundToInt(settings.PercentageRequired / 100f * playerCount);
        }

        bool CheckPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
            {
                return true;
            }

            Message(player, M_NO_PERMISSION);

            return false;
        }

        #endregion

        #region LangAPI

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            string prefix = GetMessage(player, M_PREFIX);
            string format = GetMessage(player, langKey);

            string message = prefix + string.Format(format, args);

            player.Message(message);
        }

        void Announce(string langKey, params object[] args)
        {
            foreach (IPlayer player in players.Connected)
            {
                Message(player, langKey, args);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    [M_PREFIX] = "[VoteBan] ",
                    [M_NO_PERMISSION] = "You are not allowed to use this command",
                    [M_VOTE_STARTED] = "{0} has started the vote to ban {1}, use /voteban to vote for it",
                    [M_VOTE_PROGRESS] =
                        "Vote to ban {1} is in progress, use /voteban to vote for it. Current vote progress: {2}% ({3}/{4}), time left: {5} seconds",
                    [M_VOTED] = "You've voted for banning player {0}",
                    [M_ALREADY_VOTED] = "You've voted already",
                    [M_NO_VOTE] = "No active vote found",
                    [M_VOTE_TIMED_OUT] = "Vote to ban player {1} was unsuccessful, not enough players voted for it",
                    [M_VOTE_SUCCESS] =
                        "Vote to ban player {1} was successful, player will now be banned from the server",
                    [M_VOTE_CANCELLED] = "{0} has cancelled the vote for banning player {2}",
                    [M_VOTE_CANCELLED_PLAYERS] =
                        "Vote for banning player {1} was cancelled because of insufficient player count ({2}/{3})",
                    [M_BAN_REASON] = "You've been voted-out",
                    [M_CANNOT_START_ADMIN] = "Ban vote cannot be started against admins",
                    [M_CANNOT_START_PLAYERS] = "Not enough players on the server to start a vote ({0}/{1})",
                    [M_PLAYER_NOT_FOUND] = "Vote target ({0}) was not found",
                    [M_CANNOT_VOTE_SELF] = "You cannot vote against yourself"
                },
                this
            );
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception("Configuration is null");
                }

                if (settings.PercentageRequired > 100 || settings.PercentageRequired < 1)
                {
                    LogWarning("Required vote percentage must be in range of 1..100");
                    settings.PercentageRequired = 50;
                }

                if (settings.VoteTime < 5)
                {
                    LogWarning("Vote time cannot be less than 5 seconds");
                    settings.VoteTime = 5;
                }

                if (settings.NotificationFrequency < 5)
                {
                    LogWarning("Notification frequency cannot be less than 5 seconds");
                    settings.NotificationFrequency = 5;
                }
            }
            catch (Exception e)
            {
                LogError("Failed to load configuration: {0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region PluginSettings

        class PluginSettings
        {
            public static PluginSettings Default => new PluginSettings {
                VoteTime = 600,
                NotificationFrequency = 30,
                MinPlayers = 5,
                PercentageRequired = 70,
                AllowBanningAdmins = false
            };

            [JsonProperty("Vote time")] public int VoteTime { get; set; }

            [JsonProperty("Notification frequency")]
            public int NotificationFrequency { get; set; }

            [JsonProperty("Min player count to start vote")]
            public int MinPlayers { get; set; }

            [JsonProperty("Vote success percentage")]
            public int PercentageRequired { get; set; }

            [JsonProperty("Allow banning admins")] public bool AllowBanningAdmins { get; set; }
        }

        #endregion

        #region VoteData

        class VoteData
        {
            public readonly IPlayer       voteTarget;
            public readonly IPlayer       voteInitiator;
            public          List<IPlayer> votedPlayers;
            public          float         startTime;
            public          float         endTime;

            readonly        VoteBan       plugin;
            Timer                         voteTimer;

            public int VotedPlayerCount => votedPlayers.Count;
            public float VoteFraction => (float)VotedPlayerCount / plugin.GetPlayerCountWithoutTarget(voteTarget);
            public float TimeLeft => endTime - Time.realtimeSinceStartup;

            public VoteData(IPlayer initiator, IPlayer target, VoteBan plugin)
            {
                this.plugin = plugin;
                voteTarget = target;
                voteInitiator = initiator;
#if RUST
                votedPlayers = Pool.GetList<IPlayer>();
#else
                votedPlayers = new List<IPlayer>();
#endif

                StartVote();
            }

            public void OnPlayerVoted(IPlayer player)
            {
                votedPlayers.Add(player);
                plugin.OnPlayerVoted(player);

                if (VoteFraction >= plugin.settings.PercentageRequired / 100f)
                {
                    plugin.OnVoteSuccess();
                    EndVote();
                }
            }

            public bool CanPlayerVote(IPlayer player)
            {
                return !votedPlayers.Contains(player);
            }

            public void CancelVote(IPlayer canceller)
            {
                plugin.OnVoteCancelled(canceller);
                EndVote();
            }

            void StartVote()
            {
                startTime = Time.realtimeSinceStartup;
                endTime = startTime + plugin.settings.VoteTime;

                voteTimer = plugin.timer.Every(plugin.settings.NotificationFrequency, VoteTick);

                votedPlayers.Add(voteInitiator);

                plugin.OnVoteStarted(voteInitiator, voteTarget);
            }

            void VoteTick()
            {
                if (Time.realtimeSinceStartup < endTime)
                {
                    if (plugin.GetPlayerCountWithoutTarget(voteTarget) < plugin.settings.MinPlayers)
                    {
                        plugin.OnVoteCancelled();
                        EndVote();
                    }
                    else
                    {
                        plugin.OnVoteTick();
                    }
                }
                else
                {
                    plugin.OnVoteTimedOut();
                    EndVote();
                }
            }

            void EndVote()
            {
                voteTimer.Destroy();
#if RUST
                Pool.FreeList(ref votedPlayers);
#endif
                plugin.voteData = null;
            }

            public enum CancelReason
            {
                Manual,
                InsufficientPlayers
            }
        }

        #endregion
    }
}


// --- End of file: VoteBan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/voice-ui ---
// --- Original File Path: V/VoiceUI/VoiceUI.cs ---

﻿using Network;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Voice UI", "Pinkstink", "1.0.4")]
    [Description("Displays UI of players names who are actively transmitting voice")]
    public class VoiceUI : RustPlugin
    {
        private const string USE_PERMISSION = "voiceui.use";
        private const string ADMIN_PERMISSION = "voiceui.admin";
        private const string ROOT_UI_NAME = "VoiceUI";

        private VoiceUIConfiguration config;
        private Dictionary<BasePlayer, List<VoiceRecord>> voiceRecords = new Dictionary<BasePlayer, List<VoiceRecord>>();
        private float timeSinceLastUpdate = 0f;

        void Init()
        {
            permission.RegisterPermission(USE_PERMISSION, this);
            permission.RegisterPermission(ADMIN_PERMISSION, this);
            config = Config.ReadObject<VoiceUIConfiguration>();
        }

        void Unload()
        {
            voiceRecords = null;
        }

        #region Plugin Core
        void OnFrame()
        {
            timeSinceLastUpdate += Time.deltaTime;
            if (timeSinceLastUpdate < config.UpdateInterval) return;

            ProcessVoice();
            timeSinceLastUpdate = 0;
        }

        void ProcessVoice()
        {
            var newRecords = new Dictionary<BasePlayer, List<VoiceRecord>>();

            foreach (var record in voiceRecords)
            {
                if (record.Key == null || !record.Key.IsConnected) continue;

                if (record.Value.Count <= 0)
                {
                    CuiHelper.DestroyUi(record.Key, ROOT_UI_NAME);
                    continue;
                }

                newRecords.Add(record.Key, new List<VoiceRecord>());

                List<string> elements = new List<string>
                {
                    @"
                    {
                        ""name"": ""VoiceUI"",
                        ""parent"": ""Hud"",
                        ""components"": [
                            {
                                ""type"": ""UnityEngine.UI.Image"",
                                ""color"": ""0 0 0 0""
                            },
                            {
                                ""type"": ""RectTransform"",
                                ""anchormin"": ""0.65 0.020"",
                                ""anchormax"": ""0.83 0.135""
                            }
                        ]
                    }
                    "
                };

                elements.AddRange(GenerateVoiceRecordGrid(record.Value.OrderBy(x => x.distance), "VoiceUI_Records", ROOT_UI_NAME));

                CuiHelper.DestroyUi(record.Key, ROOT_UI_NAME);
                CuiHelper.AddUi(record.Key, "[" + string.Join(",", elements).Replace("\n", string.Empty) + "]");
            }

            voiceRecords = newRecords;
        }

        void OnPlayerVoice(BasePlayer voiceSender)
        {
            List<Connection> recipients = BaseNetworkable.GetConnectionsWithin(voiceSender.transform.position, 100f);

            foreach (var connection in recipients)
            {
                var recipientPlayer = connection.player as BasePlayer;
                if (recipientPlayer == null || recipientPlayer == voiceSender) continue;
                if (config.ToggledByDefault && config.ToggledPlayers.Contains(recipientPlayer.userID)) continue;
                if (!config.ToggledByDefault && !config.ToggledPlayers.Contains(recipientPlayer.userID)) continue;

                if (!voiceRecords.ContainsKey(recipientPlayer))
                    voiceRecords.Add(recipientPlayer, new List<VoiceRecord>());

                var idx = voiceRecords[recipientPlayer].FindIndex(x => x.player == voiceSender);

                if (idx >= 0)
                    voiceRecords[recipientPlayer].RemoveAt(idx);

                voiceRecords[recipientPlayer].Add(new VoiceRecord(voiceSender, Vector3.Distance(voiceSender.transform.position, recipientPlayer.transform.position)));
            }
        }

        struct VoiceRecord
        {
            public BasePlayer player;
            public DateTime time;
            public float distance;

            public VoiceRecord(BasePlayer basePlayer, float distance)
            {
                player = basePlayer;
                this.distance = distance;
                time = DateTime.Now;
            }
        }
        #endregion

        #region Commands
        [ChatCommand("showvoice")]
        void ChatCMD_ShowVoice(BasePlayer player, string command, string[] args)
        {
            bool hasPermission = player.IsAdmin || permission.UserHasPermission(player.UserIDString, USE_PERMISSION);
            if (!hasPermission) return;

            if (config.ToggledByDefault)
            {
                if (config.ToggledPlayers.Remove(player.userID)) SaveConfig();
            }
            else
            {
                if (config.ToggledPlayers.Add(player.userID)) SaveConfig();
            }
            SendFormattedMessage(player, "Voice UI", lang.GetMessage("UIVisible", this, player.UserIDString));
        }

        [ChatCommand("hidevoice")]
        void ChatCMD_HideVoice(BasePlayer player, string command, string[] args)
        {
            bool hasPermission = player.IsAdmin || permission.UserHasPermission(player.UserIDString, USE_PERMISSION);
            if (!hasPermission) return;

            if (config.ToggledByDefault)
            {
                if (config.ToggledPlayers.Add(player.userID)) SaveConfig();
            }
            else
            {
                if (config.ToggledPlayers.Remove(player.userID)) SaveConfig();
            }
            SendFormattedMessage(player, "Voice UI", lang.GetMessage("UIHidden", this, player.UserIDString));
        }

        [ChatCommand("voice")]
        void ChatCMD_Voice(BasePlayer player, string command, string[] args)
        {
            bool hasPermission = player.IsAdmin || permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION);
            if (!hasPermission) return;

            if (args.Length < 1)
            {
                string showArgs = lang.GetMessage("ShowConfig", this, player.UserIDString);
                SendFormattedMessage(player, "Voice UI", string.Format(showArgs, Version, config.UpdateInterval, config.UIColorSensitivity, config.ToggledByDefault));
                return;
            }

            switch (args[0].ToUpper())
            {
                case "INTERVAL":
                case "UPDATEINTERVAL":
                    if (args.Length < 2)
                    {
                        SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("CurrentUpdateInterval", this, player.UserIDString), config.UpdateInterval));
                        break;
                    }
                    float newInterval;
                    if (!float.TryParse(args[1], out newInterval))
                    {
                        SendFormattedMessage(player, "Voice UI", lang.GetMessage("UpdateIntervalFormatError", this, player.UserIDString));
                        break;
                    }
                    config.UpdateInterval = newInterval;
                    SaveConfig();
                    SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("UpdateIntervalSet", this, player.UserIDString), config.UpdateInterval));
                    break;

                case "UITOGGLEDBYDEFAULT":
                case "TOGGLEDBYDEFAULT":
                    if (args.Length < 2)
                    {
                        SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("CurrentToggledByDefault", this, player.UserIDString), config.ToggledByDefault));
                        break;
                    }
                    bool newToggledByDefault;
                    if (!bool.TryParse(args[1], out newToggledByDefault))
                    {
                        SendFormattedMessage(player, "Voice UI", lang.GetMessage("ToggledByDefaultFormatError", this, player.UserIDString));
                        break;
                    }
                    config.ToggledByDefault = newToggledByDefault;
                    SaveConfig();
                    SendFormattedMessage(player, "Voice UI", lang.GetMessage(config.ToggledByDefault ? "IsToggledByDefault" : "NotToggledByDefault", this, player.UserIDString));
                    break;

                case "TOGGLED":
                case "SHOWTOGGLED":
                    SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("ToggledUsers", this, player.UserIDString), config.ToggledPlayers.Count, string.Join("\n", config.ToggledPlayers)));
                    break;

                case "SENSITIVITY":
                case "UICOLORSENSITIVITY":
                    if (args.Length < 2)
                    {
                        SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("CurrentSensitivity", this, player.UserIDString), config.UIColorSensitivity));
                        break;
                    }
                    float newSensitivity;
                    if (!float.TryParse(args[1], out newSensitivity))
                    {
                        SendFormattedMessage(player, "Voice UI", lang.GetMessage("SensitivityFormatError", this, player.UserIDString));
                        break;
                    }
                    config.UIColorSensitivity = newSensitivity;
                    SaveConfig();
                    SendFormattedMessage(player, "Voice UI", string.Format(lang.GetMessage("SensitivitySet", this, player.UserIDString), config.UIColorSensitivity));
                    break;

                default:
                    SendFormattedMessage(player, "Voice UI", lang.GetMessage("ArgNotFound", this, player.UserIDString));
                    break;
            }
        }
        #endregion

        #region Helpers
        List<string> GenerateVoiceRecordGrid(IEnumerable<VoiceRecord> records, string identifier, string parentName)
        {
            List<string> elements = new List<string>();

            // Total Grid Count
            int cols = (int)Mathf.Clamp((float)Math.Sqrt(records.Count()), 1, 3);
            int rows = (int)Math.Max(Math.Ceiling((double)records.Count() / cols), 5);

            int nameTrimLength = 32 / cols;

            // Sizing
            float xSize = 1f / cols;
            float ySize = 1f / rows;

            // Spacing
            float xSpacing = xSize / 80;
            float ySpacing = ySize / 120;

            for (int i = 0; i < records.Count(); i++)
            {
                int row = i / cols;
                int col = i % cols;

                float xMin = xSize * col + xSpacing;
                float xMax = xSize * col + xSize - xSpacing;

                float yMin = 1f - (ySize * row) - ySize + ySpacing;
                float yMax = 1f - (ySize * row) - ySpacing;

                VoiceRecord record = records.ElementAt(i);
                string text = record.player.displayName.Trim().Substring(0, Math.Min(nameTrimLength, record.player.displayName.Length)).EscapeRichText();
                float green = Math.Max(0, Math.Min(record.distance / config.UIColorSensitivity, 1));

                int textSize = (int)(75 * (yMax - yMin));

                var label = @"
                    {
                        ""name"": """ + $"{identifier}_{record.player.UserIDString}" + @""",
                        ""parent"": """ + parentName + @""",
                        ""components"": [
                            {
                                ""type"": ""UnityEngine.UI.Text"",
                                ""text"": """ + text + @""",
                                ""align"": ""MiddleLeft"",
                                ""fontSize"": " + textSize.ToString() + @",
                                ""color"": ""1 " + green.ToString() + @" 0 1""
                            },
                            {
                                ""type"": ""RectTransform"",
                                ""anchormin"": """ + $"{xMin} {yMin}" + @""",
                                ""anchormax"": """ + $"{xMax} {yMax}" + @"""
                            },
                            {
                                ""type"": ""UnityEngine.UI.Outline"",
                                ""color"": ""0 0 0 1"",
                                ""distance"": ""1.0 -0.8""
                            }
                        ]
                    }
                ";
                elements.Add(label);
            }

            return elements;
        }

        void SendFormattedMessage(BasePlayer player, string from, string message, string color = "#ff0000")
        {
            player.ChatMessage(string.Format("<color={0}>{1}</color>: {2}", color, from, message));
        }
        #endregion

        #region Localisation
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UIHidden"] = "UI is now hidden",
                ["UIVisible"] = "UI is now visible",

                ["ShowConfig"] = "Version {0}\n/showvoice\n/hidevoice\n/voice updateinterval <number>\n/voice uicolorsensitivity <number>\n/voice toggledbydefault <true / false>\n/voice toggled\n\nCurrent Configuration:\nUI Update Interval: {1}\nUI Color Sensitivity: {2}\nUI Toggled By Default: {3}",
                ["ArgNotFound"] = "Argument not found",

                ["CurrentUpdateInterval"] = "Current Update Interval set to {0} seconds",
                ["UpdateIntervalFormatError"] = "Update Interval must be a decimal number in seconds",
                ["UpdateIntervalSet"] = "Update Interval set to {0} seconds",

                ["CurrentSensitivity"] = "Current UI Color Sensitivity set to {0}",
                ["SensitivityFormatError"] = "UI Color Sensitivity must be a decimal number between 1 and 100",
                ["SensitivitySet"] = "UI Color Sensitivity set to {0}",

                ["ToggledUsers"] = "Toggled count: {0}\n{1}",

                ["CurrentToggledByDefault"] = "Toggled By Default is set to {0}",
                ["IsToggledByDefault"] = "UI is now toggled by default",
                ["NotToggledByDefault"] = "UI is no longer toggled by default",
                ["ToggledByDefaultFormatError"] = "Toggled By Default must be either \"true\" or \"false\""
            }, this);
        }
        #endregion

        #region Configuration
        protected override void LoadDefaultConfig() => Config.WriteObject(new VoiceUIConfiguration(), true);

        void SaveConfig() => Config.WriteObject(config, true);

        class VoiceUIConfiguration
        {
            private float updateInterval = 0.5f;
            public float UpdateInterval
            {
                get { return updateInterval; }
                set { updateInterval = value; }
            }
            private float uiColorSensitivity = 50f;
            public float UIColorSensitivity
            {
                get { return uiColorSensitivity; }
                set { uiColorSensitivity = Mathf.Clamp(value % 100, 1, 100); }
            }
            private HashSet<ulong> toggledPlayers = new HashSet<ulong>();
            public HashSet<ulong> ToggledPlayers
            {
                get { return toggledPlayers; }
                private set { toggledPlayers = value; }
            }

            private bool toggledByDefault = false;
            public bool ToggledByDefault
            {
                get
                {
                    return toggledByDefault;
                }
                set
                {
                    if (toggledByDefault != value)
                        ToggledPlayers.Clear();

                    toggledByDefault = value;
                }
            }
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;

            if (permName == USE_PERMISSION && config.ToggledPlayers.Remove(userID)) SaveConfig();
        }

        void OnRconCommand(IPEndPoint ip, string command, string[] args)
        {
            switch (command.ToUpper())
            {
                case "GLOBAL.REMOVEOWNER":
                case "REMOVEOWNER":
                    ulong userID;
                    if (args.Length < 0 || !ulong.TryParse(args[0], out userID)) return;
                    if (!permission.UserHasPermission(args[0], USE_PERMISSION) && config.ToggledPlayers.Remove(userID)) SaveConfig();
                    break;

                default:
                    return;
            }
        }

        void OnPlayerConnected(Network.Message packet)
        {
            ulong userID = packet.connection.userid;
            bool isAdmin = packet.connection.authLevel > 0;
            bool isToggled = config.ToggledPlayers.Contains(userID);
            if (!isToggled) return;

            if (isAdmin) return;
            if (permission.UserHasPermission(userID.ToString(), USE_PERMISSION)) return;

            if (config.ToggledPlayers.Remove(userID)) SaveConfig();
        }
        #endregion
    }
}


// --- End of file: VoiceUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vip-trial ---
// --- Original File Path: V/VIPTrial/VIPTrial.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
namespace Oxide.Plugins
{
    [Info("VIP Trial", "Maik8", "1.3.5", ResourceId = 2563)]
    [Description("Plugin that lets Users try VIP functions.")]
    public class VIPTrial : CovalencePlugin
    {
        #region Variables
        StoredData storedData;
        string groupName;
        int days;
        string message;
        List<object> permlist;
        
        #endregion

        #region Commands
        [Command("viptrial")]
        void VIPtrialCommand(IPlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0)
            {
                if (checkTrialAllowed(player))
                {
                    if (!checkAlreadyUsed(player))
                    {
                        if (!checkPlayerForGroup(player))
                        {
                            addUserForTrial(player);
                        }
                        else
                        {
                            message = string.Format(GetLangValue("VIPStillRunning", player.Id), getDaysLeft(player).ToString());
                            player.Reply(message);
                        }
                    }
                    else if (checkPlayerForGroup(player))
                    {

                        //player.Reply("VIPStillRunning", getDaysLeft(player).ToString());
                        message = string.Format(GetLangValue("VIPStillRunning", player.Id), getDaysLeft(player).ToString());
                        player.Reply(message);
                    }
                    else
                    {
                        message = string.Format(GetLangValue("VIPAlreadyUsed", player.Id));
                        player.Reply(message);
                    }
                }
                else
                {
                    message = string.Format(GetLangValue("NoPermission", player.Id));
                    player.Reply(message);
                }
            }
            else if ("list".Equals(args[0]))
            {
                if (checkTrialAdmin(player) || player.Id == "server_console")
                {
                    listActiveTrials(player);
                }
                else
                {
                    message = string.Format(GetLangValue("NoPermission", player.Id));
                    player.Reply(message);
                }
            }
            else if ("clean_group".Equals(args[0]))
            {
                if (checkTrialAdmin(player) || player.Id == "server_console")
                {
                    cleanGroup(player);
                }
                else
                {
                    message = string.Format(GetLangValue("NoPermission", player.Id));
                    player.Reply(message);
                }
            }
        }
        #endregion

        #region Methods
        #region ServerHooks
        void Init()
        {
            permission.RegisterPermission("viptrial.allowed", this);
            permission.RegisterPermission("viptrial.admin", this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Name);
            LoadDefaultConfig();
            checkGroup();
			cleanGroup();
        }
		
		void cleanGroup(IPlayer player)
		{
			bool usersremoved = false;
                    foreach (string elm in permission.GetUsersInGroup(groupName))
                    {
                        string id = elm.Substring(0, elm.LastIndexOf('('));
						id = id.TrimEnd();
                        if (checkExpired(id))
                        {
                            string name = elm.Substring(elm.LastIndexOf('(') + 1, (elm.Substring(elm.LastIndexOf('(')).Length - 2));
                            permission.RemoveUserGroup(id, groupName);
                            if (!usersremoved)
                            {
                                usersremoved = true;

                            message = string.Format(GetLangValue("CleanGroupFirstFeed", player.Id));
                            player.Reply(message);
                            }
                            message = string.Format(GetLangValue("CleanGroupGiveBackRemovedUser", player.Id), id, name);
                            player.Reply(message);
                        }
                    }
                    if (!usersremoved)
                    {
                        message = string.Format(GetLangValue("CleanGroupNobodyRemoved", player.Id));
                        player.Reply(message);
                    }
		}
		
		void cleanGroup()
		{
			bool usersremoved = false;
                    foreach (string elm in permission.GetUsersInGroup(groupName))
                    {
                        string id = elm.Substring(0, elm.LastIndexOf('('));
						id = id.TrimEnd();
                        if (checkExpired(id))
                        {
                            string name = elm.Substring(elm.LastIndexOf('(') + 1, (elm.Substring(elm.LastIndexOf('(')).Length - 2));
                            permission.RemoveUserGroup(id, groupName);
                            if (!usersremoved)
                            {
                               usersremoved = true;
                               Puts("Removed users:");
                            }
                            Puts(String.Format("{0} | {1}", id, name));
                        }
                    }
                    if (!usersremoved)
                    {
                        Puts("Nobody needs to be removed.");
                    }
		}
		
        void OnUserConnected(IPlayer player)
        {
            if (permission.UserHasGroup(player.Id, groupName))
            {
                if (checkExpired(player.Id))
                {
                    permission.RemoveUserGroup(player.Id, groupName);
                    message = string.Format(GetLangValue("VIPExpired", player.Id));
                    player.Reply(message);
                }
                else
                {
                    message = string.Format(GetLangValue("VIPEndsIn", player.Id), getDaysLeft(player).ToString());
                    player.Reply(message);
                }
            }
        }
        #endregion

        void listActiveTrials(IPlayer player)
        {
            message = string.Format(GetLangValue("ListActiveVIPStart", player.Id));
            player.Reply(message);
            foreach (VIPDataSaveFile elm in storedData.VIPDataHash)
            {
                if (!checkExpired(elm.userId))
                {
                    message = string.Format(GetLangValue("ListActiveVIPUser2", player.Id), elm.now, elm.userId, players.FindPlayerById(elm.userId).Name);
                    player.Reply(message);
                }
            }
        }
        void checkGroup()
        {
            if (!permission.GroupExists(groupName))
            {
                permission.CreateGroup(groupName, string.Empty, 0);
            }               
                checkPerm(permlist, groupName);
        }
        void checkPerm(List<object> perm, string group)
        {
            foreach (object item in perm)
            {
                if (!permission.GroupHasPermission(group, item.ToString()))
                {
                    permission.GrantGroupPermission(group, item.ToString(), null);
                }
            }
            bool check;
            foreach (string item in permission.GetGroupPermissions(group))
            {
                check = false;
                foreach (object perms in perm)
                {
                    if (perms.ToString() == item)
                    {
                        check = true;
                    }
                }
                if (!check)
                {
                    permission.RevokeGroupPermission(group, item);
                }
            }
        }
        private int getDaysLeft(IPlayer player)
        {
            DateTime usedate = DateTime.Now.Date.AddDays(-1);

            foreach (VIPDataSaveFile elm in storedData.VIPDataHash)
            {  
                if (elm.userId.Equals(player.Id))
                {
                    usedate = Convert.ToDateTime(elm.now);
                    usedate = usedate.Date;
                    break;
                }
            }
            return Convert.ToInt32((usedate.Date - DateTime.Now.Date).TotalDays);
        }

        private void addUserForTrial(IPlayer player)
        {
            permission.AddUserGroup(player.Id, groupName);
            storedData.VIPDataHash.Add( new VIPDataSaveFile( player, DateTime.Now.AddDays( days ) ) );
            Interface.Oxide.DataFileSystem.WriteObject(this.Name, storedData);
            message = string.Format(GetLangValue("VIPStarted", player.Id), DateTime.Now.Date.AddDays(days).ToShortDateString());
            player.Reply(message);
        }

        private bool checkPlayerForGroup(IPlayer player) => permission.UserHasGroup(player.Id, groupName);

        private bool checkTrialAllowed(IPlayer player) => permission.UserHasPermission(player.Id, "viptrial.allowed");

       private bool checkTrialAdmin(IPlayer player) => permission.UserHasPermission(player.Id, "viptrial.admin");

        bool checkAlreadyUsed(IPlayer player)
        {
            foreach (VIPDataSaveFile elm in storedData.VIPDataHash)
            {
                if (elm.userId == player.Id)
                {
                    return true;
                }
            }
            return false;
        }
        bool checkExpired(string Id)
        {
            DateTime usedate = DateTime.Now.Date.AddDays(-1);
            foreach (VIPDataSaveFile elm in storedData.VIPDataHash)
            {
                if (elm.userId.Equals(Id))
                {
                     usedate = Convert.ToDateTime(elm.now);
                }
            }
            if (DateTime.Compare(usedate, DateTime.Now.Date) < 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        //private void Reply(IPlayer player, string langKey, params object[] args) => player.Reply(lang.GetMessage(langKey, this, player.Id), args);
          private string GetLangValue(string key, string userId) => lang.GetMessage(key, this, userId);

        #endregion

        #region Config
        protected override void LoadDefaultConfig()
        {
            Config["VIP group name: "] = groupName = GetConfig("VIP group name: ", "vip_trial");
            Config["Amount of trial Days: "] = days = GetConfig("Amount of trial Days: ", 3);
            Config["Permissions of the group:"] = permlist = GetConfig("Permissions of the group:", new List<object>
            {
                "Oxide.plugins", "oxide.reload"
            });

            SaveConfig();
        }
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));


        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "VIPStillRunning", "Your VIP trial is still running. Days left: {0}." },
                { "VIPAlreadyUsed", "You have already used your VIP trial." },
                { "NoPermission", "You are not allowed to use this command!" },
                { "VIPExpired", "Your VIP trial is expired." },
                { "VIPEndsIn", "Your VIP trial ends in {0} days." },
                { "VIPStarted", "Your VIP trial started, lasting till: {0}" },
                { "ListActiveVIPStart", "Currently active VIP trials:" },
                { "ListActiveVIPUser2", "{0} | {1} | {2}" },
                { "RemoveVIP", "Removed {0} from the VIP trial system."},
                { "RemoveVIPFail", "Player {0} could not be found in the VIP list."},
                { "RemoveVIPTarget", "You have been removed from the VIP trial database." },
                { "EndVIP", "The VIP trial of {0} is now over."},
                { "EndVIPFail", "Failed to end the VIP trial of {0}"},
                { "ENDVIPTarget", "You have been removed from the VIP trial."},
                { "ENDVIPTargetNotInGroupAnymore", "The player {0} is not in the VIP trial group."},
                { "CleanGroupGiveBackRemovedUser", "{0} | {1}"},
                { "CleanGroupFirstFeed", "Removed users:"},
                { "CleanGroupNobodyRemoved", "Nobody needs to be removed."}
            }, this);
        }

        #endregion

        #region Classes
        class StoredData
        {
            public HashSet<VIPDataSaveFile> VIPDataHash = new HashSet<VIPDataSaveFile>();

            public StoredData()
            {
            }
        }
        class VIPDataSaveFile
        {
            public string userId;
            public string now;

            public VIPDataSaveFile()
            {
            }

            public VIPDataSaveFile(IPlayer player, DateTime now)
            {
                userId = player.Id.ToString();
                this.now = now.ToShortDateString();
            }
        }
        #endregion
    }
}

// --- End of file: VIPTrial.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/verification-gatekeeper ---
// --- Original File Path: V/VerificationGatekeeper/VerificationGatekeeper.cs ---

/* --- Contributor information ---
 * Please follow the following set of guidelines when working on this plugin,
 * this to help others understand this file more easily.
 *
 * NOTE: On Authors, new entries go BELOW the existing entries. As with any other software header comment.
 *
 * -- Authors --
 * Thimo (ThibmoRozier) <thibmorozier@live.nl> 2021-04-19 +
 *
 * -- Naming --
 * Avoid using non-alphabetic characters, eg: _
 * Avoid using numbers in method and class names (Upgrade methods are allowed to have these, for readability)
 * Private constants -------------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private readonly fields -------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private fields ----------------------- SHOULD start with a uppercase "F" (PascalCase)
 * Arguments/Parameters ----------------- SHOULD start with a lowercase "a" (camelCase)
 * Classes ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Methods ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Public properties (constants/fields) - SHOULD start with a uppercase character (PascalCase)
 * Variables ---------------------------- SHOULD start with a lowercase character (camelCase)
 *
 * -- Style --
 * Max-line-width ------- 160
 * Single-line comments - // Single-line comment
 * Multi-line comments -- Just like this comment block!
 */

using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Verification Gatekeeper", "ThibmoRozier", "1.2.1")]
    [Description("Prevents players from doing anything on the server until they are given the bypass permission")]
    public class VerificationGatekeeper : RustPlugin
    {
        #region Constants
        private const string CPermBypass = "verificationgatekeeper.bypass";
        private const string CPermBypassMount = "verificationgatekeeper.bypass.mount";
        private const string CPermBypassBedActions = "verificationgatekeeper.bypass.bedactions";
        private const string CPermBypassBuild = "verificationgatekeeper.bypass.build";
        private const string CPermBypassCardSwiping = "verificationgatekeeper.bypass.cardswiping";
        private const string CPermBypassChat = "verificationgatekeeper.bypass.chat";
        private const string CPermBypassCollectiblePickup = "verificationgatekeeper.bypass.collectiblepickup";
        private const string CPermBypassCommand = "verificationgatekeeper.bypass.command";
        private const string CPermBypassCounterActions = "verificationgatekeeper.bypass.counteractions";
        private const string CPermBypassCrafting = "verificationgatekeeper.bypass.crafting";
        private const string CPermBypassCrateHack = "verificationgatekeeper.bypass.cratehack";
        private const string CPermBypassCupboardActions = "verificationgatekeeper.bypass.cupboardactions";
        private const string CPermBypassCustomUI = "verificationgatekeeper.bypass.customui";
        private const string CPermBypassDemolish = "verificationgatekeeper.bypass.demolish";
        private const string CPermBypassDeployItem = "verificationgatekeeper.bypass.deployitem";
        private const string CPermBypassDoorActions = "verificationgatekeeper.bypass.dooractions";
        private const string CPermBypassElevatorActions = "verificationgatekeeper.bypass.elevatoractions";
        private const string CPermBypassEntityLooting = "verificationgatekeeper.bypass.entitylooting";
        private const string CPermBypassEntityPickup = "verificationgatekeeper.bypass.entitypickup";
        private const string CPermBypassExplosives = "verificationgatekeeper.bypass.explosives";
        private const string CPermBypassFlamers = "verificationgatekeeper.bypass.flamers";
        private const string CPermBypassFuelActions = "verificationgatekeeper.bypass.fuelactions";
        private const string CPermBypassGrowableGathering = "verificationgatekeeper.bypass.growablegathering";
        private const string CPermBypassHealingItemUsage = "verificationgatekeeper.bypass.healingitemusage";
        private const string CPermBypassHelicopterActions = "verificationgatekeeper.bypass.helicopteractions";
        private const string CPermBypassItemActions = "verificationgatekeeper.bypass.itemactions";
        private const string CPermBypassItemDropping = "verificationgatekeeper.bypass.itemdropping";
        private const string CPermBypassItemMoving = "verificationgatekeeper.bypass.itemmoving";
        private const string CPermBypassItemPickup = "verificationgatekeeper.bypass.itempickup";
        private const string CPermBypassItemSkinning = "verificationgatekeeper.bypass.itemskinning";
        private const string CPermBypassItemStacking = "verificationgatekeeper.bypass.itemstacking";
        private const string CPermBypassItemWearing = "verificationgatekeeper.bypass.itemwearing";
        private const string CPermBypassLiftActions = "verificationgatekeeper.bypass.liftactions";
        private const string CPermBypassLockActions = "verificationgatekeeper.bypass.lockactions";
        private const string CPermBypassMailboxActions = "verificationgatekeeper.bypass.mailboxactions";
        private const string CPermBypassMelee = "verificationgatekeeper.bypass.melee";
        private const string CPermBypassOvenActions = "verificationgatekeeper.bypass.ovenactions";
        private const string CPermBypassPhoneActions = "verificationgatekeeper.bypass.phoneactions";
        private const string CPermBypassPlayerAssist = "verificationgatekeeper.bypass.playerassist";
        private const string CPermBypassPlayerLooting = "verificationgatekeeper.bypass.playerlooting";
        private const string CPermBypassPush = "verificationgatekeeper.bypass.push";
        private const string CPermBypassRecyclerActions = "verificationgatekeeper.bypass.recycleractions";
        private const string CPermBypassReloading = "verificationgatekeeper.bypass.reloading";
        private const string CPermBypassRepair = "verificationgatekeeper.bypass.repair";
        private const string CPermBypassResearch = "verificationgatekeeper.bypass.research";
        private const string CPermBypassRockets = "verificationgatekeeper.bypass.rockets";
        private const string CPermBypassShopActions = "verificationgatekeeper.bypass.shopactions";
        private const string CPermBypassSignUpdate = "verificationgatekeeper.bypass.signupdate";
        private const string CPermBypassStashActions = "verificationgatekeeper.bypass.stashactions";
        private const string CPermBypassStructureRotate = "verificationgatekeeper.bypass.structurerotate";
        private const string CPermBypassSwitchActions = "verificationgatekeeper.bypass.switchactions";
        private const string CPermBypassTeamCreation = "verificationgatekeeper.bypass.teamcreation";
        private const string CPermBypassTrapActions = "verificationgatekeeper.bypass.trapactions";
        private const string CPermBypassTurretActions = "verificationgatekeeper.bypass.turretactions";
        private const string CPermBypassUpgrade = "verificationgatekeeper.bypass.upgrade";
        private const string CPermBypassVendingAdmin = "verificationgatekeeper.bypass.vendingadmin";
        private const string CPermBypassVendingUsage = "verificationgatekeeper.bypass.vendingusage";
        private const string CPermBypassWeaponFiring = "verificationgatekeeper.bypass.weaponfiring";
        private const string CPermBypassWiring = "verificationgatekeeper.bypass.wiring";
        private const string CPermBypassWoodCutting = "verificationgatekeeper.bypass.woodcutting";
        private const string CPermBypassWorldProjectiles = "verificationgatekeeper.bypass.worldprojectiles";
        private const string CPermBypassWounded = "verificationgatekeeper.bypass.wounded";
        #endregion Constants

        #region Variables
        private ConfigData FConfigData;
        #endregion Variables

        #region Config
        /// <summary>
        /// The config type class
        /// </summary>
        private class ConfigData
        {
            [JsonProperty("Admin Is Always Verified", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool AdminAlwaysVerified = true;
            [JsonProperty("Prevent (Dis-)Mount", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventMount = true;
            [JsonProperty("Prevent Bed Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventBedActions = true;
            [JsonProperty("Prevent Build", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventBuild = true;
            [JsonProperty("Prevent Card Swiping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCardSwiping = true;
            [JsonProperty("Prevent Chat", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventChat = true;
            [JsonProperty("Prevent Collectible Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCollectiblePickup = true;
            [JsonProperty("Prevent Command", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCommand = true;
            [JsonProperty("Prevent Counter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCounterActions = true;
            [JsonProperty("Prevent Crafting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCrafting = true;
            [JsonProperty("Prevent Crate Hack", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCrateHack = true;
            [JsonProperty("Prevent Cupboard Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventCupboardActions = true;
            [JsonProperty("Prevent Custom UI", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(false)]
            public bool PreventCustomUI = false;
            [JsonProperty("Prevent Demolish", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventDemolish = true;
            [JsonProperty("Prevent Deploy Item", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventDeployItem = true;
            [JsonProperty("Prevent Door Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventDoorActions = true;
            [JsonProperty("Prevent Elevator Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventElevatorActions = true;
            [JsonProperty("Prevent Entity Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventEntityLooting = true;
            [JsonProperty("Prevent Entity Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventEntityPickup = true;
            [JsonProperty("Prevent Explosives", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventExplosives = true;
            [JsonProperty("Prevent Flamers", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventFlamers = true;
            [JsonProperty("Prevent Fuel Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventFuelActions = true;
            [JsonProperty("Prevent Growable Gathering", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventGrowableGathering = true;
            [JsonProperty("Prevent Healing Item Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventHealingItemUsage = true;
            [JsonProperty("Prevent Helicopter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventHelicopterActions = true;
            [JsonProperty("Prevent Item Action", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemAction = true;
            [JsonProperty("Prevent Item Dropping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemDropping = true;
            [JsonProperty("Prevent Item Moving", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemMoving = true;
            [JsonProperty("Prevent Item Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemPickup = true;
            [JsonProperty("Prevent Item Skinning", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemSkinning = true;
            [JsonProperty("Prevent Item Stacking", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemStacking = true;
            [JsonProperty("Prevent Item Wearing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventItemWearing = true;
            [JsonProperty("Prevent Lift Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventLiftActions = true;
            [JsonProperty("Prevent Lock Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventLockActions = true;
            [JsonProperty("Prevent Mailbox Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventMailboxActions = true;
            [JsonProperty("Prevent Melee", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventMelee = true;
            [JsonProperty("Prevent Oven & Furnace Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventOvenActions = true;
            [JsonProperty("Prevent Phone Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventPhoneActions = true;
            [JsonProperty("Prevent Player Assist", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventPlayerAssist = true;
            [JsonProperty("Prevent Player Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventPlayerLooting = true;
            [JsonProperty("Prevent Push", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventPush = true;
            [JsonProperty("Prevent Recycler Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventRecyclerActions = true;
            [JsonProperty("Prevent Reloading", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventReloading = true;
            [JsonProperty("Prevent Repair", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventRepair = true;
            [JsonProperty("Prevent Research", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventResearch = true;
            [JsonProperty("Prevent Rockets", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventRockets = true;
            [JsonProperty("Prevent Shop Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventShopActions = true;
            [JsonProperty("Prevent Sign Update", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventSignUpdate = true;
            [JsonProperty("Prevent Stash Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventStashActions = true;
            [JsonProperty("Prevent Structure Rotate", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventStructureRotate = true;
            [JsonProperty("Prevent Switch Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventSwitchActions = true;
            [JsonProperty("Prevent Team Creation", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventTeamCreation = true;
            [JsonProperty("Prevent Trap Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventTrapActions = true;
            [JsonProperty("Prevent Turret Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventTurretActions = true;
            [JsonProperty("Prevent Upgrade", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventUpgrade = true;
            [JsonProperty("Prevent Vending Admin", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventVendingAdmin = true;
            [JsonProperty("Prevent Vending Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventVendingUsage = true;
            [JsonProperty("Prevent Weapon Firing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventWeaponFiring = true;
            [JsonProperty("Prevent Wiring", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventWiring = true;
            [JsonProperty("Prevent Wood Cutting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventWoodCutting = true;
            [JsonProperty("Prevent World Projectiles", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventWorldProjectiles = true;
            [JsonProperty("Prevent Wounded", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
            public bool PreventWounded = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            FConfigData = Config.ReadObject<ConfigData>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            FConfigData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(FConfigData);
        #endregion Config

        #region Script Methods
        private bool? CheckAndReturnNullOrFalse(BasePlayer aPlayer, string aBypassPerm)
        {
            if (aPlayer == null || aPlayer.IsNpc || aPlayer.IPlayer.IsServer || (FConfigData.AdminAlwaysVerified && Player.IsAdmin(aPlayer)) ||
                permission.UserHasPermission(aPlayer.UserIDString, CPermBypass) || permission.UserHasPermission(aPlayer.UserIDString, aBypassPerm))
                return null;

            return false;
        }

        private bool? CheckAndReturnNullOrFalse(IPlayer aPlayer, string aBypassPerm)
        {
            if (aPlayer == null || aPlayer.IsServer || (FConfigData.AdminAlwaysVerified && aPlayer.IsAdmin) ||
                permission.UserHasPermission(aPlayer.Id, CPermBypass) || permission.UserHasPermission(aPlayer.Id, aBypassPerm))
                return null;

            return false;
        }
        #endregion Script Methods

        #region Hooks
        void Init()
        {
            permission.RegisterPermission(CPermBypass, this);

            /*
            // Just as a nice-to-have I'll leave this here
            if (!permission.GroupExists(FConfigData.VerifiedPlayerGroup))
                permission.CreateGroup(FConfigData.VerifiedPlayerGroup, "", 0);
            */

            if (!FConfigData.PreventMount)
            {
                Unsubscribe(nameof(CanDismountEntity));
                Unsubscribe(nameof(CanMountEntity));
                Unsubscribe(nameof(CanSwapToSeat));
                Unsubscribe(nameof(OnRidableAnimalClaim));
            }
            else
            {
                permission.RegisterPermission(CPermBypassMount, this);
            }

            if (!FConfigData.PreventBedActions)
            {
                Unsubscribe(nameof(CanAssignBed));
                Unsubscribe(nameof(CanRenameBed));
                Unsubscribe(nameof(CanSetBedPublic));
            }
            else
            {
                permission.RegisterPermission(CPermBypassBedActions, this);
            }

            if (!FConfigData.PreventBuild)
            {
                Unsubscribe(nameof(CanAffordToPlace));
                Unsubscribe(nameof(CanBuild));
                Unsubscribe(nameof(OnConstructionPlace));
            }
            else
            {
                permission.RegisterPermission(CPermBypassBuild, this);
            }

            if (!FConfigData.PreventCardSwiping)
            {
                Unsubscribe(nameof(OnCardSwipe));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCardSwiping, this);
            }

            if (!FConfigData.PreventChat)
            {
                Unsubscribe(nameof(OnUserChat));
            }
            else
            {
                permission.RegisterPermission(CPermBypassChat, this);
            }

            if (!FConfigData.PreventCollectiblePickup)
            {
                Unsubscribe(nameof(OnCollectiblePickup));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCollectiblePickup, this);
            }

            if (!FConfigData.PreventCommand)
            {
                Unsubscribe(nameof(OnUserCommand));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCommand, this);
            }

            if (!FConfigData.PreventCounterActions)
            {
                Unsubscribe(nameof(OnCounterModeToggle));
                Unsubscribe(nameof(OnCounterTargetChange));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCounterActions, this);
            }

            if (FConfigData.PreventCrafting)
                permission.RegisterPermission(CPermBypassCrafting, this);

            if (!FConfigData.PreventCrateHack)
            {
                Unsubscribe(nameof(CanHackCrate));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCrateHack, this);
            }

            if (!FConfigData.PreventCupboardActions)
            {
                Unsubscribe(nameof(OnCupboardAuthorize));
                Unsubscribe(nameof(OnCupboardClearList));
                Unsubscribe(nameof(OnCupboardDeauthorize));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCupboardActions, this);
            }

            if (!FConfigData.PreventCustomUI)
            {
                Unsubscribe(nameof(CanUseUI));
            }
            else
            {
                permission.RegisterPermission(CPermBypassCustomUI, this);
            }

            if (!FConfigData.PreventDemolish)
            {
                Unsubscribe(nameof(CanDemolish));
                Unsubscribe(nameof(OnStructureDemolish));
            }
            else
            {
                permission.RegisterPermission(CPermBypassDemolish, this);
            }

            if (!FConfigData.PreventDeployItem)
            {
                Unsubscribe(nameof(CanDeployItem));
            }
            else
            {
                permission.RegisterPermission(CPermBypassDeployItem, this);
            }

            if (!FConfigData.PreventDoorActions)
            {
                Unsubscribe(nameof(OnDoorClosed));
                Unsubscribe(nameof(OnDoorOpened));
            }
            else
            {
                permission.RegisterPermission(CPermBypassDoorActions, this);
            }

            if (!FConfigData.PreventElevatorActions)
            {
                Unsubscribe(nameof(OnElevatorButtonPress));
            }
            else
            {
                permission.RegisterPermission(CPermBypassElevatorActions, this);
            }

            if (!FConfigData.PreventEntityLooting)
            {
                Unsubscribe(nameof(CanLootEntity));
            }
            else
            {
                permission.RegisterPermission(CPermBypassEntityLooting, this);
            }

            if (!FConfigData.PreventEntityPickup)
            {
                Unsubscribe(nameof(CanPickupEntity));
            }
            else
            {
                permission.RegisterPermission(CPermBypassEntityPickup, this);
            }

            if (!FConfigData.PreventExplosives)
            {
                Unsubscribe(nameof(OnExplosiveDropped));
                Unsubscribe(nameof(OnExplosiveThrown));
            }
            else
            {
                permission.RegisterPermission(CPermBypassExplosives, this);
            }

            if (!FConfigData.PreventFlamers)
            {
                Unsubscribe(nameof(OnFlameThrowerBurn));
            }
            else
            {
                permission.RegisterPermission(CPermBypassFlamers, this);
            }

            if (!FConfigData.PreventFuelActions)
            {
                Unsubscribe(nameof(CanCheckFuel));
            }
            else
            {
                permission.RegisterPermission(CPermBypassFuelActions, this);
            }

            if (!FConfigData.PreventGrowableGathering)
            {
                Unsubscribe(nameof(OnGrowableGather));
            }
            else
            {
                permission.RegisterPermission(CPermBypassGrowableGathering, this);
            }

            if (!FConfigData.PreventHealingItemUsage)
            {
                Unsubscribe(nameof(OnHealingItemUse));
            }
            else
            {
                permission.RegisterPermission(CPermBypassHealingItemUsage, this);
            }

            if (!FConfigData.PreventHelicopterActions)
            {
                Unsubscribe(nameof(CanUseHelicopter));
            }
            else
            {
                permission.RegisterPermission(CPermBypassHelicopterActions, this);
            }

            if (!FConfigData.PreventItemAction)
            {
                Unsubscribe(nameof(OnItemAction));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemActions, this);
            }

            if (!FConfigData.PreventItemDropping)
            {
                Unsubscribe(nameof(CanDropActiveItem));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemDropping, this);
            }

            if (!FConfigData.PreventItemMoving)
            {
                Unsubscribe(nameof(CanAcceptItem));
                Unsubscribe(nameof(CanMoveItem));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemMoving, this);
            }

            if (!FConfigData.PreventItemPickup)
            {
                Unsubscribe(nameof(OnItemPickup));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemPickup, this);
            }

            if (!FConfigData.PreventItemSkinning)
            {
                Unsubscribe(nameof(OnItemSkinChange));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemSkinning, this);
            }

            if (!FConfigData.PreventItemStacking)
            {
                Unsubscribe(nameof(CanStackItem));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemStacking, this);
            }

            if (!FConfigData.PreventItemWearing)
            {
                Unsubscribe(nameof(CanWearItem));
            }
            else
            {
                permission.RegisterPermission(CPermBypassItemWearing, this);
            }

            if (!FConfigData.PreventLiftActions)
            {
                Unsubscribe(nameof(OnLiftUse));
            }
            else
            {
                permission.RegisterPermission(CPermBypassLiftActions, this);
            }

            if (!FConfigData.PreventLockActions)
            {
                Unsubscribe(nameof(CanChangeCode));
                Unsubscribe(nameof(CanLock));
                Unsubscribe(nameof(CanPickupLock));
                Unsubscribe(nameof(CanUnlock));
                Unsubscribe(nameof(CanUseLockedEntity));
                Unsubscribe(nameof(OnCodeEntered));
                Unsubscribe(nameof(OnItemLock));
                Unsubscribe(nameof(OnItemUnlock));
            }
            else
            {
                permission.RegisterPermission(CPermBypassLockActions, this);
            }

            if (!FConfigData.PreventMailboxActions)
            {
                Unsubscribe(nameof(CanUseMailbox));
            }
            else
            {
                permission.RegisterPermission(CPermBypassMailboxActions, this);
            }

            if (!FConfigData.PreventMelee)
            {
                Unsubscribe(nameof(OnMeleeAttack));
                Unsubscribe(nameof(OnMeleeThrown));
            }
            else
            {
                permission.RegisterPermission(CPermBypassMelee, this);
            }

            if (!FConfigData.PreventOvenActions)
            {
                Unsubscribe(nameof(OnOvenToggle));
            }
            else
            {
                permission.RegisterPermission(CPermBypassOvenActions, this);
            }

            if (!FConfigData.PreventPhoneActions)
            {
                Unsubscribe(nameof(OnPhoneDial));
                Unsubscribe(nameof(OnPhoneCallStart));
                Unsubscribe(nameof(OnPhoneNameUpdate));
            }
            else
            {
                permission.RegisterPermission(CPermBypassPhoneActions, this);
            }

            if (!FConfigData.PreventPlayerAssist)
            {
                Unsubscribe(nameof(OnPlayerAssist));
                Unsubscribe(nameof(OnPlayerRevive));
            }
            else
            {
                permission.RegisterPermission(CPermBypassPlayerAssist, this);
            }

            if (!FConfigData.PreventPlayerLooting)
            {
                Unsubscribe(nameof(CanLootPlayer));
            }
            else
            {
                permission.RegisterPermission(CPermBypassPlayerLooting, this);
            }

            if (!FConfigData.PreventPush)
            {
                Unsubscribe(nameof(CanPushBoat));
                Unsubscribe(nameof(OnVehiclePush));
            }
            else
            {
                permission.RegisterPermission(CPermBypassPush, this);
            }

            if (!FConfigData.PreventRecyclerActions)
            {
                Unsubscribe(nameof(OnRecyclerToggle));
            }
            else
            {
                permission.RegisterPermission(CPermBypassRecyclerActions, this);
            }

            if (!FConfigData.PreventReloading)
            {
                Unsubscribe(nameof(OnReloadMagazine));
                Unsubscribe(nameof(OnReloadWeapon));
                Unsubscribe(nameof(OnSwitchAmmo));
            }
            else
            {
                permission.RegisterPermission(CPermBypassReloading, this);
            }

            if (!FConfigData.PreventRepair)
            {
                Unsubscribe(nameof(OnHammerHit));
                Unsubscribe(nameof(OnStructureRepair));
            }
            else
            {
                permission.RegisterPermission(CPermBypassRepair, this);
            }

            if (!FConfigData.PreventResearch)
            {
                Unsubscribe(nameof(CanResearchItem));
                Unsubscribe(nameof(CanUnlockTechTreeNode));
                Unsubscribe(nameof(CanUnlockTechTreeNodePath));
            }
            else
            {
                permission.RegisterPermission(CPermBypassResearch, this);
            }

            if (!FConfigData.PreventRockets)
            {
                Unsubscribe(nameof(OnRocketLaunched));
            }
            else
            {
                permission.RegisterPermission(CPermBypassRockets, this);
            }

            if (!FConfigData.PreventShopActions)
            {
                Unsubscribe(nameof(OnShopCompleteTrade));
            }
            else
            {
                permission.RegisterPermission(CPermBypassShopActions, this);
            }

            if (!FConfigData.PreventSignUpdate)
            {
                Unsubscribe(nameof(CanUpdateSign));
            }
            else
            {
                permission.RegisterPermission(CPermBypassSignUpdate, this);
            }

            if (!FConfigData.PreventStashActions)
            {
                Unsubscribe(nameof(CanHideStash));
                Unsubscribe(nameof(CanSeeStash));
            }
            else
            {
                permission.RegisterPermission(CPermBypassStashActions, this);
            }

            if (!FConfigData.PreventStructureRotate)
            {
                Unsubscribe(nameof(OnStructureRotate));
            }
            else
            {
                permission.RegisterPermission(CPermBypassStructureRotate, this);
            }

            if (!FConfigData.PreventSwitchActions)
            {
                Unsubscribe(nameof(OnSwitchToggle));
            }
            else
            {
                permission.RegisterPermission(CPermBypassSwitchActions, this);
            }

            if (!FConfigData.PreventTeamCreation)
            {
                Unsubscribe(nameof(OnTeamCreate));
            }
            else
            {
                permission.RegisterPermission(CPermBypassTeamCreation, this);
            }

            if (!FConfigData.PreventTrapActions)
            {
                Unsubscribe(nameof(OnTrapArm));
                Unsubscribe(nameof(OnTrapDisarm));
            }
            else
            {
                permission.RegisterPermission(CPermBypassTrapActions, this);
            }

            if (!FConfigData.PreventTurretActions)
            {
                Unsubscribe(nameof(OnTurretAuthorize));
                Unsubscribe(nameof(OnTurretClearList));
                Unsubscribe(nameof(OnTurretRotate));
            }
            else
            {
                permission.RegisterPermission(CPermBypassTurretActions, this);
            }

            if (!FConfigData.PreventUpgrade)
            {
                Unsubscribe(nameof(CanAffordUpgrade));
                Unsubscribe(nameof(CanChangeGrade));
                Unsubscribe(nameof(OnStructureUpgrade));
            }
            else
            {
                permission.RegisterPermission(CPermBypassUpgrade, this);
            }

            if (!FConfigData.PreventVendingAdmin)
            {
                Unsubscribe(nameof(CanAdministerVending));
                Unsubscribe(nameof(OnRotateVendingMachine));
            }
            else
            {
                permission.RegisterPermission(CPermBypassVendingAdmin, this);
            }

            if (!FConfigData.PreventVendingUsage)
            {
                Unsubscribe(nameof(CanUseVending));
                Unsubscribe(nameof(OnBuyVendingItem));
                Unsubscribe(nameof(OnVendingTransaction));
            }
            else
            {
                permission.RegisterPermission(CPermBypassVendingUsage, this);
            }

            if (!FConfigData.PreventWeaponFiring)
            {
                Unsubscribe(nameof(OnWeaponFired));
            }
            else
            {
                permission.RegisterPermission(CPermBypassWeaponFiring, this);
            }

            if (!FConfigData.PreventWiring)
            {
                Unsubscribe(nameof(CanUseWires));
            }
            else
            {
                permission.RegisterPermission(CPermBypassWiring, this);
            }

            if (!FConfigData.PreventWoodCutting)
            {
                Unsubscribe(nameof(CanTakeCutting));
            }
            else
            {
                permission.RegisterPermission(CPermBypassWoodCutting, this);
            }

            if (!FConfigData.PreventWorldProjectiles)
            {
                Unsubscribe(nameof(CanCreateWorldProjectile));
                Unsubscribe(nameof(OnCreateWorldProjectile));
            }
            else
            {
                permission.RegisterPermission(CPermBypassWorldProjectiles, this);
            }

            if (!FConfigData.PreventWounded)
            {
                Unsubscribe(nameof(CanBeWounded));
            }
            else
            {
                permission.RegisterPermission(CPermBypassWounded, this);
            }

            if (!(FConfigData.PreventCrafting || FConfigData.PreventItemSkinning))
                Unsubscribe(nameof(CanCraft));
        }

        // PreventMount
        bool? CanDismountEntity(BasePlayer aPlayer, BaseMountable aEntity) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMount);

        bool? CanMountEntity(BasePlayer aPlayer, BaseMountable aEntity) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMount);

        bool? CanSwapToSeat(BasePlayer aPlayer, BaseMountable aMountable) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMount);

        bool? OnRidableAnimalClaim(BaseRidableAnimal aAnimal, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMount);

        // PreventBedActions
        bool? CanAssignBed(BasePlayer aPlayer, SleepingBag aBag, ulong aTargetPlayerId) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassBedActions);

        bool? CanRenameBed(BasePlayer aPlayer, SleepingBag aBed, string aBedName) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassBedActions);

        bool? CanSetBedPublic(BasePlayer aPlayer, SleepingBag aBed) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassBedActions);

        // PreventBuild
        bool? CanAffordToPlace(BasePlayer aPlayer, Planner aPlanner, Construction aConstruction) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassBuild);

        bool? CanBuild(Planner aPlanner, Construction aPrefab, Construction.Target aTarget) =>
            CheckAndReturnNullOrFalse(aPlanner.GetOwnerPlayer(), CPermBypassBuild);

        bool? OnConstructionPlace(BaseEntity aEntity, Construction aComponent, Construction.Target aConstructionTarget, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassBuild);

        // PreventCardSwiping
        bool? OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCardSwiping);

        // PreventChat
        bool? OnUserChat(IPlayer aPlayer, string aMessage) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassChat);

        // PreventCollectiblePickup
        bool? OnCollectiblePickup(CollectibleEntity aEntity, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassCollectiblePickup);

        // PreventCommand
        bool? OnUserCommand(IPlayer aPlayer, string command, string[] args) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCommand);

        // PreventCounterActions
        bool? OnCounterModeToggle(PowerCounter aCounter, BasePlayer aPlayer, bool aMode) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCounterActions);

        bool? OnCounterTargetChange(PowerCounter aCounter, BasePlayer aPlayer, int aTargetNumber) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassCounterActions);

        // PreventCrafting
        bool? CanCraft(ItemCrafter aItemCrafter, ItemBlueprint aBp, int aAmount) =>
            FConfigData.PreventCrafting
                ? CheckAndReturnNullOrFalse(aItemCrafter.baseEntity, CPermBypassCrafting)
                : null;

        bool? CanCraft(PlayerBlueprints aPlayerBlueprints, ItemDefinition aItemDefinition, int aSkinItemId)
        {
            bool? result = null;

            if (FConfigData.PreventCrafting)
                result = CheckAndReturnNullOrFalse(aPlayerBlueprints.baseEntity, CPermBypassCrafting);

            if (result == null && FConfigData.PreventCrafting && aSkinItemId != 0)
                result = CheckAndReturnNullOrFalse(aPlayerBlueprints.baseEntity, CPermBypassItemSkinning);

            return result;
        }

        // PreventCrateHack
        bool? CanHackCrate(BasePlayer aPlayer, HackableLockedCrate aCrate) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCrateHack);


        // PreventCupboardActions
        bool? OnCupboardAuthorize(BuildingPrivlidge aPrivilege, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCupboardActions);

        bool? OnCupboardClearList(BuildingPrivlidge aPrivilege, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCupboardActions);

        bool? OnCupboardDeauthorize(BuildingPrivlidge aPrivilege, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCupboardActions);

        // PreventCustomUI
        bool? CanUseUI(BasePlayer aPlayer, string aJson) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassCustomUI);

        // PreventDemolish
        bool? CanDemolish(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassDemolish);

        bool? OnStructureDemolish(BaseCombatEntity aEntity, BasePlayer aPlayer, bool aImmediate) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassDemolish);

        // PreventDeployItem
        bool? CanDeployItem(BasePlayer aPlayer, Deployer aDeployer, uint aEntityId) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassDeployItem);

        // PreventDoorActions
        void OnDoorClosed(Door aDoor, BasePlayer aPlayer)
        {
            if (aPlayer == null || aPlayer.IsNpc || aPlayer.IPlayer.IsServer || (FConfigData.AdminAlwaysVerified && Player.IsAdmin(aPlayer)) ||
                permission.UserHasPermission(aPlayer.UserIDString, CPermBypass) || permission.UserHasPermission(aPlayer.UserIDString, CPermBypassDoorActions))
                return;

            aDoor.SetOpen(true, false);
        }

        void OnDoorOpened(Door aDoor, BasePlayer aPlayer)
        {
            if (aPlayer == null || aPlayer.IsNpc || aPlayer.IPlayer.IsServer || (FConfigData.AdminAlwaysVerified && Player.IsAdmin(aPlayer)) ||
                permission.UserHasPermission(aPlayer.UserIDString, CPermBypass) || permission.UserHasPermission(aPlayer.UserIDString, CPermBypassDoorActions))
                return;

            aDoor.SetOpen(false, false);
        }


        // PreventElevatorActions
        bool? OnElevatorButtonPress(ElevatorLift aLift, BasePlayer aPlayer, Elevator.Direction aDirection, bool aToTopOrBottom) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassElevatorActions);


        // PreventEntityLooting
        bool? CanLootEntity(BasePlayer aPlayer, BaseRidableAnimal aAnimal) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityLooting);

        bool? CanLootEntity(BasePlayer aPlayer, DroppedItemContainer aContainer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityLooting);

        bool? CanLootEntity(BasePlayer aPlayer, LootableCorpse aCorpse) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityLooting);

        bool? CanLootEntity(BasePlayer aPlayer, ResourceContainer aContainer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityLooting);

        bool? CanLootEntity(BasePlayer aPlayer, StorageContainer aContainer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityLooting);


        // PreventEntityPickup
        bool? CanPickupEntity(BasePlayer aPlayer, BaseEntity aEntity) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassEntityPickup);


        // PreventExplosives
        void OnExplosiveDropped(BasePlayer aPlayer, BaseEntity aEntity, ThrownWeapon aItem)
        {
            if (CheckAndReturnNullOrFalse(aPlayer, CPermBypassExplosives) != null)
                aEntity.AdminKill();
        }

        void OnExplosiveThrown(BasePlayer aPlayer, BaseEntity aEntity, ThrownWeapon aItem)
        {
            if (CheckAndReturnNullOrFalse(aPlayer, CPermBypassExplosives) != null)
                aEntity.AdminKill();
        }


        // PreventFlamers
        void OnFlameThrowerBurn(FlameThrower aThrower, BaseEntity aFlame)
        {
            if (CheckAndReturnNullOrFalse(aThrower.GetOwnerPlayer(), CPermBypassFlamers) != null)
                aThrower.SetFlameState(false);
        }


        // PreventFuelActions
        bool? CanCheckFuel(EntityFuelSystem aFuelSystem, StorageContainer aFuelContainer, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassFuelActions);


        // PreventGrowableGathering
        bool? OnGrowableGather(GrowableEntity plant, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassGrowableGathering);


        // PreventHealingItemUsage
        bool? OnHealingItemUse(MedicalTool aTool, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassHealingItemUsage);


        // PreventHelicopterActions
        bool? CanUseHelicopter(BasePlayer aPlayer, CH47HelicopterAIController aHelicopter) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassHelicopterActions);


        // PreventItemAction
        bool? OnItemAction(Item aItem, string aAction, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassItemActions);


        // PreventItemDropping
        bool? CanDropActiveItem(BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassItemDropping);


        // PreventItemMoving
        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer aContainer, Item aItem, int aTargetPos)
        {
            BasePlayer player = aItem.GetOwnerPlayer();

            if (player == null || player.IsNpc || player.IPlayer.IsServer || (FConfigData.AdminAlwaysVerified && Player.IsAdmin(player)) ||
                permission.UserHasPermission(player.UserIDString, CPermBypass) || permission.UserHasPermission(player.UserIDString, CPermBypassItemMoving))
                return null;

            return ItemContainer.CanAcceptResult.CannotAccept;
        }

        bool? CanMoveItem(Item aItem, PlayerInventory aPlayerLoot, uint aTargetContainer, int aTargetSlot, int aAmount)
        {
            bool? result = CheckAndReturnNullOrFalse(aItem.GetOwnerPlayer(), CPermBypassItemMoving);
            return result is bool
                ? result
                : CheckAndReturnNullOrFalse(aPlayerLoot.baseEntity, CPermBypassItemMoving);
        }


        // PreventItemPickup
        bool? OnItemPickup(Item aItem, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassItemPickup);


        // PreventItemSkinning
        bool? OnItemSkinChange(int aSkinItemId, Item aItem, StorageContainer aContainer, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassItemSkinning);


        // PreventItemStacking
        bool? CanStackItem(Item aItem, Item aTargetItem) => CheckAndReturnNullOrFalse(aItem.GetOwnerPlayer(), CPermBypassItemStacking);


        // PreventItemWearing
        bool? CanWearItem(PlayerInventory aInventory, Item aItem, int aTargetSlot) => CheckAndReturnNullOrFalse(aInventory.baseEntity, CPermBypassItemWearing);


        // PreventLiftActions
        bool? OnLiftUse(Lift aLift, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLiftActions);

        bool? OnLiftUse(ProceduralLift aLift, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLiftActions);


        // PreventLockActions
        bool? CanChangeCode(BasePlayer aPlayer, CodeLock aCodeLock, string aNewCode, bool aIsGuestCode) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? CanLock(BasePlayer aPlayer, BaseLock aLock) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? CanPickupLock(BasePlayer aPlayer, BaseLock aBaseLock) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? CanUnlock(BasePlayer aPlayer, BaseLock aBaseLock) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? CanUseLockedEntity(BasePlayer aPlayer, BaseLock aBaseLock) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? OnCodeEntered(CodeLock aCodeLock, BasePlayer aPlayer, string aCode) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassLockActions);

        bool? OnItemLock(Item aItem) => CheckAndReturnNullOrFalse(aItem.GetOwnerPlayer(), CPermBypassLockActions);

        bool? OnItemUnlock(Item aItem) => CheckAndReturnNullOrFalse(aItem.GetOwnerPlayer(), CPermBypassLockActions);


        // PreventMailboxActions
        bool? CanUseMailbox(BasePlayer aPlayer, Mailbox aMailbox) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMailboxActions);


        // PreventMelee
        bool? OnMeleeAttack(BasePlayer aPlayer, HitInfo aInfo) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassMelee);

        void OnMeleeThrown(BasePlayer aPlayer, Item aItem)
        {
            if (CheckAndReturnNullOrFalse(aPlayer, CPermBypassMelee) != null)
                aItem.Remove();
        }


        // PreventOvenActions
        bool? OnOvenToggle(BaseOven aOven, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassOvenActions);


        // PreventPhoneActions
        bool? OnPhoneDial(PhoneController aCallerPhone, PhoneController aReceiverPhone, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassPhoneActions);

        bool? OnPhoneCallStart(PhoneController aPhone, PhoneController aOtherPhone, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassPhoneActions);

        bool? OnPhoneNameUpdate(PhoneController aPhoneController, string aName, BasePlayer aPlayer) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassPhoneActions);


        // PreventPlayerAssist
        bool? OnPlayerAssist(BasePlayer aTarget, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassPlayerAssist);

        bool? OnPlayerRevive(BasePlayer aReviver, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassPlayerAssist);


        // PreventPlayerLooting
        bool? CanLootPlayer(BasePlayer aTarget, BasePlayer aLooter) => CheckAndReturnNullOrFalse(aLooter, CPermBypassPlayerLooting);


        // PreventPush
        bool? CanPushBoat(BasePlayer aPlayer, MotorRowboat aBoat) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassPush);

        bool? OnVehiclePush(BaseVehicle aVehicle, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassPush);


        // PreventRecyclerActions
        bool? OnRecyclerToggle(Recycler aRecycler, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassRecyclerActions);


        // PreventReloading
        bool? OnReloadMagazine(BasePlayer aPlayer, BaseProjectile aProjectile, int aDesiredAmount) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassReloading);

        bool? OnReloadWeapon(BasePlayer aPlayer, BaseProjectile aProjectile) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassReloading);

        bool? OnSwitchAmmo(BasePlayer aPlayer, BaseProjectile aProjectile) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassReloading);


        // PreventRepair
        bool? OnHammerHit(BasePlayer aPlayer, HitInfo aInfo) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassRepair);

        bool? OnStructureRepair(BaseCombatEntity aEntity, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassRepair);


        // PreventResearch
        bool? CanResearchItem(BasePlayer aPlayer, Item aTargetItem) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassResearch);

        bool? CanUnlockTechTreeNode(BasePlayer aPlayer, TechTreeData.NodeInstance aNode, TechTreeData aTechTree) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassResearch);

        bool? CanUnlockTechTreeNodePath(BasePlayer aPlayer, TechTreeData.NodeInstance aNode, TechTreeData aTechTree) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassResearch);


        // PreventRockets
        void OnRocketLaunched(BasePlayer aPlayer, BaseEntity aEntity)
        {
            if (CheckAndReturnNullOrFalse(aPlayer, CPermBypassRockets) != null)
                aEntity.AdminKill();
        }


        // PreventShopActions
        bool? OnShopCompleteTrade(ShopFront aShop, BasePlayer aCustomer) => CheckAndReturnNullOrFalse(aCustomer, CPermBypassShopActions);


        // PreventSignUpdate
        bool? CanUpdateSign(BasePlayer aPlayer, PhotoFrame aPhotoFrame) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassSignUpdate);

        bool? CanUpdateSign(BasePlayer aPlayer, Signage aSign) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassSignUpdate);


        // PreventStashActions
        bool? CanHideStash(BasePlayer aPlayer, StashContainer aStash) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassStashActions);

        bool? CanSeeStash(BasePlayer aPlayer, StashContainer aStash) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassStashActions);


        // PreventStructureRotate
        bool? OnStructureRotate(BaseCombatEntity aEntity, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassStructureRotate);


        // PreventSwitchActions
        bool? OnSwitchToggle(IOEntity aEntity, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassSwitchActions);


        // PreventTeamCreation
        bool? OnTeamCreate(BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTeamCreation);


        // PreventTrapActions
        bool? OnTrapArm(BearTrap aTrap, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTrapActions);

        bool? OnTrapDisarm(Landmine aTrap, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTrapActions);


        // PreventTurretActions
        bool? OnTurretAuthorize(AutoTurret aTurret, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTurretActions);

        bool? OnTurretClearList(AutoTurret aTurret, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTurretActions);

        bool? OnTurretRotate(AutoTurret aTurret, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassTurretActions);


        // PreventUpgrade
        bool? CanAffordUpgrade(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassUpgrade);

        bool? CanChangeGrade(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassUpgrade);

        bool? OnStructureUpgrade(BaseCombatEntity aEntity, BasePlayer aPlayer, BuildingGrade.Enum aGrade) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassUpgrade);


        // PreventVendingAdmin
        bool? CanAdministerVending(BasePlayer aPlayer, VendingMachine aMachine) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassVendingAdmin);

        bool? OnRotateVendingMachine(VendingMachine aMachine, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassVendingAdmin);


        // PreventVendingUsage
        bool? CanUseVending(VendingMachine aMachine, BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassVendingUsage);

        bool? OnBuyVendingItem(VendingMachine aMachine, BasePlayer aPlayer, int aSellOrderId, int aNumberOfTransactions) =>
            CheckAndReturnNullOrFalse(aPlayer, CPermBypassVendingUsage);

        bool? OnVendingTransaction(VendingMachine aMachine, BasePlayer aBuyer, int aSellOrderId, int aNumberOfTransactions) =>
            CheckAndReturnNullOrFalse(aBuyer, CPermBypassVendingUsage);


        // PreventWeaponFiring
        void OnWeaponFired(BaseProjectile aProjectile, BasePlayer aPlayer, ItemModProjectile aMod, ProtoBuf.ProjectileShoot aProjectiles)
        {
            if (CheckAndReturnNullOrFalse(aPlayer, CPermBypassWeaponFiring) != null)
                aProjectiles.projectiles.Clear();
        }


        // PreventWiring
        bool? CanUseWires(BasePlayer aPlayer) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassWiring);


        // PreventWoodCutting
        bool? CanTakeCutting(BasePlayer aPlayer, GrowableEntity aEntity) => CheckAndReturnNullOrFalse(aPlayer, CPermBypassWoodCutting);


        // PreventWorldProjectiles
        bool? CanCreateWorldProjectile(HitInfo aInfo, ItemDefinition aItemDef) =>
            CheckAndReturnNullOrFalse(aInfo.InitiatorPlayer, CPermBypassWorldProjectiles);

        bool? OnCreateWorldProjectile(HitInfo aInfo, Item aItem) =>
            CheckAndReturnNullOrFalse(aInfo.InitiatorPlayer, CPermBypassWorldProjectiles);


        // PreventWounded
        bool? CanBeWounded(BasePlayer aPlayer, HitInfo aInfo) =>
            CheckAndReturnNullOrFalse(aInfo.InitiatorPlayer, CPermBypassWounded);
        #endregion Hooks
    }
}


// --- End of file: VerificationGatekeeper.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-license ---
// --- Original File Path: V/VehicleLicence/VehicleLicence.cs ---

﻿// #define DEBUG

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Rust;
using Rust.Modular;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Random = UnityEngine.Random;

// TODO: Fix mincopters spawning above user.

namespace Oxide.Plugins
{
    [Info("Vehicle Licence", "Sorrow/TheDoc/Arainrr", "1.8.7")]
    [Description("Allows players to buy vehicles and then spawn or store it")]
    public class VehicleLicence : RustPlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Economics, ServerRewards, Friends, Clans, NoEscape, LandOnCargoShip, RustTranslationAPI, ZoneManager;

        private readonly string PERMISSION_USE = "vehiclelicence.use";
        private readonly string PERMISSION_ALL = "vehiclelicence.all";
        private readonly string PERMISSION_ADMIN = "vehiclelicence.admin";

        private readonly string PERMISSION_BYPASS_COST = "vehiclelicence.bypasscost";
        private readonly string PERMISSION_NO_DAMAGE = "vehiclelicence.nodamage";
        private readonly string PERMISSION_NO_COLLISION_DAMAGE = "vehiclelicence.nocollisiondamage";

        private const int ITEMID_FUEL = -946369541;
        private const int ITEMID_HOTAIRBALLOON_ARMOR = -1989600732;
        private const string PREFAB_ITEM_DROP = "assets/prefabs/misc/item drop/item_drop.prefab";

        //BIKES
        private const string PREFAB_PEDALBIKE = "assets/content/vehicles/bikes/pedalbike.prefab";
        private const string PREFAB_PEDALTRIKE = "assets/content/vehicles/bikes/pedaltrike.prefab";
        private const string PREFAB_MOTORBIKE = "assets/content/vehicles/bikes/motorbike.prefab";
        private const string PREFAB_MOTORBIKE_SIDECAR = "assets/content/vehicles/bikes/motorbike_sidecar.prefab";

        //SPECIAL
        private const string PREFAB_ATV = "assets/custom/atv.prefab";
        private const string PREFAB_SOFA = "assets/custom/racesofa.prefab";
        private const string PREFAB_WATERBIRD = "assets/custom/waterheli.prefab";
        private const string PREFAB_WARBIRD = "assets/custom/warbird.prefab";
        private const string PREFAB_LITTLEBIRD = "assets/custom/littlebird.prefab";
        private const string PREFAB_FIGHTER = "assets/custom/fighter.prefab";
        private const string PREFAB_OLDFIGHTER = "assets/custom/oldfighter.prefab";
        private const string PREFAB_FIGHTERBUS = "assets/custom/fighterbus.prefab";
        private const string PREFAB_WARBUS = "assets/custom/warbus.prefab";
        private const string PREFAB_AIRBUS = "assets/custom/airbus.prefab";
        private const string PREFAB_PATROLHELI = "assets/custom/patrolheli.prefab";
        private const string PREFAB_RUSTWING = "assets/custom/rustwing.prefab";
        private const string PREFAB_RUSTWINGDETAILED = "assets/custom/rustwing_detailed.prefab";
        private const string PREFAB_RUSTWINGDETAILEDOLD = "assets/custom/rustwing_detailed_old.prefab";
        private const string PREFAB_TINFIGHTER = "assets/custom/tinfighter.prefab";
        private const string PREFAB_TINFIGHTERDETAILED = "assets/custom/tinfighter_detailed.prefab";
        private const string PREFAB_TINFIGHTERDETAILEDOLD = "assets/custom/tinfighter_detailed_old.prefab";
        private const string PREFAB_MARSFIGHTER = "assets/custom/marsfighter.prefab";
        private const string PREFAB_MARSFIGHTERDETAILED = "assets/custom/marsfighter_detailed.prefab";
        private const string PREFAB_SKYPLANE = "assets/custom/skyplane.prefab";
        private const string PREFAB_SKYBOAT = "assets/custom/skyboat.prefab";
        private const string PREFAB_TWISTEDTRUCK = "assets/custom/twistedtruck.prefab";
        private const string PREFAB_TRIANWRECK = "assets/custom/trainwreck.prefab";
        private const string PREFAB_TRIANWRECKER = "assets/custom/trainwrecker.prefab";
        private const string PREFAB_SANTA = "assets/custom/santa.prefab";
        private const string PREFAB_WARSANTA = "assets/custom/warsanta.prefab";
        private const string PREFAB_WITCH = "assets/custom/witch.prefab";
        private const string PREFAB_MAGICCARPET = "assets/custom/magiccarpet.prefab";
        private const string PREFAB_AH69T = "assets/custom/ah69t.prefab";
        private const string PREFAB_AH69R = "assets/custom/ah69r.prefab";
        private const string PREFAB_AH69A = "assets/custom/ah69a.prefab";
        private const string PREFAB_MAVIK = "assets/custom/mavik.prefab";
        private const string PREFAB_HEAVYFIGHTER = "assets/custom/heavyfighter.prefab";
        private const string PREFAB_PORCELAINCOMMANDER = "assets/custom/porcelaincommander.prefab";
        private const string PREFAB_DUNEBUGGIE = "assets/custom/dunebuggie.prefab";
        private const string PREFAB_DUNETRUCKARMED = "assets/custom/dunetruckarmed.prefab";
        private const string PREFAB_DUNETRUCKUNARMED = "assets/custom/dunetruckunarmed.prefab";
        private const string PREFAB_DOOMSDAYDISCOVAN = "assets/custom/doomsdaydiscovan.prefab";
        private const string PREFAB_FORKLIFT = "assets/custom/forklift.prefab";
        private const string PREFAB_LAWNMOWER = "assets/custom/lawnmower.prefab";
        private const string PREFAB_CHARIOT = "assets/custom/chariot.prefab";
        private const string PREFAB_SOULHARVESTER = "assets/custom/soulharvester.prefab";

        //OTHER
        private const string PREFAB_KAYAK = "assets/content/vehicles/boats/kayak/kayak.prefab";
        private const string PREFAB_TUGBOAT = "assets/content/vehicles/boats/tugboat/tugboat.prefab";
        private const string PREFAB_ROWBOAT = "assets/content/vehicles/boats/rowboat/rowboat.prefab";
        private const string PREFAB_RHIB = "assets/content/vehicles/boats/rhib/rhib.prefab";
        private const string PREFAB_SEDAN = "assets/content/vehicles/sedan_a/sedantest.entity.prefab";
        private const string PREFAB_HOTAIRBALLOON = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab";
        private const string PREFAB_MINICOPTER = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        private const string PREFAB_ATTACKHELICOPTER = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab";
        private const string PREFAB_TRANSPORTCOPTER = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";
        private const string PREFAB_CHINOOK = "assets/prefabs/npc/ch47/ch47.entity.prefab";
        private const string PREFAB_RIDABLEHORSE = "assets/content/vehicles/horse/ridablehorse2.prefab";
        private const string PREFAB_WORKCART = "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
        private const string PREFAB_SEDANRAIL = "assets/content/vehicles/sedan_a/sedanrail.entity.prefab";
        private const string PREFAB_MAGNET_CRANE = "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab";
        private const string PREFAB_SUBMARINE_DUO = "assets/content/vehicles/submarine/submarineduo.entity.prefab";
        private const string PREFAB_SUBMARINE_SOLO = "assets/content/vehicles/submarine/submarinesolo.entity.prefab";

        private const string PREFAB_CHASSIS_SMALL = "assets/content/vehicles/modularcar/car_chassis_2module.entity.prefab";
        private const string PREFAB_CHASSIS_MEDIUM = "assets/content/vehicles/modularcar/car_chassis_3module.entity.prefab";
        private const string PREFAB_CHASSIS_LARGE = "assets/content/vehicles/modularcar/car_chassis_4module.entity.prefab";

        private const string PREFAB_SNOWMOBILE = "assets/content/vehicles/snowmobiles/snowmobile.prefab";
        private const string PREFAB_SNOWMOBILE_TOMAHA = "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab";

        // Train Engine
        private const string PREFAB_TRAINENGINE = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
        private const string PREFAB_TRAINENGINE_COVERED = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
        private const string PREFAB_TRAINENGINE_LOCOMOTIVE = "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab";

        // Train Car
        private const string PREFAB_TRAINWAGON_A = "assets/content/vehicles/trains/wagons/trainwagona.entity.prefab";
        private const string PREFAB_TRAINWAGON_B = "assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab";
        private const string PREFAB_TRAINWAGON_C = "assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab";
        private const string PREFAB_TRAINWAGON_UNLOADABLE = "assets/content/vehicles/trains/wagons/trainwagonunloadable.entity.prefab";
        private const string PREFAB_TRAINWAGON_UNLOADABLE_FUEL = "assets/content/vehicles/trains/wagons/trainwagonunloadablefuel.entity.prefab";
        private const string PREFAB_TRAINWAGON_UNLOADABLE_LOOT = "assets/content/vehicles/trains/wagons/trainwagonunloadableloot.entity.prefab";
        private const string PREFAB_CABOOSE = "assets/content/vehicles/trains/caboose/traincaboose.entity.prefab";

        // Defaults for Vehicle Modifications
        private readonly float TUGBOAT_ENGINETHRUST = 200000f;
        private readonly float HELICOPTER_LIFT = 0.25f;
        private readonly Vector3 SCRAP_HELICOPTER_TORQUE = new Vector3(8000.0f, 8000.0f, 4000.0f);
        private readonly Vector3 MINICOPTER_TORQUE = new Vector3(400.0f, 400.0f, 200.0f);
        private readonly Vector3 ATTACK_HELICOPTER_TORQUE = new Vector3(8000.0f, 8000.0f, 5200.0f);

        private const int LAYER_GROUND = Layers.Solid | Layers.Mask.Water;

        private readonly object _false = false;
        private bool finishedLoading = false;

        public static VehicleLicence Instance { get; private set; }

        public readonly Dictionary<BaseEntity, Vehicle> vehiclesCache = new Dictionary<BaseEntity, Vehicle>();
        public readonly Dictionary<string, BaseVehicleSettings> allVehicleSettings = new Dictionary<string, BaseVehicleSettings>();
        public readonly Dictionary<string, string> commandToVehicleType = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        
        public enum NormalVehicleType
        {
            Tugboat,
            Rowboat,
            RHIB,
            Sedan,
            HotAirBalloon,
            ArmoredHotAirBalloon,
            MiniCopter,
            AttackHelicopter,
            TransportHelicopter,
            Chinook,
            RidableHorse,
            WorkCart,
            SedanRail,
            MagnetCrane,
            SubmarineSolo,
            SubmarineDuo,
            Snowmobile,
            TomahaSnowmobile,
            Kayak,
            PedalBike,
            PedalTrike,
            MotorBike,
            MotorBike_SideCar,
        }

        public enum CustomVehicleType
        {
            ATV,
            RaceSofa,
            WaterBird,
            WarBird,
            LittleBird,
            Fighter,
            OldFighter,
            FighterBus,
            WarBus,
            AirBus,
            PatrolHeli,
            RustWing,
            RustWingDetailed,
            RustWingDetailedOld,
            TinFighter,
            TinFighterDetailed,
            TinFighterDetailedOld,
            MarsFighter,
            MarsFighterDetailed,
            SkyPlane,
            SkyBoat,
            TwistedTruck,
            TrainWreck,
            TrainWrecker,
            Santa,
            WarSanta,
            Witch,
            MagicCarpet,
            Ah69t,
            Ah69r,
            Ah69a,
            Mavik,
            HeavyFighter,
            PorcelainCommander,
            DuneBuggie,
            DuneTruckArmed,
            DuneTruckUnArmed,
            DoomsDayDiscoVan,
            ForkLift,
            LawnMower,
            Chariot,
            SoulHarvester
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum ChassisType
        {
            Small,
            Medium,
            Large
        }

        [JsonConverter(typeof(StringEnumConverter))]
        public enum TrainComponentType
        {
            Engine,
            CoveredEngine,
            Locomotive,
            WagonA,
            WagonB,
            WagonC,
            Unloadable,
            UnloadableLoot,
            UnloadableFuel,
            Caboose,
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            Instance = this;
            permission.RegisterPermission(PERMISSION_USE, this);
            permission.RegisterPermission(PERMISSION_ALL, this);
            permission.RegisterPermission(PERMISSION_ADMIN, this);
            permission.RegisterPermission(PERMISSION_BYPASS_COST, this);
            permission.RegisterPermission(PERMISSION_NO_DAMAGE, this);
            permission.RegisterPermission(PERMISSION_NO_COLLISION_DAMAGE, this);

            bool useCustomVehicles = configData.global.useCustomVehicles;
            if(useCustomVehicles && configData.customVehicles == null)
            {
                configData.customVehicles = new CustomVehicleSettings();
                SaveConfig();
            }
            
            if(useCustomVehicles)
            {
                foreach (NormalVehicleType value in Enum.GetValues(typeof(NormalVehicleType)))
                {
                    allVehicleSettings.Add(value.ToString(), GetBaseVehicleSettings(value));
                }
                
                foreach (CustomVehicleType value in Enum.GetValues(typeof(CustomVehicleType)))
                {
                    allVehicleSettings.Add(value.ToString(), GetCustomVehicleSettings(value));
                }
            }
            else
            {
                foreach (NormalVehicleType value in Enum.GetValues(typeof(NormalVehicleType)))
                {
                    allVehicleSettings.Add(value.ToString(), GetBaseVehicleSettings(value));
                }
            }
            
            foreach (var entry in configData.modularVehicles)
            {
                allVehicleSettings.Add(entry.Key, entry.Value);
            }
            foreach (var entry in configData.trainVehicles)
            {
                allVehicleSettings.Add(entry.Key, entry.Value);
            }
            foreach (var entry in allVehicleSettings)
            {
                BaseVehicleSettings settings = entry.Value;
                
                if (settings.UsePermission && !string.IsNullOrEmpty(settings.Permission))
                {
                    if (!permission.PermissionExists(settings.Permission, this))
                    {
                        permission.RegisterPermission(settings.Permission, this);
                    }
                }

                if (settings.UsePermission && !string.IsNullOrEmpty(settings.BypassCostPermission))
                {
                    if (!permission.PermissionExists(settings.BypassCostPermission, this))
                    {
                        permission.RegisterPermission(settings.BypassCostPermission, this);
                    }
                }

                foreach (var perm in settings.CooldownPermissions.Keys)
                {
                    if (!permission.PermissionExists(perm, this))
                    {
                        permission.RegisterPermission(perm, this);
                    }
                }

                foreach (var command in settings.Commands)
                {
                    if (string.IsNullOrEmpty(command))
                    {
                        continue;
                    }
                    if (!commandToVehicleType.ContainsKey(command))
                    {
                        commandToVehicleType.Add(command, entry.Key);
                    }
                    else
                    {
                        PrintError($"You have the same two commands({command}).");
                    }
                    if (configData.chat.useUniversalCommand)
                    {
                        cmd.AddChatCommand(command, this, nameof(CmdUniversal));
                    }
                    if (!string.IsNullOrEmpty(configData.chat.customKillCommandPrefix))
                    {
                        cmd.AddChatCommand(configData.chat.customKillCommandPrefix + command, this, nameof(CmdCustomKill));
                    }
                }
            }

            cmd.AddChatCommand(configData.chat.helpCommand, this, nameof(CmdLicenseHelp));
            cmd.AddChatCommand(configData.chat.buyCommand, this, nameof(CmdBuyVehicle));
            cmd.AddChatCommand(configData.chat.spawnCommand, this, nameof(CmdSpawnVehicle));
            cmd.AddChatCommand(configData.chat.recallCommand, this, nameof(CmdRecallVehicle));
            cmd.AddChatCommand(configData.chat.killCommand, this, nameof(CmdKillVehicle));

            Unsubscribe(nameof(CanMountEntity));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnEntityDismounted));
            Unsubscribe(nameof(OnEntityEnter));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnRidableAnimalClaimed));
            Unsubscribe(nameof(OnEngineStarted));
            Unsubscribe(nameof(OnVehiclePush));
        }

        private void OnServerInitialized()
        {
            ServerMgr.Instance.StartCoroutine(UpdatePlayerData(TimeEx.currentTimestamp));
            if (configData.global.preventMounting)
            {
                Subscribe(nameof(CanMountEntity));
            }
            if (configData.global.noDecay)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }
            if (configData.global.preventDamagePlayer || configData.global.safeTrainDismount || configData.global.preventDamageNPCs)
            {
                Subscribe(nameof(OnEntityEnter));
            }
            if (configData.global.preventLooting)
            {
                Subscribe(nameof(CanLootEntity));
            }
            if (configData.global.autoClaimFromVendor)
            {
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(OnRidableAnimalClaimed));
            }
            if (configData.global.checkVehiclesInterval > 0 && allVehicleSettings.Any(x => x.Value.WipeTime > 0))
            {
                Subscribe(nameof(OnEntityDismounted));
                timer.Every(configData.global.checkVehiclesInterval, CheckVehicles);
            }
            else if (configData.normalVehicles.miniCopter.flyHackPause > 0 || configData.normalVehicles.transportHelicopter.flyHackPause > 0 || configData.normalVehicles.attackHelicopter.flyHackPause > 0)
            {
                Subscribe(nameof(OnEntityDismounted));
            }
            if (configData.normalVehicles.miniCopter.instantTakeoff || configData.normalVehicles.attackHelicopter.instantTakeoff
                 || configData.normalVehicles.transportHelicopter.instantTakeoff)
            {
                Subscribe(nameof(OnEngineStarted));
            }
            if (configData.global.preventPushing)
            {
                Subscribe(nameof(OnVehiclePush));
            }
        }

        private void Unload()
        {
            if (!configData.global.storeVehicle)
            {
                foreach (var entry in vehiclesCache)
                {
                    if (entry.Key != null && !entry.Key.IsDestroyed)
                    {
                        RefundVehicleItems(entry.Value, isUnload: true);
                        entry.Key.Kill(BaseNetworkable.DestroyMode.Gib);
                    }
                    entry.Value.EntityId = 0;
                }
            }
            SaveData();
            Instance = null;
        }

        private void OnServerSave()
        {
            timer.Once(Random.Range(0f, 60f), SaveData);
        }

        private void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null)
            {
                return;
            }
            if (player != null)
            {
                BaseEntity vehicleEntity = entity.GetParentEntity();
                if (configData.normalVehicles.miniCopter.flyHackPause > 0 && vehicleEntity is Minicopter)
                {
                    player.PauseFlyHackDetection(configData.normalVehicles.miniCopter.flyHackPause);
                }
                else if (configData.normalVehicles.transportHelicopter.flyHackPause > 0 && vehicleEntity is ScrapTransportHelicopter)
                {
                    player.PauseFlyHackDetection(configData.normalVehicles.transportHelicopter.flyHackPause);
                }
                else if (configData.normalVehicles.attackHelicopter.flyHackPause > 0 && vehicleEntity is AttackHelicopter)
                {
                    player.PauseFlyHackDetection(configData.normalVehicles.attackHelicopter.flyHackPause);
                }
            }
            var vehicleParent = entity.VehicleParent();
            if (vehicleParent == null || vehicleParent.IsDestroyed)
            {
                return;
            }
            Vehicle vehicle;
            if (!vehiclesCache.TryGetValue(vehicleParent, out vehicle))
            {
                return;
            }
            vehicle.OnDismount();
        }

        // TODO: Fix/finish
        private void OnEngineStarted(BaseMountable entity, BasePlayer player)
        {
            if (player == null || entity == null) return;

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;
            BaseVehicle mounted = player.GetMountedVehicle();
            // Only allows vehicles spawned with the plugin to use instant take off.
            if (mounted == null || !vehiclesCache.ContainsKey(mounted)) return;

            PlayerHelicopter heli = mounted as PlayerHelicopter;

            NextTick(() =>
            {
                if (heli == null) return;

                if (configData.normalVehicles.miniCopter.instantTakeoff && heli is Minicopter)
                {
                    heli.engineController.FinishStartingEngine();
                    return;
                }

                if (configData.normalVehicles.attackHelicopter.instantTakeoff && heli is AttackHelicopter)
                {
                    heli.engineController.FinishStartingEngine();
                }

                if (configData.normalVehicles.transportHelicopter.instantTakeoff && heli is ScrapTransportHelicopter)
                {
                    heli.engineController.FinishStartingEngine();
                }
            });
        }

        private object OnVehiclePush(BaseVehicle vehicle, BasePlayer player)
        {
            if (vehicle == null || player == null) return null;
            if (!vehiclesCache.TryGetValue(vehicle, out Vehicle foundVehicle)) return null;
            // ulong userID = player.userID.Get();
            //
            // if (foundVehicle.PlayerId == userID || AreFriends(foundVehicle.PlayerId, player.userID)) return null;
            // if (HasAdminPermission(player)) return null;
            
            // Respond here
            SendCantPushMessage(player, foundVehicle);
            return true;
        }

        #region Mount

        private object CanMountEntity(BasePlayer friend, BaseMountable entity)
        {
            if (friend == null || entity == null)
            {
                return null;
            }
            var vehicleParent = entity.VehicleParent();
            if (vehicleParent == null || vehicleParent.IsDestroyed)
            {
                return null;
            }
            Vehicle vehicle;
            if (!vehiclesCache.TryGetValue(vehicleParent, out vehicle))
            {
                return null;
            }
            if (AreFriends(vehicle.PlayerId, friend.userID))
            {
                return null;
            }
            if (configData.global.preventDriverSeat && vehicleParent.HasMountPoints())
            {
                foreach (var mountPointInfo in vehicleParent.allMountPoints)
                {
                    if (mountPointInfo == null || mountPointInfo.mountable != entity) continue;
                    if (!mountPointInfo.isDriver)
                    {
                        return null;
                    }
                    break;
                }
            }
            if (HasAdminPermission(friend))
            {
                return null;
            }
            SendCantUseMessage(friend, vehicle);
            return _false;
        }

        #endregion Mount

        #region Loot

        private object CanLootEntity(BasePlayer friend, RidableHorse2 horse)
        {
            if (friend == null || horse == null)
            {
                return null;
            }
            return CanLootEntityInternal(friend, horse);
        }

        private object CanLootEntity(BasePlayer friend, StorageContainer container)
        {
            if (friend == null || container == null) return null;

            var parentEntity = container.GetParentEntity();

            if (parentEntity == null) return null;

            return CanLootEntityInternal(friend, parentEntity);
        }

        private object CanLootEntityInternal(BasePlayer friend, BaseEntity parentEntity)
        {
            Vehicle vehicle;
            if (!TryGetVehicle(parentEntity, out vehicle))
            {
                return null;
            }

            if (AreFriends(vehicle.PlayerId, friend.userID)) return null;

            if (HasAdminPermission(friend)) return null;

            SendCantUseMessage(friend, vehicle);
            return _false;
        }

        #endregion Loot

        #region Decay

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo?.damageTypes == null)
            {
                return;
            }
            Vehicle vehicle;
            if (!TryGetVehicle(entity, out vehicle))
            {
                return;
            }
            if (permission.UserHasPermission(vehicle.PlayerId.ToString(), PERMISSION_NO_DAMAGE) && GetBaseVehicleDamage(vehicle.VehicleType))
            {
                hitInfo.damageTypes.ScaleAll(0);
                return;
            }
            if (hitInfo.damageTypes.Has(DamageType.Collision) && permission.UserHasPermission(vehicle.PlayerId.ToString(), PERMISSION_NO_COLLISION_DAMAGE) && GetBaseVehicleCollisionDamage(vehicle.VehicleType))
            {
                hitInfo.damageTypes.Scale(DamageType.Collision, 0);
                return;
            }
            if (!hitInfo.damageTypes.Has(DamageType.Decay)) return;
            hitInfo.damageTypes.Scale(DamageType.Decay, 0);
        }

        #endregion Decay

        #region Claim

        private void OnEntitySpawned(Tugboat tugboat)
        {
            TryClaimVehicle(tugboat);
        }

        private void OnEntitySpawned(BaseSubmarine baseSubmarine)
        {
            TryClaimVehicle(baseSubmarine);
        }

        private void OnEntitySpawned(MotorRowboat motorRowboat)
        {
            TryClaimVehicle(motorRowboat);
        }

        private void OnEntitySpawned(Minicopter miniCopter)
        {
            TryClaimVehicle(miniCopter);
        }

        private void OnEntitySpawned(AttackHelicopter attackHelicopter)
        {
            TryClaimVehicle(attackHelicopter);
        }

        private void OnRidableAnimalClaimed(BaseRidableAnimal ridableAnimal, BasePlayer player)
        {
            TryClaimVehicle(ridableAnimal, player);
        }

        #endregion Claim

        #region Damage

        // ScrapTransportHelicopter / ModularCar / TrainEngine / MagnetCrane
        private object OnEntityEnter(TriggerHurtNotChild triggerHurtNotChild, BasePlayer player)
        {
            if (triggerHurtNotChild == null || player == null || triggerHurtNotChild.SourceEntity == null)
            {
                return null;
            }
            var sourceEntity = triggerHurtNotChild.SourceEntity;

            if (!vehiclesCache.ContainsKey(sourceEntity) || (!configData.global.preventDamageNPCs && !player.userID.IsSteamId())) return null;

            var baseVehicle = sourceEntity as BaseVehicle;

            if ((baseVehicle == null || player.userID.IsSteamId()) && configData.global.preventDamagePlayer) return _false;

            if (configData.global.preventDamageNPCs && !player.userID.IsSteamId()) return _false;

            if (baseVehicle is TrainEngine)
            {
                if (!configData.global.safeTrainDismount && configData.global.preventDamagePlayer && player.userID.IsSteamId()) return _false;

                if (!configData.global.safeTrainDismount) return null;

                var transform = triggerHurtNotChild.transform;
                MoveToPosition(player, transform.position + (Random.value >= 0.5f ? -transform.right : transform.right) * 2.5f);

                return configData.global.preventDamagePlayer ? _false : null;
            }

            if (!configData.global.preventDamagePlayer) return null;

            Vector3 pos;
            if (GetDismountPosition(baseVehicle, player, out pos))
            {
                MoveToPosition(player, pos);
            }
            //triggerHurtNotChild.enabled = false;
            return _false;
        }

        // HotAirBalloon
        private object OnEntityEnter(TriggerHurt triggerHurt, BasePlayer player)
        {
            if (triggerHurt == null || player == null)
            {
                return null;
            }
            var sourceEntity = triggerHurt.gameObject.ToBaseEntity();
            if (sourceEntity == null || !vehiclesCache.ContainsKey(sourceEntity)) return null;

            if (configData.global.preventDamagePlayer && player.userID.IsSteamId()
                || (configData.global.preventDamageNPCs && !player.userID.IsSteamId()))
            {
                MoveToPosition(player, sourceEntity.CenterPoint() + Vector3.down);
                //triggerHurt.enabled = false;
                return _false;
            }
            return null;
        }

        #endregion Damage

        #region Destroy

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            OnEntityDeathOrKill(entity, true);
        }

        private void OnEntityKill(BaseCombatEntity entity)
        {
            OnEntityDeathOrKill(entity);
        }

        #endregion Destroy

        #region Reskin

        private object OnEntityReskin(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            if (entity == null || player == null)
            {
                return null;
            }
            Vehicle vehicle;
            if (TryGetVehicle(entity, out vehicle))
            {
                return _false;
            }
            return null;
        }

        #endregion Reskin

        #endregion Oxide Hooks

        #region Methods

        #region Message

        private void SendCantUseMessage(BasePlayer friend, Vehicle vehicle)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            if (settings != null)
            {
                var player = RustCore.FindPlayerById(vehicle.PlayerId);
                var playerName = player?.displayName ?? ServerMgr.Instance.persistance.GetPlayerName(vehicle.PlayerId) ?? "Unknown";
                Print(friend, Lang("CantUse", friend.UserIDString, settings.DisplayName, $"<color=#{(player != null && player.IsConnected ? "69D214" : "FF6347")}>{playerName}</color>"));
            }
        }

        private void SendCantPushMessage(BasePlayer friend, Vehicle vehicle)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            if (settings == null) return;
            
            var player = RustCore.FindPlayerById(vehicle.PlayerId);
            var playerName = player?.displayName ?? ServerMgr.Instance.persistance.GetPlayerName(vehicle.PlayerId) ?? "Unknown";
            Print(friend, Lang("CantPush", friend.UserIDString, settings.DisplayName, $"<color=#{(player != null && player.IsConnected ? "69D214" : "FF6347")}>{playerName}</color>"));
        }

        #endregion Message

        #region CheckEntity

        private void OnEntityDeathOrKill(BaseCombatEntity entity, bool isCrash = false)
        {
            if (entity == null)
            {
                return;
            }
            Vehicle vehicle;
            if (!vehiclesCache.TryGetValue(entity, out vehicle))
            {
                return;
            }

            RefundVehicleItems(vehicle, isCrash);

            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            if (isCrash && settings.RemoveLicenseOnceCrash)
            {
                RemoveVehicleLicense(vehicle.PlayerId, vehicle.VehicleType);
            }

            vehicle.OnDeath();
            vehiclesCache.Remove(entity);
        }

        #endregion CheckEntity

        #region CheckVehicles

        private void CheckVehicles()
        {
            var currentTimestamp = TimeEx.currentTimestamp;
            foreach (var entry in vehiclesCache.ToArray())
            {
                if (entry.Key == null || entry.Key.IsDestroyed)
                {
                    continue;
                }
                if (VehicleIsActive(entry.Key, entry.Value, currentTimestamp))
                {
                    continue;
                }

                if (VehicleAnyMounted(entry.Key))
                {
                    continue;
                }
                entry.Key.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        private bool VehicleIsActive(BaseEntity entity, Vehicle vehicle, double currentTimestamp)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            if (settings.WipeTime <= 0)
            {
                return true;
            }
            if (settings.ExcludeCupboard && entity.GetBuildingPrivilege() != null)
            {
                return true;
            }
            return currentTimestamp - vehicle.LastDismount < settings.WipeTime;
        }

        #endregion CheckVehicles

        #region Refund

        private void RefundVehicleItems(Vehicle vehicle, bool isCrash = false, bool isUnload = false)
        {
            var entity = vehicle.Entity;
            if (entity == null || entity.IsDestroyed)
            {
                return;
            }

            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            settings.RefundVehicleItems(vehicle, isCrash, isUnload);
        }

        private static void DropItemContainer(BaseEntity entity, ulong playerId, List<Item> collect)
        {
            var droppedItemContainer = GameManager.server.CreateEntity(PREFAB_ITEM_DROP, entity.GetDropPosition(), entity.transform.rotation) as DroppedItemContainer;
            if (droppedItemContainer != null)
            {
                droppedItemContainer.inventory = new ItemContainer();
                droppedItemContainer.inventory.ServerInitialize(null, Mathf.Min(collect.Count, droppedItemContainer.maxItemCount));
                droppedItemContainer.inventory.GiveUID();
                droppedItemContainer.inventory.entityOwner = droppedItemContainer;
                droppedItemContainer.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);
                for (var i = collect.Count - 1; i >= 0; i--)
                {
                    var item = collect[i];
                    if (!item.MoveToContainer(droppedItemContainer.inventory))
                    {
                        item.DropAndTossUpwards(droppedItemContainer.transform.position);
                    }
                }

                droppedItemContainer.OwnerID = playerId;
                droppedItemContainer.Spawn();
            }
        }

        #endregion Refund

        #region TryPay

        private bool TryPay(BasePlayer player, BaseVehicleSettings settings, Dictionary<string, PriceInfo> prices, out string resources)
        {
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_BYPASS_COST) || permission.UserHasPermission(player.UserIDString, settings.BypassCostPermission))
            {
                resources = null;
                return true;
            }

            if (!CanPay(player, prices, out resources))
            {
                return false;
            }

            var collect = Pool.Get<List<Item>>();
            foreach (var entry in prices)
            {
                if (entry.Value.amount <= 0)
                {
                    continue;
                }
                var itemDefinition = ItemManager.FindItemDefinition(entry.Key);
                if (itemDefinition != null)
                {
                    player.inventory.Take(collect, itemDefinition.itemid, entry.Value.amount);
                    player.Command("note.inv", itemDefinition.itemid, -entry.Value.amount);
                    continue;
                }
                switch (entry.Key.ToLower())
                {
                    case "economics":
                        Economics?.Call("Withdraw", player.userID.Get(), (double)entry.Value.amount);
                        continue;

                    case "serverrewards":
                        ServerRewards?.Call("TakePoints", player.userID.Get(), entry.Value.amount);
                        continue;
                }
            }

            foreach (var item in collect)
            {
                item.Remove();
            }
            Pool.FreeUnmanaged(ref collect);
            resources = null;
            return true;
        }

        private bool CanPay(BasePlayer player, Dictionary<string, PriceInfo> prices, out string resources)
        {
            var entries = new Hash<string, int>();
            var language = RustTranslationAPI != null ? lang.GetLanguage(player.UserIDString) : null;
            foreach (var entry in prices)
            {
                if (entry.Value.amount <= 0)
                {
                    continue;
                }
                int missingAmount;
                var itemDefinition = ItemManager.FindItemDefinition(entry.Key);
                if (itemDefinition != null)
                {
                    missingAmount = entry.Value.amount - player.inventory.GetAmount(itemDefinition.itemid);
                }
                else
                {
                    missingAmount = CheckBalance(entry.Key, entry.Value.amount, player.userID.Get());
                }

                if (missingAmount <= 0)
                {
                    continue;
                }
                var displayName = GetItemDisplayName(language, entry.Key, entry.Value.displayName);
                entries[displayName] += missingAmount;
            }
            if (entries.Count > 0)
            {
                var stringBuilder = new StringBuilder();
                foreach (var entry in entries)
                {
                    stringBuilder.AppendLine($"* {Lang("PriceFormat", player.UserIDString, entry.Key, entry.Value)}");
                }
                resources = stringBuilder.ToString();
                return false;
            }
            resources = null;
            return true;
        }

        private int CheckBalance(string key, int price, ulong playerId)
        {
            switch (key.ToLower())
            {
                case "economics":
                    var balance = Economics?.Call("Balance", playerId);
                    if (balance is double)
                    {
                        var n = price - (double)balance;
                        return n <= 0 ? 0 : (int)Math.Ceiling(n);
                    }
                    return price;

                case "serverrewards":
                    var points = ServerRewards?.Call("CheckPoints", playerId);
                    if (points is int)
                    {
                        var n = price - (int)points;
                        return n <= 0 ? 0 : n;
                    }
                    return price;

                default:
                    PrintError($"Unknown Currency Type '{key}'");
                    return price;
            }
        }

        #endregion TryPay

        #region AreFriends

        private bool AreFriends(ulong playerId, ulong friendId)
        {
            if (playerId == friendId)
            {
                return true;
            }
            if (configData.global.useTeams && SameTeam(playerId, friendId))
            {
                return true;
            }

            if (configData.global.useFriends && HasFriend(playerId, friendId))
            {
                return true;
            }
            if (configData.global.useClans && SameClan(playerId, friendId))
            {
                return true;
            }
            return false;
        }

        private static bool SameTeam(ulong playerId, ulong friendId)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            if (playerTeam == null)
            {
                return false;
            }
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendId);
            if (friendTeam == null)
            {
                return false;
            }
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerId, ulong friendId)
        {
            if (Friends == null)
            {
                return false;
            }
            return (bool)Friends.Call("HasFriend", playerId, friendId);
        }

        private bool SameClan(ulong playerId, ulong friendId)
        {
            if (Clans == null)
            {
                return false;
            }
            //Clans
            var isMember = Clans.Call("IsClanMember", playerId.ToString(), friendId.ToString());
            if (isMember != null)
            {
                return (bool)isMember;
            }
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerId);
            if (playerClan == null)
            {
                return false;
            }
            var friendClan = Clans.Call("GetClanOf", friendId);
            if (friendClan == null)
            {
                return false;
            }
            return playerClan == friendClan;
        }

        #endregion AreFriends

        #region IsPlayerBlocked

        private bool IsPlayerBlocked(BasePlayer player)
        {
            if (NoEscape == null)
            {
                return false;
            }
            if (configData.global.useRaidBlocker && IsRaidBlocked(player.UserIDString))
            {
                Print(player, Lang("RaidBlocked", player.UserIDString));
                return true;
            }
            if (configData.global.useCombatBlocker && IsCombatBlocked(player.UserIDString))
            {
                Print(player, Lang("CombatBlocked", player.UserIDString));
                return true;
            }
            return false;
        }

        private bool IsRaidBlocked(string playerId)
        {
            return (bool)NoEscape.Call("IsRaidBlocked", playerId);
        }

        private bool IsCombatBlocked(string playerId)
        {
            return (bool)NoEscape.Call("IsCombatBlocked", playerId);
        }

        private bool InZone(BasePlayer player)
        {
            if (ZoneManager == null || !ZoneManager.IsLoaded) return false;
            return configData.AntiSpawnZones.Any(x => (bool)ZoneManager?.Call("PlayerHasFlag", player, x.ToLower()));
        }

        #endregion IsPlayerBlocked

        #region GetSettings

        private BaseVehicleSettings GetBaseVehicleSettings(string vehicleType)
        {
            BaseVehicleSettings settings;
            return allVehicleSettings.TryGetValue(vehicleType, out settings) ? settings : null;
        }

        private BaseVehicleSettings GetBaseVehicleSettings(NormalVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case NormalVehicleType.Tugboat:
                    return configData.normalVehicles.tugboat;
                case NormalVehicleType.Rowboat:
                    return configData.normalVehicles.rowboat;
                case NormalVehicleType.RHIB:
                    return configData.normalVehicles.rhib;
                case NormalVehicleType.Sedan:
                    return configData.normalVehicles.sedan;
                case NormalVehicleType.HotAirBalloon:
                    return configData.normalVehicles.hotAirBalloon;
                case NormalVehicleType.ArmoredHotAirBalloon:
                    return configData.normalVehicles.armoredHotAirBalloon;
                case NormalVehicleType.MiniCopter:
                    return configData.normalVehicles.miniCopter;
                case NormalVehicleType.AttackHelicopter:
                    return configData.normalVehicles.attackHelicopter;
                case NormalVehicleType.TransportHelicopter:
                    return configData.normalVehicles.transportHelicopter;
                case NormalVehicleType.Chinook:
                    return configData.normalVehicles.chinook;
                case NormalVehicleType.RidableHorse:
                    return configData.normalVehicles.ridableHorse;
                case NormalVehicleType.WorkCart:
                    return configData.normalVehicles.workCart;
                case NormalVehicleType.SedanRail:
                    return configData.normalVehicles.sedanRail;
                case NormalVehicleType.MagnetCrane:
                    return configData.normalVehicles.magnetCrane;
                case NormalVehicleType.SubmarineSolo:
                    return configData.normalVehicles.submarineSolo;
                case NormalVehicleType.SubmarineDuo:
                    return configData.normalVehicles.submarineDuo;
                case NormalVehicleType.Snowmobile:
                    return configData.normalVehicles.snowmobile;
                case NormalVehicleType.TomahaSnowmobile:
                    return configData.normalVehicles.tomahaSnowmobile;
                case NormalVehicleType.PedalBike:
                    return configData.normalVehicles.pedalBike;
                case NormalVehicleType.PedalTrike:
                    return configData.normalVehicles.pedalTrike;
                case NormalVehicleType.MotorBike:
                    return configData.normalVehicles.motorBike;
                case NormalVehicleType.MotorBike_SideCar:
                    return configData.normalVehicles.motorBikeSidecar;
                case NormalVehicleType.Kayak:
                    return configData.normalVehicles.Kayak;
                default:
                    return null;
            }
        }

        private BaseVehicleSettings GetCustomVehicleSettings(CustomVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case CustomVehicleType.ATV:
                    return configData.customVehicles.atv;
                case CustomVehicleType.RaceSofa:
                    return configData.customVehicles.raceSofa;
                case CustomVehicleType.WaterBird:
                    return configData.customVehicles.waterBird;
                case CustomVehicleType.WarBird:
                    return configData.customVehicles.warBird;
                case CustomVehicleType.LittleBird:
                    return configData.customVehicles.littleBird;
                case CustomVehicleType.Fighter:
                    return configData.customVehicles.fighter;
                case CustomVehicleType.OldFighter:
                    return configData.customVehicles.oldFighter;
                case CustomVehicleType.FighterBus:
                    return configData.customVehicles.fighterBus;
                case CustomVehicleType.WarBus:
                    return configData.customVehicles.warBus;
                case CustomVehicleType.AirBus:
                    return configData.customVehicles.airBus;
                case CustomVehicleType.PatrolHeli:
                    return configData.customVehicles.patrolHeli;
                case CustomVehicleType.RustWing:
                    return configData.customVehicles.rustWing;
                case CustomVehicleType.RustWingDetailed:
                    return configData.customVehicles.rustWingDetailed;
                case CustomVehicleType.RustWingDetailedOld:
                    return configData.customVehicles.rustWingDetailedOld;
                case CustomVehicleType.TinFighter:
                    return configData.customVehicles.tinFighter;
                case CustomVehicleType.TinFighterDetailed:
                    return configData.customVehicles.tinFighterDetailed;
                case CustomVehicleType.TinFighterDetailedOld:
                    return configData.customVehicles.tinFighterDetailedOld;
                case CustomVehicleType.MarsFighter:
                    return configData.customVehicles.marsFighter;
                case CustomVehicleType.MarsFighterDetailed:
                    return configData.customVehicles.marsFighterDetailed;
                case CustomVehicleType.SkyPlane:
                    return configData.customVehicles.skyPlane;
                case CustomVehicleType.SkyBoat:
                    return configData.customVehicles.skyBoat;
                case CustomVehicleType.TwistedTruck:
                    return configData.customVehicles.twistedTruck;
                case CustomVehicleType.TrainWreck:
                    return configData.customVehicles.trainWreck;
                case CustomVehicleType.TrainWrecker:
                    return configData.customVehicles.trainWrecker;
                case CustomVehicleType.Santa:
                    return configData.customVehicles.santa;
                case CustomVehicleType.WarSanta:
                    return configData.customVehicles.warSanta;
                case CustomVehicleType.Witch:
                    return configData.customVehicles.witch;
                case CustomVehicleType.MagicCarpet:
                    return configData.customVehicles.magicCarpet;
                case CustomVehicleType.Ah69t:
                    return configData.customVehicles.ah69t;
                case CustomVehicleType.Ah69r:
                    return configData.customVehicles.ah69r;
                case CustomVehicleType.Ah69a:
                    return configData.customVehicles.ah69a;
                case CustomVehicleType.Mavik:
                    return configData.customVehicles.mavik;
                case CustomVehicleType.HeavyFighter:
                    return configData.customVehicles.heavyFighter;
                case CustomVehicleType.PorcelainCommander:
                    return configData.customVehicles.porcelainCommander;
                case CustomVehicleType.DuneBuggie:
                    return configData.customVehicles.duneBuggie;
                case CustomVehicleType.DuneTruckArmed:
                    return configData.customVehicles.duneTruckArmed;
                case CustomVehicleType.DuneTruckUnArmed:
                    return configData.customVehicles.duneTruckUnArmed;
                case CustomVehicleType.DoomsDayDiscoVan:
                    return configData.customVehicles.doomsDayDiscoVan;
                case CustomVehicleType.ForkLift:
                    return configData.customVehicles.forkLift;
                case CustomVehicleType.LawnMower:
                    return configData.customVehicles.lawnMower;
                case CustomVehicleType.Chariot:
                    return configData.customVehicles.chariot;
                case CustomVehicleType.SoulHarvester:
                    return configData.customVehicles.soulHarvester;
                default:
                    return null;
            }
        }

        private bool GetBaseVehicleCollisionDamage(string vehicleType)
        {
            BaseVehicleSettings settings;
            return allVehicleSettings.TryGetValue(vehicleType, out settings) && settings.NoCollisionDamage;
        }

        // private bool GetBaseVehicleCollisionDamage(string vehicleType)
        // {
        //     BaseVehicleSettings settings;
        //     return allVehicleSettings.TryGetValue(vehicleType, out settings) && settings.NoCollisionDamage;
        // }

        private bool GetBaseVehicleCollisionDamage(NormalVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case NormalVehicleType.Tugboat:
                    return configData.normalVehicles.tugboat.NoCollisionDamage;
                case NormalVehicleType.Rowboat:
                    return configData.normalVehicles.rowboat.NoCollisionDamage;
                case NormalVehicleType.RHIB:
                    return configData.normalVehicles.rhib.NoCollisionDamage;
                case NormalVehicleType.Sedan:
                    return configData.normalVehicles.sedan.NoCollisionDamage;
                case NormalVehicleType.HotAirBalloon:
                    return configData.normalVehicles.hotAirBalloon.NoCollisionDamage;
                case NormalVehicleType.ArmoredHotAirBalloon:
                    return configData.normalVehicles.armoredHotAirBalloon.NoCollisionDamage;
                case NormalVehicleType.MiniCopter:
                    return configData.normalVehicles.miniCopter.NoCollisionDamage;
                case NormalVehicleType.AttackHelicopter:
                    return configData.normalVehicles.attackHelicopter.NoCollisionDamage;
                case NormalVehicleType.TransportHelicopter:
                    return configData.normalVehicles.transportHelicopter.NoCollisionDamage;
                case NormalVehicleType.Chinook:
                    return configData.normalVehicles.chinook.NoCollisionDamage;
                case NormalVehicleType.RidableHorse:
                    return configData.normalVehicles.ridableHorse.NoCollisionDamage;
                case NormalVehicleType.WorkCart:
                    return configData.normalVehicles.workCart.NoCollisionDamage;
                case NormalVehicleType.SedanRail:
                    return configData.normalVehicles.sedanRail.NoCollisionDamage;
                case NormalVehicleType.MagnetCrane:
                    return configData.normalVehicles.magnetCrane.NoCollisionDamage;
                case NormalVehicleType.SubmarineSolo:
                    return configData.normalVehicles.submarineSolo.NoCollisionDamage;
                case NormalVehicleType.SubmarineDuo:
                    return configData.normalVehicles.submarineDuo.NoCollisionDamage;
                case NormalVehicleType.Snowmobile:
                    return configData.normalVehicles.snowmobile.NoCollisionDamage;
                case NormalVehicleType.TomahaSnowmobile:
                    return configData.normalVehicles.tomahaSnowmobile.NoCollisionDamage;
                case NormalVehicleType.PedalBike:
                    return configData.normalVehicles.pedalBike.NoCollisionDamage;
                case NormalVehicleType.PedalTrike:
                    return configData.normalVehicles.pedalTrike.NoCollisionDamage;
                case NormalVehicleType.MotorBike:
                    return configData.normalVehicles.motorBike.NoCollisionDamage;
                case NormalVehicleType.MotorBike_SideCar:
                    return configData.normalVehicles.motorBikeSidecar.NoCollisionDamage;
                case NormalVehicleType.Kayak:
                    return configData.normalVehicles.Kayak.NoCollisionDamage;
                default:
                    return false;
            }
        }

        private bool GetBaseVehicleCollisionDamage(CustomVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case CustomVehicleType.ATV:
                    return configData.customVehicles.atv.NoCollisionDamage;
                case CustomVehicleType.RaceSofa:
                    return configData.customVehicles.raceSofa.NoCollisionDamage;
                case CustomVehicleType.WaterBird:
                    return configData.customVehicles.waterBird.NoCollisionDamage;
                case CustomVehicleType.WarBird:
                    return configData.customVehicles.warBird.NoCollisionDamage;
                case CustomVehicleType.LittleBird:
                    return configData.customVehicles.littleBird.NoCollisionDamage;
                case CustomVehicleType.Fighter:
                    return configData.customVehicles.fighter.NoCollisionDamage;
                case CustomVehicleType.OldFighter:
                    return configData.customVehicles.oldFighter.NoCollisionDamage;
                case CustomVehicleType.FighterBus:
                    return configData.customVehicles.fighterBus.NoCollisionDamage;
                case CustomVehicleType.WarBus:
                    return configData.customVehicles.warBus.NoCollisionDamage;
                case CustomVehicleType.AirBus:
                    return configData.customVehicles.airBus.NoCollisionDamage;
                case CustomVehicleType.PatrolHeli:
                    return configData.customVehicles.patrolHeli.NoCollisionDamage;
                case CustomVehicleType.RustWing:
                    return configData.customVehicles.rustWing.NoCollisionDamage;
                case CustomVehicleType.RustWingDetailed:
                    return configData.customVehicles.rustWingDetailed.NoCollisionDamage;
                case CustomVehicleType.RustWingDetailedOld:
                    return configData.customVehicles.rustWingDetailedOld.NoCollisionDamage;
                case CustomVehicleType.TinFighter:
                    return configData.customVehicles.tinFighter.NoCollisionDamage;
                case CustomVehicleType.TinFighterDetailed:
                    return configData.customVehicles.tinFighterDetailed.NoCollisionDamage;
                case CustomVehicleType.TinFighterDetailedOld:
                    return configData.customVehicles.tinFighterDetailedOld.NoCollisionDamage;
                case CustomVehicleType.MarsFighter:
                    return configData.customVehicles.marsFighter.NoCollisionDamage;
                case CustomVehicleType.MarsFighterDetailed:
                    return configData.customVehicles.marsFighterDetailed.NoCollisionDamage;
                case CustomVehicleType.SkyPlane:
                    return configData.customVehicles.skyPlane.NoCollisionDamage;
                case CustomVehicleType.SkyBoat:
                    return configData.customVehicles.skyBoat.NoCollisionDamage;
                case CustomVehicleType.TwistedTruck:
                    return configData.customVehicles.twistedTruck.NoCollisionDamage;
                case CustomVehicleType.TrainWreck:
                    return configData.customVehicles.trainWreck.NoCollisionDamage;
                case CustomVehicleType.TrainWrecker:
                    return configData.customVehicles.trainWrecker.NoCollisionDamage;
                case CustomVehicleType.Santa:
                    return configData.customVehicles.santa.NoCollisionDamage;
                case CustomVehicleType.WarSanta:
                    return configData.customVehicles.warSanta.NoCollisionDamage;
                case CustomVehicleType.Witch:
                    return configData.customVehicles.witch.NoCollisionDamage;
                case CustomVehicleType.MagicCarpet:
                    return configData.customVehicles.magicCarpet.NoCollisionDamage;
                case CustomVehicleType.Ah69t:
                    return configData.customVehicles.ah69t.NoCollisionDamage;
                case CustomVehicleType.Ah69r:
                    return configData.customVehicles.ah69r.NoCollisionDamage;
                case CustomVehicleType.Ah69a:
                    return configData.customVehicles.ah69a.NoCollisionDamage;
                case CustomVehicleType.Mavik:
                    return configData.customVehicles.mavik.NoCollisionDamage;
                case CustomVehicleType.HeavyFighter:
                    return configData.customVehicles.heavyFighter.NoCollisionDamage;
                case CustomVehicleType.PorcelainCommander:
                    return configData.customVehicles.porcelainCommander.NoCollisionDamage;
                case CustomVehicleType.DuneBuggie:
                    return configData.customVehicles.duneBuggie.NoCollisionDamage;
                case CustomVehicleType.DuneTruckArmed:
                    return configData.customVehicles.duneTruckArmed.NoCollisionDamage;
                case CustomVehicleType.DuneTruckUnArmed:
                    return configData.customVehicles.duneTruckUnArmed.NoCollisionDamage;
                case CustomVehicleType.DoomsDayDiscoVan:
                    return configData.customVehicles.doomsDayDiscoVan.NoCollisionDamage;
                case CustomVehicleType.ForkLift:
                    return configData.customVehicles.forkLift.NoCollisionDamage;
                case CustomVehicleType.LawnMower:
                    return configData.customVehicles.lawnMower.NoCollisionDamage;
                case CustomVehicleType.Chariot:
                    return configData.customVehicles.chariot.NoCollisionDamage;
                case CustomVehicleType.SoulHarvester:
                    return configData.customVehicles.soulHarvester.NoCollisionDamage;
                default:
                    return false;
            }
        }

        private bool GetBaseVehicleDamage(string vehicleType)
        {
            BaseVehicleSettings settings;
            return allVehicleSettings.TryGetValue(vehicleType, out settings) && settings.NoDamage;
        }

        private bool GetBaseVehicleDamage(NormalVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case NormalVehicleType.Tugboat:
                    return configData.normalVehicles.tugboat.NoDamage;
                case NormalVehicleType.Rowboat:
                    return configData.normalVehicles.rowboat.NoDamage;
                case NormalVehicleType.RHIB:
                    return configData.normalVehicles.rhib.NoDamage;
                case NormalVehicleType.Sedan:
                    return configData.normalVehicles.sedan.NoDamage;
                case NormalVehicleType.HotAirBalloon:
                    return configData.normalVehicles.hotAirBalloon.NoDamage;
                case NormalVehicleType.ArmoredHotAirBalloon:
                    return configData.normalVehicles.armoredHotAirBalloon.NoDamage;
                case NormalVehicleType.MiniCopter:
                    return configData.normalVehicles.miniCopter.NoDamage;
                case NormalVehicleType.AttackHelicopter:
                    return configData.normalVehicles.attackHelicopter.NoDamage;
                case NormalVehicleType.TransportHelicopter:
                    return configData.normalVehicles.transportHelicopter.NoDamage;
                case NormalVehicleType.Chinook:
                    return configData.normalVehicles.chinook.NoDamage;
                case NormalVehicleType.RidableHorse:
                    return configData.normalVehicles.ridableHorse.NoDamage;
                case NormalVehicleType.WorkCart:
                    return configData.normalVehicles.workCart.NoDamage;
                case NormalVehicleType.SedanRail:
                    return configData.normalVehicles.sedanRail.NoDamage;
                case NormalVehicleType.MagnetCrane:
                    return configData.normalVehicles.magnetCrane.NoDamage;
                case NormalVehicleType.SubmarineSolo:
                    return configData.normalVehicles.submarineSolo.NoDamage;
                case NormalVehicleType.SubmarineDuo:
                    return configData.normalVehicles.submarineDuo.NoDamage;
                case NormalVehicleType.Snowmobile:
                    return configData.normalVehicles.snowmobile.NoDamage;
                case NormalVehicleType.TomahaSnowmobile:
                    return configData.normalVehicles.tomahaSnowmobile.NoDamage;
                case NormalVehicleType.PedalBike:
                    return configData.normalVehicles.pedalBike.NoDamage;
                case NormalVehicleType.PedalTrike:
                    return configData.normalVehicles.pedalTrike.NoDamage;
                case NormalVehicleType.MotorBike:
                    return configData.normalVehicles.motorBike.NoDamage;
                case NormalVehicleType.MotorBike_SideCar:
                    return configData.normalVehicles.motorBikeSidecar.NoDamage;
                case NormalVehicleType.Kayak:
                    return configData.normalVehicles.Kayak.NoDamage;
                default:
                    return false;
            }
        }

        private bool GetBaseVehicleDamage(CustomVehicleType normalVehicleType)
        {
            switch (normalVehicleType)
            {
                case CustomVehicleType.ATV:
                    return configData.customVehicles.atv.NoDamage;
                case CustomVehicleType.RaceSofa:
                    return configData.customVehicles.raceSofa.NoDamage;
                case CustomVehicleType.WaterBird:
                    return configData.customVehicles.waterBird.NoDamage;
                case CustomVehicleType.WarBird:
                    return configData.customVehicles.warBird.NoDamage;
                case CustomVehicleType.LittleBird:
                    return configData.customVehicles.littleBird.NoDamage;
                case CustomVehicleType.Fighter:
                    return configData.customVehicles.fighter.NoDamage;
                case CustomVehicleType.OldFighter:
                    return configData.customVehicles.oldFighter.NoDamage;
                case CustomVehicleType.FighterBus:
                    return configData.customVehicles.fighterBus.NoDamage;
                case CustomVehicleType.WarBus:
                    return configData.customVehicles.warBus.NoDamage;
                case CustomVehicleType.AirBus:
                    return configData.customVehicles.airBus.NoDamage;
                case CustomVehicleType.PatrolHeli:
                    return configData.customVehicles.patrolHeli.NoDamage;
                case CustomVehicleType.RustWing:
                    return configData.customVehicles.rustWing.NoDamage;
                case CustomVehicleType.RustWingDetailed:
                    return configData.customVehicles.rustWingDetailed.NoDamage;
                case CustomVehicleType.RustWingDetailedOld:
                    return configData.customVehicles.rustWingDetailedOld.NoDamage;
                case CustomVehicleType.TinFighter:
                    return configData.customVehicles.tinFighter.NoDamage;
                case CustomVehicleType.TinFighterDetailed:
                    return configData.customVehicles.tinFighterDetailed.NoDamage;
                case CustomVehicleType.TinFighterDetailedOld:
                    return configData.customVehicles.tinFighterDetailedOld.NoDamage;
                case CustomVehicleType.MarsFighter:
                    return configData.customVehicles.marsFighter.NoDamage;
                case CustomVehicleType.MarsFighterDetailed:
                    return configData.customVehicles.marsFighterDetailed.NoDamage;
                case CustomVehicleType.SkyPlane:
                    return configData.customVehicles.skyPlane.NoDamage;
                case CustomVehicleType.SkyBoat:
                    return configData.customVehicles.skyBoat.NoDamage;
                case CustomVehicleType.TwistedTruck:
                    return configData.customVehicles.twistedTruck.NoDamage;
                case CustomVehicleType.TrainWreck:
                    return configData.customVehicles.trainWrecker.NoDamage;
                case CustomVehicleType.Santa:
                    return configData.customVehicles.santa.NoDamage;
                case CustomVehicleType.WarSanta:
                    return configData.customVehicles.warSanta.NoDamage;
                case CustomVehicleType.Witch:
                    return configData.customVehicles.witch.NoDamage;
                case CustomVehicleType.MagicCarpet:
                    return configData.customVehicles.magicCarpet.NoDamage;
                case CustomVehicleType.Ah69t:
                    return configData.customVehicles.ah69t.NoDamage;
                case CustomVehicleType.Ah69r:
                    return configData.customVehicles.ah69r.NoDamage;
                case CustomVehicleType.Ah69a:
                    return configData.customVehicles.ah69a.NoDamage;
                case CustomVehicleType.Mavik:
                    return configData.customVehicles.mavik.NoDamage;
                case CustomVehicleType.HeavyFighter:
                    return configData.customVehicles.heavyFighter.NoDamage;
                case CustomVehicleType.PorcelainCommander:
                    return configData.customVehicles.porcelainCommander.NoDamage;
                case CustomVehicleType.DuneBuggie:
                    return configData.customVehicles.duneBuggie.NoDamage;
                case CustomVehicleType.DuneTruckArmed:
                    return configData.customVehicles.duneTruckArmed.NoDamage;
                case CustomVehicleType.DuneTruckUnArmed:
                    return configData.customVehicles.duneTruckUnArmed.NoDamage;
                case CustomVehicleType.DoomsDayDiscoVan:
                    return configData.customVehicles.doomsDayDiscoVan.NoDamage;
                case CustomVehicleType.ForkLift:
                    return configData.customVehicles.forkLift.NoDamage;
                case CustomVehicleType.LawnMower:
                    return configData.customVehicles.lawnMower.NoDamage;
                case CustomVehicleType.Chariot:
                    return configData.customVehicles.chariot.NoDamage;
                case CustomVehicleType.SoulHarvester:
                    return configData.customVehicles.soulHarvester.NoDamage;
                default:
                    return false;
            }
        }

        #endregion GetSettings

        #region Permission

        private bool HasAdminPermission(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN);
        }

        private bool CanViewVehicleInfo(BasePlayer player, string vehicleType, BaseVehicleSettings settings)
        {
            if (settings.Purchasable && settings.Commands.Count > 0)
            {
                return HasVehiclePermission(player, vehicleType);
            }
            return false;
        }

        private bool HasVehiclePermission(BasePlayer player, string vehicleType)
        {
            var settings = GetBaseVehicleSettings(vehicleType);
            if (!settings.UsePermission || string.IsNullOrEmpty(settings.Permission))
            {
                return true;
            }
            return permission.UserHasPermission(player.UserIDString, PERMISSION_ALL) ||
                    permission.UserHasPermission(player.UserIDString, settings.Permission);
        }

        #endregion Permission

        #region Claim

        private void TryClaimVehicle(BaseVehicle baseVehicle)
        {
            NextTick(() =>
            {
                if (baseVehicle == null)
                {
                    return;
                }
                var player = baseVehicle.creatorEntity as BasePlayer;
                if (player == null || !player.userID.IsSteamId() || !baseVehicle.OnlyOwnerAccessible())
                {
                    return;
                }
                var vehicleType = GetClaimableVehicleType(baseVehicle);
                if (vehicleType.HasValue)
                {
                    TryClaimVehicle(player, baseVehicle, vehicleType.Value.ToString());
                }
            });
        }

        private void TryClaimVehicle(BaseVehicle baseVehicle, BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId())
            {
                return;
            }
            var vehicleType = GetClaimableVehicleType(baseVehicle);
            if (vehicleType.HasValue)
            {
                TryClaimVehicle(player, baseVehicle, vehicleType.Value.ToString());
            }
        }

        private bool TryClaimVehicle(BasePlayer player, BaseEntity entity, string vehicleType)
        {
            Vehicle vehicle;
            if (!storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle))
            {
                if (!configData.global.autoUnlockFromVendor)
                {
                    return false;
                }

                storedData.AddVehicleLicense(player.userID, vehicleType);
                vehicle = storedData.GetVehicleLicense(player.userID, vehicleType);
            }
            if (vehicle.Entity == null || vehicle.Entity.IsDestroyed)
            {
                var settings = GetBaseVehicleSettings(vehicle.VehicleType);
                if (settings != null)
                {
                    settings.PreSetupVehicle(entity, vehicle, player);
                    settings.SetupVehicle(entity, vehicle, player, false);
                }
                CacheVehicleEntity(entity, vehicle, player);
                return true;
            }
            return false;
        }

        #endregion Claim

        private bool TryGetVehicle(BaseEntity entity, out Vehicle vehicle)
        {
            if (!vehiclesCache.TryGetValue(entity, out vehicle))
            {
                var vehicleModule = entity as BaseVehicleModule;
                if (vehicleModule == null)
                {
                    return false;
                }
                var parent = vehicleModule.Vehicle;
                if (parent == null || !vehiclesCache.TryGetValue(parent, out vehicle))
                {
                    return false;
                }
            }
            return true;
        }

        private IEnumerator UpdatePlayerData(double currentTimestamp)
        {
            foreach (var playerData in storedData.playerData)
            {
                foreach (var entry in playerData.Value)
                {
                    entry.Value.PlayerId = playerData.Key;
                    entry.Value.VehicleType = entry.Key;
                    if (configData.global.storeVehicle)
                    {
                        entry.Value.LastRecall = entry.Value.LastDismount = currentTimestamp;
                        if (entry.Value.EntityId == 0)
                        {
                            continue;
                        }
                        NetworkableId id = new NetworkableId(entry.Value.EntityId);
                        entry.Value.Entity = BaseNetworkable.serverEntities.Find(id) as BaseEntity;
                        if (entry.Value.Entity == null || entry.Value.Entity.IsDestroyed)
                        {
                            entry.Value.EntityId = 0;
                        }
                        else
                        {
                            vehiclesCache.Add(entry.Value.Entity, entry.Value);
                            if (entry.Value.Entity is Tugboat)
                            {
                                Tugboat vehicle = entry.Value.Entity as Tugboat;
                                vehicle.engineThrust = TUGBOAT_ENGINETHRUST * configData.normalVehicles.tugboat.speedMultiplier;
                            }
                            else if (entry.Value.Entity is ScrapTransportHelicopter)
                            {
                                ScrapTransportHelicopter vehicle = entry.Value.Entity as ScrapTransportHelicopter;
                                vehicle.liftFraction = configData.normalVehicles.transportHelicopter.liftFraction;
                                vehicle.torqueScale = SCRAP_HELICOPTER_TORQUE * configData.normalVehicles.transportHelicopter.rotationScale;
                            }
                            else if (entry.Value.Entity is Minicopter)
                            {
                                Minicopter vehicle = entry.Value.Entity as Minicopter;
                                vehicle.liftFraction = configData.normalVehicles.miniCopter.liftFraction;
                                vehicle.torqueScale = MINICOPTER_TORQUE * configData.normalVehicles.miniCopter.rotationScale;
                            }
                            else if (entry.Value.Entity is AttackHelicopter)
                            {
                                AttackHelicopter vehicle = entry.Value.Entity as AttackHelicopter;
                                vehicle.liftFraction = configData.normalVehicles.attackHelicopter.liftFraction;
                                vehicle.torqueScale = ATTACK_HELICOPTER_TORQUE * configData.normalVehicles.attackHelicopter.rotationScale;
                            }
                        }
                    }
                    // Adjust the delay duration here if needed
                    yield return new WaitForSeconds(0.1f);
                }
            }
            finishedLoading = true;
        }

        #region Helpers

        private static NormalVehicleType? GetClaimableVehicleType(BaseVehicle baseVehicle)
        {
            if (baseVehicle is Tugboat)
            {
                return NormalVehicleType.Tugboat;
            }
            if (baseVehicle is RidableHorse2)
            {
                return NormalVehicleType.RidableHorse;
            }
            if (baseVehicle is ScrapTransportHelicopter)
            {
                return NormalVehicleType.TransportHelicopter;
            }
            if (baseVehicle is Minicopter)
            {
                return NormalVehicleType.MiniCopter;
            }
            if (baseVehicle is AttackHelicopter)
            {
                return NormalVehicleType.AttackHelicopter;
            }
            if (baseVehicle is RHIB)
            {
                return NormalVehicleType.RHIB;
            }
            if (baseVehicle is MotorRowboat)
            {
                return NormalVehicleType.Rowboat;
            }
            if (baseVehicle is SubmarineDuo)
            {
                return NormalVehicleType.SubmarineDuo;
            }
            if (baseVehicle is BaseSubmarine)
            {
                return NormalVehicleType.SubmarineSolo;
            }
            if (baseVehicle is Kayak)
            {
                return NormalVehicleType.Kayak;
            }
            return null;
        }

        private static bool GetDismountPosition(BaseVehicle baseVehicle, BasePlayer player, out Vector3 result)
        {
            var parentVehicle = baseVehicle.VehicleParent();
            if (parentVehicle != null)
            {
                return GetDismountPosition(parentVehicle, player, out result);
            }
            var list = Pool.Get<List<Vector3>>();
            foreach (var transform in baseVehicle.dismountPositions)
            {
                if (baseVehicle.ValidDismountPosition(player, transform.position))
                {
                    list.Add(transform.position);
                    if (baseVehicle.dismountStyle == BaseVehicle.DismountStyle.Ordered)
                    {
                        break;
                    }
                }
            }
            if (list.Count == 0)
            {
                result = Vector3.zero;
                Pool.FreeUnmanaged(ref list);
                return false;
            }
            var pos = player.transform.position;
            list.Sort((a, b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
            result = list[0];
            Pool.FreeUnmanaged(ref list);
            return true;
        }

        private static bool VehicleAnyMounted(BaseEntity entity)
        {
            var baseVehicle = entity as BaseVehicle;
            if (baseVehicle != null && baseVehicle.AnyMounted())
            {
                return true;
            }
            return entity.GetComponentsInChildren<BasePlayer>()?.Length > 0;
        }

        private static void DismountAllPlayers(BaseEntity entity)
        {
            var baseVehicle = entity as BaseVehicle;
            if (baseVehicle != null)
            {
                //(vehicle as BaseVehicle).DismountAllPlayers();
                foreach (var mountPointInfo in baseVehicle.allMountPoints)
                {
                    if (mountPointInfo != null && mountPointInfo.mountable != null)
                    {
                        var mounted = mountPointInfo.mountable.GetMounted();
                        if (mounted != null)
                        {
                            mountPointInfo.mountable.DismountPlayer(mounted);
                        }
                    }
                }
            }
            var players = entity.GetComponentsInChildren<BasePlayer>();
            foreach (var player in players)
            {
                player.SetParent(null, true, true);
            }
        }

        private static Vector3 GetGroundPositionLookingAt(BasePlayer player, float distance, bool needUp = true)
        {
            RaycastHit hitInfo;
            var headRay = player.eyes.HeadRay();
            if (Physics.Raycast(headRay, out hitInfo, distance, LAYER_GROUND))
            {
                return hitInfo.point;
            }
            return GetGroundPosition(headRay.origin + headRay.direction * distance, needUp);
        }

        private static Vector3 GetGroundPosition(Vector3 position, bool needUp = true)
        {
            RaycastHit hitInfo;
            position.y = Physics.Raycast(needUp ? position + Vector3.up * 250 : position, Vector3.down, out hitInfo, needUp ? 400f : 50f, LAYER_GROUND)
                    ? hitInfo.point.y
                    : TerrainMeta.HeightMap.GetHeight(position);
            return position;
        }

        private static bool IsInWater(Vector3 position)
        {
            var colliders = Pool.Get<List<Collider>>();
            Vis.Colliders(position, 0.5f, colliders);
            var flag = colliders.Any(x => x.gameObject.layer == (int)Layer.Water);
            Pool.FreeUnmanaged(ref colliders);
            return flag || WaterLevel.Test(position, false, false);
        }

        private static void MoveToPosition(BasePlayer player, Vector3 position)
        {
            player.Teleport(position);
            player.ForceUpdateTriggers();
            //if (player.HasParent()) player.SetParent(null, true, true);
            player.SendNetworkUpdateImmediate();
        }

        // Authorizes player and their team.
        private static void AuthTeamOnTugboat(Tugboat tug, BasePlayer player)
        {
            RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindPlayersTeam(player.userID);
            VehiclePrivilege vehiclePrivilege = null;
            if (team == null || team.members.Count == 1)
            {
                foreach (BaseEntity child in tug.children)
                {
                    vehiclePrivilege = child as VehiclePrivilege;
                    if (vehiclePrivilege != null) break;
                }

                if (vehiclePrivilege == null) return;
                // I find this a bit broken to do, as it breaks gameplay and makes it OP to recall tugboat.
                // if (clear) vehiclePrivilege.authorizedPlayers.Clear();
                vehiclePrivilege.AddPlayer(player);
                return;
            }
            BasePlayer teammate;
            foreach (BaseEntity child in tug.children)
            {
                vehiclePrivilege = child as VehiclePrivilege;
                if (vehiclePrivilege == null) continue;
                // I find this a bit broken to do, as it breaks gameplay, as it breaks gameplay and makes it OP to recall tugboat.
                // if(clear) vehiclePrivilege.authorizedPlayers.Clear(); 
                vehiclePrivilege.AddPlayer(player);
                foreach (ulong id in team.members)
                {
                    teammate = BasePlayer.FindByID(id);
                    if (teammate == null) continue;
                    vehiclePrivilege.AddPlayer(teammate);
                }
            }
        }
        #region Train Car

        #endregion

        #endregion Helpers

        #endregion Methods

        #region API

        [HookMethod(nameof(IsLicensedVehicle))]
        public bool IsLicensedVehicle(BaseEntity entity)
        {
            return vehiclesCache.ContainsKey(entity);
        }

        [HookMethod(nameof(GetLicensedVehicle))]
        public BaseEntity GetLicensedVehicle(ulong playerId, string license)
        {
            return storedData.GetVehicleLicense(playerId, license)?.Entity;
        }

        [HookMethod(nameof(HasVehicleLicense))]
        public bool HasVehicleLicense(ulong playerId, string license)
        {
            return storedData.HasVehicleLicense(playerId, license);
        }

        [HookMethod(nameof(RemoveVehicleLicense))]
        public bool RemoveVehicleLicense(ulong playerId, string license)
        {
            return storedData.RemoveVehicleLicense(playerId, license);
        }

        [HookMethod(nameof(AddVehicleLicense))]
        public bool AddVehicleLicense(ulong playerId, string license)
        {
            return storedData.AddVehicleLicense(playerId, license);
        }

        [HookMethod(nameof(GetVehicleLicenses))]
        public List<string> GetVehicleLicenses(ulong playerId)
        {
            return storedData.GetVehicleLicenseNames(playerId);
        }

        [HookMethod(nameof(PurchaseAllVehicles))]
        public void PurchaseAllVehicles(ulong playerId)
        {
            storedData.PurchaseAllVehicles(playerId);
        }

        #endregion API

        #region Commands

        #region Universal Command

        private void CmdUniversal(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }

            string vehicleType;
            if (IsValidOption(player, command, out vehicleType))
            {
                var bypassCooldown = args.Length > 0 && IsValidBypassCooldownOption(args[0]);
                HandleUniversalCmd(player, vehicleType, bypassCooldown, command);
            }
        }

        private void HandleUniversalCmd(BasePlayer player, string vehicleType, bool bypassCooldown, string command)
        {
            if (!finishedLoading)
            {
                Print(player, Lang("PleaseWait", player.UserIDString));
                return;
            }

            // TODO: 
            // Use TerrainMeta.HeightMap.GetHeight to get height of map at a given point!

            // Debug.Log($"INFO: {player.AirFactor()}");
            // if (player.metabolism.oxygen.value == 1)
            // {
            //     
            //     Puts(Lang("NoSpawnInAir", player.UserIDString, vehicleType));
            //     return;
            // }
            Vehicle vehicle;

            string reason;
            var position = Vector3.zero;
            var rotation = Quaternion.identity;
            if (storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle))
            {
                if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
                {
                    //recall
                    if (CanRecall(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
                    {
                        RecallVehicle(player, vehicle, position, rotation);
                        return;
                    }
                }
                else
                {
                    //spawn
                    if (CanSpawn(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
                    {
                        SpawnVehicle(player, vehicle, position, rotation);
                        return;
                    }
                }
                Print(player, reason);
                return;
            }
            //buy - Auto spawns the vehicle when attempting to spawn it via universal command
            if (!BuyVehicle(player, vehicleType)) return;
            storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle);
            if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
            {
                //recall
                if (CanRecall(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
                {
                    RecallVehicle(player, vehicle, position, rotation);
                    return;
                }
            }
            else
            {
                //spawn
                if (CanSpawn(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
                {
                    SpawnVehicle(player, vehicle, position, rotation);
                    return;
                }
            }
            Print(player, reason);
        }

        #endregion Universal Command

        #region Custom Kill Command

        private void CmdCustomKill(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            command = command.Remove(0, configData.chat.customKillCommandPrefix.Length);
            HandleKillCmd(player, command);
        }

        #endregion Custom Kill Command

        #region Help Command

        private void CmdLicenseHelp(BasePlayer player, string command, string[] args)
        {
            var stringBuilder = new StringBuilder();
            stringBuilder.AppendLine(Lang("Help", player.UserIDString));
            stringBuilder.AppendLine(Lang("HelpLicence1", player.UserIDString, configData.chat.buyCommand));
            stringBuilder.AppendLine(Lang("HelpLicence2", player.UserIDString, configData.chat.spawnCommand));
            stringBuilder.AppendLine(Lang("HelpLicence3", player.UserIDString, configData.chat.recallCommand));
            stringBuilder.AppendLine(Lang("HelpLicence4", player.UserIDString, configData.chat.killCommand));

            foreach (var entry in allVehicleSettings)
            {
                if (CanViewVehicleInfo(player, entry.Key, entry.Value))
                {
                    if (configData.chat.useUniversalCommand)
                    {
                        var firstCmd = entry.Value.Commands[0];
                        stringBuilder.AppendLine(Lang("HelpLicence5", player.UserIDString, firstCmd, entry.Value.DisplayName));
                    }
                }
            }
            Print(player, stringBuilder.ToString());
        }

        #endregion Help Command

        #region Remove Command

        [ConsoleCommand("vl.remove")]
        private void CCmdRemoveVehicle(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin && arg.Args != null && arg.Args.Length == 2)
            {
                var option = arg.Args[0];
                string vehicleType;
                if (!IsValidVehicleType(option, out vehicleType))
                {
                    Print(arg, $"{option} is not a valid vehicle type");
                    return;
                }
                switch (arg.Args[1].ToLower())
                {
                    case "*":
                    case "all":
                        {
                            storedData.RemoveLicenseForAllPlayers(vehicleType);
                            var vehicleName = GetBaseVehicleSettings(vehicleType).DisplayName;
                            Print(arg, $"You successfully removed the vehicle({vehicleName}) of all players");
                        }
                        return;

                    default:
                        {
                            var target = RustCore.FindPlayer(arg.Args[1]);
                            if (target == null)
                            {
                                Print(arg, $"Player '{arg.Args[1]}' not found");
                                return;
                            }

                            var vehicleName = GetBaseVehicleSettings(vehicleType).DisplayName;
                            if (RemoveVehicleLicense(target.userID, vehicleType))
                            {
                                Print(arg, $"You successfully removed the vehicle({vehicleName}) of {target.displayName}");
                                return;
                            }

                            Print(arg, $"{target.displayName} has not purchased vehicle({vehicleName}) and cannot be removed");
                        }
                        return;
                }
            }
        }

        [ConsoleCommand("vl.cleardata")]
        private void CCmdClearVehicle(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                foreach (var vehicle in vehiclesCache.Keys.ToArray())
                {
                    vehicle.Kill(BaseNetworkable.DestroyMode.Gib);
                }
                vehiclesCache.Clear();
                ClearData();
                Print(arg, "You successfully cleaned up all vehicle data");
            }
        }

        #endregion Remove Command

        #region Buy Command

        [ConsoleCommand("vl.buy")]
        private void CCmdBuyVehicle(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin && arg.Args != null && arg.Args.Length == 2)
            {
                var option = arg.Args[0];
                string vehicleType;
                if (!IsValidVehicleType(option, out vehicleType))
                {
                    Print(arg, $"{option} is not a valid vehicle type");
                    return;
                }
                switch (arg.Args[1].ToLower())
                {
                    case "*":
                    case "all":
                        {
                            storedData.AddLicenseForAllPlayers(vehicleType);
                            var vehicleName = GetBaseVehicleSettings(vehicleType).DisplayName;
                            Print(arg, $"You successfully purchased the vehicle({vehicleName}) for all players");
                        }
                        return;

                    default:
                        {
                            var target = RustCore.FindPlayer(arg.Args[1]);
                            if (target == null)
                            {
                                Print(arg, $"Player '{arg.Args[1]}' not found");
                                return;
                            }

                            var vehicleName = GetBaseVehicleSettings(vehicleType).DisplayName;
                            if (AddVehicleLicense(target.userID, vehicleType))
                            {
                                Print(arg, $"You successfully purchased the vehicle({vehicleName}) for {target.displayName}");
                                return;
                            }

                            Print(arg, $"{target.displayName} has purchased vehicle({vehicleName})");
                        }
                        return;
                }
            }
            var player = arg.Player();
            if (player == null)
            {
                Print(arg, $"The server console cannot use the '{arg.cmd.FullName}' command");
            }
            else
            {
                CmdBuyVehicle(player, arg.cmd.FullName, arg.Args);
            }
        }

        private void CmdBuyVehicle(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (args == null || args.Length < 1)
            {
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine(Lang("Help", player.UserIDString));
                foreach (var entry in allVehicleSettings)
                {
                    if (CanViewVehicleInfo(player, entry.Key, entry.Value))
                    {
                        var firstCmd = entry.Value.Commands[0];
                        if (entry.Value.PurchasePrices.Count > 0)
                        {
                            var prices = FormatPriceInfo(player, entry.Value.PurchasePrices);
                            stringBuilder.AppendLine(Lang("HelpBuyPrice", player.UserIDString, configData.chat.buyCommand, firstCmd, entry.Value.DisplayName, prices));
                        }
                        else
                        {
                            stringBuilder.AppendLine(Lang("HelpBuy", player.UserIDString, configData.chat.buyCommand, firstCmd, entry.Value.DisplayName));
                        }
                    }
                }
                Print(player, stringBuilder.ToString());
                return;
            }
            string vehicleType;
            if (IsValidOption(player, args[0], out vehicleType))
            {
                BuyVehicle(player, vehicleType);
            }
        }

        private bool BuyVehicle(BasePlayer player, string vehicleType, bool response = true)
        {
            var settings = GetBaseVehicleSettings(vehicleType);
            if (!settings.Purchasable)
            {
                Print(player, Lang("VehicleCannotBeBought", player.UserIDString, settings.DisplayName));
                return false;
            }
            var vehicles = storedData.GetPlayerVehicles(player.userID, false);
            if (vehicles.ContainsKey(vehicleType))
            {
                Print(player, Lang("VehicleAlreadyPurchased", player.UserIDString, settings.DisplayName));
                return false;
            }
            string resources;
            if (settings.PurchasePrices.Count > 0 && !TryPay(player, settings, settings.PurchasePrices, out resources))
            {
                Print(player, Lang("NoResourcesToPurchaseVehicle", player.UserIDString, settings.DisplayName, resources));
                return false;
            }
            vehicles.Add(vehicleType, Vehicle.Create(player.userID, vehicleType));
            SaveData();
            if (response) Print(player, Lang("VehiclePurchased", player.UserIDString, settings.DisplayName, configData.chat.spawnCommand));
            return true;
        }

        #endregion Buy Command

        #region Spawn Command

        [ConsoleCommand("vl.spawn")]
        private void CCmdSpawnVehicle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                Print(arg, $"The server console cannot use the '{arg.cmd.FullName}' command");
            }
            else
            {
                CmdSpawnVehicle(player, arg.cmd.FullName, arg.Args);
            }
        }

        private void CmdSpawnVehicle(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (args == null || args.Length < 1)
            {
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine(Lang("Help", player.UserIDString));
                foreach (var entry in allVehicleSettings)
                {
                    if (CanViewVehicleInfo(player, entry.Key, entry.Value))
                    {
                        var firstCmd = entry.Value.Commands[0];
                        if (entry.Value.SpawnPrices.Count > 0)
                        {
                            var prices = FormatPriceInfo(player, entry.Value.SpawnPrices);
                            stringBuilder.AppendLine(Lang("HelpSpawnPrice", player.UserIDString, configData.chat.spawnCommand, firstCmd, entry.Value.DisplayName, prices));
                        }
                        else
                        {
                            stringBuilder.AppendLine(Lang("HelpSpawn", player.UserIDString, configData.chat.spawnCommand, firstCmd, entry.Value.DisplayName));
                        }
                    }
                }
                Print(player, stringBuilder.ToString());
                return;
            }
            string vehicleType;
            if (IsValidOption(player, args[0], out vehicleType))
            {
                var bypassCooldown = args.Length > 1 && IsValidBypassCooldownOption(args[1]);
                SpawnVehicle(player, vehicleType, bypassCooldown, command + " " + args[0]);
            }
        }

        private bool SpawnVehicle(BasePlayer player, string vehicleType, bool bypassCooldown, string command)
        {
            var settings = GetBaseVehicleSettings(vehicleType);
            Vehicle vehicle;
            if (!storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle))
            {
                if (!permission.UserHasPermission(player.UserIDString, PERMISSION_BYPASS_COST))
                {
                    Print(player, Lang("VehicleNotYetPurchased", player.UserIDString, settings.DisplayName, configData.chat.buyCommand));
                    return false;
                }
                BuyVehicle(player, vehicleType);
                vehicle = storedData.GetVehicleLicense(player.userID, vehicleType);
            }
            if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
            {
                Print(player, Lang("AlreadyVehicleOut", player.UserIDString, settings.DisplayName, configData.chat.recallCommand));
                return false;
            }
            string reason;
            var position = Vector3.zero;
            var rotation = Quaternion.identity;
            if (CanSpawn(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
            {
                SpawnVehicle(player, vehicle, position, rotation);
                return false;
            }
            Print(player, reason);
            return true;
        }

        private bool CanSpawn(BasePlayer player, Vehicle vehicle, bool bypassCooldown, string command, out string reason, ref Vector3 position, ref Quaternion rotation)
        {

            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            // if (player.isInAir)
            // {
            //     reason = Lang("NoSpawnInAir", player.UserIDString, settings.DisplayName);
            //     return false;
            // }
            BaseEntity randomVehicle = null;
            if (configData.global.limitVehicles > 0)
            {
                var activeVehicles = storedData.ActiveVehicles(player.userID);
                var count = activeVehicles.Count();
                if (count >= configData.global.limitVehicles)
                {
                    if (configData.global.killVehicleLimited)
                    {
                        randomVehicle = activeVehicles.ElementAt(Random.Range(0, count));
                    }
                    else
                    {
                        reason = Lang("VehiclesLimit", player.UserIDString, configData.global.limitVehicles);
                        return false;
                    }
                }
            }
            if (!CanPlayerAction(player, vehicle, settings, out reason, ref position, ref rotation))
            {
                return false;
            }
            var obj = Interface.CallHook("CanLicensedVehicleSpawn", player, vehicle.VehicleType, position, rotation);
            if (obj != null)
            {
                var s = obj as string;
                reason = s ?? Lang("SpawnWasBlocked", player.UserIDString, settings.DisplayName);
                return false;
            }

#if DEBUG
            if (player.IsAdmin)
            {
                reason = null;
                return true;
            }
#endif
            if (!CheckCooldown(player, vehicle, settings, bypassCooldown, true, command, out reason))
            {
                return false;
            }

            string resources;
            if (settings.SpawnPrices.Count > 0 && !TryPay(player, settings, settings.SpawnPrices, out resources))
            {
                reason = Lang("NoResourcesToSpawnVehicle", player.UserIDString, settings.DisplayName, resources);
                return false;
            }

            // This prevents horse spawns/recalls as well
            if (!configData.CanSpawnInZones && InZone(player))
            {
                reason = Lang("NoSpawnInZone", player.UserIDString, settings.DisplayName);
                return false;
            }

            if (randomVehicle != null)
            {
                randomVehicle.Kill(BaseNetworkable.DestroyMode.Gib);
            }
            reason = null;
            return true;
        }

        private void SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation, bool response = true)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            var entity = settings.SpawnVehicle(player, vehicle, position, rotation);
            if (entity == null)
            {
                return;
            }

            Interface.CallHook("OnLicensedVehicleSpawned", entity, player, vehicle.VehicleType);
            if (!response) return;
            Print(player, Lang("VehicleSpawned", player.UserIDString, settings.DisplayName));
        }

        private void CacheVehicleEntity(BaseEntity entity, Vehicle vehicle, BasePlayer player)
        {
            vehicle.PlayerId = player.userID;
            vehicle.VehicleType = vehicle.VehicleType;
            vehicle.Entity = entity;
            vehicle.EntityId = entity.net.ID.Value;
            vehicle.LastDismount = vehicle.LastRecall = TimeEx.currentTimestamp;
            vehiclesCache[entity] = vehicle;
        }

        #endregion Spawn Command

        #region Recall Command

        [ConsoleCommand("vl.recall")]
        private void CCmdRecallVehicle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                Print(arg, $"The server console cannot use the '{arg.cmd.FullName}' command");
            }
            else
            {
                CmdRecallVehicle(player, arg.cmd.FullName, arg.Args);
            }
        }

        private void CmdRecallVehicle(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (args == null || args.Length < 1)
            {
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine(Lang("Help", player.UserIDString));
                foreach (var entry in allVehicleSettings)
                {
                    if (CanViewVehicleInfo(player, entry.Key, entry.Value))
                    {
                        var firstCmd = entry.Value.Commands[0];
                        if (entry.Value.RecallPrices.Count > 0)
                        {
                            var prices = FormatPriceInfo(player, entry.Value.RecallPrices);
                            stringBuilder.AppendLine(Lang("HelpRecallPrice", player.UserIDString, configData.chat.recallCommand, firstCmd, entry.Value.DisplayName, prices));
                        }
                        else
                        {
                            stringBuilder.AppendLine(Lang("HelpRecall", player.UserIDString, configData.chat.recallCommand, firstCmd, entry.Value.DisplayName));
                        }
                    }
                }
                Print(player, stringBuilder.ToString());
                return;
            }
            string vehicleType;
            if (IsValidOption(player, args[0], out vehicleType))
            {
                var bypassCooldown = args.Length > 1 && IsValidBypassCooldownOption(args[1]);
                RecallVehicle(player, vehicleType, bypassCooldown, command + " " + args[0]);
            }
        }

        private bool RecallVehicle(BasePlayer player, string vehicleType, bool bypassCooldown, string command)
        {
            var settings = GetBaseVehicleSettings(vehicleType);
            Vehicle vehicle;
            if (!storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle))
            {
                Print(player, Lang("VehicleNotYetPurchased", player.UserIDString, settings.DisplayName, configData.chat.buyCommand));
                return false;
            }
            if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
            {
                string reason;
                var position = Vector3.zero;
                var rotation = Quaternion.identity;
                if (CanRecall(player, vehicle, bypassCooldown, command, out reason, ref position, ref rotation))
                {
                    RecallVehicle(player, vehicle, position, rotation);
                    return true;
                }
                Print(player, reason);
                return false;
            }
            Print(player, Lang("VehicleNotOut", player.UserIDString, settings.DisplayName, configData.chat.spawnCommand));
            return false;
        }

        private bool CanRecall(BasePlayer player, Vehicle vehicle, bool bypassCooldown, string command, out string reason, ref Vector3 position, ref Quaternion rotation)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            // if (player.isInAir)
            // {
            //     reason = Lang("NoSpawnInAir", player.UserIDString, settings.DisplayName);
            //     return false;
            // }
            if (settings.RecallMaxDistance > 0 && Vector3.Distance(player.transform.position, vehicle.Entity.transform.position) > settings.RecallMaxDistance)
            {
                reason = Lang("RecallTooFar", player.UserIDString, settings.RecallMaxDistance, settings.DisplayName);
                return false;
            }
            if (configData.global.anyMountedRecall && VehicleAnyMounted(vehicle.Entity))
            {
                reason = Lang("PlayerMountedOnVehicle", player.UserIDString, settings.DisplayName);
                return false;
            }
            if (!CanPlayerAction(player, vehicle, settings, out reason, ref position, ref rotation))
            {
                return false;
            }

            var obj = Interface.CallHook("CanLicensedVehicleRecall", vehicle.Entity, player, vehicle.VehicleType, position, rotation);
            if (obj != null)
            {
                var s = obj as string;
                reason = s ?? Lang("RecallWasBlocked", player.UserIDString, settings.DisplayName);
                return false;
            }
#if DEBUG
            if (player.IsAdmin)
            {
                reason = null;
                return true;
            }
#endif
            if (!CheckCooldown(player, vehicle, settings, bypassCooldown, false, command, out reason))
            {
                return false;
            }
            string resources;
            if (settings.RecallPrices.Count > 0 && !TryPay(player, settings, settings.RecallPrices, out resources))
            {
                reason = Lang("NoResourcesToRecallVehicle", player.UserIDString, settings.DisplayName, resources);
                return false;
            }

            // This prevents horse spawns/recalls as well
            if (!configData.CanSpawnInZones && InZone(player))
            {
                reason = Lang("NoRecallInZone", player.UserIDString, settings.DisplayName);
                return false;
            }
            reason = null;
            return true;
        }

        private void RecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
        {
            var settings = GetBaseVehicleSettings(vehicle.VehicleType);
            settings.PreRecallVehicle(player, vehicle, position, rotation);
            BaseEntity vehicleEntity = vehicle.Entity;

            if (vehicleEntity.IsOn()) vehicleEntity.SetFlag(BaseEntity.Flags.On, false);
            if (vehicleEntity is TrainEngine)
            {
                TrainEngine train = vehicleEntity as TrainEngine;
                train.completeTrain.trackSpeed = 0;
            }
            else
            {
                vehicleEntity.SetVelocity(Vector3.zero);
                vehicleEntity.SetAngularVelocity(Vector3.zero);
            }
            vehicleEntity.transform.SetPositionAndRotation(position, rotation);
            vehicleEntity.transform.hasChanged = true;
            vehicleEntity.UpdateNetworkGroup();
            vehicleEntity.SendNetworkUpdateImmediate();


            settings.PostRecallVehicle(player, vehicle, position, rotation);
            vehicle.OnRecall();

            if (vehicleEntity == null || vehicleEntity.IsDestroyed)
            {
                Print(player, Lang("NotSpawnedOrRecalled", player.UserIDString, settings.DisplayName));
                return;
            }

            Interface.CallHook("OnLicensedVehicleRecalled", vehicleEntity, player, vehicle.VehicleType);
            Print(player, Lang("VehicleRecalled", player.UserIDString, settings.DisplayName));
        }

        #endregion Recall Command

        #region Kill Command

        [ConsoleCommand("vl.kill")]
        private void CCmdKillVehicle(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                Print(arg, $"The server console cannot use the '{arg.cmd.FullName}' command");
            }
            else
            {
                CmdKillVehicle(player, arg.cmd.FullName, arg.Args);
            }
        }

        private void CmdKillVehicle(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            if (args == null || args.Length < 1)
            {
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine(Lang("Help", player.UserIDString));
                foreach (var entry in allVehicleSettings)
                {
                    if (CanViewVehicleInfo(player, entry.Key, entry.Value))
                    {
                        var firstCmd = entry.Value.Commands[0];
                        if (!string.IsNullOrEmpty(configData.chat.customKillCommandPrefix))
                        {
                            stringBuilder.AppendLine(Lang("HelpKillCustom", player.UserIDString, configData.chat.killCommand, firstCmd, configData.chat.customKillCommandPrefix + firstCmd, entry.Value.DisplayName));
                        }
                        else
                        {
                            stringBuilder.AppendLine(Lang("HelpKill", player.UserIDString, configData.chat.killCommand, firstCmd, entry.Value.DisplayName));
                        }
                    }
                }
                Print(player, stringBuilder.ToString());
                return;
            }

            HandleKillCmd(player, args[0]);
        }

        private void HandleKillCmd(BasePlayer player, string option)
        {
            string vehicleType;
            if (IsValidOption(player, option, out vehicleType))
            {
                KillVehicle(player, vehicleType);
            }
        }

        private bool KillVehicle(BasePlayer player, string vehicleType, bool response = true)
        {
            var settings = GetBaseVehicleSettings(vehicleType);
            Vehicle vehicle;
            if (!storedData.IsVehiclePurchased(player.userID, vehicleType, out vehicle))
            {
                Print(player, Lang("VehicleNotYetPurchased", player.UserIDString, settings.DisplayName, configData.chat.buyCommand));
                return false;
            }
            if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
            {
                if (!CanKill(player, vehicle, settings))
                {
                    return false;
                }
                vehicle.Entity.Kill(BaseNetworkable.DestroyMode.Gib);
                if (!response) return true;
                Print(player, Lang("VehicleKilled", player.UserIDString, settings.DisplayName));
                return true;
            }
            Print(player, Lang("VehicleNotOut", player.UserIDString, settings.DisplayName, configData.chat.spawnCommand));
            return false;
        }

        private bool CanKill(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings)
        {
            if (configData.global.anyMountedKill && VehicleAnyMounted(vehicle.Entity))
            {
                Print(player, Lang("PlayerMountedOnVehicle", player.UserIDString, settings.DisplayName));
                return false;
            }
            if (settings.KillMaxDistance > 0 && Vector3.Distance(player.transform.position, vehicle.Entity.transform.position) > settings.KillMaxDistance)
            {
                Print(player, Lang("KillTooFar", player.UserIDString, settings.KillMaxDistance, settings.DisplayName));
                return false;
            }

            return true;
        }

        #endregion Kill Command

        #region Command Helpers

        private bool IsValidBypassCooldownOption(string option)
        {
            return !string.IsNullOrEmpty(configData.chat.bypassCooldownCommand) &&
                    string.Equals(option, configData.chat.bypassCooldownCommand, StringComparison.OrdinalIgnoreCase);
        }

        private bool IsValidOption(BasePlayer player, string option, out string vehicleType)
        {
            if (!commandToVehicleType.TryGetValue(option, out vehicleType))
            {
                Print(player, Lang("OptionNotFound", player.UserIDString, option));
                return false;
            }
            if (!HasVehiclePermission(player, vehicleType))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                vehicleType = null;
                return false;
            }
            if (IsPlayerBlocked(player))
            {
                vehicleType = null;
                return false;
            }
            return true;
        }

        private bool IsValidVehicleType(string option, out string vehicleType)
        {
            foreach (var entry in allVehicleSettings)
            {
                if (string.Equals(entry.Key, option, StringComparison.OrdinalIgnoreCase))
                {
                    vehicleType = entry.Key;
                    return true;
                }
            }

            vehicleType = null;
            return false;
        }

        private string FormatPriceInfo(BasePlayer player, Dictionary<string, PriceInfo> prices)
        {
            var language = RustTranslationAPI != null ? lang.GetLanguage(player.UserIDString) : null;
            return string.Join(", ", from p in prices
                                     select Lang("PriceFormat", player.UserIDString, GetItemDisplayName(language, p.Key, p.Value.displayName), p.Value.amount));
        }

        private bool CanPlayerAction(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings, out string reason, ref Vector3 position, ref Quaternion rotation)
        {
            if (configData.global.preventBuildingBlocked && player.IsBuildingBlocked())
            {
                reason = Lang("BuildingBlocked", player.UserIDString, settings.DisplayName);
                return false;
            }
            if (configData.global.preventSafeZone && player.InSafeZone())
            {
                reason = Lang("PlayerInSafeZone", player.UserIDString, settings.DisplayName);
                return false;
            }
            if (configData.global.preventMountedOrParented && HasMountedOrParented(player, settings))
            {
                reason = Lang("MountedOrParented", player.UserIDString, settings.DisplayName);
                return false;
            }
            if (!settings.TryGetVehicleParams(player, vehicle, out reason, ref position, ref rotation))
            {
                return false;
            }
            reason = null;
            return true;
        }

        private bool HasMountedOrParented(BasePlayer player, BaseVehicleSettings settings)
        {
            if (player.GetMountedVehicle() != null)
            {
                return true;
            }
            var parentEntity = player.GetParentEntity();
            if (parentEntity != null)
            {
                if (configData.global.spawnLookingAt)
                {
                    if (LandOnCargoShip != null && parentEntity is CargoShip && settings.IsFightVehicle)
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private bool CheckCooldown(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings, bool bypassCooldown, bool isSpawnCooldown, string command, out string reason)
        {
            var cooldown = settings.GetCooldown(player, isSpawnCooldown);
            if (cooldown > 0)
            {
                var timeLeft = Math.Ceiling(cooldown - (TimeEx.currentTimestamp - (isSpawnCooldown ? vehicle.LastDeath : vehicle.LastRecall)));
                if (timeLeft > 0)
                {
                    var bypassPrices = isSpawnCooldown ? settings.BypassSpawnCooldownPrices : settings.BypassRecallCooldownPrices;
                    if (bypassCooldown && bypassPrices.Count > 0)
                    {
                        string resources;
                        if (!TryPay(player, settings, bypassPrices, out resources))
                        {
                            reason = Lang(isSpawnCooldown ? "NoResourcesToSpawnVehicleBypass" : "NoResourcesToRecallVehicleBypass", player.UserIDString, settings.DisplayName, resources);
                            return false;
                        }

                        if (isSpawnCooldown)
                        {
                            vehicle.LastDeath = 0;
                        }
                        else
                        {
                            vehicle.LastRecall = 0;
                        }
                    }
                    else
                    {
                        if (string.IsNullOrEmpty(configData.chat.bypassCooldownCommand) || bypassPrices.Count <= 0)
                        {
                            reason = Lang(isSpawnCooldown ? "VehicleOnSpawnCooldown" : "VehicleOnRecallCooldown", player.UserIDString, timeLeft, settings.DisplayName);
                        }
                        else
                        {
                            reason = Lang(isSpawnCooldown ? "VehicleOnSpawnCooldownPay" : "VehicleOnRecallCooldownPay", player.UserIDString, timeLeft, settings.DisplayName,
                                          command + " " + configData.chat.bypassCooldownCommand,
                                          FormatPriceInfo(player, isSpawnCooldown ? settings.BypassSpawnCooldownPrices : settings.BypassRecallCooldownPrices));
                        }
                        return false;
                    }
                }
            }
            reason = null;
            return true;
        }

        #endregion Command Helpers

        #endregion Commands

        #region RustTranslationAPI

        private string GetItemTranslationByShortName(string language, string itemShortName)
        {
            return (string)RustTranslationAPI.Call("GetItemTranslationByShortName", language, itemShortName);
        }

        private string GetItemDisplayName(string language, string itemShortName, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                var displayName1 = GetItemTranslationByShortName(language, itemShortName);
                if (!string.IsNullOrEmpty(displayName1))
                {
                    return displayName1;
                }
            }
            return displayName;
        }

        #endregion RustTranslationAPI

        #region ConfigurationFile

        public ConfigData configData { get; private set; }

        public class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public GlobalSettings global = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chat = new ChatSettings();

            [JsonProperty("Allow vehicles to be spawned/recalled in zones listed in prevent spawning zones")]
            public bool CanSpawnInZones = false;

            [JsonProperty(PropertyName = "Zones to prevent users from spawning/recalled vehicles within.", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AntiSpawnZones = new List<string> { "KeepVehiclesOut" };

            [JsonProperty(PropertyName = "Normal Vehicle Settings")]
            public NormalVehicleSettings normalVehicles = new NormalVehicleSettings();

            [JsonProperty(PropertyName = "Modular Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, ModularVehicleSettings> modularVehicles = new Dictionary<string, ModularVehicleSettings>
            {
                ["SmallCar"] = new ModularVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Small Modular Car",
                    Distance = 5,
                    MinDistanceForPlayers = 3,
                    UsePermission = true,
                    Permission = "vehiclelicence.smallmodularcar",
                    BypassCostPermission = "vehiclelicence.smallmodularcarfree",
                    Commands = new List<string> { "small", "smallcar" },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 1600, displayName = "Scrap" }
                    },
                    SpawnPrices = new Dictionary<string, PriceInfo>
                    {
                        ["metal.refined"] = new PriceInfo { amount = 10, displayName = "High Quality Metal" }
                    },
                    RecallPrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 5, displayName = "Scrap" }
                    },
                    SpawnCooldown = 7200,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 3600,
                            recallCooldown = 10
                        }
                    },
                    ChassisType = ChassisType.Small,
                    ModuleItems = new List<ModuleItem>
                    {
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.cockpit.with.engine", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.storage", healthPercentage = 50f
                        }
                    },
                    EngineItems = new List<EngineItem>
                    {
                        new EngineItem
                        {
                            shortName = "carburetor1", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "crankshaft1", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "piston1", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "sparkplug1", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "valve1", conditionPercentage = 20f
                        }
                    }
                },
                ["MediumCar"] = new ModularVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Medium Modular Car",
                    Distance = 5,
                    MinDistanceForPlayers = 3,
                    UsePermission = true,
                    Permission = "vehiclelicence.mediumodularcar",
                    BypassCostPermission = "vehiclelicence.mediumodularcarfree",
                    Commands = new List<string> { "medium", "mediumcar" },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 2400, displayName = "Scrap" }
                    },
                    SpawnPrices = new Dictionary<string, PriceInfo>
                    {
                        ["metal.refined"] = new PriceInfo { amount = 50, displayName = "High Quality Metal" }
                    },
                    RecallPrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 8, displayName = "Scrap" }
                    },
                    SpawnCooldown = 9000,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 4500,
                            recallCooldown = 10
                        }
                    },
                    ChassisType = ChassisType.Medium,
                    ModuleItems = new List<ModuleItem>
                    {
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.cockpit.with.engine", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.rear.seats", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.flatbed", healthPercentage = 50f
                        }
                    },
                    EngineItems = new List<EngineItem>
                    {
                        new EngineItem
                        {
                            shortName = "carburetor2", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "crankshaft2", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "piston2", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "sparkplug2", conditionPercentage = 20f
                        },
                        new EngineItem
                        {
                            shortName = "valve2", conditionPercentage = 20f
                        }
                    }
                },
                ["LargeCar"] = new ModularVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Large Modular Car",
                    Distance = 6,
                    MinDistanceForPlayers = 3,
                    UsePermission = true,
                    Permission = "vehiclelicence.largemodularcar",
                    BypassCostPermission = "vehiclelicence.largemodularcarfree",
                    Commands = new List<string> { "large", "largecar" },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 3000, displayName = "Scrap" }
                    },
                    SpawnPrices = new Dictionary<string, PriceInfo>
                    {
                        ["metal.refined"] = new PriceInfo { amount = 100, displayName = "High Quality Metal" }
                    },
                    RecallPrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 10, displayName = "Scrap" }
                    },
                    SpawnCooldown = 10800,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 5400,
                            recallCooldown = 10
                        }
                    },
                    ChassisType = ChassisType.Large,
                    ModuleItems = new List<ModuleItem>
                    {
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.engine", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.cockpit.armored", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.passengers.armored", healthPercentage = 50f
                        },
                        new ModuleItem
                        {
                            shortName = "vehicle.1mod.storage", healthPercentage = 50f
                        }
                    },
                    EngineItems = new List<EngineItem>
                    {
                        new EngineItem
                        {
                            shortName = "carburetor3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "crankshaft3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "piston3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "piston3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "sparkplug3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "sparkplug3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "valve3", conditionPercentage = 10f
                        },
                        new EngineItem
                        {
                            shortName = "valve3", conditionPercentage = 10f
                        }
                    }
                }
            };

            [JsonProperty(PropertyName = "Train Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TrainVehicleSettings> trainVehicles = new Dictionary<string, TrainVehicleSettings>
            {
                ["WorkCartAboveGround"] = new TrainVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Work Cart Above Ground",
                    Distance = 12,
                    MinDistanceForPlayers = 6,
                    UsePermission = true,
                    Permission = "vehiclelicence.workcartaboveground",
                    BypassCostPermission = "vehiclelicence.workcartabovegroundfree",
                    Commands = new List<string>
                    {
                        "cartground", "workcartground"
                    },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                    },
                    SpawnCooldown = 1800,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 900,
                            recallCooldown = 10
                        }
                    },
                    TrainComponents = new List<TrainComponent>
                    {
                        new TrainComponent { type = TrainComponentType.Engine }
                    }
                },
                ["WorkCartCovered"] = new TrainVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Covered Work Cart",
                    Distance = 12,
                    MinDistanceForPlayers = 6,
                    UsePermission = true,
                    Permission = "vehiclelicence.coveredworkcart",
                    BypassCostPermission = "vehiclelicence.coveredworkcartfree",
                    Commands = new List<string>
                    {
                        "cartcovered", "coveredworkcart"
                    },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                    },
                    SpawnCooldown = 1800,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 900,
                            recallCooldown = 10
                        }
                    },
                    TrainComponents = new List<TrainComponent>
                    {
                        new TrainComponent { type = TrainComponentType.CoveredEngine }
                    }
                },
                ["CompleteTrain"] = new TrainVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Complete Train",
                    Distance = 12,
                    MinDistanceForPlayers = 6,
                    UsePermission = true,
                    Permission = "vehiclelicence.completetrain",
                    BypassCostPermission = "vehiclelicence.completetrainfree",
                    Commands = new List<string>
                    {
                        "ctrain", "completetrain"
                    },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 6000, displayName = "Scrap" }
                    },
                    SpawnCooldown = 3600,
                    RecallCooldown = 60,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 900,
                            recallCooldown = 10
                        }
                    },
                    TrainComponents = new List<TrainComponent>
                    {
                        new TrainComponent
                        {
                            type = TrainComponentType.Engine
                        },
                        new TrainComponent
                        {
                            type = TrainComponentType.WagonA
                        },
                        new TrainComponent
                        {
                            type = TrainComponentType.WagonB
                        },
                        new TrainComponent
                        {
                            type = TrainComponentType.WagonC
                        },
                        new TrainComponent
                        {
                            type = TrainComponentType.Unloadable
                        },
                        new TrainComponent
                        {
                            type = TrainComponentType.UnloadableLoot
                        }
                    }
                },
                ["Locomotive"] = new TrainVehicleSettings
                {
                    Purchasable = true,
                    NoDamage = false,
                    NoCollisionDamage = false,
                    DisplayName = "Locomotive",
                    Distance = 12,
                    MinDistanceForPlayers = 6,
                    UsePermission = true,
                    Permission = "vehiclelicence.locomotive",
                    BypassCostPermission = "vehiclelicence.locomotivefree",
                    Commands = new List<string>
                    {
                        "loco", "locomotive"
                    },
                    PurchasePrices = new Dictionary<string, PriceInfo>
                    {
                        ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                    },
                    SpawnCooldown = 1800,
                    RecallCooldown = 30,
                    CooldownPermissions = new Dictionary<string, CooldownPermission>
                    {
                        ["vehiclelicence.vip"] = new CooldownPermission
                        {
                            spawnCooldown = 900,
                            recallCooldown = 10
                        }
                    },
                    TrainComponents = new List<TrainComponent>
                    {
                        new TrainComponent { type = TrainComponentType.Locomotive }
                    }
                }
            };
            
            [DefaultValue(null)]
            [JsonProperty(PropertyName = "Custom Vehicle Settings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public CustomVehicleSettings customVehicles = null;

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Use Universal Chat Command")]
            public bool useUniversalCommand = true;

            [JsonProperty(PropertyName = "Help Chat Command")]
            public string helpCommand = "license";

            [JsonProperty(PropertyName = "Buy Chat Command")]
            public string buyCommand = "buy";

            [JsonProperty(PropertyName = "Spawn Chat Command")]
            public string spawnCommand = "spawn";

            [JsonProperty(PropertyName = "Recall Chat Command")]
            public string recallCommand = "recall";

            [JsonProperty(PropertyName = "Kill Chat Command")]
            public string killCommand = "kill";

            [JsonProperty(PropertyName = "Custom Kill Chat Command Prefix")]
            public string customKillCommandPrefix = "no";

            [JsonProperty(PropertyName = "Bypass Cooldown Command")]
            public string bypassCooldownCommand = "pay";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "<color=#00FFFF>[VehicleLicense]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon = 76561198924840872;
        }

        public class GlobalSettings
        {
            [JsonProperty(PropertyName = "Store Vehicle On Plugin Unloaded / Server Restart")]
            public bool storeVehicle = true;

            [JsonProperty(PropertyName = "Clear Vehicle Data On Map Wipe")]
            public bool clearVehicleOnWipe;

            [JsonProperty(PropertyName = "Interval to check vehicle for wipe (Seconds)")]
            public float checkVehiclesInterval = 300;

            [JsonProperty(PropertyName = "Spawn vehicle in the direction you are looking at")]
            public bool spawnLookingAt = true;

            [JsonProperty(PropertyName = "Automatically claim vehicles purchased from vehicle vendors")]
            public bool autoClaimFromVendor;

            [JsonProperty(PropertyName = "Vehicle vendor purchases will unlock the license for the player")]
            public bool autoUnlockFromVendor;

            [JsonProperty(PropertyName = "Limit the number of vehicles at a time")]
            public int limitVehicles;

            [JsonProperty(PropertyName = "Kill a random vehicle when the number of vehicles is limited")]
            public bool killVehicleLimited;

            [JsonProperty(PropertyName = "Prevent vehicles from damaging players")]
            public bool preventDamagePlayer = true;

            [JsonProperty(PropertyName = "Prevent vehicles from damaging NPCs")]
            public bool preventDamageNPCs = false;

            [JsonProperty(PropertyName = "Safe dismount players who jump off train")]
            public bool safeTrainDismount = true;

            [JsonProperty(PropertyName = "Prevent vehicles from shattering")]
            public bool preventShattering = true;

            [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling in safe zone")]
            public bool preventSafeZone = true;

            [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player are building blocked")]
            public bool preventBuildingBlocked = true;

            [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player is mounted or parented")]
            public bool preventMountedOrParented = true;

            [JsonProperty(PropertyName = "Check if any player mounted when recalling a vehicle")]
            public bool anyMountedRecall = true;

            [JsonProperty(PropertyName = "Check if any player mounted when killing a vehicle")]
            public bool anyMountedKill;

            [JsonProperty(PropertyName = "Dismount all players when a vehicle is recalled")]
            public bool dismountAllPlayersRecall = true;

            [JsonProperty(PropertyName = "Prevent other players from mounting vehicle")]
            public bool preventMounting = true;

            [JsonProperty(PropertyName = "Prevent mounting on driver's seat only")]
            public bool preventDriverSeat = true;

            [JsonProperty(PropertyName = "Prevent other players from looting fuel container and inventory")]
            public bool preventLooting = true;

            [JsonProperty(PropertyName = "Prevent other players from pushing vehicles they do not own")]
            public bool preventPushing = false;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool useTeams;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool useClans = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool useFriends = true;

            [JsonProperty(PropertyName = "Vehicle No Decay")]
            public bool noDecay;

            [JsonProperty(PropertyName = "Vehicle No Fire Ball")]
            public bool noFireBall = true;

            [JsonProperty(PropertyName = "Vehicle No Server Gibs")]
            public bool noServerGibs = true;

            [JsonProperty(PropertyName = "Chinook No Map Marker")]
            public bool noMapMarker = true;

            [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
            public bool useRaidBlocker;

            [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
            public bool useCombatBlocker;

            [JsonProperty(PropertyName = "Populate the config with Custom Vehicles (CANNOT BE UNDONE! Will make config much larger)")]
            public bool useCustomVehicles;
        }

        public class NormalVehicleSettings
        {
            [JsonProperty(PropertyName = "Tugboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TugboatSettings tugboat = new TugboatSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Tugboat",
                speedMultiplier = 1,
                autoAuth = true,
                Distance = 10,
                MinDistanceForPlayers = 3,
                UsePermission = true,
                Permission = "vehiclelicence.tug",
                BypassCostPermission = "vehiclelicence.tugfree",
                Commands = new List<string> { "tugboat", "tug" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo
                    {
                        amount = 10000,
                        displayName = "Scrap"
                    }
                },
                SpawnCooldown = 450,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 60,
                        recallCooldown = 10
                    }
                }
            };
            [JsonProperty(PropertyName = "Sedan Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SedanSettings sedan = new SedanSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Sedan",
                Distance = 5,
                MinDistanceForPlayers = 3,
                UsePermission = true,
                Permission = "vehiclelicence.sedan",
                BypassCostPermission = "vehiclelicence.sedanfree",
                Commands = new List<string> { "car", "sedan" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 300, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Chinook Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public ChinookSettings chinook = new ChinookSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Chinook",
                Distance = 15,
                MinDistanceForPlayers = 6,
                UsePermission = true,
                Permission = "vehiclelicence.chinook",
                BypassCostPermission = "vehiclelicence.chinookfree",
                Commands = new List<string> { "ch47", "chinook" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 3000, displayName = "Scrap" }
                },
                SpawnCooldown = 3000,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 1500,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Rowboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RowboatSettings rowboat = new RowboatSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Row Boat",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.rowboat",
                BypassCostPermission = "vehiclelicence.rowboatfree",
                Commands = new List<string> { "row", "rowboat" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 500, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "RHIB Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RhibSettings rhib = new RhibSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Rigid Hulled Inflatable Boat",
                Distance = 10,
                MinDistanceForPlayers = 3,
                UsePermission = true,
                Permission = "vehiclelicence.rhib",
                BypassCostPermission = "vehiclelicence.rhibfree",
                Commands = new List<string> { "rhib" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 450,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 225,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public HotAirBalloonSettings hotAirBalloon = new HotAirBalloonSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Hot Air Balloon",
                Distance = 20,
                MinDistanceForPlayers = 5,
                UsePermission = true,
                Permission = "vehiclelicence.hotairballoon",
                BypassCostPermission = "vehiclelicence.hotairballoonfree",
                Commands = new List<string> { "hab", "hotairballoon" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 500, displayName = "Scrap" }
                },
                SpawnCooldown = 900,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 450,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Armored Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public ArmoredHotAirBalloonSettings armoredHotAirBalloon = new ArmoredHotAirBalloonSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Armored Hot Air Balloon",
                Distance = 10,
                MinDistanceForPlayers = 5,
                UsePermission = true,
                Permission = "vehiclelicence.armoredhotairballoon",
                BypassCostPermission = "vehiclelicence.armoredhotairballoonfree",
                Commands = new List<string> { "ahab", "armoredhotairballoon", "armoredballoon", "aballoon" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 500, displayName = "Scrap" }
                },
                SpawnCooldown = 1000,
                RecallCooldown = 40,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 550,
                        recallCooldown = 20
                    }
                }
            };

            [JsonProperty(PropertyName = "Ridable Horse Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RidableHorseSettings ridableHorse = new RidableHorseSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                IsDoubleSaddle = false,
                DisplayName = "Ridable Horse",
                Distance = 6,
                MinDistanceForPlayers = 1,
                UsePermission = true,
                Permission = "vehiclelicence.ridablehorse",
                BypassCostPermission = "vehiclelicence.ridablehorsefree",
                Commands = new List<string> { "horse", "ridablehorse" },
                Breeds = new List<string>
                {
                    "Appalosa", "Bay", "Buckskin", "Chestnut", "Dapple Grey", "Piebald", "Pinto", "Red Roan", "White Thoroughbred", "Black Thoroughbred"
                },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 700, displayName = "Scrap" }
                },
                SpawnCooldown = 3000,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 1500,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Mini Copter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MiniCopterSettings miniCopter = new MiniCopterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Mini Copter",
                Distance = 8,
                MinDistanceForPlayers = 2,
                rotationScale = 1.0f,
                flyHackPause = 0,
                liftFraction = 0.25f,
                instantTakeoff = false,
                UsePermission = true,
                Permission = "vehiclelicence.minicopter",
                BypassCostPermission = "vehiclelicence.minicopterfree",
                Commands = new List<string> { "mini", "minicopter" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 4000, displayName = "Scrap" }
                },
                SpawnCooldown = 1800,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 900,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Attack Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public AttackHelicopterSettings attackHelicopter = new AttackHelicopterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Attack Helicopter",
                Distance = 8,
                MinDistanceForPlayers = 2,
                rotationScale = 1.0f,
                flyHackPause = 0,
                liftFraction = 0.33f,
                HVSpawnAmmoAmount = 0,
                IncendiarySpawnAmmoAmount = 0,
                FlareSpawnAmmoAmount = 0,
                instantTakeoff = false,
                UsePermission = true,
                Permission = "vehiclelicence.attackhelicopter",
                BypassCostPermission = "vehiclelicence.attackhelicopterfree",
                Commands = new List<string> { "attack", "aheli", "attackheli", "attackhelicopter" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 4000, displayName = "Scrap" }
                },
                SpawnCooldown = 1800,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 900,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Transport Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TransportHelicopterSettings transportHelicopter = new TransportHelicopterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Transport Copter",
                Distance = 7,
                MinDistanceForPlayers = 4,
                flyHackPause = 0,
                rotationScale = 1.0f,
                liftFraction = .25f,
                instantTakeoff = false,
                UsePermission = true,
                Permission = "vehiclelicence.transportcopter",
                BypassCostPermission = "vehiclelicence.transportcopterfree",
                Commands = new List<string>
                {
                    "tcop", "transportcopter"
                },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 2400,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 1200,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Work Cart Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WorkCartSettings workCart = new WorkCartSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Work Cart",
                Distance = 12,
                MinDistanceForPlayers = 6,
                UsePermission = true,
                Permission = "vehiclelicence.workcart",
                BypassCostPermission = "vehiclelicence.workcartfree",
                Commands = new List<string>
                {
                    "cart", "workcart"
                },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                },
                SpawnCooldown = 1800,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 900,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Sedan Rail Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WorkCartSettings sedanRail = new WorkCartSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Sedan Rail",
                Distance = 6,
                MinDistanceForPlayers = 3,
                UsePermission = true,
                Permission = "vehiclelicence.sedanrail",
                BypassCostPermission = "vehiclelicence.sedanrailfree",
                Commands = new List<string>
                {
                    "carrail", "sedanrail"
                },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 500, displayName = "Scrap" }
                },
                SpawnCooldown = 600,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 300,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Magnet Crane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MagnetCraneSettings magnetCrane = new MagnetCraneSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Magnet Crane",
                Distance = 16,
                MinDistanceForPlayers = 8,
                UsePermission = true,
                Permission = "vehiclelicence.magnetcrane",
                BypassCostPermission = "vehiclelicence.magnetcranefree",
                Commands = new List<string>
                {
                    "crane", "magnetcrane"
                },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                },
                SpawnCooldown = 600,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 300,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Submarine Solo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SubmarineSoloSettings submarineSolo = new SubmarineSoloSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Submarine Solo",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.submarinesolo",
                BypassCostPermission = "vehiclelicence.submarinesolofree",
                Commands = new List<string> { "subsolo", "solo" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 600, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Submarine Duo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SubmarineDuoSettings submarineDuo = new SubmarineDuoSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Submarine Duo",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.submarineduo",
                BypassCostPermission = "vehiclelicence.submarineduofree",
                Commands = new List<string> { "subduo", "duo" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SnowmobileSettings snowmobile = new SnowmobileSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Snowmobile",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.snowmobile",
                BypassCostPermission = "vehiclelicence.snowmobilefree",
                Commands = new List<string> { "snow", "snowmobile" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Tomaha Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SnowmobileSettings tomahaSnowmobile = new SnowmobileSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Tomaha Snowmobile",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.tomahasnowmobile",
                BypassCostPermission = "vehiclelicence.tomahasnowmobilefree",
                Commands = new List<string> { "tsnow", "tsnowmobile" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Pedal Bike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public PedalBikeSettings pedalBike = new PedalBikeSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Pedal Bike",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.pedalbike",
                BypassCostPermission = "vehiclelicence.pedalbikefree",
                Commands = new List<string> { "bike", "pbike" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 100, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Pedal Trike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public PedalTrikeSettings pedalTrike = new PedalTrikeSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Pedal Trike",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.pedaltrike",
                BypassCostPermission = "vehiclelicence.pedaltrikefree",
                Commands = new List<string> { "trike", "ptrike" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 200, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Motorbike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MotorBikeSettings motorBike = new MotorBikeSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Motorbike",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.motorbike",
                BypassCostPermission = "vehiclelicence.motorbikefree",
                Commands = new List<string> { "mbike", "motorbike" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 750, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Motorbike Sidecar Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MotorBikeSidecarSettings motorBikeSidecar = new MotorBikeSidecarSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Motorbike Sidecar",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.motorbikesidecar",
                BypassCostPermission = "vehiclelicence.motorbikesidecarfree",
                Commands = new List<string> { "mbikescar", "motorbikesidecar" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };
            
            [JsonProperty(PropertyName = "Kayak Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public KayakSettings Kayak = new KayakSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Kayak",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.kayak",
                BypassCostPermission = "vehiclelicence.kayakfree",
                Commands = new List<string> { "kayak" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 300, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };
        }

        public class CustomVehicleSettings
        {
            [JsonProperty(PropertyName = "ATV Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public AtvSettings atv = new AtvSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "ATV",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.atv",
                BypassCostPermission = "vehiclelicence.atvfree",
                Commands = new List<string> { "atv", "quad" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Race Sofa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RaceSofaSettings raceSofa = new RaceSofaSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Race Sofa",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.sofa",
                BypassCostPermission = "vehiclelicence.sofafree",
                Commands = new List<string> { "sofa", "rsofa" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 1000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 150,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Water Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WaterBirdSettings waterBird = new WaterBirdSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Water Bird",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.waterbird",
                BypassCostPermission = "vehiclelicence.waterbirdfree",
                Commands = new List<string> { "wbird", "waterbird" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "War Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WarBirdSettings warBird = new WarBirdSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Water Bird",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.warbird",
                BypassCostPermission = "vehiclelicence.warbirdfree",
                Commands = new List<string> { "warb", "warbird" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Little Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public LittleBirdSettings littleBird = new LittleBirdSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Little Bird",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.littlebird",
                BypassCostPermission = "vehiclelicence.littlebirdfree",
                Commands = new List<string> { "lbird", "littlebird" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public FighterSettings fighter = new FighterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Fighter Plane",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.fighter",
                BypassCostPermission = "vehiclelicence.fighterfree",
                Commands = new List<string> { "fighter", "fighterplane" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Old Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public OldFighterSettings oldFighter = new OldFighterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Old Fighter Plane",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.oldfighter",
                BypassCostPermission = "vehiclelicence.oldfighterfree",
                Commands = new List<string> { "ofighter", "oldfighterplane" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Fighter Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public FighterBusSettings fighterBus = new FighterBusSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Fighter Bus",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.fighterbus",
                BypassCostPermission = "vehiclelicence.fighterbusfree",
                Commands = new List<string> { "fbus", "fighterbus" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "War Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WarBusSettings warBus = new WarBusSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "War Bus",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.warbus",
                BypassCostPermission = "vehiclelicence.warbusfree",
                Commands = new List<string> { "wbus", "warbus" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Air Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public AirBusSettings airBus = new AirBusSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Air Bus",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.airbus",
                BypassCostPermission = "vehiclelicence.airbusfree",
                Commands = new List<string> { "abus", "airbus" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Patrol Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public PatrolHelicopterSettings patrolHeli = new PatrolHelicopterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Patrol Helicopter",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.patrolheli",
                BypassCostPermission = "vehiclelicence.patrolhelifree",
                Commands = new List<string> { "pheli", "patrolheli", "patrolhelicopter" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Rust Wing Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RustWingSettings rustWing = new RustWingSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Rust Wing",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.rustwing",
                BypassCostPermission = "vehiclelicence.rustwingfree",
                Commands = new List<string> { "rustwing" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Rust Wing Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RustWingDetailedSettings rustWingDetailed = new RustWingDetailedSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Rust Wing Detailed",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.rustwingdetailed",
                BypassCostPermission = "vehiclelicence.rustwingdetailedfree",
                Commands = new List<string> { "rustwingd" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Rust Wing Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public RustWingDetailedOldSettings rustWingDetailedOld = new RustWingDetailedOldSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Rust Wing Detailed Old",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.rustwingdetailedold",
                BypassCostPermission = "vehiclelicence.rustwingdetailedoldfree",
                Commands = new List<string> { "rustwingo" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Tin Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TinFighterSettings tinFighter = new TinFighterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Tie Fighter",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.tinfighter",
                BypassCostPermission = "vehiclelicence.tinfighterfree",
                Commands = new List<string> { "tin", "tfighter", "tinfighter" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Tin Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TinFighterDetailedSettings tinFighterDetailed = new TinFighterDetailedSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Tie Fighter Detailed",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.tinfighterdetailed",
                BypassCostPermission = "vehiclelicence.tinfighterdetailedfree",
                Commands = new List<string> { "tind", "tfighterd", "tinfighterd" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Tin Fighter Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TinFighterDetailedOldSettings tinFighterDetailedOld = new TinFighterDetailedOldSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Tie Fighter Detailed Old",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.tinfighterdetailedold",
                BypassCostPermission = "vehiclelicence.tinfighterdetailedoldfree",
                Commands = new List<string> { "tino", "tfightero", "tinfightero" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Mars Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MarsFighterSettings marsFighter = new MarsFighterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Mars Fighter",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.marsfighter",
                BypassCostPermission = "vehiclelicence.marsfighterfree",
                Commands = new List<string> { "mars", "mfighter", "marsfighter" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Mars Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MarsFighterDetailedSettings marsFighterDetailed = new MarsFighterDetailedSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Mars Fighter Detailed",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.marsfighterdetailed",
                BypassCostPermission = "vehiclelicence.marsfighterdetailedfree",
                Commands = new List<string> { "marsd", "mfighterd", "marsfighterd" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Sky Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SkyPlaneSettings skyPlane = new SkyPlaneSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Sky Plane",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.skyplane",
                BypassCostPermission = "vehiclelicence.skyplanefree",
                Commands = new List<string> { "splane", "skyplane" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Sky Boat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SkyBoatSettings skyBoat = new SkyBoatSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Sky Boat",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.skyboat",
                BypassCostPermission = "vehiclelicence.skyboatfree",
                Commands = new List<string> { "sboat", "skyboat" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Twisted Truck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TwistedTruckSettings twistedTruck = new TwistedTruckSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Twisted Truck",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.twistedtruck",
                BypassCostPermission = "vehiclelicence.twistedtruckfree",
                Commands = new List<string> { "ttruck", "twistedtruck" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Train Wreck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TrainWreckSettings trainWreck = new TrainWreckSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Train Wreck",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.trainwreck",
                BypassCostPermission = "vehiclelicence.trainwreckfree",
                Commands = new List<string> { "twreck", "trainwreck" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Train Wrecker Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public TrainWreckerSettings trainWrecker = new TrainWreckerSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Train Wrecker",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.trainwrecker",
                BypassCostPermission = "vehiclelicence.trainwreckerfree",
                Commands = new List<string> { "twrecker", "trainwrecker" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SantaSettings santa = new SantaSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Santa",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.santa",
                BypassCostPermission = "vehiclelicence.santafree",
                Commands = new List<string> { "santa" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "War Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WarSantaSettings warSanta = new WarSantaSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "War Santa",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.warsanta",
                BypassCostPermission = "vehiclelicence.warsantafree",
                Commands = new List<string> { "wsanta", "warsanta" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Witch Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public WitchSettings witch = new WitchSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Witch",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.witch",
                BypassCostPermission = "vehiclelicence.witchfree",
                Commands = new List<string> { "witch" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Magic Carpet Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MagicCarpetSettings magicCarpet = new MagicCarpetSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Magic Carpet",
                Distance = 5,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.magiccarpet",
                BypassCostPermission = "vehiclelicence.magiccarpetfree",
                Commands = new List<string> { "mcarpet", "magiccarpet" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Ah69t Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Ah69tSettings ah69t = new Ah69tSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Ah69t",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.ah69t",
                BypassCostPermission = "vehiclelicence.ah69tfree",
                Commands = new List<string> { "ah69t" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Ah69r Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Ah69rSettings ah69r = new Ah69rSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Ah69r",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.ah69r",
                BypassCostPermission = "vehiclelicence.ah69rfree",
                Commands = new List<string> { "ah69r" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Ah69a Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Ah69aSettings ah69a = new Ah69aSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Ah69r",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.ah69a",
                BypassCostPermission = "vehiclelicence.ah69afree",
                Commands = new List<string> { "ah69a" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Mavik Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public MavikSettings mavik = new MavikSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Cobat Drone",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.mavik",
                BypassCostPermission = "vehiclelicence.mavikfree",
                Commands = new List<string> { "mavik", "cd" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Heavy Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public HeavyFighterSettings heavyFighter = new HeavyFighterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Heavy Fighter",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.heavyFighter",
                BypassCostPermission = "vehiclelicence.heavyFighterfree",
                Commands = new List<string> { "heavyfighter", "hf" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Porcelain Commander Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public PorcelainCommanderSettings porcelainCommander = new PorcelainCommanderSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Porcelain Commander",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.porcelaincommander",
                BypassCostPermission = "vehiclelicence.porcelaincommanderfree",
                Commands = new List<string> { "porcelaincommander", "pc" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Dune Buggie Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public DuneBuggieSettings duneBuggie = new DuneBuggieSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Dune Buggie",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.dunebuggie",
                BypassCostPermission = "vehiclelicence.dunebuggiefree",
                Commands = new List<string> { "dunebuggie", "dbug" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Dune Truck Armed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public DuneTruckArmedSettings duneTruckArmed = new DuneTruckArmedSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Dune Truck Armed",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.dunetruckarmed",
                BypassCostPermission = "vehiclelicence.dunetruckarmedfree",
                Commands = new List<string> { "dunetruckarmed", "dta" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Dune Truck UnArmed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public DuneTruckUnArmedSettings duneTruckUnArmed = new DuneTruckUnArmedSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Dune Truck UnArmed",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.dunetruckunarmed",
                BypassCostPermission = "vehiclelicence.dunetruckunarmedfree",
                Commands = new List<string> { "dunetruckunarmed", "dtua" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Dooms Day Disco Van Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public DoomsDayDiscoVanSettings doomsDayDiscoVan = new DoomsDayDiscoVanSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Dooms Day Disco Van",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.doomsdaydiscovan",
                BypassCostPermission = "vehiclelicence.doomsdaydiscovanfree",
                Commands = new List<string> { "doomsdaydiscovan", "dddv" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            }; 
            
            [JsonProperty(PropertyName = "Lawn Mower Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public LawnMowerSettings lawnMower = new LawnMowerSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Lawn Mower",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.lawnmower",
                BypassCostPermission = "vehiclelicence.lawnmowerfree",
                Commands = new List<string> { "lawnmower", "lm" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Fork Lift Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public ForkLiftSettings forkLift = new ForkLiftSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Fork Lift",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.forklift",
                BypassCostPermission = "vehiclelicence.forkliftfree",
                Commands = new List<string> { "forklift", "fl" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Chariot Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public ChariotSettings chariot = new ChariotSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Chariot",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.chariot",
                BypassCostPermission = "vehiclelicence.chariotfree",
                Commands = new List<string> { "chariot" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };

            [JsonProperty(PropertyName = "Soul Harvester Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SoulHarvesterSettings soulHarvester = new SoulHarvesterSettings
            {
                Purchasable = true,
                NoDamage = false,
                NoCollisionDamage = false,
                DisplayName = "Soul Harvester",
                Distance = 7,
                MinDistanceForPlayers = 2,
                UsePermission = true,
                Permission = "vehiclelicence.soulharvester",
                BypassCostPermission = "vehiclelicence.soulharvesterfree",
                Commands = new List<string> { "soulharvester", "soul" },
                PurchasePrices = new Dictionary<string, PriceInfo>
                {
                    ["scrap"] = new PriceInfo { amount = 5000, displayName = "Scrap" }
                },
                SpawnCooldown = 300,
                RecallCooldown = 30,
                CooldownPermissions = new Dictionary<string, CooldownPermission>
                {
                    ["vehiclelicence.vip"] = new CooldownPermission
                    {
                        spawnCooldown = 30,
                        recallCooldown = 10
                    }
                }
            };
        }

        #region BaseSettings

        [JsonObject(MemberSerialization.OptIn)]
        public abstract class BaseVehicleSettings
        {
            #region Properties

            [JsonProperty(PropertyName = "Purchasable")]
            public bool Purchasable { get; set; }

            [JsonProperty(PropertyName = "No Damage")]
            public bool NoDamage { get; set; }

            [JsonProperty(PropertyName = "No Collision Damage")]
            public bool NoCollisionDamage { get; set; }

            [JsonProperty(PropertyName = "Display Name")]
            public string DisplayName { get; set; }

            [JsonProperty(PropertyName = "Use Permission")]
            public bool UsePermission { get; set; }

            [JsonProperty(PropertyName = "Permission")]
            public string Permission { get; set; }

            [JsonProperty(PropertyName = "Bypass Cost Permission")]
            public string BypassCostPermission { get; set; }

            [JsonProperty(PropertyName = "Distance To Spawn")]
            public float Distance { get; set; }

            [JsonProperty(PropertyName = "Time Before Vehicle Wipe (Seconds)")]
            public double WipeTime { get; set; }

            [JsonProperty(PropertyName = "Exclude cupboard zones when wiping")]
            public bool ExcludeCupboard { get; set; }

            [JsonProperty(PropertyName = "Maximum Health")]
            public float MaxHealth { get; set; }

            [JsonProperty(PropertyName = "Can Recall Maximum Distance")]
            public float RecallMaxDistance { get; set; }

            [JsonProperty(PropertyName = "Can Kill Maximum Distance")]
            public float KillMaxDistance { get; set; }

            [JsonProperty(PropertyName = "Minimum distance from player to recall or spawn")]
            public float MinDistanceForPlayers { get; set; } = 3f;

            [JsonProperty(PropertyName = "Remove License Once Crashed")]
            public bool RemoveLicenseOnceCrash { get; set; }

            [JsonProperty(PropertyName = "Commands")]
            public List<string> Commands { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Purchase Prices")]
            public Dictionary<string, PriceInfo> PurchasePrices { get; set; } = new Dictionary<string, PriceInfo>();

            [JsonProperty(PropertyName = "Spawn Prices")]
            public Dictionary<string, PriceInfo> SpawnPrices { get; set; } = new Dictionary<string, PriceInfo>();

            [JsonProperty(PropertyName = "Recall Prices")]
            public Dictionary<string, PriceInfo> RecallPrices { get; set; } = new Dictionary<string, PriceInfo>();

            [JsonProperty(PropertyName = "Recall Cooldown Bypass Prices")]
            public Dictionary<string, PriceInfo> BypassRecallCooldownPrices { get; set; } = new Dictionary<string, PriceInfo>();

            [JsonProperty(PropertyName = "Spawn Cooldown Bypass Prices")]
            public Dictionary<string, PriceInfo> BypassSpawnCooldownPrices { get; set; } = new Dictionary<string, PriceInfo>();

            [JsonProperty(PropertyName = "Spawn Cooldown (Seconds)")]
            public double SpawnCooldown { get; set; }

            [JsonProperty(PropertyName = "Recall Cooldown (Seconds)")]
            public double RecallCooldown { get; set; }

            [JsonProperty(PropertyName = "Cooldown Permissions")]
            public Dictionary<string, CooldownPermission> CooldownPermissions { get; set; } = new Dictionary<string, CooldownPermission>();

            // [JsonProperty(PropertyName = "Custom Vehicle")]
            // public bool CustomVehicle { get; set; } = false;

            #endregion Properties

            protected ConfigData configData => Instance.configData;

            public virtual bool IsWaterVehicle => false;
            public virtual bool IsTrainVehicle => false;
            public virtual bool IsNormalVehicle => true;
            public virtual bool IsFightVehicle => false;
            public virtual bool IsModularVehicle => false;
            public virtual bool IsConnectableVehicle => false;
            public virtual bool CustomVehicle => false;

            protected virtual IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return null;
            }

            protected virtual IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield break;
            }

            #region Spawn

            protected virtual string GetVehiclePrefab(string vehicleType)
            {
                NormalVehicleType normalVehicleType;
                if (Enum.TryParse(vehicleType, out normalVehicleType) && Enum.IsDefined(typeof(NormalVehicleType), normalVehicleType))
                {
                    switch (normalVehicleType)
                    {
                        case NormalVehicleType.Tugboat:
                            return PREFAB_TUGBOAT;
                        case NormalVehicleType.Rowboat:
                            return PREFAB_ROWBOAT;
                        case NormalVehicleType.RHIB:
                            return PREFAB_RHIB;
                        case NormalVehicleType.Sedan:
                            return PREFAB_SEDAN;
                        case NormalVehicleType.HotAirBalloon:
                        case NormalVehicleType.ArmoredHotAirBalloon:
                            return PREFAB_HOTAIRBALLOON;
                        case NormalVehicleType.MiniCopter:
                            return PREFAB_MINICOPTER;
                        case NormalVehicleType.AttackHelicopter:
                            return PREFAB_ATTACKHELICOPTER;
                        case NormalVehicleType.TransportHelicopter:
                            return PREFAB_TRANSPORTCOPTER;
                        case NormalVehicleType.Chinook:
                            return PREFAB_CHINOOK;
                        case NormalVehicleType.RidableHorse:
                            return PREFAB_RIDABLEHORSE;
                        case NormalVehicleType.WorkCart:
                            return PREFAB_WORKCART;
                        case NormalVehicleType.SedanRail:
                            return PREFAB_SEDANRAIL;
                        case NormalVehicleType.MagnetCrane:
                            return PREFAB_MAGNET_CRANE;
                        case NormalVehicleType.SubmarineSolo:
                            return PREFAB_SUBMARINE_SOLO;
                        case NormalVehicleType.SubmarineDuo:
                            return PREFAB_SUBMARINE_DUO;
                        case NormalVehicleType.Snowmobile:
                            return PREFAB_SNOWMOBILE;
                        case NormalVehicleType.TomahaSnowmobile:
                            return PREFAB_SNOWMOBILE_TOMAHA;
                        case NormalVehicleType.PedalBike:
                            return PREFAB_PEDALBIKE;
                        case NormalVehicleType.PedalTrike:
                            return PREFAB_PEDALTRIKE;
                        case NormalVehicleType.MotorBike:
                            return PREFAB_MOTORBIKE;
                        case NormalVehicleType.MotorBike_SideCar:
                            return PREFAB_MOTORBIKE_SIDECAR;
                        case NormalVehicleType.Kayak:
                            return PREFAB_KAYAK;
                        default:
                            return null;
                    }
                }
                return null;
            }

            protected virtual string GetVehicleCustomPrefab(string vehicleType)
            {
                if (!configData.global.useCustomVehicles) return string.Empty;
                CustomVehicleType normalVehicleType;
                if (Enum.TryParse(vehicleType, out normalVehicleType) && Enum.IsDefined(typeof(CustomVehicleType), normalVehicleType))
                {
                    switch (normalVehicleType)
                    {
                        case CustomVehicleType.ATV:
                            return PREFAB_ATV;
                        case CustomVehicleType.RaceSofa:
                            return PREFAB_SOFA;
                        case CustomVehicleType.WaterBird:
                            return PREFAB_WATERBIRD;
                        case CustomVehicleType.WarBird:
                            return PREFAB_WARBIRD;
                        case CustomVehicleType.LittleBird:
                            return PREFAB_LITTLEBIRD;
                        case CustomVehicleType.Fighter:
                            return PREFAB_FIGHTER;
                        case CustomVehicleType.OldFighter:
                            return PREFAB_OLDFIGHTER;
                        case CustomVehicleType.FighterBus:
                            return PREFAB_FIGHTERBUS;
                        case CustomVehicleType.WarBus:
                            return PREFAB_WARBUS;
                        case CustomVehicleType.AirBus:
                            return PREFAB_AIRBUS;
                        case CustomVehicleType.PatrolHeli:
                            return PREFAB_PATROLHELI;
                        case CustomVehicleType.RustWing:
                            return PREFAB_RUSTWING;
                        case CustomVehicleType.RustWingDetailed:
                            return PREFAB_RUSTWINGDETAILED;
                        case CustomVehicleType.RustWingDetailedOld:
                            return PREFAB_RUSTWINGDETAILEDOLD;
                        case CustomVehicleType.TinFighter:
                            return PREFAB_TINFIGHTER;
                        case CustomVehicleType.TinFighterDetailed:
                            return PREFAB_TINFIGHTERDETAILED;
                        case CustomVehicleType.TinFighterDetailedOld:
                            return PREFAB_TINFIGHTERDETAILEDOLD;
                        case CustomVehicleType.MarsFighter:
                            return PREFAB_MARSFIGHTER;
                        case CustomVehicleType.MarsFighterDetailed:
                            return PREFAB_MARSFIGHTERDETAILED;
                        case CustomVehicleType.SkyPlane:
                            return PREFAB_SKYPLANE;
                        case CustomVehicleType.SkyBoat:
                            return PREFAB_SKYBOAT;
                        case CustomVehicleType.TwistedTruck:
                            return PREFAB_TWISTEDTRUCK;
                        case CustomVehicleType.TrainWreck:
                            return PREFAB_TRIANWRECK;
                        case CustomVehicleType.TrainWrecker:
                            return PREFAB_TRIANWRECKER;
                        case CustomVehicleType.Santa:
                            return PREFAB_SANTA;
                        case CustomVehicleType.WarSanta:
                            return PREFAB_WARSANTA;
                        case CustomVehicleType.Witch:
                            return PREFAB_WITCH;
                        case CustomVehicleType.MagicCarpet:
                            return PREFAB_MAGICCARPET;
                        case CustomVehicleType.Ah69t:
                            return PREFAB_AH69T;
                        case CustomVehicleType.Ah69r:
                            return PREFAB_AH69R;
                        case CustomVehicleType.Ah69a:
                            return PREFAB_AH69A;
                        case CustomVehicleType.Mavik:
                            return PREFAB_MAVIK;
                        case CustomVehicleType.HeavyFighter:
                            return PREFAB_HEAVYFIGHTER;
                        case CustomVehicleType.PorcelainCommander:
                            return PREFAB_PORCELAINCOMMANDER;
                        case CustomVehicleType.DuneBuggie:
                            return PREFAB_DUNEBUGGIE;
                        case CustomVehicleType.DuneTruckArmed:
                            return PREFAB_DUNETRUCKARMED;
                        case CustomVehicleType.DuneTruckUnArmed:
                            return PREFAB_DUNETRUCKUNARMED;
                        case CustomVehicleType.DoomsDayDiscoVan:
                            return PREFAB_DOOMSDAYDISCOVAN;
                        case CustomVehicleType.ForkLift:
                            return PREFAB_FORKLIFT;
                        case CustomVehicleType.LawnMower:
                            return PREFAB_LAWNMOWER;
                        case CustomVehicleType.Chariot:
                            return PREFAB_CHARIOT;
                        case CustomVehicleType.SoulHarvester:
                            return PREFAB_SOULHARVESTER;
                        default:
                            return null;
                    }
                }
                return null;
            }

            public virtual BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                var prefab = GetVehiclePrefab(vehicle.VehicleType);
                if (string.IsNullOrEmpty(prefab))
                {
                    prefab = GetVehicleCustomPrefab(vehicle.VehicleType);
                    if (string.IsNullOrEmpty(prefab)) throw new ArgumentException($"Prefab not found for {vehicle.VehicleType}");
                }
                var entity = GameManager.server.CreateEntity(prefab, position, rotation);
                if (entity == null)
                {
                    return null;
                }
                PreSetupVehicle(entity, vehicle, player);
                entity.Spawn();
                SetupVehicle(entity, vehicle, player);
                if (!entity.IsDestroyed)
                {
                    Instance.CacheVehicleEntity(entity, vehicle, player);
                    return ModifyVehicle(entity, vehicle, player);
                }
                Instance.Print(player, Instance.Lang("NotSpawnedOrRecalled", player.UserIDString, DisplayName));
                return null;
            }

            #region Setup

            public virtual void PreSetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player)
            {
                entity.enableSaving = configData.global.storeVehicle;
                entity.OwnerID = player.userID;
            }

            public virtual void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                if (MaxHealth > 0 && Math.Abs(MaxHealth - entity.MaxHealth()) > 0f)
                {
                    (entity as BaseCombatEntity)?.InitializeHealth(MaxHealth, MaxHealth);
                }

                var helicopterVehicle = entity as BaseHelicopter;
                if (helicopterVehicle != null)
                {
                    if (configData.global.noServerGibs)
                    {
                        helicopterVehicle.serverGibs.guid = string.Empty;
                    }
                    if (configData.global.noFireBall)
                    {
                        helicopterVehicle.fireBall.guid = string.Empty;
                    }
                    if (configData.global.noMapMarker)
                    {
                        var ch47Helicopter = entity as CH47Helicopter;
                        if (ch47Helicopter != null)
                        {
                            if (ch47Helicopter.mapMarkerInstance)
                            {
                                ch47Helicopter.mapMarkerInstance.Kill();
                            }
                            ch47Helicopter.mapMarkerEntityPrefab.guid = string.Empty;
                        }
                    }
                }
                if (!configData.global.preventShattering) return;
                var magnetLiftable = entity.GetComponent<MagnetLiftable>();
                if (magnetLiftable != null)
                {
                    UnityEngine.Object.Destroy(magnetLiftable);
                }
            }

            private BaseEntity ModifyVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player)
            {
                if (entity is RidableHorse2) // Thanks to Beee :)
                {
                    RidableHorse2 ridableHorse = entity as RidableHorse2;
                    string randBreed = configData.normalVehicles.ridableHorse.Breeds[Random.Range(0, configData.normalVehicles.ridableHorse.Breeds.Count)];
                    int breedIndex;
                    if (configData.normalVehicles.ridableHorse.BreedsRef.TryGetValue(randBreed, out breedIndex))
                        ridableHorse.ApplyBreed(breedIndex);
                    if (!configData.normalVehicles.ridableHorse.IsDoubleSaddle) return entity;

                    ridableHorse.SetFlag(BaseEntity.Flags.Reserved9, false, networkupdate: false);
                    ridableHorse.SetFlag(BaseEntity.Flags.Reserved10, true, networkupdate: false);
                    ridableHorse.UpdateMountFlags();

                    return entity;
                }
                if (entity is Tugboat)
                {
                    Tugboat tug = entity as Tugboat;
                    tug.engineThrust *= configData.normalVehicles.tugboat.speedMultiplier;
                    // Code for adding all teammates to tugboats.
                    if (!configData.normalVehicles.tugboat.autoAuth) return entity;
                    AuthTeamOnTugboat(tug, player);
                    return entity;
                }

                if (entity is AttackHelicopter)
                {
                    AttackHelicopter attackHelicopter = entity as AttackHelicopter;
                    attackHelicopter.torqueScale *= configData.normalVehicles.attackHelicopter.rotationScale;
                    attackHelicopter.liftFraction = configData.normalVehicles.attackHelicopter.liftFraction;
                    return entity;
                }
                if (entity is HotAirBalloon && vehicle.VehicleType.Equals(NormalVehicleType.ArmoredHotAirBalloon.ToString()))
                {
                    HotAirBalloon HAB = entity as HotAirBalloon;
                    Item armor = ItemManager.CreateByItemID(ITEMID_HOTAIRBALLOON_ARMOR); // Using int instead of string prefab.
                    if (armor == null)
                    {
                        Debug.Log("[VehicleLicence] Please report this to the developer/maintainer. PREFAB_HOTAIRBALLOON_ARMOR's item is NULL");
                        return entity;
                    }
                    ItemModHABEquipment component = armor.info.GetComponent<ItemModHABEquipment>();
                    if (component == null) return entity;
                    HotAirBalloonEquipment equipment = GameManager.server.CreateEntity(component.Prefab.resourcePath, HAB.transform.position, HAB.transform.rotation) as HotAirBalloonEquipment;
                    equipment.SetParent(HAB, true);
                    equipment.Spawn();
                    equipment.DelayNextUpgradeOnRemoveDuration = equipment.DelayNextUpgradeOnRemoveDuration;
                    armor.UseItem();
                    HAB.SendNetworkUpdateImmediate();
                    return entity;
                }

                // TODO: Maybe increase speed of other vehicles.

                if (entity is ScrapTransportHelicopter)
                {
                    ScrapTransportHelicopter scrap = entity as ScrapTransportHelicopter;
                    scrap.torqueScale *= configData.normalVehicles.transportHelicopter.rotationScale;
                    scrap.liftFraction = configData.normalVehicles.transportHelicopter.liftFraction;
                    return entity;
                }

                if (entity is Minicopter)
                {
                    Minicopter mini = entity as Minicopter;
                    // Debug.Log($"Default mini.liftDotMax: {mini.liftDotMax}\nDefault mini.altForceDotMin {mini.altForceDotMin}");
                    // mini.altForceDotMin = 0;
                    // mini.liftDotMax = 0.2f;
                    mini.torqueScale *= configData.normalVehicles.miniCopter.rotationScale;
                    mini.liftFraction = configData.normalVehicles.miniCopter.liftFraction;
                    return entity;
                }
                return entity;
            }

            #endregion Setup

            #endregion Spawn

            #region Recall

            public virtual void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                if (configData.global.dismountAllPlayersRecall)
                {
                    DismountAllPlayers(vehicle.Entity);
                }

                if (CanDropInventory())
                {
                    TryDropVehicleInventory(player, vehicle);
                }

                if (vehicle.Entity.HasParent())
                {
                    vehicle.Entity.SetParent(null, true, true);
                }
            }

            public virtual void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
            }

            #region DropInventory

            protected virtual bool CanDropInventory()
            {
                return false;
            }

            private void TryDropVehicleInventory(BasePlayer player, Vehicle vehicle)
            {
                var droppedItemContainer = DropVehicleInventory(player, vehicle);
                if (droppedItemContainer != null)
                {
                    Instance.Print(player, Instance.Lang("VehicleInventoryDropped", player.UserIDString, DisplayName));
                }
            }

            protected virtual DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle)
            {
                var inventories = GetInventories(vehicle.Entity);
                foreach (var inventory in inventories)
                {
                    if (inventory != null)
                    {
                        return inventory.Drop(PREFAB_ITEM_DROP, vehicle.Entity.GetDropPosition(), vehicle.Entity.transform.rotation, 0);
                    }
                }
                return null;
            }

            #endregion DropInventory

            #region Train Car

            protected bool TryGetTrainCarPositionAndRotation(BasePlayer player, Vehicle vehicle, ref string reason, ref Vector3 original, ref Quaternion rotation)
            {
                float distResult;
                TrainTrackSpline splineResult;
                if (!TrainTrackSpline.TryFindTrackNear(original, Distance, out splineResult, out distResult))
                {
                    reason = Instance.Lang("TooFarTrainTrack", player.UserIDString);
                    return false;
                }

                var position = splineResult.GetPosition(distResult);
                if (!SpaceIsClearForTrainTrack(vehicle, position, rotation))
                {
                    reason = Instance.Lang("TooCloseTrainBarricadeOrWorkCart", player.UserIDString);
                    return false;
                }

                original = position;
                reason = null;
                return true;
            }

            protected bool TryMoveToTrainTrackNear(TrainCar trainCar)
            {
                float distResult;
                TrainTrackSpline splineResult;
                if (TrainTrackSpline.TryFindTrackNear(trainCar.GetFrontWheelPos(), 2f, out splineResult, out distResult))
                {
                    trainCar.FrontWheelSplineDist = distResult;
                    Vector3 tangent;
                    var positionAndTangent = splineResult.GetPositionAndTangent(trainCar.FrontWheelSplineDist, trainCar.transform.forward, out tangent);
                    trainCar.SetTheRestFromFrontWheelData(ref splineResult, positionAndTangent, tangent, trainCar.localTrackSelection, null, true);
                    trainCar.FrontTrackSection = splineResult;
                    if (trainCar.SpaceIsClear())
                    {
                        return true;
                    }
                }
                return false;
            }

            protected bool SpaceIsClearForTrainTrack(Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                var colliders = Pool.Get<List<Collider>>();
                if (vehicle.Entity == null)
                {
                    var prefab = GetVehiclePrefab(vehicle.VehicleType);
                    
                    if (string.IsNullOrEmpty(prefab)) prefab = GetVehicleCustomPrefab(vehicle.VehicleType); // In case of custom vehicle.
                    
                    if (!string.IsNullOrEmpty(prefab))
                    {
                        var trainEngine = GameManager.server.FindPrefab(prefab)?.GetComponent<TrainEngine>();
                        if (trainEngine != null)
                        {
                            GamePhysics.OverlapOBB(new OBB(position, trainEngine.transform.lossyScale, rotation, trainEngine.bounds), colliders, Layers.Mask.Vehicle_World);
                        }
                    }
                }
                else
                {
                    GamePhysics.OverlapOBB(new OBB(position, vehicle.Entity.transform.lossyScale, rotation, vehicle.Entity.bounds), colliders, Layers.Mask.Vehicle_World);
                }
                var free = true;
                foreach (var item in colliders)
                {
                    var baseEntity = item.ToBaseEntity();
                    if (baseEntity == vehicle.Entity)
                    {
                        continue;
                    }
                    free = false;
                    break;
                }
                Pool.FreeUnmanaged(ref colliders);
                return free;
            }

            #endregion

            #endregion Recall

            #region Refund

            protected virtual bool CanRefundFuel(bool isCrash, bool isUnload)
            {
                return false;
            }

            protected virtual bool CanRefundInventory(bool isCrash, bool isUnload)
            {
                return false;
            }

            protected virtual void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload)
            {
                if (CanRefundFuel(isCrash, isUnload))
                {
                    var fuelSystem = GetFuelSystem(vehicle.Entity);
                    if (fuelSystem is EntityFuelSystem entityFuelSystem)
                    {
                        var fuelContainer = entityFuelSystem.GetFuelContainer();
                        if (fuelContainer != null && fuelContainer.inventory != null)
                        {
                            items.AddRange(fuelContainer.inventory.itemList);
                        }
                    }
                }
                if (CanRefundInventory(isCrash, isUnload))
                {
                    var inventories = GetInventories(vehicle.Entity);
                    foreach (var inventory in inventories)
                    {
                        items.AddRange(inventory.itemList);
                    }
                }
            }

            public void RefundVehicleItems(Vehicle vehicle, bool isCrash, bool isUnload)
            {
                var collect = Pool.Get<List<Item>>();

                CollectVehicleItems(collect, vehicle, isCrash, isUnload);

                if (collect.Count > 0)
                {
                    var player = RustCore.FindPlayerById(vehicle.PlayerId);
                    if (player == null)
                    {
                        DropItemContainer(vehicle.Entity, vehicle.PlayerId, collect);
                    }
                    else
                    {
                        for (var i = collect.Count - 1; i >= 0; i--)
                        {
                            var item = collect[i];
                            player.GiveItem(item);
                        }

                        if (player.IsConnected)
                        {
                            Instance.Print(player, Instance.Lang("RefundedVehicleItems", player.UserIDString, DisplayName));
                        }
                    }
                }
                Pool.FreeUnmanaged(ref collect);
            }

            #endregion Refund

            #region GiveFuel

            protected void TryGiveFuel(BaseEntity entity, IFuelVehicle iFuelVehicle)
            {
                if (iFuelVehicle == null || iFuelVehicle.SpawnFuelAmount <= 0)
                {
                    return;
                }
                var fuelSystem = GetFuelSystem(entity);
                if (fuelSystem is EntityFuelSystem entityFuelSystem)
                {
                    var fuelContainer = entityFuelSystem.GetFuelContainer();
                    if (fuelContainer != null && fuelContainer.inventory != null)
                    {
                        var fuelItem = ItemManager.CreateByItemID(ITEMID_FUEL, iFuelVehicle.SpawnFuelAmount);
                        if (!fuelItem.MoveToContainer(fuelContainer.inventory))
                        {
                            fuelItem.Remove();
                        }
                    }
                }
            }

            #endregion GiveFuel

            #region Permission

            public double GetCooldown(BasePlayer player, bool isSpawn)
            {
                var cooldown = isSpawn ? SpawnCooldown : RecallCooldown;
                foreach (var entry in CooldownPermissions)
                {
                    var currentCooldown = isSpawn ? entry.Value.spawnCooldown : entry.Value.recallCooldown;
                    if (cooldown > currentCooldown && Instance.permission.UserHasPermission(player.UserIDString, entry.Key))
                    {
                        cooldown = currentCooldown;
                    }
                }
                return cooldown;
            }

            #endregion Permission

            #region TryGetVehicleParams

            public virtual bool TryGetVehicleParams(BasePlayer player, Vehicle vehicle, out string reason, ref Vector3 spawnPos, ref Quaternion spawnRot)
            {
                Vector3 original;
                Quaternion rotation;
                if (!TryGetPositionAndRotation(player, vehicle, out reason, out original, out rotation))
                {
                    return false;
                }

                CorrectPositionAndRotation(player, vehicle, original, rotation, out spawnPos, out spawnRot);
                return true;
            }

            protected virtual float GetSpawnRotationAngle()
            {
                return 90f;
            }

            protected virtual Vector3 GetOriginalPosition(BasePlayer player)
            {
                if (configData.global.spawnLookingAt || IsWaterVehicle || IsTrainVehicle)
                {
                    return GetGroundPositionLookingAt(player, Distance, !IsTrainVehicle);
                }

                return player.transform.position;
            }

            protected virtual bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, out string reason, out Vector3 original, out Quaternion rotation)
            {
                original = GetOriginalPosition(player);
                rotation = Quaternion.identity;
                if (MinDistanceForPlayers > 0)
                {
                    var nearbyPlayers = Pool.Get<List<BasePlayer>>();
                    Vis.Entities(original, MinDistanceForPlayers, nearbyPlayers, Layers.Mask.Player_Server);
                    var flag = nearbyPlayers.Any(x => x.userID.IsSteamId() && x != player);
                    Pool.FreeUnmanaged(ref nearbyPlayers);
                    if (flag)
                    {
                        reason = Instance.Lang("PlayersOnNearby", player.UserIDString, DisplayName);
                        return false;
                    }
                }
                if (IsWaterVehicle && !IsInWater(original))
                {
                    reason = Instance.Lang("NotLookingAtWater", player.UserIDString, DisplayName);
                    return false;
                }
                RaycastHit hit;
                if (IsWaterVehicle && Physics.Raycast(original, player.eyes.MovementForward(), out hit, 100))
                {
                    if (hit.GetEntity() is PaddlingPool)
                    {
                        reason = Instance.Lang("NotLookingAtWater", player.UserIDString, DisplayName);
                        return false;
                    }
                    List<BaseEntity> pools = Pool.Get<List<BaseEntity>>();
                    Vis.Entities(original, 0.5f, pools, Layers.Mask.Deployed);
                    if (pools.Any(x => x is PaddlingPool))
                    {
                        reason = Instance.Lang("NotLookingAtWater", player.UserIDString, DisplayName);
                        Pool.FreeUnmanaged(ref pools);
                        return false;
                    }
                    Pool.FreeUnmanaged(ref pools);
                }
                reason = null;
                return true;
            }

            protected virtual void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, out Vector3 spawnPos, out Quaternion spawnRot)
            {
                spawnPos = original;
                if (IsTrainVehicle)
                {
                    var forward = player.eyes.HeadForward().WithY(0);
                    spawnRot = forward != Vector3.zero ? Quaternion.LookRotation(forward) : Quaternion.identity;
                    return;
                }
                if (configData.global.spawnLookingAt)
                {
                    var needGetGround = true;
                    if (IsWaterVehicle)
                    {
                        RaycastHit hit;
                        if (Physics.Raycast(spawnPos, Vector3.up, out hit, 100, LAYER_GROUND) && hit.GetEntity() is StabilityEntity)
                        {
                            needGetGround = false; //At the dock
                        }

                        if (IsWaterVehicle && (int)player.transform.position.y >= -1)
                        {
                            if (vehicle.VehicleType == "Tugboat" && Vector3.Distance(spawnPos, player.transform.position) < configData.normalVehicles.tugboat.Distance
                               && spawnPos.y - player.transform.position.y < configData.normalVehicles.tugboat.Distance)
                            {
                                spawnPos += player.eyes.MovementForward() * configData.normalVehicles.tugboat.Distance;
                            }
                            spawnPos.y = player.transform.position.y;
                        }
                        else if (IsWaterVehicle && (int)player.transform.position.y < -1)
                        {
                            // Math.Abs(Math.Abs(spawnPos.y) - Math.Abs(player.transform.position.y)) >= configData.normalVehicles.tugboat.Distance
                            if (vehicle.VehicleType == "Tugboat" && Vector3.Distance(spawnPos, player.transform.position)
                                    < configData.normalVehicles.tugboat.Distance && spawnPos.y - player.transform.position.y < configData.normalVehicles.tugboat.Distance)
                            {
                                spawnPos += player.eyes.MovementForward() * configData.normalVehicles.tugboat.Distance;
                            }
                            spawnPos.y = player.transform.position.y - 3;
                        }
                    }
                    else
                    {
                        if (TryGetCenterOfFloorNearby(ref spawnPos))
                        {
                            needGetGround = false; //At the floor
                            if (vehicle.VehicleType == "TransportHelicopter" && Vector3.Distance(spawnPos, player.transform.position)
                               < configData.normalVehicles.transportHelicopter.Distance)
                            { spawnPos += player.eyes.MovementForward() * configData.normalVehicles.transportHelicopter.Distance; }
                        }
                    }
                    if (needGetGround)
                    {
                        spawnPos = GetGroundPosition(spawnPos);
                        if (IsWaterVehicle && (int)player.transform.position.y >= -1 && spawnPos.y <= -1)
                        {
                            if (vehicle.VehicleType == "Tugboat" && Vector3.Distance(spawnPos, player.transform.position)
                                < configData.normalVehicles.tugboat.Distance && spawnPos.y - player.transform.position.y < configData.normalVehicles.tugboat.Distance)
                            {
                                spawnPos += player.eyes.MovementForward() * configData.normalVehicles.tugboat.Distance;
                            }
                            spawnPos.y = -1;
                        }
                        else if (IsWaterVehicle && (int)player.transform.position.y < -1)
                        {
                            if (vehicle.VehicleType == "Tugboat" && Vector3.Distance(spawnPos, player.transform.position)
                                < configData.normalVehicles.tugboat.Distance && spawnPos.y - player.transform.position.y < configData.normalVehicles.tugboat.Distance)
                            {
                                spawnPos += player.eyes.MovementForward() * configData.normalVehicles.tugboat.Distance;
                            }
                            spawnPos.y = player.transform.position.y;
                        }
                        if (vehicle.VehicleType == "TransportHelicopter" && Vector3.Distance(spawnPos, player.transform.position)
                            < configData.normalVehicles.transportHelicopter.Distance)
                        { spawnPos += player.eyes.MovementForward() * configData.normalVehicles.transportHelicopter.Distance; }
                    }
                }
                else
                {
                    GetPositionWithNoPlayersNearby(player, ref spawnPos);
                }

                var normalized = (spawnPos - player.transform.position).normalized;
                var angle = normalized != Vector3.zero ? Quaternion.LookRotation(normalized).eulerAngles.y : Random.Range(0f, 360f);
                var rotationAngle = GetSpawnRotationAngle();
                spawnRot = Quaternion.Euler(Vector3.up * (angle + rotationAngle));

            }

            private void GetPositionWithNoPlayersNearby(BasePlayer player, ref Vector3 spawnPos)
            {
                var minDistance = Mathf.Min(MinDistanceForPlayers, 2.5f);
                var maxDistance = Mathf.Max(Distance, minDistance);

                var players = new BasePlayer[1];
                var sourcePos = spawnPos;
                for (var i = 0; i < 10; i++)
                {
                    spawnPos.x = sourcePos.x + Random.Range(minDistance, maxDistance) * (Random.value >= 0.5f ? 1 : -1);
                    spawnPos.z = sourcePos.z + Random.Range(minDistance, maxDistance) * (Random.value >= 0.5f ? 1 : -1);

                    if (BaseEntity.Query.Server.GetPlayersInSphere(spawnPos, minDistance, players, p => p.userID.IsSteamId() && p != player) == 0)
                    {
                        break;
                    }
                }
                spawnPos = GetGroundPosition(spawnPos);
            }

            private bool TryGetCenterOfFloorNearby(ref Vector3 spawnPos)
            {
                var buildingBlocks = Pool.Get<List<BuildingBlock>>();
                Vis.Entities(spawnPos, 2f, buildingBlocks, Layers.Mask.Construction);
                if (buildingBlocks.Count > 0)
                {
                    var position = spawnPos;
                    var closestBuildingBlock = buildingBlocks
                            .Where(x => !x.ShortPrefabName.Contains("wall"))
                            .OrderBy(x => (x.transform.position - position).magnitude).FirstOrDefault();
                    if (closestBuildingBlock != null)
                    {
                        var worldSpaceBounds = closestBuildingBlock.WorldSpaceBounds();
                        spawnPos = worldSpaceBounds.position;
                        spawnPos.y += worldSpaceBounds.extents.y;
                        Pool.FreeUnmanaged(ref buildingBlocks);
                        return true;
                    }
                }
                Pool.FreeUnmanaged(ref buildingBlocks);
                return false;
            }

            #endregion TryGetVehicleParams
        }

        public abstract class FuelVehicleSettings : BaseVehicleSettings, IFuelVehicle
        {
            public int SpawnFuelAmount { get; set; }
            public bool RefundFuelOnKill { get; set; } = true;
            public bool RefundFuelOnCrash { get; set; } = true;

            public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                if (justCreated)
                {
                    TryGiveFuel(entity, this);
                }
                base.SetupVehicle(entity, vehicle, player, justCreated);
            }

            protected override bool CanRefundFuel(bool isCrash, bool isUnload)
            {
                return isUnload || (isCrash ? RefundFuelOnCrash : RefundFuelOnKill);
            }
        }

        public abstract class InventoryVehicleSettings : BaseVehicleSettings, IInventoryVehicle
        {
            public bool RefundInventoryOnKill { get; set; } = true;
            public bool RefundInventoryOnCrash { get; set; } = true;
            public bool DropInventoryOnRecall { get; set; }

            protected override bool CanDropInventory()
            {
                return DropInventoryOnRecall;
            }

            protected override bool CanRefundInventory(bool isCrash, bool isUnload)
            {
                return isUnload || (isCrash ? RefundInventoryOnCrash : RefundInventoryOnKill);
            }
        }

        public abstract class InvFuelVehicleSettings : BaseVehicleSettings, IFuelVehicle, IInventoryVehicle
        {
            public int SpawnFuelAmount { get; set; }
            public bool RefundFuelOnKill { get; set; } = true;
            public bool RefundFuelOnCrash { get; set; } = true;
            public bool RefundInventoryOnKill { get; set; } = true;
            public bool RefundInventoryOnCrash { get; set; } = true;
            public bool DropInventoryOnRecall { get; set; }

            public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                if (justCreated)
                {
                    TryGiveFuel(entity, this);
                }
                base.SetupVehicle(entity, vehicle, player, justCreated);
            }

            protected override bool CanDropInventory()
            {
                return DropInventoryOnRecall;
            }

            protected override bool CanRefundInventory(bool isCrash, bool isUnload)
            {
                return isUnload || (isCrash ? RefundInventoryOnCrash : RefundInventoryOnKill);
            }

            protected override bool CanRefundFuel(bool isCrash, bool isUnload)
            {
                return isUnload || (isCrash ? RefundFuelOnCrash : RefundFuelOnKill);
            }
        }

        #endregion BaseSettings

        #region Interface

        public interface IFuelVehicle
        {
            [JsonProperty(PropertyName = "Amount Of Fuel To Spawn", Order = 20)]
            int SpawnFuelAmount { get; set; }

            [JsonProperty(PropertyName = "Refund Fuel On Kill", Order = 21)]
            bool RefundFuelOnKill { get; set; }

            [JsonProperty(PropertyName = "Refund Fuel On Crash", Order = 22)]
            bool RefundFuelOnCrash { get; set; }
        }

        public interface IInventoryVehicle
        {
            [JsonProperty(PropertyName = "Refund Inventory On Kill", Order = 30)]
            bool RefundInventoryOnKill { get; set; }

            [JsonProperty(PropertyName = "Refund Inventory On Crash", Order = 31)]
            bool RefundInventoryOnCrash { get; set; }

            [JsonProperty(PropertyName = "Drop Inventory Items When Vehicle Recall", Order = 49)]
            bool DropInventoryOnRecall { get; set; }
        }

        public interface IModularVehicle
        {
            [JsonProperty(PropertyName = "Refund Engine Items On Kill", Order = 40)]
            bool RefundEngineOnKill { get; set; }

            [JsonProperty(PropertyName = "Refund Engine Items On Crash", Order = 41)]
            bool RefundEngineOnCrash { get; set; }

            [JsonProperty(PropertyName = "Refund Module Items On Kill", Order = 42)]
            bool RefundModuleOnKill { get; set; }

            [JsonProperty(PropertyName = "Refund Module Items On Crash", Order = 43)]
            bool RefundModuleOnCrash { get; set; }
        }

        public interface IAmmoVehicle
        {
            [JsonProperty(PropertyName = "Amount Of Ammo To Spawn", Order = 20)]
            int SpawnAmmoAmount { get; set; }
        }

        public interface ITrainVehicle
        {
        }

        #endregion Interface

        #region Struct

        public struct CooldownPermission
        {
            public double spawnCooldown;
            public double recallCooldown;
        }

        public struct ModuleItem
        {
            public string shortName;
            public float healthPercentage;
        }

        public struct EngineItem
        {
            public string shortName;
            public float conditionPercentage;
        }

        public struct PriceInfo
        {
            public int amount;
            public string displayName;
        }

        public struct TrainComponent
        {
            public TrainComponentType type;
        }

        #endregion Struct

        #region VehicleSettings

        public class PedalBikeSettings : BaseVehicleSettings
        {
        }

        public class PedalTrikeSettings : BaseVehicleSettings
        {
        }

        public class MotorBikeSettings : FuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Bike)?.GetFuelSystem();
            }
        }

        public class MotorBikeSidecarSettings : FuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Bike)?.GetFuelSystem();
            }
        }

        public class AtvSettings : FuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Bike)?.GetFuelSystem();
            }
        }

        public class RaceSofaSettings : FuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Bike)?.GetFuelSystem();
            }
        }

        public class KayakSettings : BaseVehicleSettings
        {
            public override bool IsWaterVehicle => true;
        }

        public class SedanSettings : BaseVehicleSettings
        {
        }

        public class ChinookSettings : BaseVehicleSettings
        {
        }

        public class RowboatSettings : InvFuelVehicleSettings
        {
            public override bool IsWaterVehicle => true;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as MotorRowboat)?.GetFuelSystem();
            }

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as MotorRowboat)?.storageUnitInstance.Get(true)?.inventory;
            }
        }

        public class RhibSettings : RowboatSettings
        {
        }

        public class TugboatSettings : FuelVehicleSettings
        {
            public override bool IsWaterVehicle => true;

            [JsonProperty(PropertyName = "Speed Multiplier")]
            public float speedMultiplier { get; set; } = 1;

            [JsonProperty(PropertyName = "Auto Auth Teammates on spawn/recall")]
            public bool autoAuth { get; set; } = true;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as MotorRowboat)?.GetFuelSystem();
            }
        }


        public class HotAirBalloonSettings : InvFuelVehicleSettings
        {
            protected override float GetSpawnRotationAngle()
            {
                return 180f;
            }

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as HotAirBalloon)?.fuelSystem;
            }

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as HotAirBalloon)?.storageUnitInstance.Get(true)?.inventory;
            }
        }

        public class ArmoredHotAirBalloonSettings : HotAirBalloonSettings
        {
        }

        public class MiniCopterSettings : FuelVehicleSettings
        {
            public override bool IsFightVehicle => true;

            [JsonProperty("Rotation Scale")]
            public float rotationScale = 1.0f;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.25f;

            [JsonProperty("Seconds to pause flyhack when dismount from Mini Copter.")]
            public int flyHackPause;

            [JsonProperty("Instant Engine Start-up (instant take-off)")]
            public bool instantTakeoff;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Minicopter)?.GetFuelSystem();
            }
        }

        public class AttackHelicopterSettings : InvFuelVehicleSettings
        {
            private const int HV_AMMO_ITEM_ID = -1841918730;
            private const int INCENDIARY_AMMO_ITEM_ID = 1638322904;
            private const int FLARE_ITEM_ID = 304481038;

            [JsonProperty("HV Rocket Spawn Amount")]
            public int HVSpawnAmmoAmount { get; set; }

            [JsonProperty("Incendiary Rocket Spawn Amount")]
            public int IncendiarySpawnAmmoAmount { get; set; }

            [JsonProperty("Flare Spawn Amount")]
            public int FlareSpawnAmmoAmount { get; set; }

            public override bool IsFightVehicle => true;

            [JsonProperty("Rotation Scale")]
            public float rotationScale = 1.0f;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.33f;

            [JsonProperty("Seconds to pause flyhack when dismount from Attack Helicopter.")]
            public int flyHackPause;

            [JsonProperty("Instant Engine Start-up (instant take-off)")]
            public bool instantTakeoff;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as AttackHelicopter)?.GetFuelSystem();
            }

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as AttackHelicopter)?.GetRockets().inventory;
                yield return (entity as AttackHelicopter)?.GetTurret().inventory;
            }

            public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                if (justCreated)
                {
                    TryGiveAmmo(entity);
                }
                base.SetupVehicle(entity, vehicle, player, justCreated);
            }

            private void TryGiveAmmo(BaseEntity entity)
            {
                if (entity == null || (HVSpawnAmmoAmount <= 0 && IncendiarySpawnAmmoAmount <= 0 && FlareSpawnAmmoAmount <= 0))
                {
                    return;
                }

                AttackHelicopterRockets ammoContainer = (entity as AttackHelicopter)?.GetRockets();

                if (ammoContainer == null || ammoContainer.inventory == null) return;

                Item ammoItem = ItemManager.CreateByItemID(HV_AMMO_ITEM_ID, HVSpawnAmmoAmount);
                if (!ammoItem.MoveToContainer(ammoContainer.inventory))
                {
                    ammoItem.Remove();
                }

                ammoItem = ItemManager.CreateByItemID(INCENDIARY_AMMO_ITEM_ID, IncendiarySpawnAmmoAmount);
                if (!ammoItem.MoveToContainer(ammoContainer.inventory))
                {
                    ammoItem.Remove();
                }

                ammoItem = ItemManager.CreateByItemID(FLARE_ITEM_ID, FlareSpawnAmmoAmount);
                if (!ammoItem.MoveToContainer(ammoContainer.inventory))
                {
                    ammoItem.Remove();
                }
            }
        }

        public class WaterBirdSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;

            public override bool IsWaterVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class WarBirdSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class LittleBirdSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class FighterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class OldFighterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class FighterBusSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class WarBusSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class AirBusSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class PatrolHelicopterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class RustWingSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class RustWingDetailedSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class RustWingDetailedOldSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class TinFighterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class TinFighterDetailedSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class TinFighterDetailedOldSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class MarsFighterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class MarsFighterDetailedSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class SkyPlaneSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class SkyBoatSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;

            public override bool IsWaterVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class TwistedTruckSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class TrainWreckSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class TrainWreckerSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class SantaSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class WarSantaSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class WitchSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class MagicCarpetSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class Ah69tSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class Ah69rSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class Ah69aSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class MavikSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class HeavyFighterSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class PorcelainCommanderSettings : BaseVehicleSettings
        {
            public override bool IsFightVehicle => true;
            
            public override bool CustomVehicle => true;
        }

        public class DuneBuggieSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class DuneTruckArmedSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class DuneTruckUnArmedSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class DoomsDayDiscoVanSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class ForkLiftSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class LawnMowerSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class ChariotSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class SoulHarvesterSettings : BaseVehicleSettings
        {
            public override bool CustomVehicle => true;
        }

        public class TransportHelicopterSettings : FuelVehicleSettings
        {
            public override bool IsFightVehicle => true;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.25f;

            [JsonProperty("Rotation Scale")]
            public float rotationScale = 1.0f;

            [JsonProperty("Seconds to pause flyhack when dismount from Transport Scrap Helicopter.")]
            public int flyHackPause;
            
            [JsonProperty("Instant Engine Start-up (instant take-off)")]
            public bool instantTakeoff;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as ScrapTransportHelicopter)?.GetFuelSystem();
            }
        }

        public class RidableHorseSettings : InventoryVehicleSettings
        {
            [JsonProperty("Spawn with Double Saddle")]
            public bool IsDoubleSaddle { get; set; }

            [JsonProperty("Breeds")]
            public List<string> Breeds { get; set; }

            [JsonIgnore]
            public Dictionary<string, int> BreedsRef = new Dictionary<string, int>()
            {
                ["Appalosa"] = 0,
                ["Bay"] = 1,
                ["Buckskin"] = 2,
                ["Chestnut"] = 3,
                ["Dapple Grey"] = 4,
                ["Piebald"] = 5,
                ["Pinto"] = 6,
                ["Red Roan"] = 7,
                ["White Thoroughbred"] = 8,
                ["Black Thoroughbred"] = 9
            };

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as RidableHorse2)?.storageInventory;
            }

            public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                base.PostRecallVehicle(player, vehicle, position, rotation);

                var ridableHorse = vehicle.Entity as RidableHorse2;
                if (ridableHorse != null)
                {
                    ridableHorse.TryLeaveHitch();
                    // Broke on update, not sure what the replacement is or if one is needed
                    // ridableHorse.DropToGround(ridableHorse.transform.position, ridableHorse.transform.rotation, true); //ridableHorse.UpdateDropToGroundForDuration(2f);
                }
            }

            protected override void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, out Vector3 spawnPos, out Quaternion spawnRot)
            {
                base.CorrectPositionAndRotation(player, vehicle, original, rotation, out spawnPos, out spawnRot);
                spawnPos += Vector3.up * 0.3f;
            }
        }

        // Only work cart (TrainEngine)
        public class WorkCartSettings : FuelVehicleSettings
        {
            public override bool IsTrainVehicle => true;

            public bool IsConnectableEngine(TrainEngine trainEngine)
            {
                return trainEngine.frontCoupling != null && trainEngine.rearCoupling != null;
            }

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as TrainEngine)?.GetFuelSystem();
            }

            public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                base.PostRecallVehicle(player, vehicle, position, rotation);
                var trainEngine = vehicle.Entity as TrainEngine;
                if (trainEngine != null)
                {
                    TryMoveToTrainTrackNear(trainEngine);
                }
            }

            protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, out string reason, out Vector3 original, out Quaternion rotation)
            {
                return !base.TryGetPositionAndRotation(player, vehicle, out reason, out original, out rotation)
                       || TryGetTrainCarPositionAndRotation(player, vehicle, ref reason, ref original, ref rotation);
            }
        }

        public class MagnetCraneSettings : FuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as MagnetCrane)?.GetFuelSystem();
            }
        }

        public class SubmarineSoloSettings : InvFuelVehicleSettings, IAmmoVehicle
        {
            private const int AMMO_ITEM_ID = -1671551935;

            public int SpawnAmmoAmount { get; set; }
            public override bool IsWaterVehicle => true;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as BaseSubmarine)?.GetFuelSystem();
            }

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as BaseSubmarine)?.GetItemContainer()?.inventory;
                yield return (entity as BaseSubmarine)?.GetTorpedoContainer()?.inventory;
            }

            public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                if (justCreated)
                {
                    TryGiveAmmo(entity);
                }
                base.SetupVehicle(entity, vehicle, player, justCreated);
            }

            private void TryGiveAmmo(BaseEntity entity)
            {
                if (entity == null || SpawnAmmoAmount <= 0)
                {
                    return;
                }
                var ammoContainer = (entity as BaseSubmarine)?.GetTorpedoContainer();

                if (ammoContainer == null || ammoContainer.inventory == null) return;

                var ammoItem = ItemManager.CreateByItemID(AMMO_ITEM_ID, SpawnAmmoAmount);
                if (!ammoItem.MoveToContainer(ammoContainer.inventory))
                {
                    ammoItem.Remove();
                }
            }
        }

        public class SubmarineDuoSettings : SubmarineSoloSettings
        {
        }

        public class SnowmobileSettings : InvFuelVehicleSettings
        {
            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as Snowmobile)?.GetFuelSystem();
            }

            protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity)
            {
                yield return (entity as Snowmobile)?.GetItemContainer()?.inventory;
            }
        }

        public class ModularVehicleSettings : InvFuelVehicleSettings, IModularVehicle
        {
            #region Properties

            public bool RefundEngineOnKill { get; set; } = true;
            public bool RefundEngineOnCrash { get; set; } = true;
            public bool RefundModuleOnKill { get; set; } = true;
            public bool RefundModuleOnCrash { get; set; } = true;

            [JsonProperty(PropertyName = "Chassis Type (Small, Medium, Large)", Order = 50)]
            public ChassisType ChassisType { get; set; } = ChassisType.Small;

            [JsonProperty(PropertyName = "Vehicle Module Items", Order = 51)]
            public List<ModuleItem> ModuleItems { get; set; } = new List<ModuleItem>();

            [JsonProperty(PropertyName = "Vehicle Engine Items", Order = 52)]
            public List<EngineItem> EngineItems { get; set; } = new List<EngineItem>();

            #endregion Properties

            #region ModuleItems

            private List<ModuleItem> _validModuleItems;

            public IEnumerable<ModuleItem> ValidModuleItems
            {
                get
                {
                    if (_validModuleItems == null)
                    {
                        _validModuleItems = new List<ModuleItem>();
                        foreach (var modularItem in ModuleItems)
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(modularItem.shortName);
                            if (itemDefinition != null)
                            {
                                var itemModVehicleModule = itemDefinition.GetComponent<ItemModVehicleModule>();
                                if (itemModVehicleModule == null || !itemModVehicleModule.entityPrefab.isValid)
                                {
                                    Instance.PrintError($"'{modularItem}' is not a valid vehicle module");
                                    continue;
                                }
                                _validModuleItems.Add(modularItem);
                            }
                        }
                    }
                    return _validModuleItems;
                }
            }

            public IEnumerable<Item> CreateModuleItems()
            {
                foreach (var moduleItem in ValidModuleItems)
                {
                    var item = ItemManager.CreateByName(moduleItem.shortName);
                    if (item != null)
                    {
                        item.condition = item.maxCondition * (moduleItem.healthPercentage / 100f);
                        item.MarkDirty();
                        yield return item;
                    }
                }
            }

            #endregion ModuleItems

            #region EngineItems

            private List<EngineItem> _validEngineItems;

            public IEnumerable<EngineItem> ValidEngineItems
            {
                get
                {
                    if (_validEngineItems == null)
                    {
                        _validEngineItems = new List<EngineItem>();
                        foreach (var modularItem in EngineItems)
                        {
                            var itemDefinition = ItemManager.FindItemDefinition(modularItem.shortName);
                            if (itemDefinition != null)
                            {
                                var itemModEngineItem = itemDefinition.GetComponent<ItemModEngineItem>();
                                if (itemModEngineItem == null)
                                {
                                    Instance.PrintError($"'{modularItem}' is not a valid engine item");
                                    continue;
                                }
                                _validEngineItems.Add(modularItem);
                            }
                        }
                    }
                    return _validEngineItems;
                }
            }

            public IEnumerable<Item> CreateEngineItems()
            {
                foreach (var engineItem in ValidEngineItems)
                {
                    var item = ItemManager.CreateByName(engineItem.shortName);
                    if (item != null)
                    {
                        item.condition = item.maxCondition * (engineItem.conditionPercentage / 100f);
                        item.MarkDirty();
                        yield return item;
                    }
                }
            }

            #endregion EngineItems

            public override bool IsNormalVehicle => false;
            public override bool IsModularVehicle => true;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as ModularCar)?.GetFuelSystem();
            }

            #region Spawn

            protected override string GetVehiclePrefab(string vehicleType)
            {
                switch (ChassisType)
                {
                    case ChassisType.Small:
                        return PREFAB_CHASSIS_SMALL;
                    case ChassisType.Medium:
                        return PREFAB_CHASSIS_MEDIUM;
                    case ChassisType.Large:
                        return PREFAB_CHASSIS_LARGE;
                    default:
                        return null;
                }
            }

            #region Setup

            public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated = true)
            {
                var modularCar = entity as ModularCar;
                if (modularCar != null)
                {
                    if (ValidModuleItems.Any())
                    {
                        AttacheVehicleModules(modularCar, vehicle);
                    }
                    if (ValidEngineItems.Any())
                    {
                        Instance.NextTick(() =>
                        {
                            AddItemsToVehicleEngine(modularCar, vehicle);
                        });
                    }
                }
                base.SetupVehicle(entity, vehicle, player, justCreated);
            }

            #endregion Setup

            #endregion Spawn

            #region Recall

            public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                base.PreRecallVehicle(player, vehicle, position, rotation);

                if (vehicle.Entity is ModularCar)
                {
                    var modularCarGarages = Pool.Get<List<ModularCarGarage>>();
                    Vis.Entities(vehicle.Entity.transform.position, 3f, modularCarGarages, Layers.Mask.Deployed | Layers.Mask.Default);
                    var modularCarGarage = modularCarGarages.FirstOrDefault(x => x.carOccupant == vehicle.Entity);
                    Pool.FreeUnmanaged(ref modularCarGarages);
                    if (modularCarGarage != null)
                    {
                        modularCarGarage.enabled = false;
                        modularCarGarage.ReleaseOccupant();
                        modularCarGarage.Invoke(() => modularCarGarage.enabled = true, 0.25f);
                    }
                }
            }

            #region DropInventory

            protected override DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle)
            {
                var modularCar = vehicle.Entity as ModularCar;
                if (modularCar != null)
                {
                    foreach (var moduleEntity in modularCar.AttachedModuleEntities)
                    {
                        if (moduleEntity is VehicleModuleEngine)
                        {
                            continue;
                        }
                        var moduleStorage = moduleEntity as VehicleModuleStorage;
                        if (moduleStorage != null)
                        {
                            return moduleStorage.GetContainer()?.inventory?.Drop(PREFAB_ITEM_DROP, vehicle.Entity.GetDropPosition(), vehicle.Entity.transform.rotation, 0);
                        }
                    }
                }
                return null;
            }

            #endregion DropInventory

            #endregion Recall

            #region Refund

            private void GetRefundStatus(bool isCrash, bool isUnload, out bool refundFuel, out bool refundInventory, out bool refundEngine, out bool refundModule)
            {
                if (isUnload)
                {
                    refundFuel = refundInventory = refundEngine = refundModule = true;
                    return;
                }
                refundFuel = isCrash ? RefundFuelOnCrash : RefundFuelOnKill;
                refundInventory = isCrash ? RefundInventoryOnCrash : RefundInventoryOnKill;
                refundEngine = isCrash ? RefundEngineOnCrash : RefundEngineOnKill;
                refundModule = isCrash ? RefundModuleOnCrash : RefundModuleOnKill;
            }

            protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload)
            {
                var modularCar = vehicle.Entity as ModularCar;
                if (modularCar != null)
                {
                    bool refundFuel, refundInventory, refundEngine, refundModule;
                    GetRefundStatus(isCrash, isUnload, out refundFuel, out refundInventory, out refundEngine, out refundModule);

                    foreach (var moduleEntity in modularCar.AttachedModuleEntities)
                    {
                        if (refundEngine)
                        {
                            var moduleEngine = moduleEntity as VehicleModuleEngine;
                            if (moduleEngine != null)
                            {
                                var engineContainer = moduleEngine.GetContainer()?.inventory;
                                if (engineContainer != null)
                                {
                                    items.AddRange(engineContainer.itemList);
                                }
                                continue;
                            }
                        }
                        if (refundInventory)
                        {
                            var moduleStorage = moduleEntity as VehicleModuleStorage;
                            if (moduleStorage != null && !(moduleEntity is VehicleModuleEngine))
                            {
                                var storageContainer = moduleStorage.GetContainer()?.inventory;
                                if (storageContainer != null)
                                {
                                    items.AddRange(storageContainer.itemList);
                                }
                            }
                        }
                    }
                    if (refundFuel)
                    {
                        var fuelSystem = GetFuelSystem(modularCar);
                        if (fuelSystem is EntityFuelSystem entityFuelSystem)
                        {
                            var fuelContainer = entityFuelSystem.GetFuelContainer()?.inventory;
                            if (fuelContainer != null)
                            {
                                items.AddRange(fuelContainer.itemList);
                            }
                        }
                    }
                    if (refundModule)
                    {
                        var moduleContainer = modularCar.Inventory?.ModuleContainer;
                        if (moduleContainer != null)
                        {
                            items.AddRange(moduleContainer.itemList);
                        }
                    }
                    //var chassisContainer = modularCar.Inventory?.ChassisContainer;
                    //if (chassisContainer != null)
                    //{
                    //    collect.AddRange(chassisContainer.itemList);
                    //}
                }
            }

            #endregion Refund

            #region VehicleModules

            private void AttacheVehicleModules(ModularCar modularCar, Vehicle vehicle)
            {
                foreach (var moduleItem in CreateModuleItems())
                {
                    if (!modularCar.TryAddModule(moduleItem))
                    {
                        Instance?.PrintError($"Module item '{moduleItem.info.shortname}' in '{vehicle.VehicleType}' cannot be attached to the vehicle");
                        moduleItem.Remove();
                    }
                }
            }

            private void AddItemsToVehicleEngine(ModularCar modularCar, Vehicle vehicle)
            {
                if (modularCar == null || modularCar.IsDestroyed)
                {
                    return;
                }
                foreach (var moduleEntity in modularCar.AttachedModuleEntities)
                {
                    var vehicleModuleEngine = moduleEntity as VehicleModuleEngine;
                    if (vehicleModuleEngine != null)
                    {
                        var engineInventory = vehicleModuleEngine.GetContainer()?.inventory;
                        if (engineInventory != null)
                        {
                            foreach (var engineItem in CreateEngineItems())
                            {
                                var moved = false;
                                for (var i = 0; i < engineInventory.capacity; i++)
                                {
                                    if (engineItem.MoveToContainer(engineInventory, i, false))
                                    {
                                        moved = true;
                                        break;
                                    }
                                }
                                if (!moved)
                                {
                                    Instance?.PrintError($"Engine item '{engineItem.info.shortname}' in '{vehicle.VehicleType}' cannot be move to the vehicle engine inventory");
                                    engineItem.Remove();
                                    engineItem.DoRemove();
                                }
                            }
                        }
                    }
                }
            }

            #endregion VehicleModules
        }

        public class TrainVehicleSettings : FuelVehicleSettings, ITrainVehicle
        {
            #region Properties

            [JsonProperty(PropertyName = "Train Components", Order = 50)]
            public List<TrainComponent> TrainComponents { get; set; } = new List<TrainComponent>();

            #endregion Properties

            public override bool IsNormalVehicle => false;
            public override bool IsTrainVehicle => true;
            public override bool IsConnectableVehicle => true;

            protected override IFuelSystem GetFuelSystem(BaseEntity entity)
            {
                return (entity as TrainCar)?.GetFuelSystem();
            }

            protected override string GetVehiclePrefab(string vehicleType)
            {
                return TrainComponents.Count > 0 ? GetTrainVehiclePrefab(TrainComponents[0].type) : base.GetVehiclePrefab(vehicleType);
            }

            protected override string GetVehicleCustomPrefab(string vehicleType)
            {
                if (!configData.global.useCustomVehicles) return string.Empty;
                return TrainComponents.Count > 0 ? GetTrainVehiclePrefab(TrainComponents[0].type) : base.GetVehicleCustomPrefab(vehicleType);
            }

            #region Spawn

            private static string GetTrainVehiclePrefab(TrainComponentType componentType)
            {
                switch (componentType)
                {
                    case TrainComponentType.Engine:
                        return PREFAB_TRAINENGINE;
                    case TrainComponentType.CoveredEngine:
                        return PREFAB_TRAINENGINE_COVERED;
                    case TrainComponentType.Locomotive:
                        return PREFAB_TRAINENGINE_LOCOMOTIVE;
                    case TrainComponentType.WagonA:
                        return PREFAB_TRAINWAGON_A;
                    case TrainComponentType.WagonB:
                        return PREFAB_TRAINWAGON_B;
                    case TrainComponentType.WagonC:
                        return PREFAB_TRAINWAGON_C;
                    case TrainComponentType.Unloadable:
                        return PREFAB_TRAINWAGON_UNLOADABLE;
                    case TrainComponentType.UnloadableLoot:
                        return PREFAB_TRAINWAGON_UNLOADABLE_LOOT;
                    case TrainComponentType.UnloadableFuel:
                        return PREFAB_TRAINWAGON_UNLOADABLE_FUEL;
                    case TrainComponentType.Caboose:
                        return PREFAB_CABOOSE;
                    default:
                        return null;
                }
            }

            public override BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                TrainCar prevTrainCar = null, primaryTrainCar = null;
                foreach (var component in TrainComponents)
                {
                    var prefab = GetTrainVehiclePrefab(component.type);
                    if (string.IsNullOrEmpty(prefab))
                    {
                        throw new ArgumentException($"Prefab not found for {vehicle.VehicleType}({component.type})");
                    }
                    float distResult;
                    TrainTrackSpline splineResult;
                    if (prevTrainCar == null)
                    {
                        if (TrainTrackSpline.TryFindTrackNear(position, 20f, out splineResult, out distResult))
                        {
                            position = splineResult.GetPosition(distResult);
                            prevTrainCar = GameManager.server.CreateEntity(prefab, position, rotation) as TrainCar;
                            if (prevTrainCar == null)
                            {
                                continue;
                            }
                            PreSetupVehicle(prevTrainCar, vehicle, player);
                            prevTrainCar.Spawn();
                            prevTrainCar.CancelInvoke(prevTrainCar.KillMessage);
                            SetupVehicle(prevTrainCar, vehicle, player);
                        }
                    }
                    else
                    {
                        var newTrainCar = GameManager.server.CreateEntity(prefab, prevTrainCar.transform.position, prevTrainCar.transform.rotation) as TrainCar;
                        if (newTrainCar == null)
                        {
                            continue;
                        }

                        position += prevTrainCar.transform.rotation * (newTrainCar.bounds.center - Vector3.forward * (newTrainCar.bounds.extents.z + prevTrainCar.bounds.extents.z));
                        if (TrainTrackSpline.TryFindTrackNear(position, 20f, out splineResult, out distResult))
                        {
                            position = splineResult.GetPosition(distResult);
                            newTrainCar.transform.position = position;

                            PreSetupVehicle(newTrainCar, vehicle, player);
                            newTrainCar.Spawn();
                            newTrainCar.CancelInvoke(newTrainCar.KillMessage);
                            SetupVehicle(newTrainCar, vehicle, player);

                            float minSplineDist;
                            var distance = prevTrainCar.RearTrackSection.GetDistance(position, 1f, out minSplineDist);
                            var preferredAltTrack = prevTrainCar.RearTrackSection != prevTrainCar.FrontTrackSection ? prevTrainCar.RearTrackSection : null;
                            newTrainCar.MoveFrontWheelsAlongTrackSpline(prevTrainCar.RearTrackSection, minSplineDist, distance, preferredAltTrack, TrainTrackSpline.TrackSelection.Default);

                            newTrainCar.coupling.frontCoupling.TryCouple(prevTrainCar.coupling.rearCoupling, true);
                            prevTrainCar = newTrainCar;
                        }
                    }
                    if (primaryTrainCar == null)
                    {
                        primaryTrainCar = prevTrainCar;
                    }
                }
                if (primaryTrainCar == null || primaryTrainCar.IsDestroyed)
                {
                    Instance.Print(player, Instance.Lang("NotSpawnedOrRecalled", player.UserIDString, DisplayName));
                    return null;
                }
                Instance.CacheVehicleEntity(primaryTrainCar, vehicle, player);
                return primaryTrainCar;
            }

            #endregion Spawn

            #region Recall

            public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                base.PreRecallVehicle(player, vehicle, position, rotation);
                var trainCar = vehicle.Entity as TrainCar;
                if (trainCar != null)
                {
                    trainCar.coupling.Uncouple(true);
                    trainCar.coupling.Uncouple(false);
                }
            }

            public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation)
            {
                base.PostRecallVehicle(player, vehicle, position, rotation);
                var trainCar = vehicle.Entity as TrainCar;
                if (trainCar != null)
                {
                    TryMoveToTrainTrackNear(trainCar);
                }
            }

            #endregion Recall

            #region Refund

            protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload)
            {
                // Refund primary engine fuel only
                if (!CanRefundFuel(isCrash, isUnload)) return;

                var trainCar = vehicle.Entity as TrainCar;

                if (trainCar == null) return;
                var fuelSystem = GetFuelSystem(trainCar);

                if (fuelSystem is EntityFuelSystem entityFuelSystem)
                {
                    var fuelContainer = entityFuelSystem.GetFuelContainer()?.inventory;

                    if (fuelContainer != null)
                    {
                        items.AddRange(fuelContainer.itemList);
                    }
                }
            }

            #endregion Refund

            #region TryGetVehicleParams

            protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, out string reason, out Vector3 original, out Quaternion rotation)
            {
                if (!base.TryGetPositionAndRotation(player, vehicle, out reason, out original, out rotation)) return true;

                return TryGetTrainCarPositionAndRotation(player, vehicle, ref reason, ref original, ref rotation);
            }

            // protected override void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, out Vector3 spawnPos, out Quaternion spawnRot)
            // {
            //     base.CorrectPositionAndRotation(player, vehicle, original, rotation, out spawnPos, out spawnRot);
            //     // No rotation on recall
            //     if (vehicle.Entity != null)
            //     {
            //         spawnRot = vehicle.Entity.transform.rotation;
            //     } 
            // }

            #endregion TryGetVehicleParams
        }

        #endregion VehicleSettings

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                PreprocessOldConfig();
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        private void UpdateConfigValues()
        {
            if (configData.version >= Version) return;
            if (configData.version <= default(VersionNumber))
            {
                string prefix, prefixColor;
                if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                {
                    configData.chat.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                }
            }
            if (configData.version <= new VersionNumber(1, 7, 3))
            {
                configData.normalVehicles.sedan.MinDistanceForPlayers = 3f;
                configData.normalVehicles.chinook.MinDistanceForPlayers = 5f;
                configData.normalVehicles.rowboat.MinDistanceForPlayers = 2f;
                configData.normalVehicles.rhib.MinDistanceForPlayers = 3f;
                configData.normalVehicles.hotAirBalloon.MinDistanceForPlayers = 4f;
                configData.normalVehicles.armoredHotAirBalloon.MinDistanceForPlayers = 4f;
                configData.normalVehicles.ridableHorse.MinDistanceForPlayers = 1f;
                configData.normalVehicles.miniCopter.MinDistanceForPlayers = 2f;
                configData.normalVehicles.attackHelicopter.MinDistanceForPlayers = 2f;
                configData.normalVehicles.transportHelicopter.MinDistanceForPlayers = 4f;
                foreach (var entry in configData.modularVehicles)
                {
                    switch (entry.Value.ChassisType)
                    {
                        case ChassisType.Small:
                            entry.Value.MinDistanceForPlayers = 2f;
                            break;

                        case ChassisType.Medium:
                            entry.Value.MinDistanceForPlayers = 2.5f;
                            break;

                        case ChassisType.Large:
                            entry.Value.MinDistanceForPlayers = 3f;
                            break;

                        default:
                            continue;
                    }
                }
            }
            if (configData.version >= new VersionNumber(1, 7, 17) && configData.version <= new VersionNumber(1, 7, 18))
            {
                LoadData();
                foreach (var data in storedData.playerData)
                {
                    Vehicle vehicle;
                    if (data.Value.TryGetValue("SubmarineDouble", out vehicle))
                    {
                        data.Value.Remove("SubmarineDouble");
                        data.Value.Add(nameof(NormalVehicleType.SubmarineDuo), vehicle);
                    }
                }
                SaveData();
            }

            if (configData.version < new VersionNumber(1, 8, 0))
            {
                configData.normalVehicles.ridableHorse.Breeds = new List<string>
                {
                    "Appalosa", "Bay", "Buckskin", "Chestnut", "Dapple Grey", "Piebald", "Pinto", "Red Roan", "White Thoroughbred", "Black Thoroughbred"
                };
                configData.normalVehicles.ridableHorse.IsDoubleSaddle = false;
            }

            if (configData.version < new VersionNumber(1, 8, 3))
            {
                configData.normalVehicles.tugboat.BypassCostPermission = "vehiclelicence.tugfree";
                configData.normalVehicles.sedan.BypassCostPermission = "vehiclelicence.sedanfree";
                configData.normalVehicles.chinook.BypassCostPermission = "vehiclelicence.chinookfree";
                configData.normalVehicles.rowboat.BypassCostPermission = "vehiclelicence.rowboatfree";
                configData.normalVehicles.rhib.BypassCostPermission = "vehiclelicence.rhibfree";
                configData.normalVehicles.hotAirBalloon.BypassCostPermission = "vehiclelicence.hotairballoonfree";
                configData.normalVehicles.armoredHotAirBalloon.BypassCostPermission = "vehiclelicence.armoredhotairballoonfree";
                configData.normalVehicles.ridableHorse.BypassCostPermission = "vehiclelicence.ridablehorsefree";
                configData.normalVehicles.miniCopter.BypassCostPermission = "vehiclelicence.minicopterfree";
                configData.normalVehicles.attackHelicopter.BypassCostPermission = "vehiclelicence.attackhelicopterfree";
                configData.normalVehicles.transportHelicopter.BypassCostPermission = "vehiclelicence.transportcopterfree";
                configData.normalVehicles.workCart.BypassCostPermission = "vehiclelicence.workcartfree";
                configData.normalVehicles.sedanRail.BypassCostPermission = "vehiclelicence.sedanrailfree";
                configData.normalVehicles.magnetCrane.BypassCostPermission = "vehiclelicence.magnetcranefree";
                configData.normalVehicles.submarineSolo.BypassCostPermission = "vehiclelicence.submarinesolofree";
                configData.normalVehicles.submarineDuo.BypassCostPermission = "vehiclelicence.submarineduofree";
                configData.normalVehicles.snowmobile.BypassCostPermission = "vehiclelicence.snowmobilefree";
                configData.normalVehicles.tomahaSnowmobile.BypassCostPermission = "vehiclelicence.tomahasnowmobilefree";

                configData.modularVehicles["SmallCar"].BypassCostPermission = "vehiclelicence.smallmodularcarfree";
                configData.modularVehicles["MediumCar"].BypassCostPermission = "vehiclelicence.mediumodularcarfree";
                configData.modularVehicles["LargeCar"].BypassCostPermission = "vehiclelicence.largemodularcarfree";

                configData.trainVehicles["WorkCartAboveGround"].BypassCostPermission = "vehiclelicence.workcartabovegroundfree";
                configData.trainVehicles["WorkCartCovered"].BypassCostPermission = "vehiclelicence.coveredworkcartfree";
                configData.trainVehicles["CompleteTrain"].BypassCostPermission = "vehiclelicence.completetrainfree";
                configData.trainVehicles["Locomotive"].BypassCostPermission = "vehiclelicence.locomotivefree";
            }

            if (configData.version < new VersionNumber(1, 8, 6))
            {
                configData.normalVehicles.transportHelicopter.instantTakeoff = false;
                configData.global.preventPushing = false;
                configData.global.useCustomVehicles = false;
            }

            configData.version = Version;
            SaveConfig();
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue != null)
            {
                if (configValue is T)
                {
                    value = (T)configValue;
                    return true;
                }
                try
                {
                    value = Config.ConvertValue<T>(configValue);
                    return true;
                }
                catch (Exception ex)
                {
                    PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
                }
            }

            value = default(T);
            return false;
        }

        private void SetConfigValue(params object[] pathAndTrailingValue)
        {
            Config.Set(pathAndTrailingValue);
        }

        #region Preprocess Old Config

        private void PreprocessOldConfig()
        {
            var config = Config.ReadObject<JObject>();
            if (config == null)
            {
                return;
            }
            //Interface.Oxide.DataFileSystem.WriteObject(Name + "_old", jObject);
            VersionNumber oldVersion;
            if (!GetConfigVersionPre(config, out oldVersion)) return;
            if (oldVersion >= Version) return;
            if (oldVersion < new VersionNumber(1, 7, 35))
            {
                try
                {
                    if (config["Train Vehicle Settings"] == null)
                    {
                        config["Train Vehicle Settings"] = JObject.FromObject(new ConfigData().trainVehicles);
                    }
                    var workCartAboveGround = GetConfigValue(config, "Normal Vehicle Settings", "Work Cart Above Ground Vehicle");
                    if (workCartAboveGround != null)
                    {
                        var settings = workCartAboveGround.ToObject<TrainVehicleSettings>();
                        settings.TrainComponents = new List<TrainComponent>
                        {
                            new TrainComponent
                            {
                                type = TrainComponentType.Engine
                            }
                        };
                        config["Train Vehicle Settings"]["WorkCartAboveGround"] = JObject.FromObject(settings);
                    }
                    var coveredWorkCart = GetConfigValue(config, "Normal Vehicle Settings", "Covered Work Cart Vehicle");
                    if (coveredWorkCart != null)
                    {
                        var settings = coveredWorkCart.ToObject<TrainVehicleSettings>();
                        settings.TrainComponents = new List<TrainComponent>
                        {
                            new TrainComponent
                            {
                                type = TrainComponentType.CoveredEngine
                            }
                        };
                        config["Train Vehicle Settings"]["WorkCartCovered"] = JObject.FromObject(settings);
                    }
                }
                catch
                {
                    // ignored
                }
            }

            if (oldVersion < new VersionNumber(1, 7, 48))
            {
                try
                {
                    var locomotive = GetConfigValue(config, "Train Vehicle Settings", "Locomotive");
                    if (locomotive == null)
                    {
                        var settings = new TrainVehicleSettings
                        {
                            Purchasable = true,
                            DisplayName = "Locomotive",
                            Distance = 12,
                            MinDistanceForPlayers = 6,
                            UsePermission = true,
                            Permission = "vehiclelicence.locomotive",
                            Commands = new List<string>
                            {
                                "loco", "locomotive"
                            },
                            PurchasePrices = new Dictionary<string, PriceInfo>
                            {
                                ["scrap"] = new PriceInfo { amount = 2000, displayName = "Scrap" }
                            },
                            SpawnCooldown = 1800,
                            RecallCooldown = 30,
                            CooldownPermissions = new Dictionary<string, CooldownPermission>
                            {
                                ["vehiclelicence.vip"] = new CooldownPermission
                                {
                                    spawnCooldown = 900,
                                    recallCooldown = 10
                                }
                            },
                            TrainComponents = new List<TrainComponent>
                            {
                                new TrainComponent
                                {
                                    type = TrainComponentType.Locomotive
                                }
                            }
                        };
                        config["Train Vehicle Settings"]["Locomotive"] = JObject.FromObject(settings);
                    }
                }
                catch
                {
                    // Still ignored.
                }
            }
            Config.WriteObject(config);
            // Interface.Oxide.DataFileSystem.WriteObject(Name + "_new", jObject);
        }

        private JObject GetConfigValue(JObject config, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    return null;
                }

                for (var i = 1; i < path.Length; i++)
                {
                    var jObject = jToken as JObject;
                    if (jObject == null || !jObject.TryGetValue(path[i], out jToken))
                    {
                        return null;
                    }
                }
                return jToken as JObject;
            }
            catch (Exception ex)
            {
                PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
            }
            return null;
        }

        private bool GetConfigValuePre<T>(JObject config, out T value, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    value = default(T);
                    return false;
                }

                for (var i = 1; i < path.Length; i++)
                {
                    var jObject = jToken.ToObject<JObject>();

                    if (jObject != null && jObject.TryGetValue(path[i], out jToken)) continue;

                    value = default(T);
                    return false;
                }
                value = jToken.ToObject<T>();
                return true;
            }
            catch (Exception ex)
            {
                PrintError($"GetConfigValuePre ERROR: path: {string.Join("\\", path)}\n{ex}");
            }
            value = default(T);
            return false;
        }

        private void SetConfigValuePre(JObject config, object value, params string[] path)
        {
            if (path.Length < 1)
            {
                throw new ArgumentException("path is empty");
            }

            try
            {
                JToken jToken;
                if (!config.TryGetValue(path[0], out jToken))
                {
                    if (path.Length == 1)
                    {
                        jToken = JToken.FromObject(value);
                        config.Add(path[0], jToken);
                        return;
                    }
                    jToken = new JObject();
                    config.Add(path[0], jToken);
                }

                for (var i = 1; i < path.Length - 1; i++)
                {
                    var jObject = jToken as JObject;
                    if (jObject == null || !jObject.TryGetValue(path[i], out jToken))
                    {
                        jToken = new JObject();
                        jObject?.Add(path[i], jToken);
                    }
                }
                var targetToken = jToken as JObject;
                if (targetToken != null)
                {
                    targetToken[path[path.Length - 1]] = JToken.FromObject(value);
                }
                // (jToken as JObject)?.TryAdd(path[path.Length - 1], JToken.FromObject(value));
            }
            catch (Exception ex)
            {
                PrintError($"SetConfigValuePre ERROR: value: {value} path: {string.Join("\\", path)}\n{ex}");
            }
        }

        private bool GetConfigVersionPre(JObject config, out VersionNumber version)
        {
            try
            {
                JToken jToken;
                if (config.TryGetValue("Version", out jToken))
                {
                    version = jToken.ToObject<VersionNumber>();
                    return true;
                }
            }
            catch
            {
                // ignored
            }
            version = default(VersionNumber);
            return false;
        }

        #endregion Preprocess Old Config

        #endregion ConfigurationFile

        #region DataFile

        public StoredData storedData { get; private set; }

        public class StoredData
        {
            public readonly Dictionary<ulong, Dictionary<string, Vehicle>> playerData = new Dictionary<ulong, Dictionary<string, Vehicle>>();

            public IEnumerable<BaseEntity> ActiveVehicles(ulong playerId)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    yield break;
                }

                foreach (var vehicle in vehicles.Values)
                {
                    if (vehicle.Entity != null && !vehicle.Entity.IsDestroyed)
                    {
                        yield return vehicle.Entity;
                    }
                }
            }

            public Dictionary<string, Vehicle> GetPlayerVehicles(ulong playerId, bool readOnly = true)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    if (!readOnly)
                    {
                        vehicles = new Dictionary<string, Vehicle>();
                        playerData.Add(playerId, vehicles);
                        return vehicles;
                    }
                    return null;
                }
                return vehicles;
            }

            public bool IsVehiclePurchased(ulong playerId, string vehicleType, out Vehicle vehicle)
            {
                vehicle = GetVehicleLicense(playerId, vehicleType);
                if (vehicle == null)
                {
                    return false;
                }
                return true;
            }

            public Vehicle GetVehicleLicense(ulong playerId, string vehicleType)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    return null;
                }
                Vehicle vehicle;
                if (!vehicles.TryGetValue(vehicleType, out vehicle))
                {
                    return null;
                }
                return vehicle;
            }

            public bool HasVehicleLicense(ulong playerId, string vehicleType)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    return false;
                }
                return vehicles.ContainsKey(vehicleType);
            }

            public bool AddVehicleLicense(ulong playerId, string vehicleType)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    vehicles = new Dictionary<string, Vehicle>();
                    playerData.Add(playerId, vehicles);
                }
                if (vehicles.ContainsKey(vehicleType))
                {
                    return false;
                }
                vehicles.Add(vehicleType, Vehicle.Create(playerId, vehicleType));
                Instance.SaveData();
                return true;
            }

            public bool RemoveVehicleLicense(ulong playerId, string vehicleType)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    return false;
                }

                if (!vehicles.Remove(vehicleType))
                {
                    return false;
                }
                Instance.SaveData();
                return true;
            }

            public List<string> GetVehicleLicenseNames(ulong playerId)
            {
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    return new List<string>();
                }
                return vehicles.Keys.ToList();
            }

            public void PurchaseAllVehicles(ulong playerId)
            {
                var changed = false;
                Dictionary<string, Vehicle> vehicles;
                if (!playerData.TryGetValue(playerId, out vehicles))
                {
                    vehicles = new Dictionary<string, Vehicle>();
                    playerData.Add(playerId, vehicles);
                }
                foreach (var vehicleType in Instance.allVehicleSettings.Keys)
                {
                    if (!vehicles.ContainsKey(vehicleType))
                    {
                        vehicles.Add(vehicleType, Vehicle.Create(playerId, vehicleType));
                        changed = true;
                    }
                }

                if (changed)
                {
                    Instance.SaveData();
                }
            }

            public void AddLicenseForAllPlayers(string vehicleType)
            {
                foreach (var entry in playerData)
                {
                    if (!entry.Value.ContainsKey(vehicleType))
                    {
                        entry.Value.Add(vehicleType, Vehicle.Create(entry.Key, vehicleType));
                    }
                }
            }

            public void RemoveLicenseForAllPlayers(string vehicleType)
            {
                foreach (var entry in playerData)
                {
                    entry.Value.Remove(vehicleType);
                }
            }

            public void ResetPlayerData()
            {
                foreach (var vehicleEntries in playerData)
                {
                    foreach (var vehicleEntry in vehicleEntries.Value)
                    {
                        vehicleEntry.Value.Reset();
                    }
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        public class Vehicle
        {
            [JsonProperty("entityID")]
            public ulong EntityId { get; set; }

            [JsonProperty("lastDeath")]
            public double LastDeath { get; set; }

            public ulong PlayerId { get; set; }
            public BaseEntity Entity { get; set; }
            public string VehicleType { get; set; }
            public double LastRecall { get; set; }
            public double LastDismount { get; set; }

            public void OnDismount()
            {
                LastDismount = TimeEx.currentTimestamp;
            }

            public void OnRecall()
            {
                LastRecall = TimeEx.currentTimestamp;
            }

            public void OnDeath()
            {
                Entity = null;
                EntityId = 0;
                LastDeath = TimeEx.currentTimestamp;
            }

            public void Reset()
            {
                EntityId = 0;
                LastDeath = 0;
            }

            public static Vehicle Create(ulong playerId, string vehicleType)
            {
                var vehicle = new Vehicle();
                vehicle.VehicleType = vehicleType;
                vehicle.PlayerId = playerId;
                return vehicle;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void OnNewSave()
        {
            if (configData.global.clearVehicleOnWipe)
            {
                ClearData();
            }
            else
            {
                storedData.ResetPlayerData();
                SaveData();
            }
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chat.prefix, configData.chat.steamIDIcon);
        }

        private void Print(ConsoleSystem.Arg arg, string message)
        {
            var player = arg.Player();
            if (player == null)
            {
                Puts(message);
            }
            else
            {
                PrintToConsole(player, message);
            }
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "These are the available commands:",
                ["HelpLicence1"] = "<color=#4DFF4D>/{0}</color> -- To buy a vehicle",
                ["HelpLicence2"] = "<color=#4DFF4D>/{0}</color> -- To spawn a vehicle",
                ["HelpLicence3"] = "<color=#4DFF4D>/{0}</color> -- To recall a vehicle",
                ["HelpLicence4"] = "<color=#4DFF4D>/{0}</color> -- To kill a vehicle",
                ["HelpLicence5"] = "<color=#4DFF4D>/{0}</color> -- To buy, spawn or recall a <color=#009EFF>{1}</color>",

                ["PriceFormat"] = "<color=#FF1919>{0}</color> x{1}",
                ["HelpBuy"] = "<color=#4DFF4D>/{0} {1}</color> -- To buy a <color=#009EFF>{2}</color>",
                ["HelpBuyPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- To buy a <color=#009EFF>{2}</color>. Price: {3}",
                ["HelpSpawn"] = "<color=#4DFF4D>/{0} {1}</color> -- To spawn a <color=#009EFF>{2}</color>",
                ["HelpSpawnPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- To spawn a <color=#009EFF>{2}</color>. Price: {3}",
                ["HelpRecall"] = "<color=#4DFF4D>/{0} {1}</color> -- To recall a <color=#009EFF>{2}</color>",
                ["HelpRecallPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- To recall a <color=#009EFF>{2}</color>. Price: {3}",
                ["HelpKill"] = "<color=#4DFF4D>/{0} {1}</color> -- To kill a <color=#009EFF>{2}</color>",
                ["HelpKillCustom"] = "<color=#4DFF4D>/{0} {1}</color> or <color=#4DFF4D>/{2}</color>  -- To kill a <color=#009EFF>{3}</color>",

                ["NotAllowed"] = "You do not have permission to use this command.",
                ["PleaseWait"] = "Please wait a little bit before using this command.",
                ["RaidBlocked"] = "<color=#FF1919>You may not do that while raid blocked</color>.",
                ["CombatBlocked"] = "<color=#FF1919>You may not do that while combat blocked</color>.",
                ["OptionNotFound"] = "This <color=#009EFF>{0}</color> option doesn't exist.",
                ["VehiclePurchased"] = "You have purchased a <color=#009EFF>{0}</color>, type <color=#4DFF4D>/{1}</color> for more information.",
                ["VehicleAlreadyPurchased"] = "You have already purchased <color=#009EFF>{0}</color>.",
                ["VehicleCannotBeBought"] = "<color=#009EFF>{0}</color> is unpurchasable",
                ["VehicleNotOut"] = "<color=#009EFF>{0}</color> is not out, type <color=#4DFF4D>/{1}</color> for more information.",
                ["AlreadyVehicleOut"] = "You already have a <color=#009EFF>{0}</color> outside, type <color=#4DFF4D>/{1}</color> for more information.",
                ["VehicleNotYetPurchased"] = "You have not yet purchased a <color=#009EFF>{0}</color>, type <color=#4DFF4D>/{1}</color> for more information.",
                ["VehicleSpawned"] = "You spawned your <color=#009EFF>{0}</color>.",
                ["VehicleRecalled"] = "You recalled your <color=#009EFF>{0}</color>.",
                ["VehicleKilled"] = "You killed your <color=#009EFF>{0}</color>.",
                ["VehicleOnSpawnCooldown"] = "You must wait <color=#FF1919>{0}</color> seconds before you can spawn your <color=#009EFF>{1}</color>.",
                ["VehicleOnRecallCooldown"] = "You must wait <color=#FF1919>{0}</color> seconds before you can recall your <color=#009EFF>{1}</color>.",
                ["VehicleOnSpawnCooldownPay"] = "You must wait <color=#FF1919>{0}</color> seconds before you can spawn your <color=#009EFF>{1}</color>. You can bypass this cooldown by using the <color=#FF1919>/{2}</color> command to pay <color=#009EFF>{3}</color>",
                ["VehicleOnRecallCooldownPay"] = "You must wait <color=#FF1919>{0}</color> seconds before you can recall your <color=#009EFF>{1}</color>. You can bypass this cooldown by using the <color=#FF1919>/{2}</color> command to pay <color=#009EFF>{3}</color>",
                ["NotLookingAtWater"] = "You must be looking at water to spawn or recall a <color=#009EFF>{0}</color>.",
                ["BuildingBlocked"] = "You can't spawn a <color=#009EFF>{0}</color> if you don't have the building privileges.",
                ["RefundedVehicleItems"] = "Your <color=#009EFF>{0}</color> vehicle items was refunded to your inventory.",
                ["PlayerMountedOnVehicle"] = "It cannot be recalled or killed when players mounted on your <color=#009EFF>{0}</color>.",
                ["PlayerInSafeZone"] = "You cannot spawn or recall your <color=#009EFF>{0}</color> in the safe zone.",
                ["VehicleInventoryDropped"] = "Your <color=#009EFF>{0}</color> vehicle inventory cannot be recalled, it have dropped to the ground.",
                ["NoResourcesToPurchaseVehicle"] = "You don't have enough resources to buy a <color=#009EFF>{0}</color>. You are missing: \n{1}",
                ["NoResourcesToSpawnVehicle"] = "You don't have enough resources to spawn a <color=#009EFF>{0}</color>. You are missing: \n{1}",
                ["NoResourcesToSpawnVehicleBypass"] = "You don't have enough resources to bypass the cooldown to spawn a <color=#009EFF>{0}</color>. You are missing: \n{1}",
                ["NoResourcesToRecallVehicle"] = "You don't have enough resources to recall a <color=#009EFF>{0}</color>. You are missing: \n{1}",
                ["NoResourcesToRecallVehicleBypass"] = "You don't have enough resources to bypass the cooldown to recall a <color=#009EFF>{0}</color>. You are missing: \n{1}",
                ["MountedOrParented"] = "You cannot spawn or recall a <color=#009EFF>{0}</color> when mounted or parented.",
                ["RecallTooFar"] = "You must be within <color=#FF1919>{0}</color> meters of <color=#009EFF>{1}</color> to recall.",
                ["KillTooFar"] = "You must be within <color=#FF1919>{0}</color> meters of <color=#009EFF>{1}</color> to kill.",
                ["PlayersOnNearby"] = "You cannot spawn or recall a <color=#009EFF>{0}</color> when there are players near the position you are looking at.",
                ["RecallWasBlocked"] = "An external plugin blocked you from recalling a <color=#009EFF>{0}</color>.",
                ["NoRecallInZone"] = "No recalling a <color=#009EFF>{0}</color> in the zone.",
                ["NoSpawnInZone"] = "No spawning a <color=#009EFF>{0}</color> in the zone.",
                ["NoSpawnInAir"] = "No spawning a <color=#009EFF>{0}</color> in the air.",
                ["SpawnWasBlocked"] = "An external plugin blocked you from spawning a <color=#009EFF>{0}</color>.",
                ["VehiclesLimit"] = "You can have up to <color=#009EFF>{0}</color> vehicles at a time.",
                ["TooFarTrainTrack"] = "You are too far from the train track.",
                ["TooCloseTrainBarricadeOrWorkCart"] = "You are too close to the train barricade or work cart.",
                ["NotSpawnedOrRecalled"] = "For some reason, your <color=#009EFF>{0}</color> vehicle was not spawned/recalled",

                ["CantUse"] = "Sorry! This {0} belongs to {1}. You cannot use it.",
                ["CantPush"] = "Sorry! This {0} belongs to {1}. You cannot push it.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "可用命令列表:",
                ["HelpLicence1"] = "<color=#4DFF4D>/{0}</color> -- 购买一辆载具",
                ["HelpLicence2"] = "<color=#4DFF4D>/{0}</color> -- 生成一辆载具",
                ["HelpLicence3"] = "<color=#4DFF4D>/{0}</color> -- 召回一辆载具",
                ["HelpLicence4"] = "<color=#4DFF4D>/{0}</color> -- 摧毁一辆载具",
                ["HelpLicence5"] = "<color=#4DFF4D>/{0}</color> -- 购买，生成，召回一辆 <color=#009EFF>{1}</color>",

                ["PriceFormat"] = "<color=#FF1919>{0}</color> x{1}",
                ["HelpBuy"] = "<color=#4DFF4D>/{0} {1}</color> -- 购买一辆 <color=#009EFF>{2}</color>",
                ["HelpBuyPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- 购买一辆 <color=#009EFF>{2}</color>，价格: {3}",
                ["HelpSpawn"] = "<color=#4DFF4D>/{0} {1}</color> -- 生成一辆 <color=#009EFF>{2}</color>",
                ["HelpSpawnPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- 生成一辆 <color=#009EFF>{2}</color>，价格: {3}",
                ["HelpRecall"] = "<color=#4DFF4D>/{0} {1}</color> -- 召回一辆 <color=#009EFF>{2}</color>",
                ["HelpRecallPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- 召回一辆 <color=#009EFF>{2}</color>，价格: {3}",
                ["HelpKill"] = "<color=#4DFF4D>/{0} {1}</color> -- 摧毁一辆 <color=#009EFF>{2}</color>",
                ["HelpKillCustom"] = "<color=#4DFF4D>/{0} {1}</color> 或者 <color=#4DFF4D>/{2}</color>  -- 摧毁一辆 <color=#009EFF>{3}</color>",

                ["NotAllowed"] = "您没有权限使用该命令",
                ["PleaseWait"] = "使用此命令之前请稍等一下",
                ["RaidBlocked"] = "<color=#FF1919>您被突袭阻止了，不能使用该命令</color>",
                ["CombatBlocked"] = "<color=#FF1919>您被战斗阻止了，不能使用该命令</color>",
                ["OptionNotFound"] = "选项 <color=#009EFF>{0}</color> 不存在",
                ["VehiclePurchased"] = "您购买了 <color=#009EFF>{0}</color>, 输入 <color=#4DFF4D>/{1}</color> 了解更多信息",
                ["VehicleAlreadyPurchased"] = "您已经购买了 <color=#009EFF>{0}</color>",
                ["VehicleCannotBeBought"] = "<color=#009EFF>{0}</color> 是不可购买的",
                ["VehicleNotOut"] = "您还没有生成您的 <color=#009EFF>{0}</color>, 输入 <color=#4DFF4D>/{1}</color> 了解更多信息",
                ["AlreadyVehicleOut"] = "您已经生成了您的 <color=#009EFF>{0}</color>, 输入 <color=#4DFF4D>/{1}</color> 了解更多信息",
                ["VehicleNotYetPurchased"] = "您还没有购买 <color=#009EFF>{0}</color>, 输入 <color=#4DFF4D>/{1}</color> 了解更多信息",
                ["VehicleSpawned"] = "您生成了您的 <color=#009EFF>{0}</color>",
                ["VehicleRecalled"] = "您召回了您的 <color=#009EFF>{0}</color>",
                ["VehicleKilled"] = "您摧毁了您的 <color=#009EFF>{0}</color>",
                ["VehicleOnSpawnCooldown"] = "您必须等待 <color=#FF1919>{0}</color> 秒，才能生成您的 <color=#009EFF>{1}</color>",
                ["VehicleOnRecallCooldown"] = "您必须等待 <color=#FF1919>{0}</color> 秒，才能召回您的 <color=#009EFF>{1}</color>",
                ["VehicleOnSpawnCooldownPay"] = "您必须等待 <color=#FF1919>{0}</color> 秒，才能生成您的 <color=#009EFF>{1}</color>。你可以使用 <color=#FF1919>/{2}</color> 命令支付 <color=#009EFF>{3}</color> 来绕过这个冷却时间",
                ["VehicleOnRecallCooldownPay"] = "您必须等待 <color=#FF1919>{0}</color> 秒，才能召回您的 <color=#009EFF>{1}</color>。你可以使用 <color=#FF1919>/{2}</color> 命令支付 <color=#009EFF>{3}</color> 来绕过这个冷却时间",
                ["NotLookingAtWater"] = "您必须看着水面才能生成您的 <color=#009EFF>{0}</color>",
                ["BuildingBlocked"] = "您没有领地柜权限，无法生成您的 <color=#009EFF>{0}</color>",
                ["RefundedVehicleItems"] = "您的 <color=#009EFF>{0}</color> 载具物品已经归还回您的库存",
                ["PlayerMountedOnVehicle"] = "您的 <color=#009EFF>{0}</color> 上坐着玩家，无法被召回或摧毁",
                ["PlayerInSafeZone"] = "您不能在安全区域内生成或召回您的 <color=#009EFF>{0}</color>",
                ["VehicleInventoryDropped"] = "您的 <color=#009EFF>{0}</color> 载具物品不能召回，它已经掉落在地上了",
                ["NoResourcesToPurchaseVehicle"] = "您没有足够的资源购买 <color=#009EFF>{0}</color>，还需要: \n{1}",
                ["NoResourcesToSpawnVehicle"] = "您没有足够的资源生成 <color=#009EFF>{0}</color>，还需要: \n{1}",
                ["NoResourcesToSpawnVehicleBypass"] = "您没有足够的资源绕过冷却时间来生成 <color=#009EFF>{0}</color>，还需要: \n{1}",
                ["NoResourcesToRecallVehicle"] = "您没有足够的资源召回 <color=#009EFF>{0}</color>，还需要: \n{1}",
                ["NoResourcesToRecallVehicleBypass"] = "您没有足够的资源绕过冷却时间来召回 <color=#009EFF>{0}</color>，还需要: \n{1}",
                ["MountedOrParented"] = "当您坐着或者在附着在实体上时无法生成或召回 <color=#009EFF>{0}</color>",
                ["RecallTooFar"] = "您必须在 <color=#FF1919>{0}</color> 米内才能召回您的 <color=#009EFF>{1}</color>",
                ["KillTooFar"] = "您必须在 <color=#FF1919>{0}</color> 米内才能摧毁您的 <color=#009EFF>{1}</color>",
                ["PlayersOnNearby"] = "您正在看着的位置附近有玩家时无法生成或召回 <color=#009EFF>{0}</color>",
                ["RecallWasBlocked"] = "有其他插件阻止您召回 <color=#009EFF>{0}</color>.",
                ["NoRecallInZone"] = "不召回该区域中的<color=#009EFF>{0}</color>.",
                ["NoSpawnInZone"] = "不会在该区域生成 <color=#009EFF>{0}</color>.",
                ["NoSpawnInAir"] = "在空中时不会生成 <color=#009EFF>{0}</color>.",
                ["SpawnWasBlocked"] = "有其他插件阻止您生成 <color=#009EFF>{0}</color>.",
                ["VehiclesLimit"] = "您在同一时间内最多可以拥有 <color=#009EFF>{0}</color> 辆载具",
                ["TooFarTrainTrack"] = "您距离铁路轨道太远了",
                ["TooCloseTrainBarricadeOrWorkCart"] = "您距离铁轨障碍物或其它火车太近了",
                ["NotSpawnedOrRecalled"] = "由于某些原因，您的 <color=#009EFF>{0}</color> 载具无法生成或召回",

                ["CantUse"] = "您不能使用它，这个 {0} 属于 {1}",
                ["CantPush"] = "您无法推送此内容，它 {0} 属于 {1}.",
            }, this, "zh-CN");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "Список доступных команд:",
                ["HelpLicence1"] = "<color=#4DFF4D>/{0}</color> -- Купить транспорт",
                ["HelpLicence2"] = "<color=#4DFF4D>/{0}</color> -- Создать транспорт",
                ["HelpLicence3"] = "<color=#4DFF4D>/{0}</color> -- Вызвать транспорт",
                ["HelpLicence4"] = "<color=#4DFF4D>/{0}</color> -- Уничтожить транспорт",
                ["HelpLicence5"] = "<color=#4DFF4D>/{0}</color> -- Купить, создать, или вызвать <color=#009EFF>{1}</color>",

                ["PriceFormat"] = "<color=#FF1919>{0}</color> x{1}",
                ["HelpBuy"] = "<color=#4DFF4D>/{0} {1}</color> -- Купить <color=#009EFF>{2}</color>.",
                ["HelpBuyPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- Купить <color=#009EFF>{2}</color>. Цена: {3}",
                ["HelpSpawn"] = "<color=#4DFF4D>/{0} {1}</color> -- Создать <color=#009EFF>{2}</color>",
                ["HelpSpawnPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- Вызывать <color=#009EFF>{2}</color>. Цена: {3}",
                ["HelpRecall"] = "<color=#4DFF4D>/{0} {1}</color> -- Вызвать <color=#009EFF>{2}</color>",
                ["HelpRecallPrice"] = "<color=#4DFF4D>/{0} {1}</color> -- Вызвать <color=#009EFF>{2}</color>. Цена: {3}",
                ["HelpKill"] = "<color=#4DFF4D>/{0} {1}</color> -- Уничтожить <color=#009EFF>{2}</color>",
                ["HelpKillCustom"] = "<color=#4DFF4D>/{0} {1}</color> или же <color=#4DFF4D>/{2}</color>  -- Уничтожить <color=#009EFF>{3}</color>",

                ["NotAllowed"] = "У вас нет разрешения для использования данной команды.",
                ["PleaseWait"] = "Пожалуйста, подождите немного, прежде чем использовать эту команду.",
                ["RaidBlocked"] = "<color=#FF1919>Вы не можете это сделать из-за блокировки (рейд)</color>.",
                ["CombatBlocked"] = "<color=#FF1919>Вы не можете это сделать из-за блокировки (бой)</color>.",
                ["OptionNotFound"] = "Опция <color=#009EFF>{0}</color> не существует.",
                ["VehiclePurchased"] = "Вы приобрели <color=#009EFF>{0}</color>, напишите <color=#4DFF4D>/{1}</color> для получения дополнительной информации.",
                ["VehicleAlreadyPurchased"] = "Вы уже приобрели <color=#009EFF>{0}</color>.",
                ["VehicleCannotBeBought"] = "<color=#009EFF>{0}</color> приобрести невозможно",
                ["VehicleNotOut"] = "<color=#009EFF>{0}</color> отсутствует. Напишите <color=#4DFF4D>/{1}</color> для получения дополнительной информации.",
                ["AlreadyVehicleOut"] = "У вас уже есть <color=#009EFF>{0}</color>, напишите <color=#4DFF4D>/{1}</color>  для получения дополнительной информации.",
                ["VehicleNotYetPurchased"] = "Вы ещё не приобрели <color=#009EFF>{0}</color>. Напишите <color=#4DFF4D>/{1}</color> для получения дополнительной информации.",
                ["VehicleSpawned"] = "Вы создали ваш <color=#009EFF>{0}</color>.",
                ["VehicleRecalled"] = "Вы вызвали ваш <color=#009EFF>{0}</color>.",
                ["VehicleKilled"] = "Вы уничтожили ваш <color=#009EFF>{0}</color>.",
                ["VehicleOnSpawnCooldown"] = "Вам необходимо подождать <color=#FF1919>{0}</color> секунд прежде, чем создать свой <color=#009EFF>{1}</color>.",
                ["VehicleOnRecallCooldown"] = "Вам необходимо подождать <color=#FF1919>{0}</color> секунд прежде, чем вызвать свой <color=#009EFF>{1}</color>.",
                ["VehicleOnSpawnCooldownPay"] = "Вам необходимо подождать <color=#FF1919>{0}</color> секунд прежде, чем создать свой <color=#009EFF>{1}</color>. Вы можете обойти это время восстановления, используя команду <color=#FF1919>/{2}</color>, чтобы заплатить <color=#009EFF>{3}</color>",
                ["VehicleOnRecallCooldownPay"] = "Вам необходимо подождать <color=#FF1919>{0}</color> секунд прежде, чем вызвать свой <color=#009EFF>{1}</color>. Вы можете обойти это время восстановления, используя команду <color=#FF1919>/{2}</color>, чтобы заплатить <color=#009EFF>{3}</color>",
                ["NotLookingAtWater"] = "Вы должны смотреть на воду, чтобы создать или вызвать <color=#009EFF>{0}</color>.",
                ["BuildingBlocked"] = "Вы не можете создать <color=#009EFF>{0}</color> если отсутствует право строительства.",
                ["RefundedVehicleItems"] = "Запчасти от вашего <color=#009EFF>{0}</color> были возвращены в ваш инвентарь.",
                ["PlayerMountedOnVehicle"] = "Нельзя вызвать, когда игрок находится в вашем <color=#009EFF>{0}</color>.",
                ["PlayerInSafeZone"] = "Вы не можете создать, или вызвать ваш <color=#009EFF>{0}</color> в безопасной зоне.",
                ["VehicleInventoryDropped"] = "Инвентарь из вашего <color=#009EFF>{0}</color> не может быть вызван, он выброшен на землю.",
                ["NoResourcesToPurchaseVehicle"] = "У вас недостаточно ресурсов для покупки <color=#009EFF>{0}</color>. Вам не хватает: \n{1}",
                ["NoResourcesToSpawnVehicle"] = "У вас недостаточно ресурсов для покупки <color=#009EFF>{0}</color>. Вам не хватает: \n{1}",
                ["NoResourcesToSpawnVehicleBypass"] = "У вас недостаточно ресурсов для покупки <color=#009EFF>{0}</color>. Вам не хватает: \n{1}",
                ["NoResourcesToRecallVehicle"] = "У вас недостаточно ресурсов для покупки <color=#009EFF>{0}</color>. Вам не хватает: \n{1}",
                ["NoResourcesToRecallVehicleBypass"] = "У вас недостаточно ресурсов для покупки <color=#009EFF>{0}</color>. Вам не хватает: \n{1}",
                ["MountedOrParented"] = "Вы не можете создать <color=#009EFF>{0}</color> когда сидите или привязаны к объекту.",
                ["RecallTooFar"] = "Вы должны быть в пределах <color=#FF1919>{0}</color> метров от <color=#009EFF>{1}</color>, чтобы вызывать.",
                ["KillTooFar"] = "Вы должны быть в пределах <color=#FF1919>{0}</color> метров от <color=#009EFF>{1}</color>, уничтожить.",
                ["PlayersOnNearby"] = "Вы не можете создать <color=#009EFF>{0}</color> когда рядом с той позицией, на которую вы смотрите, есть игроки.",
                ["RecallWasBlocked"] = "Внешний плагин заблокировал вам вызвать <color=#009EFF>{0}</color>.",
                ["NoRecallInZone"] = "Нет отзыва <color=#009EFF>{0}</color> в зоне.",
                ["NoSpawnInZone"] = "В зоне не создается <color=#009EFF>{0}</color>.",
                ["NoSpawnInAir"] = "Не создавать <color=#009EFF>{0}</color> в воздухе.",
                ["SpawnWasBlocked"] = "Внешний плагин заблокировал вам создать <color=#009EFF>{0}</color>.",
                ["VehiclesLimit"] = "У вас может быть до <color=#009EFF>{0}</color> автомобилей одновременно",
                ["TooFarTrainTrack"] = "Вы слишком далеко от железнодорожных путей",
                ["TooCloseTrainBarricadeOrWorkCart"] = "Вы слишком близко к железнодорожной баррикаде или рабочей тележке",
                ["NotSpawnedOrRecalled"] = "По какой-то причине ваш <color=#009EFF>{0}</color>  автомобилей не был вызван / отозван",

                ["CantUse"] = "Простите! Этот {0} принадлежит {1}. Вы не можете его использовать.",
                ["CantPush"] = "Простите! Этот {0} принадлежит {1}. Вы не можете его подтолкнуть.",
            }, this, "ru");
        }

        #endregion LanguageFile
    }
}

// --- End of file: VehicleLicence.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-vendor-options ---
// --- Original File Path: V/VehicleVendorOptions/VehicleVendorOptions.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using static ConversationData;
using static NPCTalking;

namespace Oxide.Plugins
{
    [Info("Vehicle Vendor Options", "WhiteThunder", "1.7.6")]
    [Description("Allows customizing vehicle fuel and prices at NPC vendors.")]
    internal class VehicleVendorOptions : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Economics, ServerRewards;

        private Configuration _config;

        private const string Permission_Allow_All = "vehiclevendoroptions.allow.all";
        private const string Permission_Free_All = "vehiclevendoroptions.free.allvehicles";
        private const string Permission_Ownership_All = "vehiclevendoroptions.ownership.allvehicles";

        private const string Permission_Price_Prefix = "vehiclevendoroptions.price";

        private const int MinHiddenSlot = 24;
        private const int ScrapItemId = -932201673;
        private const float VanillaDespawnProtectionTime = 300;

        private readonly object False = false;

        private Item _scrapItem;
        private readonly VehicleInfoManager _vehicleInfoManager;

        public VehicleVendorOptions()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission_Allow_All, this);
            permission.RegisterPermission(Permission_Free_All, this);
            permission.RegisterPermission(Permission_Ownership_All, this);

            _vehicleInfoManager.Init();
        }

        private void OnServerInitialized()
        {
            _scrapItem = ItemManager.CreateByItemID(ScrapItemId);
            _vehicleInfoManager.OnServerInitialized();
        }

        private void Unload()
        {
            CostLabelUI.DestroyAll();
            _scrapItem?.Remove();
        }

        private void OnEntitySpawned(HotAirBalloon vehicle) => HandleSpawn(vehicle);

        private void OnEntitySpawned(PlayerHelicopter vehicle) => HandleSpawn(vehicle);

        private void OnEntitySpawned(MotorRowboat vehicle) => HandleSpawn(vehicle);

        private void OnEntitySpawned(BaseSubmarine vehicle) => HandleSpawn(vehicle);

        private object OnRidableAnimalClaim(RidableHorse2 horse, BasePlayer player, Item saddleItem)
        {
            if (!horse.IsForSale)
                return null;

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(horse);
            if (vehicleInfo == null)
                return null;

            if (!HasPermission(player.UserIDString, Permission_Free_All)
                && !HasPermission(player.UserIDString, vehicleInfo.FreePermission))
                return null;

            horse.SetFlag(BaseEntity.Flags.Reserved2, false);
            if (saddleItem != null)
            {
                horse.OnClaimedWithToken(saddleItem);
            }
            else
            {
                // If the saddle item is null, that means the hook is out of date, so just use one seat for now.
                horse.SetFlag(BaseEntity.Flags.Reserved9, true, networkupdate: false);
                horse.SetFlag(BaseEntity.Flags.Reserved10, false);
                horse.UpdateMountFlags();
            }

            horse.AttemptMount(player, doMountChecks: false);
            Interface.CallHook("OnRidableAnimalClaimed", horse, player);
            return False;
        }

        private void OnRidableAnimalClaimed(RidableHorse2 horse, BasePlayer player)
        {
            SetOwnerIfPermission(horse, player);
        }

        private object OnNpcConversationRespond(VehicleVendor vendor, BasePlayer player, ConversationData conversationData, ResponseNode responseNode)
        {
            CostLabelUI.Destroy(player);

            var resultingSpeechNode = ConversationUtils.FindSpeechNodeByName(conversationData, responseNode.resultingSpeechNode);
            if (resultingSpeechNode == null)
                return null;

            var vehicleInfo = _vehicleInfoManager.GetForPayPrompt(resultingSpeechNode.shortname);
            if (vehicleInfo != null)
            {
                // Player has selected a specific vehicle.
                return HandlePayPrompt(vendor, player, resultingSpeechNode, vehicleInfo);
            }

            if (!string.IsNullOrEmpty(responseNode.actionString))
            {
                vehicleInfo = _vehicleInfoManager.GetForPayAction(responseNode.actionString);
                if (vehicleInfo == null)
                    return null;

                // Player has selected the option to pay for the vehicle.
                return HandlePayment(vendor, player, conversationData, responseNode, vehicleInfo);
            }

            return null;
        }

        private void OnNpcConversationEnded(VehicleVendor vendor, BasePlayer player)
        {
            CostLabelUI.Destroy(player);
        }

        #endregion

        #region Helpers

        private static void AdjustFuel(VehicleSpawner.IVehicleSpawnUser vehicle, int desiredFuelAmount)
        {
            if (vehicle.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            var fuelAmount = desiredFuelAmount < 0
                ? fuelSystem.GetFuelContainer().allowedItem.stackable
                : desiredFuelAmount;

            var fuelItem = fuelSystem.GetFuelItem();
            if (fuelItem != null && fuelItem.amount != fuelAmount)
            {
                fuelItem.amount = fuelAmount;
                fuelItem.MarkDirty();
            }
        }

        private void HandleSpawn(VehicleSpawner.IVehicleSpawnUser vehicle)
        {
            if (Rust.Application.isLoadingSave)
                return;

            var vehicle2 = vehicle;
            NextTick(() =>
            {
                var entity = vehicle2 as BaseEntity;
                if (entity?.creatorEntity == null)
                    return;

                var vehicleConfig = _vehicleInfoManager.GetVehicleInfo(entity)?.VehicleConfig;
                if (vehicleConfig == null)
                    return;

                AdjustFuel(vehicle2, vehicleConfig.FuelAmount);
                MaybeSetOwner(entity);

                var spawnTimeDelta = vehicleConfig.DespawnProtectionSeconds - VanillaDespawnProtectionTime;

                var baseVehicle = entity as BaseVehicle;
                if ((object)baseVehicle != null)
                {
                    baseVehicle.spawnTime += spawnTimeDelta;
                }

                var hotAirBalloon = entity as HotAirBalloon;
                if ((object)hotAirBalloon != null)
                {
                    hotAirBalloon.spawnTime += spawnTimeDelta;
                }
            });
        }

        private void MaybeSetOwner(BaseEntity vehicle)
        {
            var basePlayer = vehicle.creatorEntity as BasePlayer;
            if (basePlayer == null)
                return;

            SetOwnerIfPermission(vehicle, basePlayer);
        }

        private void SetOwnerIfPermission(BaseEntity vehicle, BasePlayer basePlayer)
        {
            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
            if (vehicle == null)
                return;

            if (HasPermission(basePlayer.UserIDString, Permission_Ownership_All)
                || HasPermission( basePlayer.UserIDString, vehicleInfo.OwnershipPermission))
            {
                vehicle.OwnerID = basePlayer.userID;
            }
        }

        private bool HasPermission(string userIdString, string perm)
        {
            return permission.UserHasPermission(userIdString, perm);
        }

        private object HandlePayPrompt(VehicleVendor vendor, BasePlayer player, SpeechNode resultingSpeechNode, VehicleInfo vehicleInfo)
        {
            if (vehicleInfo.VehicleConfig.RequiresPermission
                && !HasPermission(player.UserIDString, Permission_Allow_All)
                && !HasPermission(player.UserIDString, vehicleInfo.PurchasePermission))
            {
                // End the conversation instead of showing the option to pay.
                ConversationUtils.ForceSpeechNode(vendor, player, ConversationUtils.SpeechNodes.Goodbye);
                ChatMessage(player, "Error.Vehicle.NoPermission");
                return False;
            }

            // Player has permission, so check if we need to send a UI and fake inventory snapshot.
            var scrapCondition = ConversationUtils.FindPayConditionInResponses(resultingSpeechNode);
            if (scrapCondition != null)
            {
                var vanillaPrice = (int)scrapCondition.conditionAmount;

                var priceConfig = vehicleInfo.VehicleConfig.GetPriceForPlayer(this, player.IPlayer, vehicleInfo.FreePermission);
                if (priceConfig == null || priceConfig.MatchesVanillaPrice(vanillaPrice))
                    return null;

                // Always send the UI if the price is custom, regardless of whether the player has enough.
                CostLabelUI.Create(this, player, priceConfig);

                var playerScrapAmount = player.inventory.GetAmount(ScrapItemId);
                var canAffordVanillaPrice = playerScrapAmount >= vanillaPrice;
                var canAffordCustomPrice = priceConfig.CanPlayerAfford(player);

                if (canAffordCustomPrice == canAffordVanillaPrice)
                    return null;

                // Either the client has enough but thinks it doesn't, or doesn't have enough but thinks it does.
                // Add or remove scrap so the vanilla logic for showing the payment option will match the custom payment logic.
                var addOrRemoveScrapAmount = canAffordCustomPrice ? vanillaPrice : -playerScrapAmount;
                PlayerInventoryUtils.UpdateWithFakeScrap(player, _scrapItem, addOrRemoveScrapAmount);

                var player2 = player;
                // Refresh the player inventory to clear out the fake snapshot, after a few seconds.
                // This delay needs to be long enough for the text to print out, which could vary by language.
                player2.Invoke(() => PlayerInventoryUtils.Refresh(player2), 3f);
            }

            return null;
        }

        // This method is mostly vanilla logic, with some changes to modify the price.
        private object HandlePayment(VehicleVendor vendor, BasePlayer player, ConversationData conversationData, ResponseNode responseNode, VehicleInfo vehicleInfo)
        {
            if (responseNode.conditions.Length != 0)
            {
                vendor.UpdateFlags();
            }

            var scrapCondition = ConversationUtils.GetScrapCondition(responseNode);
            if (scrapCondition == null)
                return null;

            var resultAction = ConversationUtils.FindResultAction(vendor, vehicleInfo.PayAction);
            if (resultAction == null)
                return null;

            var vanillaPrice = (int)scrapCondition.conditionAmount;

            var priceConfig = vehicleInfo.VehicleConfig.GetPriceForPlayer(this, player.IPlayer, vehicleInfo.FreePermission);
            if (priceConfig == null || priceConfig.MatchesVanillaPrice(vanillaPrice))
                return null;

            if (!priceConfig.CanPlayerAfford(player))
            {
                ConversationUtils.ForceSpeechNode(vendor, player, ConversationUtils.SpeechNodes.Goodbye);
                return False;
            }

            if (priceConfig.RequiresScrap)
            {
                // Set the scrap price to the custom amount.
                scrapCondition.conditionAmount = (uint)priceConfig.Amount;
                resultAction.scrapCost = priceConfig.Amount;
            }
            else
            {
                // Set the scrap price to 0 since the player is being charged for custom currency.
                priceConfig.TryChargePlayer(player);
                scrapCondition.conditionAmount = 0;
                resultAction.scrapCost = 0;
            }

            bool passesConditions;

            try
            {
                passesConditions = responseNode.PassesConditions(player, vendor);
                if (passesConditions && !string.IsNullOrEmpty(responseNode.actionString))
                {
                    vendor.OnConversationAction(player, responseNode.actionString);
                }
            }
            finally
            {
                // Revert scrap price to vanilla.
                scrapCondition.conditionAmount = (uint)vanillaPrice;
                resultAction.scrapCost = vanillaPrice;
            }

            var speechNodeIndex = conversationData.GetSpeechNodeIndex(passesConditions
                ? responseNode.resultingSpeechNode
                : responseNode.GetFailedSpeechNode(player, vendor));

            if (speechNodeIndex == -1)
            {
                vendor.ForceEndConversation(player);
                return False;
            }

            vendor.ForceSpeechNode(player, speechNodeIndex);
            Interface.CallHook("OnNpcConversationResponded", this, player, conversationData, responseNode);

            return False;
        }

        #endregion

        #region Vehicle Info

        private class VehicleInfo
        {
            public string PrefabPath;
            public string PermissionSuffix;
            public VehicleConfig VehicleConfig;
            public string PayPrompt;
            public string PayAction;

            public uint PrefabId { get; private set; }
            public string PurchasePermission { get; private set; }
            public string OwnershipPermission { get; private set; }
            public string FreePermission { get; private set; }

            public void Init()
            {
                PurchasePermission = $"{nameof(VehicleVendorOptions)}.allow.{PermissionSuffix}".ToLower();
                OwnershipPermission = $"{nameof(VehicleVendorOptions)}.ownership.{PermissionSuffix}".ToLower();
                FreePermission = $"{nameof(VehicleVendorOptions)}.free.{PermissionSuffix}".ToLower();
            }

            public void OnServerInitialized()
            {
                var entity = GameManager.server.FindPrefab(PrefabPath)?.GetComponent<BaseEntity>();
                if (entity != null)
                {
                    PrefabId = entity.prefabID;
                }
            }
        }

        private class VehicleInfoManager
        {
            private readonly VehicleVendorOptions _plugin;
            private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo = new();
            private readonly Dictionary<string, VehicleInfo> _payPromptToVehicleInfo = new();
            private readonly Dictionary<string, VehicleInfo> _payActionToVehicleInfo = new();
            private VehicleInfo[] _allVehicles;

            public VehicleInfoManager(VehicleVendorOptions plugin)
            {
                _plugin = plugin;
            }

            public void Init()
            {
                _allVehicles = new[]
                {
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                        PermissionSuffix = "minicopter",
                        VehicleConfig = _plugin._config.Vehicles.Minicopter,
                        PayPrompt = "minicopterbuy",
                        PayAction = "buyminicopter",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                        PermissionSuffix = "scraptransport",
                        VehicleConfig = _plugin._config.Vehicles.ScrapTransport,
                        PayPrompt = "transportbuy",
                        PayAction = "buytransport",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab",
                        PermissionSuffix = "attackhelicopter",
                        VehicleConfig = _plugin._config.Vehicles.AttackHelicopter,
                        PayPrompt = "attackbuy",
                        PayAction = "buyattack",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                        PermissionSuffix = "hotairballoon",
                        VehicleConfig = _plugin._config.Vehicles.HotAirBalloon,
                        PayPrompt = "habbuy",
                        PayAction = "buyhab",
                    },

                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                        PermissionSuffix = "rowboat",
                        VehicleConfig = _plugin._config.Vehicles.Rowboat,
                        PayPrompt = "pay_rowboat",
                        PayAction = "buyboat",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/boats/rhib/rhib.prefab",
                        PermissionSuffix = "rhib",
                        VehicleConfig = _plugin._config.Vehicles.RHIB,
                        PayPrompt = "pay_rhib",
                        PayAction = "buyrhib",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/submarine/submarinesolo.entity.prefab",
                        PermissionSuffix = "solosub",
                        VehicleConfig = _plugin._config.Vehicles.SoloSub,
                        PayPrompt = "pay_sub",
                        PayAction = "buysub",
                    },
                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/submarine/submarineduo.entity.prefab",
                        PermissionSuffix = "duosub",
                        VehicleConfig = _plugin._config.Vehicles.DuoSub,
                        PayPrompt = "pay_duosub",
                        PayAction = "buysubduo",
                    },

                    new VehicleInfo
                    {
                        PrefabPath = "assets/content/vehicles/horse/ridablehorse2.prefab",
                        PermissionSuffix = "ridablehorse",
                    },
                };

                foreach (var vehicleInfo in _allVehicles)
                {
                    vehicleInfo.Init();

                    if (!string.IsNullOrEmpty(vehicleInfo.PayPrompt))
                    {
                        _payPromptToVehicleInfo[vehicleInfo.PayPrompt] = vehicleInfo;
                    }

                    if (!string.IsNullOrEmpty(vehicleInfo.PayAction))
                    {
                        _payActionToVehicleInfo[vehicleInfo.PayAction] = vehicleInfo;
                    }
                }

                // Register permissions in batches by permission type.
                foreach (var vehicleInfo in _allVehicles)
                {
                    _plugin.permission.RegisterPermission(vehicleInfo.PurchasePermission, _plugin);
                }

                foreach (var vehicleInfo in _allVehicles)
                {
                    _plugin.permission.RegisterPermission(vehicleInfo.OwnershipPermission, _plugin);
                }

                foreach (var vehicleInfo in _allVehicles)
                {
                    _plugin.permission.RegisterPermission(vehicleInfo.FreePermission, _plugin);
                }

                foreach (var vehicleInfo in _allVehicles)
                {
                    vehicleInfo.VehicleConfig?.InitAndValidate(_plugin, vehicleInfo.PermissionSuffix);
                }
            }

            public void OnServerInitialized()
            {
                foreach (var vehicleInfo in _allVehicles)
                {
                    vehicleInfo.OnServerInitialized();

                    if (vehicleInfo.PrefabId != 0)
                    {
                        _prefabIdToVehicleInfo[vehicleInfo.PrefabId] = vehicleInfo;
                    }
                    else
                    {
                        _plugin.LogError($"Unable to determine Prefab ID for prefab: {vehicleInfo.PrefabPath}");
                    }
                }
            }

            public VehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                return _prefabIdToVehicleInfo.GetValueOrDefault(entity.prefabID);
            }

            public VehicleInfo GetForPayPrompt(string promptName)
            {
                return _payPromptToVehicleInfo.GetValueOrDefault(promptName);
            }

            public VehicleInfo GetForPayAction(string actionName)
            {
                return _payActionToVehicleInfo.GetValueOrDefault(actionName);
            }
        }

        #endregion

        #region Player Inventory Utilities

        private static class PlayerInventoryUtils
        {
            public static void Refresh(BasePlayer player)
            {
                player.inventory.SendUpdatedInventory(PlayerInventory.Type.Main, player.inventory.containerMain);
            }

            public static void UpdateWithFakeScrap(BasePlayer player, Item scrapItem, int amountDiff)
            {
                using var containerUpdate = Facepunch.Pool.Get<ProtoBuf.UpdateItemContainer>();
                containerUpdate.type = (int)PlayerInventory.Type.Main;
                containerUpdate.container = Facepunch.Pool.Get<List<ProtoBuf.ItemContainer>>();

                var containerInfo = player.inventory.containerMain.Save();
                var itemSlot = AddFakeScrapToContainerUpdate(containerInfo, scrapItem, amountDiff);

                containerUpdate.container.Capacity = itemSlot + 1;
                containerUpdate.container.Add(containerInfo);
                player.ClientRPCPlayer(null, player, "UpdatedItemContainer", containerUpdate);
            }

            private static int AddFakeScrapToContainerUpdate(ProtoBuf.ItemContainer containerInfo, Item scrapItem, int scrapAmount)
            {
                // Always use a separate item so it can be placed out of view.
                var itemInfo = scrapItem.Save();
                itemInfo.amount = scrapAmount;
                itemInfo.slot = GetNextAvailableSlot(containerInfo);
                containerInfo.contents.Add(itemInfo);
                return itemInfo.slot;
            }

            private static int GetNextAvailableSlot(ProtoBuf.ItemContainer containerInfo)
            {
                var highestSlot = MinHiddenSlot;
                foreach (var item in containerInfo.contents)
                {
                    if (item.slot > highestSlot)
                    {
                        highestSlot = item.slot;
                    }
                }

                return highestSlot;
            }
        }

        #endregion

        #region Conversation Utilities

        private static class ConversationUtils
        {
            public static class SpeechNodes
            {
                public const string Goodbye = "goodbye";
            }

            public static ConversationCondition GetScrapCondition(ResponseNode responseNode)
            {
                foreach (var condition in responseNode.conditions)
                {
                    if (condition.conditionType == ConversationCondition.ConditionType.HasScrap)
                        return condition;
                }

                return null;
            }

            public static ConversationCondition FindPayConditionInResponses(SpeechNode speechNode)
            {
                foreach (var futureResponseOption in speechNode.responses)
                {
                    var scrapCondition = GetScrapCondition(futureResponseOption);
                    if (scrapCondition != null)
                    {
                        return scrapCondition;
                    }
                }

                return null;
            }

            public static void ForceSpeechNode(NPCTalking npcTalking, BasePlayer player, string speechNodeName)
            {
                var speechNodeIndex = npcTalking.GetConversationFor(player).GetSpeechNodeIndex(speechNodeName);
                npcTalking.ForceSpeechNode(player, speechNodeIndex);
            }

            public static NPCConversationResultAction FindResultAction(NPCTalking npcTalking, string actionString)
            {
                if (string.IsNullOrEmpty(actionString))
                    return null;

                foreach (var resultAction in npcTalking.conversationResultActions)
                {
                    if (resultAction.action == actionString)
                        return resultAction;
                }

                return null;
            }

            public static SpeechNode FindSpeechNodeByName(ConversationData conversationData, string speechNodeName)
            {
                foreach (var speechNode in conversationData.speeches)
                {
                    if (speechNode.shortname == speechNodeName)
                        return speechNode;
                }

                return null;
            }
        }

        #endregion

        #region UI

        private static class CostLabelUI
        {
            private const string Name = "VehicleVendorOptions";

            public static void Destroy(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Name);
            }

            public static void DestroyAll()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    Destroy(player);
                }
            }

            public static void Create(VehicleVendorOptions plugin, BasePlayer player, PriceConfig priceConfig)
            {
                var itemPrice = priceConfig.Amount == 0
                    ? plugin.GetMessage(player, "UI.Price.Free")
                    : priceConfig.PaymentProvider is EconomicsPaymentProvider
                    ? plugin.GetMessage(player, "UI.Currency.Economics", priceConfig.Amount)
                    : priceConfig.PaymentProvider is ServerRewardsPaymentProvider
                    ? plugin.GetMessage(player, "UI.Currency.ServerRewards", priceConfig.Amount)
                    : $"{priceConfig.Amount} {plugin.GetMessage(player, plugin.GetItemNameLocalizationKey(priceConfig.ItemShortName))}";

                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.5",
                                AnchorMax = "0.5 0.5",
                                OffsetMin = "152 21",
                                OffsetMax = "428 41",
                            },
                            Text =
                            {
                                Text = plugin.GetMessage(player, "UI.ActualPrice", itemPrice),
                                FontSize = 11,
                                Font = "robotocondensed-regular.ttf",
                                Align = UnityEngine.TextAnchor.MiddleLeft,
                            },
                        },
                        "Overlay",
                        Name
                    },
                };

                CuiHelper.AddUi(player, cuiElements);
            }
        }

        #endregion

        #region Payment Providers

        private interface IPaymentProvider
        {
            bool IsAvailable { get; }
            int GetBalance(BasePlayer player);
            void TakeBalance(BasePlayer player, int amount);
        }

        private class EconomicsPaymentProvider : IPaymentProvider
        {
            private readonly VehicleVendorOptions _plugin;
            private Plugin _ownerPlugin => _plugin.Economics;

            public EconomicsPaymentProvider(VehicleVendorOptions plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_ownerPlugin.Call("Balance", (ulong)player.userID));
            }

            public void TakeBalance(BasePlayer player, int amount)
            {
                _ownerPlugin.Call("Withdraw", (ulong)player.userID, Convert.ToDouble(amount));
            }
        }

        private class ServerRewardsPaymentProvider : IPaymentProvider
        {
            private readonly VehicleVendorOptions _plugin;
            private Plugin _ownerPlugin => _plugin.ServerRewards;

            public ServerRewardsPaymentProvider(VehicleVendorOptions plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_ownerPlugin.Call("CheckPoints", (ulong)player.userID));
            }

            public void TakeBalance(BasePlayer player, int amount)
            {
                _ownerPlugin.Call("TakePoints", (ulong)player.userID, amount);
            }
        }

        private class ItemsPaymentProvider : IPaymentProvider
        {
            public bool IsAvailable => true;

            private int _itemId;

            public ItemsPaymentProvider(int itemId)
            {
                _itemId = itemId;
            }

            public int GetBalance(BasePlayer player)
            {
                return player.inventory.GetAmount(_itemId);
            }

            public void TakeBalance(BasePlayer player, int amount)
            {
                player.inventory.Take(null, _itemId, amount);
            }
        }

        #endregion

        #region Configuration

        private class VehicleConfigMap
        {
            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new()
            {
                FuelAmount = 100,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 500 },
                    new PriceConfig { Amount = 250 },
                },
            };

            [JsonProperty("ScrapTransport")]
            public VehicleConfig ScrapTransport = new()
            {
                FuelAmount = 100,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 800 },
                    new PriceConfig { Amount = 400 },
                },
            };

            [JsonProperty("AttackHelicopter")]
            public VehicleConfig AttackHelicopter = new()
            {
                FuelAmount = 100,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 1750 },
                    new PriceConfig { Amount = 1250 },
                },
            };

            [JsonProperty("HotAirBalloon")]
            public VehicleConfig HotAirBalloon = new()
            {
                FuelAmount = 75,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 100 },
                    new PriceConfig { Amount = 50 },
                },
            };

            [JsonProperty("Rowboat")]
            public VehicleConfig Rowboat = new()
            {
                FuelAmount = 50,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 80 },
                    new PriceConfig { Amount = 40 },
                },
            };

            [JsonProperty("RHIB")]
            public VehicleConfig RHIB = new()
            {
                FuelAmount = 50,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 200 },
                    new PriceConfig { Amount = 100 },
                },
            };

            [JsonProperty("SoloSub")]
            public VehicleConfig SoloSub = new()
            {
                FuelAmount = 50,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 125 },
                    new PriceConfig { Amount = 50 },
                },
            };

            [JsonProperty("DuoSub")]
            public VehicleConfig DuoSub = new()
            {
                FuelAmount = 50,
                PricesRequiringPermission = new[]
                {
                    new PriceConfig { Amount = 200 },
                    new PriceConfig { Amount = 100 },
                },
            };
        }

        private class VehicleConfig
        {
            private static PriceConfig FreePriceConfig = new() { Amount = 0 };

            [JsonProperty("RequiresPermission")]
            public bool RequiresPermission = false;

            [JsonProperty("FuelAmount")]
            public int FuelAmount = 100;

            [JsonProperty("DespawnProtectionSeconds")]
            public float DespawnProtectionSeconds = 300;

            [JsonProperty("PricesRequiringPermission")]
            public PriceConfig[] PricesRequiringPermission = Array.Empty<PriceConfig>();

            public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType)
            {
                foreach (var priceConfig in PricesRequiringPermission)
                {
                    priceConfig.InitAndValidate(plugin, vehicleType);
                    plugin.permission.RegisterPermission(priceConfig.Permission, plugin);
                }
            }

            public PriceConfig GetPriceForPlayer(VehicleVendorOptions plugin, IPlayer player, string freePermission)
            {
                if (plugin.HasPermission(player.Id, Permission_Free_All)
                    || plugin.HasPermission(player.Id, freePermission))
                    return FreePriceConfig;

                if (PricesRequiringPermission == null)
                    return null;

                for (var i = PricesRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var priceConfig = PricesRequiringPermission[i];
                    if (priceConfig.IsValid && player.HasPermission(priceConfig.Permission))
                        return priceConfig;
                }

                return null;
            }
        }

        private class PriceConfig
        {
            [JsonProperty("Amount")]
            public int Amount;

            [JsonProperty("ItemShortName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ItemShortName = "scrap";

            [JsonProperty("UseEconomics")]
            public bool UseEconomics = false;

            [JsonProperty("UseServerRewards")]
            public bool UseServerRewards = false;

            [JsonIgnore]
            public string Permission;

            [JsonIgnore]
            public IPaymentProvider PaymentProvider;

            [JsonIgnore]
            public bool IsValid => (PaymentProvider?.IsAvailable ?? false) && Permission != string.Empty;

            [JsonIgnore]
            public bool RequiresScrap => PaymentProvider is ItemsPaymentProvider
                                         && ItemShortName == "scrap";

            private ItemDefinition _itemDefinition;
            [JsonIgnore]
            public ItemDefinition ItemDef
            {
                get
                {
                    if (_itemDefinition == null)
                    {
                        _itemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                    }

                    return _itemDefinition;
                }
            }

            public bool MatchesVanillaPrice(int vanillaPrice)
            {
                return RequiresScrap && Amount == vanillaPrice;
            }

            public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType)
            {
                Permission = GeneratePermission(vehicleType);
                PaymentProvider = CreatePaymentProvider(plugin);
            }

            private IPaymentProvider CreatePaymentProvider(VehicleVendorOptions plugin)
            {
                if (UseEconomics)
                    return new EconomicsPaymentProvider(plugin);

                if (UseServerRewards)
                    return new ServerRewardsPaymentProvider(plugin);

                if (ItemDef == null)
                {
                    plugin.LogError($"Price config contains an invalid item short name: '{ItemShortName}'.");
                    return null;
                }

                return new ItemsPaymentProvider(ItemDef.itemid);
            }

            private string GeneratePermission(string vehicleType)
            {
                if (Amount == 0)
                {
                    Permission = $"{Permission_Price_Prefix}.{vehicleType}.free";
                }
                else
                {
                    var currencyType = UseEconomics ? "economics"
                        : UseServerRewards ? "serverrewards"
                        : ItemShortName;

                    if (string.IsNullOrEmpty(ItemShortName))
                        return string.Empty;

                    Permission = $"{Permission_Price_Prefix}.{vehicleType}.{currencyType}.{Amount}";
                }

                return Permission;
            }

            public bool CanPlayerAfford(BasePlayer player)
            {
                if (Amount <= 0)
                    return true;

                return PaymentProvider.GetBalance(player) >= Amount;
            }

            public bool TryChargePlayer(BasePlayer player)
            {
                if (Amount <= 0)
                    return true;

                PaymentProvider.TakeBalance(player, Amount);
                return true;
            }
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Vehicles")]
            public VehicleConfigMap Vehicles = new();
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.UserIDString, messageName), args));

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.IPlayer, messageName, args);

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetItemNameLocalizationKey(string itemShortName) => $"Item.{itemShortName}";

        private void AddEnglishItemNamesForPriceConfigs(Dictionary<string, string> messages, PriceConfig[] priceConfigs)
        {
            foreach (var priceConfig in priceConfigs)
            {
                if (string.IsNullOrEmpty(priceConfig.ItemShortName))
                    continue;

                var localizationKey = GetItemNameLocalizationKey(priceConfig.ItemShortName);
                messages[localizationKey] = priceConfig.ItemDef.displayName.english;
            }
        }

        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                ["Error.Vehicle.NoPermission"] = "You don't have permission to buy that vehicle.",
                ["UI.ActualPrice"] = "Actual price: {0}",
                ["UI.Price.Free"] = "Free",
                ["UI.Currency.Economics"] = "{0:C}",
                ["UI.Currency.ServerRewards"] = "{0} reward points",
            };

            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.Minicopter.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.ScrapTransport.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.AttackHelicopter.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.HotAirBalloon.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.Rowboat.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.RHIB.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.SoloSub.PricesRequiringPermission);
            AddEnglishItemNamesForPriceConfigs(messages, _config.Vehicles.DuoSub.PricesRequiringPermission);

            lang.RegisterMessages(messages, this, "en");
        }

        #endregion
    }
}


// --- End of file: VehicleVendorOptions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/visual-debug ---
// --- Original File Path: V/VisualDebug/VisualDebug.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Reflection;
using System;
using System.Collections;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("VisualDebug", "Jake_Rich", "1.0.2")]
    [Description("A visual object explorer, to browse rust plugins")]

    public class VisualDebug : RustPlugin
    {
        public MemoryTableUIManager UI { get; set; }

        public static VisualDebug _plugin { get; set; }

        void Init()
        {
            _plugin = this;
            UI = new MemoryTableUIManager();
        }

        void Unload()
        {
            UI.Destroy();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (UI._player == player)
            {
                UI.Destroy();
            }
        }

        public Dictionary<string, string> LangAPI = new Dictionary<string, string>()
        {
            { "AdminCommandWarning", "This command is for admins only." },

        };

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(LangAPI, this);
        }

        [ChatCommand("visualdbg")]
        void VisualDebugging(BasePlayer player)
        {
            if (!player.IsAdmin)
            {
                PrintToChat(player, lang.GetMessage("AdminCommandWarning", this, player.UserIDString));
                return;
            }

            if (UI._player == null)
            {
                UI.ShowPlayer(player);
            }
            else
            {
                UI.HidePlayer(player);
            }
        }

        public static bool IsValueType(object obj)
        {
            if (obj == null)
            {
                return true;
            }
            if (obj.GetType() == null)
            {
                return true;
            }
            return (obj is ValueType || obj is string) && !obj.GetType().IsGenericType && (obj.GetType().Namespace == null ? true : obj.GetType().Namespace.Contains("System"));
        }

        public class ObjectMemoryInfo
        {
            public string name { get; set; }
            public int memoryUsed { get; set; }
            public int elements { get; set; }
            public object _target { get; set; }
            private int currentLayer { get; set; } = 0;
            public ObjectMemoryInfo _parent { get; set; }
            private bool _autoExpand { get; set; }

            public List<ObjectMemoryInfo> children { get; set; } = new List<ObjectMemoryInfo>();
            public List<MethodInfo> methods { get; set; } = new List<MethodInfo>();

            public ObjectMemoryInfo(object targetObject, int layers, string variableName = "", ObjectMemoryInfo parent = null, bool autoExpand = false)
            {
                _autoExpand = autoExpand;
                _parent = parent;
                name = variableName;
                name = name.Replace("<", "");
                name = name.Replace(">", "");
                name = name.Replace("k__BackingField", "");
                currentLayer = layers - 1;
                _target = targetObject;
                SetupObject();
                if (autoExpand)
                {
                    Expand();
                }
            }

            public void Expand()
            {
                CalculateSubObjects();
            }

            public void SetupObject()
            {
                #region Elements

                if (_target is IEnumerable)
                {
                    elements = GetCount();
                }
                if (_target is HashSet<object>)
                {
                    elements = (_target as HashSet<object>).Count;
                }

                #endregion

                #region Memory Usage
                var Type = _target?.GetType();
                if (Type == null)
                {
                    return;
                }
                if (Type == typeof(int))
                {
                    memoryUsed = 4;
                }
                else if (Type == typeof(string))
                {
                    memoryUsed = (_target as string).Length;
                }
                else if (Type == typeof(BaseNetworkable))
                {
                    memoryUsed = 8;
                }
                else if (_target is IDictionary)
                {
                    memoryUsed = elements * 16;
                }
                else if (_target is IList)
                {
                    memoryUsed = elements * 8;
                }
                else if (Type == typeof(int))
                {
                    memoryUsed = 4;
                }
                foreach (var child in children)
                {
                    memoryUsed += child.memoryUsed;
                }
                #endregion


                #region Methods

                foreach (var method in Type.GetMethods())
                {
                    if (method?.GetParameters().Length != 0)
                    {
                        continue;
                    }
                    methods.Add(method);
                }
                #endregion
            }

            private int GetCount()
            {
                int? c = (_target as IEnumerable).Cast<object>()?.Count();
                if (c != null)
                {
                    return (int)c;
                }
                return 0;
            }

            public string GetInfo()
            {
                return (_target is IEnumerable) ? $"Count : {elements}" : GetMemoryUsage();
            }

            public string GetVisualText()
            {
                if (_target == null)
                {
                    return $"{name} = <color=#3B8AD6FF>NULL</color>";
                }
                string elementText = ((_target is IEnumerable && !(_target is string)) ? $" Count : {elements}" : "");
                string valueText = (IsValueType(_target) ? $" = <color=#3B8AD6FF>{_target?.ToString()}</color>" : "");
                return $"<color=#4EC8B0FF>{GetTypeName(_target.GetType())}</color> {name}{elementText}{valueText}";
            }

            public static string GetMethodText(MethodInfo info)
            {
                return $"{(info.IsPublic ? "<color=#3B8AD6FF>public " : "<color=#3B8AD6FF>private ")}{(info.IsVirtual ? "virtual</color> " : "</color>")}{$"<color=#4EC8B0FF>{GetTypeName(info.ReturnType)}</color> "}{info.Name}()";
            }

            private static string GetTypeName(Type type)
            {
                if (type == null)
                {
                    return "";
                }
                string generic = type.IsGenericType ? $"<{string.Join(",",type.GetGenericArguments().Select(x=>GetTypeName(x)).ToArray())}>" : "";
                string name = type.Name;
                if (name.Contains("`"))
                {
                    name = name.Remove(name.IndexOf('`', 2));
                }
                return $"{name}{generic}";
            }

            private string GetMemoryUsage()
            {
                if (memoryUsed > 1000000000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000000000, 2)}GB";
                }
                if (memoryUsed > 1000000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000000, 2)}MB";
                }
                if (memoryUsed > 1000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000, 2)}KB";
                }
                return $"{memoryUsed}B";
            }

            public void CalculateSubObjects()
            {
                children.Clear();
                try
                {
                    if (currentLayer < 0)
                    {
                        return;
                    }
                    if (_target == null)
                    {
                        return;
                    }
                    var Type = _target.GetType();
                    if (Type == null)
                    {
                        return;
                    }
                    if (_target is string) //No need to expand these
                    {
                        return;
                    }
                    if (_target is IEnumerable)
                    {
                        int index = 0;
                        var objects = (_target as IEnumerable).Cast<object>();
                        if (objects == null)
                        {
                            return;
                        }
                        foreach (var item in objects)
                        {
                            children.Add(new ObjectMemoryInfo(item, currentLayer, index.ToString(), this, _autoExpand));
                            index++;
                        }
                    }
                    else
                    {
                        foreach (var field in Type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static))
                        {
                            object target = field.GetValue(_target);
                            if (!CheckParents())
                            {
                                continue;
                            }
                            children.Add(new ObjectMemoryInfo(target, currentLayer, field.Name, this));
                        }
                    }
                }
                catch (Exception ex)
                {
                    _plugin.Puts(ex.ToString());
                }
            }

            public bool CheckParents()
            {
                ObjectMemoryInfo parent = _parent;
                while (parent != null)
                {
                    if (parent._target == _target)
                    {
                        return false;
                    }
                    parent = parent._parent;
                }
                return true;
            }

            public List<string> GetOutput(int layer = 0, bool justLists = false)
            {
                List<string> returnValue = new List<string>();
                string padding = new string('\t', layer);
                if (_target != null)
                {
                    if (_target is IEnumerable || !justLists || children.Count != 0)
                    {
                        returnValue.Add(padding + $"{_target.GetType().Name} {name} {GetMemoryUsage()}");
                    }
                }
                if (children.Count > 0)
                {
                    returnValue.Add(padding + "{");
                    foreach (var child in children)
                    {
                        returnValue.AddRange(child.GetOutput(layer + 1, justLists));
                    }
                    returnValue.Add(padding + "}");
                }
                return returnValue;
            }

            public string PrintOutput(bool justLists = false)
            {
                return string.Join(Environment.NewLine, GetOutput(0, justLists).ToArray());
            }
        }

        #region Jakes UI Framework - Old (Could be replaced later, but works for this plugin)

        private Dictionary<string, UIButton> UIButtonCallBacks { get; set; } = new Dictionary<string, UIButton>();

        void OnButtonClick(ConsoleSystem.Arg arg)
        {
            UIButton button;
            if (UIButtonCallBacks.TryGetValue(arg.cmd.Name, out button))
            {
                button.OnClicked(arg);
                return;
            }
            Puts("Unknown button command: {0}", arg.cmd.Name);
        }

        public class UIElement
        {
            public CuiElement Element { get; protected set; }
            public CuiRectTransformComponent transform { get; protected set; }
            public HashSet<BasePlayer> players { get; set; } = new HashSet<BasePlayer>();
            public Vector2 position { get; set; } = new Vector2();
            public Vector2 size { get; set; } = new Vector2();
            private VisualDebug _plugin;

            protected UIElement(UIContainer container)
            {
                transform = new CuiRectTransformComponent();
                Element = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = "Hud",
                    Components =
                        {
                            transform
                        }
                };

                container.Elements.Add(this);
            }

            public void SetParent(UIElement element)
            {
                Element.Parent = element.Element.Name;
            }

            public void Refresh(BasePlayer player)
            {
                Hide(player);
                Show(player);
            }

            private bool AddPlayer(BasePlayer player)
            {
                if (!players.Contains(player))
                {
                    players.Add(player);
                    return true;
                }

                return false;
            }

            private bool RemovePlayer(BasePlayer player)
            {
                return players.Remove(player);
            }

            public virtual void Show(BasePlayer player)
            {
                if (AddPlayer(player))
                {
                    SafeAddUi(player, Element);
                }
            }

            public void Show(List<BasePlayer> players)
            {
                foreach (BasePlayer player in players)
                {
                    Show(player);
                }
            }

            public void Show(HashSet<BasePlayer> players)
            {
                foreach (BasePlayer player in players)
                {
                    Show(player);
                }
            }

            public virtual void Hide(BasePlayer player)
            {
                if (RemovePlayer(player))
                {
                    SafeDestroyUi(player, Element);
                }
            }

            public void HideAll()
            {
                foreach (BasePlayer player in players.ToList())
                {
                    Hide(player);
                }
            }

            public void RefreshAll()
            {
                foreach (BasePlayer player in players.ToList())
                {
                    Refresh(player);
                }
            }

            private void SafeAddUi(BasePlayer player, CuiElement element)
            {
                try
                {
                    //_plugin.Puts($"Adding {element.Name} to {player.userID}");
                    List<CuiElement> elements = new List<CuiElement>();
                    elements.Add(element);
                    CuiHelper.AddUi(player, elements);
                }
                catch (Exception ex)
                {

                }
            }

            private void SafeDestroyUi(BasePlayer player, CuiElement element)
            {
                try
                {
                    //_plugin.Puts($"Deleting {element.Name} to {player.userID}");
                    CuiHelper.DestroyUi(player, element.Name);
                }
                catch (Exception ex)
                {

                }
            }

            public void SetSize(float x, float y)
            {
                size = new Vector2(x, y);
                UpdatePlacement();
            }

            public void SetPosition(float x, float y)
            {
                position = new Vector2(x, y);
                UpdatePlacement();
            }

            public void UpdatePlacement()
            {
                transform.AnchorMin = $"{position.x} {position.y}";
                transform.AnchorMax = $"{position.x + size.x} {position.y + size.y}";

                //_plugin.Puts($"POSITION [{transform.AnchorMin},{transform.AnchorMax}]");
                RefreshAll();
            }


            public void SetPositionAndSize(CuiRectTransformComponent trans)
            {
                transform.AnchorMin = trans.AnchorMin;
                transform.AnchorMax = trans.AnchorMax;

                //_plugin.Puts($"POSITION [{transform.AnchorMin},{transform.AnchorMax}]");

                RefreshAll();
            }
        }

        public class UIButton : UIElement
        {
            public CuiButtonComponent buttonComponent { get; private set; }
            public CuiTextComponent textComponent { get; private set; }
            private UILabel label { get; set; }

            private int _fontSize;

            public Action<ConsoleSystem.Arg> onClicked;

            public UIButton(UIContainer container, string buttonText = "", string buttonColor = "0 0 0 0.85", string textColor = "1 1 1 1", int fontSize = 15) : base(container)
            {
                _fontSize = fontSize;

                var button = new CuiButton();

                buttonComponent = button.Button;
                textComponent = button.Text;

                buttonComponent.Command = CuiHelper.GetGuid();
                buttonComponent.Color = buttonColor;

                textComponent.Text = buttonText;
                textComponent.FontSize = _fontSize;
                textComponent.Align = TextAnchor.MiddleCenter;

                Element.Components.Insert(0, buttonComponent);

                _plugin.cmd.AddConsoleCommand(buttonComponent.Command, _plugin, "OnButtonClick");

                _plugin.UIButtonCallBacks[buttonComponent.Command] = this;

                label = new UILabel(container, buttonText, parent: Element.Name, fontSize: _fontSize);

                label.SetPosition(0, 0);
                label.SetSize(1f, 1f);
                label.text.Align = TextAnchor.MiddleCenter;
                label.text.Color = textColor;

                textComponent = label.text;
            }

            public virtual void OnClicked(ConsoleSystem.Arg args)
            {
                onClicked.Invoke(args);
            }

            public void AddChatCommand(string fullCommand)
            {
                if (fullCommand == null)
                {
                    return;
                }
                /*
                List<string> split = fullCommand.Split(' ').ToList();
                string command = split[0];
                split.RemoveAt(0); //Split = command args now*/
                onClicked += (arg) =>
                {
                    _plugin.rust.RunClientCommand(arg.Player(), $"chat.say \"/{fullCommand}\"");
                    //plugin.Puts($"Calling chat command {command} {string.Join(" ",split.ToArray())}");
                    //Need to call chat command somehow here
                };
            }

            public void AddCallback(Action<BasePlayer> callback)
            {
                if (callback == null)
                {
                    return;
                }
                onClicked += (args) => { callback(args.Player()); };
            }

            public override void Hide(BasePlayer player)
            {
                base.Hide(player);
                //No way to remove console commands
            }
        }

        public class UILabel : UIElement
        {
            public CuiTextComponent text { get; private set; }

            public UILabel(UIContainer container, string labelText, int fontSize = 12, string fontColor = "1 1 1 1", TextAnchor alignment = TextAnchor.MiddleCenter, string parent = "") : base(container)
            {

                text = new CuiTextComponent();

                text.Text = labelText;
                text.Color = fontColor;
                text.Align = alignment;
                text.FontSize = fontSize;

                if (!string.IsNullOrEmpty(parent))
                {
                    Element.Parent = parent;
                }

                Element.Components.Insert(0, text);
            }
        }

        public class UIPanel : UIElement
        {
            private CuiImageComponent panel;
            private CuiNeedsCursorComponent needsCursor { get; set; }

            private bool requiresFocus { get; set; }

            public bool CursorEnabled
            {
                get
                {
                    return requiresFocus;
                }
                set
                {
                    if (value)
                    {
                        needsCursor = new CuiNeedsCursorComponent();
                        Element.Components.Add(needsCursor);
                    }
                    else
                    {
                        Element.Components.Remove(needsCursor);
                    }

                    requiresFocus = value;
                }
            }

            public UIPanel(UIContainer container, Vector2 position, float width, float height, string color = "0 0 0 .85", string pngImage = "") : base(container)
            {
                panel = new CuiImageComponent
                {
                    Color = color
                };

                this.SetPosition(position.x, position.y);
                this.SetSize(width, height);

                Element.Components.Insert(0, panel);
            }
        }

        public class UIButtonContainer : UIContainer
        {
            private IEnumerable<UIButtonConfiguration> _buttonConfiguration;
            private Vector2 _position;
            private float _width;
            private float _height;
            private string _title;
            private string _panelColor;
            private bool _stackedButtons;
            private float _paddingPercentage;
            private int _titleSize;
            private int _buttonFontSize;


            const float TITLE_PERCENTAGE = 0.20f;

            private float _paddingAmount;
            private bool _hasTitle;

            public UIButtonContainer(IEnumerable<UIButtonConfiguration> buttonConfiguration, string panelBgColor, Vector2 position, float width, float height, float paddingPercentage = 0.05f, string title = "", int titleSize = 30, int buttonFontSize = 15, bool stackedButtons = true)
            {
                _buttonConfiguration = buttonConfiguration;
                _position = position;
                _width = width;
                _height = height;
                _title = title;
                _titleSize = titleSize;
                _panelColor = panelBgColor;
                _stackedButtons = stackedButtons;
                _paddingPercentage = paddingPercentage;
                _buttonFontSize = buttonFontSize;

                Init();
            }

            private void Init()
            {
                var panel = new UIPanel(this, new Vector2(_position.x, _position.y), _width, _height, _panelColor);

                _paddingAmount = (_stackedButtons ? _height : _width) * _paddingPercentage / _buttonConfiguration.Count();

                var firstButtonPosition = new Vector2(_position.x + _paddingAmount, _position.y + _paddingAmount);
                var titleHeight = TITLE_PERCENTAGE * _height;

                if (!string.IsNullOrEmpty(_title))
                {
                    _hasTitle = true;

                    var titlePanel = new UIPanel(this, new Vector2(_position.x, _position.y + _height - titleHeight), _width, titleHeight);
                    var titleLabel = new UILabel(this, _title, fontSize: _titleSize, parent: titlePanel.Element.Name);
                }

                var buttonHeight = (_height - (_paddingAmount * 2) - (_hasTitle ? titleHeight : 0) - (_paddingAmount * (_buttonConfiguration.Count() - 1))) / (_stackedButtons ? _buttonConfiguration.Count() : 1);
                var buttonWidth = _stackedButtons
                    ? (_width - (_paddingAmount * 2))
                    : ((_width - (_paddingAmount * 2) - (_paddingAmount * (_buttonConfiguration.Count() - 1))) / _buttonConfiguration.Count());

                _plugin.Puts($"ButtonHeight {buttonHeight} ButtonWidth {buttonWidth}");
                for (var buttonId = 0; buttonId < _buttonConfiguration.Count(); buttonId++)
                {
                    var buttonConfig = _buttonConfiguration.ElementAt(buttonId);
                    var button = new UIButton(this, buttonText: buttonConfig.ButtonName, buttonColor: buttonConfig.ButtonColor, fontSize: _buttonFontSize);

                    if (!_stackedButtons)
                    {
                        button.SetPosition(
                            firstButtonPosition.x + ((buttonWidth + _paddingAmount) * buttonId + _paddingAmount),
                            firstButtonPosition.y + (_paddingAmount) * 2);
                    }
                    else
                    {
                        button.SetPosition(
                            firstButtonPosition.x,
                            firstButtonPosition.y + ((buttonHeight + _paddingAmount) * buttonId + _paddingAmount));
                    }

                    button.SetSize(
                        buttonWidth - (_stackedButtons ? 0 : _paddingAmount * 2),
                        buttonHeight - (_stackedButtons ? _paddingAmount * 2 : 0));

                    button.AddCallback(buttonConfig.callback);
                    button.AddChatCommand(buttonConfig.ButtonCommand);
                }
            }
        }

        public class UIButtonConfiguration
        {
            public string ButtonName { get; set; }
            public string ButtonCommand { get; set; }
            public string ButtonColor { get; set; }
            public Action<BasePlayer> callback { get; set; }
        }

        public class UIImage : UIPanel
        {
            public CuiImageComponent Image { get; private set; }

            public UIImage(UIContainer container, Vector2 position, float width, float height) : base(container, position, width, height)
            {
                Image = new CuiImageComponent();
                Element.Components.Insert(0, Image);
            }
        }

        public class UIRawImage : UIElement
        {
            public CuiRawImageComponent Image { get; private set; }

            public UIRawImage(UIContainer container, Vector2 position, float width, float height, string png) : base(container)
            {
                var panel = new UIPanel(container, position, width, height);

                Element.Parent = panel.Element.Name;

                Image = new CuiRawImageComponent()
                {
                    Png = png,
                    Sprite = "assets/content/textures/generic/fulltransparent.tga"
                };

                Element.Components.Insert(0, Image);
            }
        }

        public class UIContainer
        {
            public List<UIContainer> ChildContainers { get; private set; } = new List<UIContainer>();
            public List<UIElement> Elements { get; private set; } = new List<UIElement>();

            private HashSet<BasePlayer> _players { get; set; } = new HashSet<BasePlayer>();

            public UIContainer()
            {
            }

            private void AddPlayer(BasePlayer player)
            {
                if (!_players.Contains(player))
                    _players.Add(player);
            }

            public void Show(BasePlayer player)
            {
                AddPlayer(player);

                foreach (UIElement element in Elements)
                {
                    element.Show(player);
                }

                foreach (UIContainer container in ChildContainers)
                {
                    container.Show(player);
                }
            }

            public void RemoveElements<T>(IEnumerable<T> elementsToRemove) where T : UIElement
            {
                foreach (var element in elementsToRemove)
                {
                    if (Elements.Contains(element))
                    {
                        element.HideAll();
                        Elements.Remove(element);
                    }
                }
            }

            public void Hide(BasePlayer player)
            {
                foreach (UIElement element in Elements)
                {
                    element.Hide(player);
                }

                foreach (UIContainer container in ChildContainers)
                {
                    container.Hide(player);
                }
            }

            public void HideAll()
            {
                foreach (BasePlayer player in _players)
                {
                    Hide(player);
                }
            }

            public void AddElement(UIElement element)
            {
                Elements.Add(element);
            }

            public void AddChildContainer(UIContainer container)
            {
                ChildContainers.Add(container);
            }
        }

        #endregion

        public const int objectsPerScreen = 30;

        public class MemoryObjectInfoUI : UIContainer
        {
            public UIButton expand { get; set; }
            private UIPanel background { get; set; }
            private UILabel label { get; set; }
            public ObjectMemoryInfo memoryObject { get; set; }

            public MemoryObjectInfoUI(ObjectMemoryInfo obj, Vector2 pos, MemoryTableUIManager manager, bool parent = true)
            {
                memoryObject = obj;
                background = new UIPanel(this, pos, 1f - pos.x - 0.05f, (0.90f / objectsPerScreen));
                AddElement(background);

                label = new UILabel(this, obj.GetVisualText(), alignment: TextAnchor.MiddleLeft);
                label.SetSize(1f, 1f);
                label.SetPosition(0.0f, 0f);
                label.SetParent(background);
                AddElement(label);

                if (!IsValueType(memoryObject._target))
                {
                    expand = new UIButton(this, buttonColor: parent ? "1 0 0 1" : "0 1 0 1", fontSize: 10, textColor: "1 1 1 1");
                    expand.AddCallback((arg) =>
                    {
                        if (parent)
                        {
                            manager.Shrink(this);
                        }
                        else
                        {
                            manager.Expand(this);
                        }

                    });
                    expand.SetSize(0.005f, 0.45f);
                    expand.SetPosition(0.0f, 0.5f - expand.size.y / 2);
                    expand.SetParent(background);
                    //expand.textComponent.Text = parent ? "-" : "+";
                    AddElement(expand);
                    label.SetPosition(label.position.x + expand.size.x + 0.005f, label.position.y);
                }

                Show(manager._player);
            }

            public MemoryObjectInfoUI(MethodInfo method, Vector2 pos, MemoryTableUIManager manager, ObjectMemoryInfo obj)
            {
                background = new UIPanel(this, pos, 1f - pos.x - 0.05f, (0.90f / objectsPerScreen));
                AddElement(background);

                label = new UILabel(this, ObjectMemoryInfo.GetMethodText(method), alignment: TextAnchor.MiddleLeft);
                label.SetSize(1f, 1f);
                label.SetPosition(0.0f, 0f);
                label.SetParent(background);
                AddElement(label);

                expand = new UIButton(this, buttonColor: "0 0 1 1", fontSize: 10, textColor: "1 1 1 1");
                expand.AddCallback((arg) =>
                {
                    if (method.ReturnType != null)
                    {
                        if (method.ReturnType.IsValueType || method.ReturnType == typeof(string))
                        {
                            _plugin.PrintToChat(manager._player, method.Invoke(obj._target, null)?.ToString());
                        }
                        else //When clicking on a function that returns a object to explore
                        {
                            var objectReturn = method.Invoke(obj._target, null);
                            if (objectReturn != null) //Explore blue function
                            {
                                var rootObject = new ObjectMemoryInfo(objectReturn, int.MaxValue, objectReturn.GetType().Name, obj);
                                manager.ShowObject(rootObject);
                            }
                        }
                    }
                    else
                    {
                        _plugin.PrintToChat($"Executed {ObjectMemoryInfo.GetMethodText(method)}");
                    }
                
                });
                expand.SetSize(0.005f, 0.45f);
                expand.SetPosition(0.0f, 0.5f - expand.size.y / 2);
                expand.SetParent(background);
                AddElement(expand);
                label.SetPosition(label.position.x + expand.size.x + 0.005f, label.position.y);

                Show(manager._player);
            }

        }

        public class MemoryTableUIManager : UIContainer
        {
            public ObjectMemoryInfo rootObject { get; set; }

            public MemoryObjectInfoUI currentObject { get; set; }

            public List<MemoryObjectInfoUI> shownObjects { get; set; } = new List<MemoryObjectInfoUI>();

            private UIButton nextPage { get; set; }
            private UIButton prevPage { get; set; }

            public BasePlayer _player { get; set; }

            private int currentIndex { get; set; }

            public MemoryTableUIManager()
            {

                nextPage = new UIButton(this, "Next");
                nextPage.SetPosition(0.51f, 0f);
                nextPage.SetSize(0.09f, 0.03f);
                nextPage.AddCallback((player) => { NextPage(); });
                //AddElement(nextPage);

                prevPage = new UIButton(this, "Prev");
                prevPage.SetPosition(0.4f, 0f);
                prevPage.SetSize(0.09f, 0.03f);
                prevPage.AddCallback((player) => { PrevPage(); });
                //AddElement(prevPage);
            }

            public void Destroy() 
            {
                foreach(var item in shownObjects)
                {
                    item.HideAll();
                }
                currentObject.HideAll();
                nextPage?.HideAll();
                prevPage?.HideAll();
                HideAll();
            }

            public void ShowPlayer(BasePlayer player)
            {
                _player = player;
                rootObject = new ObjectMemoryInfo(Oxide.Core.Interface.Oxide.RootPluginManager.GetPlugins(), int.MaxValue, "Plugins");
                ShowObject(rootObject);
            }

            public void HidePlayer(BasePlayer player)
            {
                _player = null;
                Destroy();
            }

            public void LinqQuery(BasePlayer player, string cmd)
            {
                string[] commands = cmd.Split('.');
            }

            public void Expand(MemoryObjectInfoUI obj)
            {
                if (obj.memoryObject != null)
                {
                    ShowObject(obj.memoryObject);
                }
            }

            public void Shrink(MemoryObjectInfoUI obj)
            {
                if (currentObject.memoryObject == rootObject)
                {
                    return;
                }
                if (obj.memoryObject._parent != null)
                {
                    ShowObject(obj.memoryObject._parent);
                }
            }

            public void NextPage()
            {
                currentIndex += objectsPerScreen;
                ShowObject(currentObject.memoryObject, true);
            }

            public void PrevPage()
            {
                currentIndex = Mathf.Clamp(currentIndex -= objectsPerScreen, 0, currentIndex);
                ShowObject(currentObject.memoryObject, true);
            }

            private void HideCurrent()
            {
                currentObject?.HideAll();
                foreach (var item in shownObjects)
                {
                    item.HideAll();
                }
            }

            public void ShowObject(ObjectMemoryInfo obj, bool changePage = false)
            {
                HideCurrent();
                if (!changePage)
                {
                    currentIndex = 0;
                }
                int i = 0;
                currentObject = new MemoryObjectInfoUI(obj, new Vector2(0.25f, 0.95f), this);
                obj.Expand();
                if (obj.children.Count == 0)
                {
                    _plugin.Puts("No children!");
                    _plugin.Puts(IsValueType(obj._target).ToString());
                    return;
                }
                bool nextPageNeeded = false;
                Vector2 pos = new Vector2(0.25f, 0.90f);
                foreach (var item in obj.children)
                {
                    //_plugin.Puts($"i: {i}, currentIndex: {currentIndex}");
                    if (i < currentIndex)
                    {
                        i++;
                        continue;
                    }
                    if (i >= currentIndex + objectsPerScreen && (obj.children.Count != objectsPerScreen))
                    {
                        nextPageNeeded = true;
                        break;
                    }
                    shownObjects.Add(new MemoryObjectInfoUI(item, pos, this, false));
                    pos.y -= (0.90f / objectsPerScreen);
                    i++;
                }

                foreach(var method in obj.methods)
                {
                    if (i < currentIndex)
                    {
                        i++;
                        continue;
                    }
                    if (i >= currentIndex + objectsPerScreen)
                    {
                        nextPageNeeded = true;
                        break;
                    }
                    shownObjects.Add(new MemoryObjectInfoUI(method, pos, this, obj));
                    pos.y -= (0.90f / objectsPerScreen);
                    i++;
                }

                nextPage.HideAll();
                if (nextPageNeeded)
                {
                    nextPage.Show(_player);
                }
                prevPage.HideAll();
                if (currentIndex > 0)
                {
                    prevPage.Show(_player);
                }
            }
        }
    }

}

// --- End of file: VisualDebug.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-deployed-locks ---
// --- Original File Path: V/VehicleDeployedLocks/VehicleDeployedLocks.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vehicle Deployed Locks", "WhiteThunder", "1.13.5")]
    [Description("Allows players to deploy code locks and key locks to vehicles.")]
    internal class VehicleDeployedLocks : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Clans, Friends;

        private const string Permission_CodeLock_Prefix = "vehicledeployedlocks.codelock";
        private const string Permission_KeyLock_Prefix = "vehicledeployedlocks.keylock";
        private const string Permission_MasterKey = "vehicledeployedlocks.masterkey";

        private const string Prefab_CodeLock_DeployedEffect = "assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab";
        private const string Prefab_CodeLock_DeniedEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
        private const string Prefab_CodeLock_UnlockEffect = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";

        private const float MaxDeployDistance = 3;

        private Configuration _config;

        private CooldownManager _craftCodeLockCooldowns;
        private CooldownManager _craftKeyLockCooldowns;

        private readonly VehicleInfoManager _vehicleInfoManager;
        private readonly LockedVehicleTracker _lockedVehicleTracker;
        private readonly AutoUnlockManager _autoUnlockManager;
        private readonly ReskinManager _reskinManager;

        private readonly object False = false;

        private enum PayType { Item, Resources, Free }

        public VehicleDeployedLocks()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
            _lockedVehicleTracker = new LockedVehicleTracker(_vehicleInfoManager);
            _autoUnlockManager = new AutoUnlockManager(this, _lockedVehicleTracker);
            _reskinManager = new ReskinManager(_vehicleInfoManager, _lockedVehicleTracker);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission_MasterKey, this);
            permission.RegisterPermission(LockInfo_CodeLock.PermissionFree, this);
            permission.RegisterPermission(LockInfo_CodeLock.PermissionAllVehicles, this);
            permission.RegisterPermission(LockInfo_KeyLock.PermissionFree, this);
            permission.RegisterPermission(LockInfo_KeyLock.PermissionAllVehicles, this);

            _craftKeyLockCooldowns = new CooldownManager(_config.CraftCooldownSeconds);
            _craftCodeLockCooldowns = new CooldownManager(_config.CraftCooldownSeconds);

            if (_config.AllowPushWhileLockedOut)
            {
                Unsubscribe(nameof(OnVehiclePush));
            }

            Unsubscribe(nameof(OnEntityKill));
        }

        private void OnServerInitialized()
        {
            _vehicleInfoManager.OnServerInitialized();
            _lockedVehicleTracker.OnServerInitialized();
            _autoUnlockManager.OnServerInitialized(_config.AutoUnlockSettings);

            if (_config.UpdateLockPositions)
            {
                foreach (var networkable in BaseNetworkable.serverEntities)
                {
                    var entity = networkable as BaseEntity;
                    if ((object)entity == null)
                        continue;

                    var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                    if (vehicleInfo == null)
                        continue;

                    var lockEntity = GetVehicleLock(entity);
                    if (lockEntity == null)
                        continue;

                    var transform = lockEntity.transform;
                    transform.localPosition = vehicleInfo.LockPosition;
                    transform.localRotation = vehicleInfo.LockRotation;
                    lockEntity.SendNetworkUpdate_Position();
                }
            }

            Subscribe(nameof(OnEntityKill));
        }

        private object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            // Don't lock taxi modules
            if (entity is ModularCarSeat carSeat && IsTaxiSeat(carSeat))
                return null;

            return CanPlayerInteractWithParentVehicle(player, entity);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            // Don't lock taxi module shopfronts
            if (container is ModularVehicleShopFront)
                return null;

            return CanPlayerInteractWithParentVehicle(player, container);
        }

        private object CanLootEntity(BasePlayer player, ContainerIOEntity container)
        {
            return CanPlayerInteractWithParentVehicle(player, container);
        }

        private object CanLootEntity(BasePlayer player, RidableHorse horse)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object CanLootEntity(BasePlayer player, RidableHorse2 horse)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object CanLootEntity(BasePlayer player, ModularCarGarage carLift)
        {
            if (carLift == null
                || _config.ModularCarSettings.AllowEditingWhileLockedOut
                || !carLift.PlatformIsOccupied)
                return null;

            return CanPlayerInteractWithVehicle(player, carLift.carOccupant);
        }

        private object OnHorseLead(RidableHorse horse, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object OnHorseLead(RidableHorse2 horse, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object OnHotAirBalloonToggle(HotAirBalloon hab, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, hab);
        }

        private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player)
        {
            if (electricSwitch == null)
                return null;

            var autoTurret = electricSwitch.GetParentEntity() as AutoTurret;
            if (autoTurret != null)
                return CanPlayerInteractWithParentVehicle(player, autoTurret);

            return null;
        }

        private object OnTurretAuthorize(AutoTurret entity, BasePlayer player)
        {
            return CanPlayerInteractWithParentVehicle(player, entity);
        }

        private object OnTurretTarget(AutoTurret autoTurret, BasePlayer player)
        {
            if (autoTurret == null || player == null || player.UserIDString == null)
                return null;

            var turretParent = autoTurret.GetParentEntity();
            var vehicle = turretParent as BaseVehicle ?? (turretParent as BaseVehicleModule)?.Vehicle;
            if (vehicle == null)
                return null;

            var baseLock = GetVehicleLock(vehicle);
            if (baseLock == null)
                return null;

            if (CanPlayerBypassLock(player, baseLock, provideFeedback: false))
                return False;

            return null;
        }

        private object CanSwapToSeat(BasePlayer player, ModularCarSeat carSeat)
        {
            // Don't lock taxi modules
            if (IsTaxiSeat(carSeat))
                return null;

            return CanPlayerInteractWithParentVehicle(player, carSeat, provideFeedback: false);
        }

        private object OnVehiclePush(BaseVehicle vehicle, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, vehicle);
        }

        private void OnEntityKill(BaseLock baseLock)
        {
            var vehicle = GetParentVehicle(baseLock);
            if (vehicle == null)
                return;

            _lockedVehicleTracker.OnLockRemoved(vehicle);
        }

        // Handle the case where a cockpit is removed but the car remains
        // If a lock is present, either move the lock to another cockpit or destroy it
        private void OnEntityKill(VehicleModuleSeating seatingModule)
        {
            if (seatingModule == null || !seatingModule.HasADriverSeat())
                return;

            var car = seatingModule.Vehicle as ModularCar;
            if (car == null)
                return;

            var baseLock = seatingModule.GetComponentInChildren<BaseLock>();
            if (baseLock == null)
                return;

            baseLock.SetParent(null);

            var car2 = car;
            var baseLock2 = baseLock;

            NextTick(() =>
            {
                if (car2 == null)
                {
                    _lockedVehicleTracker.OnLockRemoved(car2);
                    baseLock2.Kill();
                }
                else
                {
                    var driverModule = FindFirstDriverModule(car2);
                    if (driverModule == null)
                    {
                        _lockedVehicleTracker.OnLockRemoved(car2);
                        baseLock2.Kill();
                    }
                    else
                    {
                        baseLock2.SetParent(driverModule);
                    }
                }
            });
        }

        // Allow players to deploy locks directly without any commands.
        private object CanDeployItem(BasePlayer basePlayer, Deployer deployer, NetworkableId entityId)
        {
            if (basePlayer == null || deployer == null)
                return null;

            var deployable = deployer.GetDeployable();
            if (deployable == null)
                return null;

            var activeItem = basePlayer.GetActiveItem();
            if (activeItem == null)
                return null;

            var itemid = activeItem.info.itemid;

            LockInfo lockInfo;
            if (itemid == LockInfo_CodeLock.ItemId)
            {
                lockInfo = LockInfo_CodeLock;
            }
            else if (itemid == LockInfo_KeyLock.ItemId)
            {
                lockInfo = LockInfo_KeyLock;
            }
            else
            {
                return null;
            }

            var vehicleInfo = GetVehicleAndInfo(BaseNetworkable.serverEntities.Find(entityId) as BaseEntity, basePlayer, out var vehicle, fromDeployHook: true);
            if (vehicleInfo == null)
                return null;

            var player = basePlayer.IPlayer;

            // Trick to make sure the replies are in chat instead of console.
            player.LastCommand = CommandType.Chat;

            if (!VerifyCanDeploy(player, vehicle, vehicleInfo, lockInfo, out var payType)
                || !VerifyDeployDistance(player, vehicle))
                return False;

            DeployLockForPlayer(vehicle, vehicleInfo, lockInfo, basePlayer, payType);
            return False;
        }

        private object OnEntityReskin(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            var baseLock = GetVehicleLock(snowmobile);
            if (baseLock == null)
                return null;

            if (_vehicleInfoManager.GetVehicleInfo(snowmobile) == null)
                return null;

            if (baseLock.IsLocked() && !CanPlayerBypassLock(player, baseLock, provideFeedback: true))
                return False;

            _reskinManager.HandleReskinPre(snowmobile, baseLock);

            // In case another plugin blocks the pre-hook, add back or destroy the lock.
            NextTick(_reskinManager.CleanupAction);

            return null;
        }

        private void OnEntityReskinned(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            _reskinManager.HandleReskinPost(snowmobile);
        }

        #endregion

        #region API

        [HookMethod(nameof(API_DeployCodeLock))]
        public CodeLock API_DeployCodeLock(BaseEntity vehicle, BasePlayer player, bool isFree = true)
        {
            return DeployLockForAPI(vehicle, player, LockInfo_CodeLock, isFree) as CodeLock;
        }

        [HookMethod(nameof(API_DeployKeyLock))]
        public KeyLock API_DeployKeyLock(BaseEntity vehicle, BasePlayer player, bool isFree = true)
        {
            return DeployLockForAPI(vehicle, player, LockInfo_KeyLock, isFree) as KeyLock;
        }

        [HookMethod(nameof(API_CanPlayerDeployCodeLock))]
        public bool API_CanPlayerDeployCodeLock(BasePlayer player, BaseEntity vehicle)
        {
            return CanPlayerDeployLockForAPI(player, vehicle, LockInfo_CodeLock);
        }

        [HookMethod(nameof(API_CanPlayerDeployKeyLock))]
        public bool API_CanPlayerDeployKeyLock(BasePlayer player, BaseEntity vehicle)
        {
            return CanPlayerDeployLockForAPI(player, vehicle, LockInfo_KeyLock);
        }

        [HookMethod(nameof(API_CanAccessVehicle))]
        public bool API_CanAccessVehicle(BasePlayer player, BaseEntity vehicle, bool provideFeedback = true)
        {
            return CanPlayerInteractWithVehicle(player, vehicle, provideFeedback) == null;
        }

        [HookMethod(nameof(API_RegisterCustomVehicleType))]
        public void API_RegisterCustomVehicleType(string vehicleType, Vector3 lockPosition, Quaternion lockRotation, string parentBone, Func<BaseEntity, BaseEntity> determineLockParent)
        {
            _vehicleInfoManager.RegisterCustomVehicleType(this, new VehicleInfo()
            {
                VehicleType = vehicleType,
                LockPosition = lockPosition,
                LockRotation = lockRotation,
                ParentBone = parentBone,
                DetermineLockParent = determineLockParent,
            });
        }

        #endregion

        #region Commands

        [Command("vehiclecodelock", "vcodelock", "vlock")]
        private void CodeLockCommand(IPlayer player, string cmd, string[] args)
        {
            LockCommand(player, LockInfo_CodeLock);
        }

        [Command("vehiclekeylock", "vkeylock")]
        private void KeyLockCommand(IPlayer player, string cmd, string[] args)
        {
            LockCommand(player, LockInfo_KeyLock);
        }

        private void LockCommand(IPlayer player, LockInfo lockInfo)
        {
            if (player.IsServer)
                return;

            var basePlayer = player.Object as BasePlayer;
            var vehicleInfo = GetVehicleAndInfo(GetLookEntity(basePlayer, MaxDeployDistance), basePlayer, out var vehicle);
            if (vehicleInfo == null)
            {
                ReplyToPlayer(player, Lang.DeployErrorNoVehicleFound);
                return;
            }

            if (!VerifyCanDeploy(player, vehicle, vehicleInfo, lockInfo, out var payType))
                return;

            DeployLockForPlayer(vehicle, vehicleInfo, lockInfo, basePlayer, payType);
        }

        #endregion

        #region Helper Methods - General

        private static bool HasPermissionAny(IPlayer player, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (player.HasPermission(perm))
                    return true;
            }

            return false;
        }

        private static BaseLock GetVehicleLock(BaseEntity vehicle)
        {
            return vehicle.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
        }

        private static bool IsLockableEntity(BaseEntity entity)
        {
            if (entity.IsBusy())
                return false;

            return entity.HasSlot(BaseEntity.Slot.Lock);
        }

        private static string[] FindPrefabsOfType<T>() where T : BaseEntity
        {
            var prefabList = new List<string>();

            foreach (var assetPath in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(assetPath)?.GetComponent<T>();
                if (entity == null)
                    continue;

                prefabList.Add(entity.PrefabName);
            }

            return prefabList.ToArray();
        }

        private static bool IsTaxiSeat(ModularCarSeat carSeat)
        {
            return carSeat is { associatedSeatingModule.DoorsAreLockable: false };
        }

        #endregion

        #region Helper Methods - Lock Authorization

        private bool IsPlayerAuthorizedToCodeLock(ulong userID, CodeLock codeLock)
        {
            return codeLock.whitelistPlayers.Contains(userID)
                || codeLock.guestPlayers.Contains(userID);
        }

        private bool IsPlayerAuthorizedToLock(BasePlayer player, BaseLock baseLock)
        {
            return (baseLock as KeyLock)?.HasLockPermission(player)
                ?? IsPlayerAuthorizedToCodeLock(player.userID, baseLock as CodeLock);
        }

        private bool PlayerHasMasterKeyForLock(BasePlayer player)
        {
            return permission.UserHasPermission(player.UserIDString, Permission_MasterKey);
        }

        private bool IsLockSharedWithPlayer(BasePlayer player, BaseLock baseLock)
        {
            var ownerId = baseLock.OwnerID;
            if (ownerId == 0 || ownerId == player.userID)
                return false;

            // In case the owner was locked out for some reason
            var codeLock = baseLock as CodeLock;
            if (codeLock != null && !IsPlayerAuthorizedToCodeLock(ownerId, codeLock))
                return false;

            var sharingSettings = _config.SharingSettings;
            if (sharingSettings.Team && player.currentTeam != 0)
            {
                var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (team != null && team.members.Contains(ownerId))
                    return true;
            }

            if (sharingSettings.Friends && Friends != null)
            {
                var friendsResult = Friends.Call("HasFriend", baseLock.OwnerID, player.userID);
                if (friendsResult is true)
                    return true;
            }

            if ((sharingSettings.Clan || sharingSettings.ClanOrAlly) && Clans != null)
            {
                var clanMethodName = sharingSettings.ClanOrAlly ? "IsMemberOrAlly" : "IsClanMember";
                var clanResult = Clans.Call(clanMethodName, ownerId.ToString(), player.UserIDString);
                if (clanResult is true)
                    return true;
            }

            return false;
        }

        private bool CanPlayerBypassLock(BasePlayer player, BaseLock baseLock, bool provideFeedback)
        {
            var hookResult = Interface.CallHook("CanUseLockedEntity", player, baseLock);
            if (hookResult is bool result)
                return result;

            if (_config.AllowNPCsToBypassLocks && (player.IsNpc || !player.userID.IsSteamId()))
                return true;

            var canAccessLock = IsPlayerAuthorizedToLock(player, baseLock)
                || IsLockSharedWithPlayer(player, baseLock)
                || PlayerHasMasterKeyForLock(player);

            if (canAccessLock)
            {
                if (provideFeedback && !(baseLock is KeyLock))
                {
                    Effect.server.Run(Prefab_CodeLock_UnlockEffect, baseLock, 0, Vector3.zero, Vector3.forward);
                }

                return true;
            }

            if (provideFeedback)
            {
                Effect.server.Run(Prefab_CodeLock_DeniedEffect, baseLock, 0, Vector3.zero, Vector3.forward);
                ChatMessage(player, Lang.GenericErrorVehicleLocked);
            }

            return false;
        }

        private object CanPlayerInteractWithVehicle(BasePlayer player, BaseEntity vehicle, bool provideFeedback = true)
        {
            if (player == null || vehicle == null)
                return null;

            var baseLock = GetVehicleLock(vehicle);
            if (baseLock == null || !baseLock.IsLocked())
                return null;

            if (CanPlayerBypassLock(player, baseLock, provideFeedback))
                return null;

            return False;
        }

        private BaseEntity GetParentVehicle(BaseEntity entity)
        {
            var parent = entity.GetParentEntity();
            if (parent == null)
                return null;

            // Check for a vehicle module first since they are considered vehicles.
            var parentModule = parent as BaseVehicleModule;
            if (parentModule != null)
                return parentModule.Vehicle;

            if (parent is HotAirBalloon or BaseVehicle)
                return parent;

            return _vehicleInfoManager.GetCustomVehicleParent(entity);
        }

        private object CanPlayerInteractWithParentVehicle(BasePlayer player, BaseEntity entity, bool provideFeedback = true)
        {
            return CanPlayerInteractWithVehicle(player, GetParentVehicle(entity), provideFeedback);
        }

        #endregion

        #region Helper Methods - Deploying Locks

        private static bool DeployWasBlocked(BaseEntity vehicle, BasePlayer player, LockInfo lockInfo)
        {
            return Interface.CallHook(lockInfo.PreHookName, vehicle, player) is false;
        }

        private static BaseEntity GetLookEntity(BasePlayer player, float maxDistance)
        {
            if (!Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore))
                return null;

            return hit.GetEntity();
        }

        private static bool IsDead(BaseEntity entity)
        {
            return (entity as BaseCombatEntity)?.IsDead() ?? false;
        }

        private static VehicleModuleSeating FindFirstDriverModule(ModularCar car)
        {
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                if (car.TryGetModuleAt(socketIndex, out var module))
                {
                    var seatingModule = module as VehicleModuleSeating;
                    if (seatingModule != null && seatingModule.HasADriverSeat())
                        return seatingModule;
                }
            }

            return null;
        }

        private static bool CanCarHaveLock(ModularCar car)
        {
            return FindFirstDriverModule(car) != null;
        }

        private static bool CanVehicleHaveALock(BaseEntity vehicle)
        {
            // Only modular cars have restrictions
            var car = vehicle as ModularCar;
            return car == null || CanCarHaveLock(car);
        }

        private static Item GetPlayerLockItem(BasePlayer player, LockInfo lockInfo)
        {
            return player.inventory.FindItemByItemID(lockInfo.ItemId);
        }

        private static PayType DeterminePayType(IPlayer player, LockInfo lockInfo)
        {
            if (player.HasPermission(lockInfo.PermissionFree))
                return PayType.Free;

            return GetPlayerLockItem(player.Object as BasePlayer, lockInfo) != null
                ? PayType.Item
                : PayType.Resources;
        }

        private static bool CanPlayerAffordLock(BasePlayer player, LockInfo lockInfo, out PayType payType)
        {
            payType = DeterminePayType(player.IPlayer, lockInfo);
            if (payType != PayType.Resources)
                return true;

            return player.inventory.crafting.CanCraft(lockInfo.ItemDefinition);
        }

        private static RidableHorse2 GetClosestHorse(HitchTrough hitchTrough, BasePlayer player)
        {
            var closestDistance = float.MaxValue;
            RidableHorse2 closestHorse = null;

            foreach (var hitchSpot in hitchTrough.hitchSpots)
            {
                if (!hitchSpot.IsOccupied())
                    continue;

                var distance = Vector3.Distance(player.transform.position, hitchSpot.tr.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    if (hitchSpot.hitchableEntRef.Get(serverside: true) is RidableHorse2 ridableHorse)
                    {
                        closestHorse = ridableHorse;
                    }
                }
            }

            return closestHorse;
        }

        private static void ClaimVehicle(BaseEntity vehicle, ulong ownerId)
        {
            vehicle.OwnerID = ownerId;
            Interface.CallHook("OnVehicleOwnershipChanged", vehicle);
        }

        private bool IsVehicleConnectedEntity(BasePlayer basePlayer, BaseEntity entity, out BaseEntity vehicle)
        {
            vehicle = null;

            if (entity is BaseVehicleModule module)
            {
                vehicle = module.Vehicle ?? module.GetParentEntity();
                return true;
            }

            if (entity is ModularCarGarage carLift)
            {
                vehicle = carLift.carOccupant;
                return true;
            }

            if (entity is HitchTrough hitchTrough)
            {
                vehicle = GetClosestHorse(hitchTrough, basePlayer);
                return true;
            }

            return false;
        }

        private VehicleInfo GetVehicleAndInfo(BaseEntity entity, BasePlayer basePlayer, out BaseEntity vehicle, bool fromDeployHook = false)
        {
            if (entity == null)
            {
                vehicle = null;
                return null;
            }

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
            if (vehicleInfo != null)
            {
                vehicle = entity;
                return vehicleInfo;
            }

            if (IsVehicleConnectedEntity(basePlayer, entity, out vehicle) && vehicle != null)
                return _vehicleInfoManager.GetVehicleInfo(vehicle);

            if (fromDeployHook && IsLockableEntity(entity))
            {
                // Let the game decide whether to lock the entity, instead of resolving the parent vehicle.
                vehicle = null;
                return null;
            }

            vehicle = entity.GetParentEntity();
            if (vehicle == null)
                return null;

            return _vehicleInfoManager.GetVehicleInfo(vehicle);
        }

        private bool AllowNoOwner(BaseEntity vehicle)
        {
            return _config.AllowIfNoOwner
                || vehicle.OwnerID != 0;
        }

        private bool AllowDifferentOwner(IPlayer player, BaseEntity vehicle)
        {
            return _config.AllowIfDifferentOwner
                || vehicle.OwnerID == 0
                || vehicle.OwnerID.ToString() == player.Id;
        }

        private void MaybeChargePlayerForLock(BasePlayer player, LockInfo lockInfo, PayType payType)
        {
            if (payType == PayType.Free)
                return;

            if (payType == PayType.Item)
            {
                // Prefer taking the item they are holding in case they are deploying directly.
                var heldItem = player.GetActiveItem();
                if (heldItem != null && heldItem.info.itemid == lockInfo.ItemId)
                {
                    heldItem.UseItem(1);
                }
                else
                {
                    player.inventory.Take(null, lockInfo.ItemId, 1);
                }

                player.Command("note.inv", lockInfo.ItemId, -1);
                return;
            }

            foreach (var ingredient in lockInfo.Blueprint.ingredients)
            {
                player.inventory.Take(null, ingredient.itemid, (int)ingredient.amount);
                player.Command("note.inv", ingredient.itemid, -ingredient.amount);
                GetCooldownManager(lockInfo).UpdateLastUsedForPlayer(player.UserIDString);
            }
        }

        private BaseLock DeployLock(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, ulong ownerId = 0)
        {
            var parentToEntity = vehicleInfo.DetermineLockParent(vehicle);
            if (parentToEntity == null)
                return null;

            var baseLock = GameManager.server.CreateEntity(lockInfo.Prefab, vehicleInfo.LockPosition, vehicleInfo.LockRotation) as BaseLock;
            if (baseLock == null)
                return null;

            var keyLock = baseLock as KeyLock;
            if (keyLock != null)
            {
                keyLock.keyCode = UnityEngine.Random.Range(1, 100000);
            }

            // Assign lock ownership when the lock is being deployed by/for a player.
            if (ownerId != 0)
            {
                baseLock.OwnerID = ownerId;
            }

            baseLock.SetParent(parentToEntity, vehicleInfo.ParentBone);
            baseLock.Spawn();
            vehicle.SetSlot(BaseEntity.Slot.Lock, baseLock);

            // Auto lock key locks to be consistent with vanilla.
            if (ownerId != 0 && keyLock != null)
            {
                keyLock.SetFlag(BaseEntity.Flags.Locked, true);
            }

            Effect.server.Run(Prefab_CodeLock_DeployedEffect, baseLock.transform.position);
            Interface.CallHook("OnVehicleLockDeployed", vehicle, baseLock);
            _lockedVehicleTracker.OnLockAdded(vehicle);

            return baseLock;
        }

        private BaseLock DeployLockForPlayer(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, BasePlayer player, PayType payType)
        {
            var originalVehicleOwnerId = vehicle.OwnerID;

            // Temporarily set the player as the owner of the vehicle, for compatibility with AutoCodeLock (OnItemDeployed).
            vehicle.OwnerID = player.userID;

            var baseLock = DeployLock(vehicle, vehicleInfo, lockInfo, player.userID);
            if (baseLock == null)
            {
                vehicle.OwnerID = originalVehicleOwnerId;
                return null;
            }

            // Allow other plugins to detect the code lock being deployed (e.g., to auto lock).
            var lockItem = GetPlayerLockItem(player, lockInfo);
            if (lockItem != null)
            {
                Interface.CallHook("OnItemDeployed", lockItem.GetHeldEntity(), vehicle, baseLock);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                player.inventory.containerMain.capacity++;
                var temporaryLockItem = ItemManager.CreateByItemID(lockInfo.ItemId);
                if (player.inventory.GiveItem(temporaryLockItem))
                {
                    Interface.CallHook("OnItemDeployed", temporaryLockItem.GetHeldEntity(), vehicle, baseLock);
                    temporaryLockItem.RemoveFromContainer();
                }

                temporaryLockItem.Remove();
                player.inventory.containerMain.capacity--;
            }

            // Revert the vehicle owner to the original, after OnItemDeployed is called.
            vehicle.OwnerID = originalVehicleOwnerId;

            MaybeChargePlayerForLock(player, lockInfo, payType);

            // Potentially assign vehicle ownership when the lock is being deployed by/for a player.
            if (vehicle.OwnerID == 0)
            {
                if (_config.AutoClaimUnownedVehicles)
                {
                    ClaimVehicle(vehicle, player.userID);
                }
            }
            else if (vehicle.OwnerID != player.userID && _config.AutoReplaceVehicleOwnership)
            {
                ClaimVehicle(vehicle, player.userID);
            }

            return baseLock;
        }

        private BaseLock DeployLockForAPI(BaseEntity vehicle, BasePlayer player, LockInfo lockInfo, bool isFree)
        {
            if (vehicle == null || IsDead(vehicle))
                return null;

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
            if (vehicleInfo == null
                || GetVehicleLock(vehicle) != null
                || !CanVehicleHaveALock(vehicle))
                return null;

            PayType payType;
            if (isFree)
            {
                payType = PayType.Free;
            }
            else if (!VerifyPlayerCanDeployLock(player.IPlayer, lockInfo, out payType))
            {
                return null;
            }

            if (DeployWasBlocked(vehicle, player, lockInfo))
                return null;

            return player != null
                ? DeployLockForPlayer(vehicle, vehicleInfo, lockInfo, player, payType)
                : DeployLock(vehicle, vehicleInfo, lockInfo);
        }

        private bool CanPlayerDeployLockForAPI(BasePlayer player, BaseEntity vehicle, LockInfo lockInfo)
        {
            return vehicle != null
                && !IsDead(vehicle)
                && _vehicleInfoManager.GetVehicleInfo(vehicle) != null
                && AllowNoOwner(vehicle)
                && AllowDifferentOwner(player.IPlayer, vehicle)
                && player.CanBuild()
                && GetVehicleLock(vehicle) == null
                && CanVehicleHaveALock(vehicle)
                && CanPlayerAffordLock(player, lockInfo, out _)
                && !DeployWasBlocked(vehicle, player, lockInfo);
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyDeployDistance(IPlayer player, BaseEntity vehicle)
        {
            if (vehicle.Distance(player.Object as BasePlayer) <= MaxDeployDistance)
                return true;

            ReplyToPlayer(player, Lang.DeployErrorDistance);
            return false;
        }

        private bool VerifyPermissionToVehicleAndLockType(IPlayer player, VehicleInfo vehicleInfo, LockInfo lockInfo)
        {
            var vehiclePerm = lockInfo == LockInfo_CodeLock
                ? vehicleInfo.CodeLockPermission
                : vehicleInfo.KeyLockPermission;

            if (vehiclePerm != null && HasPermissionAny(player, lockInfo.PermissionAllVehicles, vehiclePerm))
                return true;

            ReplyToPlayer(player, Lang.GenericErrorNoPermission);
            return false;
        }

        private bool VerifyVehicleIsNotDead(IPlayer player, BaseEntity vehicle)
        {
            if (!IsDead(vehicle))
                return true;

            ReplyToPlayer(player, Lang.DeployErrorVehicleDead);
            return false;
        }

        private bool VerifyNotForSale(IPlayer player, BaseEntity vehicle)
        {
            var rideableAnimal = vehicle as BaseRidableAnimal;
            if (rideableAnimal == null || !rideableAnimal.IsForSale())
                return true;

            ReplyToPlayer(player, Lang.DeployErrorOther);
            return false;
        }

        private bool VerifyNoOwnershipRestriction(IPlayer player, BaseEntity vehicle)
        {
            if (!AllowNoOwner(vehicle))
            {
                ReplyToPlayer(player, Lang.DeployErrorNoOwner);
                return false;
            }

            if (!AllowDifferentOwner(player, vehicle))
            {
                ReplyToPlayer(player, Lang.DeployErrorDifferentOwner);
                return false;
            }

            return true;
        }

        private bool VerifyCanBuild(IPlayer player, BaseEntity vehicle)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return false;

            if (vehicle.OwnerID == 0 && _config.RequireTCIfNoOwner)
            {
                if (!basePlayer.IsBuildingAuthed() || !basePlayer.IsBuildingAuthed(vehicle.WorldSpaceBounds()))
                {
                    ReplyToPlayer(player, Lang.DeployErrorNoOwnerRequiresTC);
                    return false;
                }
            }
            else if (basePlayer.IsBuildingBlocked() || basePlayer.IsBuildingBlocked(vehicle.WorldSpaceBounds()))
            {
                ReplyToPlayer(player, Lang.GenericErrorBuildingBlocked);
                return false;
            }

            return true;
        }

        private bool VerifyVehicleHasNoLock(IPlayer player, BaseEntity vehicle)
        {
            if (GetVehicleLock(vehicle) == null)
                return true;

            ReplyToPlayer(player, Lang.DeployErrorHasLock);
            return false;
        }

        private bool VerifyVehicleCanHaveALock(IPlayer player, BaseEntity vehicle)
        {
            if (CanVehicleHaveALock(vehicle))
                return true;

            ReplyToPlayer(player, Lang.DeployErrorModularCarNoCockpit);
            return false;
        }

        private bool VerifyPlayerCanAffordLock(BasePlayer player, LockInfo lockInfo, out PayType payType)
        {
            if (CanPlayerAffordLock(player, lockInfo, out payType))
                return true;

            ChatMessage(player, Lang.DeployErrorInsufficientResources, lockInfo.ItemDefinition.displayName.translated);
            return false;
        }

        private bool VerifyOffCooldown(IPlayer player, LockInfo lockInfo, PayType payType)
        {
            if (payType != PayType.Resources)
                return true;

            var secondsRemaining = GetCooldownManager(lockInfo).GetSecondsRemaining(player.Id);
            if (secondsRemaining <= 0)
                return true;

            ChatMessage(player.Object as BasePlayer, Lang.GenericErrorCooldown, Math.Ceiling(secondsRemaining));
            return false;
        }

        private bool VerifyPlayerCanDeployLock(IPlayer player, LockInfo lockInfo, out PayType payType)
        {
            return VerifyPlayerCanAffordLock(player.Object as BasePlayer, lockInfo, out payType)
                && VerifyOffCooldown(player, lockInfo, payType);
        }

        private bool VerifyNotMounted(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo)
        {
            if (!vehicleInfo.IsMounted(vehicle))
                return true;

            ReplyToPlayer(player, Lang.DeployErrorMounted);
            return false;
        }

        private bool VerifyCanDeploy(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, out PayType payType)
        {
            var basePlayer = player.Object as BasePlayer;
            payType = PayType.Item;

            return VerifyPermissionToVehicleAndLockType(player, vehicleInfo, lockInfo)
                && VerifyVehicleIsNotDead(player, vehicle)
                && VerifyNotForSale(player, vehicle)
                && VerifyNoOwnershipRestriction(player, vehicle)
                && VerifyCanBuild(player, vehicle)
                && VerifyVehicleHasNoLock(player, vehicle)
                && VerifyVehicleCanHaveALock(player, vehicle)
                && VerifyPlayerCanDeployLock(player, lockInfo, out payType)
                && VerifyNotMounted(player, vehicle, vehicleInfo)
                && !DeployWasBlocked(vehicle, basePlayer, lockInfo);
        }

        #endregion

        #region Vehicle Info

        private class VehicleInfo
        {
            public string VehicleType;
            public string[] PrefabPaths;
            public Vector3 LockPosition;
            public Quaternion LockRotation;
            public string ParentBone;

            public string CodeLockPermission { get; private set; }
            public string KeyLockPermission { get; private set; }
            public uint[] PrefabIds { get; private set; }

            public Func<BaseEntity, BaseEntity> DetermineLockParent = entity => entity;
            public Func<BaseEntity, float> TimeSinceLastUsed = _ => 0;

            public void OnServerInitialized(VehicleDeployedLocks plugin)
            {
                CodeLockPermission = $"{Permission_CodeLock_Prefix}.{VehicleType}";
                KeyLockPermission = $"{Permission_KeyLock_Prefix}.{VehicleType}";

                if (!plugin.permission.PermissionExists(CodeLockPermission, plugin))
                {
                    plugin.permission.RegisterPermission(CodeLockPermission, plugin);
                }

                if (!plugin.permission.PermissionExists(KeyLockPermission, plugin))
                {
                    plugin.permission.RegisterPermission(KeyLockPermission, plugin);
                }

                // Custom vehicles aren't currently allowed to specify prefabs since they reuse existing prefabs.
                if (PrefabPaths != null)
                {
                    var prefabIds = new List<uint>();
                    foreach (var prefabName in PrefabPaths)
                    {
                        var prefabId = StringPool.Get(prefabName);
                        if (prefabId != 0)
                        {
                            prefabIds.Add(prefabId);
                        }
                        else
                        {
                            plugin.LogError($"Invalid prefab. Please alert the plugin maintainer -- {prefabName}");
                        }
                    }

                    PrefabIds = prefabIds.ToArray();
                }
            }

            // In the future, custom vehicles may be able to pass in a method to override this.
            public bool IsMounted(BaseEntity entity)
            {
                var vehicle = entity as BaseVehicle;
                if (vehicle != null)
                    return vehicle.AnyMounted();

                var mountable = entity as BaseMountable;
                if (mountable != null)
                    return mountable.AnyMounted();

                return false;
            }
        }

        private class VehicleInfoManager
        {
            private static readonly FieldInfo BikeTimeSinceLastUsedField = typeof(Bike).GetField("timeSinceLastUsed",
                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            private readonly VehicleDeployedLocks _plugin;
            private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo = new();
            private readonly Dictionary<string, VehicleInfo> _customVehicleTypes = new();

            public VehicleInfoManager(VehicleDeployedLocks plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                var allVehicles = new[]
                {
                    new VehicleInfo
                    {
                        VehicleType = "attackhelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab" },
                        LockPosition = new Vector3(-0.6f, 1.08f, 1.01f),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as AttackHelicopter)?.lastEngineOnTime ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "chinook",
                        PrefabPaths = new[] { "assets/prefabs/npc/ch47/ch47.entity.prefab" },
                        LockPosition = new Vector3(-1.175f, 2, 6.5f),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as CH47Helicopter)?.lastPlayerInputTime ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "duosub",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarineduo.entity.prefab" },
                        LockPosition = new Vector3(-0.455f, 1.29f, 0.75f),
                        LockRotation = Quaternion.Euler(0, 180, 10),
                        TimeSinceLastUsed = vehicle => (vehicle as SubmarineDuo)?.timeSinceLastUsed ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "hotairballoon",
                        PrefabPaths = new[] { "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab" },
                        LockPosition = new Vector3(1.45f, 0.9f, 0),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as HotAirBalloon)?.sinceLastBlast ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "kayak",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/kayak/kayak.prefab" },
                        LockPosition = new Vector3(-0.43f, 0.2f, 0.2f),
                        LockRotation = Quaternion.Euler(0, 90, 90),
                        TimeSinceLastUsed = vehicle => (vehicle as Kayak)?.timeSinceLastUsed ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "locomotive",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab" },
                        LockPosition = new Vector3(-0.11f, 2.89f, 4.95f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "magnetcrane",
                        PrefabPaths = new[] { "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab" },
                        LockPosition = new Vector3(-1.735f, -1.445f, 0.79f),
                        LockRotation = Quaternion.Euler(0, 0, 90),
                        ParentBone = "Top",
                        TimeSinceLastUsed = vehicle => Time.realtimeSinceStartup - (vehicle as MagnetCrane)?.lastDrivenTime ?? Time.realtimeSinceStartup,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "minicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/minicopter/minicopter.entity.prefab" },
                        LockPosition = new Vector3(-0.15f, 0.7f, -0.1f),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as Minicopter)?.lastEngineOnTime ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "modularcar",
                        // There are at least 37 valid Modular Car prefabs.
                        PrefabPaths = FindPrefabsOfType<ModularCar>(),
                        LockPosition = new Vector3(-0.9f, 0.35f, -0.5f),
                        DetermineLockParent = vehicle => FindFirstDriverModule((ModularCar)vehicle),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as ModularCar)?.lastEngineOnTime ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "motorbike.sidecar",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike_sidecar.prefab" },
                        LockPosition = new Vector3(-0.09f, 0.65f, 0.03f),
                        TimeSinceLastUsed = vehicle => (TimeSince)BikeTimeSinceLastUsedField.GetValue(vehicle),
                    },
                    new VehicleInfo
                    {
                        VehicleType = "motorbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike.prefab" },
                        LockPosition = new Vector3(-0.09f, 0.65f, 0.03f),
                        TimeSinceLastUsed = vehicle => (TimeSince)BikeTimeSinceLastUsedField.GetValue(vehicle),
                    },
                    new VehicleInfo
                    {
                        VehicleType = "pedalbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedalbike.prefab" },
                        LockPosition = new Vector3(0, 0.6f, 0.1f),
                        TimeSinceLastUsed = vehicle => (TimeSince)BikeTimeSinceLastUsedField.GetValue(vehicle),
                    },
                    new VehicleInfo
                    {
                        VehicleType = "pedaltrike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedaltrike.prefab" },
                        LockPosition = new Vector3(0, 0.6f, 0.1f),
                        TimeSinceLastUsed = vehicle => (TimeSince)BikeTimeSinceLastUsedField.GetValue(vehicle),
                    },
                    new VehicleInfo
                    {
                        VehicleType = "rhib",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rhib/rhib.prefab" },
                        LockPosition = new Vector3(-0.68f, 2.00f, 0.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as RHIB)?.timeSinceLastUsedFuel ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "ridablehorse",
                        PrefabPaths = new[]
                        {
                            "assets/content/vehicles/horse/ridablehorse2.prefab",
                            "assets/content/vehicles/horse/_old/testridablehorse.prefab",
                        },
                        LockPosition = new Vector3(-0.6f, 0.25f, -0.1f),
                        LockRotation = Quaternion.Euler(0, 95, 90),
                        ParentBone = "Horse_RootBone",
                        TimeSinceLastUsed = vehicle =>
                        {
                            var lastInputTime = vehicle switch
                            {
                                RidableHorse ridableHorse => ridableHorse.lastInputTime,
                                RidableHorse2 ridableHorse2 => ridableHorse2.lastRiddenTime,
                                _ => Time.time,
                            };

                            return Time.time - lastInputTime;
                        },
                    },
                    new VehicleInfo
                    {
                        VehicleType = "rowboat",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rowboat/rowboat.prefab" },
                        LockPosition = new Vector3(-0.83f, 0.51f, -0.57f),
                        TimeSinceLastUsed = vehicle => (vehicle as MotorRowboat)?.timeSinceLastUsedFuel ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "scraptransport",
                        PrefabPaths = new[] { "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab" },
                        LockPosition = new Vector3(-1.25f, 1.22f, 1.99f),
                        TimeSinceLastUsed = vehicle => Time.time - (vehicle as ScrapTransportHelicopter)?.lastEngineOnTime ?? Time.time,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "sedan",
                        PrefabPaths = new[] { "assets/content/vehicles/sedan_a/sedantest.entity.prefab" },
                        LockPosition = new Vector3(-1.09f, 0.79f, 0.5f),
                    },
                    new VehicleInfo
                    {
                        VehicleType = "sedanrail",
                        PrefabPaths = new[] { "assets/content/vehicles/sedan_a/sedanrail.entity.prefab" },
                        LockPosition = new Vector3(-1.09f, 1.025f, -0.26f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "snowmobile",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/snowmobile.prefab" },
                        LockPosition = new Vector3(-0.205f, 0.59f, 0.4f),
                        TimeSinceLastUsed = vehicle => (vehicle as Snowmobile)?.timeSinceLastUsed ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "solosub",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarinesolo.entity.prefab" },
                        LockPosition = new Vector3(0f, 1.85f, 0f),
                        LockRotation = Quaternion.Euler(0, 90, 90),
                        TimeSinceLastUsed = vehicle => (vehicle as BaseSubmarine)?.timeSinceLastUsed ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "tomaha",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab" },
                        LockPosition = new Vector3(-0.37f, 0.4f, 0.125f),
                        TimeSinceLastUsed = vehicle => (vehicle as Snowmobile)?.timeSinceLastUsed ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "tugboat",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/tugboat/tugboat.prefab" },
                        LockPosition = new Vector3(0.065f, 6.8f, 4.12f),
                        LockRotation = Quaternion.Euler(0, 90, 60),
                        TimeSinceLastUsed = vehicle => (vehicle as Tugboat)?.timeSinceLastUsedFuel ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcart",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart.entity.prefab" },
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcartaboveground",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab" },
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0,
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcartcovered",
                        PrefabPaths = new[] { "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab" },
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0,
                    },
                };

                foreach (var vehicleInfo in allVehicles)
                {
                    vehicleInfo.OnServerInitialized(_plugin);
                    foreach (var prefabId in vehicleInfo.PrefabIds)
                    {
                        _prefabIdToVehicleInfo[prefabId] = vehicleInfo;
                    }
                }
            }

            public void RegisterCustomVehicleType(VehicleDeployedLocks plugin, VehicleInfo vehicleInfo)
            {
                vehicleInfo.OnServerInitialized(plugin);
                _customVehicleTypes[vehicleInfo.VehicleType] = vehicleInfo;
            }

            public VehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                if (_prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out var vehicleInfo))
                    return vehicleInfo;

                foreach (var customVehicleInfo in _customVehicleTypes.Values)
                {
                    if (customVehicleInfo.DetermineLockParent(entity) != null)
                        return customVehicleInfo;
                }

                return null;
            }

            public BaseEntity GetCustomVehicleParent(BaseEntity entity)
            {
                foreach (var vehicleInfo in _customVehicleTypes.Values)
                {
                    var lockParent = vehicleInfo.DetermineLockParent(entity);
                    if (lockParent != null)
                        return lockParent;
                }

                return null;
            }
        }

        #endregion

        #region Lock Info

        private class LockInfo
        {
            public int ItemId;
            public string Prefab;
            public string PermissionAllVehicles;
            public string PermissionFree;
            public string PreHookName;

            public ItemDefinition ItemDefinition => ItemManager.FindItemDefinition(ItemId);

            public ItemBlueprint Blueprint => ItemManager.FindBlueprint(ItemDefinition);
        }

        private readonly LockInfo LockInfo_CodeLock = new()
        {
            ItemId = 1159991980,
            Prefab = "assets/prefabs/locks/keypad/lock.code.prefab",
            PermissionAllVehicles = $"{Permission_CodeLock_Prefix}.allvehicles",
            PermissionFree = $"{Permission_CodeLock_Prefix}.free",
            PreHookName = "CanDeployVehicleCodeLock",
        };

        private readonly LockInfo LockInfo_KeyLock = new()
        {
            ItemId = -850982208,
            Prefab = "assets/prefabs/locks/keylock/lock.key.prefab",
            PermissionAllVehicles = $"{Permission_KeyLock_Prefix}.allvehicles",
            PermissionFree = $"{Permission_KeyLock_Prefix}.free",
            PreHookName = "CanDeployVehicleKeyLock",
        };

        #endregion

        #region Locked Vehicle Tracker

        private class LockedVehicleTracker
        {
            public Dictionary<VehicleInfo, HashSet<BaseEntity>> VehiclesWithLocksByType { get; } = new();

            private readonly VehicleInfoManager _vehicleInfoManager;

            public LockedVehicleTracker(VehicleInfoManager vehicleInfoManager)
            {
                _vehicleInfoManager = vehicleInfoManager;
            }

            public void OnServerInitialized()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var baseEntity = entity as BaseEntity;
                    if (baseEntity == null)
                        continue;

                    var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(baseEntity);
                    if (vehicleInfo == null || GetVehicleLock(baseEntity) == null)
                        continue;

                    OnLockAdded(baseEntity);
                }
            }

            public void OnLockAdded(BaseEntity vehicle)
            {
                GetEntityListForVehicle(vehicle)?.Add(vehicle);
            }

            public void OnLockRemoved(BaseEntity vehicle)
            {
                GetEntityListForVehicle(vehicle)?.Remove(vehicle);
            }

            private HashSet<BaseEntity> EnsureEntityList(VehicleInfo vehicleInfo)
            {
                if (!VehiclesWithLocksByType.TryGetValue(vehicleInfo, out var vehicleList))
                {
                    vehicleList = new HashSet<BaseEntity>();
                    VehiclesWithLocksByType[vehicleInfo] = vehicleList;
                }
                return vehicleList;
            }

            private HashSet<BaseEntity> GetEntityListForVehicle(BaseEntity entity)
            {
                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                if (vehicleInfo == null)
                    return null;

                return EnsureEntityList(vehicleInfo);
            }
        }

        #endregion

        #region Auto Unlock Manager

        private class AutoUnlockManager
        {
            private VehicleDeployedLocks _plugin;
            private LockedVehicleTracker _lockedVehicleTracker;
            private AutoUnlockSettings _autoUnlockSettings;

            public AutoUnlockManager(VehicleDeployedLocks plugin, LockedVehicleTracker lockedVehicleTracker)
            {
                _plugin = plugin;
                _lockedVehicleTracker = lockedVehicleTracker;
            }

            public void OnServerInitialized(AutoUnlockSettings settings)
            {
                _autoUnlockSettings = settings;

                if (!settings.Enabled)
                    return;

                _plugin.timer.Every(settings.CheckIntervalSeconds, CheckVehicles);
            }

            private void CheckVehicles()
            {
                List<BaseEntity> remainingVehicles = null;

                foreach (var (vehicleInfo, vehicleList) in _lockedVehicleTracker.VehiclesWithLocksByType)
                {
                    foreach (var vehicle in vehicleList)
                    {
                        if (vehicle == null || vehicle.IsDestroyed)
                            continue;

                        if (_autoUnlockSettings.ExemptOwnedVehicles && vehicle.OwnerID != 0)
                            continue;

                        var baseLock = GetVehicleLock(vehicle);
                        if (baseLock == null || baseLock.IsDestroyed || !baseLock.IsLocked())
                            continue;

                        var timeSinceUsed = vehicleInfo.TimeSinceLastUsed(vehicle);
                        if (timeSinceUsed < _autoUnlockSettings.IdleSeconds)
                            continue;

                        if (_autoUnlockSettings.ExemptNearTC)
                        {
                            remainingVehicles ??= new List<BaseEntity>();
                            remainingVehicles.Add(vehicle);
                            continue;
                        }

                        Unlock(baseLock);
                    }
                }

                if (remainingVehicles == null)
                    return;

                var vehicleIndex = 0;

                // The remaining vehicles need more expensive checks, so spread them out across multiple frames.
                _plugin.timer.Repeat(0, remainingVehicles.Count, () =>
                {
                    var vehicle = remainingVehicles[vehicleIndex++];
                    if (vehicle == null || vehicle.IsDestroyed)
                        return;

                    var baseLock = GetVehicleLock(vehicle);
                    if (baseLock == null || baseLock.IsDestroyed || !baseLock.IsLocked())
                        return;

                    if (vehicle.GetBuildingPrivilege() != null)
                        return;

                    Unlock(baseLock);
                });
            }

            private void Unlock(BaseLock baseLock)
            {
                baseLock.SetFlag(BaseEntity.Flags.Locked, false);
                Effect.server.Run(Prefab_CodeLock_UnlockEffect, baseLock, 0, Vector3.zero, Vector3.forward);
            }
        }

        #endregion

        #region Reskin Management

        private class ReskinEvent
        {
            public BaseEntity Entity;
            public BaseLock BaseLock;
            public Vector3 Position;

            public void Assign(BaseEntity entity, BaseLock baseLock)
            {
                Entity = entity;
                BaseLock = baseLock;
                Position = entity?.transform.position ?? Vector3.zero;
            }

            public void Reset()
            {
                Assign(null, null);
            }
        }

        private class ReskinManager
        {
            private VehicleInfoManager _vehicleInfoManager;
            private LockedVehicleTracker _lockedVehicleTracker;

            // Pool only a single reskin event since usually there will be at most a single event per frame.
            private ReskinEvent _pooledReskinEvent;

            // Keep track of all reskin events happening in a frame, in case there are multiple.
            private List<ReskinEvent> _reskinEvents = new();

            public readonly Action CleanupAction;

            public ReskinManager(VehicleInfoManager vehicleInfoManager, LockedVehicleTracker lockedVehicleTracker)
            {
                _vehicleInfoManager = vehicleInfoManager;
                _lockedVehicleTracker = lockedVehicleTracker;
                CleanupAction = CleanupEvents;
            }

            public void HandleReskinPre(BaseEntity entity, BaseLock baseLock)
            {
                _pooledReskinEvent ??= new ReskinEvent();

                var reskinEvent = _pooledReskinEvent.Entity == null
                    ? _pooledReskinEvent
                    : new ReskinEvent();

                // Unparent the lock to prevent it from being destroyed.
                // It will later be parented to the newly spawned entity.
                baseLock.SetParent(null);

                reskinEvent.Assign(entity, baseLock);
                _reskinEvents.Add(reskinEvent);
            }

            public void HandleReskinPost(BaseEntity entity)
            {
                var reskinEvent = FindReskinEventForPosition(entity.transform.position);
                if (reskinEvent == null)
                    return;

                var baseLock = reskinEvent.BaseLock;
                if (baseLock == null || baseLock.IsDestroyed)
                    return;

                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                if (vehicleInfo == null)
                    return;

                _reskinEvents.Remove(reskinEvent);

                baseLock.SetParent(entity, vehicleInfo.ParentBone);
                entity.SetSlot(BaseEntity.Slot.Lock, baseLock);
                _lockedVehicleTracker.OnLockAdded(entity);

                var lockTransform = baseLock.transform;
                lockTransform.localPosition = vehicleInfo.LockPosition;
                lockTransform.localRotation = vehicleInfo.LockRotation;
                baseLock.SendNetworkUpdateImmediate();

                if (reskinEvent == _pooledReskinEvent)
                {
                    reskinEvent.Reset();
                }
            }

            private ReskinEvent FindReskinEventForPosition(Vector3 position)
            {
                foreach (var reskinEvent in _reskinEvents)
                {
                    if (reskinEvent.Position == position)
                        return reskinEvent;
                }

                return null;
            }

            private void CleanupEvents()
            {
                if (_reskinEvents.Count == 0)
                    return;

                foreach (var reskinEvent in _reskinEvents)
                {
                    var baseLock = reskinEvent.BaseLock;
                    if (baseLock == null || baseLock.IsDestroyed || baseLock.HasParent())
                        continue;

                    var entity = reskinEvent.Entity;
                    if (entity != null && !entity.IsDestroyed)
                    {
                        // The reskin event must have been blocked, so reparent the lock to it.
                        baseLock.SetParent(reskinEvent.Entity);
                        continue;
                    }

                    // The post event wasn't called, and the original entity is gone, so destroy the lock.
                    baseLock.Kill();
                }

                _pooledReskinEvent.Reset();
                _reskinEvents.Clear();
            }
        }

        #endregion

        #region Cooldown Manager

        private class CooldownManager
        {
            private readonly Dictionary<string, float> _cooldownMap = new();
            private readonly float _cooldownDuration;

            public CooldownManager(float duration)
            {
                _cooldownDuration = duration;
            }

            public void UpdateLastUsedForPlayer(string userID)
            {
                _cooldownMap[userID] = Time.realtimeSinceStartup;
            }

            public float GetSecondsRemaining(string userID)
            {
                return _cooldownMap.TryGetValue(userID, out var duration)
                    ? duration + _cooldownDuration - Time.realtimeSinceStartup
                    : 0;
            }
        }

        private CooldownManager GetCooldownManager(LockInfo lockInfo)
        {
            return lockInfo == LockInfo_CodeLock
                ? _craftCodeLockCooldowns
                : _craftKeyLockCooldowns;
        }

        #endregion

        #region Configuration

        private class AutoUnlockSettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Unlock after idle time (seconds)")]
            public float IdleSeconds = 3600;

            [JsonProperty("IdleSeconds")]
            private float DeprecatedIdleSeconds { set => IdleSeconds = value; }

            [JsonProperty