("Check interval seconds")]
            public float CheckIntervalSeconds = 300;

            [JsonProperty("CheckIntervalSeconds")]
            private float DeprecatedCheckIntervalSeconds { set => CheckIntervalSeconds = value; }

            [JsonProperty("Exempt owned vehicles")]
            public bool ExemptOwnedVehicles = true;

            [JsonProperty("ExemptOwnedVehicles")]
            private bool DeprecatedExemptOwnedVehicles { set => ExemptOwnedVehicles = value; }

            [JsonProperty("Exempt vehicles near cupboards")]
            public bool ExemptNearTC = true;

            [JsonProperty("ExemptNearTC")]
            private bool DeprecatedExemptNearTC { set => ExemptNearTC = value; }
        }

        private class ModularCarSettings
        {
            [JsonProperty("Allow editing while locked out")]
            public bool AllowEditingWhileLockedOut = true;

            [JsonProperty("AllowEditingWhileLockedOut")]
            private bool DeprecatedAllowEditingWhileLockedOut { set => AllowEditingWhileLockedOut = value; }
        }

        private class SharingSettings
        {
            [JsonProperty("Clan")]
            public bool Clan;

            [JsonProperty("Clan or ally")]
            public bool ClanOrAlly;

            [JsonProperty("ClanOrAlly")]
            private bool DeprecatedClanOrAlly { set => ClanOrAlly = value; }

            [JsonProperty("Friends")]
            public bool Friends;

            [JsonProperty("Team")]
            public bool Team;
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Update lock positions", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool UpdateLockPositions;

            [JsonProperty("Allow NPCs to bypass locks")]
            public bool AllowNPCsToBypassLocks;

            [JsonProperty("Allow deploying locks onto vehicles owned by other players")]
            public bool AllowIfDifferentOwner;

            [JsonProperty("AllowIfDifferentOwner")]
            private bool DeprecatedAllowIfDifferentOwner { set => AllowIfDifferentOwner = value; }

            [JsonProperty("Allow deploying locks onto unowned vehicles")]
            public bool AllowIfNoOwner = true;

            [JsonProperty("AllowIfNoOwner")]
            private bool DeprecatedAllowIfNoOwner { set => AllowIfNoOwner = value; }

            [JsonProperty("Require cupboard auth to deploy locks onto unowned vehicles")]
            public bool RequireTCIfNoOwner;

            [JsonProperty("RequireTCIfNoOwner")]
            private bool DeprecatedRequireTCIfNoOwner { set => RequireTCIfNoOwner = value; }

            [JsonProperty("Auto claim unowned vehicles when deploying locks")]
            public bool AutoClaimUnownedVehicles;

            [JsonProperty("Auto replace vehicle ownership when deploying locks")]
            public bool AutoReplaceVehicleOwnership;

            [JsonProperty("Allow pushing vehicles while locked out")]
            public bool AllowPushWhileLockedOut = true;

            [JsonProperty("AllowPushWhileLockedOut")]
            private bool DeprecatedAllowPushWhileLockedOut { set => AllowPushWhileLockedOut = value; }

            [JsonProperty("Cooldown to auto craft locks (seconds)")]
            public float CraftCooldownSeconds = 10;

            [JsonProperty("CraftCooldownSeconds")]
            private float DeprecatedCraftCooldownSeconds { set => CraftCooldownSeconds = value; }

            [JsonProperty("Modular car settings")]
            public ModularCarSettings ModularCarSettings = new();

            [JsonProperty("ModularCarSettings")]
            private ModularCarSettings DeprecatedModularCarSettings { set => ModularCarSettings = value; }

            [JsonProperty("Lock sharing settings")]
            public SharingSettings SharingSettings = new();

            [JsonProperty("DefaultSharingSettings")]
            private SharingSettings DeprecatedSharingSettings { set => SharingSettings = value; }

            [JsonProperty("Auto unlock idle vehicles")]
            public AutoUnlockSettings AutoUnlockSettings = new();

            [JsonProperty("AutoUnlockIdleVehicles")]
            private AutoUnlockSettings DeprecatedAutoUnlockSettings { set => AutoUnlockSettings = value; }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.UserIDString, messageName), args));

        private static class Lang
        {
            public const string GenericErrorNoPermission = "Generic.Error.NoPermission";
            public const string GenericErrorBuildingBlocked = "Generic.Error.BuildingBlocked";
            public const string GenericErrorCooldown = "Generic.Error.Cooldown";
            public const string GenericErrorVehicleLocked = "Generic.Error.VehicleLocked";
            public const string DeployErrorNoVehicleFound = "Deploy.Error.NoVehicleFound";
            public const string DeployErrorVehicleDead = "Deploy.Error.VehicleDead";
            public const string DeployErrorOther = "Deploy.Error.Other";
            public const string DeployErrorDifferentOwner = "Deploy.Error.DifferentOwner";
            public const string DeployErrorNoOwner = "Deploy.Error.NoOwner";
            public const string DeployErrorNoOwnerRequiresTC = "Deploy.Error.NoOwner.NoBuildingPrivilege";
            public const string DeployErrorHasLock = "Deploy.Error.HasLock";
            public const string DeployErrorInsufficientResources = "Deploy.Error.InsufficientResources";
            public const string DeployErrorMounted = "Deploy.Error.Mounted";
            public const string DeployErrorModularCarNoCockpit = "Deploy.Error.ModularCar.NoCockpit";
            public const string DeployErrorDistance = "Deploy.Error.Distance";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.GenericErrorNoPermission] = "You don't have permission to do that.",
                [Lang.GenericErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.GenericErrorCooldown] = "Please wait <color=red>{0}s</color> and try again.",
                [Lang.GenericErrorVehicleLocked] = "That vehicle is locked.",
                [Lang.DeployErrorNoVehicleFound] = "Error: No vehicle found.",
                [Lang.DeployErrorVehicleDead] = "Error: That vehicle is dead.",
                [Lang.DeployErrorOther] = "Error: You cannot do that.",
                [Lang.DeployErrorDifferentOwner] = "Error: Someone else owns that vehicle.",
                [Lang.DeployErrorNoOwner] = "Error: You do not own that vehicle.",
                [Lang.DeployErrorNoOwnerRequiresTC] = "Error: Locking unowned vehicles requires building privilege.",
                [Lang.DeployErrorHasLock] = "Error: That vehicle already has a lock.",
                [Lang.DeployErrorInsufficientResources] = "Error: Not enough resources to craft a {0}.",
                [Lang.DeployErrorMounted] = "Error: That vehicle is currently occupied.",
                [Lang.DeployErrorModularCarNoCockpit] = "Error: That car needs a cockpit module to receive a lock.",
                [Lang.DeployErrorDistance] = "Error: Too far away."
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.GenericErrorNoPermission] = "Você não tem permissão para fazer isso.",
                [Lang.GenericErrorBuildingBlocked] = "Erro: Não é possível fazer isso enquanto o edifício está bloqueado.",
                [Lang.GenericErrorCooldown] = "Aguarde <color=red>{0} seg</color> e tente novamente.",
                [Lang.GenericErrorVehicleLocked] = "Esse veículo está trancado.",
                [Lang.DeployErrorNoVehicleFound] = "Erro: Nenhum veículo encontrado.",
                [Lang.DeployErrorVehicleDead] = "Erro: esse veículo está destruido.",
                [Lang.DeployErrorOther] = "Erro: Você não pode fazer isso.",
                [Lang.DeployErrorDifferentOwner] = "Erro: outra pessoa é proprietária desse veículo.",
                [Lang.DeployErrorNoOwner] = "Erro: você não possui esse veículo.",
                [Lang.DeployErrorNoOwnerRequiresTC] = "Erro: o bloqueio de veículos sem proprietário requer privilégio de construção.",
                [Lang.DeployErrorHasLock] = "Erro: esse veículo já tem fechadura.",
                [Lang.DeployErrorInsufficientResources] = "Erro: recursos insuficientes para criar um {0}.",
                [Lang.DeployErrorMounted] = "Erro: esse veículo está ocupado no momento.",
                [Lang.DeployErrorModularCarNoCockpit] = "Erro: esse carro precisa de um módulo de cabine para receber um bloqueio.",
                [Lang.DeployErrorDistance] = "Erro: muito longe."
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: VehicleDeployedLocks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vending-in-stock ---
// --- Original File Path: V/VendingInStock/VendingInStock.cs ---

using Oxide.Core;
using System.Linq;
using System;

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Vending In Stock", "AVOcoder / rostov114", "1.1.0")]
    [Description("VendingMachines sell-orders always in stock")]
    class VendingInStock : RustPlugin
    {
        #region Configuration
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Disable native refill")]
            public bool disableNativeRefill = false;

            [JsonProperty(PropertyName = "Do not refill items")]
            public string[] noRefillItems =
            { 
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Do not refill vendings")]
            public string[] noRefillVendings =
            {
                "put vending orders name here (see console command >>> vending_orders_name <<<)"
            };

            public bool NoRefillItem(Item item)
            {
                if (noRefillItems == null)
                    return false;

                return noRefillItems.Contains(item.info.shortname);
            }

            public bool NoRefillVending(NPCVendingMachine vm)
            {
                if (noRefillVendings == null || vm.vendingOrders == null || vm.vendingOrders.name == null)
                    return false;

                return noRefillVendings.Contains(vm.vendingOrders.name);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnServerInitialized));
                Unsubscribe(nameof(Unload));
                Unsubscribe(nameof(CanPurchaseItem));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            if (!_config.disableNativeRefill)
                return;

            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                timer.Once(1f, () =>
                {
                    if (vm == null || vm.IsDestroyed || _config.NoRefillVending(vm)) 
                        return;

                    foreach (Item item in vm.inventory.itemList)
                    {
                        if (_config.NoRefillItem(item))
                            PrintWarning($"Native refill disabled and enabled not refill item! Please disable 'Disable native refill' OR add vending in 'Do not refill vendings'! Vending name: {vm.shopName}, Item: {item.info.shortname}");
                    }

                    vm.CancelInvoke(new Action(vm.Refill));
                });
            }
        }

        private void Unload()
        {
            if (!_config.disableNativeRefill)
                return;

            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                if (_config.NoRefillVending(vm)) 
                    continue;

                vm.InvokeRandomized(new Action(vm.Refill), 1f, 1f, 0.1f);
            }
        }

        private void CanPurchaseItem(BasePlayer buyer, Item soldItem, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vm)
        {
            if (vm == null || soldItem == null || soldItem.info == null)
                return;

            if (_config.NoRefillVending(vm))
                return; 

            if (_config.NoRefillItem(soldItem))
            {
                if (_config.disableNativeRefill)
                    PrintWarning($"Native refill disabled and enabled not refill item! Please disable 'Disable native refill' OR add vending in 'Do not refill vendings'! Vending name: {vm.shopName}, Item: {soldItem.info.shortname}");

                return;
            }

            if (Interface.CallHook("CanVendingStockRefill", vm, soldItem, buyer) != null)
                return;

            Item item = ItemManager.Create(soldItem.info, soldItem.amount, soldItem.skin);
            if (soldItem.blueprintTarget != 0)
                item.blueprintTarget = soldItem.blueprintTarget;

            if (soldItem.instanceData != null)
                item.instanceData.dataInt = soldItem.instanceData.dataInt;

            NextTick(() =>
            {
                if (item == null)
                    return;

                if (vm == null || vm.IsDestroyed) {
                    item.Remove(0f);
                    return;
                }

                vm.transactionActive = true;
                if (!item.MoveToContainer(vm.inventory, -1, true))
                    item.Remove(0f);

                vm.transactionActive = false;
                vm.FullUpdate();
            });
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("vending_orders_name")]
        private void vending_orders_name(ConsoleSystem.Arg arg)
        {
            BasePlayer p = arg?.Player() ?? null; 
            if (p != null && !p.IsAdmin) 
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Vending name");
            textTable.AddColumn("Vending orders name (use plugin config)");

            List<string> _cache = Pool.GetList<string>();
            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                if (vm == null || vm.vendingOrders == null || vm.vendingOrders.name == null || _cache.Contains(vm.vendingOrders.name))
                    continue;

                _cache.Add(vm.vendingOrders.name);
                textTable.AddRow(new string[]
                {
                    vm.shopName,
                    vm.vendingOrders.name
                });
            }

            Pool.FreeList<string>(ref _cache);
            arg.ReplyWith(textTable.ToString());
        }
        #endregion
    }
}

// --- End of file: VendingInStock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vendor-rotate-protection ---
// --- Original File Path: V/VendorRotateProtection/VendorRotateProtection.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Vendor Rotate Protection", "nuchacho/Arainrr", "1.1.3")]
    [Description("Prevents anyone except the entity owner from rotating vending machine.")]
    public class VendorRotateProtection : RustPlugin
    {
        [PluginReference] private readonly Plugin Friends, Clans;

        private object OnRotateVendingMachine(VendingMachine machine, BasePlayer player)
        {
            if (machine == null || player == null || machine.OwnerID == 0) return null;
            if (AreFriends(machine.OwnerID, player.userID)) return null;
            Print(player, Lang("CantRotateVendor", player.UserIDString));
            return false;
        }

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (playerID == friendID) return true;
            if (configData.useTeam && SameTeam(playerID, friendID)) return true;
            if (configData.useFriends && HasFriend(playerID, friendID)) return true;
            if (configData.useClans && SameClan(playerID, friendID)) return true;
            return false;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix = "[VendorRotateProtection]:";

            [JsonProperty(PropertyName = "Chat Prefix Color")]
            public string prefixColor = "#00FFFF";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon = 0;

            [JsonProperty(PropertyName = "Use Team")]
            public bool useTeam = false;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool useFriends = false;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool useClans = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region LanguageFile

        protected override void LoadDefaultMessages()
        {
            //English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "You can only rotate vending machines that you placed."
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "Vous pouvez uniquement faire pivoter les distributeurs automatiques que vous avez placés."
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "Sie können nur Verkaufsautomaten drehen, die Sie platziert haben."
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "Вы можете вращать только торговые автоматы, которые вы разместили."
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "Solo puede girar las máquinas expendedoras que haya colocado."
            }, this, "es");

            // Chinese
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRotateVendor"] = "您不能旋转这个售货机。"
            }, this, "zh-CN");
        }

        private void Print(BasePlayer player, string message) => Player.Message(player, message, $"<color={configData.prefixColor}>{configData.prefix}</color>", configData.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion LanguageFile
    }
}

// --- End of file: VendorRotateProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/voter-rewards ---
// --- Original File Path: V/Voter/Voter.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("VoteRewards", "k1lly0u", "2.1.1", ResourceId = 752)]
    class Voter : RustPlugin
    {
        #region Fields 
        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin Economics;

        StoredData storedData;
        private DynamicConfigFile data;

        private Dictionary<string, ItemDefinition> itemDefs = new Dictionary<string, ItemDefinition>();

        private Timer broadcastTimer;
        private TrackerType trackerType;

        const string rsTracker = "http://rust-servers.net/api/?action=custom&object=plugin&element=reward&key={KEY}&steamid=";
        const string trsTracker = "http://api.toprustservers.com/api/get?plugin=voter&key={KEY}&uid=";
        const string bcTracker = "http://beancan.io/vote/get/{KEY}/";

        string trackerName;

        private string col1;
        private string col2;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("voter_data");
        }
        void OnServerInitialized()
        {
            itemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
            LoadVariables();
            LoadData();
            col1 = $"<color={configData.Messaging.MainColor}>";
            col2 = $"<color={configData.Messaging.MSGColor}>";

            if (string.IsNullOrEmpty(configData.Tracker.APIKey))
            {
                PrintError("Please enter your API key in the config!");
                Interface.Oxide.UnloadPlugin("Voter");
                return;
            }

            if (ParseTrackerType())
            {
                cmd.AddChatCommand(configData.Commands.VoteCommand, this, cmdVote);
                cmd.AddChatCommand(configData.Commands.RewardCommand, this, cmdRewards);

                if (configData.Messaging.Enabled)
                    BroadcastLoop();
            }
        }
        void Unload()
        {
            if (broadcastTimer != null)
                broadcastTimer.Destroy();
        }
        #endregion

        #region Functions
        private bool ParseTrackerType()
        {
            try
            {
                trackerType = (TrackerType)Enum.Parse(typeof(TrackerType), configData.Tracker.TrackerType, true);
                trackerName = trackerType == TrackerType.RustServers ? "Rust-Servers" : trackerType == TrackerType.Beancan ? "BeancanIO" : "TopRustServers";
                return true;
            }
            catch
            {
                PrintError("Invalid tracker type set in the config. Either use \"TopRustServers\", \"RustServers\" or \"Beancan\"");
                Interface.Oxide.UnloadPlugin(Title);
                return false;
            }

        }
        private void BroadcastLoop()
        {
            PrintToChat(string.Format(msg("broadcastMessage1").Replace("{TYPE}", trackerName), configData.Commands.VoteCommand));
            broadcastTimer = timer.Once(configData.Messaging.Timer * 60, () => BroadcastLoop());
        }
        private void CheckForVotes(BasePlayer player) => GetWebRequest(player);
        

        private void GetWebRequest(BasePlayer player)
        {
            string tracker = trackerType == TrackerType.RustServers ? rsTracker : trackerType == TrackerType.Beancan ? bcTracker : trsTracker;
            Puts(tracker.Replace("{KEY}", configData.Tracker.APIKey) + player.UserIDString);
            webrequest.EnqueueGet(tracker.Replace("{KEY}", configData.Tracker.APIKey) + player.UserIDString, (code, response) =>
            {
                if (response == null || code != 200)
                {
                    PrintWarning($"Error: {code} - Couldn't get an answer from {trackerName} for {player.displayName}");
                    SendReply(player, $"{col1}{msg("contactError1", player.UserIDString).Replace("{TYPE}", trackerName)}</color>");
                }
                else
                {
                    Puts(response);
                    int responeNum;
                    if (!int.TryParse(response, out responeNum))
                    {
                        PrintError($"There was a error processing what was returned from {trackerName}");
                        SendReply(player, $"{col1}{msg("voteError", player.UserIDString)}</color>");
                    }
                    else if (responeNum == 0 || responeNum == 2)
                    {
                        SendReply(player, $"{col1}{msg("noVotes", player.UserIDString)}</color>");
                    }
                    else if (responeNum == 1)
                    {
                        if (configData.Rewards.Count == 1)                        
                            GiveReward(player, configData.Rewards.First().Value);                        
                        else
                        {
                            storedData.userData[player.userID] += configData.Tracker.PointsPerVote;
                            SaveData();
                            SendReply(player, $"{col2}{string.Format(msg("voteSuccess", player.UserIDString), $"</color>{col1}{storedData.userData[player.userID]}</color>{col2}", $"</color>{col1}/{configData.Commands.RewardCommand}</color>{col2}")}</color>");
                        }
                    }                   
                }
            }, this);
        }
        #endregion
       
        #region Rewards
        private bool GiveReward(BasePlayer player, Rewards reward)
        {
            if (reward.RPAmount > 0)
            {
                if (!ServerRewards)
                {
                    SendReply(player, $"{col1}{msg("noSR", player.UserIDString)}</color>");
                    return false;
                }
                GiveRP(player, reward.RPAmount);
            }
            if (reward.EcoAmount > 0)
            {
                if (!Economics)
                {
                    SendReply(player, $"{col1}{msg("noEco", player.UserIDString)}</color>");
                    return false;
                }
                GiveCoins(player, reward.EcoAmount);
            }            
            foreach(var rewardItem in reward.RewardItems)
            {                
                if (itemDefs.ContainsKey(rewardItem.Shortname))
                {
                    player.GiveItem(ItemManager.CreateByItemID(itemDefs[rewardItem.Shortname].itemid, rewardItem.Amount, rewardItem.SkinID), BaseEntity.GiveItemReason.PickedUp);
                }
                else
                {
                    SendReply(player, $"{col1}{msg("noItem", player.UserIDString)}</color>");
                    PrintError($"The reward {rewardItem.Shortname} does not exist. Check for the correct item shortname");
                    return false;
                }
            }
            SendReply(player, $"{col1}{msg("rewardSuccess", player.UserIDString)}</color>");
            return true;
        }
        private void GiveRP(BasePlayer player, int amount) => ServerRewards?.Call("AddPoints", player.UserIDString, amount);
        private void GiveCoins(BasePlayer player, int amount) => Economics?.Call("Deposit", player.UserIDString, (double) amount);
        #endregion

        #region Chat Commands
        
        private void cmdVote(BasePlayer player, string command, string[] args)
        {
            if (!storedData.userData.ContainsKey(player.userID))
                storedData.userData.Add(player.userID, 0);            

            CheckForVotes(player);
        }
        
        private void cmdRewards(BasePlayer player, string command, string[] args)
        {
            if (!storedData.userData.ContainsKey(player.userID))
                storedData.userData.Add(player.userID, 0);
            if (args == null || args.Length == 0)
            {
                SendReply(player, $"{col1}Voter</color>  {col2}v </color>{col1}{Version}</color>");
                SendReply(player, $"{col2}{string.Format(msg("hasPoints", player.UserIDString), $"</color>{col1}{storedData.userData[player.userID]}</color>{col2}")}</color>");
                SendReply(player, $"{col2}{string.Format(msg("rewardHelp", player.UserIDString), $"</color>{col1}/{configData.Commands.RewardCommand}")}</color>");
                SendReply(player, $"{col2}{msg("available", player.UserIDString)}</color>");
                foreach (var reward in configData.Rewards)
                {
                    string rewardString = $"{col1}{msg("id", player.UserIDString)}</color> {col2}{reward.Key}</color>\n{col1}{msg("cost", player.UserIDString)}</color> {col2}{reward.Value.CostToBuy}</color>";
                    if (Economics && reward.Value.EcoAmount > 0)
                        rewardString += $"\n{col1}{msg("economics", player.UserIDString)}</color> {col2}{reward.Value.EcoAmount}</color>";
                    if (ServerRewards && reward.Value.RPAmount > 0)
                        rewardString += $"\n{col1}{msg("serverrewards", player.UserIDString)}</color> {col2}{reward.Value.RPAmount}</color>";

                    string rewardItems = string.Empty;
                    if (reward.Value.RewardItems.Count > 0)
                    {
                        rewardItems += $"\n{col1}{msg("rewardItems", player.UserIDString)}</color> {col2}";
                        for (int i = 0; i < reward.Value.RewardItems.Count; i++)
                        {
                            var item = reward.Value.RewardItems[i];
                            rewardItems += $"{item.Amount}x {itemDefs[item.Shortname].displayName.english}";
                            if (i < reward.Value.RewardItems.Count - 1)
                                rewardItems += ", ";
                            else rewardItems += "</color>";
                        } 
                    }
                    rewardString += rewardItems;
                    SendReply(player, rewardString);
                }
            }
            if (args.Length == 1)
            {
                int key;
                if (!int.TryParse(args[0], out key))
                {
                    SendReply(player, $"{col2}{msg("noId", player.UserIDString)}</color>");
                    return;
                }
                if (!configData.Rewards.ContainsKey(key))
                {
                    SendReply(player, $"{col2}{msg("notExist", player.UserIDString)} {key}</color>");
                    return;
                }
                var reward = configData.Rewards[key];
                if (storedData.userData[player.userID] < reward.CostToBuy)
                {
                    SendReply(player, $"{col2}{msg("noPoints", player.UserIDString)}</color>");
                    return;
                }
                else
                {
                    if (GiveReward(player, reward))
                    {
                        storedData.userData[player.userID] -= reward.CostToBuy;
                        SaveData();
                    }
                }
            }

        }
        #endregion

        #region HelpText
        private void SendHelpText(BasePlayer player)
        {
            SendReply(player, string.Format(msg("helptext1", player.UserIDString), configData.Commands.VoteCommand).Replace("{TYPE}", trackerName));
            SendReply(player, string.Format(msg("helptext2", player.UserIDString), configData.Commands.RewardCommand));
        }
        #endregion

        #region Config  
        enum TrackerType { TopRustServers, RustServers, Beancan } 
        class Tracker
        {
            [JsonProperty(PropertyName = "Tracker type (TopRustServers, RustServers, Beancan)")]
            public string TrackerType { get; set; }
            [JsonProperty(PropertyName = "API Key")]
            public string APIKey { get; set; }
            [JsonProperty(PropertyName = "Points received per vote")]
            public int PointsPerVote { get; set; }
        }  
        class Commands
        {
            [JsonProperty(PropertyName = "Chat Command - Reward Menu")]
            public string RewardCommand { get; set; }
            [JsonProperty(PropertyName = "Chat Command - Vote Checking")]
            public string VoteCommand { get; set; }
        } 
        class Rewards
        {
            [JsonProperty(PropertyName = "Reward Items")]
            public List<RewardItem> RewardItems { get; set; }
            [JsonProperty(PropertyName = "Reward RP (Server Rewards)")]
            public int RPAmount { get; set; }
            [JsonProperty(PropertyName = "Reward Money (Economics)")]
            public int EcoAmount { get; set; }
            [JsonProperty(PropertyName = "Reward Cost")]
            public int CostToBuy { get; set; }

            public class RewardItem
            {
                [JsonProperty(PropertyName = "Item Shortname")]
                public string Shortname { get; set; }
                [JsonProperty(PropertyName = "Item Skin ID")]
                public ulong SkinID { get; set; }
                [JsonProperty(PropertyName = "Item Amount")]
                public int Amount { get; set; }
            }
        }
        
        class Messaging
        {
            [JsonProperty(PropertyName = "Message color (Primary)")]
            public string MainColor { get; set; }
            [JsonProperty(PropertyName = "Message color (Secondary)")]
            public string MSGColor { get; set; }
            [JsonProperty(PropertyName = "Activate automated broadcasting")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Automated broadcast timer (minutes)")]
            public int Timer { get; set; }
        }
        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Chat Commands")]
            public Commands Commands { get; set; } 
            [JsonProperty(PropertyName = "Messaging Options")]
            public Messaging Messaging { get; set; }
            [JsonProperty(PropertyName = "Reward List")]
            public Dictionary<int, Rewards> Rewards { get; set; }            
            [JsonProperty(PropertyName = "Tracker Information")]
            public Tracker Tracker { get; set; }
            
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {                
                Rewards = new Dictionary<int, Rewards>
                {
                    {0, new Rewards
                    {
                        CostToBuy = 1,
                        RPAmount = 0,
                        EcoAmount = 0,                      
                        RewardItems = new List<Rewards.RewardItem>
                        {
                            new Rewards.RewardItem
                            {
                                Amount = 1,
                                Shortname = "supply.signal",
                                SkinID = 0
                            }
                        }                       
                    } },
                    {1, new Rewards
                    {
                        CostToBuy = 2,
                        RPAmount = 0,
                        EcoAmount = 0,                       
                        RewardItems = new List<Rewards.RewardItem>
                        {
                            new Rewards.RewardItem
                            {
                                Amount = 100,
                                Shortname = "hq.metal.ore",
                                SkinID = 0
                            },
                            new Rewards.RewardItem
                            {
                                Amount = 150,
                                Shortname = "sulfur.ore",
                                SkinID = 0
                            }
                        }
                    } },
                    {2, new Rewards
                    {
                        CostToBuy = 3,
                        RPAmount = 200,
                        EcoAmount = 0,                      
                        RewardItems = new List<Rewards.RewardItem>()
                    } }
                },
                Commands = new Commands
                {
                    RewardCommand = "reward",
                    VoteCommand = "vote"
                },                
                Messaging = new Messaging
                {
                    MainColor = "#ce422b",
                    MSGColor = "#939393",
                    Enabled = true,
                    Timer = 30
                },
                Tracker = new Tracker
                {
                    APIKey = "",
                    PointsPerVote = 1,
                    TrackerType = "RustServers"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveData() => data.WriteObject(storedData);
        void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }
        class StoredData
        {
            public Dictionary<ulong, int> userData = new Dictionary<ulong, int>();
        }       
        #endregion

        #region Localization
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"contactError1", "There was a error contacting {TYPE}. Please try again later"},
            {"voteError", "There was a error collecting your votes. Please try again later" },
            {"noVotes", "Thank you for voting for us but you have not cast anymore votes since the last time you checked"},
            {"voteSuccess", "Thank you for voting for us! You now have {0} vote points available. You can spend these points by typing {1}"},
            {"noSR", "ServerRewards is not installed. Unable to issue points"},
            {"noEco", "Economics is not installed. Unable to issue coins"},
            {"noItem", "Unable to find the requested reward" },
            {"rewardSuccess", "Thank you for voting for us! Enjoy your reward." },
            {"hasPoints", "You currently have {0} vote points to spend"},
            {"rewardHelp", "You can claim any reward package you have enough vote points to buy by typing {0} <ID>" },
            {"available", "Available Rewards:" },
            {"economics", "Coins (Economics):"},
            {"serverrewards", "RP (ServerRewards):"},
            {"rewardItems", "Items:" },
            {"id", "ID:" },
            {"cost", "Cost:" },
            {"noId", "You need to enter a reward ID"},
            {"notExist", "There is no reward with the ID:" },
            {"noPoints", "You do not have enough vote points to purchase that reward"},
            {"broadcastMessage1", "<color=#939393>Vote for us on </color><color=#ce422b>{TYPE}</color><color=#939393> and receive rewards! Type </color><color=#ce422b>/{0}</color><color=#939393> after voting</color>"},
            {"helptext1", "<color=#ce422b>/{0}</color><color=#939393> - Checks {TYPE} to see if you have voted for this server</color>" },
            {"helptext2", "<color=#ce422b>/{0}</color><color=#939393> - Display's available rewards and how many votepoints you have</color>" }
        };
        #endregion
    }
}

// --- End of file: Voter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vending-machine-timeout ---
// --- Original File Path: V/VendingMachineTimeout/VendingMachineTimeout.cs ---

﻿using System;
using System.Collections.Generic;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Vending Machine Timeout", "0x89A", "1.0.15")]
    [Description("Prevents players from hogging vending machines at outpost")]
    class VendingMachineTimeout : RustPlugin
    {
        private Dictionary<ulong, Timer> timeoutTimers = new Dictionary<ulong, Timer>();

        private const string bypass = "vendingmachinetimeout.bypass";

        private void Init() => permission.RegisterPermission(bypass, this);
        
        void OnOpenVendingShop(NPCVendingMachine machine, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, bypass))
            {
                if (!timeoutTimers.ContainsKey(player.userID)) timeoutTimers.Add(player.userID, null);

                timeoutTimers[player.userID] = timer.Once(config.timeoutSeconds, () => { if (player != null) player.EndLooting(); });
            }
        }

        void OnLootEntityEnd(BasePlayer player, NPCVendingMachine entity)
        {
            Timer timer;
            if (!timeoutTimers.ContainsKey(player.userID) || !timeoutTimers.TryGetValue(player.userID, out timer) || timer == null) return;

            timer.Destroy();
        }

        #region -Configuration-

        private Configuration config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Timeout time (seconds)")]
            public float timeoutSeconds = 30f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Error loading config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}


// --- End of file: VendingMachineTimeout.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-locks ---
// --- Original File Path: V/VehicleLocks/VehicleLocks.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Vehicle Locks", "MrPoundsign", "1.0.4")]
    [Description("Vehicle ownership and locking")]
    class VehicleLocks : RustPlugin
    {
        const string chinookPilotSeat = "assets/prefabs/vehicle/seats/pilotseat.prefab";
        const string sedanDriverSeat = "assets/prefabs/vehicle/seats/driverseat.prefab";
        const string smallBoatDriverSeat = "assets/prefabs/vehicle/seats/smallboatdriver.prefab";
        const string miniHeliSeat = "assets/prefabs/vehicle/seats/miniheliseat.prefab";
        const string rhibDriverSeat = "assets/prefabs/vehicle/seats/standingdriver.prefab";
        const string saddlePrefab = "assets/prefabs/vehicle/seats/saddletest.prefab";
        const string scrapTransportSeat = "assets/prefabs/vehicle/seats/transporthelipilot.prefab";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["vehicle.locked"] = "You don't have the keys for this vehicle",
                ["vehicle.owned"] = "You now own this vehicle",
            }, this);
        }

        object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            if (player.IsNpc) return null;

            // Only restrict to driver's seats
            if (entity.name != chinookPilotSeat &&
                entity.name != sedanDriverSeat &&
                entity.name != smallBoatDriverSeat &&
                entity.name != miniHeliSeat &&
                entity.name != rhibDriverSeat &&
                entity.name != saddlePrefab &&
                entity.name != scrapTransportSeat) return null;

            var vehicle = entity.VehicleParent();

            // If the player already owns the vehicle
            if (vehicle == null || vehicle.OwnerID == player.userID) return null;

            // If the player is in a safe zone, they can always take any vehicle
            // Additionaly, if it's unowned, it can be taken. This sets ownership
            // to the player taking the vehicle.
            if (vehicle.OwnerID == 0 || (!player.InSafeZone() && player.CanBuild()))
            {
                player.ChatMessage(lang.GetMessage("vehicle.owned", this, player.UserIDString));
                vehicle.OwnerID = player.userID;
                return null;
            }

            // Players who are standing in a place they are authorized to build,
            // with or without TC coverage, they can take a vehicle.
            var bp = player.GetBuildingPrivilege();
            if (bp != null)
            {
                // At this point we need to determine if the owner is authorized to the
                // tool cupboard providing the build privileges. This is so if someone
                // parks their vehicle at an enemy base, anyone can take it.
                foreach (ProtoBuf.PlayerNameID playerNameID in bp.authorizedPlayers)
                {
                    if (playerNameID.userid == vehicle.OwnerID)
                    {
                        player.ChatMessage(lang.GetMessage("vehicle.locked", this, player.UserIDString));
                        return true;
                    }
                }
            }

            // All other checks have failed, the vehicle is theirs to take.
            player.ChatMessage(lang.GetMessage("vehicle.owned", this, player.UserIDString));
            vehicle.OwnerID = player.userID;
            return null;
        }
    }
}


// --- End of file: VehicleLocks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-bbqs ---
// --- Original File Path: V/VehicleBBQ/VehicleBBQ.cs ---

using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Vehicle BBQ's", "Judess69er/Shady14u", "1.3.6")]
	[Description("Puts Barbeque's on specific Vehicles")]
	public class VehicleBBQ : RustPlugin
	{
		#region Fields
		public const string BBQ_PREFAB = "assets/bundled/prefabs/static/bbq.static.prefab";
		public PluginConfig _config;
		#endregion Fields
		#region Initialization
		void OnServerInitialized(bool initialBoot)
		{
			LoadConfig();
			foreach (var vehicle in UnityEngine.Object.FindObjectsOfType<BaseVehicle>())
			{
				AddOven(vehicle);
			}
		}
        #endregion
		#region Config
		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}
		public PluginConfig GetDefaultConfig()
		{
			return new PluginConfig
			{
				EnableRHIB = false,
				EnableWorkcart = false,
				EnableScrapHeli = false
			};
		}
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<PluginConfig>() ?? GetDefaultConfig();
				SaveConfig();
			}
			catch
			{
				PrintWarning("Creating new config file.");
				LoadDefaultConfig();
			}
		} 
		protected override void SaveConfig() => Config.WriteObject(_config);
		public class PluginConfig
		{
			[JsonProperty(PropertyName = "Add BBQ to Rigid Hull Inflatable Boat ( True/False )")]
			public bool EnableRHIB { get; set; }
			
			[JsonProperty(PropertyName = "Add BBQ to Workcart ( True/False )")]
			public bool EnableWorkcart { get; set; }
			
			[JsonProperty(PropertyName = "Add BBQ to Scrap Transport Helicopter ( True/False )")]
			public bool EnableScrapHeli { get; set; }
		}
		#endregion Config
		#region Oxide Hooks
		private static void RemoveColliderProtection(BaseEntity colliderEntity)
		{
			foreach (var meshCollider in colliderEntity.GetComponentsInChildren<MeshCollider>())
			{
			UnityEngine.Object.DestroyImmediate(meshCollider);
			}
			UnityEngine.Object.DestroyImmediate(colliderEntity.GetComponent<GroundWatch>());
		}
		void OnEntitySpawned(BaseVehicle entity)
		{
			if (entity == null) return;
			NextTick(() =>
			{
				AddOven(entity);
			});
		}
		#endregion Oxide Hooks
		#region Component
		void AddOven(BaseVehicle entity)
		{
			if (entity == null || entity.GetComponentsInChildren<BaseOven>(true).Any(child => child.name == BBQ_PREFAB))
			{
				return;
			}
			// Spawn BBQ on Rigid Hull Inflatable Boat
			if (entity.ShortPrefabName.Contains("rhib") && _config.EnableRHIB)
			{
				SpawnOven(entity, new Vector3(0.0f, 0.95f, 3.5f), new Vector3(0.0f, 90.0f, 0.0f));
				return;
			}
			// Spawn BBQ on Workcart
			if (entity.ShortPrefabName.Contains("workcart") &&  _config.EnableWorkcart)
			{
				SpawnOven(entity, new Vector3(0.85f, 1.4f, -0.6f), new Vector3(0.0f, 90.0f, 0.0f));
				return;
			}
			// Spawn BBQ on Scrap Transport Helicopter
			if (entity.ShortPrefabName.Contains("scraptransporthelicopter") && _config.EnableScrapHeli)
			{
				SpawnOven(entity, new Vector3(-0.85f, 0.6f, -2.6f), new Vector3(0.0f, 0.0f, 0.0f));
				return;
			}
		}
		private void SpawnOven(BaseVehicle entity, Vector3 localPosition, Vector3 rotate)
		{
			var oven = GameManager.server?.CreateEntity(BBQ_PREFAB, entity.transform.position) as BaseOven;
			if (oven == null) return;
			RemoveColliderProtection(oven);
			oven.Spawn();
			oven.SetParent(entity);
			oven.pickup.enabled = false;
			oven.dropsLoot = true;
			oven.transform.localPosition = localPosition;
			oven.transform.Rotate(rotate);
			oven.SendNetworkUpdateImmediate(true);
		}
		// drop items when entity is killed (don't want salty tears)
		private void OnEntityKill(BaseVehicle entity)
		{
			if (entity == null) return;
			foreach (var child in entity.GetComponentsInChildren<BaseOven>(true))
			{
				if (child.name != BBQ_PREFAB) continue;
				child.DropItems();
				child.Kill();
			}
		}
		#endregion Component
		#region Console Command
		[ConsoleCommand("killbbqs")]
		private void cmdKillBBQs(ConsoleSystem.Arg arg)
		{
			foreach (var vehicle in UnityEngine.Object.FindObjectsOfType<BaseVehicle>())
			{
				foreach (var child in vehicle.GetComponentsInChildren<BaseOven>(true).Where(x=>x.name==BBQ_PREFAB))
				{
					child.DropItems();
					child.Kill();
				}
			}
		}
		#endregion Console Command
	}
}

// --- End of file: VehicleBBQ.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vending-machine-logs ---
// --- Original File Path: V/VendingMachineLogs/VendingMachineLogs.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Vending Machine Logs", "Ryz0r", "1.0.5"), Description("Logs vending machine transactions to Discord.")]
    public class VendingMachineLogs : RustPlugin
    {
        private const string BypassPerm = "vendingmachinelogs.bypass";
        #region Configuration
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string WebhookURL = "https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty(PropertyName = "Ignore Non-Player Vending Machines")]
            public bool IgnoreNonPlayer = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("A new configuration file is being generated.");
            _config = new Configuration();
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(BypassPerm, this);
        }

        private void OnVendingTransaction(VendingMachine machine, BasePlayer player, int sellOrderId, int numberOfTransactions)
        {
            if (permission.UserHasPermission(player.UserIDString, BypassPerm)) return;
            if (_config.IgnoreNonPlayer && machine.OwnerID == 0) return;
           
            var sellOrder = machine.sellOrders.sellOrders[sellOrderId];
           
            var currency = sellOrder.currencyID;
            var currencyAmount = sellOrder.currencyAmountPerItem * numberOfTransactions;
            var currencyName = ItemManager.FindItemDefinition(currency).displayName.english;
                       
            var item = sellOrder.itemToSellID;
            var itemAmount = sellOrder.itemToSellAmount * numberOfTransactions;
            var itemName = ItemManager.FindItemDefinition(item).displayName.english;
                       
            SendDiscordMessage(player.displayName, player.UserIDString, itemName, item, currencyName, currency, machine.shopName, itemAmount, currencyAmount, machine.OwnerID.ToString());

        }

        #endregion
        #region Functions
        private void SendDiscordMessage(string customerName, string customerID, string soldItem, int soldItemID, string currencyItem, int currencyItemID, string shopName, int soldQuantity, int currencyQuantity, string machineOwner)
        {
            var embed = new Embed()
                .AddField("Customer:", customerName + " (" + customerID + ")", true)
                .AddField("Shop Name:", shopName, true)
                .AddField("Shop Owner ID:", machineOwner, true)
                
                .AddField("Sold Item:", soldItem, true)
                .AddField("Sold Item ID:", soldItemID.ToString(), true)
                .AddField("Amount Sold:", soldQuantity.ToString(), true)
                
                .AddField("Currency Item:", currencyItem, true)
                .AddField("Currency Item ID:", currencyItemID.ToString(), true)
                .AddField("Amount Spent:", currencyQuantity.ToString(), true)
                .SetColor("#00FFFF");
            
            var headers = new Dictionary<string, string>() {{"Content-Type", "application/json"}};
            const float timeout = 500f;
            
            webrequest.Enqueue(_config.WebhookURL, new DiscordMessage("", embed).ToJson(),  GetCallback, this,
                RequestMethod.POST, headers, timeout);
        }
        
        private void GetCallback(int code, string response)
        {
            if (response != null && code == 204) return;
            
            Puts($"Error: {code} - Couldn't get an answer from server.");
        }
        #endregion
        #region Discord Stuff
        private class DiscordMessage
        {
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = content;
                Embeds  = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }
            

            public string ToJson() => JsonConvert.SerializeObject(this);
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();
            [JsonProperty("color")] public int Color { get; set; }

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
            
            public Embed SetColor(string color)
            {
                var replace = color.Replace("#", "");
                var decValue = int.Parse(replace, System.Globalization.NumberStyles.HexNumber);
                Color = decValue;
                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion
    }
}

// --- End of file: VendingMachineLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vip-no-decay ---
// --- Original File Path: V/VIPNoDecay/VIPNoDecay.cs ---

﻿using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("VIPNoDecay", "ColonBlow", "1.0.4")]
    [Description("Disables Decay Damage for player or oxide group with VIP permissions")]

    class VIPNoDecay : CovalencePlugin
    {
        const string permVIP = "vipnodecay.vip";

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permVIP, this);
        }

        bool HasPermission(ulong playerID, string perm) => permission.UserHasPermission(playerID.ToString(), perm);

        private object OnEntityTakeDamage(DecayEntity decayEntity, HitInfo hitInfo)
        {
            if (hitInfo == null || !hitInfo.damageTypes.GetMajorityDamageType().ToString().Contains("Decay")) return null;
            var ownerid = decayEntity.OwnerID;
            if (ownerid != null && HasPermission(ownerid, "vipnodecay.vip"))
            {
                decayEntity.DecayTouch();
                return true;
            }
            return null;
        }
    }
}

// --- End of file: VIPNoDecay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vote-kick ---
// --- Original File Path: V/VoteKick/VoteKick.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    // TODO LIST
    // Nothing, yet.

    [Info("VoteKick", "Kappasaurus", "1.0.2")]

    class VoteKick : CovalencePlugin
    {
        #region Variables

        private List<string> voted = new List<string>();
        private bool activeVote;
        private int votes = 0;
        private IPlayer target;
        private Timer voteTimer;

        // CONFIG RELATED
        private float percentageRequired = 0.6f;
        private int playersRequired = 10;

        #endregion

        #region Hooks

        void Init()
        {
            permission.RegisterPermission("votekick.able", this);
            LoadConfig();
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (target != null && activeVote && player.Id == target.Id)
            {
                server.Broadcast(lang.GetMessage("Target Disconnected", this));
                activeVote = false;
                voteTimer?.Destroy();
                voted.Clear();
                target = null;
            }
        }

        #endregion

        #region Command

        [Command("votekick")]
        void VoteKickCmd(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("votekick.able"))
            {
                player.Message(lang.GetMessage("No Permission", this, player.Id));
                return;
            }

            if (players.Connected.Count() < playersRequired)
            {
                player.Message(lang.GetMessage("Not Enough Players", this, player.Id));
                return;
            }

            if (activeVote)
            {
                player.Message(lang.GetMessage("Other Vote Open", this, player.Id));
                return;
            }

            if (args.Length == 0)
            {
                player.Message(lang.GetMessage("No Target", this, player.Id));
                return;
            }

            target = covalence.Players.FindPlayer(args[0]);

            if (target == null || !target.IsConnected)
            {
                player.Message(lang.GetMessage("Target Not Found", this, player.Id));
                return;
            }

            if (player.Equals(target))
            {
                player.Message(lang.GetMessage("Vote Self", this, player.Id));
                return;
            }

            if (target.IsAdmin)
            {
                player.Message(lang.GetMessage("No Permission", this, player.Id));
                return;
            }

            activeVote = true;
            server.Broadcast(lang.GetMessage("Kick Started", this).Replace("{player}", player.Name).Replace("{target}", target.Name));

            voteTimer = timer.Once(600f, () =>
            {
                if (!activeVote)
                    return;

                activeVote = false;
                target = null;
                server.Broadcast(lang.GetMessage("Timed Out", this));
                voted.Clear();
            });
        }

        [Command("vote")]
        void VoteCmd(IPlayer player, string command, string[] args)
        {
            var requiredVotes = players.Connected.Count() * percentageRequired;

            if (!activeVote)
            {
                player.Message(lang.GetMessage("No Vote Open", this, player.Id));
                return;
            }

            if (player.Equals(target))
            {
                player.Message(lang.GetMessage("Vote Self", this, player.Id));
                return;
            }

            if (voted.Contains(player.Id))
            {
                player.Message(lang.GetMessage("Already Voted", this, player.Id));
                return;
            }

             voted.Add(player.Id);
             player.Message(lang.GetMessage("Vote Placed", this, player.Id));

             if (voted.Count >= requiredVotes)
             {
                server.Broadcast(lang.GetMessage("Vote Successful", this));
                target.Kick(lang.GetMessage("Kick Message", this, player.Id));
                activeVote = false;
                 target = null;
                voteTimer?.Destroy();
                voted.Clear();
             }

        }

        #endregion

        #region Configuration

        private new void LoadConfig()
        {
            GetConfig(ref percentageRequired, "Percentage required");
            GetConfig(ref playersRequired, "Players required");

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion

        #region Helpers

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kick Message"] = "You have been voted out.",
                ["Vote Self"] = "<size=12>Error, you can't vote to kick yourself.</size>",
                ["Timed Out"] = "<size=12>Error, not enough votes, vote cancelled.</size>",
                ["Vote Successful"] = "<size=12>Vote successful.</size>",
                ["Not Enough Players"] = "<size=12>Error, not enough players online.</size>",
                ["No Arguments"] = "<size=12>Error, no arguments supplied.</size>",
                ["No Target"] = "<size=12>Error, no target supplied.</size>",
                ["Target Not Found"] = "<size=12>Error, player not found, try more specific terms.</size>",
                ["Already Voted"] = "<size=12>Error, you already voted.</size>",
                ["Vote Placed"] = "<size=12>Vote sucessfully placed.</size>",
                ["No Vote Open"] = "<size=12>Error, no vote open.</size>",
                ["No Permission"] = "<size=12>Error, no permission.</size>",
                ["Kick Started"] = "<size=12>{player} called a kick vote on {target}.</size> Use /vote to vote yes.",
                ["Target Disconnected"] = "<size=12>Vote cancelled, target disconnected.</size>",
                ["Another Vote Open"] = "<size=12>Error, another vote is already open.</size>"
            }, this);
        }

        #endregion
    }
}

// --- End of file: VoteKick.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vending-loot-drop ---
// --- Original File Path: V/VendingLootDrop/VendingLootDrop.cs ---

﻿using Newtonsoft.Json;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Vending Loot Drop", "Bazz3l", "1.0.6")]
    [Description("Drops vending machine contents when destroyed.")]
    class VendingLootDrop : RustPlugin
    {
        #region Fields

        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        class PluginConfig
        {
            [JsonProperty(PropertyName = "Drop chance (percents, 1f = 100%)")]
            public float DropChance;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    DropChance = 0.8f
                };
            }
        }

        #endregion

        #region Oxide

        void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));

            foreach (VendingMachine machine in BaseNetworkable.serverEntities.OfType<VendingMachine>())
            {
                OnEntitySpawned(machine);
            }
        }

        void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        void OnEntitySpawned(VendingMachine machine) => machine.dropsLoot = UnityEngine.Random.value <= _config.DropChance;

        #endregion
    }
}

// --- End of file: VendingLootDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vpn-block ---
// --- Original File Path: V/VPNBlock/VPNBlock.cs ---

using System.Collections.Generic;
using System;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info ("VPN Block", "Calytic", "1.0.0")]
    class VPNBlock : CovalencePlugin
    {
        List<string> allowedISPs = new List<string> ();
        string IPHUB_API_KEY;
        string IPSTACK_API_KEY;
        string AA_API_KEY;
        Dictionary<string, string> headers = new Dictionary<string, string> ();
        string unauthorizedMessage;
        bool debug = false;

        void Loaded ()
        {
            LoadData ();
            LoadMessages ();
            permission.RegisterPermission ("vpnblock.canvpn", this);
            IPHUB_API_KEY = GetConfig ("IPHub", "apiKey", string.Empty);
            IPSTACK_API_KEY = GetConfig ("IPStack", "apiKey", string.Empty);
            AA_API_KEY = GetConfig ("AbstractAPI", "apiKey", string.Empty);
            debug = GetConfig ("Debug", false);
            if (string.IsNullOrEmpty (IPHUB_API_KEY) && string.IsNullOrEmpty (IPSTACK_API_KEY) && string.IsNullOrEmpty (AA_API_KEY)) {
                Unsubscribe ("OnUserConnected");
            }

            if (!string.IsNullOrEmpty (IPHUB_API_KEY)) {
                headers.Add ("X-Key", IPHUB_API_KEY);
            }

            unauthorizedMessage = GetMsg ("Unauthorized");
        }

        protected override void LoadDefaultConfig ()
        {
            Config ["IPHub", "apiKey"] = "";
            Config ["IPStack", "apiKey"] = "";
            Config ["AbstractAPI", "apiKey"] = "";
            Config ["Debug"] = false;
        }

        void LoadData ()
        {
            allowedISPs = Interface.Oxide.DataFileSystem.ReadObject<List<string>> ("vpnblock_allowedisp");
        }

        void SaveData ()
        {
            Interface.Oxide.DataFileSystem.WriteObject ("vpnblock_allowedisp", allowedISPs);
        }

        [Command ("wisp")]
        void WhiteListISP (IPlayer player, string command, string [] args)
        {
            if (!IsAllowed (player)) return;

            if (args.Length == 0) {
                player.Reply (GetMsg ("WISP Invalid", player.Id));
                return;
            }

            allowedISPs.Add (string.Join (" ", args));

            player.Reply (GetMsg ("ISP Whitelisted", player.Id));
            SaveData ();
        }

        void LoadMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
            {
                {"Unauthorized", "Unauthorized.  ISP/VPN not permitted"},
                {"Is Banned", "{0} is trying to connect from proxy VPN/ISP {1}"},
                {"ISP Whitelisted", "ISP Whitelisted"},
                {"WISP Invalid", "Syntax Invalid. /wisp [ISP NAME]"},
            }, this);
        }

        bool IsAllowed (IPlayer player)
        {
            if (player.IsAdmin) return true;
            return false;
        }

        bool hasAccess (IPlayer player, string permissionname)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission (player.Id, permissionname);
        }

        void OnUserConnected (IPlayer player)
        {
            if (hasAccess (player, "vpnblock.canvpn")) {
                return;
            }

            string ip = player.Address;
            string url = string.Empty;
            if (!string.IsNullOrEmpty (IPHUB_API_KEY)) {
                url = string.Format ("http://v2.api.iphub.info/ip/{0}", ip);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleIPHubResponse (player, url, ip, code, response), this, RequestMethod.GET, headers);
            }

            if (!string.IsNullOrEmpty (IPSTACK_API_KEY)) {
                url = string.Format ("http://api.ipstack.com/{0}?access_key={1}", ip, IPSTACK_API_KEY);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleIPStackResponse (player, url, ip, code, response), this);
            }
            
            if (!string.IsNullOrEmpty (AA_API_KEY)) {
                url = string.Format ("https://ipgeolocation.abstractapi.com/v1/?ip_address{0}&api_key={1}", ip, AA_API_KEY);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleAAResponse (player, url, ip, code, response), this);
            }
        }

        void HandleIPHubResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                FailResponse("IPHub", code, response);
            } else {
                Dictionary<string, object> jsonresponse;
                try {
                    jsonresponse = JsonConvert.DeserializeObject<Dictionary<string, object>> (response);
                } catch (JsonReaderException e) {
                    PrintWarning ("Error parsing url response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (jsonresponse ["block"] != null) {
                    var playerVpn = (jsonresponse ["block"].ToString ());

                    if (jsonresponse ["asn"] == null) {
                        LogWarning ("IPHub response does not include asn information");
                        return;
                    }

                    var playerIsp = (jsonresponse ["asn"].ToString ());

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("IPHub response does not include block information");
                }
            }
        }
        
        void FailResponse(string service, int code, string response)
        {
            if(debug)
            {
                string message = string.Empty;
                if(code != 200)
                {
                    message = $"Response Code: {code}";
                }
                if(!string.IsNullOrEmpty(response))
                {
                    if(!string.IsNullOrEmpty(message))
                    {
                        message += "\n";
                    }
                    message += $"Response: {response}";
                }
                
                PrintError ($"Service ({service}) error: {message}");
            }
            else
            {
                PrintError ($"Service ({service}) temporarily offline");
            }
        }

        void HandleIPStackResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                
                FailResponse("IPStack", code, response);
            } else {
                JObject json;
                try {
                    json = JObject.Parse (response);
                } catch (JsonReaderException e) {
                    LogWarning ("Error parsing URL response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (json ["error"] != null) {
                    LogWarning (json ["error"] ["info"].ToString ().Split (new char [] { '.' }, 2) [1]);
                    return;
                }

                if (json ["security"] != null) {
                    if (json ["security"] ["is_proxy"] == null) {
                        LogWarning ("IPStack response does not include proxy information");
                        return;
                    }

                    if (json ["connection"] == null) {
                        LogWarning ("IPStack response does not include connection information");
                        return;
                    }

                    if (json ["connection"] ["asn"] == null) {
                        LogWarning ("IPStack response does not include isp information");
                        return;
                    }

                    string playerVpn = json ["security"] ["is_proxy"].ToString ();
                    string playerIsp = json ["connection"] ["asn"].ToString ();

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("IPStack response does not include security information");
                }
            }
        }
        
        void HandleAAResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                
                FailResponse("AbstractAPI", code, response);
            } else {
                JObject json;
                try {
                    json = JObject.Parse (response);
                } catch (JsonReaderException e) {
                    LogWarning ("Error parsing URL response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (json ["error"] != null) {
                    LogWarning (json ["error"] ["info"].ToString ().Split (new char [] { '.' }, 2) [1]);
                    return;
                }

                if (json ["security"] != null) {
                    if (json ["security"] ["is_vpn"] == null) {
                        LogWarning ("AbstractAPI response does not include proxy information");
                        return;
                    }

                    if (json ["connection"] == null) {
                        LogWarning ("AbstractAPI response does not include connection information");
                        return;
                    }

                    if (json ["connection"] ["isp_name"] == null) {
                        LogWarning ("AbstractAPI response does not include isp information");
                        return;
                    }

                    string playerVpn = json ["security"] ["is_vpn"].ToString ();
                    string playerIsp = json ["connection"] ["isp_name"].ToString ();

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("AbstractAPI response does not include security information");
                }
            }
        }

        bool IsWhitelisted (string playerIsp)
        {
            foreach (string isp in allowedISPs) {
                if (playerIsp.Contains (isp)) {
                    return true;
                }
            }

            return false;
        }

        T GetConfig<T> (string name, string name2, T defaultValue)
        {
            if (Config [name, name2] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name, name2], typeof (T));
        }

        T GetConfig<T> (string name, T defaultValue)
        {
            if (Config [name] == null)
                return defaultValue;

            return (T)Convert.ChangeType (Config [name], typeof (T));
        }

        string GetMsg (string key, object userID = null)
        {
            return lang.GetMessage (key, this, userID == null ? null : userID.ToString ());
        }
    }
}

// --- End of file: VPNBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-decay-protection ---
// --- Original File Path: V/VehicleDecayProtection/VehicleDecayProtection.cs ---

﻿// #define DEBUG_LOG
// #define DEBUG_SHOW

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Rust;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vehicle Decay Protection", "WhiteThunder", "2.7.1")]
    [Description("Protects vehicles from decay based on ownership and other factors.")]
    internal class VehicleDecayProtection : CovalencePlugin
    {
        #region Fields

        private Configuration _pluginConfig;

        private const string Permission_NoDecay_AllVehicles = "vehicledecayprotection.nodecay.allvehicles";

        private const float VanillaDecaySeconds = 60f;
        #if DEBUG_SHOW
        private const float MaxDrawSeconds = 30f;
        private const float MaxDrawDistanceSquared = 10000f;
        #endif

        private readonly VehicleInfoManager _vehicleInfoManager;

        public VehicleDecayProtection()
        {
            _vehicleInfoManager = new VehicleInfoManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Permission_NoDecay_AllVehicles, this);
        }

        private void OnServerInitialized()
        {
            _vehicleInfoManager.OnServerInitialized(_pluginConfig);

            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var entity = networkable as BaseEntity;
                if (entity is BaseVehicle or HotAirBalloon)
                {
                    HandleEntitySpawned(entity);
                }
            }
        }

        private void Unload()
        {
            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var entity = networkable as BaseEntity;
                if (entity is BaseVehicle or HotAirBalloon)
                {
                    var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                    if (vehicleInfo == null)
                        continue;

                    VehicleDecayReplacer.RemoveFromEntity(entity);
                }
            }
        }

        // Using separate hooks to improve performance by reducing hook calls.
        private void OnEntitySpawned(BaseVehicle entity) => HandleEntitySpawned(entity);
        private void OnEntitySpawned(HotAirBalloon entity) => HandleEntitySpawned(entity);

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnVehicleDecayReplace(BaseEntity entity)
            {
                return Interface.CallHook("OnVehicleDecayReplace", entity);
            }
        }

        #endregion

        #region Helper Methods

        private void ScheduleReplaceDecay(BaseEntity entity, IVehicleInfo vehicleInfo)
        {
            NextTick(() =>
            {
                if (entity == null || entity.IsDestroyed)
                    return;

                if (ExposedHooks.OnVehicleDecayReplace(entity) is false)
                    return;

                VehicleDecayReplacer.AddToEntity(entity, vehicleInfo);
            });
        }

        private void HandleEntitySpawned(BaseEntity entity)
        {
            // Null check because some people reported seeing GetVehicleInfo throw NRE, though this shouldn't happen.
            if (entity == null)
                return;

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
            if (vehicleInfo == null || !vehicleInfo.VehicleConfig.Enabled)
                return;

            ScheduleReplaceDecay(entity, vehicleInfo);
        }

        private bool UserHasPermission(UserData userData, string perm)
        {
            return userData.Perms.Contains(perm)
                || permission.GroupsHavePermission(userData.Groups, perm);
        }

        private bool UserHasVehiclePermission(ulong ownerId, string vehicleSpecificNoDecayPerm)
        {
            if (ownerId == 0)
                return false;

            var userData = permission.GetUserData(ownerId.ToString());

            return UserHasPermission(userData, Permission_NoDecay_AllVehicles)
                || UserHasPermission(userData, vehicleSpecificNoDecayPerm);
        }

        private bool VehiclePrivilegeHasPermission(BaseEntity vehicle, string vehicleSpecificNoDecayPerm)
        {
            var vehiclePrivilege = GetChildOfType<VehiclePrivilege>(vehicle);
            if (vehiclePrivilege == null)
                return false;

            foreach (var entry in vehiclePrivilege.authorizedPlayers)
            {
                if (UserHasVehiclePermission(entry.userid, vehicleSpecificNoDecayPerm))
                    return true;
            }

            return false;
        }

        private bool LockOwnerHasPermission(BaseEntity vehicle, string vehicleSpecificNoDecayPerm, out ulong lockOwnerId)
        {
            lockOwnerId = 0;

            var baseLock = vehicle.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
            if (baseLock == null || !baseLock.IsLocked() || baseLock.OwnerID == vehicle.OwnerID)
                return false;

            lockOwnerId = baseLock.OwnerID;
            return UserHasVehiclePermission(baseLock.OwnerID, vehicleSpecificNoDecayPerm);
        }

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Vehicle Decay Protection] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Vehicle Decay Protection] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Vehicle Decay Protection] {message}");

        private static T GetChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }

            return null;
        }

        private static string[] FindPrefabsOfType<T>() where T : BaseEntity
        {
            var prefabList = new List<string>();

            foreach (var assetPath in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(assetPath)?.GetComponent<T>();
                if (entity == null)
                    continue;

                prefabList.Add(entity.PrefabName);
            }

            return prefabList.ToArray();
        }

        #if DEBUG_SHOW
        private static bool IsPlayerDrawEligible(BasePlayer player, BaseEntity entity)
        {
            return player.IsAdmin
                && (player.transform.position - entity.transform.position).sqrMagnitude < MaxDrawDistanceSquared;
        }

        private static void DrawVehicleText(BasePlayer player, BaseEntity entity, IVehicleInfo vehicleInfo, Color color, string text)
        {
            player.SendConsoleCommand(
                "ddraw.text",
                Mathf.Min(MaxDrawSeconds, vehicleInfo.VehicleConfig.DecayIntervalSeconds - 5f),
                color,
                entity.transform.position + new Vector3(0, entity.WorldSpaceBounds().extents.y * 2, 0),
                $"<size=20>VDP ({vehicleInfo.VehicleConfig.DecayIntervalSeconds}s)\n{text}</size>"
            );
        }
        #endif

        private static void SetupDecayTick(FacepunchBehaviour component, Action action, float time)
        {
            component.InvokeRandomized(action, UnityEngine.Random.Range(time / 2f, time), time, time / 10f);
        }

        private static bool WasRecentlyUsed(BaseEntity entity, IVehicleInfo vehicleInfo, float protectionMinutesAfterUse = -1)
        {
            var timeSinceLastUsed = vehicleInfo.GetTimeSinceLastUsed(entity);
            var vehicleConfig = vehicleInfo.VehicleConfig;
            if (vehicleConfig.ProtectionMinutesAfterUse != -1)
            {
                protectionMinutesAfterUse = vehicleConfig.ProtectionMinutesAfterUse;
            }
            if (protectionMinutesAfterUse != -1 && timeSinceLastUsed >= 60 * protectionMinutesAfterUse)
                return false;

            #if DEBUG_SHOW
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (IsPlayerDrawEligible(player, entity))
                {
                    DrawVehicleText(player, entity, vehicleInfo, Color.green, $"{(int)timeSinceLastUsed}s < {60 * protectionMinutesAfterUse}s");
                }
            }
            #endif

            #if DEBUG_LOG
            LogWarning($"{entity.ShortPrefabName} :: Recently used :: {(int)timeSinceLastUsed}s < {60 * protectionMinutesAfterUse}s");
            #endif

            return true;
        }

        private static bool VehicleHasPermission(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo)
        {
            if (!pluginInstance._pluginConfig.EnablePermission)
                return false;

            pluginInstance.TrackStart();
            var ownerHasPermission = pluginInstance.UserHasVehiclePermission(entity.OwnerID, vehicleInfo.Permission);
            pluginInstance.TrackEnd();

            if (ownerHasPermission)
            {
                #if DEBUG_SHOW
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (IsPlayerDrawEligible(player, entity))
                    {
                        DrawVehicleText(player, entity, vehicleInfo, Color.green, "Owner permission");
                    }
                }
                #endif

                #if DEBUG_LOG
                LogWarning($"{entity.ShortPrefabName} :: Owner has permission :: {entity.OwnerID}");
                #endif

                return true;
            }

            ulong lockOwnerId;
            pluginInstance.TrackStart();
            var lockOwnerHasPermission = pluginInstance.LockOwnerHasPermission(entity, vehicleInfo.Permission, out lockOwnerId);
            pluginInstance.TrackEnd();

            if (lockOwnerHasPermission)
            {
                #if DEBUG_SHOW
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (IsPlayerDrawEligible(player, entity))
                    {
                        DrawVehicleText(player, entity, vehicleInfo, Color.green, "Lock owner permission");
                    }
                }
                #endif

                #if DEBUG_LOG
                LogWarning($"{entity.ShortPrefabName} :: Lock owner has permission");
                #endif

                return true;
            }

            pluginInstance.TrackStart();
            var privilegeHasPermission = entity is Tugboat && pluginInstance.VehiclePrivilegeHasPermission(entity, vehicleInfo.Permission);
            pluginInstance.TrackEnd();

            if (privilegeHasPermission)
            {
                #if DEBUG_SHOW
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (IsPlayerDrawEligible(player, entity))
                    {
                        DrawVehicleText(player, entity, vehicleInfo, Color.green, "Vehicle privilege permission");
                    }
                }
                #endif

                return true;
            }

            return false;
        }

        private static float GetInsideMultiplier(BaseEntity entity, IVehicleInfo vehicleInfo, out bool isOutside, bool forceOutsideCheck)
        {
            isOutside = true;

            var vehicleConfig = vehicleInfo.VehicleConfig;
            if (forceOutsideCheck || vehicleConfig.DecayMultiplierInside != 1f)
            {
                isOutside = entity.IsOutside();
            }

            if (vehicleConfig.DecayMultiplierInside == 1f || isOutside)
                return 1f;

            #if DEBUG_SHOW
            if (vehicleConfig.DecayMultiplierInside == 0f)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (IsPlayerDrawEligible(player, entity))
                    {
                        DrawVehicleText(player, entity, vehicleInfo, Color.green, $"Inside x{vehicleConfig.DecayMultiplierInside}");
                    }
                }
            }
            #endif

            #if DEBUG_LOG
            LogWarning($"{entity.ShortPrefabName} :: Inside :: x{vehicleConfig.DecayMultiplierInside}");
            #endif

            return vehicleConfig.DecayMultiplierInside;
        }

        private static float GetNearTCMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo)
        {
            var vehicleConfig = vehicleInfo.VehicleConfig;
            if (vehicleConfig.DecayMultiplierNearTC == 1f)
                return 1f;

            pluginInstance.TrackStart();
            var hasBuildingPrivilege = entity.GetBuildingPrivilege() != null;
            pluginInstance.TrackEnd();

            if (!hasBuildingPrivilege)
                return 1f;

            #if DEBUG_SHOW
            if (vehicleConfig.DecayMultiplierNearTC == 0f)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (IsPlayerDrawEligible(player, entity))
                    {
                        DrawVehicleText(player, entity, vehicleInfo, Color.green, $"Near TC x{vehicleConfig.DecayMultiplierNearTC}");
                    }
                }
            }
            #endif

            #if DEBUG_LOG
            LogWarning($"{entity.ShortPrefabName} :: Near TC :: x{vehicleConfig.DecayMultiplierNearTC}");
            #endif

            return vehicleConfig.DecayMultiplierNearTC;
        }

        private static float GetLocationMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo, out bool isOutside, bool forceOutsideCheck = false)
        {
            var multiplier = GetInsideMultiplier(entity, vehicleInfo, out isOutside, forceOutsideCheck);
            if (multiplier == 0f)
                return 0f;

            multiplier *= GetNearTCMultiplier(pluginInstance, entity, vehicleInfo);
            return multiplier == 0f ? 0f : multiplier;
        }

        private static float GetLocationMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo)
        {
            return GetLocationMultiplier(pluginInstance, entity, vehicleInfo, out _);
        }

        private static void DoDecayDamage(BaseCombatEntity entity, IVehicleInfo vehicleInfo, float fraction, DamageType damageType = DamageType.Decay, bool useProtection = false)
        {
            var amount = entity.MaxHealth() * fraction * vehicleInfo.GetTimeMultiplier();

            if (useProtection && entity.baseProtection != null)
            {
                // Manually scale damage so that we can show the correct amount.
                amount *= (1 - entity.baseProtection.amounts[(int)damageType]);
            }

            #if DEBUG_SHOW
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (IsPlayerDrawEligible(player, entity))
                {
                    DrawVehicleText(player, entity, vehicleInfo, Color.red, $"-{amount:f2}");
                }
            }
            #endif

            if (amount == 0)
                return;

            entity.Hurt(amount, damageType, entity, useProtection: false);
        }

        private static void DoCarDecayDamage(ModularCar car, IVehicleInfo vehicleInfo, float amount)
        {
            #if DEBUG_SHOW
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (IsPlayerDrawEligible(player, car))
                {
                    DrawVehicleText(player, car, vehicleInfo, Color.red, $"-{amount:f2}");
                }
            }
            #endif

            car.DoDecayDamage(amount);
        }

        private static void HelicopterDecay(VehicleDecayProtection pluginInstance, PlayerHelicopter heli, IVehicleInfo vehicleInfo)
        {
            if (heli.healthFraction == 0f
                || heli.IsOn()
                || WasRecentlyUsed(heli, vehicleInfo)
                || VehicleHasPermission(pluginInstance, heli, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, heli, vehicleInfo, out var isOutside, forceOutsideCheck: true);
            if (multiplier == 0f)
                return;

            var decayMinutes = isOutside ? PlayerHelicopter.outsidedecayminutes : PlayerHelicopter.insidedecayminutes;
            DoDecayDamage(heli, vehicleInfo, multiplier / decayMinutes);
        }

        private static void SnowmobileDecay(VehicleDecayProtection pluginInstance, Snowmobile snowmobile, IVehicleInfo vehicleInfo)
        {
            if (snowmobile.IsDead()
                || WasRecentlyUsed(snowmobile, vehicleInfo)
                || VehicleHasPermission(pluginInstance, snowmobile, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, snowmobile, vehicleInfo);
            if (multiplier == 0f)
                return;

            DoDecayDamage(snowmobile, vehicleInfo, multiplier / Snowmobile.outsideDecayMinutes);
        }

        private static void WaterVehicleDecay(VehicleDecayProtection pluginInstance, BaseCombatEntity waterVehicle, IVehicleInfo vehicleInfo, float outsideDecayMinutes, float deepWaterDecayMinutes, float protectionMinutesAfterUse = -1)
        {
            if (waterVehicle.healthFraction == 0f
                || WasRecentlyUsed(waterVehicle, vehicleInfo, protectionMinutesAfterUse)
                || VehicleHasPermission(pluginInstance, waterVehicle, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, waterVehicle, vehicleInfo);
            if (multiplier == 0f)
                return;

            var decayMinutes = outsideDecayMinutes;
            var overallWaterDepth = WaterLevel.GetOverallWaterDepth(waterVehicle.transform.position, waves: true, volumes: false);
            if (overallWaterDepth > 12f)
            {
                var divisor = Mathf.Lerp(0.1f, 1f, Mathf.InverseLerp(12f, 16f, overallWaterDepth));
                decayMinutes = Mathf.Min(decayMinutes, deepWaterDecayMinutes / divisor);
            }

            DoDecayDamage(waterVehicle, vehicleInfo, multiplier / decayMinutes);
        }

        private static void SledDecay(VehicleDecayProtection pluginInstance, Sled sled, IVehicleInfo vehicleInfo)
        {
            if (sled.DecayAmount == 0f
                || sled.AnyMounted()
                || VehicleHasPermission(pluginInstance, sled, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, sled, vehicleInfo);
            if (multiplier == 0f)
                return;

            DoDecayDamage(sled, vehicleInfo, multiplier * sled.DecayAmount / sled.MaxHealth(), DamageType.Generic, useProtection: true);
        }

        private static void BikeDecay(VehicleDecayProtection pluginInstance, Bike bike, IVehicleInfo vehicleInfo)
        {
            if (bike.IsDead()
                || WasRecentlyUsed(bike, vehicleInfo)
                || VehicleHasPermission(pluginInstance, bike, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, bike, vehicleInfo, out _, forceOutsideCheck: true);
            if (multiplier == 0f)
                return;

            DoDecayDamage(bike, vehicleInfo, multiplier / Bike.outsideDecayMinutes);
        }

        private static void SiegeWeaponDecay(VehicleDecayProtection pluginInstance, BaseSiegeWeapon siegeWeapon, IVehicleInfo vehicleInfo)
        {
            if (siegeWeapon.IsDestroyed
                || WasRecentlyUsed(siegeWeapon, vehicleInfo)
                || VehicleHasPermission(pluginInstance, siegeWeapon, vehicleInfo))
                return;

            var multiplier = GetLocationMultiplier(pluginInstance, siegeWeapon, vehicleInfo);
            if (multiplier == 0f)
                return;

            DoDecayDamage(siegeWeapon, vehicleInfo, multiplier / BaseSiegeWeapon.outsideDecayMinutes, useProtection: true);
        }

        #endregion

        #region Vehicle Decay Component

        private class VehicleDecayReplacer : FacepunchBehaviour
        {
            public static void AddToEntity(BaseEntity entity, IVehicleInfo vehicleInfo)
            {
                var component = entity.gameObject.AddComponent<VehicleDecayReplacer>();
                component._entity = entity;
                component._vehicleInfo = vehicleInfo;

                // Cancel vanilla decay.
                var vanillaDecayMethod = vehicleInfo.GetVanillaDecayMethod(entity);
                if (vanillaDecayMethod != null)
                {
                    entity.CancelInvoke(vanillaDecayMethod);
                }

                // Enable custom decay.
                SetupDecayTick(component, component.DecayTick, vehicleInfo.VehicleConfig.DecayIntervalSeconds);
            }

            public static void RemoveFromEntity(BaseEntity entity)
            {
                var component = entity.gameObject.GetComponent<VehicleDecayReplacer>();
                if (component == null)
                    return;

                // Enable vanilla decay.
                var vanillaDecayMethod = component._vehicleInfo.GetVanillaDecayMethod(entity);
                if (vanillaDecayMethod != null)
                {
                    SetupDecayTick(entity, vanillaDecayMethod, VanillaDecaySeconds);
                }

                // Cancel custom decay.
                DestroyImmediate(component);
            }

            private BaseEntity _entity;
            private IVehicleInfo _vehicleInfo;

            private void DecayTick()
            {
                _vehicleInfo.DecayTick(_entity);
            }
        }

        #endregion

        #region Vehicle Info

        private struct HorseInfo
        {
            public static HorseInfo FromHorse(RidableHorse ridableHorse)
            {
                return new HorseInfo
                {
                    IsForSale = ridableHorse.IsForSale(),
                    LastEatTime = ridableHorse.lastEatTime,
                    NextDecayTime = ridableHorse.nextDecayTime,
                };
            }

            public static HorseInfo FromHorse(RidableHorse2 ridableHorse2)
            {
                return new HorseInfo
                {
                    IsForSale = ridableHorse2.IsForSale,
                    LastEatTime = ridableHorse2.lastEatTime,
                    NextDecayTime = ridableHorse2.nextDecayTime,
                };
            }

            public bool IsForSale;
            public float LastEatTime;
            public float NextDecayTime;
        }

        private interface IVehicleInfo
        {
            uint[] PrefabIds { get; }
            VehicleConfig VehicleConfig { get; }
            string Permission { get; }

            void OnServerInitialized(VehicleDecayProtection plugin);
            bool IsCorrectType(BaseEntity entity);
            float GetTimeMultiplier();
            float GetTimeSinceLastUsed(BaseEntity entity);
            Action GetVanillaDecayMethod(BaseEntity entity);
            void DecayTick(BaseEntity entity);
        }

        private class VehicleInfo<T> : IVehicleInfo where T : BaseEntity
        {
            public uint[] PrefabIds { get; private set; }
            public VehicleConfig VehicleConfig { get; set; }
            public string Permission { get; private set; }

            public string VehicleType;
            public string[] PrefabPaths;

            public Func<T, float> TimeSinceLastUsed = (entity) =>
            {
                throw new NotImplementedException($"TimeSinceLastUsed: {entity.ShortPrefabName}");
            };

            public Func<T, Action> VanillaDecayMethod = (entity) =>
            {
                throw new NotImplementedException($"VanillaDecayMethod: {entity.ShortPrefabName}");
            };

            public Action<T, IVehicleInfo> Decay = (entity, vehicleInfo) =>
            {
                throw new NotImplementedException($"Decay: {entity.ShortPrefabName}");
            };

            public void OnServerInitialized(VehicleDecayProtection pluginInstance)
            {
                Permission = $"{nameof(VehicleDecayProtection)}.nodecay.{VehicleType}".ToLower();
                pluginInstance.permission.RegisterPermission(Permission, pluginInstance);

                var prefabIds = new List<uint>(PrefabPaths.Length);

                foreach (var prefabName in PrefabPaths)
                {
                    var prefabId = StringPool.Get(prefabName);
                    if (prefabId != 0)
                    {
                        prefabIds.Add(prefabId);
                    }
                    else
                    {
                        LogError($"Invalid prefab. Please alert the plugin maintainer -- {prefabName}");
                    }
                }

                PrefabIds = prefabIds.ToArray();
            }

            public bool IsCorrectType(BaseEntity entity)
            {
                return entity is T;
            }

            public float GetTimeMultiplier()
            {
                return VehicleConfig.DecayIntervalSeconds / VanillaDecaySeconds;
            }

            public float GetTimeSinceLastUsed(BaseEntity entity)
            {
                return TimeSinceLastUsed(entity as T);
            }

            public Action GetVanillaDecayMethod(BaseEntity entity)
            {
                return VanillaDecayMethod(entity as T);
            }

            public void DecayTick(BaseEntity entity)
            {
                Decay(entity as T, this);
            }
        }

        private class VehicleInfoManager
        {
            private static readonly FieldInfo BikeTimeSinceLastUsedField = typeof(Bike).GetField("timeSinceLastUsed",
                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            private VehicleDecayProtection _pluginInstance;

            private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo = new();

            public VehicleInfoManager(VehicleDecayProtection pluginInstance)
            {
                _pluginInstance = pluginInstance;
            }

            public void OnServerInitialized(Configuration pluginConfig)
            {
                var allVehicles = new IVehicleInfo[]
                {
                    new VehicleInfo<AttackHelicopter>
                    {
                        VehicleType = "attackhelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.AttackHelicopter,
                        TimeSinceLastUsed = heli => UnityEngine.Time.time - heli.lastEngineOnTime,
                        VanillaDecayMethod = heli => heli.DecayTick,
                        Decay = (heli, vehicleInfo) => HelicopterDecay(_pluginInstance, heli, vehicleInfo),
                    },
                    new VehicleInfo<Ballista>
                    {
                        VehicleType = "ballista",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/ballista/ballista.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Ballista,
                        TimeSinceLastUsed = siegeWeapon => UnityEngine.Time.time - siegeWeapon.lastUseTime,
                        VanillaDecayMethod = siegeWeapon => siegeWeapon.DecayTick,
                        Decay = (siegeWeapon, vehicleInfo) => SiegeWeaponDecay(_pluginInstance, siegeWeapon, vehicleInfo),
                    },
                    new VehicleInfo<BatteringRam>
                    {
                        VehicleType = "batteringram",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/batteringram/batteringram.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.BatteringRam,
                        TimeSinceLastUsed = siegeWeapon => UnityEngine.Time.time - siegeWeapon.lastUseTime,
                        VanillaDecayMethod = siegeWeapon => siegeWeapon.DecayTick,
                        Decay = (siegeWeapon, vehicleInfo) => SiegeWeaponDecay(_pluginInstance, siegeWeapon, vehicleInfo),
                    },
                    new VehicleInfo<Catapult>
                    {
                        VehicleType = "catapult",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/catapult/catapult.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Catapult,
                        TimeSinceLastUsed = siegeWeapon => UnityEngine.Time.time - siegeWeapon.lastUseTime,
                        VanillaDecayMethod = siegeWeapon => siegeWeapon.DecayTick,
                        Decay = (siegeWeapon, vehicleInfo) => SiegeWeaponDecay(_pluginInstance, siegeWeapon, vehicleInfo),
                    },
                    new VehicleInfo<SiegeTower>
                    {
                        VehicleType = "siegetower",
                        PrefabPaths = new[] { "assets/content/vehicles/siegeweapons/siegetower/siegetower.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.SiegeTower,
                        TimeSinceLastUsed = siegeWeapon => UnityEngine.Time.time - siegeWeapon.lastUseTime,
                        VanillaDecayMethod = siegeWeapon => siegeWeapon.DecayTick,
                        Decay = (siegeWeapon, vehicleInfo) => SiegeWeaponDecay(_pluginInstance, siegeWeapon, vehicleInfo),
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleType = "motorbike.sidecar",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike_sidecar.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.MotorBikeSidecar,
                        TimeSinceLastUsed = bike => (TimeSince)BikeTimeSinceLastUsedField.GetValue(bike),
                        VanillaDecayMethod = bike => bike.BikeDecay,
                        Decay = (bike, vehicleInfo) => BikeDecay(_pluginInstance, bike, vehicleInfo),
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleType = "motorbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/motorbike.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.MotorBike,
                        TimeSinceLastUsed = bike => (TimeSince)BikeTimeSinceLastUsedField.GetValue(bike),
                        VanillaDecayMethod = bike => bike.BikeDecay,
                        Decay = (bike, vehicleInfo) => BikeDecay(_pluginInstance, bike, vehicleInfo),
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleType = "pedalbike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedalbike.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.PedalBike,
                        TimeSinceLastUsed = bike => (TimeSince)BikeTimeSinceLastUsedField.GetValue(bike),
                        VanillaDecayMethod = bike => bike.BikeDecay,
                        Decay = (bike, vehicleInfo) => BikeDecay(_pluginInstance, bike, vehicleInfo),
                    },
                    new VehicleInfo<Bike>
                    {
                        VehicleType = "pedaltrike",
                        PrefabPaths = new[] { "assets/content/vehicles/bikes/pedaltrike.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.PedalTrike,
                        TimeSinceLastUsed = bike => (TimeSince)BikeTimeSinceLastUsedField.GetValue(bike),
                        VanillaDecayMethod = bike => bike.BikeDecay,
                        Decay = (bike, vehicleInfo) => BikeDecay(_pluginInstance, bike, vehicleInfo),
                    },
                    new VehicleInfo<SubmarineDuo>
                    {
                        VehicleType = "duosubmarine",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarineduo.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.DuoSubmarine,
                        TimeSinceLastUsed = submarine => submarine.timeSinceLastUsed,
                        VanillaDecayMethod = submarine => submarine.SubmarineDecay,
                        Decay = (submarine, vehicleInfo) => WaterVehicleDecay(
                            _pluginInstance,
                            submarine,
                            vehicleInfo,
                            BaseSubmarine.outsidedecayminutes,
                            BaseSubmarine.deepwaterdecayminutes
                        )
                    },
                    new VehicleInfo<HotAirBalloon>
                    {
                        VehicleType = "hotairballoon",
                        PrefabPaths = new[] { "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.HotAirBalloon,
                        TimeSinceLastUsed = hab => UnityEngine.Time.time - hab.sinceLastBlast,
                        VanillaDecayMethod = hab => hab.DecayTick,
                        Decay = (hab, vehicleInfo) =>
                        {
                            if (hab.healthFraction == 0f
                                || hab.IsFullyInflated
                                || WasRecentlyUsed(hab, vehicleInfo)
                                || VehicleHasPermission(_pluginInstance, hab, vehicleInfo))
                                return;

                            var multiplier = GetLocationMultiplier(_pluginInstance, hab, vehicleInfo);
                            if (multiplier == 0f)
                                return;

                            DoDecayDamage(hab, vehicleInfo, multiplier / HotAirBalloon.outsidedecayminutes);
                        }
                    },
                    new VehicleInfo<Kayak>
                    {
                        VehicleType = "kayak",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/kayak/kayak.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Kayak,
                        TimeSinceLastUsed = kayak => kayak.timeSinceLastUsed,
                        VanillaDecayMethod = kayak => kayak.BoatDecay,
                        Decay = (kayak, vehicleInfo) => WaterVehicleDecay(
                            _pluginInstance,
                            kayak,
                            vehicleInfo,
                            MotorRowboat.outsidedecayminutes,
                            MotorRowboat.deepwaterdecayminutes
                        ),
                    },
                    new VehicleInfo<Minicopter>
                    {
                        VehicleType = "minicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/minicopter/minicopter.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Minicopter,
                        TimeSinceLastUsed = mini => UnityEngine.Time.time - mini.lastEngineOnTime,
                        VanillaDecayMethod = mini => mini.DecayTick,
                        Decay = (mini, vehicleInfo) => HelicopterDecay(_pluginInstance, mini, vehicleInfo),
                    },
                    new VehicleInfo<ModularCar>
                    {
                        VehicleType = "modularcar",
                        // There are at least 37 valid Modular Car prefabs.
                        PrefabPaths = FindPrefabsOfType<ModularCar>(),
                        VehicleConfig = pluginConfig.Vehicles.ModularCar,
                        TimeSinceLastUsed = car => UnityEngine.Time.time - car.lastEngineOnTime,
                        VanillaDecayMethod = car => car.DecayTick,
                        Decay = (car, vehicleInfo) =>
                        {
                            if (car.IsDestroyed
                                || car.IsOn()
                                || car.immuneToDecay
                                || WasRecentlyUsed(car, vehicleInfo)
                                || VehicleHasPermission(_pluginInstance, car, vehicleInfo))
                                return;

                            if (car.IsDead())
                            {
                                var numModules = Mathf.Max(1, car.AttachedModuleEntities.Count);
                                DoCarDecayDamage(car, vehicleInfo, 120f / numModules * vehicleInfo.GetTimeMultiplier());
                                return;
                            }

                            var multiplier = GetLocationMultiplier(_pluginInstance, car, vehicleInfo);
                            if (multiplier == 0f)
                                return;

                            var health = car.HasAnyModules
                                ? car.AttachedModuleEntities.Max(module => module.MaxHealth())
                                : car.MaxHealth();

                            DoCarDecayDamage(car, vehicleInfo, health * vehicleInfo.GetTimeMultiplier() * multiplier / ModularCar.outsidedecayminutes);
                        }
                    },
                    new VehicleInfo<RHIB>
                    {
                        VehicleType = "rhib",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rhib/rhib.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.RHIB,
                        TimeSinceLastUsed = rhib => rhib.timeSinceLastUsedFuel,
                        VanillaDecayMethod = rhib => rhib.BoatDecay,
                        Decay = (rhib, vehicleInfo) =>
                        {
                            if (rhib.IsDying)
                                return;

                            WaterVehicleDecay(
                                _pluginInstance,
                                rhib,
                                vehicleInfo,
                                MotorRowboat.outsidedecayminutes,
                                MotorRowboat.deepwaterdecayminutes,
                                MotorRowboat.decaystartdelayminutes
                            );
                        }
                    },
                    // Using BaseVehicle since it's the closest base class of RidableHorse and RidableHorse2.
                    new VehicleInfo<BaseVehicle>
                    {
                        VehicleType = "ridablehorse",
                        PrefabPaths = new[]
                        {
                            "assets/content/vehicles/horse/ridablehorse2.prefab",
                            "assets/content/vehicles/horse/_old/testridablehorse.prefab",
                        },
                        VehicleConfig = pluginConfig.Vehicles.RidableHorse,
                        TimeSinceLastUsed = horse =>
                        {
                            var lastInputTime = horse switch
                            {
                                RidableHorse ridableHorse => ridableHorse.lastInputTime,
                                RidableHorse2 ridableHorse2 => ridableHorse2.lastRiddenTime,
                                _ => UnityEngine.Time.time,
                            };

                            return UnityEngine.Time.time - lastInputTime;
                        },
                        VanillaDecayMethod = horse =>
                        {
                            if (horse is RidableHorse ridableHorse)
                                return ridableHorse.AnimalDecay;

                            if (horse is RidableHorse2 ridableHorse2)
                                return ridableHorse2.HorseDecay;

                            return null;
                        },
                        Decay = (horse, vehicleInfo) =>
                        {
                            if (horse.healthFraction == 0f
                                || horse.IsDestroyed
                                || WasRecentlyUsed(horse, vehicleInfo))
                                return;

                            HorseInfo horseInfo;

                            switch (horse)
                            {
                                case RidableHorse ridableHorse:
                                    horseInfo = HorseInfo.FromHorse(ridableHorse);
                                    break;
                                case RidableHorse2 ridableHorse2:
                                    horseInfo = HorseInfo.FromHorse(ridableHorse2);
                                    break;
                                default:
                                    return;
                            }

                            if (UnityEngine.Time.time < horseInfo.LastEatTime + 600f
                                || horseInfo.IsForSale
                                || UnityEngine.Time.time < horseInfo.NextDecayTime
                                || VehicleHasPermission(_pluginInstance, horse, vehicleInfo))
                                return;

                            var multiplier = GetLocationMultiplier(_pluginInstance, horse, vehicleInfo);
                            if (multiplier == 0f)
                                return;

                            DoDecayDamage(horse, vehicleInfo, multiplier / BaseRidableAnimal.decayminutes);
                        },
                    },
                    new VehicleInfo<MotorRowboat>
                    {
                        VehicleType = "rowboat",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/rowboat/rowboat.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Rowboat,
                        TimeSinceLastUsed = rowBoat => rowBoat.timeSinceLastUsedFuel,
                        VanillaDecayMethod = rowBoat => rowBoat.BoatDecay,
                        Decay = (rowBoat, vehicleInfo) =>
                        {
                            if (rowBoat.IsDying)
                                return;

                            WaterVehicleDecay(
                                _pluginInstance,
                                rowBoat,
                                vehicleInfo,
                                MotorRowboat.outsidedecayminutes,
                                MotorRowboat.deepwaterdecayminutes,
                                MotorRowboat.decaystartdelayminutes
                            );
                        }
                    },
                    new VehicleInfo<ScrapTransportHelicopter>
                    {
                        VehicleType = "scraptransporthelicopter",
                        PrefabPaths = new[] { "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.ScrapTransportHelicopter,
                        TimeSinceLastUsed = heli => UnityEngine.Time.time - heli.lastEngineOnTime,
                        VanillaDecayMethod = heli => heli.DecayTick,
                        Decay = (heli, vehicleInfo) => HelicopterDecay(_pluginInstance, heli, vehicleInfo),
                    },
                    new VehicleInfo<Sled>
                    {
                        VehicleType = "sled",
                        PrefabPaths = new[] { "assets/prefabs/misc/xmas/sled/sled.deployed.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Sled,
                        TimeSinceLastUsed = sled => float.MaxValue,
                        VanillaDecayMethod = sled => sled.DecayOverTime,
                        Decay = (sled, vehicleInfo) => SledDecay(_pluginInstance, sled, vehicleInfo)
                    },
                    new VehicleInfo<Sled>
                    {
                        VehicleType = "sled.xmas",
                        PrefabPaths = new[] { "assets/prefabs/misc/xmas/sled/skins/sled.deployed.xmas.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.SledXmas,
                        TimeSinceLastUsed = sled => float.MaxValue,
                        VanillaDecayMethod = sled => sled.DecayOverTime,
                        Decay = (sled, vehicleInfo) => SledDecay(_pluginInstance, sled, vehicleInfo)
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleType = "snowmobile",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/snowmobile.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Snowmobile,
                        TimeSinceLastUsed = snowmobile => snowmobile.timeSinceLastUsed,
                        VanillaDecayMethod = snowmobile => snowmobile.SnowmobileDecay,
                        Decay = (snowmobile, vehicleInfo) => SnowmobileDecay(_pluginInstance, snowmobile, vehicleInfo),
                    },
                    new VehicleInfo<BaseSubmarine>
                    {
                        VehicleType = "solosubmarine",
                        PrefabPaths = new[] { "assets/content/vehicles/submarine/submarinesolo.entity.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.SoloSubmarine,
                        TimeSinceLastUsed = submarine => submarine.timeSinceLastUsed,
                        VanillaDecayMethod = submarine => submarine.SubmarineDecay,
                        Decay = (submarine, vehicleInfo) => WaterVehicleDecay(
                            _pluginInstance,
                            submarine,
                            vehicleInfo,
                            BaseSubmarine.outsidedecayminutes,
                            BaseSubmarine.deepwaterdecayminutes
                        ),
                    },
                    new VehicleInfo<Snowmobile>
                    {
                        VehicleType = "tomaha",
                        PrefabPaths = new[] { "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Tomaha,
                        TimeSinceLastUsed = tomaha => tomaha.timeSinceLastUsed,
                        VanillaDecayMethod = tomaha => tomaha.SnowmobileDecay,
                        Decay = (tomaha, vehicleInfo) => SnowmobileDecay(_pluginInstance, tomaha, vehicleInfo),
                    },
                    new VehicleInfo<Tugboat>
                    {
                        VehicleType = "tugboat",
                        PrefabPaths = new[] { "assets/content/vehicles/boats/tugboat/tugboat.prefab" },
                        VehicleConfig = pluginConfig.Vehicles.Tugboat,
                        TimeSinceLastUsed = tugboat => tugboat.timeSinceLastUsedFuel,
                        VanillaDecayMethod = tugboat => tugboat.BoatDecay,
                        Decay = (tugboat, vehicleInfo) =>
                        {
                            if (tugboat.IsDying)
                                return;

                            WaterVehicleDecay(
                                _pluginInstance,
                                tugboat,
                                vehicleInfo,
                                Tugboat.tugdecayminutes,
                                Tugboat.tugdecayminutes,
                                Tugboat.tugdecaystartdelayminutes
                            );
                        },
                    },
                };

                foreach (var vehicleInfo in allVehicles)
                {
                    vehicleInfo.OnServerInitialized(_pluginInstance);

                    foreach (var prefabId in vehicleInfo.PrefabIds)
                    {
                        _prefabIdToVehicleInfo[prefabId] = vehicleInfo;
                    }
                }
            }

            public IVehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                return _prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out var vehicleInfo) && vehicleInfo.IsCorrectType(entity)
                    ? vehicleInfo
                    : null;
            }
        }

        #endregion

        #region Configuration

        private class VehicleConfig
        {
            [JsonProperty("Allow the plugin to influence decay")]
            public bool Enabled = true;

            [JsonProperty("Decay multiplier while inside")]
            public float DecayMultiplierInside = 1;

            [JsonProperty("DecayMultiplierInside")]
            private float DeprecatedDecayMultiplierInside { set => DecayMultiplierInside = value; }

            [JsonProperty("Decay multiplier near tool cupboard")]
            public float DecayMultiplierNearTC = 1;

            [JsonProperty("DecayMultiplierNearTC")]
            private float DeprecatedDecayMultiplierNearTC { set => DecayMultiplierNearTC = value; }

            [JsonProperty("Protect from decay after recent use (minutes)", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(-1f)]
            public float ProtectionMinutesAfterUse = 10;

            [JsonProperty("ProtectionMinutesAfterUse")]
            private float DeprecatedProtectionMinutesAfterUse { set => ProtectionMinutesAfterUse = value; }

            [JsonProperty("Decay interval (seconds)")]
            public float DecayIntervalSeconds = 60;

            [JsonProperty("DecayIntervalSeconds")]
            private float DeprecatedDecayIntervalSeconds { set => DecayIntervalSeconds = value; }
        }

        private class VehicleConfigMap
        {
            [JsonProperty("Ridable Horse")]
            public VehicleConfig RidableHorse = new()
            {
                DecayMultiplierInside = 2,
                ProtectionMinutesAfterUse = 10,
            };

            [JsonProperty("RidableHorse")]
            private VehicleConfig DeprecatedRidableHorse { set => RidableHorse = value; }

            [JsonProperty("Ballista")]
            public VehicleConfig Ballista = new()
            {
                DecayMultiplierInside = 0.1f,
                ProtectionMinutesAfterUse = 5,
            };

            [JsonProperty("Battering Ram")]
            public VehicleConfig BatteringRam = new()
            {
                DecayMultiplierInside = 0.1f,
                ProtectionMinutesAfterUse = 5,
            };

            [JsonProperty("Catapult")]
            public VehicleConfig Catapult = new()
            {
                DecayMultiplierInside = 0.1f,
                ProtectionMinutesAfterUse = 5,
            };

            [JsonProperty("Siege Tower")]
            public VehicleConfig SiegeTower = new()
            {
                DecayMultiplierInside = 0.1f,
                ProtectionMinutesAfterUse = 5,
            };

            [JsonProperty("Modular Car")]
            public VehicleConfig ModularCar = new()
            {
                DecayMultiplierInside = 0.1f,
                ProtectionMinutesAfterUse = 10,
            };

            [JsonProperty("ModularCar")]
            private VehicleConfig DeprecatedModularCar { set => ModularCar = value; }

            [JsonProperty("Motor Bike")]
            public VehicleConfig MotorBike = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Motor Bike Sidecar")]
            public VehicleConfig MotorBikeSidecar = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Pedal Bike")]
            public VehicleConfig PedalBike = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Pedal Trike")]
            public VehicleConfig PedalTrike = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Snowmobile")]
            public VehicleConfig Snowmobile = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Tomaha")]
            public VehicleConfig Tomaha = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 45,
            };

            [JsonProperty("Sled")]
            public VehicleConfig Sled = new()
            {
                DecayMultiplierInside = 1f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("Sled Xmas")]
            public VehicleConfig SledXmas = new()
            {
                DecayMultiplierInside = 1f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("Sled.Xmas")]
            private VehicleConfig DeprecatedSledXmas { set => SledXmas = value; }

            [JsonProperty("Kayak")]
            public VehicleConfig Kayak = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("Rowboat")]
            public VehicleConfig Rowboat = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("RHIB")]
            public VehicleConfig RHIB = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("Tugboat")]
            public VehicleConfig Tugboat = new()
            {
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("Solo Submarine")]
            public VehicleConfig SoloSubmarine = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("SoloSubmarine")]
            private VehicleConfig DeprecatedSoloSubmarine { set => SoloSubmarine = value; }

            [JsonProperty("Duo Submarine")]
            public VehicleConfig DuoSubmarine = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = -1,
            };

            [JsonProperty("DuoSubmarine")]
            private VehicleConfig DeprecatedDuoSubmarine { set => DuoSubmarine = value; }

            [JsonProperty("Hot Air Balloon")]
            public VehicleConfig HotAirBalloon = new()
            {
                DecayMultiplierInside = 0f,
                ProtectionMinutesAfterUse = 10,
            };

            [JsonProperty("HotAirBalloon")]
            private VehicleConfig DeprecatedHotAirBalloon { set => HotAirBalloon = value; }

            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new()
            {
                DecayMultiplierInside = 1f,
                ProtectionMinutesAfterUse = 10,
            };

            [JsonProperty("Scrap Transport Helicopter")]
            public VehicleConfig ScrapTransportHelicopter = new()
            {
                DecayMultiplierInside = 1f,
                ProtectionMinutesAfterUse = 10,
            };

            [JsonProperty("ScrapTransportHelicopter")]
            private VehicleConfig DeprecatedScrapTransportHelicopter { set => ScrapTransportHelicopter = value; }

            [JsonProperty("Attack Helicopter")]
            public VehicleConfig AttackHelicopter = new()
            {
                DecayMultiplierInside = 1f,
                ProtectionMinutesAfterUse = 10,
            };
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Enable permission")]
            public bool EnablePermission = true;

            [JsonProperty("EnablePermission")]
            private bool DeprecatedEnablePermission { set => EnablePermission = value; }

            [JsonProperty("Vehicles")]
            public VehicleConfigMap Vehicles = new();
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: VehicleDecayProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vehicle-storage ---
// --- Original File Path: V/VehicleStorage/VehicleStorage.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vehicle Storage", "WhiteThunder", "3.5.1")]
    [Description("Allows adding storage containers to vehicles and increasing built-in storage capacity.")]
    internal class VehicleStorage : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin CargoTrainEvent;

        private Configuration _config;

        private const string BasePermissionPrefix = "vehiclestorage";

        private const string RhibStoragePrefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";
        private const string HabStoragePrefab = "assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab";

        private const string StashDeployEffectPrefab = "assets/prefabs/deployable/small stash/effects/small-stash-deploy.prefab";
        private const string BoxDeployEffectPrefab = "assets/prefabs/deployable/woodenbox/effects/wooden-box-deploy.prefab";

        private const string ResizableLootPanelName = "generic_resizable";
        private const int MaxCapacity = 48;

        private readonly VehicleTracker _vehicleTracker = new VehicleTracker();
        private readonly ReskinEventManager _reskinEventManager = new ReskinEventManager();
        private readonly ContainerBoundsManager _containerBoundsManager = new ContainerBoundsManager();

        #endregion

        #region Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            _config.Init(this);
            _containerBoundsManager.OnServerInitialized(this);

            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                var baseEntity = networkable as BaseEntity;
                if (baseEntity == null)
                    continue;

                OnEntitySpawned(baseEntity);
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            var vehicleConfig = _config.GetVehicleConfig(entity);
            if (vehicleConfig == null)
                return;

            _vehicleTracker.AddVehicle(vehicleConfig, entity);

            // Wait 2 ticks to give Vehicle Vendor Options an opportunity to set ownership.
            NextTick(() => NextTick(() =>
            {
                if (entity == null)
                    return;

                RefreshVehicleStorage(entity, vehicleConfig);
            }));
        }

        private void OnEntityKill(BaseEntity entity)
        {
            var vehicleConfig = _config.GetVehicleConfig(entity);
            if (vehicleConfig == null || vehicleConfig.ContainerPresets == null)
                return;

            if (!_vehicleTracker.RemoveVehicle(vehicleConfig, entity))
                return;

            foreach (var child in entity.children)
            {
                var container = child as StorageContainer;
                if (container == null)
                    continue;

                if (!vehicleConfig.ContainerPresets.ContainsKey(container.name))
                    continue;

                container.DropItems();
            }
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (perm.StartsWith(BasePermissionPrefix))
            {
                HandlePermissionChanged(userId);
            }
        }

        private void OnGroupPermissionGranted(string group, string perm)
        {
            if (perm.StartsWith(BasePermissionPrefix))
            {
                HandlePermissionChanged();
            }
        }

        private void OnUserGroupAdded(string userId, string groupName)
        {
            var permList = permission.GetGroupPermissions(groupName, parents: true);
            foreach (var perm in permList)
            {
                if (perm.StartsWith(BasePermissionPrefix))
                {
                    HandlePermissionChanged(userId);
                    return;
                }
            }
        }

        private void OnRidableAnimalClaimed(RidableHorse horse, BasePlayer player)
        {
            RefreshVehicleStorage(horse);
        }

        private void OnEntityReskin(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            var vehicleConfig = _config.GetVehicleConfig(snowmobile);
            if (vehicleConfig?.ContainerPresets == null)
                return;

            var reskinEvent = _reskinEventManager.GetEvent()
                .WithParent(snowmobile)
                .WithVehicleConfig(vehicleConfig);

            for (var i = snowmobile.children.Count - 1; i >= 0; i--)
            {
                var container = snowmobile.children[i] as StorageContainer;
                if (container == null || container.IsDestroyed)
                    continue;

                if (!vehicleConfig.ContainerPresets.ContainsKey(container.name))
                    continue;

                reskinEvent.AddContainer(container);

                // Unparent the container to prevent it from being destroyed.
                // It will later be parented to the newly spawned entity.
                container.SetParent(null);
            }

            if (reskinEvent.Containers.Count == 0)
            {
                _reskinEventManager.CancelEvent(reskinEvent);
            }
            else
            {
                _reskinEventManager.RecordEvent(reskinEvent);

                // In case another plugin blocks the pre-hook, reparent or kill the containers.
                NextTick(_reskinEventManager.CleanupAction);
            }
        }

        private void OnEntityReskinned(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player)
        {
            var transform = snowmobile.transform;
            var reskinEvent = _reskinEventManager.FindEvent(transform.position);
            if (reskinEvent == null)
                return;

            var newVehicleConfig = _config.GetVehicleConfig(snowmobile);
            if (newVehicleConfig?.ContainerPresets == null)
            {
                // New vehicle has no container presets, so kill the containers.
                foreach (var container in reskinEvent.Containers)
                {
                    container.DropItems();
                    container.Kill();
                }

                return;
            }

            foreach (var container in reskinEvent.Containers)
            {
                var containerName = container.name;
                var newContainerPreset = newVehicleConfig.FindContainerPreset(containerName);
                if (newContainerPreset == null || container.PrefabName != newContainerPreset.Prefab)
                {
                    container.DropItems();
                    container.Kill();
                    continue;
                }

                newContainerPreset.MoveContainerToParent(container, snowmobile);
            }

            _reskinEventManager.CompleteEvent(reskinEvent);
        }

        // Compatibility with plugin: Claim Vehicle Ownership
        private void OnVehicleOwnershipChanged(BaseEntity vehicle) => RefreshVehicleStorage(vehicle);

        #endregion

        #region Dependencies

        private bool IsCargoTrain(BaseEntity entity)
        {
            var workcart = entity as TrainEngine;
            if (workcart == null)
                return false;

            var result = CargoTrainEvent?.Call("IsTrainSpecial", workcart.net.ID);
            return result is bool && (bool)result;
        }

        #endregion

        #region API

        private void API_RefreshVehicleStorage(BaseEntity vehicle)
        {
            RefreshVehicleStorage(vehicle);
        }

        #endregion

        #region Exposed Hooks

        private bool AlterStorageWasBlocked(BaseEntity vehicle)
        {
            var hookResult = Interface.CallHook("OnVehicleStorageUpdate", vehicle);
            if (hookResult is bool && (bool)hookResult == false)
                return true;

            if (IsCargoTrain(vehicle))
                return true;

            return false;
        }

        private bool SpawnStorageWasBlocked(BaseEntity vehicle)
        {
            var hookResult = Interface.CallHook("OnVehicleStorageSpawn", vehicle);
            return hookResult is bool && (bool)hookResult == false;
        }

        private void CallHookVehicleStorageSpawned(BaseEntity vehicle, StorageContainer container)
        {
            Interface.CallHook("OnVehicleStorageSpawned", vehicle, container);
        }

        #endregion

        #region Helper Methods

        private void RemoveProblemComponents(BaseEntity entity)
        {
            foreach (var meshCollider in entity.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(meshCollider);
            }

            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private void SetupStorage(BaseEntity vehicle, StorageContainer container, ContainerPreset preset)
        {
            if (container.IsFullySpawned())
            {
                MoveOverlappingDismountPositions(vehicle, container);
            }

            container.name = preset.Name;
            container.pickup.enabled = false;
            container.dropsLoot = true;
            RemoveProblemComponents(container);
        }

        private void MoveOverlappingDismountPositions(BaseEntity vehicle, StorageContainer container)
        {
            var vehicleEntity = vehicle as BaseVehicle;
            if (vehicleEntity == null)
                return;

            var containerTransform = container.transform;
            var containerLocalPosition = containerTransform.localPosition;
            var containerBounds = _containerBoundsManager.GetBounds(container);
            var containerWorldBounds = new OBB(containerTransform.position, containerTransform.lossyScale, containerTransform.rotation, containerBounds);

            foreach (var dismountTransform in vehicleEntity.dismountPositions)
            {
                if (containerWorldBounds.Contains(dismountTransform.position))
                {
                    var newDismountLocalPosition = dismountTransform.localPosition;
                    newDismountLocalPosition.y = containerLocalPosition.y + containerBounds.center.y + containerBounds.extents.y + 0.4f;
                    dismountTransform.localPosition = newDismountLocalPosition;
                }
            }
        }

        private StorageContainer SpawnStorage(BaseEntity vehicle, ContainerPreset preset, int capacity)
        {
            if (SpawnStorageWasBlocked(vehicle))
                return null;

            Vector3 position;
            Quaternion rotation;

            var parentAfterSpawn = vehicle is HotAirBalloon && preset.Prefab == HabStoragePrefab;
            if (parentAfterSpawn)
            {
                var vehicleTransform = vehicle.transform;
                position = vehicleTransform.TransformPoint(preset.Position);
                rotation = vehicleTransform.rotation * preset.Rotation;
            }
            else
            {
                position = preset.Position;
                rotation = preset.Rotation;
            }

            var createdEntity = GameManager.server.CreateEntity(preset.Prefab, position, rotation);
            if (createdEntity == null)
                return null;

            var container = createdEntity as StorageContainer;
            if (container == null)
            {
                UnityEngine.Object.Destroy(createdEntity);
                return null;
            }

            container.name = preset.Name;
            SetupStorage(vehicle, container, preset);
            if (parentAfterSpawn)
            {
                container.Spawn();
                container.SetParent(vehicle, preset.ParentBone, worldPositionStays: true, sendImmediate: true);
            }
            else
            {
                container.SetParent(vehicle, preset.ParentBone);
                container.Spawn();
            }

            MoveOverlappingDismountPositions(vehicle, container);
            MaybeIncreaseCapacity(container, capacity);
            CallHookVehicleStorageSpawned(vehicle, container);

            var deployEffect = preset.Prefab == RhibStoragePrefab
                ? BoxDeployEffectPrefab
                : preset.Prefab == HabStoragePrefab
                ? StashDeployEffectPrefab
                : null;

            if (deployEffect != null)
            {
                Effect.server.Run(deployEffect, container.transform.position);
            }

            return container;
        }

        private StorageContainer FindStorageContainerForPreset(BaseEntity entity, ContainerPreset preset)
        {
            foreach (var child in entity.children)
            {
                var container = child as StorageContainer;
                if (container == null)
                    continue;

                if (container.PrefabName == preset.Prefab
                    && (container.transform.localPosition == preset.Position || container.name == preset.Name))
                    return container;
            }

            return null;
        }

        private void MaybeIncreaseCapacity(StorageContainer container, int capacity)
        {
            container.panelName = ResizableLootPanelName;

            // Don't decrease capacity, in case there are items in those slots.
            // It's possible to handle that better, but not a priority as of writing this.
            if (capacity != -1 && container.inventory.capacity < capacity)
            {
                container.inventory.capacity = capacity;
            }
        }

        private void AddOrUpdateExtraContainers(BaseEntity vehicle, VehicleProfile vehicleProfile)
        {
            foreach (var entry in vehicleProfile.ValidAdditionalStorage)
            {
                var containerPreset = entry.Key;
                var capacity = entry.Value;

                var container = FindStorageContainerForPreset(vehicle, containerPreset);
                if (container == null)
                {
                    SpawnStorage(vehicle, containerPreset, capacity);
                    continue;
                }

                SetupStorage(vehicle, container, containerPreset);
                MaybeIncreaseCapacity(container, capacity);
                var transform = container.transform;
                if (transform.localPosition != containerPreset.Position || transform.localRotation != containerPreset.Rotation)
                {
                    transform.localPosition = containerPreset.Position;
                    transform.localRotation = containerPreset.Rotation;
                    container.InvalidateNetworkCache();
                    container.SendNetworkUpdate_Position();
                }
            }
        }

        private void RefreshVehicleStorage(BaseEntity vehicle, VehicleConfig vehicleConfig)
        {
            var vehicleProfile = vehicleConfig.GetProfileForVehicle(permission, vehicle);
            if (vehicleProfile == null)
            {
                // Probably not a supported vehicle.
                return;
            }

            if (AlterStorageWasBlocked(vehicle))
            {
                // Another plugin blocked altering storage.
                return;
            }

            var defaultContainer = vehicleConfig.GetDefaultContainer(vehicle);
            if (defaultContainer != null)
            {
                MaybeIncreaseCapacity(defaultContainer, vehicleProfile.BuiltInStorageCapacity);
            }

            if (vehicleProfile.ValidAdditionalStorage != null)
            {
                AddOrUpdateExtraContainers(vehicle, vehicleProfile);
            }
        }

        private void RefreshVehicleStorage(BaseEntity vehicle)
        {
            if (vehicle is ModularCar)
            {
                foreach (var child in vehicle.children)
                {
                    var module = child as BaseVehicleModule;
                    if (module != null)
                    {
                        RefreshVehicleStorage(module);
                    }
                }
                return;
            }

            var vehicleConfig = _config.GetVehicleConfig(vehicle);
            if (vehicleConfig == null)
                return;

            RefreshVehicleStorage(vehicle, vehicleConfig);
        }

        private void HandlePermissionChanged(string userIdString = "")
        {
            foreach (var entry in _vehicleTracker.AllSupportedVehicles)
            {
                var vehicleConfig = entry.Key;
                var vehicleList = entry.Value;

                foreach (var vehicle in vehicleList)
                {
                    var ownerId = vehicleConfig.GetOwnerId(vehicle);
                    if (ownerId == 0)
                    {
                        // Unowned vehicles cannot be affected by permissions so there's nothing to do.
                        continue;
                    }

                    if (userIdString != string.Empty && userIdString != vehicle.OwnerID.ToString())
                    {
                        // Permissions changed for a specific player, but they don't own the vehicle, so nothing to do.
                        continue;
                    }

                    RefreshVehicleStorage(vehicle, vehicleConfig);
                }
            }
        }

        #endregion

        #region Container Bounds Manager

        private class ContainerBoundsManager
        {
            private readonly Dictionary<string, string> _boundsReplacements = new Dictionary<string, string>
            {
                // The RHIB storage bounds are small, so use the normal wooden box bounds.
                [RhibStoragePrefab] = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab",
            };

            private readonly Dictionary<uint, Bounds> _boundsReplacementsByPrefabId = new Dictionary<uint, Bounds>();

            public void OnServerInitialized(VehicleStorage plugin)
            {
                foreach (var entry in _boundsReplacements)
                {
                    var destinationEntity = GameManager.server.FindPrefab(entry.Key)?.GetComponent<BaseEntity>();
                    if (destinationEntity == null)
                    {
                        plugin.LogWarning($"Prefab not found: {entry.Key}");
                        continue;
                    }

                    var sourceEntity = GameManager.server.FindPrefab(entry.Value)?.GetComponent<BaseEntity>();
                    if (sourceEntity == null)
                    {
                        plugin.LogWarning($"Prefab not found: {entry.Value}");
                        continue;
                    }

                    _boundsReplacementsByPrefabId[destinationEntity.prefabID] = sourceEntity.bounds;
                }
            }

            public Bounds GetBounds(BaseEntity entity)
            {
                Bounds bounds;
                return _boundsReplacementsByPrefabId.TryGetValue(entity.prefabID, out bounds)
                    ? bounds
                    : entity.bounds;
            }
        }

        #endregion

        #region Supported Vehicle Tracker

        private class VehicleTracker
        {
            public readonly Dictionary<VehicleConfig, HashSet<BaseEntity>> AllSupportedVehicles = new Dictionary<VehicleConfig, HashSet<BaseEntity>>();

            public HashSet<BaseEntity> GetVehicles(VehicleConfig vehicleConfig)
            {
                HashSet<BaseEntity> vehicles;
                return AllSupportedVehicles.TryGetValue(vehicleConfig, out vehicles)
                    ? vehicles
                    : null;
            }

            public void AddVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle)
            {
                var vehicles = GetVehicles(vehicleConfig);
                if (vehicles == null)
                {
                    vehicles = new HashSet<BaseEntity>();
                    AllSupportedVehicles[vehicleConfig] = vehicles;
                }

                vehicles.Add(vehicle);
            }

            public bool RemoveVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle)
            {
                return GetVehicles(vehicleConfig)?.Remove(vehicle) ?? false;
            }
        }

        #endregion

        #region Reskin Manager

        private class ReskinEvent
        {
            public BaseEntity Parent;
            public VehicleConfig VehicleConfig;
            public List<StorageContainer> Containers = new List<StorageContainer>();
            public Vector3 Position;

            public ReskinEvent WithParent(BaseEntity parent)
            {
                Parent = parent;
                Position = parent?.transform.position ?? Vector3.zero;
                return this;
            }

            public ReskinEvent WithVehicleConfig(VehicleConfig vehicleConfig)
            {
                VehicleConfig = vehicleConfig;
                return this;
            }

            public void AddContainer(StorageContainer container)
            {
                Containers.Add(container);
            }

            public void Reset()
            {
                Parent = null;
                Position = Vector3.zero;
                Containers.Clear();
            }
        }

        private class ReskinEventManager
        {
            // Pool only a single reskin event since usually there will be at most a single event per frame.
            private ReskinEvent _pooledReskinEvent;

            // Keep track of all reskin events happening in a frame, in case there are multiple.
            private List<ReskinEvent> _reskinEvents = new List<ReskinEvent>();

            public readonly Action CleanupAction;

            public ReskinEventManager()
            {
                CleanupAction = CleanupEvents;
            }

            public ReskinEvent GetEvent()
            {
                if (_pooledReskinEvent == null)
                {
                    _pooledReskinEvent = new ReskinEvent();
                }

                return ReferenceEquals(_pooledReskinEvent.Parent, null)
                    ? _pooledReskinEvent
                    : new ReskinEvent();
            }

            public void RecordEvent(ReskinEvent reskinEvent)
            {
                _reskinEvents.Add(reskinEvent);
            }

            public void CancelEvent(ReskinEvent reskinEvent)
            {
                reskinEvent.Reset();
            }

            public ReskinEvent FindEvent(Vector3 position)
            {
                foreach (var reskinEvent in _reskinEvents)
                {
                    if (reskinEvent.Position == position)
                        return reskinEvent;
                }

                return null;
            }

            public void CompleteEvent(ReskinEvent reskinEvent)
            {
                reskinEvent.Reset();
                _reskinEvents.Remove(reskinEvent);
            }

            private void CleanupEvents()
            {
                if (_reskinEvents.Count == 0)
                    return;

                foreach (var reskinEvent in _reskinEvents)
                {
                    if (reskinEvent.Parent == null || reskinEvent.Parent.IsDestroyed)
                    {
                        // The post event wasn't called, and the original parent is gone, so kill the containers.
                        foreach (var container in reskinEvent.Containers)
                        {
                            if (container == null || container.IsDestroyed)
                                continue;

                            container.DropItems();
                            container.Kill();
                        }

                        continue;
                    }

                    // The reskin event must have been blocked, so reparent the containers to the original parent.
                    foreach (var container in reskinEvent.Containers)
                    {
                        var containerPreset = reskinEvent.VehicleConfig.FindContainerPreset(container.name);
                        if (containerPreset != null)
                        {
                            containerPreset.MoveContainerToParent(container, reskinEvent.Parent);
                        }
                        else
                        {
                            container.SetParent(reskinEvent.Parent);
                        }
                    }
                }

                _pooledReskinEvent.Reset();
                _reskinEvents.Clear();
            }
        }

        #endregion

        #region Configuration

        private class ContainerPreset
        {
            [JsonProperty("Prefab")]
            public string Prefab;

            [JsonProperty("Position")]
            public Vector3 Position;

            [JsonProperty("RotationAngles", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 RotationAngles;

            [JsonProperty("ParentBone", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ParentBone;

            [JsonIgnore]
            public Quaternion Rotation => Quaternion.Euler(RotationAngles);

            [JsonIgnore]
            public string Name;

            public void MoveContainerToParent(StorageContainer container, BaseEntity parent)
            {
                var transform = container.transform;
                transform.localPosition = Position;
                transform.localRotation = Rotation;

                container.SetParent(parent, ParentBone);
                container.SendNetworkUpdate_Position();
            }
        }

        private class VehicleProfile
        {
            [JsonProperty("PermissionSuffix", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PermissionSuffix;

            [JsonProperty("BuiltInStorageCapacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(-1)]
            public int BuiltInStorageCapacity = -1;

            [JsonProperty("AdditionalStorage", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, int> AdditionalStorage;

            [JsonIgnore]
            public Dictionary<ContainerPreset, int> ValidAdditionalStorage { get; private set; }

            [JsonIgnore]
            public string Permission { get; private set; }

            public void Init(VehicleStorage pluginInstance, VehicleConfig vehicleConfig)
            {
                if (PermissionSuffix != null)
                {
                    Permission = $"{BasePermissionPrefix}.{vehicleConfig.VehicleType}.{PermissionSuffix}";
                    pluginInstance.permission.RegisterPermission(Permission, pluginInstance);
                }

                if (AdditionalStorage != null && AdditionalStorage.Count != 0)
                {
                    ValidAdditionalStorage = new Dictionary<ContainerPreset, int>(AdditionalStorage.Count);

                    foreach (var presetEntry in AdditionalStorage)
                    {
                        var presetName = presetEntry.Key;
                        var capacity = presetEntry.Value;

                        ContainerPreset preset;
                        if (!vehicleConfig.ContainerPresets.TryGetValue(presetName, out preset))
                        {
                            pluginInstance.LogError($"Storage preset {vehicleConfig.VehicleType} -> \"{presetName}\" does not exist.");
                            continue;
                        }

                        if (string.IsNullOrEmpty(preset.Prefab))
                        {
                            pluginInstance.LogError($"Missing prefab for preset {vehicleConfig.VehicleType} -> \"{presetName}\".");
                            continue;
                        }

                        preset.Name = presetName;
                        ValidAdditionalStorage[preset] = capacity;
                    }
                }
            }
        }

        private abstract class VehicleConfig
        {
            [JsonProperty("DefaultProfile")]
            public VehicleProfile DefaultProfile = new VehicleProfile();

            [JsonProperty("ProfilesRequiringPermission")]
            public VehicleProfile[] ProfilesRequiringPermission;

            [JsonProperty("ContainerPresets", DefaultValueHandling = DefaultValueHandling.Ignore, ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, ContainerPreset> ContainerPresets;

            [JsonIgnore]
            public abstract string VehicleType { get; }

            [JsonIgnore]
            public abstract string PrefabPath { get; }

            public virtual StorageContainer GetDefaultContainer(BaseEntity enitty) => null;

            public virtual ulong GetOwnerId(BaseEntity entity) => entity.OwnerID;

            public void Init(VehicleStorage pluginInstance)
            {
                if (ProfilesRequiringPermission == null)
                    return;

                DefaultProfile.Init(pluginInstance, this);

                foreach (var profile in ProfilesRequiringPermission)
                {
                    profile.Init(pluginInstance, this);
                }
            }

            public VehicleProfile GetProfileForVehicle(Permission permissionSystem, BaseEntity vehicle)
            {
                var ownerId = GetOwnerId(vehicle);
                if (ownerId == 0 || (ProfilesRequiringPermission?.Length ?? 0) == 0)
                    return DefaultProfile;

                var ownerIdString = ownerId.ToString();

                for (var i = ProfilesRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var profile = ProfilesRequiringPermission[i];
                    if (profile.Permission != null && permissionSystem.UserHasPermission(ownerIdString, profile.Permission))
                        return profile;
                }

                return DefaultProfile;
            }

            public ContainerPreset FindContainerPreset(string name)
            {
                ContainerPreset preset;
                return ContainerPresets.TryGetValue(name, out preset)
                    ? preset
                    : null;
            }
        }

        private class AttackHelicopterConfig : VehicleConfig
        {
            public override string VehicleType => "attackhelicopter";
            public override string PrefabPath => "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab";
        }

        private class ChinookConfig : VehicleConfig
        {
            public override string VehicleType => "chinook";
            public override string PrefabPath => "assets/prefabs/npc/ch47/ch47.entity.prefab";
        }

        private class DuoSubmarineConfig : SoloSubmarineConfig
        {
            public override string VehicleType => "duosub";
            public override string PrefabPath => "assets/content/vehicles/submarine/submarineduo.entity.prefab";
        }

        private class HotAirBalloonConfig : VehicleConfig
        {
            public override string VehicleType => "hotairballoon";
            public override string PrefabPath => "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as HotAirBalloon)?.storageUnitInstance.Get(serverside: true);
        }

        private class KayakConfig : VehicleConfig
        {
            public override string VehicleType => "kayak";
            public override string PrefabPath => "assets/content/vehicles/boats/kayak/kayak.prefab";
        }

        private class LocomotiveConfig : VehicleConfig
        {
            public override string VehicleType => "locomotive";
            public override string PrefabPath => "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab";
        }

        private class MagnetCraneConfig : VehicleConfig
        {
            public override string VehicleType => "magnetcrane";
            public override string PrefabPath => "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab";
        }

        private class MinicopterConfig : VehicleConfig
        {
            public override string VehicleType => "minicopter";
            public override string PrefabPath => "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        }

        private class ModularCarStorageModuleConfig : VehicleConfig
        {
            public override string VehicleType => "modularcarstorage";
            public override string PrefabPath => "assets/content/vehicles/modularcar/module_entities/1module_storage.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as VehicleModuleStorage)?.GetContainer() as StorageContainer;

            public override ulong GetOwnerId(BaseEntity entity) =>
                (entity as VehicleModuleStorage)?.Vehicle?.OwnerID ?? 0;
        }

        private class ModularCarCamperModuleConfig : VehicleConfig
        {
            public override string VehicleType => "modularcarcamper";
            public override string PrefabPath => "assets/content/vehicles/modularcar/module_entities/2module_camper.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as VehicleModuleCamper)?.activeStorage.Get(serverside: true);

            public override ulong GetOwnerId(BaseEntity entity) =>
                (entity as VehicleModuleCamper)?.Vehicle?.OwnerID ?? 0;
        }

        private class MotorBikeConfig : VehicleConfig
        {
            public override string VehicleType => "motorbike";
            public override string PrefabPath => "assets/content/vehicles/bikes/motorbike.prefab";
        }

        private class MotorBikeSideCarConfig : VehicleConfig
        {
            public override string VehicleType => "motorbike.sidecar";
            public override string PrefabPath => "assets/content/vehicles/bikes/motorbike_sidecar.prefab";
        }

        private class PedalBikeConfig : VehicleConfig
        {
            public override string VehicleType => "pedalbike";
            public override string PrefabPath => "assets/content/vehicles/bikes/pedalbike.prefab";
        }

        private class PedalTrikeConfig : VehicleConfig
        {
            public override string VehicleType => "pedaltrike";
            public override string PrefabPath => "assets/content/vehicles/bikes/pedaltrike.prefab";
        }

        private class RHIBConfig : RowboatConfig
        {
            public override string VehicleType => "rhib";
            public override string PrefabPath => "assets/content/vehicles/boats/rhib/rhib.prefab";
        }

        private class RidableHorseConfig : VehicleConfig
        {
            public override string VehicleType => "ridablehorse";
            public override string PrefabPath => "assets/content/vehicles/horse/ridablehorse2.prefab";
        }

        private class RowboatConfig : VehicleConfig
        {
            public override string VehicleType => "rowboat";
            public override string PrefabPath => "assets/content/vehicles/boats/rowboat/rowboat.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as MotorRowboat)?.storageUnitInstance.Get(serverside: true);
        }

        private class ScrapTransportHelicopterConfig : VehicleConfig
        {
            public override string VehicleType => "scraptransport";
            public override string PrefabPath => "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";
        }

        private class SedanConfig : VehicleConfig
        {
            public override string VehicleType => "sedan";
            public override string PrefabPath => "assets/content/vehicles/sedan_a/sedantest.entity.prefab";
        }

        private class SedanRailConfig : VehicleConfig
        {
            public override string VehicleType => "sedanrail";
            public override string PrefabPath => "assets/content/vehicles/sedan_a/sedanrail.entity.prefab";
        }

        private class SnowmobileConfig : VehicleConfig
        {
            public override string VehicleType => "snowmobile";
            public override string PrefabPath => "assets/content/vehicles/snowmobiles/snowmobile.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as Snowmobile)?.GetItemContainer();
        }

        private class SoloSubmarineConfig : VehicleConfig
        {
            public override string VehicleType => "solosub";
            public override string PrefabPath => "assets/content/vehicles/submarine/submarinesolo.entity.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as BaseSubmarine)?.GetItemContainer();
        }

        private class TomahaConfig : VehicleConfig
        {
            public override string VehicleType => "tomaha";
            public override string PrefabPath => "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab";

            public override StorageContainer GetDefaultContainer(BaseEntity entity) =>
                (entity as Snowmobile)?.GetItemContainer();
        }

        private class WagonAConfig : VehicleConfig
        {
            public override string VehicleType => "wagona";
            public override string PrefabPath => "assets/content/vehicles/trains/wagons/trainwagona.entity.prefab";
        }

        private class WagonBConfig : VehicleConfig
        {
            public override string VehicleType => "wagonb";
            public override string PrefabPath => "assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab";
        }

        private class WagonCConfig : VehicleConfig
        {
            public override string VehicleType => "wagonc";
            public override string PrefabPath => "assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab";
        }

        private class WorkcartConfig : VehicleConfig
        {
            public override string VehicleType => "workcart";
            public override string PrefabPath => "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
        }

        private class WorkcartAbovegroundConfig : VehicleConfig
        {
            public override string VehicleType => "workcartaboveground";
            public override string PrefabPath => "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
        }

        private class WorkcartCoveredConfig : VehicleConfig
        {
            public override string VehicleType => "workcartcovered";
            public override string PrefabPath => "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("AttackHelicopter")]
            public AttackHelicopterConfig AttackHelicopter = new AttackHelicopterConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                        }
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                            ["Right Stash"] = 48,
                        }
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.63f, 1.07f, 0.68f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.63f, 1.07f, 0.68f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                },
            };

            [JsonProperty("Chinook")]
            public ChinookConfig Chinook = new ChinookConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                            ["Front Upper Left Box"] = MaxCapacity,
                            ["Front Upper Right Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-0.91f, 1.259f, 2.845f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Front Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.91f, 1.259f, 2.845f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Front Upper Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-0.91f, 1.806f, 2.845f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Front Upper Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.91f, 1.806f, 2.845f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                },
            };

            [JsonProperty("DuoSubmarine")]
            public DuoSubmarineConfig DuoSubmarine = new DuoSubmarineConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 18,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Stash"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Stash"] = MaxCapacity,
                            ["Back Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 1.56f, 0.55f),
                        RotationAngles = new Vector3(270, 0, 0),
                    },
                    ["Back Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 1.56f, -1.18f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                },
            };

            [JsonProperty("HotAirBalloon")]
            public HotAirBalloonConfig HotAirBalloon = new HotAirBalloonConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 18,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Stash"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "3stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Stash"] = MaxCapacity,
                            ["Front Right Stash"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Stash"] = MaxCapacity,
                            ["Front Right Stash"] = MaxCapacity,
                            ["Back Right Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(1.2f, 0.6f, 1.2f),
                        RotationAngles = new Vector3(330f, 225f, 0),
                    },
                    ["Front Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(1.2f, 0.6f, -1.2f),
                        RotationAngles = new Vector3(330f, 315, 0),
                    },
                    ["Back Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-1.2f, 0.6f, -1.2f),
                        RotationAngles = new Vector3(330f, 45f, 0),
                    },
                },
            };

            [JsonProperty("Kayak")]
            public KayakConfig Kayak = new KayakConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Middle Stash"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                            ["Back Right Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.28f, 0.23f, -1.18f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                    ["Back Middle Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.075f, 0.23f, -1.18f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                    ["Back Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.17f, 0.23f, -1.18f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                },
            };

            [JsonProperty("Locomotive")]
            public LocomotiveConfig Locomotive = new LocomotiveConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.43f, 2.89f, 5.69f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                },
            };

            [JsonProperty("MagnetCrane")]
            public MagnetCraneConfig MagnetCrane = new MagnetCraneConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.78f, -1.445f, 0f),
                        RotationAngles = new Vector3(90, 0, 90),
                        ParentBone = "Top",
                    },
                },
            };

            [JsonProperty("Minicopter")]
            public MinicopterConfig Minicopter = new MinicopterConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Stash Below Pilot Seat"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Stash Below Pilot Seat"] = MaxCapacity,
                            ["Stash Below Front Seat"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "3stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Stash Below Pilot Seat"] = MaxCapacity,
                            ["Stash Below Front Seat"] = MaxCapacity,
                            ["Stash Behind Fuel Tank"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Stash Below Pilot Seat"] = MaxCapacity,
                            ["Stash Below Front Seat"] = MaxCapacity,
                            ["Stash Below Left Seat"] = MaxCapacity,
                            ["Stash Below Right Seat"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Stash Below Pilot Seat"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.01f, 0.33f, 0.21f),
                        RotationAngles = new Vector3(270, 90, 0),
                    },
                    ["Stash Below Front Seat"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.01f, 0.22f, 1.32f),
                        RotationAngles = new Vector3(270, 90, 0),
                    },
                    ["Stash Below Left Seat"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.6f, 0.32f, -0.41f),
                        RotationAngles = new Vector3(270, 0, 0),
                    },
                    ["Stash Below Right Seat"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.6f, 0.32f, -0.41f),
                        RotationAngles = new Vector3(270, 0, 0),
                    },
                    ["Stash Behind Fuel Tank"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 1.025f, -0.63f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Box Below Fuel Tank"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0, 0.31f, -0.57f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Back Middle Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.0f, 0.07f, -1.05f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Back Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-0.48f, 0.07f, -1.05f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Back Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.48f, 0.07f, -1.05f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                },
            };

            [JsonProperty("ModularCarCamperModule")]
            public ModularCarCamperModuleConfig ModularCarCamperModule = new ModularCarCamperModuleConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 12,
                },

                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "3rows",
                        BuiltInStorageCapacity = 18,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                },
            };
            [JsonProperty("MotorBike")]
            public MotorBikeConfig MotorBike = new MotorBikeConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                        }
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                            ["Right Stash"] = 48,
                        }
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.09f, 0.8f, -0.6f),
                        RotationAngles = new Vector3(-7, 265, 0),
                    },
                    ["Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.09f, 0.8f, -0.6f),
                        RotationAngles = new Vector3(-7, 95, 0),
                    },
                },
            };

            [JsonProperty("MotorBikeSideCar")]
            public MotorBikeSideCarConfig MotorBikeSideCar = new MotorBikeSideCarConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                        }
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                            ["Right Stash"] = 48,
                        }
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "3stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                            ["Right Stash"] = 48,
                            ["Back Stash"] = 48
                        }
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.09f, 0.8f, -0.6f),
                        RotationAngles = new Vector3(-7, 265, 0),
                    },
                    ["Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.09f, 0.8f, -0.6f),
                        RotationAngles = new Vector3(-7, 95, 0),
                    },
                    ["Back Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.72f, 0.5f, -0.65f),
                        RotationAngles = new Vector3(185, 0, 90),
                    },
                },
            };

            [JsonProperty("PedalBike")]
            public PedalBikeConfig PedalBike = new PedalBikeConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Stash"] = 48,
                        }
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 0.93f, 0.48f),
                        RotationAngles = new Vector3(0, 0, 0),
                    }
                },
            };

            [JsonProperty("PedalTrike")]
            public PedalTrikeConfig PedalTrike = new PedalTrikeConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                        }
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Left Stash"] = 48,
                            ["Right Stash"] = 48,
                        }
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.28f, 0.67f, -0.7f),
                        RotationAngles = new Vector3(0, 265, 278),
                    },
                    ["Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.28f, 0.67f, -0.7f),
                        RotationAngles = new Vector3(0, -265, -278),
                    },
                },
            };
            [JsonProperty("ModularCarStorageModule")]
            public ModularCarStorageModuleConfig ModularCarStorageModule = new ModularCarStorageModuleConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 48,
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1box",
                        BuiltInStorageCapacity = 48,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Middle Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Middle Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0, 0.61f, 0),
                    },
                },
            };

            [JsonProperty("RHIB")]
            public RHIBConfig RHIB = new RHIBConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 36,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "3boxes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Box"] = MaxCapacity,
                            ["Back Right Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-0.4f, 1.255f, -2.25f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Back Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.4f, 1.255f, -2.25f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                },
            };

            [JsonProperty("RidableHorse")]
            public RidableHorseConfig RidableHorse = new RidableHorseConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                            ["Back Right Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.1f, 0.1f, 0),
                        RotationAngles = new Vector3(270, 285, 0),
                        ParentBone = "L_Hip",
                    },
                    ["Back Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.1f, -0.1f, 0),
                        RotationAngles = new Vector3(90, 105, 0),
                        ParentBone = "R_Hip",
                    },
                },
            };

            [JsonProperty("Rowboat")]
            public RowboatConfig Rowboat = new RowboatConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 18,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.42f, 0.52f, -1.7f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                },
            };

            [JsonProperty("ScrapTransportHelicopter")]
            public ScrapTransportHelicopterConfig ScrapTransportHelicopter = new ScrapTransportHelicopterConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1box",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["LeftBox"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["LeftBox"] = MaxCapacity,
                            ["RightBox"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["LeftBox"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-0.5f, 0.85f, 1.75f),
                    },
                    ["RightBox"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.5f, 0.85f, 1.75f),
                    },
                },
            };

            [JsonProperty("Sedan")]
            public SedanConfig Sedan = new SedanConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Middle Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Middle Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 0.83f, 0.55f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                },
            };

            [JsonProperty("SedanRail")]
            public SedanRailConfig SedanRail = new SedanRailConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Middle Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Middle Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0, 1.065f, -0.21f),
                        RotationAngles = new Vector3(270, 180, 0),
                    },
                },
            };

            [JsonProperty("Snowmobile")]
            public SnowmobileConfig Snowmobile = new SnowmobileConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 12,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "3rows",
                        BuiltInStorageCapacity = 18,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                            ["Back Right Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.21f, 0.555f, -1.08f),
                        RotationAngles = new Vector3(0, 270, 270),
                    },
                    ["Back Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.21f, 0.555f, -1.08f),
                        RotationAngles = new Vector3(0, 90, 90),
                    },
                },
            };

            [JsonProperty("SoloSubmarine")]
            public SoloSubmarineConfig SoloSubmarine = new SoloSubmarineConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 18,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "1stash",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.34f, 1.16f, -0.7f),
                        RotationAngles = new Vector3(300, 270, 270),
                    },
                },
            };

            [JsonProperty("Tomaha")]
            public TomahaConfig Tomaha = new TomahaConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    BuiltInStorageCapacity = 12,
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "3rows",
                        BuiltInStorageCapacity = 18,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4rows",
                        BuiltInStorageCapacity = 24,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "5rows",
                        BuiltInStorageCapacity = 30,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "6rows",
                        BuiltInStorageCapacity = 36,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "7rows",
                        BuiltInStorageCapacity = 42,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "8rows",
                        BuiltInStorageCapacity = 48,
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2stashes",
                        BuiltInStorageCapacity = MaxCapacity,
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Back Left Stash"] = MaxCapacity,
                            ["Back Right Stash"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Back Left Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(-0.21f, 0.37f, -1.08f),
                        RotationAngles = new Vector3(0, 270, 270),
                    },
                    ["Back Right Stash"] = new ContainerPreset
                    {
                        Prefab = HabStoragePrefab,
                        Position = new Vector3(0.21f, 0.37f, -1.08f),
                        RotationAngles = new Vector3(0, 90, 90),
                    },
                },
            };

            [JsonProperty("WagonA")]
            public WagonAConfig WagonA = new WagonAConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                            ["Back Left Box"] = MaxCapacity,
                            ["Back Right Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-1.1f, 1.55f, 1.545f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Front Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(1.10f, 1.55f, 1.545f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Back Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-1.1f, 1.55f, -0.5f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Back Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(1.10f, 1.55f, -0.5f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                },
            };

            [JsonProperty("WagonB")]
            public WagonBConfig WagonB = new WagonBConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Left Box"] = MaxCapacity,
                            ["Front Right Box"] = MaxCapacity,
                            ["Back Left Box"] = MaxCapacity,
                            ["Back Right Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-1.1f, 1.55f, 1.545f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Front Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(1.10f, 1.55f, 1.545f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Back Left Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(-1.1f, 1.55f, -0.5f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Back Right Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(1.10f, 1.55f, -0.5f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                },
            };

            [JsonProperty("WagonC")]
            public WagonCConfig WagonC = new WagonCConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Middle Box 1"] = MaxCapacity,
                            ["Middle Box 2"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "4boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Middle Box 1"] = MaxCapacity,
                            ["Middle Box 2"] = MaxCapacity,
                            ["Middle Box 3"] = MaxCapacity,
                            ["Middle Box 4"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Middle Box 1"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0f, 1.51f, 1.5f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Middle Box 2"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0f, 1.51f, 0.5f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                    ["Middle Box 3"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0f, 1.51f, -0.5f),
                        RotationAngles = new Vector3(0, 90, 0),
                    },
                    ["Middle Box 4"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0f, 1.51f, -1.5f),
                        RotationAngles = new Vector3(0, 270, 0),
                    },
                },
            };

            [JsonProperty("Workcart")]
            public WorkcartConfig Workcart = new WorkcartConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1box",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                            ["Back Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 1.43f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Back Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 0.7f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                },
            };

            [JsonProperty("WorkcartAboveground")]
            public WorkcartAbovegroundConfig WorkcartAboveground = new WorkcartAbovegroundConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1box",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                            ["Back Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 1.43f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Back Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 0.7f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                },
            };

            [JsonProperty("WorkcartCovered")]
            public WorkcartCoveredConfig WorkcartCovered = new WorkcartCoveredConfig
            {
                DefaultProfile = new VehicleProfile
                {
                    AdditionalStorage = new Dictionary<string, int>(),
                },
                ProfilesRequiringPermission = new[]
                {
                    new VehicleProfile
                    {
                        PermissionSuffix = "1box",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                        },
                    },
                    new VehicleProfile
                    {
                        PermissionSuffix = "2boxes",
                        AdditionalStorage = new Dictionary<string, int>
                        {
                            ["Front Box"] = MaxCapacity,
                            ["Back Box"] = MaxCapacity,
                        },
                    },
                },
                ContainerPresets = new Dictionary<string, ContainerPreset>
                {
                    ["Front Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 1f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                    ["Back Box"] = new ContainerPreset
                    {
                        Prefab = RhibStoragePrefab,
                        Position = new Vector3(0.85f, 2.595f, 0.27f),
                        RotationAngles = new Vector3(0, 180, 0),
                    },
                },
            };

            [JsonIgnore]
            private readonly Dictionary<uint, VehicleConfig> _vehicleConfigsByPrefabId = new Dictionary<uint, VehicleConfig>();

            public void Init(VehicleStorage pluginInstance)
            {
                var allVehicleConfigs = new VehicleConfig[]
                {
                    AttackHelicopter,
                    Chinook,
                    DuoSubmarine,
                    HotAirBalloon,
                    Kayak,
                    Locomotive,
                    MagnetCrane,
                    Minicopter,
                    ModularCarCamperModule,
                    ModularCarStorageModule,
                    MotorBike,
                    MotorBikeSideCar,
                    PedalBike,
                    PedalTrike,
                    RHIB,
                    RidableHorse,
                    Rowboat,
                    ScrapTransportHelicopter,
                    Sedan,
                    SedanRail,
                    Snowmobile,
                    SoloSubmarine,
                    Tomaha,
                    WagonA,
                    WagonB,
                    WagonC,
                    Workcart,
                    WorkcartAboveground,
                    WorkcartCovered,
                };

                foreach (var vehicleConfig in allVehicleConfigs)
                {
                    // Map the configs by prefab id for fast lookup.
                    var prefabId = StringPool.Get(vehicleConfig.PrefabPath);
                    _vehicleConfigsByPrefabId[prefabId] = vehicleConfig;

                    // Validate correctness, and register permissions.
                    vehicleConfig.Init(pluginInstance);
                }
            }

            public VehicleConfig GetVehicleConfig(BaseEntity entity)
            {
                VehicleConfig vehicleConfig;
                return _vehicleConfigsByPrefabId.TryGetValue(entity.prefabID, out vehicleConfig)
                    ? vehicleConfig
                    : null;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion
    }
}


// --- End of file: VehicleStorage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/virtual-items ---
// --- Original File Path: V/VirtualItems/VirtualItems.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("Virtual Items", "WhiteThunder", "0.5.1")]
    [Description("Removes resource costs of specific ingredients for crafting and building.")]
    internal class VirtualItems : CovalencePlugin
    {
        #region Fields

        private const string PermissionRulesetPrefix = "virtualitems.ruleset";

        [PluginReference]
        private readonly Plugin ItemRetriever;

        private Configuration _config;
        private readonly RulesetManager _rulesetManager;

        private readonly object True = true;

        public VirtualItems()
        {
            _rulesetManager = new RulesetManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);

            if (!_config.AnyRulesetHasFreeDeployables)
            {
                Unsubscribe(nameof(OnPayForPlacement));
            }
        }

        private void OnServerInitialized()
        {
            if (ItemRetriever == null)
            {
                LogError($"{nameof(ItemRetriever)} is not installed. This plugin will not function until {nameof(ItemRetriever)} loads.");
                return;
            }

            RegisterAsItemSupplier();
            UpdatePlayerInventories();
        }

        private void Unload()
        {
            _rulesetManager.Unload();
            UpdatePlayerInventories();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == nameof(ItemRetriever))
            {
                RegisterAsItemSupplier();
                UpdatePlayerInventories();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _rulesetManager.Remove(player);
        }

        private void OnGroupPermissionGranted(string groupName, string perm)
        {
            if (perm.StartsWith(PermissionRulesetPrefix))
            {
                _rulesetManager.Clear();
            }
        }

        private void OnGroupPermissionRevoked(string groupName, string perm)
        {
            if (perm.StartsWith(PermissionRulesetPrefix))
            {
                _rulesetManager.Clear();
            }
        }

        private void OnUserPermissionGranted(string userId, string perm)
        {
            if (perm.StartsWith(PermissionRulesetPrefix))
            {
                _rulesetManager.Clear();
            }
        }

        private void OnUserPermissionRevoked(string userId, string perm)
        {
            if (perm.StartsWith(PermissionRulesetPrefix))
            {
                _rulesetManager.Clear();
            }
        }

        private object OnPayForPlacement(BasePlayer player, Planner planner)
        {
            if (!planner.isTypeDeployable)
                return null;

            var item = planner.GetItem();
            if (item == null)
                return null;

            var ruleset = _rulesetManager.Get(player);
            if (ruleset == null)
                return null;

            return ruleset.HasFreeDeployable(item)
                ? True
                : null;
        }

        #endregion

        #region Helper Methods

        public static void LogDebug(string message) => Interface.Oxide.LogDebug($"[Virtual Items] {message}");
        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Virtual Items] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Virtual Items] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Virtual Items] {message}");

        private static void SendInventoryUpdate(BasePlayer player)
        {
            player.inventory.SendUpdatedInventory(PlayerInventory.Type.Main, player.inventory.containerMain);
        }

        private static void UpdatePlayerInventories()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.Invoke(() => SendInventoryUpdate(player), UnityEngine.Random.Range(0f, 1f));
            }
        }

        private void RegisterAsItemSupplier()
        {
            ItemRetriever?.Call("API_AddSupplier", this, new Dictionary<string, object>
            {
                ["Priority"] = -10,

                ["SumPlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int>((player, rawItemQuery) =>
                {
                    var ruleset = _rulesetManager.Get(player);
                    if (ruleset == null)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return ruleset.SumItems(ref itemQuery);
                }),

                // For Item Retriever v0.6.5.
                ["TakePlayerItems"] = new Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>((player, rawItemQuery, amount, collect) =>
                {
                    var ruleset = _rulesetManager.Get(player);
                    if (ruleset == null)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    return ruleset.TakeItems(ref itemQuery, amount, collect);
                }),

                // For Item Retriever v0.7.0+.
                ["TakePlayerItemsV2"] = new Func<BasePlayer, Dictionary<string, object>, int, List<Item>, ItemCraftTask, int>((player, rawItemQuery, amount, collect, itemCraftTask) =>
                {
                    var ruleset = _rulesetManager.Get(player);
                    if (ruleset == null)
                        return 0;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    if (itemCraftTask != null)
                    {
                        // Don't actually create items for crafting. Simply return up to the amount allowed.
                        return Math.Min(amount, ruleset.SumItems(ref itemQuery));
                    }

                    return ruleset.TakeItems(ref itemQuery, amount, collect);
                }),

                ["FindPlayerItems"] = new Action<BasePlayer, Dictionary<string, object>, List<Item>>((player, rawItemQuery, collect) =>
                {
                    var ruleset = _rulesetManager.Get(player);
                    if (ruleset == null)
                        return;

                    var itemQuery = ItemQuery.Parse(rawItemQuery);
                    ruleset.FindItems(ref itemQuery, collect);
                }),

                ["SerializeForNetwork"] = new Action<BasePlayer, List<ProtoBuf.Item>>((player, saveList) =>
                {
                    _rulesetManager.Get(player)?.SerializeForNetwork(saveList);
                }),
            });
        }

        #endregion

        #region Item Pool

        private class ItemPool
        {
            private readonly int _itemId;
            private readonly List<Item> _availableItems = new List<Item>();
            private readonly List<Item> _takenItems = new List<Item>();

            public ItemPool(int itemId)
            {
                _itemId = itemId;
            }

            public Item Take()
            {
                ReturnUnusedItems();

                Item item;

                if (_availableItems.Count > 0)
                {
                    item = _availableItems[_availableItems.Count - 1];
                    _availableItems.RemoveAt(_availableItems.Count - 1);
                }
                else
                {
                    item = ItemManager.CreateByItemID(_itemId);
                }

                _takenItems.Add(item);
                return item;
            }

            public void ReturnUnusedItems()
            {
                for (var i = _takenItems.Count - 1; i >= 0; i--)
                {
                    var item = _takenItems[i];
                    if (!IsUnused(item))
                        continue;

                    _takenItems.RemoveAt(i);
                    _availableItems.Add(item);
                }
            }

            public void Unload()
            {
                foreach (var item in _availableItems)
                {
                    item.Remove();
                }

                foreach (var item in _takenItems)
                {
                    if (IsUnused(item))
                    {
                        item.Remove();
                    }
                }
            }

            private bool IsUnused(Item item)
            {
                return item.parent == null && (object)item.GetWorldEntity() == null;
            }
        }

        #endregion

        #region Ruleset Manager

        private class RulesetManager
        {
            private readonly VirtualItems _plugin;
            private readonly Dictionary<ulong, Ruleset> _rulesetByPlayer = new Dictionary<ulong, Ruleset>();

            public RulesetManager(VirtualItems plugin)
            {
                _plugin = plugin;
            }

            public Ruleset Get(BasePlayer player)
            {
                Ruleset ruleset;
                if (!_rulesetByPlayer.TryGetValue(player.userID, out ruleset))
                {
                    ruleset = _plugin._config.DetermineBestRuleset(_plugin.permission, player);
                    _rulesetByPlayer[player.userID] = ruleset;
                }

                return ruleset;
            }

            public void Remove(BasePlayer player)
            {
                _rulesetByPlayer.Remove(player.userID);
            }

            public void Clear()
            {
                _rulesetByPlayer.Clear();
            }

            public void Unload()
            {
                foreach (var ruleset in _rulesetByPlayer.Values)
                {
                    // Ruleset may be cached as null, for players with no assigned ruleset.
                    ruleset?.Unload();
                }
            }
        }

        #endregion

        #region Item Query

        private struct ItemQuery
        {
            public static ItemQuery Parse(Dictionary<string, object> raw)
            {
                var itemQuery = new ItemQuery();

                GetOption(raw, "BlueprintId", out itemQuery.BlueprintId);
                GetOption(raw, "DisplayName", out itemQuery.DisplayName);
                GetOption(raw, "DataInt", out itemQuery.DataInt);
                GetOption(raw, "FlagsContain", out itemQuery.FlagsContain);
                GetOption(raw, "FlagsEqual", out itemQuery.FlagsEqual);
                GetOption(raw, "ItemId", out itemQuery.ItemId);
                GetOption(raw, "SkinId", out itemQuery.SkinId);

                return itemQuery;
            }

            private static void GetOption<T>(Dictionary<string, object> dict, string key, out T result)
            {
                object value;
                result = dict.TryGetValue(key, out value) && value is T
                    ? (T)value
                    : default(T);
            }

            public int? BlueprintId;
            public int? DataInt;
            public string DisplayName;
            public Item.Flag? FlagsContain;
            public Item.Flag? FlagsEqual;
            public int? ItemId;
            public ulong? SkinId;
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class Ruleset
        {
            private class ItemInfo
            {
                public int Amount { get; }
                private ItemDefinition _itemDefinition;
                private ProtoBuf.Item _itemData;

                public ItemInfo(ItemDefinition itemDefinition, int amount)
                {
                    _itemDefinition = itemDefinition;
                    Amount = amount;
                }

                public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
                {
                    if (_itemData == null)
                    {
                        _itemData = new ProtoBuf.Item();
                        _itemData.ShouldPool = false;
                        _itemData.itemid = _itemDefinition.itemid;
                        _itemData.amount = Amount;
                    }

                    saveList.Add(_itemData);
                }

                public Item Create(int amount)
                {
                    return ItemManager.Create(_itemDefinition, amount);
                }
            }

            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("All deployables are free")]
            public bool AllDeployablesFree;

            [JsonProperty("Free deployables")]
            public string[] FreeDeployables = Array.Empty<string>();

            [JsonProperty("Items")]
            public Dictionary<string, int> ItemAmounts = new Dictionary<string, int>();

            [JsonIgnore]
            private HashSet<int> _freeDeployableIds = new HashSet<int>();

            [JsonIgnore]
            private Dictionary<int, ItemInfo> _itemCacheById = new Dictionary<int, ItemInfo>();

            [JsonIgnore]
            private List<ItemInfo> _itemCacheList = new List<ItemInfo>();

            [JsonIgnore]
            private readonly Dictionary<int, ItemPool> _itemPoolByItemId = new Dictionary<int, ItemPool>();

            [JsonIgnore]
            public string Permission { get; private set; }

            [JsonIgnore]
            public bool HasAnyFreeDeployables => AllDeployablesFree || _freeDeployableIds.Count > 0;

            public void Init(VirtualItems plugin)
            {
                if (string.IsNullOrWhiteSpace(Name))
                    return;

                Permission = $"{PermissionRulesetPrefix}.{Name}";
                plugin.permission.RegisterPermission(Permission, plugin);

                foreach (var itemShortName in FreeDeployables)
                {
                    ItemDefinition itemDefinition;
                    if (!VerifyValidItem(itemShortName, out itemDefinition))
                        continue;

                    _freeDeployableIds.Add(itemDefinition.itemid);
                }

                foreach (var itemAmount in ItemAmounts)
                {
                    var itemShortName = itemAmount.Key;
                    var amount = itemAmount.Value;

                    ItemDefinition itemDefinition;
                    if (!VerifyValidItem(itemShortName, out itemDefinition))
                        continue;

                    if (_itemCacheById.ContainsKey(itemDefinition.itemid))
                    {
                        LogWarning($"Duplicate item in ruleset {Name}: {itemShortName}");
                        continue;
                    }

                    var itemInfo = new ItemInfo(itemDefinition, amount);
                    _itemCacheById[itemDefinition.itemid] = itemInfo;
                    _itemCacheList.Add(itemInfo);
                }
            }

            public bool HasFreeDeployable(Item item)
            {
                return AllDeployablesFree || _freeDeployableIds.Contains(item.info.itemid);
            }

            public int SumItems(ref ItemQuery itemQuery)
            {
                return GetItemInfo(ref itemQuery)?.Amount ?? 0;
            }

            public int TakeItems(ref ItemQuery itemQuery, int amount, List<Item> collect)
            {
                var itemInfo = GetItemInfo(ref itemQuery);
                if (itemInfo == null)
                    return 0;

                amount = Math.Min(amount, itemInfo.Amount);
                collect?.Add(itemInfo.Create(amount));
                return amount;
            }

            public void FindItems(ref ItemQuery itemQuery, List<Item> collect)
            {
                // Only support item ids for now since only expecting Rust to call this.
                if (!itemQuery.ItemId.HasValue)
                    return;

                var itemInfo = GetItemInfo(ref itemQuery);
                if (itemInfo == null)
                    return;

                var item = GetItemPool(itemQuery.ItemId.Value).Take();
                item.amount = itemInfo.Amount;
                collect.Add(item);
            }

            public void SerializeForNetwork(List<ProtoBuf.Item> saveList)
            {
                for (var i = 0; i < _itemCacheList.Count; i++)
                {
                    _itemCacheList[i].SerializeForNetwork(saveList);
                }
            }

            public void Unload()
            {
                foreach (var itemPool in _itemPoolByItemId.Values)
                {
                    itemPool.Unload();
                }
            }

            private bool VerifyValidItem(string itemShortName, out ItemDefinition itemDefinition)
            {
                itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                if (itemDefinition != null)
                    return true;

                LogError($"Invalid item short name in config: {itemShortName}");
                return false;
            }

            private ItemInfo GetItemInfo(ref ItemQuery itemQuery)
            {
                // If a plugin is not searching by item id, we can't consider any item a match.
                if (!itemQuery.ItemId.HasValue)
                    return null;

                // If a plugin is searching by other criteria, we can't consider any item a match.
                if (itemQuery.SkinId.HasValue && itemQuery.SkinId.Value != 0)
                    return null;

                if (itemQuery.BlueprintId.HasValue)
                    return null;

                if (itemQuery.DataInt.HasValue && itemQuery.DataInt != 0)
                    return null;

                if (itemQuery.FlagsContain.HasValue && itemQuery.FlagsContain != 0)
                    return null;

                if (itemQuery.FlagsEqual.HasValue && itemQuery.FlagsEqual != 0)
                    return null;

                if (itemQuery.DisplayName != null)
                    return null;

                ItemInfo itemInfo;
                return _itemCacheById.TryGetValue(itemQuery.ItemId.Value, out itemInfo)
                    ? itemInfo
                    : null;
            }

            private ItemPool GetItemPool(int itemId)
            {
                ItemPool itemPool;
                if (!_itemPoolByItemId.TryGetValue(itemId, out itemPool))
                {
                    itemPool = new ItemPool(itemId);
                    _itemPoolByItemId[itemId] = itemPool;
                }

                return itemPool;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Rulesets")]
            private Ruleset[] Rulesets =
            {
                new Ruleset
                {
                    Name = "build",
                    ItemAmounts =
                    {
                        ["metal.fragments"] = 100000,
                        ["metal.refined"] = 100000,
                        ["stones"] = 100000,
                        ["wood"] = 100000,
                    }
                },
                new Ruleset
                {
                    Name = "unlimited_ammo",
                    ItemAmounts =
                    {
                        ["ammo.grenadelauncher.buckshot"] = 100000,
                        ["ammo.grenadelauncher.he"] = 100000,
                        ["ammo.grenadelauncher.smoke"] = 100000,
                        ["ammo.handmade.shell"] = 100000,
                        ["ammo.nailgun.nails"] = 100000,
                        ["ammo.pistol"] = 100000,
                        ["ammo.pistol.fire"] = 100000,
                        ["ammo.pistol.hv"] = 100000,
                        ["ammo.rifle"] = 100000,
                        ["ammo.rifle.explosive"] = 100000,
                        ["ammo.rifle.hv"] = 100000,
                        ["ammo.rifle.incendiary"] = 100000,
                        ["ammo.rocket.basic"] = 100000,
                        ["ammo.rocket.fire"] = 100000,
                        ["ammo.rocket.hv"] = 100000,
                        ["ammo.rocket.smoke"] = 100000,
                        ["ammo.shotgun"] = 100000,
                        ["ammo.shotgun.fire"] = 100000,
                        ["ammo.shotgun.slug"] = 100000,
                        ["arrow.bone"] = 100000,
                        ["arrow.fire"] = 100000,
                        ["arrow.hv"] = 100000,
                        ["arrow.wooden"] = 100000,
                        ["snowball"] = 100000,
                        ["speargun.spear"] = 100000,
                    },
                },
                new Ruleset
                {
                    Name = "craft_most_items",
                    ItemAmounts =
                    {
                        ["bone.fragments"] = 100000,
                        ["can.tuna.empty"] = 100000,
                        ["cloth"] = 100000,
                        ["electric.rf.broadcaster"] = 100000,
                        ["electric.rf.receiver"] = 100000,
                        ["fat.animal"] = 100000,
                        ["gears"] = 100000,
                        ["ladder.wooden.wall"] = 100000,
                        ["leather"] = 100000,
                        ["lowgradefuel"] = 100000,
                        ["metal.fragments"] = 100000,
                        ["metal.refined"] = 100000,
                        ["metalblade"] = 100000,
                        ["metalpipe"] = 100000,
                        ["metalspring"] = 100000,
                        ["propanetank"] = 100000,
                        ["pumpkin"] = 100000,
                        ["riflebody"] = 100000,
                        ["roadsigns"] = 100000,
                        ["rope"] = 100000,
                        ["semibody"] = 100000,
                        ["sewingkit"] = 100000,
                        ["sheetmetal"] = 100000,
                        ["skull.human"] = 100000,
                        ["skull.wolf"] = 100000,
                        ["smgbody"] = 100000,
                        ["spear.wooden"] = 100000,
                        ["stash.small"] = 100000,
                        ["stones"] = 100000,
                        ["syringe.medical"] = 100000,
                        ["targeting.computer"] = 100000,
                        ["tarp"] = 100000,
                        ["wood"] = 100000,
                    }
                },
                new Ruleset
                {
                    Name = "craft_all_items",
                    ItemAmounts =
                    {
                        ["bone.fragments"] = 100000,
                        ["can.tuna.empty"] = 100000,
                        ["cctv.camera"] = 100000,
                        ["charcoal"] = 100000,
                        ["cloth"] = 100000,
                        ["electric.rf.broadcaster"] = 100000,
                        ["electric.rf.receiver"] = 100000,
                        ["explosives"] = 100000,
                        ["fat.animal"] = 100000,
                        ["gears"] = 100000,
                        ["grenade.beancan"] = 100000,
                        ["gunpowder"] = 100000,
                        ["ladder.wooden.wall"] = 100000,
                        ["leather"] = 100000,
                        ["lowgradefuel"] = 100000,
                        ["metal.fragments"] = 100000,
                        ["metal.refined"] = 100000,
                        ["metalblade"] = 100000,
                        ["metalpipe"] = 100000,
                        ["metalspring"] = 100000,
                        ["propanetank"] = 100000,
                        ["pumpkin"] = 100000,
                        ["riflebody"] = 100000,
                        ["roadsigns"] = 100000,
                        ["rope"] = 100000,
                        ["scrap"] = 100000,
                        ["semibody"] = 100000,
                        ["sewingkit"] = 100000,
                        ["sheetmetal"] = 100000,
                        ["skull.human"] = 100000,
                        ["skull.wolf"] = 100000,
                        ["smgbody"] = 100000,
                        ["spear.wooden"] = 100000,
                        ["stash.small"] = 100000,
                        ["stones"] = 100000,
                        ["sulfur"] = 100000,
                        ["syringe.medical"] = 100000,
                        ["targeting.computer"] = 100000,
                        ["tarp"] = 100000,
                        ["techparts"] = 100000,
                        ["wood"] = 100000,
                    }
                },
                new Ruleset
                {
                    Name = "craft_all_items_unlimited_ammo",
                    ItemAmounts =
                    {
                        ["ammo.grenadelauncher.buckshot"] = 100000,
                        ["ammo.grenadelauncher.he"] = 100000,
                        ["ammo.grenadelauncher.smoke"] = 100000,
                        ["ammo.handmade.shell"] = 100000,
                        ["ammo.nailgun.nails"] = 100000,
                        ["ammo.pistol"] = 100000,
                        ["ammo.pistol.fire"] = 100000,
                        ["ammo.pistol.hv"] = 100000,
                        ["ammo.rifle"] = 100000,
                        ["ammo.rifle.explosive"] = 100000,
                        ["ammo.rifle.hv"] = 100000,
                        ["ammo.rifle.incendiary"] = 100000,
                        ["ammo.rocket.basic"] = 100000,
                        ["ammo.rocket.fire"] = 100000,
                        ["ammo.rocket.hv"] = 100000,
                        ["ammo.shotgun"] = 100000,
                        ["ammo.shotgun.fire"] = 100000,
                        ["ammo.shotgun.slug"] = 100000,
                        ["arrow.bone"] = 100000,
                        ["arrow.fire"] = 100000,
                        ["arrow.hv"] = 100000,
                        ["arrow.wooden"] = 100000,
                        ["bone.fragments"] = 100000,
                        ["can.tuna.empty"] = 100000,
                        ["cctv.camera"] = 100000,
                        ["charcoal"] = 100000,
                        ["cloth"] = 100000,
                        ["electric.rf.broadcaster"] = 100000,
                        ["electric.rf.receiver"] = 100000,
                        ["explosives"] = 100000,
                        ["fat.animal"] = 100000,
                        ["gears"] = 100000,
                        ["grenade.beancan"] = 100000,
                        ["gunpowder"] = 100000,
                        ["ladder.wooden.wall"] = 100000,
                        ["leather"] = 100000,
                        ["lowgradefuel"] = 100000,
                        ["metal.fragments"] = 100000,
                        ["metal.refined"] = 100000,
                        ["metalblade"] = 100000,
                        ["metalpipe"] = 100000,
                        ["metalspring"] = 100000,
                        ["propanetank"] = 100000,
                        ["pumpkin"] = 100000,
                        ["riflebody"] = 100000,
                        ["roadsigns"] = 100000,
                        ["rope"] = 100000,
                        ["scrap"] = 100000,
                        ["semibody"] = 100000,
                        ["sewingkit"] = 100000,
                        ["sheetmetal"] = 100000,
                        ["skull.human"] = 100000,
                        ["skull.wolf"] = 100000,
                        ["smgbody"] = 100000,
                        ["snowball"] = 100000,
                        ["spear.wooden"] = 100000,
                        ["speargun.spear"] = 100000,
                        ["stash.small"] = 100000,
                        ["stones"] = 100000,
                        ["sulfur"] = 100000,
                        ["syringe.medical"] = 100000,
                        ["targeting.computer"] = 100000,
                        ["tarp"] = 100000,
                        ["techparts"] = 100000,
                        ["wood"] = 100000,
                    }
                }
            };

            [JsonIgnore]
            public bool AnyRulesetHasFreeDeployables
            {
                get
                {
                    foreach (var ruleset in Rulesets)
                    {
                        if (ruleset.HasAnyFreeDeployables)
                            return true;
                    }

                    return false;
                }
            }

            public void Init(VirtualItems plugin)
            {
                foreach (var ruleset in Rulesets)
                {
                    ruleset.Init(plugin);
                }
            }

            public Ruleset DetermineBestRuleset(Permission permission, BasePlayer player)
            {
                if (Rulesets == null)
                    return null;

                for (var i = Rulesets.Length - 1; i >= 0; i--)
                {
                    var ruleset = Rulesets[i];
                    if (ruleset.Permission != null && permission.UserHasPermission(player.UserIDString, ruleset.Permission))
                        return ruleset;
                }

                return null;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion
    }
}


// --- End of file: VirtualItems.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vanish ---
// --- Original File Path: V/Vanish/Vanish.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;
using Rust.Ai;
using HarmonyLib;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Vanish", "Whispers88", "1.9.2")]
    [Description("Allows players with permission to become invisible")]
    public class Vanish : CovalencePlugin
    {
        private static Vanish? vanish;
        private readonly List<ulong> _hiddenPlayers = new List<ulong>();
        private List<ulong> _hiddenOffline = new List<ulong>();
        private static List<string>? _registeredhooks;
        private static int PlayerLayermask;
        private static DamageTypeList? _EmptyDmgList;
        CuiElementContainer? cachedVanishUI = null;

        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("NoClip on Vanish (runs noclip command)")]
            public bool NoClipOnVanish = true;

            [JsonProperty("Inventory view cmd", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] InvViewCMD = new[] { "inv", "invspy" };

            [JsonProperty("Use OnEntityTakeDamage hook (Set to true to enable use of vanish.damage perm. Set to false for better performance)")]
            public bool UseOnEntityTakeDamage = false;

            [JsonProperty("Use CanUseLockedEntity hook (Allows vanished players with the perm vanish.unlock to bypass locks. Set to false for better performance)")]
            public bool UseCanUseLockedEntity = true;

            [JsonProperty("Automatically vanish players (with the vanish.use perm) on player connect")]
            public bool EnforceOnConnect = true;

            [JsonProperty("Automatically vanish players (with the vanish.use perm) on player disconnect")]
            public bool EnforceOnDisconnect = true;

            [JsonProperty("Keep a vanished player hidden on disconnect")]
            public bool HideOnDisconnect = true;

            [JsonProperty("Teleport a vanished player under the map on disconnect")]
            public bool UnderWorldOnDisconnect = false;

            [JsonProperty("Teleport a vanished player above the map on connect")]
            public bool AboveWorldOnConnect = true;

            [JsonProperty("Bypass violation checks for vanished players")]
            public bool BypassViolation = true;

            [JsonProperty("Turn off fly hack detection for players in vanish")]
            public bool AntiHack = true;

            [JsonProperty("Disable metabolism in vanish")]
            public bool Metabolism = true;

            [JsonProperty("Reset hydration and health on un-vanishing (resets to pre-vanished state)")]
            public bool MetabolismReset = true;

            [JsonProperty("Enable vanishing and reappearing sound effects")]
            public bool EnableSound = true;

            [JsonProperty("Make sound effects public")]
            public bool PublicSound = false;

            [JsonProperty("Enable chat notifications")]
            public bool EnableNotifications = true;

            [JsonProperty("Sound effect to use when vanishing")]
            public string VanishSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Sound effect to use when reappearing")]
            public string ReappearSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Enable GUI")]
            public bool EnableGUI = true;

            [JsonProperty("Icon URL (.png or .jpg)")]
            public string ImageUrlIcon = "https://i.ibb.co/3rZzftx/yL9HNRy.png";

            [JsonProperty("Image Color")]
            public string ImageColor = "1 1 1 0.3";

            [JsonProperty("Image AnchorMin")]
            public string ImageAnchorMin = "0.175 0.017";

            [JsonProperty("Image AnchorMax")]
            public string ImageAnchorMax = "0.22 0.08";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (config.ImageUrlIcon == "http://i.imgur.com/Gr5G3YI.png")
                {
                    config.ImageUrlIcon = "https://i.imgur.com/yL9HNRy.png";
                    config.ImageColor = "1 1 1 0.8";
                    if (config.ImageAnchorMin == "0.175 0.017" && config.ImageAnchorMax == "0.22 0.08")
                    {
                        config.ImageAnchorMin = "0.18 0.017";
                        config.ImageAnchorMax = "0.22 0.09";
                    }
                    LogWarning("Updating image Icon URL");
                    SaveConfig();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        private void Loaded()
        {
            _hiddenOfflineData = Interface.Oxide.DataFileSystem.GetFile("VanishPlayers");
            LoadData();
            InitVanishedPlayers();
        }

        private void InitVanishedPlayers()
        {
            foreach (var playerid in _hiddenOffline)
            {
                BasePlayer player = BasePlayer.FindByID(playerid);
                if (player == null) continue;

                if (IsInvisible(player))
                    continue;

                if (!player.IsConnected)
                {
                    List<Connection> connections = Pool.Get<List<Connection>>();
                    foreach (var con in Net.sv.connections)
                    {
                        if (con.connected && con.isAuthenticated && con.player is BasePlayer && con.player != player)
                            connections.Add(con);
                    }
                    player.OnNetworkSubscribersLeave(connections);
                    player.DisablePlayerCollider();
                    player.syncPosition = false;
                    player.limitNetworking = true;
                    Pool.FreeUnmanaged(ref connections);
                }
                else
                {
                    Disappear(player);
                }
            }
        }
        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VanishCommand"] = "vanish",
                ["Vanished"] = "Vanish: <color=orange> Enabled </color>",
                ["Reappear"] = "Vanish: <color=orange> Disabled </color>",
                ["NoPerms"] = "You do not have permission to do this",
                ["PermanentVanish"] = "You are in a permanent vanish mode",
                ["NoPlayers"] = "No players found using id: {0}"

            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string PermAllow = "vanish.allow";
        private const string PermUnlock = "vanish.unlock";
        private const string PermDamage = "vanish.damage";
        private const string PermVanish = "vanish.permanent";
        private const string PermInvView = "vanish.invviewer";


        private void Init()
        {
            vanish = this;
            cachedVanishUI = CreateVanishUI();
            PlayerLayermask = LayerMask.GetMask(LayerMask.LayerToName((int)Layer.Player_Server));
            _registeredhooks = new List<string> { "CanUseLockedEntity", "OnEntityTakeDamage" };
            _EmptyDmgList = new DamageTypeList();

            // Register universal chat/console commands
            AddLocalizedCommand(nameof(VanishCommand));
            AddCovalenceCommand(config.InvViewCMD, "InventoryViewerCMD");

            // Register permissions for commands
            permission.RegisterPermission(PermAllow, this);
            permission.RegisterPermission(PermUnlock, this);
            permission.RegisterPermission(PermDamage, this);
            permission.RegisterPermission(PermVanish, this);
            permission.RegisterPermission(PermInvView, this);


            //Unsubscribe from hooks
            UnSubscribeFromHooks();

            if (!config.UseOnEntityTakeDamage)
            {
                _registeredhooks.Remove("OnEntityTakeDamage");
            }

            if (!config.BypassViolation)
            {
                _registeredhooks.Remove("OnPlayerViolation");
            }

            if (!config.UseCanUseLockedEntity)
            {
                _registeredhooks.Remove("CanUseLockedEntity");
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!HasPerm(player.UserIDString, PermVanish) || IsInvisible(player)) continue;
                Disappear(player);
            }

        }

        private void Unload()
        {
            for (int i = _hiddenPlayers.Count - 1; i > -1; i--)
            {
                BasePlayer? hiddenPlayer = GetPlayer(_hiddenPlayers[i]);
                if (hiddenPlayer == null) continue;

                if (!_hiddenOffline.Contains(hiddenPlayer.userID))
                    _hiddenOffline.Add(hiddenPlayer.userID);
                Reappear(hiddenPlayer);
            }
            SaveData();
            vanish = null;
            _registeredhooks = null;
            _EmptyDmgList = null;
        }

        private DynamicConfigFile _hiddenOfflineData;

        private void LoadData()
        {
            try
            {
                _hiddenOffline = _hiddenOfflineData.ReadObject<List<ulong>>();
            }
            catch
            {
                _hiddenOffline = new List<ulong>();
            }
            Puts("Load Data");
        }

        private void SaveData()
        {
            _hiddenOfflineData.WriteObject(_hiddenOffline);
        }

        #endregion Initialization

        #region Commands
        private void InventoryViewerCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            if (player == null) return;
            if (!HasPerm(player.UserIDString, PermInvView))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
                return;
            }
            if (args.Length < 1)
            {
                RaycastHit raycastHit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f, PlayerLayermask))
                    return;

                BasePlayer? entity = raycastHit.GetEntity() as BasePlayer;

                if (entity == null)
                {
                    Message(player.IPlayer, "NoPlayers", "NoArgs");
                    return;
                }

                timer.Once(0.3f, () => { StartLootingPlayer(player, entity); });
                return;

            }
            BasePlayer? foundplayer = null;
            if (ulong.TryParse(args[0], out ulong steamID))
            {
                foundplayer = BasePlayer.FindAwakeOrSleepingByID(steamID);
            }
            else
            {
                foreach (var p in BasePlayer.allPlayerList)
                {
                    if (!p.displayName.StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                        continue;

                    foundplayer = p;
                    break;
                }
            }
            if (foundplayer == null)
            {
                Message(player.IPlayer, "NoPlayers", args[0]);
                return;
            }

            timer.Once(0.3f, () => { StartLootingPlayer(player, foundplayer); });
        }

        private void StartLootingPlayer(BasePlayer player, BasePlayer foundplayer)
        {
            if (player == null || foundplayer == null)
                return;
            player.inventory.loot.AddContainer(foundplayer.inventory.containerMain);
            player.inventory.loot.AddContainer(foundplayer.inventory.containerWear);
            player.inventory.loot.AddContainer(foundplayer.inventory.containerBelt);
            player.inventory.loot.entitySource = RelationshipManager.ServerInstance;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.SendImmediate();
            player.ClientRPC<string>(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
        }

        private void VanishCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            if (player == null) return;
            if (!HasPerm(player.UserIDString, PermAllow))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
                return;
            }
            if (HasPerm(player.UserIDString, PermVanish))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "PermanentVanish");
                return;
            }
            if (IsInvisible(player)) Reappear(player);
            else Disappear(player);
        }

        private string drowneffect = "28ad47c8e6d313742a7a2740674a25b5";
        private string falldamageeffect = "ca14ed027d5924003b1c5d9e523a5fce";
        private void Reappear(BasePlayer player)
        {
            if (Interface.CallHook("OnVanishReappear", player) != null) return;

            if (config.AntiHack) player.ResetAntiHack();

            player.syncPosition = true;

            VanishPositionUpdate vanishPositionUpdate;
            if (player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                UnityEngine.Object.Destroy(vanishPositionUpdate);

            SimpleAIMemory.RemoveIgnorePlayer(player);
            BaseEntity.Query.Server.RemovePlayer(player); // have to remove first in case of other plugins
            BaseEntity.Query.Server.AddPlayer(player);

            player._limitedNetworking = false;
            _hiddenPlayers.Remove(player.userID);

            player.EnablePlayerCollider();
            player.UpdateNetworkGroup();
            player.SendNetworkUpdate();
            player.GetHeldEntity()?.SendNetworkUpdate();

            //Un-Mute Player Effects
            player.drownEffect.guid = drowneffect;
            player.fallDamageEffect.guid = falldamageeffect;

            //metabolism
            if (config.Metabolism)
            {
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.radiation_poison.max = 500;
                player.metabolism.oxygen.min = 0;
                player.metabolism.calories.min = 0;
                player.metabolism.wetness.max = 1;
            }

            if (config.MetabolismReset && _storedMetabolism.TryGetValue(player.userID, out MetabolismValues value))
            {
                player.SetHealth(value.health);
                player.metabolism.hydration.SetValue(value.hydration);
                player.metabolism.calories.SetValue(value.calories);
                _storedMetabolism.Remove(player.userID);
            }
            player.metabolism.SendChangesToClient();

            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.ReappearSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.ReappearSoundEffect);
                }
            }

            CuiHelper.DestroyUi(player, "VanishUI");

            if (config.NoClipOnVanish && player.IsFlying) player.SendConsoleCommand(noclip);

            if (config.EnableNotifications) Message(player.IPlayer, "Reappear");
        }

        private class MetabolismValues
        {
            public float health;
            public float hydration;
            public float calories;
        }

        private GameObjectRef _emptygameObject = new GameObjectRef();
        private Dictionary<ulong, MetabolismValues> _storedMetabolism = new Dictionary<ulong, MetabolismValues>();
        private string noclip = "noclip";

        private void Disappear(BasePlayer player)
        {
            if (!_hiddenPlayers.Contains(player.userID))
                _hiddenPlayers.Add(player.userID);

            if (Interface.CallHook("OnVanishDisappear", player) != null) return;

            if (config.AntiHack)
            {
                player.PauseFlyHackDetection(float.MaxValue);
            }

            SimpleAIMemory.AddIgnorePlayer(player);
            BaseEntity.Query.Server.RemovePlayer(player);

            player.syncPosition = false;
            player.limitNetworking = true;
            player.fallDamageEffect = _emptygameObject;
            player.drownEffect = _emptygameObject;
            player.GetHeldEntity()?.SetHeld(false);
            player.DisablePlayerCollider();

            if (config.MetabolismReset)
                _storedMetabolism[player.userID] = new MetabolismValues() { health = player.health, hydration = player.metabolism.hydration.value, calories = player.metabolism.calories.value };

            //metabolism
            if (config.Metabolism)
            {
                player.SetHealth(100f);
                player.metabolism.calories.value = 500;
                player.metabolism.hydration.value = 250;
                player.metabolism.temperature.min = 20;
                player.metabolism.temperature.max = 20;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.wetness.max = 0;
                player.metabolism.calories.min = player.metabolism.calories.value;
                player.metabolism.isDirty = true;
                player.metabolism.SendChangesToClient();
            }

            List<Connection> connections = Pool.Get<List<Connection>>();
            foreach (var con in Net.sv.connections)
            {
                if (con.connected && con.isAuthenticated && con.player is BasePlayer && con.player != player)
                    connections.Add(con);
            }
            player.OnNetworkSubscribersLeave(connections);
            Pool.FreeUnmanaged(ref connections);

            VanishPositionUpdate vanishPositionUpdate;
            if (player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                UnityEngine.Object.Destroy(vanishPositionUpdate);

            player.gameObject.AddComponent<VanishPositionUpdate>();

            if (_hiddenPlayers.Count == 1) SubscribeToHooks();

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.VanishSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.VanishSoundEffect);
                }
            }

            if (config.NoClipOnVanish && !player.IsFlying && !player.isMounted) player.SendConsoleCommand(noclip);

            if (config.EnableGUI)
            {
                CuiHelper.AddUi(player, cachedVanishUI);
            }

            if (config.EnableNotifications) Message(player.IPlayer, "Vanished");
        }

        #endregion Commands

        #region Hooks
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(3f, () => OnPlayerConnected(player));
                return;
            }
            if (config.AboveWorldOnConnect && player._limitedNetworking)
            {
                float terrainY = TerrainMeta.HeightMap.GetHeight(player.transform.position);
                if (player.transform.position.y < terrainY)
                    player.transform.position = new Vector3(player.transform.position.x, terrainY + 0.5f, player.transform.position.z);
            }
            if (_hiddenOffline.Contains(player.userID))
            {
                _hiddenOffline.Remove(player.userID);
                if (HasPerm(player.UserIDString, PermAllow))
                {
                    Disappear(player);
                    return;

                }
            }

            if (HasPerm(player.UserIDString, PermVanish))
            {
                Disappear(player);
                return;
            }

            if (config.EnforceOnConnect && HasPerm(player.UserIDString, PermAllow))
            {
                Disappear(player);
                return;
            }
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (!player.limitNetworking) return null;
            if (HasPerm(player.UserIDString, PermUnlock)) return true;
            if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
            return null;
        }

        private object? OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null)
                return null;

            BasePlayer attacker = info.InitiatorPlayer;
            BasePlayer victim = entity.ToPlayer();
            if (!IsInvisible(victim) && !IsInvisible(attacker)) return null;
            if (attacker == null) return null;
            if (IsInvisible(attacker) && HasPerm(attacker.UserIDString, PermDamage)) return null;
            info.damageTypes = _EmptyDmgList;
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
            info.HitEntity = null;
            return true;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (config.EnforceOnDisconnect && HasPerm(player.UserIDString, PermAllow))
            {
                Disappear(player);
            }

            if (!IsInvisible(player)) return;

            if (!config.HideOnDisconnect && !HasPerm(player.UserIDString, PermVanish))
                Reappear(player);
            else
            {
                if (config.UnderWorldOnDisconnect)
                {
                    float terrainY = TerrainMeta.HeightMap.GetHeight(player.transform.position);
                    if (player.transform.position.y > terrainY)
                        player.transform.position = new Vector3(player.transform.position.x, terrainY - 5f, player.transform.position.z);
                }

                if (!_hiddenOffline.Contains(player.userID))
                    _hiddenOffline.Add(player.userID);

                _hiddenPlayers.Remove(player.userID);
                VanishPositionUpdate t;
                if (player.TryGetComponent<VanishPositionUpdate>(out t))
                    UnityEngine.Object.Destroy(t);
            }
            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();
        }

        private void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            VanishPositionUpdate vanishPositionUpdate;
            if (!player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate)) return;
            UnityEngine.Object.Destroy(vanishPositionUpdate);
        }

        private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            if (!player._limitedNetworking) return;

            VanishPositionUpdate vanishPositionUpdate;
            if (!player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                player.gameObject.AddComponent<VanishPositionUpdate>().EndSpectate();
        }

        private object? OnPlayerColliderEnable(BasePlayer player, CapsuleCollider collider) => IsInvisible(player) ? (object)true : null;

        private object? OnPlayerViolation(BasePlayer player, AntiHackType type, float amount) => IsInvisible(player) ? (object)true : null;

        #endregion Hooks

        #region GUI
        private CuiElementContainer CreateVanishUI()
        {
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = config.ImageAnchorMin, AnchorMax = config.ImageAnchorMax }
            }, "Hud.Menu", "VanishUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent {Color = config.ImageColor, Url = config.ImageUrlIcon},
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });
            return elements;
        }

        #endregion GUI

        #region Monobehaviour
        public class VanishPositionUpdate : FacepunchBehaviour
        {
            private BasePlayer player;
            private static int Layermask = LayerMask.GetMask(LayerMask.LayerToName((int)Layer.Construction), LayerMask.LayerToName((int)Layer.Deployed), LayerMask.LayerToName((int)Layer.Vehicle_World), LayerMask.LayerToName((int)Layer.Player_Server));
            LootableCorpse corpse;
            GameObject child;
            SphereCollider col;
            int LayerReserved1 = (int)Layer.Reserved1;
            BUTTON _reload = BUTTON.RELOAD;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                player.transform.localScale = Vector3.zero;
                CreateChildGO();
            }

            private void FixedUpdate()
            {
                if (player == null || !player.serverInput.IsDown(_reload) || !player.serverInput.WasDown(_reload)) return;
                player.serverInput.previous.buttons = 0;

                RaycastHit raycastHit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f, Layermask))
                    return;

                BaseEntity entity = raycastHit.GetEntity() as BaseEntity;

                if (entity == null) return;

                if (entity is StorageContainer container)
                {
                    player.inventory.loot.Clear();
                    player.inventory.loot.AddContainer(container.inventory);
                    player.inventory.loot.entitySource = RelationshipManager.ServerInstance;
                    player.inventory.loot.PositionChecks = false;
                    player.inventory.loot.MarkDirty();
                    player.SendNetworkUpdateImmediate();
                    player.ClientRPC<string>(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
                    return;
                }

                if (entity is BasePlayer targetplayer)
                {
                    if (!vanish.HasPerm(player.UserIDString, PermInvView))
                        return;

                    player.inventory.loot.AddContainer(targetplayer.inventory.containerMain);
                    player.inventory.loot.AddContainer(targetplayer.inventory.containerWear);
                    player.inventory.loot.AddContainer(targetplayer.inventory.containerBelt);
                    player.inventory.loot.entitySource = RelationshipManager.ServerInstance;
                    player.inventory.loot.PositionChecks = false;
                    player.inventory.loot.MarkDirty();
                    player.inventory.loot.SendImmediate();
                    player.ClientRPC<string>(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
                    return;
                }

                if (entity is Door door)
                {
                    if (door.IsOpen())
                    {
                        door.SetOpen(false, true);
                    }
                    else
                    {
                        door.SetOpen(true, false);
                    }
                    return;
                }

                BaseMountable component = entity.GetComponent<BaseMountable>();
                if (component == null)
                    return;
                component.AttemptMount(player, true);

            }

            private void UpdatePos()
            {
                if (player == null)
                    return;

                player.net.UpdateGroups(player.transform.position);
            }

            void OnTriggerEnter(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent != null)
                {
                    triggerParent.OnTriggerEnter(player.playerCollider);
                    return;
                }
                TriggerWorkbench triggerWorkbench = col.GetComponentInParent<TriggerWorkbench>();
                if (triggerWorkbench == null)
                    return;

                player.EnterTrigger(triggerWorkbench);
                player.nextCheckTime = float.MaxValue;
                player.cachedCraftLevel = triggerWorkbench.parentBench.Workbenchlevel;

                switch (player.cachedCraftLevel)
                {
                    case 1:
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, true); break;
                    case 2:
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, true); break;
                    case 3:
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, true); break;
                }
            }

            void OnTriggerExit(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent != null)
                {
                    triggerParent.OnTriggerExit(player.playerCollider);
                    return;
                }
                TriggerWorkbench triggerWorkbench = col.GetComponentInParent<TriggerWorkbench>();
                if (triggerWorkbench != null)
                {
                    player.LeaveTrigger(triggerWorkbench);
                    player.cachedCraftLevel = 0f;
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, false);
                    player.nextCheckTime = Time.realtimeSinceStartup;
                    return;
                }
            }

            public void EndSpectate()
            {
                InvokeRepeating(RespawnCheck, 1f, 0.5f);
            }

            public void RespawnCheck()
            {
                if (player == null || !player.IsAlive()) return;
                CancelInvoke(RespawnCheck);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.SendNetworkUpdateImmediate();
                CreateChildGO();
            }

            public void CreateChildGO()
            {
                if (player == null || player.IsSpectating())
                    return;

                player.transform.localScale = Vector3.zero;
                child = gameObject.CreateChild();
                col = child.AddComponent<SphereCollider>();
                child.layer = LayerReserved1;
                child.transform.localScale = Vector3.zero;
                col.isTrigger = true;
                player.lastAdminCheatTime = float.MaxValue;
                InvokeRepeating("UpdatePos", 1f, 5f);
            }

            private void OnDestroy()
            {
                CancelInvoke(UpdatePos);

                if (player != null)
                {
                    if (player.IsConnected)
                        player.Connection.active = true;

                    player.lastAdminCheatTime = Time.realtimeSinceStartup;
                    player.transform.localScale = new Vector3(1, 1, 1);

                    //Reset Triggers
                    if (player.triggers != null)
                    {
                        for (int i = player.triggers.Count - 1; i >= 0; i--)
                        {
                            if (player.triggers[i] is TriggerWorkbench)
                            {
                                player.triggers[i].OnEntityLeave(player);
                                player.triggers.RemoveAt(i);
                            }
                        }
                    }

                    //Reset Workbench Level
                    player.cachedCraftLevel = 0f;
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, false);
                    player.nextCheckTime = Time.realtimeSinceStartup;
                }

                if (col != null)
                    Destroy(col);
                if (child != null)
                    Destroy(child);

                GameObject.Destroy(this);
            }

        }

        #endregion Monobehaviour

        #region Helpers
        private BasePlayer? GetPlayer(ulong steamID)
        {
            foreach (var player in BasePlayer.allPlayerList)
            {
                if (player.userID.Get() != steamID)
                    continue;

                return player;
            }
            return null;
        }
        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool IsInvisible(BasePlayer player) => player?._limitedNetworking ?? false;

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in _registeredhooks)
                Unsubscribe(hook);
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in _registeredhooks)
                Subscribe(hook);

        }

        private static void SendEffect(BasePlayer player, string sound) => EffectNetwork.Send(new Effect(sound, player, 0, Vector3.zero, Vector3.forward), player.net.connection);


        #endregion Helpers

        #region Public Helpers
        public void _Disappear(BasePlayer basePlayer) => Disappear(basePlayer);
        public void _Reappear(BasePlayer basePlayer) => Reappear(basePlayer);
        public bool _IsInvisible(BasePlayer basePlayer) => IsInvisible(basePlayer);
        #endregion

        #region Harmony
        //Used for OcclusionPlayerFound
        [HarmonyPatch(typeof(BasePlayer), "OcclusionPlayerFound"), AutoPatch]
        private static class BasePlayer_OcclusionPlayerFound_Patch
        {
            [HarmonyPrefix]
            private static bool Prefix(BasePlayer player1, BasePlayer player2, bool cache)
            {
                if (player2._limitedNetworking)
                {
                    return false;
                }
                return true;
            }
        }
        #endregion Harmony
    }
}

// --- End of file: Vanish.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/visual-cupboard-radius ---
// --- Original File Path: V/VisualCupboard/VisualCupboard.cs ---

using System;
using Oxide.Core;
using UnityEngine;
using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("VisualCupboard", "Colon Blow", "1.0.12")]
    class VisualCupboard : RustPlugin
    {

        #region Loadup

        private void OnServerInitialized() { serverInitialized = true; }

        private void Loaded()
        {
            LoadVariables();
            serverInitialized = true;
            lang.RegisterMessages(messages, this);
            permission.RegisterPermission("visualcupboard.allowed", this);
            permission.RegisterPermission("visualcupboard.admin", this);
        }

        private void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private Dictionary<string, string> messages = new Dictionary<string, string>()
            {
            {"notallowed", "You are not allowed to access that command." }
            };

        #endregion

        #region Configuration

        private bool Changed;
        private static float UseCupboardRadius = 25f;
        private float DurationToShowRadius = 60f;
        private float ShowCupboardsWithinRangeOf = 50f;
        private int VisualDarkness = 5;

        private static bool serverInitialized = false;

        private void LoadConfigVariables()
        {
            CheckCfgFloat("My Cupboard Radius is (25 is default)", ref UseCupboardRadius);
            CheckCfgFloat("Show Visuals On Cupboards Withing Range Of", ref ShowCupboardsWithinRangeOf);
            CheckCfgFloat("Show Visuals For This Long", ref DurationToShowRadius);
            CheckCfg("How Dark to make Visual Cupboard", ref VisualDarkness);
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Sphere Entity

        private class ToolCupboardSphere : MonoBehaviour
        {
            private BaseEntity sphere;
            private BaseEntity entity;
            public bool showall;
            private Vector3 pos = new Vector3(0, 0, 0);
            private Quaternion rot = new Quaternion();
            private string strPrefab = "assets/prefabs/visualization/sphere.prefab";

            private void Awake()
            {
                SpawnSphere();
            }

            private void SpawnSphere()
            {
                entity = GetComponent<BaseEntity>();
                sphere = GameManager.server.CreateEntity(strPrefab, pos, rot, true);
                SphereEntity ball = sphere.GetComponent<SphereEntity>();
                ball.OwnerID = entity.OwnerID;
                ball.currentRadius = 1f;
                ball.lerpRadius = 2.0f * UseCupboardRadius;
                ball.lerpSpeed = 100f;
                showall = false;
                sphere.SetParent(entity);
                sphere.Spawn();
            }

            private void OnDestroy()
            {
                if (sphere == null) return;
                sphere.Kill(BaseNetworkable.DestroyMode.None);
            }

        }

        #endregion

        #region Hooks

        private object CanNetworkTo(SphereEntity sphereEntity, BasePlayer target)
        {
            var sphereobj = sphereEntity.GetComponentInParent<ToolCupboardSphere>();
            if (sphereobj == null) return null;
            if (sphereobj != null && sphereobj.showall == false)

            {
                if (target.userID != sphereEntity.OwnerID) return false;
            }
            return null;
        }

        #endregion

        #region Commands

        [ChatCommand("showsphere")]
        private void cmdChatShowSphere(BasePlayer player, string command)
        {
            AddSphere(player, false, false);
        }

        [ChatCommand("showsphereall")]
        private void cmdChatShowSphereAll(BasePlayer player, string command)
        {
            AddSphere(player, true, false);
        }

        [ChatCommand("showsphereadmin")]
        private void cmdChatShowSphereAdmin(BasePlayer player, string command)
        {
            if (isAllowed(player, "visualcupboard.admin"))
            {
                AddSphere(player, true, true);
                return;
            }
            else if (!isAllowed(player, "visualcupboard.admin"))
            {
                SendReply(player, lang.GetMessage("notallowed", this));
                return;
            }
        }

        [ChatCommand("killsphere")]
        private void cmdChatDestroySphere(BasePlayer player, string command)
        {
            if (isAllowed(player, "visualcupboard.admin"))
            {
                DestroyAll<ToolCupboardSphere>();
                return;
            }
            else if (!isAllowed(player, "visualcupboard.admin"))
            {
                SendReply(player, lang.GetMessage("notallowed", this));
                return;
            }
        }

        #endregion

        #region Helpers

        private void AddSphere(BasePlayer player, bool showall, bool adminshow)
        {
            if (isAllowed(player, "visualcupboard.allowed") || isAllowed(player, "visualcupboard.admin"))
            {
                List<BaseCombatEntity> cblist = new List<BaseCombatEntity>();
                Vis.Entities<BaseCombatEntity>(player.transform.position, ShowCupboardsWithinRangeOf, cblist);

                foreach (BaseCombatEntity bp in cblist)
                {
                    if (bp is BuildingPrivlidge)
                    {
                        if (bp.GetComponent<ToolCupboardSphere>() == null)
                        {
                            Vector3 pos = bp.transform.position;

                            if (!adminshow)
                            {
                                if (player.userID == bp.OwnerID)
                                {
                                    for (int i = 0; i < VisualDarkness; i++)
                                    {
                                        var sphereobj = bp.gameObject.AddComponent<ToolCupboardSphere>();
                                        if (showall) sphereobj.showall = true;
                                        GameManager.Destroy(sphereobj, DurationToShowRadius);
                                    }
                                }

                            }
                            if (adminshow)
                            {
                                for (int i = 0; i < VisualDarkness; i++)
                                {
                                    var sphereobj = bp.gameObject.AddComponent<ToolCupboardSphere>();
                                    sphereobj.showall = true;
                                    GameManager.Destroy(sphereobj, DurationToShowRadius);
                                }
                                player.SendConsoleCommand("ddraw.text", 10f, Color.red, pos + Vector3.up, FindPlayerName(bp.OwnerID));
                                PrintWarning("Tool Cupboard Owner " + bp.OwnerID + " : " + FindPlayerName(bp.OwnerID));
                            }
                        }
                    }
                }
                return;
            }
            SendReply(player, lang.GetMessage("notallowed", this));
            return;
        }

        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player)
                return player.displayName;

            player = BasePlayer.FindSleeping(userId);
            if (player)
                return player.displayName;

            var iplayer = covalence.Players.FindPlayer(userId.ToString());
            if (iplayer != null)
                return iplayer.Name;

            return "Unknown Entity Owner";
        }

        private void Unload()
        {
            DestroyAll<ToolCupboardSphere>();
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        private bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion
    }
}

// --- End of file: VisualCupboard.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/voice-mute ---
// --- Original File Path: V/VoiceMute/VoiceMute.cs ---

﻿using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Voice Mute", "Tori1157", "1.0.3")]
    [Description("Voice mute via commands with time and reason")]

    class VoiceMute : CovalencePlugin
    {
        #region Fields

        private const string permMute = "voicemute.mute";
        private const string permList = "voicemute.list";
        private const string permInfo = "voicemute.info";
        private const string permUnmute = "voicemute.unmute";
        private const string permCheckInfo = "voicemute.checkinfo";
        private const string mData = "Mutes";

        private bool Changed;
        private bool addReason;
        private bool broadcastMessage;
        private bool hasExpired = false;

        private DataFileSystem MuteData;

        #endregion Fields

        #region Initialization & Loading

        private void LoadVariables()
        {
            MuteData = new DataFileSystem($"{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}VoiceMute");

            Mute = new MuteManager();

            addReason = BoolConfig("General Settings", "Replace Existing Reason", true);
            broadcastMessage = BoolConfig("General Settings", "Broadcast Mutes", true);

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new config file");
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help Message"] = "There are shortened versions of the commands.\n\n- [#add8e6]Mute[/#] -> M\n- [#add8e6]Unmute[/#] -> UM\n- [#add8e6]List[/#] -> L\n- [#add8e6]Info[/#] -> I\n\n- [#orange]/voice[/#] [i](Displays this message)[/i]\n- [#orange]/voice mute[/#] [#add8e6]<\"user name\" | SteamID64> <time: 1d1h1m1s> <\"optional reason\">[/#] [i](Voice-mutes a player within specified time)[/i]\n- [#orange]/voice unmute[/#] [#add8e6]<\"user name\" | SteamID64>[/#] [i](Voice-unmute's a player)[/i]\n- [#orange]/voice list[/#] [i](Displays all voice-mutes)[/i]\n- [#orange]/voice info[/#] [i](Displays your mute info)[/i]\n- [#orange]/voice info[/#] [#add8e6]<\"user name\" | SteamID64>[/#] [i](Displays targeted player's mute info)[/i]",
                ["You Are Muted"] = "You are currently [#lightblue]voice-muted[/#], no one can hear you.",
                ["Mute Info"] = "[#lightblue]Muted Name[/#]: {0}\n[#lightblue]Muter Name[/#]: {1}\n[#lightblue]Mute Reason[/#]: {2}\n[#lightblue]Mute Time Left[/#]: {3}",

                ["Broadcast Mute Message"] = "[#lightblue]{0}[/#] has been voice-muted by [#lightblue]{1}[/#] for [#lightblue]{2}[/#]{3}",
                ["Broadcast Unmute Message"] = "[#lightblue]{0}[/#] has been voice-unmuted.",
                ["Player Muted"] = "You have voice-muted [#lightblue]{0}[/#] for [#lightblue]{1}[/#][#lightblue]{2}[/#].",
                ["Target Muted"] = "You have been voice-muted by [#lightblue]{0}[/#] for [#lightblue]{1}[/#][#lightblue]{2}[/#].",
                ["Player Unmuted"] = "You have voice-unmuted [#lightblue]{0}[/#].",
                ["Target Unmuted"] = "You have been voice-unmuted.",
                ["No Mutes"] = "There are currently no voice-muted players.",
                ["Not Muted"] = "[#lightblue]{0}[/#] is not voice-muted.",
                ["You Not Muted"] = "You're currently not voice-muted.",

                ["No Permission"] = "You do not have permission to use the '[#lightblue]{0}[/#]' command.",
                ["SteamID Not Found"] = "Could not find this SteamID: [#lightblue]{0}[/#].",
                ["Player Not Found"] = "Could not find this player: [#lightblue]{0}[/#].",
                ["Multiple Players Found"] = "Found multiple players!\n\n{0}",

                ["Invalid Parameter"] = "'[#lightblue]{0}[/#]' is an invalid parameter, do [#orange]/voice[/#] for more information.",
                ["Invalid Syntax Mute"] = "Invalid Syntax! | /voice mute <\"user name\" | SteamID64> <time: 1d1h1m1s> <\"optional reason\">",
                ["Invalid Syntax Unmute"] = "Invalid Syntax! | /voice unmute <\"user name\" | SteamID64>",

                ["Because"] = "because",

                ["Prefix Help"] = "Voice Mute Help",
                ["Prefix Info"] = "Voice Mute Info",
                ["Prefix List"] = "Voice Mute List",
            }, this);
        }

        private void Init()
        {
            LoadVariables();
            LoadStoredData();

            permission.RegisterPermission(permMute, this);
            permission.RegisterPermission(permList, this);
            permission.RegisterPermission(permUnmute, this);
        }

        private void OnServerInitialized()
        {
            CheckMutes();
        }

        #endregion Initialization & Loading

        #region Commands

        [Command("voice")]
        private void VoiceCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendInfoMessage(player, Lang("Prefix Help", player.Id), $"[+13]{Lang("Help Message", player.Id)}[/+]");
                return;
            }

            var CommandArg = args[0].ToLower();
            var CaseArgs = (new List<object>
            {
                "mute", "m", "unmute", "um", "list", "l", "info", "i"
            });

            if (!CaseArgs.Contains(CommandArg))
            {
                SendChatMessage(player, Lang("Invalid Parameter", player.Id, CommandArg));
                return;
            }

            switch (CommandArg)
            {
                case "m":
                case "mute":
                    MutePlayer(player, command, args);
                    return;
                case "um":
                case "unmute":
                    UnmutePlayer(player, command, args);
                    return;
                case "l":
                case "list":
                    ListMutes(player, command, args);
                    return;
                case "i":
                case "info":
                    InfoMute(player, command, args);
                    return;
            }
        }

        #endregion Commands

        #region Functions

        private bool CanMute(IPlayer player) => player.HasPermission(permMute);
        private bool CanList(IPlayer player) => player.HasPermission(permList);
        private bool CanInfo(IPlayer player) => player.HasPermission(permInfo);
        private bool CanUnmute(IPlayer player) => player.HasPermission(permUnmute);
        private bool CanCheckInfo(IPlayer player) => player.HasPermission(permCheckInfo);

        private void OnUserConnected(IPlayer player)
        {
            var BPlayer = player.Object as BasePlayer;

            if (Mute.MuteExists(player) && !BPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
                BPlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, true);

            if (!Mute.MuteExists(player) && BPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
                BPlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);
        }

        private void OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (Mute.MuteExists(player.IPlayer) && !Mute.MessageSent(player.UserIDString))
            {
                SendChatMessage(player.IPlayer, Lang("You Are Muted", player.UserIDString));

                // Not saving, so we don't have to change it on unload.
                Mute.SetMessageSent(player.UserIDString, true);
                timer.Once(30f, () => { Mute.SetMessageSent(player.UserIDString, false); });
            }
        }

        private void MutePlayer(IPlayer player, string command, string[] args)
        {
            var CommandInfo = $"{command} {args[0].ToLower()}";

            BasePlayer BPlayer = player.Object as BasePlayer;
            // /voice mute Tori1157 1d1h1m1s "Testing stuff"

            if (!CanMute(player) && !player.IsServer)
            {
                SendChatMessage(player, Lang("No Permission", player.Id, CommandInfo));
                return;
            }

            if (args.Length < 3)
            {
                SendChatMessage(player, Lang("Invalid Syntax Mute", player.Id));
                return;
            }

            TimeSpan timeSpan;

            if (!TryParseTimeSpan(args[2], out timeSpan))
            {
                SendChatMessage(player, Lang("Invalid Time Span", player.Id));
                return;
            }

            IPlayer target = GetPlayer(args[1], player);

            if (target == null)
                return;

            var TBPlayer = target.Object as BasePlayer;

            string reason = (args.Length < 4 ? null : args[3]);

            Mute.AddMute(target, player.Name, DateTime.UtcNow + timeSpan, reason, !addReason);
            SaveMutes();
            TBPlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, true);

            if (broadcastMessage)
                SendBroadcastMessage(Lang("Broadcast Mute Message", player.Id, target.Name, player.Name, FormatTime(timeSpan), $" {Lang("Because", player.Id)} [#lightblue]{reason}[/#]"));
            else
            {
                SendChatMessage(player, Lang("Player Muted", player.Id, target.Name, FormatTime(timeSpan), reason));
                SendChatMessage(target, Lang("Target Muted", target.Id, player.Name, FormatTime(timeSpan), reason));
            }
        }

        private void UnmutePlayer(IPlayer player, string command, string[] args)
        {
            var CommandInfo = $"{command} {args[0].ToLower()}";

            BasePlayer BPlayer = player.Object as BasePlayer;
            // /voice unmute Tori1157

            if (!CanUnmute(player) && !player.IsServer)
            {
                SendChatMessage(player, Lang("No Permission", player.Id, CommandInfo));
                return;
            }

            if (args.Length < 2)
            {
                SendChatMessage(player, Lang("Invalid Syntax Unmute", player.Id));
                return;
            }

            IPlayer target = GetPlayer(args[1], player);

            if (target == null)
                return;

            var TBPlayer = target.Object as BasePlayer;

            if (!Mute.MuteExists(target))
            {
                SendChatMessage(player, Lang("Not Muted", player.Id, target.Name));
                return;
            }

            Mute.RemoveMute(target);
            SaveMutes();
            TBPlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);

            if (broadcastMessage)
                SendBroadcastMessage(Lang("Broadcast Unmute Message", player.Id, target.Name));
            else
            {
                SendChatMessage(player, Lang("Player Unmuted", player.Id, target.Name));
                SendChatMessage(target, Lang("Target Unmuted", target.Id));
            }
        }

        private void ListMutes(IPlayer player, string command, string[] args)
        {
            var CommandInfo = $"{command} {args[0].ToLower()}";
            // /voice list

            if (!CanList(player) && !player.IsServer)
            {
                SendChatMessage(player, Lang("No Permission", player.Id, CommandInfo));
                return;
            }

            if (Mutes.Count == 0)
            {
                SendChatMessage(player, Lang("No Mutes", player.Id));
                return;
            }

            var mutes = string.Join(Environment.NewLine, Mutes.Select(kvp => $"- [#add8e6]{Mutes[kvp.Key].PlayerName}[/#]: {FormatTime(kvp.Value.ExpireDate - DateTime.UtcNow)}").ToArray());

            SendInfoMessage(player, Lang("Prefix List", player.Id), mutes);
        }

        private void InfoMute(IPlayer player, string command, string[] args)
        {
            var CommandInfo = $"{command} {args[0].ToLower()}";
            // /voice info
            // /voice info tori

            if (args.Length == 2)
            {
                if (!CanCheckInfo(player) && !player.IsServer)
                {
                    SendChatMessage(player, Lang("No Permission", player.Id, CommandInfo));
                    return;
                }

                IPlayer target = GetPlayer(args[1], player);

                if (target == null)
                    return;

                if (!Mute.MuteExists(player))
                {
                    SendChatMessage(player, Lang("Not Muted", player.Id, target.Name));
                    return;
                }

                SendInfoMessage(player, Lang("Prefix Info", player.Id), Lang("Mute Info", player.Id, Mute.GetPlayerName(target), Mute.GetAdmin(target), Mute.GetReason(target), FormatTime((DateTime)Mute.GetExpireDate(target) - DateTime.UtcNow)));
            }

            if (!Mute.MuteExists(player))
            {
                SendChatMessage(player, Lang("You Not Muted", player.Id));
                return;
            }

            SendInfoMessage(player, Lang("Prefix Info", player.Id), Lang("Mute Info", player.Id, Mute.GetPlayerName(player), Mute.GetAdmin(player), Mute.GetReason(player), FormatTime((DateTime)Mute.GetExpireDate(player) - DateTime.UtcNow)));
        }

        #endregion Functions

        #region Time

        // Credit to LaserHydra for this code
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace($"{seconds}s", string.Empty);
            source = source.Replace($"{minutes}m", string.Empty);
            source = source.Replace($"{hours}h", string.Empty);
            source = source.Replace($"{days}d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }
        // End credit for LaserHydra

        private void CheckMutes()
        {
            timer.Repeat(10, 0, () =>
            {
                List<string> expired = Mutes.Where(m => m.Value.Expired).Select(m => m.Key).ToList();

                foreach (string id in expired)
                {
                    IPlayer player = players.FindPlayerById(id);
                    var BPlayer = player.Object as BasePlayer;

                    if (player != null)
                    {
                        if (Mute.IsExpired(id))
                        {
                            if (broadcastMessage)
                                SendBroadcastMessage(Lang("Broadcast Unmute Message", null, player.Name));
                            else
                                SendChatMessage(player, Lang("Target Unmuted", player.Id));

                            Mute.RemoveMute(id);
                            SaveMutes();

                            if (BPlayer != null)
                                BPlayer.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);
                        }
                    }

                    if (!hasExpired)
                        hasExpired = true;
                }

                if (hasExpired)
                {
                    SaveMutes();
                    hasExpired = false;
                }
            });
        }

        #endregion Time

        #region Data

        MuteManager Mute;

        private static Dictionary<string, MuteInfo> Mutes = new Dictionary<string, MuteInfo>();
        public class MuteInfo
        {
            public string PlayerName { get; set; }
            public string PlayerId { get; set; }
            public string Reason { get; set; }
            public string Admin { get; set; }
            public bool Sent { get; set; }
            public DateTime ExpireDate { get; set; }

            public bool Expired => ExpireDate < DateTime.UtcNow;

            public MuteInfo() { }

            public MuteInfo(IPlayer target, string adminName, DateTime expireDate, string reason)
            {
                PlayerName = target.Name;
                PlayerId = target.Id;
                Reason = reason;
                Admin = adminName;
                Sent = false;
                ExpireDate = expireDate;
            }
        }

        public class MuteManager
        {
            public MuteInfo AddMute(IPlayer target, string adminName, DateTime expireDate, string reason = null, bool addReason = false)
            {
                MuteInfo info;

                if (Mutes.ContainsKey(target.Id))
                {
                    MuteInfo m = GetMute(target);

                    if (m == null)
                        return null;

                    m.ExpireDate = expireDate;
                    m.Reason = (addReason ? $"{m.Reason} | {reason}" : reason);

                    return null;
                }

                info = new MuteInfo(target, adminName, expireDate, reason);
                Mutes.Add(target.Id, info);

                return info;
            }

            public void RemoveMute(string steamid) => RemoveMute(GetMute(steamid));
            public void RemoveMute(IPlayer player) => RemoveMute(GetMute(player));
            private void RemoveMute(MuteInfo info)
            {
                if (info == null)
                    return;

                Mutes.Remove(info.PlayerId);
            }

            MuteInfo GetMute(IPlayer player) => GetMute(player.Id);
            MuteInfo GetMute(string steamid)
            {
                MuteInfo info;

                if (Mutes.TryGetValue(steamid, out info))
                    return info;
                else
                    return null;
            }

            public bool MuteExists(string steamid) => MuteExists(GetMute(steamid));
            public bool MuteExists(IPlayer player) => MuteExists(GetMute(player));
            private bool MuteExists(MuteInfo info)
            {
                if (info != null)
                    return true;

                return false;
            }

            public bool IsExpired(string steamid) => IsExpired(GetMute(steamid));
            public bool IsExpired(IPlayer player) => IsExpired(GetMute(player));
            private bool IsExpired(MuteInfo info)
            {
                if (info != null)
                    return info.ExpireDate < DateTime.UtcNow;

                return false;
            }

            public bool MessageSent(string steamid) => MessageSent(GetMute(steamid));
            public bool MessageSent(IPlayer player) => MessageSent(GetMute(player));
            private bool MessageSent(MuteInfo info)
            {
                if (info != null)
                    return info.Sent;

                return false;
            }

            public string GetPlayerName(IPlayer player) => GetPlayerName(GetMute(player));
            private string GetPlayerName(MuteInfo info)
            {
                if (info != null)
                    return info.PlayerName;

                return null;
            }

            public string GetPlayerId(IPlayer player) => GetPlayerId(GetMute(player));
            private string GetPlayerId(MuteInfo info)
            {
                if (info != null)
                    return info.PlayerId;

                return null;
            }

            public string GetReason(IPlayer player) => GetReason(GetMute(player));
            private string GetReason(MuteInfo info)
            {
                if (info != null)
                    return info.Reason;

                return null;
            }

            public string GetAdmin(IPlayer player) => GetAdmin(GetMute(player));
            private string GetAdmin(MuteInfo info)
            {
                if (info != null)
                    return info.Admin;

                return null;
            }

            public DateTime? GetExpireDate(IPlayer player) => GetExpireDate(GetMute(player));
            private DateTime? GetExpireDate(MuteInfo info)
            {
                if (info != null)
                    return info.ExpireDate;

                return null;
            }

            public void SetReason(IPlayer player, string reason, bool addReason = false) => SetReason(GetMute(player), reason, addReason);
            private void SetReason(MuteInfo info, string reason, bool addReason = false)
            {
                if (info != null)
                    info.Reason = (addReason ? $"{info.Reason} | {reason}" : reason);
            }

            public void SetAdmin(IPlayer player, IPlayer admin) => SetAdmin(GetMute(player), admin);
            private void SetAdmin(MuteInfo info, IPlayer admin)
            {
                if (info != null)
                    info.Admin = admin.Name;
            }

            public void SetExpireDate(IPlayer player, DateTime expireDate) => SetExpireDate(GetMute(player), expireDate);
            private void SetExpireDate(MuteInfo info, DateTime expireDate)
            {
                if (info != null)
                    info.ExpireDate = expireDate;
            }

            public void SetMessageSent(string steamid, bool sent) => SetMessageSent(GetMute(steamid), sent);
            public void SetMessageSent(IPlayer player, bool sent) => SetMessageSent(GetMute(player), sent);
            private void SetMessageSent(MuteInfo info, bool sent)
            {
                if (info != null)
                    info.Sent = sent;
            }
        }

        private void LoadStoredData()
        {
            LoadData(ref Mutes, mData);
            SaveData(Mutes, mData);
        }

        private void SaveMutes() => timer.Once(1f, () => { SaveData(Mutes, mData); });

        private void SaveData<T>(T data, string filename = null) => MuteData.WriteObject(filename ?? Name, data);
        private void LoadData<T>(ref T data, string filename = null) => data = MuteData.ReadObject<T>(filename ?? Name);

        #endregion Data

        #region Helpers

        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            if (nameOrID.IsSteamId())
            {
                IPlayer result = players.All.ToList().Find((p) => p.Id == nameOrID);

                if (result == null)
                    SendChatMessage(player, Lang("SteamID Not Found", player.Id, nameOrID));

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.All)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, Lang("Player Not Found", player.Id, nameOrID));
                    break;
                case 1:
                    return foundPlayers[0];
                default:
                    string[] names = (from current in foundPlayers select $"- {current.Name}").ToArray();
                    SendChatMessage(player, Lang("Multiple Players Found", player.Id, string.Join("\n", names)));
                    break;
            }
            return null;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;

            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private bool BoolConfig(string menu, string dataValue, bool defaultValue) => Convert.ToBoolean(GetConfig(menu, dataValue, defaultValue));

        #endregion Helpers

        #region Messaging

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void SendChatMessage(IPlayer player, string message) => player.Reply(message);

        private void SendBroadcastMessage(string message)
        {
            foreach (IPlayer current in players.Connected)
                SendChatMessage(current, message);
        }

        private void SendInfoMessage(IPlayer player, string prefix, string message) => player.Reply($"[+18][#orange]{prefix}[/#][/+]\n\n{message}");

        #endregion Messaging
    }
}

// --- End of file: VoiceMute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vending-manager ---
// --- Original File Path: V/VendingManager/VendingManager.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vending Manager", "Whispers88", "0.2.2")]
    [Description("Improved vending machine control")]
    class VendingManager : RustPlugin
    {
        #region Variables

        [PluginReference]
        Plugin CustomVendingSetup, Economics, ServerRewards;

        // usage permission
        private const string PermCanUse = "vendingmanager.canuse";
        private const string PermCanEject = "vendingmanager.caneject";

        // valid commands
        private enum Command
        {
            add, clear, eject, info, list, load, reset, save, set, unset
        };

        // configuration options
        private enum Option
        {
            destroyOnUnload,    // destroy locks on unload
            ejectLocks,         // eject locks on unload/reload
            health,             // health
            lockable,           // allow attaching locks
            lockFailureMessage, // display message on lock attach failure
            saveLocks,          // save locks on unload
            setHealth,          // enable setting health
            noBroadcast,        // blocks broadcasting
            restricted,         // restrict panel access to owners
            useEconomics,       // use Economics
            useServerRewards,   // use ServerRewards
            transactionTimeout, // timeout to end transactions
            logTransSuccess,    // enable logging transaction success
            logTransFailure,    // enable logging transaction failures
            transMessages,      // enable transaction success messages
            currencyItem        // currency item shortname
        }

        // default configuration values
        object[] defaults = new object[] { false, false, defaultHealth, true, false, true, true, false, false, false, false, 300f, false, false, true, "blood" };

        // container for config/data
        VendingData data = new VendingData();
        Dictionary<ulong, VendingMachineInfo> vms = new Dictionary<ulong, VendingMachineInfo>();
        Dictionary<ulong, LockInfo> locks = new Dictionary<ulong, LockInfo>();
        const float defaultHealth = 500f;
        ProtectionProperties defaultProtection;
        ProtectionProperties customProtection;

        const string CodeLockPrefab = "assets/prefabs/locks/keypad/lock.code.prefab";
        const string KeyLockPrefab = "assets/prefabs/locks/keylock/lock.key.prefab";

        Dictionary<ulong, Timer> transactionTimers = new Dictionary<ulong, Timer>();
        Dictionary<ulong, Timer> timeoutTimers = new Dictionary<ulong, Timer>();

        bool isShuttingDown = false;
        bool useEconomics = false;
        bool useServerRewards = false;
        string currencyPlugin
        {
            get
            {
                if (useEconomics) return Economics.Name;
                if (useServerRewards) return ServerRewards.Name;
                return null;
            }
        }

        int currencyIndex = 24;
        ItemDefinition currencyItem;

        #endregion

        #region Lang

        // load default messages to Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Prefix", "<color=orange>[ VendingManager ]</color> "},
                {"ClearSuccess", "Successfully cleared Vending Machine sell orders"},
                {"SaveSuccess", "Saved Vending Machine sell orders to \"{0}\""},
                {"LoadSuccess", "Loaded Vending Machine sell orders from \"{0}\""},
                {"ResetSuccess", "Successfully cleared and reset VendingManager configuration to defaults"},
                {"ConfirmReset", "To reset the VendingManager configuration and remove all saved templates, type: /vm reset confirm"},
                {"VMNotFound", "No Vending Machine found"},
                {"EmptyTemplate", "Template \"{0}\" is empty"},
                {"EmptyVM", "Vending Machine has no sell orders defined"},
                {"TemplateNotFound", "No sell order template found with name \"{0}\""},
                {"TemplateExists", "Template with name \"{0}\" already exists, add \"overwrite\" parameter to command to overwrite template"},
                {"InvalidCommand", "Invalid command: {0}"},
                {"InvalidParameter", "Invalid parameter"},
                {"NotAuthorized", "You cannot add a lock to that Vending Machine"},
                {"CommandList", "<color=cyan>Valid Commands:</color>" + Environment.NewLine + "{0}"},
                {"TemplateList", "<color=cyan>Templates:</color>" + Environment.NewLine + "{0}"},
                {"Ejected", "Ejected {0} locks from Vending Machines"},
                {"NoBroadcast", "Broadcasting is not allowed" },
                {"Restricted", "You do not have access to administrate that VendingMachine" },
                {"Information", "Vending Machine ID: <color=cyan>{0}</color>" + Environment.NewLine + "Has configuration? <color=cyan>{1}</color>" + Environment.NewLine + "Flags: <color=cyan>{2}</color>" },

                {"EconomicsNotEnoughMoney", "Transaction Cancelled (Economics): Not enough money" },
                {"EconomicsNotEnoughMoneyOwner", "Transaction Cancelled (Economics): Buyer doesn't have enough money" },
                {"EconomicsTransferFailed", "Transaction Cancelled (Economics): Money transfer failed" },
                {"EconomicsPurchaseSuccess", "Successfully purchased {0} {1} for {2:C}; Remaining balance: {3:C}" },
                {"EconomicsSellSuccess", "Successfully sold {0} {1} for {2:C}; New balance: {3:C}" },

                {"ServerRewardsNotEnoughMoney", "Transaction Cancelled (ServerRewards): Not enough RP" },
                {"ServerRewardsNotEnoughMoneyOwner", "Transaction Cancelled (ServerRewards): Buyer doesn't have enough RP" },
                {"ServerRewardsTransferFailed", "Transaction Cancelled (ServerRewards): RP transfer failed" },
                {"ServerRewardsPurchaseSuccess", "Successfully purchased {0} {1} for {2}RP; Remaining balance: {3}RP" },
                {"ServerRewardsSellSuccess", "Successfully sold {0} {1} for {2}RP; New balance: {3}RP" },

                {"SetSuccess", "Successfully set flag <color=cyan>{0}</color>" },
                {"UnsetSuccess", "Successfully removed flag <color=cyan>{0}</color>" },
                {"WarnEconAndSREnabled", "Economics and ServerRewards are both enabled as currency; ServerRewards has been forcibly disabled." },

                {"NotAllowed", "You are not allowed to use this command!"},
                {"CmdBase", "vm"}
            }, this);
        }

        // get message from Lang
        string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion

        #region Loading/Unloading

        // on load
        //void Loaded()
        void Init()
        {
            cmd.AddChatCommand(GetMessage("CmdBase"), this, "CommandDelegator");
            permission.RegisterPermission(PermCanUse, this);
            permission.RegisterPermission(PermCanEject, this);
            LoadData();
        }

        // on unload, reset all vending machines
        void Unload()
        {
            if (ConfigValue<bool>(Option.saveLocks) || isShuttingDown)
                SaveVMsAndLocks();
            SetAll(false);
            if (ConfigValue<bool>(Option.destroyOnUnload) || isShuttingDown)
                DestroyLocks();

            foreach (Timer t in transactionTimers.Values)
                t?.Destroy();
            foreach (Timer t in timeoutTimers.Values)
                t?.Destroy();
        }

        // server initialized
        void OnServerInitialized()
        {
            SetAll(ConfigValue<bool>(Option.lockable), ConfigValue<float>(Option.health));
            if (ConfigValue<bool>(Option.saveLocks))
                LoadLocks();
            currencyItem = ItemManager.FindItemDefinition(ConfigValue<string>(Option.currencyItem)) ?? ItemManager.FindItemDefinition("blood"); // assume blood if item missing
            useEconomics = ConfigValue<bool>(Option.useEconomics);
            useServerRewards = ConfigValue<bool>(Option.useServerRewards);
            Check(true);
        }

        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Name == "Economics" && ConfigValue<bool>(Option.useEconomics))
                Check();
            else if (plugin.Name == "ServerRewards" && ConfigValue<bool>(Option.useServerRewards))
                Check();
        }

        void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == "Economics" && ConfigValue<bool>(Option.useEconomics))
                Check();
            else if (plugin.Name == "ServerRewards" && ConfigValue<bool>(Option.useServerRewards))
                Check();
        }

        void Check(bool initial = false)
        {
            bool prev = useEconomics;
            useEconomics = ConfigValue<bool>(Option.useEconomics) && Economics != null;
            if (initial || prev != useEconomics)
                Puts("Economics " + (useEconomics ? "detected - money purchases enabled" : "not detected - money purchases disabled"));
            prev = useServerRewards;
            useServerRewards = ConfigValue<bool>(Option.useServerRewards) && ServerRewards != null;
            if (initial || prev != useServerRewards)
                Puts("ServerRewards " + (useServerRewards ? "detected - RP purchases enabled" : "not detected - RP purchases disabled"));
            if (useEconomics && useServerRewards)
            {
                useServerRewards = false;
                PrintWarning(GetMessage("WarnEconAndSREnabled"));
            }
        }

        // save/destroy locks on server shutdown to avoid NULL in saveList
        void OnServerShutdown()
        {
            isShuttingDown = true;
        }

        // save locks when server saves
        void OnServerSave()
        {
            // delayed save to fight the lag monster
            timer.In(5f, () => SaveVMsAndLocks());
        }

        #endregion

        #region Configuration

        // load default config
        bool LoadDefaultConfig()
        {
            data = new VendingData();
            CheckConfig();
            data.templates = new Dictionary<string, SellOrderTemplate>();
            return true;
        }

        void LoadData()
        {
            bool dirty = false;
            try
            {
                data = Config.ReadObject<VendingData>();
            }
            catch (Exception) { }
            dirty = CheckConfig();
            if (data.templates == null)
                dirty |= LoadDefaultConfig();
            if (dirty)
                SaveData();
            vms = Interface.GetMod()?.DataFileSystem?.ReadObject<Dictionary<ulong, VendingMachineInfo>>("VendingManagerVMs");
            locks = Interface.GetMod()?.DataFileSystem?.ReadObject<Dictionary<ulong, LockInfo>>("VendingManagerLocks");
        }

        // write data container to config
        void SaveData()
        {
            Config.WriteObject(data);
        }

        void SaveVendingMachineData()
        {
            foreach (ulong k in vms.Keys.ToList())
            {
                BaseNetworkable net = BaseNetworkable.serverEntities.Find(new NetworkableId(k));
                VendingMachine vm = net as VendingMachine;
                if (net == null || vm == null)
                    vms.Remove(k);
            }
            Interface.GetMod().DataFileSystem.WriteObject("VendingManagerVMs", vms);
        }

        // save locks data to file
        void SaveLocksData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("VendingManagerLocks", locks);
        }

        // get value from config (handles type conversion)
        T GetConfig<T>(string group, string name, T value)
        {
            if (Config[group, name] == null)
            {
                Config[group, name] = value;
                SaveConfig();
            }
            return (T)Convert.ChangeType(Config[group, name], typeof(T));
        }

        // validate configuration
        bool CheckConfig()
        {
            bool dirty = false;
            foreach (Option option in Enum.GetValues(typeof(Option)))
                if (!data.config.ContainsKey(option))
                {
                    data.config[option] = defaults[(int)option];
                    dirty = true;
                }
            return dirty;
        }

        #endregion

        #region Hooks

        // set newly spawned vending machines to the value of lockable
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity.GetType() == typeof(VendingMachine))
                Set(entity as VendingMachine, ConfigValue<bool>(Option.lockable), ConfigValue<float>(Option.health));
        }

        // block unauthorized lock deployment onto vending machines
        // only allow attachment from the rear, except if player is
        // the owner of the vending machine
        void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (!ConfigValue<bool>(Option.lockable)) return;
            if (deployer == null || entity == null) return;
            BasePlayer player = deployer.GetOwnerPlayer();
            VendingMachine vm = entity as VendingMachine;
            if (vm == null || player == null) return;
            if (deployer.GetDeployable().slot == BaseEntity.Slot.Lock && !(vm.CanPlayerAdmin(player) || player.userID == vm.OwnerID))
            {
                BaseLock lockEntity = vm.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
                if (lockEntity == null) return;
                deployer.GetItem().amount++;
                lockEntity.Kill();
                if (ConfigValue<bool>(Option.lockFailureMessage))
                    SendMessage(player, "NotAuthorized");
            }
        }

        // handle blocking broadcasting
        void OnToggleVendingBroadcast(VendingMachine vm, BasePlayer player)
        {
            if (ConfigValue<bool>(Option.noBroadcast))
            {
                vm.SetFlag(BaseEntity.Flags.Reserved4, false, false);
                SendMessage(player, "NoBroadcast");
            }
        }

        object OnVendingTransaction(VendingMachine vm, BasePlayer player, int sellOrderId, int numTransactions)
        {
            var cvsResult = CustomVendingSetup?.Call("API_IsCustomized", vm);
            if (cvsResult is bool && (bool)cvsResult)
                return null;

            VendingMachineInfo i;
            vms.TryGetValue(vm.net.ID.Value, out i);
            bool bottomless = i == null ? false : i.HasFlag(VendingMachineInfo.VMFlags.Bottomless);

            bool log = ConfigValue<bool>(Option.logTransSuccess) || ConfigValue<bool>(Option.logTransFailure) || (i != null && i.HasFlag(VendingMachineInfo.VMFlags.LogTransactions));
            bool force = i != null && i.HasFlag(VendingMachineInfo.VMFlags.LogTransactions);
            ProtoBuf.VendingMachine.SellOrder sellOrder = vm.sellOrders.sellOrders[sellOrderId];

            bool isCurrencySellOrder = (useEconomics || useServerRewards) && sellOrder.currencyID == currencyItem.itemid;
            bool isCurrencyBuyOrder = (useEconomics || useServerRewards) && sellOrder.itemToSellID == currencyItem.itemid;

            LogEntry logEntry = new LogEntry();
            if (log)
            {
                logEntry.id = vm.net.ID;
                logEntry.playerID = player.userID;
                logEntry.playerName = player.displayName;
            }

            List<Item> items = vm.inventory.FindItemsByItemID(sellOrder.itemToSellID);
            if (sellOrder.itemToSellIsBP)
            {
                items = (
                    from x in vm.inventory.FindItemsByItemID(vm.blueprintBaseDef.itemid)
                    where x.blueprintTarget == sellOrder.itemToSellID
                    select x).ToList();
            }
            if (items == null || items.Count == 0)
            {
                return false;
            }
            int numberOfTransactions = Mathf.Clamp(numTransactions, 1, (!items[0].hasCondition ? 1000000 : 1));
            int sellCount = sellOrder.itemToSellAmount * numberOfTransactions;
            int buyCount = sellOrder.currencyAmountPerItem * numberOfTransactions;

            if (sellCount > items.Sum(x => x.amount))
                return false;

            int cost = 0;
            if (!isCurrencySellOrder)
            {
                int num2 = sellOrder.currencyAmountPerItem * numberOfTransactions;

                if (log) logEntry.cost = num2 + " " + ItemManager.FindItemDefinition(sellOrder.currencyID).displayName.translated + (sellOrder.currencyIsBP ? " (BP)" : "");

                List<Item> items1 = player.inventory.FindItemsByItemID(sellOrder.currencyID);
                if (sellOrder.currencyIsBP)
                {
                    items1 = (
                        from x in player.inventory.FindItemsByItemID(vm.blueprintBaseDef.itemid)
                        where x.blueprintTarget == sellOrder.currencyID
                        select x).ToList();
                }
                if (items1.Count == 0)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.NoItems;
                        LogTransaction(logEntry, force);
                    }
                    return false;
                }

                int num1 = items1.Sum(x => x.amount);
                if (num1 < num2)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.NoItems;
                        LogTransaction(logEntry, force);
                    }
                    return false;
                }

                vm.transactionActive = true;
                int num3 = 0;
                Item item;
                foreach (Item item2 in items1)
                {
                    int num4 = Mathf.Min(num2 - num3, item2.amount);
                    item = (item2.amount > num4 ? item2.SplitItem(num4) : item2);
                    if (bottomless)
                        item.Remove();
                    else
                        if (!item.MoveToContainer(vm.inventory, -1, true))
                    {
                        item.Drop(vm.inventory.dropPosition, Vector3.zero, new Quaternion());
                    }
                    num3 = num3 + num4;
                    if (num3 < num2)
                        continue;
                    break;
                }
            }
            else
            {
                cost = sellOrder.currencyAmountPerItem * numberOfTransactions;
                if (log)
                {
                    logEntry.isBuyOrder = true;
                    logEntry.cost = string.Format("{0:C}", cost);
                }
                double money = GetBalance(player.userID);
                if (money < 1.0)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.NoMoney;
                        LogTransaction(logEntry, force);
                    }
                    return false;
                }

                if (Mathf.FloorToInt((float)money) < cost)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.NoMoney;
                        LogTransaction(logEntry, force);
                    }
                    SendMessage(player, currencyPlugin + "NotEnoughMoney");
                    return false;
                }

                vm.transactionActive = true;
                bool success = false;
                if (bottomless)
                    success = Withdraw(player.userID, cost);
                else
                    success = Transfer(player.userID, vm.OwnerID, cost);

                if (!success)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.Unknown;
                        LogTransaction(logEntry, force);
                    }
                    SendMessage(player, currencyPlugin + "TransferFailed");
                    vm.transactionActive = false;
                    return false;
                }
            }
            int amount = 0;
            if (isCurrencyBuyOrder)
            {
                amount = sellOrder.itemToSellAmount * numberOfTransactions;
                if (log)
                {
                    logEntry.isBuyOrder = false;
                    logEntry.cost = string.Format("{0:C}", amount);
                    logEntry.bought = sellOrder.currencyAmountPerItem + " " + ItemManager.FindItemDefinition(sellOrder.currencyID).displayName.translated;
                }

                double money = GetBalance(vm.OwnerID);
                if (!bottomless)
                {
                    if (money < 1.0)
                    {
                        if (log)
                        {
                            logEntry.success = false;
                            logEntry.reason = LogEntry.FailureReason.NoMoney;
                            LogTransaction(logEntry, force);
                        }
                        return false;
                    }

                    if (Mathf.FloorToInt((float)money) < amount)
                    {
                        if (log)
                        {
                            logEntry.success = false;
                            logEntry.reason = LogEntry.FailureReason.NoMoney;
                            LogTransaction(logEntry, force);
                        }
                        SendMessage(player, currencyPlugin + "NotEnoughMoneyOwner");
                        return false;
                    }
                }

                vm.transactionActive = true;
                bool success = false;
                if (bottomless)
                    success = Deposit(player.userID, amount);
                else
                    success = Transfer(vm.OwnerID, player.userID, amount);

                if (!success)
                {
                    if (log)
                    {
                        logEntry.success = false;
                        logEntry.reason = LogEntry.FailureReason.Unknown;
                        LogTransaction(logEntry, force);
                    }
                    SendMessage(player, currencyPlugin + "TransferFailed");
                    vm.transactionActive = false;
                    return false;
                }
            }
            else
            {
                if (log) logEntry.bought = sellOrder.itemToSellAmount + " " + ItemManager.FindItemDefinition(sellOrder.itemToSellID).displayName.translated + (sellOrder.itemToSellIsBP ? " (BP)" : "");
                if (!bottomless)
                {
                    int num5 = 0;
                    Item item1 = null;
                    foreach (Item item3 in items)
                    {
                        item1 = (item3.amount > sellCount ? item3.SplitItem(sellCount) : item3);
                        num5 = num5 + item1.amount;
                        player.GiveItem(item1, BaseEntity.GiveItemReason.PickedUp);
                        if (num5 < sellCount)
                            continue;
                        break;
                    }
                }
                else
                {
                    Item item = null;
                    if (sellOrder.itemToSellIsBP)
                    {
                        item = ItemManager.CreateByItemID(vm.blueprintBaseDef.itemid, sellCount);
                        item.blueprintTarget = sellOrder.itemToSellID;
                    }
                    else
                        item = ItemManager.CreateByItemID(sellOrder.itemToSellID, sellCount, vm.inventory.FindItemsByItemID(sellOrder.itemToSellID).Select(e => e.skin).FirstOrDefault());
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                }
            }

            vm.UpdateEmptyFlag();
            vm.transactionActive = false;

            if (ConfigValue<bool>(Option.transMessages) && isCurrencySellOrder && cost > 0)
            {
                double remaining = GetBalance(player.userID);
                SendMessage(player, currencyPlugin + "PurchaseSuccess", new object[] { sellCount, ItemManager.FindItemDefinition(sellOrder.itemToSellID).displayName.translated, cost, remaining });
            }
            else if (ConfigValue<bool>(Option.transMessages) && isCurrencyBuyOrder && amount > 0)
            {
                double balance = GetBalance(player.userID);
                SendMessage(player, currencyPlugin + "SellSuccess", new object[] { buyCount, ItemManager.FindItemDefinition(sellOrder.currencyID).displayName.translated, amount, balance });
            }
            if (log)
            {
                logEntry.success = true;
                LogTransaction(logEntry, force);
            }

            return true;
        }

        // override administration if restricted access on
        object CanAdministerVending(VendingMachine vm, BasePlayer player)
        {
            bool restricted = ConfigValue<bool>(Option.restricted);
            if (!restricted)
            {
                VendingMachineInfo i;
                if (vms.TryGetValue(vm.net.ID.Value, out i))
                    restricted = i.HasFlag(VendingMachineInfo.VMFlags.Restricted);
            }
            if (restricted && vm.OwnerID != player.userID && !player.IsAdmin)
            {
                SendMessage(player, "Restricted");
                return false;
            }
            return null;
        }

        // block damage for Immortal vending machines
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (entity == null || hitinfo == null) return;
            if (entity is VendingMachine)
            {
                VendingMachineInfo i;
                if (vms.TryGetValue(entity.net.ID.Value, out i))
                {
                    if (i.HasFlag(VendingMachineInfo.VMFlags.Immortal))
                        hitinfo.damageTypes = new DamageTypeList();
                }
            }
        }

        // hack to show vending buttons - when VM shop opened, add currency items
        // to hidden inventory slot to represent current economics balance
        void OnVendingShopOpened(VendingMachine vm, BasePlayer player)
        {
            if (!useEconomics && !useServerRewards) return;
            if (vm.sellOrders.sellOrders.Count == 0) return;

            bool hasCurrencySellOrder = false;
            bool hasCurrencyBuyOrder = true;
            // create and add items to player inventory to prevent "Can't Afford" button
            foreach (ProtoBuf.VendingMachine.SellOrder so in vm.sellOrders.sellOrders)
            {
                if (so.currencyID == currencyItem.itemid)
                    hasCurrencySellOrder = true;
                else if (so.itemToSellID == currencyItem.itemid)
                    hasCurrencyBuyOrder = true;
            }
            if (!hasCurrencySellOrder && !hasCurrencyBuyOrder) return;

            int playerMoney = 0;
            if (hasCurrencyBuyOrder)
            {
                vm.inventory.capacity = currencyIndex + 1;
                VendingMachineInfo i;
                vms.TryGetValue(vm.net.ID.Value, out i);
                bool bottomless = i == null ? false : i.HasFlag(VendingMachineInfo.VMFlags.Bottomless);
                if (bottomless)
                {
                    Item money = ItemManager.CreateByItemID(currencyItem.itemid, 10000, 0);
                    money.MoveToContainer(vm.inventory, currencyIndex, true);
                }
                else
                {
                    playerMoney = Mathf.FloorToInt((float)GetBalance(vm.OwnerID));
                    if (playerMoney > 0)
                    {
                        Item money = ItemManager.CreateByItemID(currencyItem.itemid, playerMoney);
                        money.MoveToContainer(vm.inventory, currencyIndex, true);
                    }
                }
                /*
                int lastMoney = playerMoney;
                transactionTimers[player.userID] = timer.Every(0.5f, () => {
                    int m = Mathf.FloorToInt((float)GetBalance(vm.OwnerID));
                    if (lastMoney != m)
                    {
                        lastMoney = m;
                        Item item = vm.inventory.GetSlot(currencyIndex);
                        if (item != null)
                        {
                            if (lastMoney == 0)
                                item.Remove();
                            else
                                item.amount = lastMoney;
                            vm.RefreshSellOrderStockLevel();
                        }
                    }
                });
                */
            }
            playerMoney = 0;
            if (hasCurrencySellOrder)
            {
                player.inventory.containerMain.capacity = currencyIndex + 1;
                playerMoney = Mathf.FloorToInt((float)GetBalance(player.userID));
                if (playerMoney > 0)
                {
                    Item money = ItemManager.CreateByItemID(currencyItem.itemid, playerMoney, 0);
                    money.MoveToContainer(player.inventory.containerMain, currencyIndex, true);
                }

                int lastMoney = playerMoney;
                transactionTimers[player.userID] = timer.Every(0.5f, () => {
                    int m = Mathf.FloorToInt((float)GetBalance(player.userID));
                    if (lastMoney != m)
                    {
                        if (lastMoney == 0 && m > 0)
                        {
                            Item money = ItemManager.CreateByItemID(currencyItem.itemid, m, 0);
                            money.MoveToContainer(player.inventory.containerMain, currencyIndex, true);
                        }
                        lastMoney = m;
                        Item item = player.inventory.containerMain.GetSlot(currencyIndex);
                        if (item != null)
                        {
                            if (lastMoney == 0)
                                item.Remove();
                            else
                                item.amount = lastMoney;
                            player.inventory.SendSnapshot();
                        }
                    }
                });
            }
            if (ConfigValue<float>(Option.transactionTimeout) > 0f)
                timeoutTimers[player.userID] = timer.Once(ConfigValue<float>(Option.transactionTimeout), () => player.EndLooting());
        }

        // when VM shop closed, remove all currency items from player's inventory
        void OnLootEntityEnd(BasePlayer player, BaseEntity entity)
        {
            if ((!useEconomics && !useServerRewards) || entity == null || !(entity is VendingMachine)) return;
            if (transactionTimers.ContainsKey(player.userID))
                transactionTimers[player.userID]?.Destroy();
            if (timeoutTimers.ContainsKey(player.userID))
                timeoutTimers[player.userID]?.Destroy();

            int i = player.inventory.containerMain.capacity;
            while (i >= currencyIndex)
                player.inventory.containerMain.GetSlot(i--)?.Remove();
            Item b = player.inventory.containerMain.FindItemByItemID(currencyItem.itemid);
            if (b != null) b.Remove();
            player.inventory.containerMain.capacity = currencyIndex;

            VendingMachine vm = entity as VendingMachine;
            int j = vm.inventory.capacity;
            while (j >= currencyIndex)
                vm.inventory.GetSlot(j--)?.Remove();
            Item c = vm.inventory.FindItemByItemID(currencyItem.itemid);
            if (c != null) c.Remove();
            vm.inventory.capacity = currencyIndex;
        }

        // on rotate, send network update for lock position
        void OnRotateVendingMachine(VendingMachine vm, BasePlayer player)
        {
            BaseLock l = vm.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
            if (l != null)
                NextTick(() => l.SendNetworkUpdate());
        }

        #endregion

        #region Command Handling

        // command delegator
        void CommandDelegator(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermCanUse))
            {
                SendReply(player, GetMessage("NotAllowed", player.UserIDString));
                return;
            }
            string message = "InvalidCommand";
            // assume args[0] is the command (beyond /vm)
            if (args != null && args.Length > 0)
                command = args[0];
            // shift arguments
            if (args != null)
            {
                if (args.Length > 1)
                    args = args.Skip(1).ToArray();
                else
                    args = new string[] { };
            }
            object[] opts = new object[] { command };
            if (Enum.IsDefined(typeof(Command), command))
            {
                switch ((Command)Enum.Parse(typeof(Command), command))
                {
                    case Command.add:
                        HandleLoad(player, args, false, out message, out opts);
                        break;
                    case Command.clear:
                        HandleClear(player, out message);
                        break;
                    case Command.eject:
                        if (hasPermission(player, PermCanEject))
                            EjectAll(out message, out opts);
                        break;
                    case Command.info:
                        HandleInfo(player, out message, out opts);
                        break;
                    case Command.list:
                        HandleList(out message, out opts);
                        break;
                    case Command.load:
                        HandleLoad(player, args, true, out message, out opts);
                        break;
                    case Command.reset:
                        HandleReset(args, out message);
                        break;
                    case Command.save:
                        HandleSave(player, args, out message, out opts);
                        break;
                    case Command.set:
                        HandleSet(player, args, out message, out opts);
                        break;
                    case Command.unset:
                        HandleSet(player, args, out message, out opts, true);
                        break;
                    default:
                        break;
                }
            }
            else
                ShowCommands(out message, out opts);
            if (message != null && message != "")
                SendMessage(player, message, opts);
        }

        // handle reset command
        void HandleReset(string[] args, out string message)
        {
            bool confirm = (args.Length > 0 && args[0] != null && args[0].ToLower() == "confirm");
            if (confirm)
            {
                Config.Clear();
                data = new VendingData();
                SaveData();
                message = "ResetSuccess";
            }
            else
                message = "ConfirmReset";
        }

        // handle clear command
        void HandleClear(BasePlayer player, out string message)
        {
            message = "VMNotFound";
            object entity;
            if (GetRaycastTarget(player, out entity))
                if (entity != null && entity is VendingMachine)
                {
                    (entity as VendingMachine).sellOrders.sellOrders.Clear();
                    message = "ClearSuccess";
                }
        }

        void HandleInfo(BasePlayer player, out string message, out object[] opts)
        {
            message = "VMNotFound";
            opts = new object[] { };
            object entity;
            if (GetRaycastTarget(player, out entity))
                if (entity != null && entity is VendingMachine)
                {
                    ulong id = (entity as VendingMachine).net.ID.Value;
                    bool isConfigured = vms.ContainsKey(id);
                    string flags = "None";
                    if (isConfigured)
                        flags = vms[id].flags.ToString();
                    message = "Information";
                    opts = new object[] { id, isConfigured, flags };
                }
        }

        // handle load command
        void HandleLoad(BasePlayer player, string[] args, bool replaceAll, out string message, out object[] opts)
        {
            message = "";
            opts = new object[] { };
            if (args == null || args.Length == 0 || args[0] == null || args[0] == "")
            {
                message = "InvalidParameter";
                return;
            }
            object entity;
            if (!GetRaycastTarget(player, out entity))
            {
                message = "VMNotFound";
                return;
            }

            opts = new object[] { args[0] };
            if (entity != null && entity is VendingMachine)
                LoadSellOrders(entity as VendingMachine, args[0], replaceAll, out message);
        }

        // handle loading the sell orders into a vending machine
        void LoadSellOrders(VendingMachine vm, string templateName, bool replace, out string message)
        {
            message = "LoadSuccess";
            if (!data.templates.ContainsKey(templateName))
            {
                message = "TemplateNotFound";
                return;
            }
            if (data.templates[templateName].Empty())
            {
                message = "EmptyTemplate";
                return;
            }
            if (replace)
                vm.sellOrders.sellOrders.Clear();
            foreach (SellOrderEntry e in data.templates[templateName].entries)
            {
                ProtoBuf.VendingMachine.SellOrder o = new ProtoBuf.VendingMachine.SellOrder();
                o.itemToSellID = ItemManager.FindItemDefinition(e.itemToSellName).itemid;
                o.itemToSellAmount = e.itemToSellAmount;
                o.itemToSellIsBP = e.itemToSellIsBP;
                o.currencyID = ItemManager.FindItemDefinition(e.currencyName).itemid;
                o.currencyAmountPerItem = e.currencyAmountPerItem;
                o.currencyIsBP = e.currencyIsBP;
                vm.sellOrders.sellOrders.Add(o);
            }
            vm.RefreshSellOrderStockLevel();
            return;
        }

        // handle save command
        void HandleSave(BasePlayer player, string[] args, out string message, out object[] opts)
        {
            message = "";
            opts = new object[] { };
            if (args == null || args.Length == 0 || args[0] == null || args[0] == "")
            {
                message = "InvalidParameter";
                return;
            }
            bool overwrite = (args.Length > 1 && args[1] != null && args[1].ToLower() == "overwrite");
            object entity;
            if (!GetRaycastTarget(player, out entity))
            {
                message = "VMNotFound";
                return;
            }
            opts = new object[] { args[0] };
            if (entity != null && entity is VendingMachine)
                SaveSellOrders(entity as VendingMachine, args[0], out message, overwrite);
        }

        // handle saving the sell orders from a vending machine
        void SaveSellOrders(VendingMachine vm, string templateName, out string message, bool overwrite = false)
        {
            message = "SaveSuccess";
            if (templateName == null || templateName == "")
            {
                message = "InvalidParameter";
                return;
            }
            if (data.templates.ContainsKey(templateName) && !overwrite)
            {
                message = "TemplateExists";
                return;
            }

            ProtoBuf.VendingMachine.SellOrderContainer sellOrderContainer = vm.sellOrders;
            if (sellOrderContainer == null || sellOrderContainer.sellOrders == null || sellOrderContainer.sellOrders.Count == 0)
            {
                message = "EmptyVM";
                return;
            }
            SellOrderTemplate template = new SellOrderTemplate();
            template.PopulateTemplate(sellOrderContainer.sellOrders);
            if (!template.Empty())
            {
                data.templates[templateName] = template;
                SaveData();
            }
            return;
        }

        // handle set/unset flag
        void HandleSet(BasePlayer player, string[] args, out string message, out object[] opts, bool unset = false)
        {
            message = unset ? "UnsetSuccess" : "SetSuccess";
            opts = new object[] { };
            if (args == null || args.Length == 0 || args[0] == null || args[0] == "" || !Enum.IsDefined(typeof(VendingMachineInfo.VMFlags), args[0]))
            {
                message = "InvalidParameter";
                return;
            }
            object entity;
            if (!GetRaycastTarget(player, out entity))
            {
                message = "VMNotFound";
                return;
            }
            opts = new object[] { args[0] };
            if (entity != null && entity is VendingMachine)
            {
                VendingMachineInfo.VMFlags flags = (VendingMachineInfo.VMFlags)Enum.Parse(typeof(VendingMachineInfo.VMFlags), args[0]);
                VendingMachineInfo i;
                if (!vms.TryGetValue((entity as VendingMachine).net.ID.Value, out i))
                {
                    i = new VendingMachineInfo();
                    i.id = (entity as VendingMachine).net.ID.Value;
                    vms[i.id] = i;
                }
                if (unset)
                    i.flags &= ~flags;
                else
                    i.flags |= flags;
                if (i.flags == VendingMachineInfo.VMFlags.None)
                    vms.Remove(i.id);
                SaveVendingMachineData();
            }
        }

        #endregion

        #region Messaging

        // send reply to a player
        void SendMessage(BasePlayer player, string message, object[] options = null)
        {
            string msg = GetMessage(message, player.UserIDString);
            if (options != null && options.Length > 0)
                msg = String.Format(msg, options);
            SendReply(player, GetMessage("Prefix", player.UserIDString) + msg);
        }

        // handle list command
        void HandleList(out string message, out object[] opts)
        {
            message = "TemplateList";
            opts = new object[] { data.GetTemplateList() };
        }

        // show list of valid commands
        void ShowCommands(out string message, out object[] opts)
        {
            message = "CommandList";
            opts = new object[] { string.Join(", ", Enum.GetValues(typeof(Command)).Cast<Command>().Select(x => x.ToString()).ToArray()) };
        }

        void LogTransaction(LogEntry logEntry, bool force = false)
        {
            if ((ConfigValue<bool>(Option.logTransSuccess) && logEntry.success) || (ConfigValue<bool>(Option.logTransFailure) && !logEntry.success) || force)
            {
                string logString = logEntry.ToString();
                LogToFile("Transactions", logString, this, true);
            }
        }

        #endregion

        #region Helper Procedures

        // set all vending machines
        void SetAll(bool lockable, float health = defaultHealth)
        {
            foreach(var ent in BaseNetworkable.serverEntities)
            {
                if (ent is VendingMachine)
                {
                    Set(ent as VendingMachine, lockable, health);
                }
            }
        }

        // setup a specific vending machine
        void Set(VendingMachine vm, bool lockable, float health = defaultHealth, bool restoreProtection = false)
        {
            if (ConfigValue<bool>(Option.noBroadcast))
                vm.SetFlag(BaseEntity.Flags.Reserved4, false, false);
            if (defaultProtection == null)
            {
                defaultProtection = vm.baseProtection;
                if (data.resistances == null)
                {
                    data.SetResistances(defaultProtection.amounts);
                    SaveData();
                }
            }
            else
            {
                if (customProtection == null)
                    customProtection = UnityEngine.Object.Instantiate(vm.baseProtection) as ProtectionProperties;
                if (data.resistances != null && !restoreProtection)
                {
                    customProtection.amounts = data.GetResistances();
                    vm.baseProtection = customProtection;
                    //vm.baseProtection.amounts = data.GetResistances();
                }
                if (restoreProtection)
                    vm.baseProtection = defaultProtection;
            }
            if (!lockable && ConfigValue<bool>(Option.ejectLocks)) Eject(vm);
            vm.isLockable = lockable;
            if (ConfigValue<bool>(Option.setHealth))
            {
                float h = health * vm.healthFraction;
                vm.InitializeHealth(h, health);
                vm.SendNetworkUpdate();
            }
        }

        // eject lock from vending machine
        bool Eject(VendingMachine m)
        {
            BaseEntity lockEntity = m.GetSlot(BaseEntity.Slot.Lock);
            if (lockEntity != null && lockEntity is BaseLock)
            {
                Item lockItem = ItemManager.Create((lockEntity as BaseLock).itemType, 1, lockEntity.skinID);
                lockEntity.Kill();
                lockItem.Drop(m.GetDropPosition(), m.GetDropVelocity(), m.transform.rotation);
                m.isLockable = ConfigValue<bool>(Option.lockable);
                return true;
            }
            return false;
        }

        // eject locks from all vending machines
        void EjectAll(out string message, out object[] opts)
        {
            int counter = 0;
            foreach (VendingMachine m in GameObject.FindObjectsOfType(typeof(VendingMachine)))
                if (Eject(m)) counter++;

            message = "Ejected";
            opts = new object[] { counter };
        }

        // raycast to find entity being looked at
        bool GetRaycastTarget(BasePlayer player, out object closestEntity)
        {
            closestEntity = null;
            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 5f))
                return false;
            closestEntity = hit.GetEntity();
            return true;
        }

        // check if player is an admin
        private static bool isAdmin(BasePlayer player)
        {
            if (player?.net?.connection == null) return true;
            return player.net.connection.authLevel > 0;
        }

        // check if player has permission or is an admin
        private bool hasPermission(BasePlayer player, string permname)
        {
            //return isAdmin(player) || permission.UserHasPermission(player.UserIDString, permname);
            return permission.UserHasPermission(player.UserIDString, permname);
        }

        // get config value and convert type
        T ConfigValue<T>(Option option)
        {
            return (T)Convert.ChangeType(data.config[option], typeof(T));
        }

        // save all locks
        void SaveVMsAndLocks()
        {
            locks.Clear();
            foreach (VendingMachine vm in GameObject.FindObjectsOfType(typeof(VendingMachine)))
            {
                BaseLock l = (BaseLock)vm.GetSlot(BaseEntity.Slot.Lock);
                if (l == null) continue;

                LockInfo li = new LockInfo(vm.net.ID.Value, l);
                locks[vm.net.ID.Value] = li;
            }
            SaveVendingMachineData();
            SaveLocksData();
        }

        // load all locks
        void LoadLocks()
        {
            foreach (LockInfo li in locks.Values)
            {
                VendingMachine vm = (VendingMachine)BaseNetworkable.serverEntities.Find(new NetworkableId(li.vmId));
                if (vm == null) continue;
                if (vm.GetSlot(BaseEntity.Slot.Lock) != null) continue;

                BaseLock l;
                if (li.isCodeLock)
                    l = (CodeLock)GameManager.server.CreateEntity(CodeLockPrefab);
                else
                    l = (KeyLock)GameManager.server.CreateEntity(KeyLockPrefab);

                if (l == null) continue;

                l.gameObject.Identity();
                li.ToLock(ref l);
                l.SetParent(vm, vm.GetSlotAnchorName(BaseEntity.Slot.Lock));
                l.OnDeployed(vm, null, null);
                l.Spawn();
                vm.SetSlot(BaseEntity.Slot.Lock, l);
            }
        }

        // Destroy all attached locks on shutdown
        void DestroyLocks()
        {
            foreach (VendingMachine vm in GameObject.FindObjectsOfType(typeof(VendingMachine)))
            {
                BaseEntity l;
                if ((l = vm.GetSlot(BaseEntity.Slot.Lock)) != null)
                    l.Kill();
            }
        }

        double GetBalance(ulong playerId)
        {
            if (useEconomics)
            {
                return (double)Economics.CallHook("Balance", playerId.ToString());
            }
            else if (useServerRewards)
            {
                return (int)(ServerRewards.CallHook("CheckPoints", playerId) ?? 0.0);
            }
            return 0.0;
        }

        bool Withdraw(ulong playerId, double amount)
        {
            if (useEconomics)
            {
                return (bool)Economics.CallHook("Withdraw", playerId.ToString(), amount);
            }
            else if (useServerRewards)
            {
                return (bool)ServerRewards.CallHook("TakePoints", playerId, (int)amount);
            }
            return false;
        }

        bool Deposit(ulong playerId, double amount)
        {
            if (useEconomics)
            {
                Economics.CallHook("Deposit", playerId.ToString(), amount);
                return true;
            }
            else if (useServerRewards)
            {
                return (bool)ServerRewards.Call("AddPoints", new object[] { playerId, (int)amount });
            }
            return false;
        }

        bool Transfer(ulong fromId, ulong toId, double amount)
        {
            if (useEconomics)
            {
                return (bool)Economics.CallHook("Transfer", fromId.ToString(), toId.ToString(), amount);
            }
            else if (useServerRewards)
            {
                if (Withdraw(fromId, amount))
                {
                    bool result = Deposit(toId, amount);
                    if (!result)
                        Deposit(fromId, amount); // if transfer failed, refund
                    return result;
                }
            }
            return false;
        }

        #endregion

        #region Subclasses

        // config/data container
        class VendingData
        {
            public Dictionary<Option, object> config = new Dictionary<Option, object>();
            public Dictionary<DamageType, float> resistances;
            public Dictionary<string, SellOrderTemplate> templates;

            public string GetTemplateList()
            {
                string list = string.Join(", ", templates.Keys.ToArray());
                if (list == null || list == "")
                    list = "(empty)";
                return list;
            }

            public void SetResistances(float[] amounts)
            {
                resistances = new Dictionary<DamageType, float>();
                for (int i = 0; i < amounts.Length; i++)
                    resistances[(DamageType)i] = amounts[i];
            }

            public float[] GetResistances()
            {
                float[] values = new float[30];
                if (resistances != null)
                    foreach (KeyValuePair<DamageType, float> entry in resistances)
                        values[(int)entry.Key] = entry.Value;
                return values;
            }
        }

        // helper class for building sell order entries
        class SellOrderTemplate
        {
            public List<SellOrderEntry> entries = new List<SellOrderEntry>();

            public void PopulateTemplate(List<ProtoBuf.VendingMachine.SellOrder> sellOrders)
            {
                if (sellOrders == null) return;
                foreach (ProtoBuf.VendingMachine.SellOrder o in sellOrders)
                    AddSellOrder(o);
            }

            public void AddSellOrder(ProtoBuf.VendingMachine.SellOrder o)
            {
                if (o == null) return;
                SellOrderEntry e = new SellOrderEntry();
                e.itemToSellName = ItemManager.FindItemDefinition(o.itemToSellID).shortname;
                e.itemToSellAmount = o.itemToSellAmount;
                e.currencyName = ItemManager.FindItemDefinition(o.currencyID).shortname;
                e.currencyAmountPerItem = o.currencyAmountPerItem;
                e.itemToSellIsBP = o.itemToSellIsBP;
                e.currencyIsBP = o.currencyIsBP;
                entries.Add(e);
            }

            public bool Empty()
            {
                return (entries == null || entries.Count == 0);
            }
        }

        // simple sell order entry container
        struct SellOrderEntry
        {
            public string itemToSellName;
            public int itemToSellAmount;
            public string currencyName;
            public int currencyAmountPerItem;
            public bool itemToSellIsBP;
            public bool currencyIsBP;
        }

        struct LogEntry
        {
            public enum FailureReason { NoMoney, NoItems, Unknown }
            public NetworkableId id;
            public ulong playerID;
            public string playerName;
            public string bought;
            public string cost;
            public bool success;
            public bool isBuyOrder;
            public FailureReason reason;

            public override string ToString()
            {
                if (isBuyOrder)
                    return "VM " + id + ": " + playerName + " [" + playerID + "] " + (success ? "bought " : "failed to buy ") + bought + " for " + cost + (success ? "" : " - Reason: " + GetReason());
                else
                    return "VM " + id + ": " + playerName + " [" + playerID + "] " + (success ? "sold " : "failed to sell ") + bought + " for " + cost + (success ? "" : " - Reason: " + GetReason());
            }
            string GetReason()
            {
                if (reason == FailureReason.NoItems)
                    return "Not enough currency items";
                if (reason == FailureReason.NoMoney)
                    return "Not enough money";
                return "Unknown reason";
            }
        }

        class VendingMachineInfo
        {
            [Flags]
            public enum VMFlags
            {
                None = 0,
                Bottomless = 1,
                Immortal = 1 << 1,
                Restricted = 1 << 2,
                LogTransactions = 1 << 3
            }
            public ulong id;
            [JsonConverter(typeof(StringEnumConverter))]
            public VMFlags flags;
            public bool HasFlag(VMFlags flag) => (flags & flag) == flag;
        }

        // Lock details container
        class LockInfo
        {
            static readonly byte[] entropy = new byte[] { 11, 7, 5, 3 };
            public ulong vmId;
            public bool isCodeLock = false;
            public string codeEncrypted;
            [JsonIgnore]
            public string code
            {
                get
                {
                    return Shift(codeEncrypted, -4);
                }
                set
                {
                    codeEncrypted = Shift(value, 4);
                }
            }
            public string guestCodeEncrypted;
            [JsonIgnore]
            public string guestCode
            {
                get
                {
                    return Shift(guestCodeEncrypted, -4);
                }
                set
                {
                    guestCodeEncrypted = Shift(value, 4);
                }
            }
            public List<ulong> whitelist;
            public List<ulong> guests;
            public int keyCode;
            public bool firstKey;
            public bool isLocked;

            public LockInfo() { }
            public LockInfo(ulong vmId, BaseLock l)
            {
                this.vmId = vmId;
                FromLock(l);
            }

            public void FromLock(BaseLock l)
            {
                if (l.GetType() == typeof(CodeLock))
                {
                    isCodeLock = true;
                    code = (l as CodeLock).code;
                    guestCode = (l as CodeLock).guestCode;
                    whitelist = (l as CodeLock).whitelistPlayers;
                    guests = (l as CodeLock).guestPlayers;
                }
                else if (l.GetType() == typeof(KeyLock))
                {
                    keyCode = (l as KeyLock).keyCode;
                    firstKey = (l as KeyLock).firstKeyCreated;
                }
                isLocked = l.IsLocked();
            }

            public void ToLock(ref BaseLock l)
            {
                if (l.GetType() == typeof(CodeLock))
                {
                    (l as CodeLock).code = code;
                    (l as CodeLock).guestCode = guestCode;
                    (l as CodeLock).whitelistPlayers = whitelist;
                    (l as CodeLock).guestPlayers = guests;
                }
                else if (l.GetType() == typeof(KeyLock))
                {
                    (l as KeyLock).keyCode = keyCode;
                    (l as KeyLock).firstKeyCreated = firstKey;
                }
                l.SetFlag(BaseEntity.Flags.Locked, isLocked);
            }

            // simple obfuscation for codes
            static string Shift(string source, int shift)
            {
                int maxChar = Convert.ToInt32(char.MaxValue);
                int minChar = Convert.ToInt32(char.MinValue);

                char[] buffer = source.ToCharArray();

                for (int i = 0; i < buffer.Length; i++)
                {
                    int shifted = Convert.ToInt32(buffer[i]) + (shift * entropy[i]);

                    if (shifted > maxChar)
                    {
                        shifted -= maxChar;
                    }
                    else if (shifted < minChar)
                    {
                        shifted += maxChar;
                    }

                    buffer[i] = Convert.ToChar(shifted);
                }

                return new string(buffer);
            }
        }

        #endregion
    }
}

// --- End of file: VendingManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/vote-for-money ---
// --- Original File Path: V/VoteForMoney/VoteForMoney.cs ---

﻿using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("VoteForMoney", "Frenk92", "1.0.7")]
    class VoteForMoney : RustPlugin
    {
        [PluginReference]
        Plugin Economics, ServerRewards, Kits;

        DateTime wipeTime;
        const string permAdmin = "voteformoney.admin";

        #region Sites

        class SiteLinks
        {
            public string _vote { get; set; }
            public string _get { get; set; }
            public string _put { get; set; }
        }

        Dictionary<string, SiteLinks> Site = new Dictionary<string, SiteLinks>
        {
            {
                "Rust-Servers",
                new SiteLinks
                {
                    _vote = "http://rust-servers.net/server/",
                    _get = "http://rust-servers.net/api/?action=custom&object=plugin&element=reward&key={0}&steamid={1}",
                    _put = ""
                }
            },
            {
                "TopRustServers",
                new SiteLinks
                {
                    _vote = "http://toprustservers.com/",
                    _get = "http://api.toprustservers.com/api/get?plugin=voter&key={0}&uid={1}",
                    _put = "http://api.toprustservers.com/api/put?plugin=voter&key={0}&uid={1}"
                }
            },
            {
                "TrackyServer",
                new SiteLinks
                {
                    _vote = "https://trackyserver.com/server/",
                    _get = "http://www.api.trackyserver.com/vote/?action=status&key={0}&steamid={1}",
                    _put = "http://www.api.trackyserver.com/vote/?action=claim&key={0}&steamid={1}"
                }
            }
        };

        #endregion

        #region Config

        ConfigData _config;

        class ConfigData
        {
            public bool InitCheck { get; set; }
            public bool AllGroupsGetDefault { get; set; }
            public string Prefix { get; set; }
            public string BlockVote { get; set; }

            public static ConfigData DefaultConfig()
            {
                return new ConfigData
                {
                    InitCheck = true,
                    AllGroupsGetDefault = false,
                    Prefix = "<color=#808000ff><b>VoteForMoney:</b></color>",
                    BlockVote = "0.6"
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning(Lang("NoConfig"));
            _config = ConfigData.DefaultConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Data

        Dictionary<ulong, PlayerVote> Users = new Dictionary<ulong, PlayerVote>();
        class PlayerVote
        {
            public string Name { get; set; }
            public Dictionary<string, SitesVote> Sites { get; set; }

            public PlayerVote(string Name)
            {
                this.Name = Name;
                Sites = new Dictionary<string, SitesVote>();
            }
        }

        class SitesVote
        {
            public int Votes { get; set; }
            public string ExpDate { get; set; }
            public List<string> KitsNotClaimed { get; set; }

            public SitesVote()
            {
                Votes = 0;
                ExpDate = DateTime.Now.ToString();
                KitsNotClaimed = new List<string>();
            }
        }

        RewardsData Rewards;
        class RewardsData
        {
            public Dictionary<string, Dictionary<string, string>> Groups { get; set; }
            public Dictionary<int, Dictionary<string, string>> TopVoters { get; set; } //Coming Soon

            public static RewardsData DefaultRewards()
            {
                return new RewardsData
                {
                    Groups = new Dictionary<string, Dictionary<string, string>>
                {
                    { "default.1" , new Dictionary<string, string>
                        {
                            ["money"] = "250",
                            ["rp"] = "30",
                            ["kit"] = ""
                        }
                    },
                    { "default.2", new Dictionary<string, string>() },
                    { "vip.1", new Dictionary<string, string>() }
                },
                    TopVoters = new Dictionary<int, Dictionary<string, string>>
                {
                    { 1, new Dictionary<string, string>
                        {
                            ["money"] = "1000",
                            ["rp"] = "100",
                            ["kit"] = ""
                        }
                    },
                    { 2, new Dictionary<string, string>() },
                    { 3, new Dictionary<string, string>() }
                }
                };
            }
        }

        Dictionary<string, SiteSettings> Settings = new Dictionary<string, SiteSettings>();
        class SiteSettings
        {
            public string ID { get; set; }
            public string Key { get; set; }
            public string Interval { get; set; }

            public SiteSettings()
            {
                ID = "";
                Key = "";
                Interval = "1.0";
            }
        }

        string FileDestination(string name) => string.Format($"{Title}/{name}");
        private void LoadData<T>(ref T data, string filename) { var file = FileDestination(filename); data = Interface.Oxide.DataFileSystem.ReadObject<T>(file); }
        private void SaveData<T>(T data, string filename) { var file = FileDestination(filename); Interface.Oxide.DataFileSystem.WriteObject(file, data); }

        #endregion

        #region Hooks

        void Loaded()
        {
            AddCovalenceCommand("editvote", "cmdEditVote", permAdmin);
            AddCovalenceCommand("vr", "cmdVoteRewards", permAdmin);

            //Load Data
            var fileSystem = Interface.Oxide.DataFileSystem;

            if (!fileSystem.ExistsDatafile(FileDestination("Rewards")))
            {
                Rewards = RewardsData.DefaultRewards();
                SaveData(Rewards, "Rewards");
            }
            else
                LoadData(ref Rewards, "Rewards");

            if (!fileSystem.ExistsDatafile(FileDestination("Sites")))
            {
                foreach (var s in Site.Keys)
                    Settings.Add(s, new SiteSettings());
                SaveData(Settings, "Sites");
            }
            else
                LoadData(ref Settings, "Sites");

            LoadData(ref Users, "VoteData");
            DataCheck();
        }

        void OnNewSave(string name)
        {
            foreach (var p in Users.Values)
                foreach (var s in p.Sites.Values)
                {
                    s.Votes = 0;
                    s.KitsNotClaimed = new List<string>();
                }

            SaveData(Users, "VoteData");
        }

        private void OnServerInitialized()
		{
            WipeCooldown();
		}

        List<ulong> Join = new List<ulong>();

        void OnPlayerInit(BasePlayer player)
        {
            if (_config.InitCheck && !Join.Contains(player.userID)) Join.Add(player.userID);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_config.InitCheck && Join.Contains(player.userID)) Join.Remove(player.userID);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (_config.InitCheck && Join.Contains(player.userID))
            {
                CheckVote(player);
                Join.Remove(player.userID);
            }
        }

        #endregion

        #region Commands

        #region Chat

        [ChatCommand("vote")]
        void cmdVote(BasePlayer player, string command, string[] args)
        {
            if (WipeBlocked(player)) return;
            CheckVote(player);
        }

        [ChatCommand("claimkit")]
        void cmdClaimKit(BasePlayer player, string command, string[] args)
        {
            if (WipeBlocked(player)) return;

            var userData = GetPlayerData(player.userID, SteamName(player));

            var i = 0;
            var error = false;
            foreach (var s in Site)
            {
                if (error) break;
                List<string> list = new List<string>(userData.Sites[s.Key].KitsNotClaimed);
                if (list.Count() > 0)
                {
                    foreach (var kit in list)
                    {
                        var flag = Kits?.Call("CanRedeemKit", player, kit, true);
                        if (flag is string || flag == null)
                        {
                            error = true;
                            break;
                        }
                        var succecss = Kits?.Call("GiveKit", player, kit);
                        if (succecss is string || succecss == null)
                        {
                            error = true;
                            break;
                        }
                        userData.Sites[s.Key].KitsNotClaimed.Remove(kit);
                    }
                }
                else ++i;
            }

            if (i == 3)
                MessageChat(player, "AlreadyClaimed");
            else if (error)
                MessageChat(player, "ErrorKit");
            else
            {
                MessageChat(player, "RewardKit");
                SaveData(Users, "VoteData");
            }
        }

        #endregion

        #region Editor

        void cmdEditVote(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0) return;

            for(var i = 0; i < args.Length; i++)
            {
                var error = "";
                var param = args[i].ToLower();
                var value = "";
                switch (param)
                {
                    case "check":
                        {
                            var flag = false;
                            if (args.Length > i + 1 && bool.TryParse(args[i + 1], out flag))
                            {
                                _config.InitCheck = flag;
                                ++i;
                            }
                            else
                                _config.InitCheck = !_config.InitCheck;
                            value = _config.InitCheck.ToString();
                            break;
                        }
                    case "alldefault":
                        {
                            var flag = false;
                            if (args.Length > i + 1 && bool.TryParse(args[i + 1], out flag))
                            {
                                _config.AllGroupsGetDefault = flag;
                                ++i;
                            }
                            else
                                _config.AllGroupsGetDefault = !_config.AllGroupsGetDefault;
                            value = _config.AllGroupsGetDefault.ToString();
                            break;
                        }
                    case "prefix":
                        {
                            if (args.Length == i + 1)
                                error = Lang("MissingArg", player.Id);
                            else
                                _config.Prefix = value = args[++i];
                            break;
                        }
                    case "block":
                        {
                            if (args.Length == i + 1)
                            {
                                error = Lang("MissingArg", player.Id);
                                break;
                            }
                            var f = args[++i].Split('.');
                            if (f.Length == 2 && f[0].All(char.IsDigit) && f[1].All(char.IsDigit))
                            {
                                _config.BlockVote = value = args[i];
                                WipeCooldown();
                            }
                            else
                                error = Lang("InvalidValue", player.Id, args[i]);
                            break;
                        }
                    default:
                        {
                            error = Lang("InvalidArg", player.Id, param);
                            break;
                        }
                }

                if (error != "")
                    player.Reply(error);
                else
                {
                    player.Reply(Lang("Edited", player.Id, param, value));
                    SaveConfig();
                }
            }
        }

        string _group = "";

        void cmdVoteRewards(IPlayer player, string command, string[] args)
        {
            if (args.Length < 2)
            {
                player.Reply(Lang("MissingArg", player.Id));
                return;
            }

            var msg = "";
            var error = "";
            switch (args[0].ToLower())
            {
                case "add":
                    {
                        if (args.Length < 3)
                        {
                            error = Lang("MissingArg", player.Id);
                            break;
                        }

                        var p = args[1].ToLower();
                        if (p == "group")
                        {
                            var x = args[2].Split('.');
                            if (x.Length < 2 || !x[1].All(char.IsDigit))
                            {
                                error = Lang("InvalidValue", player.Id, args[2]);
                            }
                            else if (!permission.GroupExists(x[0]))
                            {
                                error = Lang("NoGroup", player.Id, x[0]);
                            }
                            else
                            {
                                Rewards.Groups.Add(args[2], new Dictionary<string, string>());
                                _group = args[2];
                                msg = Lang("GroupAdded", player.Id, args[2]);
                            }
                        }
                        else
                        {
                            if (_group == "")
                            {
                                error = Lang("NotSelected", player.Id);
                                break;
                            }

                            var rg = Rewards.Groups[_group];
                            if (rg.ContainsKey(p) || (p == "cmd" && rg.ContainsKey(args[2])))
                            {
                                error = Lang("AlreadyExists", player.Id);
                                break;
                            }
                            switch (p)
                            {
                                case "money":
                                    {
                                        if (!Economics)
                                        {
                                            error = Lang("NoPlugin", player.Id, "Economics");
                                            break;
                                        }
                                        if (!args[2].All(char.IsDigit))
                                            error = Lang("InvalidValue", player.Id, args[2]);
                                        else
                                            rg.Add("money", args[2]);
                                        break;
                                    }
                                case "rp":
                                    {
                                        if (!ServerRewards)
                                        {
                                            error = Lang("NoPlugin", player.Id, "ServerRewards");
                                            break;
                                        }
                                        if (!args[2].All(char.IsDigit))
                                            error = Lang("InvalidValue", player.Id, args[2]);
                                        else
                                            rg.Add("rp", args[2]);
                                        break;
                                    }
                                case "kit":
                                    {
                                        if (!Kits)
                                        {
                                            error = Lang("NoPlugin", player.Id, "Rust Kits");
                                            break;
                                        }
                                        var flag = (bool)Kits?.Call("isKit", args[2]);
                                        if (!flag)
                                            error = Lang("NoKit", player.Id, args[2]);
                                        else
                                            rg.Add("kit", args[2]);
                                        break;
                                    }
                                case "cmd":
                                    {
                                        if (args.Length < 4)
                                            error = Lang("MissingArg", player.Id);
                                        else
                                        {
                                            rg.Add(args[2], args[3]);
                                            p = args[2];
                                        }
                                        break;
                                    }
                                default:
                                    {
                                        error = Lang("InvalidArg", player.Id, args[1]);
                                        break;
                                    }
                            }
                            if (error == "")
                                msg = Lang("RewardAdded", player.Id, p);
                        }
                        break;
                    }
                case "remove":
                    {
                        var p = args[1].ToLower();
                        if (p == "group")
                        {
                            if (args.Length < 3)
                            {
                                error = Lang("MissingArg", player.Id);
                                break;
                            }

                            if (!Rewards.Groups.ContainsKey(args[2]))
                                error = Lang("NotFound", player.Id, args[2]);
                            else
                            {
                                Rewards.Groups.Remove(args[2]);
                                if (_group == args[2]) _group = "";
                                msg = Lang("GroupRemoved", player.Id, args[2]);
                            }
                        }
                        else
                        {
                            if (_group == "")
                            {
                                error = Lang("NotSelected", player.Id);
                                break;
                            }

                            var rg = Rewards.Groups[_group];
                            if (p == "cmd")
                            {
                                if (args.Length < 3)
                                    error = Lang("MissingArg", player.Id);
                                else if (!rg.ContainsKey(args[2]))
                                    error = Lang("NoReward", player.Id, args[2]);
                                else
                                {
                                    rg.Remove(args[2]);
                                    p = args[2];
                                }
                            }
                            else
                            {
                                if (!rg.ContainsKey(p))
                                {
                                    error = Lang("NoReward", player.Id, p);
                                    break;
                                }
                                switch (p)
                                {
                                    case "money":
                                        {
                                            rg.Remove("money");
                                            break;
                                        }
                                    case "rp":
                                        {
                                            rg.Remove("rp");
                                            break;
                                        }
                                    case "kit":
                                        {
                                            rg.Remove("kit");
                                            break;
                                        }
                                    default:
                                        {
                                            error = Lang("InvalidArg", player.Id, args[1]);
                                            break;
                                        }
                                }
                            }
                            if (error == "")
                                msg = Lang("RewardRemoved", player.Id, p);
                        }
                        break;
                    }
                case "edit":
                    {
                        if (args.Length < 3)
                        {
                            error = Lang("MissingArg", player.Id);
                            break;
                        }
                        if (_group == "")
                        {
                            error = Lang("NotSelected", player.Id);
                            break;
                        }

                        var p = args[1].ToLower();
                        var rg = Rewards.Groups[_group];
                        if (p == "cmd")
                        {
                            if (args.Length < 4)
                                error = Lang("MissingArg", player.Id);
                            else if (!rg.ContainsKey(args[2]))
                                error = Lang("NoReward", player.Id, args[2]);
                            else
                            {
                                rg[args[2]] = args[3];
                                msg = Lang("Edited", player.Id, args[2], args[3]);
                            }
                        }
                        else
                        {
                            if (!rg.ContainsKey(p))
                            {
                                error = Lang("NoReward", player.Id, p);
                                break;
                            }
                            switch (p)
                            {
                                case "money":
                                    {
                                        if (!args[2].All(char.IsDigit))
                                            error = Lang("InvalidValue", player.Id, args[2]);
                                        else
                                            rg["money"] = args[2];
                                        break;
                                    }
                                case "rp":
                                    {
                                        if (!args[2].All(char.IsDigit))
                                            error = Lang("InvalidValue", player.Id, args[2]);
                                        else
                                            rg["rp"] = args[2];
                                        break;
                                    }
                                case "kit":
                                    {
                                        var flag = (bool)Kits?.Call("isKit", args[2]);
                                        if (!flag)
                                            error = Lang("NoKit", player.Id, args[2]);
                                        else
                                            rg["kit"] = args[2];
                                        break;
                                    }
                                default:
                                    {
                                        error = Lang("InvalidArg", player.Id, args[1]);
                                        break;
                                    }
                            }
                            if (error == "")
                                msg = Lang("Edited", player.Id, args[1], args[2]);
                        }
                        break;
                    }
                case "set":
                    {
                        if (!Rewards.Groups.ContainsKey(args[1]))
                            error = Lang("NotFound", player.Id, args[1]);
                        else
                        {
                            _group = args[1];
                            msg = Lang("Selected", player.Id, args[1]);
                        }
                        break;
                    }
                case "list":
                    {
                        switch (args[1].ToLower())
                        {
                            case "groups":
                                msg = Lang("GroupsList", player.Id, string.Join(", ", Rewards.Groups.Keys));
                                break;
                            case "rewards":
                                if (_group == "")
                                {
                                    error = Lang("NotSelected", player.Id);
                                    break;
                                }
                                var list = new StringBuilder();
                                foreach (var r in Rewards.Groups[_group])
                                    list.Append($"\n{r.Key}: {r.Value}");
                                msg = Lang("RewardsList", player.Id, _group, list.ToString());
                                break;
                            default:
                                {
                                    error = Lang("InvalidArg", player.Id, args[1]);
                                    break;
                                }
                        }
                        break;
                    }
                default:
                    {
                        error = Lang("InvalidArg", player.Id, args[0]);
                        break;
                    }
            }

            if (error != "")
                player.Reply(error);
            else
            {
                SaveData(Rewards, "Rewards");
                player.Reply(msg);
            }
        }

        #endregion

        #endregion

        #region Methods

        void CheckVote(BasePlayer player)
        {
            var userData = GetPlayerData(player.userID, SteamName(player));
            
            var time = DateTime.Now;
            foreach(var s in Site)
            {
                if(Settings[s.Key].Key != "")
                {
                    var expdate = Convert.ToDateTime(userData.Sites[s.Key].ExpDate);
                    if (time < expdate)
                    {
                        MessageChat(player, "AlreadyVoted", s.Key);
                        MessageChat(player, "NextVote", expdate);
                    }
                    else
                        GetWebRequest(player.UserIDString, s.Value._get, Settings[s.Key].Key, (code, response) => GetCallback(code, response, player, s));
                }
            }
        }

        void GetCallback(int code, string response, BasePlayer player, KeyValuePair<string, SiteLinks> s)
        {
            if (response == null || code != 200)
            {
                Puts(Lang("ConsNoAnswer", null, code, s.Key));
                MessageChat(player, "NoAnswer", s.Key);
                return;
            }

            switch (response)
            {
                case "0":
                    {
                        MessageChat(player, "NoVote", s.Key, s.Value._vote, Settings[s.Key].ID);
                        break;
                    }
                case "1":
                    {
                        if (s.Value._put != "")
                            GetWebRequest(player.UserIDString, s.Value._put, Settings[s.Key].Key, (putcode, putresp) => PutCallback(putcode, putresp, player, s));
                        else
                            GetReward(player, s.Key);
                        break;
                    }
                case "2":
                    {
                        MessageChat(player, "AlreadyVoted", s.Key);
                        break;
                    }
            }
        }

        void PutCallback(int code, string response, BasePlayer player, KeyValuePair<string, SiteLinks> s)
        {
            if (response == null || code != 200)
            {
                Puts(Lang("ConsNoAnswer", null, code, s.Key));
                MessageChat(player, "NoAnswer", s.Key);
                return;
            }

            if (response == "1") GetReward(player, s.Key);
        }

        void GetReward(BasePlayer player, string s)
        {
            MessageChat(player, "Thanks", s);

            var userData = GetPlayerData(player.userID, SteamName(player));
            userData.Sites[s].Votes++;
            if (userData.Sites[s].KitsNotClaimed.Count > 0) userData.Sites[s].KitsNotClaimed.Clear();

            var getdefault = true;
            foreach (var key in Rewards.Groups.Keys)
            {
                var g = key.Split('.')[0];
                if (g == "default") continue;
                if (permission.UserHasGroup(player.UserIDString, g))
                {
                    getdefault = false;
                    break;
                }
            }

            var totmoney = 0;
            var totrp = 0;
            var kit = false;
            var kiterror = false;
            List<string> commands = new List<string>();
            foreach(var g in Rewards.Groups)
            {
                if (g.Value.Count == 0) continue;
                var args = g.Key.Split('.');
                if ((args[0] == "default" && !getdefault && !_config.AllGroupsGetDefault)
                    || !permission.UserHasGroup(player.UserIDString, args[0])) continue;
                if (!permission.GroupExists(args[0]))
                {
                    PrintWarning(Lang("NoGroup", null, args[0]));
                    continue;
                }
                var m = 0;
                if(args.Length <= 1 || !int.TryParse(args[1], out m))
                {
                    PrintWarning(Lang("InvalidReward", null, g.Key));
                    continue;
                }
                if (userData.Sites[s].Votes < m || (userData.Sites[s].Votes % m) != 0) continue;

                foreach (var r in g.Value)
                {
                    switch(r.Key)
                    {
                        case "money":
                            {
                                if (!Economics) break;
                                var eco = Convert.ToDouble(r.Value);
                                Economics.Call("Deposit", player.userID, eco);
                                totmoney += Convert.ToInt32(r.Value);
                                break;
                            }
                        case "rp":
                            {
                                if (!ServerRewards) break;
                                var p = Convert.ToInt32(r.Value);
                                ServerRewards.Call("AddPoints", new object[] { player.userID, p });
                                totrp += Convert.ToInt32(r.Value);
                                break;
                            }
                        case "kit":
                            {
                                if (!Kits || r.Value == "") break;
                                var flag = Kits?.Call("CanRedeemKit", player, r.Value, true);
                                if (flag is string || flag == null || kiterror)
                                {
                                    if (!kiterror) kiterror = true;
                                    userData.Sites[s].KitsNotClaimed.Add(r.Value);
                                }
                                else
                                {
                                    var success = Kits?.Call("GiveKit", player, r.Value);
                                    if (success is string || success == null)
                                    {
                                        kiterror = true;
                                        userData.Sites[s].KitsNotClaimed.Add(r.Value);
                                    }
                                    else if (!kit) kit = true;
                                }
                                break;
                            }
                        default:
                            {
                                rust.RunServerCommand(r.Value.Replace("$player.id", player.UserIDString).Replace("$player.name", player.displayName));
                                if (!commands.Contains(r.Key)) commands.Add(r.Key);
                                break;
                            }
                    }
                }
            }

            if(totmoney > 0) MessageChat(player, "RewardCoins", totmoney);
            if(totrp > 0) MessageChat(player, "RewardRP", totrp);
            if(kiterror) MessageChat(player, "ErrorKits");
            else if(kit) MessageChat(player, "RewardKit");
            foreach (var c in commands) MessageChat(player, "RewardCommand", c);

            try
            {
                var i = Settings[s].Interval.Split('.').Select(n => Convert.ToInt32(n)).ToArray();
                var newdate = DateTime.Now + new TimeSpan(i[0], i[1], 0, 0);
                userData.Sites[s].ExpDate = newdate.ToString();
                SaveData(Users, "VoteData");
            }
            catch
            {
                MessageChat(player, "InvalidInterval");
                var newdate = DateTime.Now + new TimeSpan(1, 0, 0, 0);
                userData.Sites[s].ExpDate = newdate.ToString();
                SaveData(Users, "VoteData");
            }
        }

        void GetWebRequest(string userID, string reqlink, string key, Action<int, string> callback) => webrequest.Enqueue(string.Format(reqlink, key, userID), null, callback, this);

        #endregion

        #region Utility

        PlayerVote GetPlayerData(ulong userID, string name)
        {
            PlayerVote userData;
            if (!Users.TryGetValue(userID, out userData))
            {
                Users[userID] = userData = new PlayerVote(name);
                foreach (var s in Site.Keys) userData.Sites.Add(s, new SitesVote());
                SaveData(Users, "VoteData");
            }
            return userData;
        }

        bool WipeBlocked(BasePlayer player)
        {
            var tm = wipeTime - DateTime.UtcNow;
            if (tm < TimeSpan.Zero) return false;
            var p = (int)tm.TotalDays;
            var key = "DaysFormat";
            if (tm.TotalDays < 1)
            {
                if (tm.TotalHours < 1)
                {
                    if (tm.TotalMinutes < 1)
                    {
                        key = "SecondsFormat";
                        p = (int)tm.TotalSeconds;
                    }
                    else
                    {
                        key = "MinutesFormat";
                        p = (int)tm.TotalMinutes;
                    }
                }
                else
                {
                    key = "HoursFormat";
                    p = (int)tm.TotalHours;
                }
            }

            MessageChat(player, key, p);
            return true;
        }

        void WipeCooldown()
        {
            var i = _config.BlockVote.Split('.').Select(n => Convert.ToInt32(n)).ToArray();
            wipeTime = SaveRestore.SaveCreatedTime + new TimeSpan(i[0], i[1], 0, 0);
        }

        void DataCheck()
        {
            var f = false;
            if (Settings.Count != Site.Count) f = true;
            else
                foreach (var s in Site.Keys)
                    if (!Settings.ContainsKey(s)) f = true;

            if (f)
            {
                var sc = new Dictionary<string, SiteSettings>(Settings);
                Settings = new Dictionary<string, SiteSettings>();
                foreach (var s in Site.Keys)
                {
                    if (sc.ContainsKey(s)) Settings.Add(s, sc[s]);
                    else Settings.Add(s, new SiteSettings());
                }
                SaveData(Settings, "Sites");

                var dc = new Dictionary<ulong, PlayerVote>(Users);
                Users = new Dictionary<ulong, PlayerVote>();
                foreach (var u in dc)
                {
                    PlayerVote pv;
                    Users[u.Key] = pv = new PlayerVote(u.Value.Name);
                    foreach (var s in Site.Keys)
                    {
                        if (u.Value.Sites.ContainsKey(s)) pv.Sites.Add(s, u.Value.Sites[s]);
                        else pv.Sites.Add(s, new SitesVote());
                    }
                }
                SaveData(Users, "VoteData");
            }
        }

        string SteamName(BasePlayer player) => player.net.connection.username;

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Thanks"] = "Thanks for voting on {0}",
                ["RewardCoins"] = "Coins reward: {0}",
                ["RewardRP"] = "RP reward: {0}",
                ["RewardKit"] = "All Kits rewarded.",
                ["RewardCommand"] = "{0} rewarded.",
                ["NextVote"] = "Next Vote: {0}",
                ["NoVote"] = "You have not voted yet on {0}.\nLink to vote: {1}{2}",
                ["AlreadyVoted"] = "You have already voted on {0}.",
                ["AlreadyClaimed"] = "You have already claimed all kits.",
                ["AlreadyExists"] = "This reward already exists.",
                ["Edited"] = "\"{0}\" edited to: {1}",
                ["Selected"] = "Group \"{0}\" has been selected.",
                ["GroupAdded"] = "Group \"{0}\" has been added.",
                ["GroupRemoved"] = "Group \"{0}\" has been removed.",
                ["RewardAdded"] = "Reward \"{0}\" has been added.",
                ["RewardRemoved"] = "Reward \"{0}\" has been removed.",
                ["GroupsList"] = "Groups list: {0}",
                ["RewardsList"] = "\"{0}\" rewards list: {1}",
                ["NoPlugin"] = "Plugin \"{0}\" not loaded.",
                ["NoGroup"] = "Group \"{0}\" doesn't exist.",
                ["NoKit"] = "Kit \"{0}\" doesn't exist.",
                ["NoReward"] = "Reward \"{0}\" not found.",
                ["NotFound"] = "Group \"{0}\" not found.",
                ["NotSelected"] = "Group not selected. Use \"/vr set\" to select one (Example: /vr set default.1).",
                ["NoAnswer"] = "No answer from {0}. Try later.",
                ["NoConfig"] = "Could not read config file. Creating new one...",
                ["ConsNoAnswer"] = "Error: {0} - Couldn't get an answer from {1}",
                ["MissingArg"] = "One or more arguments are missing.",
                ["ErrorBool"] = "Error. Only 'true' or 'false'.",
                ["ErrorKits"] = "Not all kits have been redeemed. Empty the inventory and redeem them with \"/claimkit\".",
                ["InvalidReward"] = "\"{0}\" is an invalid reward.",
                ["InvalidArg"] = "\"{0}\" is an invalid argument.",
                ["InvalidValue"] = "\"{0}\" is an invalid value.",
                ["SecondsFormat"] = "The vote is blocked for {0} second/s.",
                ["MinutesFormat"] = "The vote is blocked for {0} minute/s.",
                ["HoursFormat"] = "The vote is blocked for {0} hour/s.",
                ["DaysFormat"] = "The vote is blocked for {0} day/s.",
                //["Help"] = "\n============== VOTE HELP =============\nType: /editvote \"COMMAND\" \"VALUE\" (Example: /editvote check true)\n============== VOTE HELP =============",
            }, this);
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        void MessageChat(BasePlayer player, string key, params object[] args)
        {
            var msg = Lang(key, player.UserIDString, args);
            PrintToChat(player, $"{_config.Prefix} {msg}");
        }

        #endregion
    }
}


// --- End of file: VoteForMoney.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-hacker ---
// --- Original File Path: L/LootHacker/LootHacker.cs ---

﻿using UnityEngine;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;



namespace Oxide.Plugins
{
    [Info("Loot Hacker", "Zeeuss", "0.1.2")]
    [Description("Unlocks codelocks on storages")]
    public class LootHacker : RustPlugin
    {

        #region Init
        private const string PermissionUseCmnd = "loothacker.cmnd";
        private const string PermissionUseItem = "loothacker.item";

        private void Init()
        {
            permission.RegisterPermission(PermissionUseCmnd, this);
            permission.RegisterPermission(PermissionUseItem, this);
            if(!LoadConfigVariables())
            {
                return;
            }
        }

        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //FORMAT: {0} = storage short prefab name, {1} = seconds to unlock
                ["MustLookAtStorage"] = "You must be looking at a locked storage container to hack it!",
                ["NoPerms"] = "You don't have permission to use this!",
                ["UnlocksIn"] = "{0} will unlock in {1} secs",
                ["Unlocked"] = "Unlocked {0}"

            }, this);
        }
        #endregion

        #region Oxide Hook

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input == null)
            {
                return;
            }
            if (player == null)
            {
                return;
            }
            if(player.GetActiveItem() == null)
            {
                return;
            }
            // Check if player pressed PRIMARY hotkey & has targeting computer selected in hotbar
            if (input.WasJustPressed(BUTTON.FIRE_PRIMARY) && player.GetActiveItem().info.name == "targeting_computer.item")
            {

                if (!permission.UserHasPermission(player.UserIDString, PermissionUseItem))
                {
                    return;
                }
                
                RaycastHit hit;
                if (Physics.Raycast(player.eyes.HeadRay(), out hit, 3f, Layers))
                {
                    var storageContainer = hit.GetEntity()?.GetComponent<BaseEntity>() as StorageContainer;
                    if (storageContainer != null)
                    {

                        var codeLock = storageContainer.GetComponentInChildren<CodeLock>();

                        if (codeLock != null && codeLock.IsLocked())
                        {

                            SendReply(player, String.Format(lang.GetMessage("UnlocksIn", this, player.UserIDString), storageContainer.ShortPrefabName, configData.unlockTime.ToString()));
                            if(configData.consumeComp == true)
                            {
                                player.GetActiveItem().UseItem(1);
                            }
                            timer.Once(configData.unlockTime, () => {

                                codeLock.SetFlag(BaseEntity.Flags.Locked, false);
                                SendReply(player, String.Format(lang.GetMessage("Unlocked", this, player.UserIDString), storageContainer.ShortPrefabName));

                            });
                            

                        }
 
                    }
                    else
                    {
                        return;
                    }
                }
                else
                {
                    SendReply(player, lang.GetMessage("MustLookAtStorage", this, player.UserIDString));
                }
            }
            else
            {
                return;
            }
        }
        #endregion

        #region ChatCommand
        [ChatCommand("loothack")]
        private void UnlockCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUseCmnd))
            {
                SendReply(player, lang.GetMessage("NoPerms", this, player.UserIDString));
                return;
            }

            // Check if player is looking at a locked storage container
            RaycastHit hit;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, 3f, Layers))
            {
                var storageContainer = hit.GetEntity()?.GetComponent<BaseEntity>() as StorageContainer;
                if (storageContainer != null)
                {
                    
                    var codeLock = storageContainer.GetComponentInChildren<CodeLock>();
                    if (codeLock != null && codeLock.IsLocked())
                    {
                        codeLock.SetFlag(BaseEntity.Flags.Locked, false);

                    }

                    SendReply(player, String.Format(lang.GetMessage("Unlocked", this, player.UserIDString), storageContainer.ShortPrefabName));
                }
            }
            else
            {
                SendReply(player, lang.GetMessage("MustLookAtStorage", this, player.UserIDString));
            }
        }
        #endregion

        #region Config
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Seconds until storage unlocks")]
            public float unlockTime = 5f;

            [JsonProperty(PropertyName = "Consume Targeting Computer on use")]
            public bool consumeComp = true;
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData();
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Helper
        private static int Layers = LayerMask.GetMask("Construction", "Deployed");
        #endregion
    }

}

// --- End of file: LootHacker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-logs ---
// --- Original File Path: L/LootLogs/LootLogs.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using System.IO;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("LootLogs", "k1lly0u", "0.2.1"), Description("Log all items deposited and removed from storage, stash and oven containers")]
    class LootLogs : RustPlugin
    {
        #region Fields
        private readonly Hash<ItemId, LootData> m_TrackedItems = new Hash<ItemId, LootData>();
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnItemAddedToContainer));
            Unsubscribe(nameof(OnItemRemovedFromContainer));

            DeleteExpiredLogs();
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(OnItemAddedToContainer));
            Subscribe(nameof(OnItemRemovedFromContainer));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error.NoEntity"] = "No valid entity found!",
                ["Message.Details"] = "The box you are looking at is of the type: {0} with the ID: {1}. You can find the log for this box in 'oxide/logs/LootLogs/{0}/{2}_{1}.txt'"
            }, this);
        }

        private void OnEntityDeath(StorageContainer entity, HitInfo hitInfo)
        {
            if (!entity || hitInfo == null)
                return;

            DeathLog(entity.GetType().Name, 
                entity.PrefabName, 
                entity.net.ID.Value.ToString(), 
                entity.transform.position.ToString(), 
                hitInfo.InitiatorPlayer ? hitInfo.InitiatorPlayer.displayName : string.Empty);            
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item == null || !item.uid.IsValid)
                return;

            if (!container.entityOwner && !container.playerOwner)
                return;

            LootData lootData;
            if (!m_TrackedItems.TryGetValue(item.uid, out lootData))
                return;

            if (container.playerOwner && container.playerOwner.net != null)
                Log(container.playerOwner.displayName, $"{lootData.ItemAmount}x {lootData.ItemName}", lootData.Type, lootData.EntityID, lootData.EntityName, true);
            if (container.entityOwner && !(container.entityOwner is DroppedItemContainer) && container.entityOwner.net != null)
                Log(lootData.EntityName, $"{lootData.ItemAmount}x {lootData.ItemName}", container.entityOwner.GetType(), container.entityOwner.net.ID.Value, container.entityOwner.ShortPrefabName, false);

            m_TrackedItems.Remove(item.uid);
        }

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (item == null || !item.uid.IsValid)
                return;

            if (!container.entityOwner && !container.playerOwner)
                return;
            
            if (!m_TrackedItems.ContainsKey(item.uid))
            {
                m_TrackedItems.Add(item.uid, new LootData
                {
                    EntityName = container.entityOwner ? container.entityOwner.ShortPrefabName : container.playerOwner.displayName,
                    EntityID = container.entityOwner? container.entityOwner.net.ID.Value : container.playerOwner.userID,
                    ItemAmount = item.amount,
                    ItemName = item.info.displayName.english,
                    Type = container.entityOwner ? container.entityOwner.GetType() : typeof(BasePlayer)
                });

                timer.Once(5, () =>
                {
                    if (m_TrackedItems.ContainsKey(item.uid))
                        m_TrackedItems.Remove(item.uid);
                });
            }
        }

        private struct LootData
        {
            public string EntityName;
            public ulong EntityID;
            public string ItemName;
            public int ItemAmount;
            public Type Type;            
        }
        #endregion

        #region Raycasts
        private readonly RaycastHit[] m_RaycastHits = new RaycastHit[128];
        
        private BaseEntity FindEntity(BasePlayer player)
        {
            int hits = Physics.RaycastNonAlloc(player.eyes.HeadRay(), m_RaycastHits, 5f);

            if (hits > 0)
            {
                for (int i = 0; i < hits; i++)
                {
                    RaycastHit raycastHit = m_RaycastHits[i];

                    BaseEntity baseEntity = raycastHit.GetEntity();
                    if (baseEntity is StorageContainer)
                        return baseEntity;
                }
            }
            
            return null;
        }
        #endregion
        
        #region Logging
        private static readonly object _logFileLock = new object();
        
        private static readonly string _directory = Path.Combine(Interface.Oxide.LogDirectory, "LootLogs");
        
        private readonly Hash<string, Hash<string, List<string>>> m_QueuedLogs = new Hash<string, Hash<string, List<string>>>();
        
        private const string DESTROYED_CONTAINERS = "DestroyedContainers";

        private void QueueLogEntry(string path, string fileName, string text)
        {
            if (!m_QueuedLogs.ContainsKey(path))
                m_QueuedLogs.Add(path, new Hash<string, List<string>>());

            if (!m_QueuedLogs[path].ContainsKey(fileName))
                m_QueuedLogs[path].Add(fileName, new List<string>());

            m_QueuedLogs[path][fileName].Add(text);
        }

        private void OnServerSave()
        {
            try
            {
                foreach (KeyValuePair<string, Hash<string, List<string>>> path in m_QueuedLogs)
                {
                    foreach (KeyValuePair<string, List<string>> fileName in path.Value)
                    {
                        foreach (string text in fileName.Value)
                            LogToFile(path.Key, fileName.Key, text);

                        fileName.Value.Clear();
                    }
                }
            }
            catch(Exception ex)
            {
                PrintError($"{ex.Message}\n{ex.StackTrace}");
            }
        }
        
        private void Log(string playername, string item, Type type, ulong id, string entityname, bool take)
        {
            string path = Path.Combine(type.Name, DateTime.Now.ToString("yyyy-MM-dd"));
            string fileName = $"{entityname}_{id}";

            QueueLogEntry(path, fileName, $"{playername} {(take ? "looted" : "deposited")} {item}");
        }

        private void DeathLog(string type, string entityname, string id, string position, string killer)
        {
            string path = Path.Combine(DESTROYED_CONTAINERS, DateTime.Now.ToString("yyyy-MM-dd"), type);
            string fileName = $"DeathLog_{DateTime.Now.ToString("yyyy-MM-dd")}";

            QueueLogEntry(path, fileName, $"Name:{entityname} | BoxID:{id} | Position:{position} | Killer: {killer} | LogFile: oxide/logs/LootLogs/{type}/{DateTime.Now.ToString("yyyy-MM-dd")}/{entityname}_{id}.txt");      
        }

        private void LogToFile(string path, string filename, string text)
        {
            path = Path.Combine(_directory, path);
            
            if (!Directory.Exists(path))
                Directory.CreateDirectory(path);
            
            filename = filename.ToLower() + ".txt";
            
            lock (_logFileLock)
            {
                using (FileStream fileStream = new FileStream(Path.Combine(path, Utility.CleanPath(filename)), FileMode.Append, FileAccess.Write, FileShare.Read))
                {
                    using (StreamWriter streamWriter = new StreamWriter(fileStream, Encoding.UTF8))
                        streamWriter.WriteLine(text);
                }
            }
        }

        private void DeleteExpiredLogs()
        {
            if (configData.DeleteAfterDays <= 0)
                return;
            
            if (!Directory.Exists(_directory))
                return;
            
            string[] directories = Directory.GetDirectories(_directory, "*", SearchOption.TopDirectoryOnly);

            foreach (string subDirectory in directories)
                DeleteExpiredLogFolders(subDirectory);
        }

        private void DeleteExpiredLogFolders(string subDirectory)
        {
            string[] dateDirectories = Directory.GetDirectories(subDirectory, "*", SearchOption.TopDirectoryOnly);

            for (int i = 0; i < dateDirectories.Length; i++)
            {
                string date = Path.GetFileNameWithoutExtension(dateDirectories[i]);

                try
                {
                    DateTime dt = DateTime.ParseExact(date, "yyyy-MM-dd", CultureInfo.InvariantCulture);
                    if (DateTime.Now - dt > TimeSpan.FromDays(7))
                    {
                        Directory.Delete(dateDirectories[i], true);
                    }
                }
                catch(Exception ex){}
            }
        }

        [ConsoleCommand("testlog")]
        private void ConsoleCommandTestLog(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;
            
            Log("string 1", "string 2", typeof(StorageContainer), 72223441141414, "string 5", false);
            DeathLog("strings", "name", "id", "position", "killer");
            OnServerSave();
        }
        #endregion

        #region Chat Commands
        [ChatCommand("findid")]
        private void cmdFindID(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
                return;

            BaseEntity entity = FindEntity(player);
            if (entity is StorageContainer)
                FormatString(player, "Message.Details", entity.GetType(), entity.net.ID.Value, entity.ShortPrefabName);
            else TranslatedString(player, "Error.NoEntity");
        }
        #endregion

        #region Messaging
        private void TranslatedString(BasePlayer player, string key) => player.ChatMessage(lang.GetMessage(key, this, player.UserIDString));

        private void FormatString(BasePlayer player, string key, params object[] args) => player.ChatMessage(string.Format(lang.GetMessage(key, this, player.UserIDString), args));
        #endregion
        
        #region Config        
        private ConfigData configData;
        private class ConfigData
        {         
            [JsonProperty("Delete logs after X days (0 to disable)")]
            public int DeleteAfterDays { get; set; }
            
            public VersionNumber Version { get; set; }
        }        

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DeleteAfterDays = 0,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = GetBaseConfig();
            
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
       
        #endregion
    }
}


// --- End of file: LootLogs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/lighthouse-beacon ---
// --- Original File Path: L/LighthouseBeacon/LighthouseBeacon.cs ---

﻿using System.Collections.Generic;
using System.Linq;

using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Lighthouse Beacon", "S0N_0F_BISCUIT", "1.0.3")]
	[Description("Adds a beacon to the lighthouse monument")]
	class LighthouseBeacon : RustPlugin
	{
		#region Variables
		private List<SearchLight> beacons = new List<SearchLight>();

		class Beacon : MonoBehaviour
		{
			#region Variables
			private SearchLight light { get; set; } = null;
			#endregion

			#region Initialization
			/// <summary>
			/// Initialize beacon
			/// </summary>
			private void Awake()
			{
				light = GetComponent<SearchLight>();
				light.SetFlag(BaseEntity.Flags.On, true);
				light.SetFlag(BaseEntity.Flags.Busy, true);
				light.aimDir = Quaternion.AngleAxis(15, Vector3.right) * (light.aimDir + Vector3.forward);
				light.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
			}
			#endregion

			#region Functionality
			/// <summary>
			/// Rotate the beacon
			/// </summary>
			private void Update()
			{
				light.aimDir = Quaternion.Euler(0, -.25f, 0) * light.aimDir;
				light.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
			}
			/// <summary>
			/// Destroy the beacon with the searchlight
			/// </summary>
			public void OnDestroy()
			{
				Destroy(this);
			}
			#endregion
		}
		#endregion

		/// <summary>
		/// Create beacons when the plugin is initialized
		/// </summary>
		void OnServerInitialized()
		{
			// Delete leftover beacons
			foreach (var light in UnityEngine.Object.FindObjectsOfType<SearchLight>().Where(light => light.gameObject.HasComponent<Beacon>()))
            {
				light.Kill();
            }
			// Spawn at monuments
			foreach (MonumentInfo monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Where(monument => monument.name.Contains("lighthouse")))
			{
				CreateBeacon(monument.transform.position + Vector3.up * 57);
			}
		}
		/// <summary>
		/// Destroy the beacons when the plugin is unloaded
		/// </summary>
		void Unload()
		{
			foreach (SearchLight beacon in beacons)
			{
				try
				{
					beacon.Kill();
				}
				catch { }
			}
		}
		/// <summary>
		/// Create a new lighthouse beacon
		/// </summary>
		/// <param name="position"></param>
		void CreateBeacon(Vector3 position)
		{
			var newLight = GameManager.server.CreateEntity("assets/prefabs/deployable/search light/searchlight.deployed.prefab", position, new Quaternion(), true);
			BaseEntity searchLight = newLight?.GetComponent<BaseEntity>();
			if (searchLight)
			{
				searchLight?.gameObject.AddComponent<Beacon>();
				searchLight?.Spawn();
				(searchLight as SearchLight).UpdateHasPower((searchLight as SearchLight).DesiredPower(), 0);
				(searchLight as SearchLight).SetFlag(BaseEntity.Flags.Reserved8, true);
				beacons.Add(searchLight as SearchLight);
			}
		}
	}
}

// --- End of file: LighthouseBeacon.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-spawnpoints ---
// --- Original File Path: L/LootSpawnpoints/LootSpawnpoints.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Loot Spawnpoints", "Orange", "1.0.0")]
    [Description("Add extra loot spawnpoints on custom maps")]
    public class LootSpawnpoints : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            cmd.AddConsoleCommand("spawnpoints.get", this, "cmdGetSpawnpointsConsole");
        }
        
        private void OnServerInitialized()
        {
            LoadData();
            CreateSpawnpoints();
        }

        private void Unload()
        {
            UnityEngine.Object.FindObjectsOfType<Spawner>().ToList().ForEach(UnityEngine.Object.Destroy);
        }

        #endregion

        #region Commands

        private void cmdGetSpawnpointsConsole(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
            {
                return;
            }
            
            GetSpawnpoints();
            PrintWarning($"{data.Count} objects saved");
            Unload();
            CreateSpawnpoints();
        }

        #endregion

        #region Core

        private void GetSpawnpoints()
        {
            var objects = UnityEngine.Object.FindObjectsOfType<LootContainer>().Where(x => IsAllowed(x.ShortPrefabName));
            data.Clear();

            foreach (var obj in objects)
            {
                data.Add(new BaseEntityToSave
                {
                    prefab = obj.PrefabName,
                    rotation = obj.transform.rotation,
                    position = obj.transform.position
                });
            }
            
            SaveData();
        }

        private bool IsAllowed(string shortName)
        {
            return config.whitelist.Count > 0 ? config.whitelist.Contains(shortName) : config.blacklist.Contains(shortName);
        }

        private void CreateSpawnpoints()
        {
            UnityEngine.Object.FindObjectsOfType<Spawner>().ToList().ForEach(UnityEngine.Object.Destroy);
            
            foreach (var value in data)
            {
                var time = config.defaultRespawnTimer;
                var name = value.prefab;
                if (config.respawnTimers.ContainsKey(name))
                {
                    time = config.respawnTimers[name];
                }
                
                var entity = new GameObject().AddComponent<Spawner>();
                entity.transform.position = value.position;
                entity.transform.rotation = value.rotation;
                entity.time = time;
                entity.prefab = name;
            }
            
            PrintWarning($"{UnityEngine.Object.FindObjectsOfType<Spawner>().Length} spawners loaded");
        }

        #endregion
        
        #region Configuration 1.0.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "A. Whitelist (keep empty to use blacklist)")]
            public List<string> whitelist;

            [JsonProperty(PropertyName = "B. Blacklist")]
            public List<string> blacklist;

            [JsonProperty(PropertyName = "C. Respawn timers")]
            public Dictionary<string, int> respawnTimers;

            [JsonProperty(PropertyName = "Default respawn timer")]
            public int defaultRespawnTimer;

            [JsonProperty(PropertyName = "Allow stacking")]
            public bool allowStacking;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                defaultRespawnTimer = 60 * 20,
                allowStacking = false,
                whitelist = new List<string>
                {
                    "crate_elite",
                    "crate_normal",
                    "crate_normal_2"
                },
                blacklist = new List<string>
                {
                    
                },
                respawnTimers = new Dictionary<string, int>
                {
                    {"assets/bundled/prefabs/radtown/crate_elite.prefab", 60 * 40},
                    {"assets/bundled/prefabs/radtown/crate_normal.prefab", 60 * 25},
                    {"assets/bundled/prefabs/radtown/crate_normal_2.prefab", 60 * 15}
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Data 1.0.0

        private const string filename = "LootSpawpoints";
        private List<BaseEntityToSave> data = new List<BaseEntityToSave>();

        private void LoadData()
        {
            try
            {
                // TODO: Solve quaternion issue 
                var value = Interface.Oxide.DataFileSystem.ReadObject<string>(filename); 
                data = JsonConvert.DeserializeObject<List<BaseEntityToSave>>(value);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
        }

        private void SaveData()
        {
            // TODO: Solve quaternion issue
            var value = JsonConvert.SerializeObject(data, Formatting.None, new JsonSerializerSettings {ReferenceLoopHandling = ReferenceLoopHandling.Ignore});
            Interface.Oxide.DataFileSystem.WriteObject(filename, value);
        }

        #endregion
        
        #region Classes

        private class BaseEntityToSave
        {
            public string prefab;
            public Quaternion rotation;
            public Vector3 position;
        }

        private class Spawner : MonoBehaviour
        {
            public string prefab;
            public int time;

            private void Start()
            {
                InvokeRepeating("Spawn", 0, time);
            }

            private void Spawn()
            {
                if (!config.allowStacking && HasContainerNearby())
                {
                    return;
                }
                
                var entity = GameManager.server.CreateEntity(prefab, transform.position, transform.rotation);
                entity?.Spawn();
            }

            private bool HasContainerNearby()
            {
                var containers = new List<LootContainer>();
                Vis.Entities(transform.position, 0.5f, containers);
                return containers.Count > 0;
            }
        }
        
        #endregion
    }
}

// --- End of file: LootSpawnpoints.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-plus ---
// --- Original File Path: L/LootPlus/LootPlus.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Physics = UnityEngine.Physics;
using Pool = Facepunch.Pool;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Loot Plus", "Iv Misticos", "2.2.6")]
    [Description("Modify loot on your server.")]
    public class LootPlus : RustPlugin
    {
        #region Variables

        private static LootPlus _ins;

        private Random _random = new Random();

        private bool _initialized = false;

        private const string PermissionLootSave = "lootplus.lootsave";

        private const string PermissionLootRefill = "lootplus.lootrefill";

        private const string PermissionLoadConfig = "lootplus.loadconfig";

        #endregion

        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Refill Loot On Plugin Load")]
            public bool RefillOnLoad = true;

            [JsonProperty(PropertyName = "Process Corpses", NullValueHandling = NullValueHandling.Ignore)]
            public bool? ProcessCorpses = null;

            [JsonProperty(PropertyName = "Process Loot Containers", NullValueHandling = NullValueHandling.Ignore)]
            public bool? ProcessLootContainers = null;

            [JsonProperty(PropertyName = "Container Loot Save Command")]
            public string LootSaveCommand = "lootsave";

            [JsonProperty(PropertyName = "Container Refill Command")]
            public string LootRefillCommand = "lootrefill";

            [JsonProperty(PropertyName = "Load Config Command")]
            public string LoadConfigCommand = "lootconfig";

            [JsonProperty(PropertyName = "Containers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ContainerData> Containers = new List<ContainerData> {new ContainerData()};

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        private class ContainerData
        {
            [JsonProperty(PropertyName = "Entity Shortnames", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ShortnameData> Shortnames = new List<ShortnameData>
            {
                new ShortnameData()
            };

            [JsonProperty(PropertyName = "Process Corpses")]
            public bool ProcessCorpses = true;

            [JsonProperty(PropertyName = "Process Loot Containers")]
            public bool ProcessLootContainers = true;

            [JsonProperty(PropertyName = "Monument Prefabs", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Monuments = new List<string> {string.Empty};

            [JsonProperty(PropertyName = "Shuffle Items")]
            public bool ShuffleItems = true;

            [JsonProperty(PropertyName = "Allow Duplicate Items")]
            public bool AllowDuplicateItems = false;

            [JsonProperty(PropertyName = "Allow Duplicate Items With Different Skins")]
            public bool AllowDuplicateItemsDifferentSkins = true;

            [JsonProperty(PropertyName = "Remove Container")]
            public bool RemoveContainer = false;

            [JsonProperty(PropertyName = "Item Container Indexes",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<int> ContainerIndexes = new List<int> {0};

            [JsonProperty(PropertyName = "Replace Items")]
            public bool ReplaceItems = true;

            [JsonProperty(PropertyName = "Add Items")]
            public bool AddItems = false;

            [JsonProperty(PropertyName = "Modify Items")]
            public bool ModifyItems = false;

            [JsonProperty(PropertyName = "Modify Ignores Blueprint State")]
            public bool ModifyIgnoreBlueprint = false;

            [JsonProperty(PropertyName = "Fill With Default Items")]
            public bool DefaultLoot = false;

            [JsonProperty(PropertyName = "Online Condition")]
            public OnlineData Online = new OnlineData();

            [JsonProperty(PropertyName = "Maximal Failures To Add An Item")]
            public int MaxRetries = 5;

            [JsonProperty(PropertyName = "Capacity", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CapacityData> Capacity = new List<CapacityData> {new CapacityData()};

            [JsonProperty(PropertyName = "Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ItemData> Items = new List<ItemData> {new ItemData()};

            public bool ShortnameFits(string shortname, bool api)
            {
                var fits = false;

                for (var i = 0; i < Shortnames.Count; i++)
                {
                    var shortnameData = Shortnames[i];
                    if (shortnameData.API != api)
                        continue;

                    var fitsExpression = shortnameData.FitsExpression(shortname);
                    if (!fitsExpression)
                        continue;

                    if (shortnameData.Exclude)
                        return false;

                    fits = true;
                }

                return fits;
            }

            public class ShortnameData
            {
                [JsonProperty(PropertyName = "Shortname")]
                public string Shortname = "entity.shortname";

                [JsonProperty(PropertyName = "Enable Regex")]
                public bool Regex = false;

                [JsonProperty(PropertyName = "Exclude")]
                public bool Exclude = false;

                [JsonProperty(PropertyName = "API Shortname")]
                public bool API = false;

                [JsonIgnore]
                public Regex ParsedRegex;

                public bool FitsExpression(string shortname)
                {
                    if (Regex)
                    {
                        return ParsedRegex.IsMatch(shortname);
                    }

                    return Shortname == "global" || Shortname == shortname;
                }
            }
        }

        private class ItemData : ChanceData
        {
            [JsonProperty(PropertyName = "Item Shortname", NullValueHandling = NullValueHandling.Ignore)]
            public string Shortname = null;

            [JsonProperty(PropertyName = "Item Shortnames", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ShortnameData> Shortnames = new List<ShortnameData>
            {
                new ShortnameData()
            };

            [JsonProperty(PropertyName = "Item Name (Empty To Ignore)")]
            public string Name = "";

            [JsonProperty(PropertyName = "Is Blueprint")]
            public bool IsBlueprint = false;

            [JsonProperty(PropertyName = "Allow Stacking")]
            public bool AllowStacking = true;

            [JsonProperty(PropertyName = "Ignore Max Stack")]
            public bool IgnoreStack = true;

            [JsonProperty(PropertyName = "Ignore Max Condition")]
            public bool IgnoreCondition = true;

            [JsonProperty(PropertyName = "Remove Item")]
            public bool RemoveItem = false;

            [JsonProperty(PropertyName = "Replace Item With Default Loot")]
            public bool ReplaceDefaultLoot = false;

            [JsonProperty(PropertyName = "Conditions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ConditionData> Conditions = new List<ConditionData> {new ConditionData()};

            [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<SkinData> Skins = new List<SkinData> {new SkinData()};

            [JsonProperty(PropertyName = "Amount", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AmountData> Amount = new List<AmountData> {new AmountData()};

            public bool ShortnameFits(Rarity rarity, ItemCategory category, string shortname)
            {
                var fits = false;

                for (var i = 0; i < Shortnames.Count; i++)
                {
                    var shortnameData = Shortnames[i];
                    var fitsExpression = shortnameData.FitsExpression(rarity, category, shortname);
                    if (!fitsExpression)
                        continue;

                    if (shortnameData.Exclude)
                        return false;

                    fits = true;
                }

                return fits;
            }

            public bool ShortnameFits(Item item, ContainerData container)
            {
                if (!container.ModifyIgnoreBlueprint && item.IsBlueprint() != IsBlueprint)
                    return false;

                return ShortnameFits(item.IsBlueprint() ? item.blueprintTargetDef.rarity : item.info.rarity,
                    item.IsBlueprint() ? item.blueprintTargetDef.category : item.info.category,
                    item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname);
            }

            public class ShortnameData
            {
                [JsonProperty(PropertyName = "Shortname")]
                public string Shortname = "item.shortname";
                
                [JsonProperty(PropertyName = "Rarity")]
                public string Rarity = "global";
                
                [JsonProperty(PropertyName = "Category")]
                public string Category = "global";

                [JsonProperty(PropertyName = "Enable Regex")]
                public bool Regex = false;

                [JsonProperty(PropertyName = "Exclude")]
                public bool Exclude = false;

                [JsonIgnore]
                public Regex ParsedRegex;

                public bool FitsExpression(Rarity rarity, ItemCategory category, string shortname)
                {
                    if (Rarity != "global" && Rarity != rarity.ToString())
                        return false;

                    if (Category != "global" && Category != category.ToString())
                        return false;
                    
                    if (Regex)
                    {
                        return ParsedRegex.IsMatch(shortname);
                    }

                    return Shortname == "global" || Shortname == shortname;
                }
            }
        }

        #region Additional

        private class ConditionData : ChanceData
        {
            [JsonProperty(PropertyName = "Condition", NullValueHandling = NullValueHandling.Ignore)]
            public float? Condition = null;

            [JsonProperty(PropertyName = "Minimal Condition")]
            public float MinCondition = 75f;

            [JsonProperty(PropertyName = "Maximal Condition")]
            public float MaxCondition = 100f;

            [JsonProperty(PropertyName = "Max Condition Of Item")]
            public float MaxItemCondition = -1f;

            [JsonProperty(PropertyName = "Condition Rate")]
            public float ConditionRate = -1f;

            [JsonProperty(PropertyName = "Max Condition Rate")]
            public float MaxItemConditionRate = -1f;

            public void Modify(ref float condition, ref float maxCondition)
            {
                if (MaxItemCondition > 0f)
                    maxCondition = MaxItemCondition;

                if (MaxItemConditionRate > 0f)
                    maxCondition *= MaxItemConditionRate;

                if (MinCondition > 0 && MaxCondition > 0)
                    condition = (float) (_ins._random.NextDouble() * (MaxCondition - MinCondition) + MinCondition);

                if (ConditionRate > 0f)
                    condition *= ConditionRate;
            }
        }

        private class SkinData : ChanceData
        {
            [JsonProperty(PropertyName = "Skin")]
            // ReSharper disable once RedundantDefaultMemberInitializer
            public ulong Skin = 0;
        }

        private class AmountData : ChanceData
        {
            [JsonProperty(PropertyName = "Amount", NullValueHandling = NullValueHandling.Ignore)]
            public int? Amount = null;

            [JsonProperty(PropertyName = "Minimal Amount")]
            public int MinAmount = 3;

            [JsonProperty(PropertyName = "Maximal Amount")]
            public int MaxAmount = 3;

            [JsonProperty(PropertyName = "Rate")]
            public float Rate = -1f;

            public void Modify(ref int amount)
            {
                if (MinAmount > 0 && MaxAmount > 0)
                    amount = _ins._random.Next(MinAmount, MaxAmount + 1);

                if (Rate > 0)
                    amount = (int) (amount * Rate);
            }
        }

        private class CapacityData : ChanceData
        {
            [JsonProperty(PropertyName = "Capacity")]
            public int Capacity = 3;
        }

        private class OnlineData
        {
            // sorry, dont want anything in config to be "private" :)
            // ReSharper disable MemberCanBePrivate.Local
            [JsonProperty(PropertyName = "Minimal Online")]
            public int MinOnline = -1;

            [JsonProperty(PropertyName = "Maximal Online")]
            public int MaxOnline = -1;
            // ReSharper restore MemberCanBePrivate.Local

            public bool IsOkay()
            {
                var online = BasePlayer.activePlayerList.Count;
                return MinOnline == -1 && MaxOnline == -1 || online > MinOnline && online < MaxOnline;
            }
        }

        public class ChanceData
        {
            [JsonProperty(PropertyName = "Chance")]
            // ReSharper disable once MemberCanBePrivate.Global
            public int Chance = 1;

            public static T Select<T>(IReadOnlyList<T> data) where T : ChanceData
            {
                // xD

                if (data == null)
                {
                    return null;
                }

                if (data.Count == 0)
                {
                    return null;
                }

                var sum1 = 0;
                for (var i = 0; i < data.Count; i++)
                {
                    var entry = data[i];
                    sum1 += entry?.Chance ?? 0;
                }

                if (sum1 < 1)
                {
                    return null;
                }

                var random = _ins._random.Next(1, sum1 + 1); // include the sum1 number itself and exclude the 0

                var sum2 = 0;
                for (var i = 0; i < data.Count; i++)
                {
                    var entry = data[i];
                    sum2 += entry?.Chance ?? 0;
                    if (random <= sum2)
                        return entry;
                }

                return null;
            }
        }

        #endregion

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            
                for (var i = 0; i < _config.Containers.Count; i++)
                {
                    var container = _config.Containers[i];

                    if (_config.ProcessCorpses.HasValue)
                    {
                        container.ProcessCorpses = _config.ProcessCorpses.Value;
                    }

                    if (_config.ProcessLootContainers.HasValue)
                    {
                        container.ProcessLootContainers = _config.ProcessLootContainers.Value;
                    }

                    for (var j = 0; j < container.Items.Count; j++)
                    {
                        var item = container.Items[j];
                        if (item.Shortname != null)
                        {
                            if (!string.IsNullOrEmpty(item.Shortname))
                            {
                                item.Shortnames.Add(new ItemData.ShortnameData
                                {
                                    Shortname = item.Shortname,
                                    Exclude = false,
                                    Regex = false
                                });
                            }

                            item.Shortname = null;
                        }

                        for (var k = 0; k < item.Amount.Count; k++)
                        {
                            var amount = item.Amount[k];
                            if (!amount.Amount.HasValue)
                                continue;

                            amount.MinAmount = amount.Amount.Value;
                            amount.MaxAmount = amount.Amount.Value;
                            amount.Amount = null;
                        }

                        for (var k = 0; k < item.Conditions.Count; k++)
                        {
                            var condition = item.Conditions[k];
                            if (!condition.Condition.HasValue)
                                continue;

                            condition.MinCondition = condition.Condition.Value;
                            condition.MaxCondition = condition.Condition.Value;
                            condition.Condition = null;
                        }

                        for (var k = 0; k < item.Shortnames.Count; k++)
                        {
                            var shortname = item.Shortnames[k];
                            if (!shortname.Regex)
                                continue;

                            shortname.ParsedRegex = new Regex(shortname.Shortname);
                        }
                    }

                    for (var j = 0; j < container.Shortnames.Count; j++)
                    {
                        var shortname = container.Shortnames[j];
                        if (!shortname.Regex)
                            continue;

                        shortname.ParsedRegex = new Regex(shortname.Shortname);
                    }
                }

                if (_config.ProcessCorpses.HasValue)
                {
                    _config.ProcessCorpses = null;
                }

                if (_config.ProcessLootContainers.HasValue)
                {
                    _config.ProcessLootContainers = null;
                }
            
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Commands

        private void CommandLootSave(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null)
            {
                iplayer.Reply(GetMsg("In-Game Only", iplayer.Id));
                return;
            }

            if (!iplayer.HasPermission(PermissionLootSave))
            {
                iplayer.Reply(GetMsg("No Permission", iplayer.Id));
                return;
            }

            RaycastHit hit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 10f) || hit.GetEntity() == null ||
                !(hit.GetEntity() is LootContainer))
            {
                iplayer.Reply(GetMsg("No Loot Container", iplayer.Id));
                return;
            }

            var container = hit.GetEntity() as LootContainer;
            if (container == null || container.inventory == null)
            {
                // Shouldn't really happen
                return;
            }

            var inventory = player.inventory.containerMain;

            var containerData = new ContainerData
            {
                ModifyItems = false,
                AddItems = false,
                ReplaceItems = true,
                Shortnames = new List<ContainerData.ShortnameData>
                {
                    new ContainerData.ShortnameData
                    {
                        Shortname = container.ShortPrefabName,
                        Exclude = false,
                        Regex = false,
                        API = false
                    }
                },
                Capacity = new List<CapacityData>
                {
                    new CapacityData
                    {
                        Capacity = inventory.itemList.Count
                    }
                },
                Items = new List<ItemData>(),
                MaxRetries = inventory.itemList.Count * 10
            };

            for (var i = 0; i < inventory.itemList.Count; i++)
            {
                var item = inventory.itemList[i];
                var isBlueprint = item.IsBlueprint();
                var itemData = new ItemData
                {
                    Amount = new List<AmountData>
                    {
                        new AmountData
                        {
                            MinAmount = item.amount,
                            MaxAmount = item.amount
                        }
                    },
                    Conditions = new List<ConditionData>(),
                    Skins = new List<SkinData>
                    {
                        new SkinData
                        {
                            Skin = item.skin
                        }
                    },
                    Shortnames = new List<ItemData.ShortnameData>
                    {
                        new ItemData.ShortnameData
                        {
                            Shortname = isBlueprint ? item.blueprintTargetDef.shortname : item.info.shortname
                        }
                    },
                    Name = item.name ?? string.Empty, // yes but it doesnt work :( lol?
                    AllowStacking = true,
                    IsBlueprint = isBlueprint
                };

                if (!isBlueprint)
                {
                    if (item.hasCondition)
                        itemData.Conditions.Add(new ConditionData
                        {
                            MinCondition = item.condition,
                            MaxCondition = item.condition,
                            MaxItemCondition = item.maxCondition
                        });
                }

                containerData.Items.Add(itemData);
            }

            _config.Containers.Add(containerData);
            SaveConfig();

            iplayer.Reply(GetMsg("Loot Container Saved", iplayer.Id));
        }

        private void CommandLootRefill(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionLootRefill))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            player.Reply(GetMsg("Loot Refill Started", player.Id));
            LootRefill();
        }

        private void CommandLoadConfig(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionLoadConfig))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            LoadConfig(); // What if something has changed there? :o

            player.Reply(GetMsg("Config Loaded", player.Id));
        }

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"In-Game Only", "Please, use this only while you're in the game"},
                {"No Permission", "You don't have enough permissions"},
                {"No Loot Container", "Please, look at the loot container in 10m"},
                {"Loot Container Saved", "You have saved this loot container data to configuration"},
                {"Loot Refill Started", "Loot refill process just started"},
                {"Config Loaded", "Your configuration was loaded"}
            }, this);
        }

        private void Init()
        {
            _ins = this;
            
            permission.RegisterPermission(PermissionLootSave, this);
            permission.RegisterPermission(PermissionLootRefill, this);
            permission.RegisterPermission(PermissionLoadConfig, this);

            AddCovalenceCommand(_config.LootSaveCommand, nameof(CommandLootSave));
            AddCovalenceCommand(_config.LootRefillCommand, nameof(CommandLootRefill));
            AddCovalenceCommand(_config.LoadConfigCommand, nameof(CommandLoadConfig));
        }

        private void OnServerInitialized()
        {
            _ins = this;
            _initialized = true;
            
            if (!_config.RefillOnLoad)
            {
                PrintWarning("Loot refill on plugin load is disabled in configuration");
                return;
            }

            NextFrame(LootRefill);
        }

        private void Unload()
        {
            _initialized = false;
            
            // LOOT IS BACK
            using (var entitiesEnumerator = BaseNetworkable.serverEntities.GetEnumerator())
            {
                while (entitiesEnumerator.MoveNext())
                {
                    var entity = entitiesEnumerator.Current;
                    var lootContainer = entity as LootContainer;
                    if (lootContainer == null)
                        continue;

                    if (lootContainer is Stocking && !XMas.enabled)
                    {
                        PrintDebug("Stocking entity but XMas is disabled");
                        continue;
                    }

                    if (lootContainer.shouldRefreshContents && !lootContainer.IsInvoking(lootContainer.SpawnLoot))
                    {
                        PrintDebug("Entity should refresh content but does NOT.");
                        continue;
                    }

                    PrintDebug(
                        $"Restoring loot for {lootContainer.ShortPrefabName}. SRC: {lootContainer.shouldRefreshContents} / II: {lootContainer.IsInvoking(lootContainer.SpawnLoot)}");
                    
                    // Creating an inventory
                    if (lootContainer.inventory == null)
                    {
                        lootContainer.CreateInventory(true);
                    }
                    else
                    {
                        lootContainer.inventory.Clear();
                        ItemManager.DoRemoves();
                    }

                    // Spawning loot
                    lootContainer.SpawnLoot();

                    // Changing the capacity
                    lootContainer.inventory.capacity = lootContainer.inventory.itemList.Count;

                    // no i wont do anything with npc and other containers >:(
                }
            }

            _ins = null;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!_initialized)
                return;
            
            if (entity is LootContainer)
            {
                PrintDebug("Entity is a LootContainer. Waiting for OnLootSpawn");
                return; // So this entity's content is modified in OnLootSpawn
            }
            
            OnLootSpawn(entity);
        }

        private void OnLootSpawn(BaseNetworkable entity)
        {
            if (!_initialized || entity == null)
                return;

            var lootContainer = entity as LootContainer;
            if (lootContainer != null)
            {
                RunLootHandler(entity, lootContainer.inventory, -1);
                return;
            }
            
            var corpse = entity as LootableCorpse;
            if (corpse != null)
            {
                if (corpse.containers == null || corpse.containers.Length == 0)
                {
                    PrintDebug("Entity has no containers");
                    return;
                }
                
                for (var i = 0; i < corpse.containers.Length; i++)
                {
                    var inventory = corpse.containers[i];
                    RunLootHandler(entity, inventory, i);
                }
            }
        }

        #endregion
        
        #region API

        private void FillContainer(ItemContainer container, string apiShortname, int containerIndex = -1)
        {
            HandleAPIFill(container, apiShortname, containerIndex);
        }
        
        #endregion
        
        #region Helpers

        private void RunLootHandler(BaseNetworkable networkable, ItemContainer inventory, int containerIndex)
        {
            NextFrame(() => ServerMgr.Instance.StartCoroutine(LootHandler(networkable, inventory, containerIndex)));
        }

        private IEnumerator LootHandler(BaseNetworkable networkable, ItemContainer inventory, int containerIndex, string apiShortname = null)
        {
            if (inventory == null || networkable == null && string.IsNullOrEmpty(apiShortname) ||
                networkable.ShortPrefabName == "player_corpse")
                yield break;
            
            var isApi = networkable == null;


            var blacklisted = new List<ItemData>();
            var usable = new List<ContainerData>();
            for (var i = 0; i < _config.Containers.Count; i++)
            {
                var container = _config.Containers[i];
                
                if (!container.ProcessCorpses && networkable is LootableCorpse)
                    continue;

                if (!container.ProcessLootContainers && networkable is LootContainer)
                    continue;

                if (!container.ShortnameFits(isApi ? apiShortname : networkable.ShortPrefabName, isApi))
                    continue;

                if (containerIndex != -1 && !container.ContainerIndexes.Contains(containerIndex))
                    continue;

                if (networkable != null && container.Monuments.Count > 0)
                {
                    if (!container.Monuments.Contains(string.Empty))
                    {
                        if (!container.Monuments.Contains(GetMonumentName(networkable.transform.position)))
                            continue;
                    }
                }
                
                usable.Add(container);

                for (var j = 0; j < container.Items.Count; j++)
                {
                    var item = container.Items[j];
                    if (item.ReplaceDefaultLoot || item.RemoveItem)
                        blacklisted.Add(item);
                }
            }

            for (var i = 0; i < usable.Count; i++)
            {
                yield return HandleInventory(networkable, inventory, usable[i], blacklisted);
            }
        }

        private IEnumerator HandleInventory(BaseNetworkable networkable, ItemContainer inventory, ContainerData container, List<ItemData> blacklisted)
        {
            if (container.RemoveContainer)
            {
                PrintDebug("Removing container in next frame");
                NextFrame(() =>
                {
                    if (networkable != null && !networkable.IsDestroyed)
                        networkable.Kill();
                });
                
                yield break;
            }
            
            if (!container.Online.IsOkay())
            {
                PrintDebug("Online check failed");
                yield break;
            }

            if (container.ShuffleItems && !container.ModifyItems && container.Items != null) // No need to shuffle for items modification
                Shuffle(container.Items);

            inventory.capacity = inventory.itemList.Count;

            if (container.ReplaceItems || container.AddItems)
            {
                var dataCapacity = ChanceData.Select(container.Capacity);
                if (dataCapacity == null)
                {
                    PrintDebug("Could not select a correct capacity");
                    yield break;
                }

                if (container.ReplaceItems)
                {
                    inventory.Clear();
                    ItemManager.DoRemoves();
                    inventory.capacity = dataCapacity.Capacity;
                }

                if (container.AddItems)
                {
                    inventory.capacity += dataCapacity.Capacity;
                }
                
                if (container.Items?.Count > 0)
                    yield return HandleInventoryAddReplace(inventory, container);
            }

            if (container.ModifyItems && container.Items?.Count > 0)
            {
                yield return HandleInventoryModify(inventory, container, blacklisted);
            }

            if (!container.DefaultLoot)
                yield break;
            
            PrintDebug("Filling with default loot..");

            var lootContainer = networkable as LootContainer;
            if (lootContainer == null)
            {
                PrintDebug("Tried to set vanilla loot, but it's not a loot container");
                yield break;
            }

            var failures = 0;
            while (inventory.itemList.Count < inventory.capacity)
            {
                Item addedItem;
                do
                {
                    addedItem = GenerateDefaultItem(lootContainer, blacklisted, container, inventory.itemList);
                } while (addedItem == null & ++failures <= container.MaxRetries);

                if (failures > container.MaxRetries)
                {
                    PrintDebug($"Skipping item, a lot of failures ({failures})");

                    addedItem?.Remove();
                    break;
                }

                if (addedItem != null)
                {
                    PrintDebug($"Inserting default loot {addedItem.info.shortname} ({addedItem.blueprintTargetDef?.shortname ?? "nobp"})");
                    addedItem.position = inventory.itemList.Count - 1;
                    if (!inventory.Insert(addedItem))
                        PrintDebug("Unable to insert an item!");
                }

                yield return null;
            }
            
            ItemManager.DoRemoves();
        }

        private void HandleAPIFill(ItemContainer container, string apiShortname, int containerIndex)
        {
            PrintDebug($"Handling API fill with API Shortname: {apiShortname}");
            // ReSharper disable once IteratorMethodResultIsIgnored
            LootHandler(null, container, containerIndex, apiShortname);
        }

        private static IEnumerator HandleInventoryAddReplace(ItemContainer inventory, ContainerData container)
        {
            PrintDebug($"Add or Replace for {inventory.entityOwner?.ShortPrefabName ?? "Unknown"}");
            
            var failures = 0;
            while (inventory.itemList.Count < inventory.capacity)
            {
                yield return null;

                var dataItem = ChanceData.Select(container.Items);
                if (dataItem == null)
                {
                    PrintDebug("Could not select a correct item");
                
                    if (++failures > container.MaxRetries)
                    {
                        PrintDebug("Stopping because of failures");
                        break;
                    }
                    
                    continue;
                }

                for (var i = 0; i < dataItem.Shortnames.Count; i++)
                {
                    var shortnameData = dataItem.Shortnames[i];
                    PrintDebug(
                        $"Handling item {shortnameData.Shortname} (Blueprint: {dataItem.IsBlueprint} / Stacking: {dataItem.AllowStacking})");

                    var skin = ChanceData.Select(dataItem.Skins)?.Skin ?? 0UL;

                    if (!container.AllowDuplicateItems) // Duplicate items are not allowed
                    {
                        if (IsDuplicate(inventory.itemList, container, dataItem, shortnameData.Shortname, skin))
                        {
                            if (++failures > container.MaxRetries)
                            {
                                PrintDebug("Stopping because of duplicates");
                                break;
                            }

                            continue;
                        }

                        PrintDebug("No duplicates");
                    }

                    var dataAmount = ChanceData.Select(dataItem.Amount);
                    if (dataAmount == null)
                    {
                        PrintDebug("Could not select a correct amount");
                        continue;
                    }

                    var amount = 1;
                    dataAmount.Modify(ref amount);

                    var definition =
                        ItemManager.FindItemDefinition(dataItem.IsBlueprint
                            ? "blueprintbase"
                            : shortnameData.Shortname);
                    if (definition == null)
                    {
                        PrintDebug("Could not find an item definition");
                        continue;
                    }

                    var stack = dataItem.IgnoreStack ? amount : Math.Min(amount, definition.stackable);
                    PrintDebug($"Creating with amount: {stack} ({amount})");

                    var createdItem = ItemManager.Create(definition, stack, skin);
                    if (createdItem == null)
                    {
                        PrintDebug("Could not create an item");
                        continue;
                    }

                    if (dataItem.IsBlueprint)
                    {
                        createdItem.blueprintTarget = ItemManager.FindItemDefinition(shortnameData.Shortname).itemid;
                    }
                    else
                    {
                        var dataCondition = ChanceData.Select(dataItem.Conditions);
                        if (createdItem.hasCondition)
                        {
                            if (dataCondition != null)
                            {
                                dataCondition.Modify(ref createdItem._condition, ref createdItem._maxCondition);

                                if (!dataItem.IgnoreCondition)
                                    createdItem._condition =
                                        Math.Min(createdItem._condition, createdItem._maxCondition);
                            }
                        }
                        else if (dataCondition != null)
                        {
                            PrintDebug("Configurated item has a condition but item doesn't have condition");
                        }
                    }

                    if (!string.IsNullOrEmpty(dataItem.Name))
                        createdItem.name = dataItem.Name;

                    var moved = createdItem.MoveToContainer(inventory, allowStack: dataItem.AllowStacking);
                    if (moved) continue;

                    PrintDebug("Could not move item to a container");
                }
            }
        }

        private static IEnumerator HandleInventoryModify(ItemContainer inventory, ContainerData container, List<ItemData> blacklisted)
        {
            PrintDebug($"Modify for {inventory.entityOwner?.ShortPrefabName ?? "Unknown"}");
            
            // Reversed, because an item can be removed.
            for (var i = inventory.itemList.Count - 1; i >= 0; i--)
            {
                var item = inventory.itemList[i];
                for (var j = 0; j < container.Items.Count; j++)
                {
                    yield return null;

                    var dataItem = container.Items[j];
                    if (!dataItem.ShortnameFits(item, container))
                        continue;

                    PrintDebug(
                        $"Handling item {item.info.shortname} (Blueprint: {dataItem.IsBlueprint} / Stacking: {dataItem.AllowStacking})");

                    if (dataItem.RemoveItem)
                    {
                        PrintDebug("Removing item");

                        for (var k = 0; k < item.info.itemMods.Length; k++)
                        {
                            var itemMod = item.info.itemMods[k];
                            itemMod.OnRemove(item);
                        }

                        item.DoRemove();
                        break;
                    }

                    if (dataItem.ReplaceDefaultLoot)
                    {
                        PrintDebug(
                            $"Replacing {item.info.shortname} ({item.blueprintTargetDef?.shortname ?? "nobp"}) with default loot");

                        for (var k = 0; k < item.info.itemMods.Length; k++)
                        {
                            var itemMod = item.info.itemMods[k];
                            itemMod.OnRemove(item);
                        }

                        item.DoRemove();

                        var lootContainer = inventory.entityOwner as LootContainer;
                        if (lootContainer == null)
                        {
                            PrintDebug(
                                "Tried to change an item to another vanilla loot item, but it's not a loot container");

                            break;
                        }

                        var failures = 0;
                        
                        Item addedItem;
                        do
                        {
                            addedItem = GenerateDefaultItem(lootContainer, blacklisted, container, inventory.itemList);
                        } while (addedItem == null & ++failures <= container.MaxRetries);

                        if (failures > container.MaxRetries)
                        {
                            PrintDebug($"Skipping item, a lot of failures ({failures})");

                            addedItem?.Remove();
                            break;
                        }

                        if (addedItem != null)
                        {
                            PrintDebug(
                                $"Inserting replace with default loot {addedItem.info.shortname} ({addedItem.blueprintTargetDef?.shortname ?? "nobp"})");
                            addedItem.position = inventory.itemList.Count - 1;
                            if (!inventory.Insert(addedItem))
                                PrintDebug("Unable to insert an item!");
                        }

                        ItemManager.DoRemoves();
                        break;
                    }

                    item.skin = ChanceData.Select(dataItem.Skins)?.Skin ?? item.skin;

                    var dataAmount = ChanceData.Select(dataItem.Amount);
                    if (dataAmount == null)
                    {
                        PrintDebug("Could not select a correct amount");
                        continue;
                    }

                    var amount = item.amount;
                    dataAmount.Modify(ref amount);

                    var stack = dataItem.IgnoreStack ? amount : Math.Min(amount, item.info.stackable);

                    item.amount = stack;
                    var dataCondition = ChanceData.Select(dataItem.Conditions);
                    if (item.hasCondition)
                    {
                        if (dataCondition != null)
                        {
                            dataCondition.Modify(ref item._condition, ref item._maxCondition);

                            if (!dataItem.IgnoreCondition)
                                item._condition = Math.Min(item._condition, item._maxCondition);
                        }
                    }
                    else if (dataCondition != null)
                    {
                        PrintDebug("Configurated item has a condition but item doesn't have condition");
                    }

                    if (!string.IsNullOrEmpty(dataItem.Name))
                        item.name = dataItem.Name;
                }
            }
        }

        private static Item GenerateDefaultItem(LootContainer lootContainer, IReadOnlyList<ItemData> blacklisted,
            ContainerData containerData, IList<Item> containerItems)
        {
            var items = Pool.GetList<Item>();
            if (lootContainer.LootSpawnSlots.Length != 0)
            {
                for (var i = 0; i < lootContainer.LootSpawnSlots.Length; i++)
                {
                    var lootSpawnSlot = lootContainer.LootSpawnSlots[i];
                    for (var j = 0; j < lootSpawnSlot.numberToSpawn; ++j)
                    {
                        if (UnityEngine.Random.Range(0.0f, 1f) <= (double) lootSpawnSlot.probability)
                        {
                            GetLootSpawnItem(lootSpawnSlot.definition, blacklisted, containerData, containerItems,
                                items);
                        }
                    }
                }
            }
            else if (lootContainer.lootDefinition != null)
            {
                for (var i = 0; i < lootContainer.maxDefinitionsToSpawn; ++i)
                {
                    GetLootSpawnItem(lootContainer.lootDefinition, blacklisted, containerData, containerItems, items);
                }
            }

            Item addedItem = null;
            if (items.Count == 0)
                goto free;

            var index = _ins._random.Next(0, items.Count);
            addedItem = items[index];
            
            items.RemoveAt(index);

            for (var i = 0; i < items.Count; i++)
            {
                items[i].Remove();
            }

            if (lootContainer.SpawnType == LootContainer.spawnType.ROADSIDE ||
                lootContainer.SpawnType == LootContainer.spawnType.TOWN)
            {
                if (addedItem.hasCondition)
                    addedItem.condition =
                        UnityEngine.Random.Range(addedItem.info.condition.foundCondition.fractionMin,
                            addedItem.info.condition.foundCondition.fractionMax) *
                        addedItem.info.condition.max;
            }

            free:
            Pool.FreeList(ref items);
            return addedItem;
        }

        private static void GetLootSpawnItem(LootSpawn loot, IReadOnlyList<ItemData> blacklisted,
            ContainerData containerData, IList<Item> containerItems, ICollection<Item> items)
        {
            if (loot.subSpawn != null && loot.subSpawn.Length != 0)
            {
                var totalWeight = loot.subSpawn.Sum(x => x.weight);
                var randomNumber = UnityEngine.Random.Range(0, totalWeight);
                for (var i = 0; i < loot.subSpawn.Length; i++)
                {
                    if (loot.subSpawn[i].category == null)
                        continue;

                    totalWeight -= loot.subSpawn[i].weight;
                    if (randomNumber >= totalWeight)
                    {
                        GetLootSpawnItem(loot.subSpawn[i].category, blacklisted, containerData, containerItems, items);
                        return;
                    }
                }

                return;
            }

            if (loot.items == null)
                return;

            for (var i = 0; i < loot.items.Length; i++)
            {
                var itemAmountRanged = loot.items[i];
                if (itemAmountRanged == null)
                    continue;

                Item item;
                if (itemAmountRanged.itemDef.spawnAsBlueprint)
                {
                    var blueprintBaseDef = loot.GetBlueprintBaseDef();
                    if (blueprintBaseDef == null)
                        continue;

                    item = ItemManager.Create(blueprintBaseDef);
                    item.blueprintTarget = itemAmountRanged.itemDef.itemid;
                }
                else
                {
                    item = ItemManager.CreateByItemID(itemAmountRanged.itemid, (int) itemAmountRanged.GetAmount());
                }

                if (IsItemBlacklisted(item, blacklisted, containerData) ||
                    IsItemDuplicate(containerItems, item, containerData))
                {
                    item.Remove();
                    continue;
                }

                items.Add(item);
            }
        }

        private static bool IsItemDuplicate(IEnumerable<Item> items, Item origin, ContainerData container)
        {
            // In case duplicate items are allowed or item is null
            if (container.AllowDuplicateItems || origin == null)
                return false;

            var originShortname = origin.IsBlueprint() ? origin.blueprintTargetDef.shortname : origin.info.shortname;
            foreach (var item in items)
            {
                if ((!container.ModifyItems || !container.ModifyIgnoreBlueprint) &&
                    item.IsBlueprint() != origin.IsBlueprint())
                    continue;

                var itemShortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname;
                if (originShortname != itemShortname)
                    continue;

                if (container.AllowDuplicateItemsDifferentSkins && origin.skin != item.skin)
                    continue;

                return true;
            }

            return false;
        }

        private static bool IsItemBlacklisted(Item item, IReadOnlyList<ItemData> blacklisted, ContainerData container)
        {
            if (item == null)
                return false;

            for (var i = 0; i < blacklisted.Count; i++)
            {
                var blacklistedItem = blacklisted[i];
                if (!blacklistedItem.ShortnameFits(item, container))
                    continue;

                return true;
            }

            return false;
        }

        // Not used in modify
        private static bool IsDuplicate(IReadOnlyList<Item> list, ContainerData container, ItemData dataItem, string shortname, ulong skin)
        {
            for (var j = 0; j < list.Count; j++)
            {
                var item = list[j];
                if (dataItem.IsBlueprint)
                {
                    if (!item.IsBlueprint() || item.blueprintTargetDef.shortname != shortname) continue;

                    PrintDebug("Found a duplicate blueprint");
                    return true;
                }

                if (item.IsBlueprint() || item.info.shortname != shortname) continue;
                if (container.AllowDuplicateItemsDifferentSkins && item.skin != skin)
                    continue;

                PrintDebug("Found a duplicate item");
                return true;
            }

            return false;
        }

        private string GetMsg(string key, string userId) => lang.GetMessage(key, this, userId);

        private static void PrintDebug(string message)
        {
            if (_config.Debug)
                Interface.Oxide.LogDebug(message);
        }

        private void LootRefill()
        {
            using (var enumerator = BaseNetworkable.serverEntities.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    OnLootSpawn(enumerator.Current);
                }
            }
        }

        private string GetMonumentName(Vector3 position)
        {
            var monuments = TerrainMeta.Path.Monuments;
            for (var i = 0; i < monuments.Count; i++)
            {
                var monument = monuments[i];
                var obb = new OBB(monument.transform.position, Quaternion.identity, monument.Bounds);
                if (obb.Contains(position))
                    return monument.name;
            }

            return string.Empty;
        }

        private static void Shuffle<T>(IList<T> list)
        {
            var count = list.Count;
            while (count > 1)
            {
                count--;
                var index = _ins._random.Next(count + 1);
                var value = list[index];
                list[index] = list[count];
                list[count] = value;
            }
        }
        
        #endregion
    }
}

// --- End of file: LootPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limited-admin ---
// --- Original File Path: L/LimitedAdmin/LimitedAdmin.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Oxide.Plugins
{
    [Info("Limited Admin", "misticos", "1.0.8")]
    [Description("Prevents admin abuse by blocking actions and commands")]
    class LimitedAdmin : RustPlugin
    {
        #region Configuration

        private Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Limited Admins (SteamID)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> Admins = new List<ulong>
            {
                76000000000000
            };

            [JsonProperty(PropertyName = "Limited Auth Levels",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<uint> LimitedAuthLevels = new List<uint>
            {
                1, 2
            };

            [JsonProperty(PropertyName = "Whitelisted Admins (SteamID)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> ExcludedAdmins = new List<ulong>
            {
                76000000000000
            };

            [JsonProperty(PropertyName = "Limit All Admins Exclude Whitelisted")]
            public bool LimitAll = true;

            [JsonProperty(PropertyName = "Blocked Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Blacklist = new List<string>
            {
                "chat.say"
            };

            [JsonProperty(PropertyName = "Can Loot Entity")]
            public bool CanLootEntity = false;

            [JsonProperty(PropertyName = "Can Loot Player")]
            public bool CanLootPlayer = false;

            [JsonProperty(PropertyName = "Can Pickup Entity")]
            public bool CanPickupEntity = false;

            [JsonProperty(PropertyName = "Can Rename Bed")]
            public bool CanRenameBed = false;

            [JsonProperty(PropertyName = "Can Use Locked Entity")]
            public bool CanUseLockedEntity = false;

            [JsonProperty(PropertyName = "Can Interact With Lock")]
            public bool CanInteractLock = false;

            [JsonProperty(PropertyName = "Can Use Voice Chat")]
            public bool CanUseVoiceChat = false;

            [JsonProperty(PropertyName = "Can Be Targeted")]
            public bool CanBeTargeted = false;

            [JsonProperty(PropertyName = "Can Build")]
            public bool CanBuild = false;

            [JsonProperty(PropertyName = "Can Interact With Structure")]
            public bool CanInteractStructure = false;

            [JsonProperty(PropertyName = "Can Hack CH47 Crate")]
            public bool CanHackCrate = false;

            [JsonProperty(PropertyName = "Can Interact With Item")]
            public bool CanInteractItem = false;

            [JsonProperty(PropertyName = "Can Pickup Item")]
            public bool CanItemPickup = false;

            [JsonProperty(PropertyName = "Can Damage")]
            public bool CanDamage = false;

            [JsonProperty(PropertyName = "Can Use Lift")]
            public bool CanUseLift = false;

            [JsonProperty(PropertyName = "Can Toggle Oven")]
            public bool CanToggleOven = false;

            [JsonProperty(PropertyName = "Can Toggle Recycler")]
            public bool CanToggleRecycler = false;

            [JsonProperty(PropertyName = "Can Interact With Turret")]
            public bool CanInteractTurret = false;

            [JsonProperty(PropertyName = "Can Gather")]
            public bool CanGather = false;

            [JsonProperty(PropertyName = "Can Update Sign")]
            public bool CanUpdateSign = false;

            [JsonProperty(PropertyName = "Can Interact With Cupboard")]
            public bool CanInteractCupboard = false;

            [JsonProperty(PropertyName = "Can Interact With Vending Machine")]
            public bool CanInteractVending = false;

            [JsonProperty(PropertyName = "Can Interact With Weapons")]
            public bool CanInteractWeapons = false;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            if (_config.CanLootEntity)
                Unsubscribe(nameof(CanLootEntity));

            if (_config.CanLootPlayer)
                Unsubscribe(nameof(CanLootPlayer));

            if (_config.CanPickupEntity)
                Unsubscribe(nameof(CanPickupEntity));

            if (_config.CanRenameBed)
                Unsubscribe(nameof(CanRenameBed));

            if (_config.CanUseLockedEntity)
                Unsubscribe(nameof(CanUseLockedEntity));

            if (_config.CanUseVoiceChat)
                Unsubscribe(nameof(OnPlayerVoice));

            if (_config.CanBeTargeted)
            {
                Unsubscribe(nameof(CanBeTargeted));
                Unsubscribe(nameof(CanBradleyApcTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
                Unsubscribe(nameof(CanHelicopterTarget));
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(OnTurretTarget));
            }

            if (_config.CanBuild)
                Unsubscribe(nameof(CanBuild));

            if (_config.CanInteractStructure)
            {
                Unsubscribe(nameof(OnStructureDemolish));
                Unsubscribe(nameof(OnStructureRepair));
                Unsubscribe(nameof(OnStructureUpgrade));
                Unsubscribe(nameof(OnStructureRotate));
            }

            if (_config.CanHackCrate)
                Unsubscribe(nameof(CanHackCrate));

            if (_config.CanInteractItem)
                Unsubscribe(nameof(OnItemAction));

            if (_config.CanItemPickup)
                Unsubscribe(nameof(OnItemPickup));

            if (_config.CanDamage)
                Unsubscribe(nameof(OnEntityTakeDamage));

            if (_config.CanUseLift)
                Unsubscribe(nameof(OnLiftUse));

            if (_config.CanToggleOven)
                Unsubscribe(nameof(OnOvenToggle));

            if (_config.CanToggleRecycler)
                Unsubscribe(nameof(OnRecyclerToggle));

            if (_config.CanInteractTurret)
            {
                Unsubscribe(nameof(OnTurretAuthorize));
                Unsubscribe(nameof(OnTurretDeauthorize));
                Unsubscribe(nameof(OnTurretClearList));
            }

            if (_config.CanGather)
            {
                Unsubscribe(nameof(OnCollectiblePickup));
                Unsubscribe(nameof(OnDispenserBonus));
                Unsubscribe(nameof(OnDispenserGather));
                Unsubscribe(nameof(OnGrowableGather));
            }

            if (_config.CanUpdateSign)
                Unsubscribe(nameof(CanUpdateSign));

            if (_config.CanInteractLock)
            {
                Unsubscribe(nameof(CanLock));
                Unsubscribe(nameof(CanUnlock));
                Unsubscribe(nameof(OnCodeEntered));
                Unsubscribe(nameof(CanChangeCode));
            }

            if (_config.CanInteractCupboard)
            {
                Unsubscribe(nameof(OnCupboardAuthorize));
                Unsubscribe(nameof(OnCupboardClearList));
                Unsubscribe(nameof(OnCupboardDeauthorize));
            }

            if (_config.CanInteractVending)
            {
                Unsubscribe(nameof(CanAdministerVending));
                Unsubscribe(nameof(CanUseVending));
                Unsubscribe(nameof(OnRotateVendingMachine));
            }

            if (_config.CanInteractWeapons)
            {
                Unsubscribe(nameof(CanCreateWorldProjectile));
                Unsubscribe(nameof(OnReloadMagazine));
                Unsubscribe(nameof(OnReloadWeapon));
                Unsubscribe(nameof(OnSwitchAmmo));
            }
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !IsLimited(player))
                return null;

            var command = arg.cmd.FullName;
            return _config.Blacklist.Contains(command) ? false : (object) null;
        }

        #region Can Loot Entity

        private object CanLootEntity(BasePlayer player, Object container) =>
            IsLimited(player) ? false : (object) null;

        #endregion

        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => IsLimited(looter) ? false : (object) null;

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity) =>
            IsLimited(player) ? false : (object) null;

        private object CanRenameBed(BasePlayer player, SleepingBag bed, string bedName) =>
            IsLimited(player) ? false : (object) null;

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock) =>
            IsLimited(player) ? false : (object) null;

        private object OnPlayerVoice(BasePlayer player, byte[] data) => IsLimited(player) ? false : (object) null;

        #region Can Be Targeted

        private object CanBeTargeted(BaseCombatEntity entity, MonoBehaviour behaviour)
        {
            var player = entity as BasePlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        private object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
        {
            var player = entity as BasePlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI entity, BasePlayer target) =>
            IsLimited(target) ? false : (object) null;

        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnNpcTarget(BaseNpc npc, BaseEntity entity)
        {
            var player = entity as BasePlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            var player = entity as BasePlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        #endregion

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target) =>
            IsLimited(planner.GetOwnerPlayer()) ? false : (object) null;

        #region Can Interact With Structure

        private object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player, bool immediate) =>
            IsLimited(player) ? false : (object) null;

        private object OnStructureRepair(BaseCombatEntity entity, BasePlayer player, bool immediate) =>
            IsLimited(player) ? false : (object) null;

        private object OnStructureRotate(BaseCombatEntity entity, BasePlayer player, bool immediate) =>
            IsLimited(player) ? false : (object) null;

        private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, bool immediate) =>
            IsLimited(player) ? false : (object) null;

        #endregion

        private object CanHackCrate(BasePlayer player, HackableLockedCrate crate) =>
            IsLimited(player) ? false : (object) null;

        private object OnItemAction(Item item, string action, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnItemPickup(Item item, BasePlayer player) => IsLimited(player) ? false : (object) null;

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var player = info.InitiatorPlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        #region Can Use Lift

        private object OnLiftUse(Object lift, BasePlayer player) => IsLimited(player) ? false : (object) null;

        #endregion

        private object OnOvenToggle(BaseOven oven, BasePlayer player) => IsLimited(player) ? false : (object) null;

        private object OnRecyclerToggle(Recycler recycler, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        #region Can Interact With Turret

        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnTurretClearList(AutoTurret turret, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnTurretDeauthorize(AutoTurret turret, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        #endregion

        #region Can Gather

        private object OnCollectiblePickup(Item item, BasePlayer player) => IsLimited(player) ? false : (object) null;

        private object OnGrowableGather(GrowableEntity plant, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) =>
            IsLimited(player) ? false : (object) null;

        private object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity as BasePlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        #endregion

        private object CanUpdateSign(BasePlayer player, Signage sign) => IsLimited(player) ? (object) false : null;

        #region Can Interact With Lock

        private object CanLock(BasePlayer player, BaseLock baseLock) => IsLimited(player) ? false : (object) null; 

        private object CanUnlock(BasePlayer player, BaseLock baseLock) => IsLimited(player) ? false : (object) null;

        private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code) =>
            IsLimited(player) ? false : (object) null;

        private object CanChangeCode(CodeLock codeLock, BasePlayer player, string newCode, bool isGuestCode) =>
            IsLimited(player) ? false : (object) null;

        private object CanPickupLock(BasePlayer player, BaseLock baseLock) =>
            IsLimited(player) ? false : (object) null;
        
        #endregion
        
        #region Can Interact With Cupboard

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;
        
        #endregion
        
        #region Can Interact With Vending Machine

        private object CanAdministerVending(BasePlayer player, VendingMachine machine) =>
            IsLimited(player) ? false : (object) null;

        private object CanUseVending(VendingMachine machine, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;

        private object OnRotateVendingMachine(VendingMachine machine, BasePlayer player) =>
            IsLimited(player) ? false : (object) null;
        
        #endregion
        
        #region Can Interact With Weapons

        private object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
        {
            var player = info.InitiatorPlayer;
            return player == null || player.IsNpc || player.net?.connection == null || !IsLimited(player)
                ? (object) null
                : false;
        }

        private object OnReloadMagazine(BasePlayer player, BaseProjectile projectile) =>
            IsLimited(player) ? false : (object) null;

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile) =>
            IsLimited(player) ? false : (object) null;

        private object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile) =>
            IsLimited(player) ? false : (object) null;
        
        #endregion
        
        #endregion
        
        #region Helpers

        private bool IsLimited(BasePlayer player)
        {
            if (player == null || player.net?.connection == null)
                return false;

            if (_config.Admins.Contains(player.userID))
                return true;

            if (_config.LimitAll && _config.ExcludedAdmins.Contains(player.userID))
                return false;

            if (_config.LimitAll && _config.LimitedAuthLevels.Contains(player.net.connection.authLevel))
                return true;

            return false;
        }

        private void PrintDebug(string message)
        {
            if (_config.Debug)
                Interface.Oxide.LogDebug(message);
        }

        #endregion
    }
}

// --- End of file: LimitedAdmin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/local-time-damage-control ---
// --- Original File Path: L/LocalTimeDamageControl/LocalTimeDamageControl.cs ---

﻿using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("LocalTimeDamageControl", "CARNY666", "1.0.11", ResourceId = 2720)]

    class LocalTimeDamageControl : RustPlugin
    {
        const string adminPriv = "LocalTimeDamageControl.admin";
        bool activated = false;

        void Init()
        {
            try
            { 
                PrintWarning($"{this.Title} {this.Version} Initialized @ {DateTime.Now.ToLongTimeString()}...");
                LoadConfig();
            }
            catch (Exception ex)
            {
                PrintError($"Error Init: {ex.StackTrace}");
            }

        }

        void Loaded()
        {
            try
            {
                lang.RegisterMessages(new Dictionary<string, string>
                {
                    { "localtime", "Local time is {localtime}." },
                    { "nodamage", "You cannot cause damage during between {starttime} and {endtime}." },
                    { "activated", "You cannot cause damage during while LocalTimeDamageControl is activated." },
                    { "starts", "LocalTimeDamageControl starts at {starts}." },
                    { "remains", "LocalTimeDamageControl remains on for {remains}." },
                    { "onstatus", "LocalTimeDamageControl is ON. It will become active @ {starttime} until {endtime}" },
                    { "offstatus", "LocalTimeDamageControl is {status}. It will NOT become active." },
                    { "duration", "LocalTimeDamageControl duration is {duration} minutes." },
                    { "errorstart", "Error, please 24 hour time format: i.e 08:00 for 8 am. 20:00 for 8pm." },
                    { "errormin", "Error, please enter an integer i.e: 60 for 60 minutes." },
                    { "errorhour", "Error, please enter an integer i.e: 2 for 180 minutes." },
                    { "activate", "- Activates (ignores configuration)"},
                    { "deactivate", "- Deactivate (back to normal, uses config)"},
                    { "info", "- LocalTimeDamageControl {act} inform players when they are unable to damage."},
                    { "help1", "/lset start 8:00 am ~ Set start time for damage control." },
                    { "help2", "/lset minutes 60    ~ Set duration in minutes for damage control."},
                    { "help3", "/lset hours 12      ~ Set duration in hours for damage control."},
                    { "help4", "/lset activate      ~ Force damage control ON, ignore config."},
                    { "help5", "/lset info          ~ Toggle player message, when damage is denied."},
                    { "help6", "/lset deactivate    ~ use configured times."},
                    { "help7", "/lset off           ~ Turn off damage control."},
                    { "help8", "/lset on            ~ Turn on damage control during set times. "},
                    { "help9", "- starts at {starttime} ends at {endtime}. (Server's time)"}
            }, this, "en");


                //if ((bool)Config["LocalTimeDamageControlOn"])
                //{
                    PrintWarning("LocalTimeDamageControl starts at " + ShowTime(Config["LocalTimeDamageControlStart"]));
                    PrintWarning("LocalTimeDamageControl remains on for " + Config["LocalTimeDamageControlDuratationMinutes"] + " minutes.");                
                //}
                //else
                //{
                //    PrintWarning("LocalTimeDamageControl is off.");
                //}
                permission.RegisterPermission(adminPriv, this);
                PrintWarning(adminPriv + " privilidge is registered.");

            }
            catch (Exception ex)
            {
                PrintError($"Error Loaded: {ex.StackTrace}");
            }

        }

        protected override void LoadDefaultConfig() // Only called if the config file does not already exist
        {
            try
            {
                PrintWarning("Creating a new configuration file.");

                Config.Clear();

                Config["LocalTimeDamageControlStart"] = "08:30 AM";           // 8:30 AM
                Config["LocalTimeDamageControlDuratationMinutes"] = (8 * 60); // 8 hrs
                Config["LocalTimeDamageControlOn"] = true;
                Config["LocalTimeDamageControlInformPlayer"] = true;

                SaveConfig();
            }
            catch(Exception ex)
            {
                throw new Exception($"Error LoadDefaultConfig", ex);
            }

        }

        public bool IsDamageControlOn()
        {
            try
            {
                if (activated)
                {
                    //PrintWarning("IsDamageControlOn: activated: true;");
                    return true;
                }

                //if ((bool)Config["LocalTimeDamageControlOn"] == false)
                //{
                //    PrintWarning("IsDamageControlOn: LocalTimeDamageControlOn: false;");
                //    return false;
                //}

                DateTime startTime = DateTime.ParseExact(Config["LocalTimeDamageControlStart"].ToString(), "hh:mm tt", CultureInfo.InvariantCulture);
                DateTime endTime = DateTime.ParseExact(Config["LocalTimeDamageControlStart"].ToString(), "hh:mm tt", CultureInfo.InvariantCulture).AddMinutes(int.Parse(Config["LocalTimeDamageControlDuratationMinutes"].ToString()));

                if ((DateTime.Now.ToLocalTime() >= startTime) && (DateTime.Now.ToLocalTime() <= endTime))
                {
                    //PrintWarning("IsDamageControlOn: Within Time Window: true;");
                    return true;
                }
                else
                {
                    //PrintWarning("IsDamageControlOn: Within Time Window: false;");
                    return false;
                }
            }
            catch(Exception ex)
            {
                throw new Exception($"Error IsDamageControlOn", ex);
            }
        }

        public DateTime getStartTime()
        {
            try
            {
                return DateTime.Parse(Config["LocalTimeDamageControlStart"].ToString());
            }
            catch(Exception ex)
            {
                throw new Exception($"Error getStartTime. {Config["LocalTimeDamageControlStart"].ToString()}" , ex);
            }
        }

        public DateTime getEndTime()
        {
            try
            {
                return DateTime.Parse(Config["LocalTimeDamageControlStart"].ToString()).AddMinutes(int.Parse(Config["LocalTimeDamageControlDuratationMinutes"].ToString()));
            }
            catch(Exception ex)
            {
                throw new Exception($"Error getEndTime. {Config["LocalTimeDamageControlStart"].ToString()}, {Config["LocalTimeDamageControlDuratationMinutes"].ToString()}", ex);
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null) return null; 
                if (info == null) return null; 
                if (info.InitiatorPlayer == null) return null;
                if (IsDamageControlOn() == false) return null;                  // check if on or off
                if (entity is BasePlayer) return null;                          // damage to players ok!!
                if (entity.OwnerID == 0) return null;
                if (entity.OwnerID == info.InitiatorPlayer.userID) return null; // owner can damage own stuff

                if (info.InitiatorPlayer != null) {

                    if ((bool)Config["LocalTimeDamageControlInformPlayer"] == true)                    
                    {
                        if (!activated)
                        {
                            if (info.InitiatorPlayer != null)
                            {
                                PrintToChat(info.InitiatorPlayer, lang.GetMessage("nodamage", this, info.InitiatorPlayer.UserIDString)
                                    .Replace("{starttime}", ShowTime(getStartTime()))
                                    .Replace("{endtime}", ShowTime(getEndTime())));
                                
                            }
                        }
                        else
                        {
                            if (info.InitiatorPlayer != null)
                                PrintToChat(info.InitiatorPlayer, lang.GetMessage("activated", this, info.InitiatorPlayer.UserIDString));
                            
                        }
                    }
                }

                info.damageTypes.ScaleAll(0.0f);                                // no damage
                return false;
            }
            catch (Exception ex)
            {
                PrintError("Error OnEntityTakeDamage: " + ex.Message);
                
            }
            return null;
        }

        [ChatCommand("lset")]
        private void lset(BasePlayer player, string command, string[] args)
        {

            PrintToChat(player, lang.GetMessage("localtime", this, player.UserIDString)
                .Replace("{localtime}", ShowTime(DateTime.Now.ToLocalTime())));

            if (!permission.UserHasPermission(player.UserIDString, adminPriv))
                return;

            if (args.Count() > 0)
            {
                #region toggle
                //if (args[0].ToLower() == "off")
                //{
                //    Config["LocalTimeDamageControlOn"] = false;
                //    PrintToChat(player, lang.GetMessage("offstatus", this, player.UserIDString)
                //        .Replace("{status}", ((bool)Config["LocalTimeDamageControlOn"] ? "ON" : "OFF")));
                //    SaveConfig();
                //    return;
                //}

                //if (args[0].ToLower() == "on")
                //{
                //    Config["LocalTimeDamageControlOn"] = true;
                //    PrintToChat(player, lang.GetMessage("onstatus", this, player.UserIDString)
                //        .Replace("{status}", ((bool)Config["LocalTimeDamageControlOn"] ? "ON" : "OFF"))
                //        .Replace("{starttime}", ShowTime(getStartTime()))
                //        .Replace("{endtime}", ShowTime(getEndTime())));

                //    SaveConfig();
                //    return;
                //}

                if (args[0].ToLower() == "activate")
                {
                    activated = true;
                    PrintToChat(player, lang.GetMessage("activate", this, player.UserIDString));
                    return;
                }
                
                if (args[0].ToLower() == "deactivate")
                {
                    activated = false;
                    PrintToChat(player, lang.GetMessage("deactivate", this, player.UserIDString));
                    return;
                }

                if (args[0].ToLower() == "info")
                {
                    if ((bool)Config["LocalTimeDamageControlInformPlayer"] == true) 
                        Config["LocalTimeDamageControlInformPlayer"] = false;

                    else
                        Config["LocalTimeDamageControlInformPlayer"] = true;

                    PrintToChat(player, lang.GetMessage("info", this, player.UserIDString).Replace("{act}",$"{(((bool)Config["LocalTimeDamageControlInformPlayer"] == true)?"WILL":"WILL NOT") }"));

                        
                    SaveConfig();
                    return;


                }
                #endregion

                if (args[0].ToLower() == "start")
                    {
                    try
                    {
                        //DateTime dateTime = DateTime.ParseExact(args[1].ToUpper(), "HH:mm", CultureInfo.InvariantCulture);

                        DateTime dateTime = DateTime.Parse(args[1].ToUpper());

                        Config["LocalTimeDamageControlStart"] = dateTime.ToString("hh:mm tt" , CultureInfo.CurrentCulture);

                        SaveConfig();

                        PrintToChat(player, lang.GetMessage("starts", this, player.UserIDString)
                            .Replace("{starts}", ShowTime(Config["LocalTimeDamageControlStart"])));
                    }
                    catch (Exception)
                    {
                        PrintToChat(player, lang.GetMessage("errorstart", this, player.UserIDString));
                        
                    }
                    return;
                }
                if (args[0].ToLower() == "minutes")
                {
                    try
                    {
                        Config["LocalTimeDamageControlDuratationMinutes"] = int.Parse(args[1]);
                        SaveConfig();
                        PrintToChat(lang.GetMessage("duration", this, player.UserIDString)
                            .Replace("{duration}", Config["LocalTimeDamageControlDuratationMinutes"].ToString()));
                    }
                    catch (Exception)
                    {
                        PrintToChat(player, lang.GetMessage("errormin", this, player.UserIDString));

                    }
                    return;
                }
                if (args[0].ToLower() == "hours")
                {
                    try
                    {
                        Config["LocalTimeDamageControlDuratationMinutes"] = int.Parse(args[1]) * 60;
                        SaveConfig();
                        PrintToChat(lang.GetMessage("duration", this, player.UserIDString)
                            .Replace("{duration}", Config["LocalTimeDamageControlDuratationMinutes"].ToString()));
                    }
                    catch (Exception)
                    {
                        PrintToChat(player, lang.GetMessage("errorhour", this, player.UserIDString));
                    }
                    return;
                }

            }
            else
            {
                for (int ii = 1; ii <= 9; ii++)
                    PrintToChat(player, lang.GetMessage("help" + ii, this, player.UserIDString)
                        .Replace("{starttime}", ShowTime(getStartTime()))
                        .Replace("{endtime}", ShowTime(getEndTime())));
            }


        }

        string ShowTime(object TimeIn)
        {
            return DateTime.Parse(TimeIn.ToString()).ToString("hh:mm tt");
        }

        Dictionary<string, string> get()
        {
            return new Dictionary<string, string>
            {
                { "localtime", "Local time is {localtime}." },
                { "nodamage", "You cannot cause damage during between {starttime} and {endtime}." },
                { "activated", "You cannot cause damage during while LocalTimeDamageControl is activated." },
                { "starts", "LocalTimeDamageControl starts at {starts}." },
                { "remains", "LocalTimeDamageControl remains on for {remains}." },
                { "onstatus", "LocalTimeDamageControl is ON. It will become active @ {starttime} until {endtime}" },
                { "offstatus", "LocalTimeDamageControl is {status}. It will NOT become active." },
                { "duration", "LocalTimeDamageControl duration is {duration} minutes." },
                { "errorstart", "Error, please 24 hour time format: i.e 08:00 for 8 am. 20:00 for 8pm." },
                { "errormin", "Error, please enter an integer i.e: 60 for 60 minutes." },
                { "errorhour", "Error, please enter an integer i.e: 2 for 180 minutes." },
                { "activate", "- Activates (ignores configuration)" },
                { "deactivate", "- Deactivate (back to normal, uses config)" },
                { "info", "- LocalTimeDamageControl {act} inform players when they are unable to damage." },
                { "help1", "/lset start 8:00 am ~ Set start time for damage control." },
                { "help2", "/lset minutes 60    ~ Set duration in minutes for damage control." },
                { "help3", "/lset hours 12      ~ Set duration in hours for damage control." },
                { "help4", "/lset activate      ~ Force damage control ON, ignore config." },
                { "help5", "/lset info          ~ Toggle player message, when damage is denied." },
                { "help6", "/lset deactivate    ~ use configured times." },
                { "help7", "/lset off           ~ Turn off damage control." },
                { "help8", "/lset on            ~ Turn on damage control during set times. " },
                { "help9", "- starts at {starttime} ends at {endtime}. (Server's time)" }

            };
        }

    }
}


// --- End of file: LocalTimeDamageControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/laptop-crate-hack ---
// --- Original File Path: L/LaptopCrateHack/LaptopCrateHack.cs ---

﻿using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Previous maintenance and contributions by Arainrr
 * Originally created by TheSurgeon
 */

namespace Oxide.Plugins
{
    [Info("Laptop Crate Hack", "VisEntities", "2.0.2")]
    [Description("Hack locked crates using targeting computers.")]
    public class LaptopCrateHack : RustPlugin
    {
        #region 3rd Party Dependencies

        [PluginReference]
        private readonly Plugin Clans, Friends;

        #endregion 3rd Party Dependencies

        #region Fields

        private static LaptopCrateHack _plugin;
        private static Configuration _config;
        
        private const int ITEM_ID_COMPUTER = 1523195708;
        private const string FX_CODE_LOCK_SHOCK = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";

        private Dictionary<ulong, DateTime> _playerLastHackTimes = new Dictionary<ulong, DateTime>();
        
        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Required Targeting Computers For Hack")]
            public int RequiredTargetingComputersForHack { get; set; }
            
            [JsonProperty("Consume Targeting Computer On Hack")]
            public bool ConsumeTargetingComputerOnHack { get; set; }

            [JsonProperty("Crate Unlock Time Seconds")]
            public float CrateUnlockTimeSeconds { get; set; }

            [JsonProperty("Cooldown Between Hacks Seconds")]
            public float CooldownBetweenHacksSeconds { get; set; }

            [JsonProperty("Crate Lootable By Hacker Only")]
            public bool CrateLootableByHackerOnly { get; set; }

            [JsonProperty("Can Be Looted By Hacker Teammates")]
            public bool CanBeLootedByHackerTeammates { get; set; }

            [JsonProperty("Can Be Looted By Hacker Friends")]
            public bool CanBeLootedByHackerFriends { get; set; }

            [JsonProperty("Can Be Looted By Hacker Clanmates")]
            public bool CanBeLootedByHackerClanmates { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Config changes detected! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            PrintWarning("Config update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),
                RequiredTargetingComputersForHack = 1,
                ConsumeTargetingComputerOnHack = true,
                CrateUnlockTimeSeconds = 900f,
                CooldownBetweenHacksSeconds = 300f,
                CrateLootableByHackerOnly = true,
                CanBeLootedByHackerTeammates = true,
                CanBeLootedByHackerFriends = false,
                CanBeLootedByHackerClanmates = false
            };
        }

        #endregion Configuration

        #region Oxide Hooks

        private void Init()
        {
            _plugin = this;
        }

        private void Unload()
        {
            _config = null;
            _plugin = null;
        }

        private object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null || crate == null)
                return null;

            if (_config.RequiredTargetingComputersForHack > 0)
            {
                Item activeItem = player.GetActiveItem();
                if (activeItem == null || activeItem.info.itemid != ITEM_ID_COMPUTER || activeItem.amount < _config.RequiredTargetingComputersForHack)
                {
                    SendReplyToPlayer(player, Lang.NeedTargetingComputer, _config.RequiredTargetingComputersForHack);
                    OnCrateHackFailed(crate);
                    return true;
                }
            }

            if (_playerLastHackTimes.TryGetValue(player.userID, out DateTime lastHackTime))
            {
                var timeSinceLastHack = DateTime.UtcNow - lastHackTime;
                if (timeSinceLastHack.TotalSeconds < _config.CooldownBetweenHacksSeconds)
                {
                    var timeLeft = _config.CooldownBetweenHacksSeconds - timeSinceLastHack.TotalSeconds;
                    SendReplyToPlayer(player, Lang.CooldownBeforeNextHack, timeLeft);
                    OnCrateHackFailed(crate);
                    return true;
                }
            }

            crate.hackSeconds = HackableLockedCrate.requiredHackSeconds - _config.CrateUnlockTimeSeconds;
            return null;
        }

        private void OnCrateHack(HackableLockedCrate crate)
        {
            if (crate == null || crate.originalHackerPlayerId == 0)
                return;

            BasePlayer player = BasePlayer.FindByID(crate.originalHackerPlayerId);
            if (player != null)
            {
                _playerLastHackTimes[player.userID] = DateTime.UtcNow;

                if (_config.ConsumeTargetingComputerOnHack)
                {
                    Item activeItem = player.GetActiveItem();
                    if (activeItem != null && activeItem.info.itemid == ITEM_ID_COMPUTER)
                    {
                        activeItem.UseItem(_config.RequiredTargetingComputersForHack);
                    }
                }
            }
        }

        private object CanLootEntity(BasePlayer player, HackableLockedCrate crate)
        {
            if (crate == null || player == null)
                return null;

            if (_config.CrateLootableByHackerOnly && crate.originalHackerPlayerId != player.userID)
            {
                bool isTeammate = _config.CanBeLootedByHackerTeammates && AreTeammates(player, crate.originalHackerPlayerId);
                bool isFriend = _config.CanBeLootedByHackerFriends && FriendUtil.AreFriends(player.userID, crate.originalHackerPlayerId);
                bool isClanmate = _config.CanBeLootedByHackerClanmates && ClanUtil.AreClanmates(player.userID, crate.originalHackerPlayerId);

                if (isTeammate || isFriend || isClanmate)
                    return null;
                else
                {
                    SendReplyToPlayer(player, Lang.CrateLootDenied);
                    return true;
                }
            }

            return null;
        }

        #endregion Oxide Hooks

        #region Clan Integration

        private static class ClanUtil
        {
            public static bool AreClanmates(ulong firstPlayerId, ulong secondPlayerId)
            {
                if (!VerifyPluginBeingLoaded(_plugin.Clans))
                    return false;

                return (bool)_plugin.Call("IsClanMember", firstPlayerId, secondPlayerId);
            }
        }

        #endregion Clan Integration

        #region Friend Integration
        
        private static class FriendUtil
        {
            public static bool AreFriends(ulong firstPlayerId, ulong secondPlayerId)
            {
                if (!VerifyPluginBeingLoaded(_plugin.Friends))
                    return false;

                return (bool)_plugin.Friends.Call("HasFriend", firstPlayerId, secondPlayerId);
            }
        }

        #endregion Friend Integration

        #region Functions
        
        private void OnCrateHackFailed(HackableLockedCrate crate)
        {
            RunEffect(FX_CODE_LOCK_SHOCK, crate.transform.TransformPoint(new Vector3(0.02f, 1.10f, 0.56f)), Vector3.up);
        }

        #endregion Functions

        #region Helper Functions

        public static bool VerifyPluginBeingLoaded(Plugin plugin)
        {
            if (plugin != null && plugin.IsLoaded)
                return true;
            else
                return false;
        }

        public static bool AreTeammates(BasePlayer firstPlayer, ulong secondPlayerId)
        {
            if (firstPlayer.Team != null && firstPlayer.Team.members.Contains(secondPlayerId))
                return true;

            return false;
        }

        private static void RunEffect(string prefab, Vector3 worldPosition = default(Vector3), Vector3 worldDirection = default(Vector3), Connection effectRecipient = null, bool sendToAll = false)
        {
            Effect.server.Run(prefab, worldPosition, worldDirection, effectRecipient, sendToAll);
        }

        #endregion Helper Functions

        #region Localization

        private class Lang
        {
            public const string NeedTargetingComputer = "NeedTargetingComputer";
            public const string CooldownBeforeNextHack = "CooldownBeforeNextHack";
            public const string CrateLootDenied = "CrateLootDenied";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.NeedTargetingComputer] = "You need to hold <color=#FABE28>{0}</color> targeting computers in your hand to hack this crate.",
                [Lang.CooldownBeforeNextHack] = "You must wait <color=#FABE28>{0:N0}</color> more seconds before hacking another crate.",
                [Lang.CrateLootDenied] = "This crate is reserved for the original hacker and cannot be looted."
            }, this, "en");
        }

        public void SendReplyToPlayer(BasePlayer player, string messageKey, params object[] args)
        {
            string message = lang.GetMessage(messageKey, this, player.UserIDString);
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, message);
        }

        #endregion Localization
    }
}

// --- End of file: LaptopCrateHack.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limited-drone-height ---
// --- Original File Path: L/LimitedDroneHeight/LimitedDroneHeight.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Limited Drone Height", "WhiteThunder", "1.0.0")]
    [Description("Limits how high RC drones can be flown above terrain.")]
    internal class LimitedDroneHeight : CovalencePlugin
    {
        #region Fields

        private static LimitedDroneHeight _pluginInstance;
        private static Configuration _pluginConfig;

        private const string PermissionProfilePrefix = "limiteddroneheight";

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginConfig.Init(this);
            _pluginInstance = this;
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var computerStation = player.GetMounted() as ComputerStation;
                if (computerStation == null)
                    continue;

                var drone = computerStation.currentlyControllingEnt.Get(serverside: true) as Drone;
                if (drone == null)
                    continue;

                OnDroneControlStarted(drone);
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null)
                    continue;

                HeightLimiter.RemoveFromDrone(drone);
            }

            _pluginConfig = null;
            _pluginInstance = null;
        }

        private void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, Drone drone)
        {
            OnDroneControlStarted(drone);
        }

        private void OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, Drone drone)
        {
            OnDroneControlEnded(drone);
        }

        // This hook is exposed by plugin: Ridable Drones (RidableDrones).
        private void OnDroneControlStarted(Drone drone)
        {
            var maxHeight = _pluginConfig.GetMaxHeightForDrone(drone);
            if (maxHeight == 0)
                return;

            if (LimitHeightWasBlocked(drone))
                return;

            HeightLimiter.StartControl(drone, maxHeight);
        }

        // This hook is exposed by plugin: Ridable Drones (RidableDrones).
        private void OnDroneControlEnded(Drone drone)
        {
            if (drone == null)
                return;

            HeightLimiter.StopControl(drone);
        }

        #endregion

        #region Helper Methods

        private static bool LimitHeightWasBlocked(Drone drone)
        {
            object hookResult = Interface.CallHook("OnDroneHeightLimit", drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool IsDroneEligible(Drone drone) => !(drone is DeliveryDrone);

        private static string GetProfilePermission(string profileSuffix) =>
            $"{PermissionProfilePrefix}.{profileSuffix}";

        #endregion

        private class HeightLimiter : EntityComponent<Drone>
        {
            private const float DistanceFromMaxHeightToSlow = 5;
            private const float DistanceToleranceAboveMaxHeight = 5;

            public static void StartControl(Drone drone, int maxHeight) =>
                drone.GetOrAddComponent<HeightLimiter>().OnControlStarted(maxHeight);

            public static void StopControl(Drone drone) =>
                drone.GetComponent<HeightLimiter>()?.OnControlStopped();

            public static void RemoveFromDrone(Drone drone) =>
                DestroyImmediate(drone.GetComponent<HeightLimiter>());

            private Transform _droneTransform;
            private int _maxHeight;
            private int _numControllers = 0;

            private void Awake()
            {
                _droneTransform = baseEntity.transform;
            }

            private void OnControlStarted(int maxHeight)
            {
                CancelInvoke(DelayedDestroy);

                _numControllers++;
                _maxHeight = maxHeight;
            }

            private void DelayedDestroy() => DestroyImmediate(this);

            private void OnControlStopped()
            {
                _numControllers--;
                if (_numControllers <= 0)
                    Invoke(DelayedDestroy, 0);
            }

            // Using LateUpdate since RidableDrones uses Update() to send player inputs.
            private void LateUpdate()
            {
                if (!baseEntity.IsBeingControlled)
                    return;

                // Optimization: Skip if there was no user input this frame (keep using previous input).
                // This may not be totally ideal if the player is lagging and not sending updates,
                // since that could mean the drone will keep moving downward.
                if (baseEntity.lastInputTime < Time.time)
                    return;

                var dronePosition = _droneTransform.position;
                var terrainOrWaterHeight = Math.Max(TerrainMeta.WaterMap.GetHeight(dronePosition), TerrainMeta.HeightMap.GetHeight(dronePosition));
                var currentHeight = dronePosition.y - terrainOrWaterHeight;

                var heightDiff = currentHeight - _maxHeight;
                var currentThrottle = baseEntity.currentInput.throttle;

                if (heightDiff > DistanceToleranceAboveMaxHeight && currentThrottle >= 0)
                {
                    // Drone is above max height, and the player is not attempting to move down, so set throttle to negative to make the drone move down.
                    baseEntity.currentInput.throttle = -heightDiff / baseEntity.altitudeAcceleration;
                }
                else if (heightDiff >= 0 && currentThrottle > 0)
                {
                    // Drone is within allowed distance above max height, and the player is attempting to move up, so set throttle to zero.
                    baseEntity.currentInput.throttle = 0;
                }
                else if (heightDiff < 0 && heightDiff >= -DistanceFromMaxHeightToSlow && currentThrottle > 0)
                {
                    // Close to max height, and the player is attempting to move up, so reduce throttle relative to the distance.
                    // For example: If 4 meters away, use 0.8 throttle. If 2 meters away, use 0.4 throttle.
                    baseEntity.currentInput.throttle = 1 / DistanceFromMaxHeightToSlow * heightDiff / baseEntity.altitudeAcceleration;
                }
            }
        }

        #region Configuration

        private class HeightProfile
        {
            [JsonProperty("PermissionSuffix")]
            public string PermissionSuffix;

            [JsonProperty("MaxHeight")]
            public int MaxHeight;

            [JsonIgnore]
            public string Permission;

            public void Init(LimitedDroneHeight pluginInstance)
            {
                if (string.IsNullOrWhiteSpace(PermissionSuffix))
                    return;

                Permission = GetProfilePermission(PermissionSuffix);
                pluginInstance.permission.RegisterPermission(Permission, pluginInstance);
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("DefaultMaxHeight")]
            public int DefaultMaxHeight = 75;

            [JsonProperty("ProfilesRequiringPermission")]
            public HeightProfile[] ProfilesRequiringPermission = new HeightProfile[]
            {
                new HeightProfile()
                {
                    PermissionSuffix = "low",
                    MaxHeight = 25,
                },
                new HeightProfile()
                {
                    PermissionSuffix = "medium",
                    MaxHeight = 75,
                },
                new HeightProfile()
                {
                    PermissionSuffix = "high",
                    MaxHeight = 125,
                },
                new HeightProfile()
                {
                    PermissionSuffix = "unlimited",
                    MaxHeight = 0,
                },
            };

            public void Init(LimitedDroneHeight pluginInstance)
            {
                foreach (var profile in ProfilesRequiringPermission)
                    profile.Init(pluginInstance);
            }

            public int GetMaxHeightForDrone(Drone drone)
            {
                if (drone.OwnerID == 0)
                    return DefaultMaxHeight;

                if (ProfilesRequiringPermission == null)
                    return DefaultMaxHeight;

                var ownerIdString = drone.OwnerID.ToString();

                for (var i = ProfilesRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var profile = ProfilesRequiringPermission[i];
                    if (profile.Permission != null && _pluginInstance.permission.UserHasPermission(ownerIdString, profile.Permission))
                        return profile.MaxHeight;
                }

                return DefaultMaxHeight;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: LimitedDroneHeight.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limited-smoke-grenade ---
// --- Original File Path: L/LimitedSmokeGrenade/LimitedSmokeGrenade.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Limited Smoke Grenade", "Lincoln", "1.0.3")]
    [Description("Limit the smoke grenade duration time.")]
    public class LimitedSmokeGrenade : RustPlugin
    {
        #region Vars
        
        private const string permUse = "LimitedSmokeGrenade.use";
        
        #endregion
        
        #region Oxide Hooks
        
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            config = Config.ReadObject<PluginConfig>();
        }
        
        private void OnExplosiveThrown(BasePlayer player, SmokeGrenade smokeGrenade)
        {
            SmokeGrenade(player, smokeGrenade);
        }
        private void OnExplosiveDropped(BasePlayer player, SmokeGrenade smokeGrenade)
        {
            SmokeGrenade(player, smokeGrenade);
        }
        private void OnRocketLaunched(BasePlayer player, SmokeGrenade smokeGrenade)
        {
            SmokeGrenade(player, smokeGrenade);
        }
        private void SmokeGrenade(BasePlayer player, SmokeGrenade smokeGrenade)
        {
            if (permission.UserHasPermission(player.UserIDString, permUse))
            {
                smokeGrenade.smokeDuration = config.SmokeDurationInSeconds;
            }
        }
        
        #endregion

        #region Config
        
        private class PluginConfig
        {
            [JsonProperty("Smoke Duration (seconds)")]
            public int SmokeDurationInSeconds;
        }

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                SmokeDurationInSeconds = 45
            };
        }
        
        #endregion
    }
}

// --- End of file: LimitedSmokeGrenade.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/legacy-nodes ---
// --- Original File Path: L/LegacyNodes/LegacyNodes.cs ---

using System;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Legacy Nodes", "xdEggie", "1.0.2")]
    [Description("Restore legacy nodes to current rust")]
    class LegacyNodes : CovalencePlugin
    {

        #region References

        [PluginReference]
        private Plugin GatherRates;

        #endregion

        #region initialize

        private string permPrefix = "LegacyNodes.enabled";
        private List<BasePlayer> quedLastHit = new List<BasePlayer>();
        private List<ResourceDispenser> blacklisted = new List<ResourceDispenser>();
        private List<ResourceDispenser> nonbonusmetal = new List<ResourceDispenser>();
        private Dictionary<ResourceDispenser, NodeData> nodes = new Dictionary<ResourceDispenser, NodeData>();

        private int stone = -2099697608;
        private int sulfur = -1157596551;
        private int metal = -4031221;
        private int highqual = -1982036270;

        public class NodeData
        {
            public int rewardedstone { get; set; } = 750;
            public int rewardedmetal { get; set; } = 500;
            public int rewardedsulfur { get; set; } = 200;

            public bool sulfurComplete { get; set; } = false;
            public bool stoneComplete { get; set; } = false;
            public bool metalComplete { get; set; } = false;
        }

        private void Init() { permission.RegisterPermission(permPrefix, this); }

        private void OnServerInitialized()
        {
            if (GatherRates != null) LoadGatherRatesConfig();
            if (!legacyConfig.General.bonusEnabled) { Unsubscribe("OnDispenserBonus"); Unsubscribe("OnEntityDeath"); }

            if (legacyConfig.General.bonusEnabled) timer.Every(1f, () =>
            {
                List<BasePlayer> qued = new List<BasePlayer>();
                foreach (BasePlayer player in quedLastHit)
                {
                    if (player.IsConnected && player.IsAlive())
                    {
                        qued.Add(player);
                        int highQualAmount = 2; if (GatherRates != null) highQualAmount = highQualAmount * (int)ItemModifier(player.UserIDString, highqual.ToString());
                        DoItemAdd(player, highQualAmount, highqual.ToString());
                    }
                }

                foreach (BasePlayer player in qued) quedLastHit.Remove(player);
                qued.Clear();
            });
        }

        #endregion

        #region Config

        private LegacyNodeConfig legacyConfig;

        public class LegacyNodeConfig
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralSettings General { get; set; }

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings Chat { get; set; }

            public class GeneralSettings
            {
                [JsonProperty("Bonus Enabled")]
                public bool bonusEnabled { get; set; }

                [JsonProperty("Permission Only Mode")]
                public bool permissionMode { get; set; }
            }

            public class ChatSettings
            {
                [JsonProperty("Announce Plugin Loaded In Game")]
                public bool AnnouncePluginLoaded { get; set; }

                [JsonProperty("Chat Prefix Enabled")]
                public bool PrefixEnabled { get; set; }

                [JsonProperty(PropertyName = "Chat Prefix Color")]
                public string PrefixColor { get; set; }

                [JsonProperty(PropertyName = "Chat Message Color")]
                public string MessageColor { get; set; }
            }

            [JsonProperty(PropertyName = "Version: ")]
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        private void LoadDefaultConfig() => legacyConfig = LoadBaseConfig();

        private void SaveConfig() => Config.WriteObject(legacyConfig, true);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                legacyConfig = Config.ReadObject<LegacyNodeConfig>();

                if (legacyConfig == null)
                    throw new JsonException();

                if (legacyConfig.Version < Version || legacyConfig.Version > Version)
                {
                    LogWarning(GetLang("configUpdated"));
                    LoadDefaultConfig();
                }

                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
                LogWarning(GetLang("confCorrupt"));
                SaveConfig();
            }
        }

        private LegacyNodeConfig LoadBaseConfig()
        {
            return new LegacyNodeConfig
            {
                General = new LegacyNodeConfig.GeneralSettings
                {
                    bonusEnabled = true,
                    permissionMode = false
                },

                Chat = new LegacyNodeConfig.ChatSettings
                {
                    AnnouncePluginLoaded = true,
                    PrefixEnabled = true,
                    PrefixColor = "4A95CC",
                    MessageColor = "C57039"
                },

                Version = Version
            };
        }

        #endregion

        #region Hooks

        private void Unload()
        {
            quedLastHit.Clear();
            blacklisted.Clear();
            nonbonusmetal.Clear();
            nodes.Clear();
            legacyConfig = null;
        }

        private void OnEntityDeath(ResourceEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null) return;

            ResourceDispenser resourceEntity = entity.resourceDispenser;

            if (resourceEntity == null || resourceEntity.gatherType != ResourceDispenser.GatherType.Ore) return;

            BasePlayer initiatorPlayer = info.InitiatorPlayer; if (initiatorPlayer == null) return;

            if (legacyConfig.General.permissionMode && !initiatorPlayer.IPlayer.HasPermission(permPrefix)) return;

            NextTick(() =>
            {
                if (initiatorPlayer != null) { Interface.CallHook("OnNodeLastHit", resourceEntity, initiatorPlayer); }
            });
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BasePlayer basePlayer, Item item)
        {
            if (dispenser == null || basePlayer == null || item == null) return;

            if (dispenser.gatherType != ResourceDispenser.GatherType.Ore) return;
            
            if (legacyConfig.General.permissionMode && !basePlayer.IPlayer.HasPermission(permPrefix)) return;

            if (!nodes.ContainsKey(dispenser)) nodes.Add(dispenser, new NodeData());
                
            double amount = (double)item.amount;

            if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, item.info.itemid.ToString()) != 1) amount = amount / ItemModifier(basePlayer.UserIDString, item.info.itemid.ToString()); }

            if (item.info.itemid == stone)
            {

                var data = nodes[dispenser]; 

                int sulfurAmount = (int)Math.Round(amount / 3.75);
                sulfurAmount = ValidateAmount(dispenser, sulfurAmount, "sulfur");

                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, sulfur.ToString()) != 1) sulfurAmount = sulfurAmount * (int)ItemModifier(basePlayer.UserIDString, sulfur.ToString()); }

                DoItemAdd(basePlayer, sulfurAmount, sulfur.ToString());
                
                int metalAmount = (int) Math.Round(amount / 1.505);
                metalAmount = ValidateAmount(dispenser, metalAmount, "metal");

                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, metal.ToString()) != 1) metalAmount = metalAmount * (int)ItemModifier(basePlayer.UserIDString, metal.ToString()); }

                DoItemAdd(basePlayer, metalAmount, metal.ToString());

            }

            if(item.info.itemid == sulfur)
            {

                int stoneAmount = (int)Math.Round(amount * 3.75);
                stoneAmount = ValidateAmount(dispenser, stoneAmount, "stone");
               
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, stone.ToString()) != 1) stoneAmount = stoneAmount * (int)ItemModifier(basePlayer.UserIDString, stone.ToString()); }

                DoItemAdd(basePlayer, stoneAmount, stone.ToString());

                int metalAmount = (int)Math.Round(amount * 2.5);
                metalAmount = ValidateAmount(dispenser, metalAmount, "metal");

                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, metal.ToString()) != 1) metalAmount = metalAmount * (int)ItemModifier(basePlayer.UserIDString, metal.ToString()); }

                DoItemAdd(basePlayer, metalAmount, metal.ToString());

            }

            if(item.info.itemid == metal)
            {

                int stoneAmount = (int)Math.Round(amount * 1.5);
                stoneAmount = ValidateAmount(dispenser, stoneAmount, "stone");

                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, stone.ToString()) != 1) stoneAmount = stoneAmount * (int)ItemModifier(basePlayer.UserIDString, stone.ToString()); }

                DoItemAdd(basePlayer, stoneAmount, stone.ToString());

                int sulfurAmount = (int)Math.Round(amount / 2.5);
                sulfurAmount = ValidateAmount(dispenser, sulfurAmount, "sulfur");

                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, sulfur.ToString()) != 1) sulfurAmount = sulfurAmount * (int)ItemModifier(basePlayer.UserIDString, sulfur.ToString()); }

                DoItemAdd(basePlayer, sulfurAmount, sulfur.ToString());

                if (legacyConfig.General.bonusEnabled && !blacklisted.Contains(dispenser)) blacklisted.Add(dispenser);
                if (legacyConfig.General.bonusEnabled && !nonbonusmetal.Contains(dispenser)) nonbonusmetal.Add(dispenser);

            }

            if (legacyConfig.General.bonusEnabled) timer.Once(0.3f, () =>
            {
                if (quedLastHit.Contains(basePlayer))
                {
                    quedLastHit.Remove(basePlayer);
                    int highQualAmount = 2; if (GatherRates != null) highQualAmount = highQualAmount * (int) ItemModifier(basePlayer.UserIDString, highqual.ToString());
                    DoItemAdd(basePlayer, highQualAmount, highqual.ToString());
                }
            });
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer basePlayer, Item item)
        {
            if (!legacyConfig.General.bonusEnabled) return;

            if (dispenser == null || basePlayer == null || item == null) return;
            if (dispenser.gatherType != ResourceDispenser.GatherType.Ore) return;

            if (legacyConfig.General.permissionMode && !basePlayer.IPlayer.HasPermission(permPrefix)) return;

            double amount = (double)item.amount;
            if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, item.info.itemid.ToString()) != 1) amount = amount / ItemModifier(basePlayer.UserIDString, item.info.itemid.ToString()); }

            if (item.info.itemid == stone)
            {

                int sulfurAmount = (int)Math.Round(amount / 5 * 2);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, sulfur.ToString()) != 1) sulfurAmount = sulfurAmount * (int)ItemModifier(basePlayer.UserIDString, sulfur.ToString()); }

                DoItemAdd(basePlayer, sulfurAmount, sulfur.ToString());

                int metalAmount = (int)Math.Round(amount / 5 * 2.01);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, metal.ToString()) != 1) metalAmount = metalAmount * (int)ItemModifier(basePlayer.UserIDString, metal.ToString()); }

                DoItemAdd(basePlayer, metalAmount, metal.ToString());

            }

            if (item.info.itemid == sulfur)
            {

                int stoneAmount = (int)Math.Round(amount * 2.5);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, stone.ToString()) != 1) stoneAmount = stoneAmount * (int)ItemModifier(basePlayer.UserIDString, stone.ToString()); }

                DoItemAdd(basePlayer, stoneAmount, stone.ToString());

                int metalAmount = (int)Math.Round(amount);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, metal.ToString()) != 1) metalAmount = metalAmount * (int)ItemModifier(basePlayer.UserIDString, metal.ToString()); }

                DoItemAdd(basePlayer, metalAmount, metal.ToString());

            }

            if (item.info.itemid == metal)
            {

                int stoneAmount = (int)Math.Round(amount * 2.495);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, stone.ToString()) != 1) stoneAmount = stoneAmount * (int)ItemModifier(basePlayer.UserIDString, stone.ToString()); }

                DoItemAdd(basePlayer, stoneAmount, stone.ToString());

                int sulfurAmount = (int)Math.Round(amount);
                if (GatherRates != null) { if (ItemModifier(basePlayer.UserIDString, sulfur.ToString()) != 1) sulfurAmount = sulfurAmount * (int)ItemModifier(basePlayer.UserIDString, sulfur.ToString()); }

                DoItemAdd(basePlayer, sulfurAmount, sulfur.ToString());
                if (nonbonusmetal.Contains(dispenser)) nonbonusmetal.Remove(dispenser);

            }
        }
        
        //Notice to Developers: OnNodeLastHit always passes a null dispenser, it is simply used as a key.
        private void OnNodeLastHit(ResourceDispenser dispenser, BasePlayer basePlayer)
        {
            if (basePlayer == null) return;

            if (legacyConfig.General.permissionMode && !basePlayer.IPlayer.HasPermission(permPrefix)) return;

            if (blacklisted.Contains(dispenser) && !nonbonusmetal.Contains(dispenser))
            {
                blacklisted.Remove(dispenser);
                nonbonusmetal.Remove(dispenser);
                return;
            }

            if (!legacyConfig.General.bonusEnabled) return;

            if (quedLastHit.Contains(basePlayer))
                quedLastHit.Remove(basePlayer);

            quedLastHit.Add(basePlayer);
        }

        #endregion

        #region Helpers

        private void DoItemAdd(BasePlayer player, int quantity, string itemid)
        {
            if (quantity < 1) return;

            Item resourceItem = ItemManager.Create(FindItemDef(itemid), quantity, 0UL); if (resourceItem == null) return;
            ItemContainer itemContainer = null;
            itemContainer = player.inventory.containerMain;

            player.GiveItem(resourceItem, BaseEntity.GiveItemReason.ResourceHarvested);
        }

        private ItemDefinition FindItemDef(string idOrName)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(idOrName.ToLower());
            if (itemDef == null)
            {
                int itemId;
                if (int.TryParse(idOrName, out itemId))
                {
                    itemDef = ItemManager.FindItemDefinition(itemId);
                }
            }
            return itemDef;
        }

        private int ValidateAmount(ResourceDispenser dispenser, int amount, string nodetype)
        {
            var data = nodes[dispenser];
           
            switch (nodetype)
            {
                case "metal":

                    if (data.metalComplete) break;

                    if (data.rewardedmetal - amount < 5)
                    {
                        int amm = (int)FindDifference(data.rewardedmetal, 0);
                        data.rewardedmetal = data.rewardedmetal - amm;
                        return amm;
                    }

                    int newmetalamount = data.rewardedmetal - amount;

                    if (dispenser.baseEntity.Health() >= 175f && dispenser.baseEntity.Health() <= 260f && newmetalamount <= 355 && data.rewardedmetal >= 355)
                    {
                        data.metalComplete = true;
                        int finalmetal = (int)FindDifference(data.rewardedmetal, 250);
                        data.rewardedmetal = data.rewardedmetal - finalmetal;

                        return finalmetal;
                    }

                    data.rewardedmetal = data.rewardedmetal - amount;
                    return amount;

                case "stone":

                    if (data.stoneComplete) break;

                    if (data.rewardedstone - amount <= 0)
                    {
                        int amm = (int)FindDifference(data.rewardedstone, 0);
                        data.rewardedstone = data.rewardedstone - amm;
                        return amm;
                    }

                    int newstoneamount = data.rewardedstone - amount;

                    if (dispenser.baseEntity.Health() >= 20f && dispenser.baseEntity.Health() <= 65f && newstoneamount <= 415 && data.rewardedstone >= 375)
                    {
                        data.stoneComplete = true;
                        int finalstone = (int)FindDifference(data.rewardedstone, 375);
                        data.rewardedstone = data.rewardedstone - finalstone;
                        return finalstone;
                    }

                    data.rewardedstone = data.rewardedstone - amount;
                    return amount;
                 
                case "sulfur":

                    if (data.sulfurComplete) break;

                    if (data.rewardedsulfur - amount < 0)
                    {
                        int amm = (int)FindDifference(data.rewardedsulfur, 0);
                        data.rewardedsulfur = data.rewardedsulfur - amm;
                        return amm;
                    }

                    int newsulfuramount = data.rewardedsulfur - amount;
                    if (dispenser.baseEntity.Health() >= 20f && dispenser.baseEntity.Health() <= 65f && newsulfuramount <= 105 && data.rewardedsulfur >= 100)
                    {
                        data.sulfurComplete = true;
                        int finalsulfur = (int)FindDifference(data.rewardedsulfur, 100);
                        data.rewardedstone = data.rewardedstone - finalsulfur;
                        return finalsulfur;
                    }

                    data.rewardedsulfur = data.rewardedsulfur - amount;
                    return amount;

                default:
                    break;
            }
            return 0;
        }

        private float ItemModifier(string userId, string itemid)
        {
            Item resourceItem = ItemManager.Create(FindItemDef(itemid), 1, 0UL); if (resourceItem == null) return 1f;

            var ruleset = GetPlayerRuleset(userId);
            if (ruleset == null)
                return 1f;

            var rate = ruleset.GetGatherRate(resourceItem);
            return rate;
        }

        private decimal FindDifference(decimal amountone, decimal amounttwo)
        {
            return Math.Abs(amountone - amounttwo);
        }

        #endregion

        #region Localization

        private string GetLang(string message) => lang.GetMessage(message, this);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["announcement"] = "Legacy Nodes Enabled",
                ["confCorrupt"] = "Config Is Corrupt",
                ["configUpdated"] = "Version Change Detected, Updating Config",
                ["pmNull"] = "Error: Private Message Null",
                ["announceNull"] = "Error: Announcement Null",
                ["invalidGatherRatesConfig"] = "Configuration file is invalid, Gather scaling will not function"

            }, this);
        }

        #endregion

        #region GatherRatesByWhiteThunder

        private const string permFormat = "gatherrates.ruleset.{0}";

        private static string GetPermission(string name) => string.Format(permFormat, name);

        private GatherRatesConfig grconfig;

        private class GatherRatesConfig
        {
            [JsonProperty("GatherRateRulesets")]
            public GatherRateRuleset[] GatherRateRulesets = new GatherRateRuleset[]
            {
                new GatherRateRuleset()
                {
                    Name = "2x",
                    DefaultRate = 2,
                },
                new GatherRateRuleset()
                {
                    Name = "5x",
                    DefaultRate = 5,
                },
                new GatherRateRuleset()
                {
                    Name = "10x",
                    DefaultRate = 10,
                },
                new GatherRateRuleset()
                {
                    Name = "100x",
                    DefaultRate = 100,
                },
                new GatherRateRuleset()
                {
                    Name = "1000x",
                    DefaultRate = 1000,
                }
            };
        }

        private GatherRateRuleset GetPlayerRuleset(string userId)
        {
            var rulesets = grconfig.GatherRateRulesets;

            if (userId == string.Empty || rulesets == null)
                return null;

            for (var i = rulesets.Length - 1; i >= 0; i--)
            {
                var ruleset = rulesets[i];
                if (!string.IsNullOrEmpty(ruleset.Name)
                    && permission.UserHasPermission(userId, GetPermission(ruleset.Name)))
                    return ruleset;
            }

            return null;
        }

        private class GatherRateRuleset
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("DefaultRate")]
            public float DefaultRate = 1;

            [JsonProperty("ItemRateOverrides", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, float> ItemRateOverrides = null;

            [JsonProperty("DispenserRateOverrides", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, Dictionary<string, float>> DispenserRateOverrides = null;

            public float GetGatherRate(Item item)
            {
                Dictionary<string, float> itemRates;
                float rate;
                if (DispenserRateOverrides != null
                    && DispenserRateOverrides.TryGetValue(item.info.displayName.english, out itemRates)
                    && itemRates.TryGetValue(item.info.shortname, out rate))
                    return rate;

                if (ItemRateOverrides != null
                    && ItemRateOverrides.TryGetValue(item.info.shortname, out rate))
                    return rate;

                return DefaultRate;
            }
        }

        private void LoadGatherRatesConfig()
        {
            try
            {
                grconfig = Interface.Oxide.DataFileSystem.ReadObject<GatherRatesConfig>("GatherRates");
                if (grconfig == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                LogWarning(GetLang("invalidGatherRatesConfig"));
                GatherRates = null;
            }
        }

        #endregion

    }
}

// --- End of file: LegacyNodes.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loading-messages ---
// --- Original File Path: L/LoadingMessages/LoadingMessages.cs ---

﻿using Network;
using System.Linq;
using Newtonsoft.Json;
using System.Collections.Generic;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Loading Messages", "CosaNostra/Def/klauz24", "1.1.3")]
    [Description("Shows custom texts on loading screen")]
    public class LoadingMessages : RustPlugin
    {
        private readonly Dictionary<ulong, Connection> _clients = new Dictionary<ulong, Connection>();
        private readonly List<ulong> _disconnectedClients = new List<ulong>();

        #region Variables

        private static MsgConfig _config;
        private Timer _timer;
        private List<Connection> _queueConnections;
        private static MsgCollection _messages, _messagesQueue;

        #endregion

        #region Classes

        private class MsgCollection
        {
            public List<MsgEntry> MessagesList;
            public MsgEntry CurrentMessage;
            private int _messageIndex;

            public void AdvanceMessage()
            {
                if (_config.EnableCyclicity)
                {
                    if (_config.EnableRandomCyclicity)
                    {
                        CurrentMessage = PickRandom(MessagesList);
                    }
                    else
                    {
                        CurrentMessage = MessagesList[_messageIndex++];
                        if (_messageIndex >= MessagesList.Count)
                            _messageIndex = 0;
                    }
                }
            }

            public void SelectFirst() => CurrentMessage = MessagesList.First();
        }

        #endregion

        #region Config

        private class MsgConfig
        {
            [JsonProperty("Cycle Messages Every ~N Seconds")]
            public float CyclicityFreq;
            [JsonProperty("Enable Messages Cyclicity")]
            public bool EnableCyclicity;
            [JsonProperty("Use Random Cyclicity (Instead of sequential)")]
            public bool EnableRandomCyclicity;
            [JsonProperty("Messages")]
            public List<MsgEntry> Msgs;
            [JsonProperty("Enable Queue Messages")]
            public bool EnableQueueMessages;
            [JsonProperty("Queue Messages")]
            public List<MsgEntry> QueueMsgs;
            [JsonProperty("Last Message (When entering game)")]
            public MsgEntry LastMessage;
        }

        private class MsgEntry
        {
            [JsonProperty("Icon name")]
            public string IconName;
            [JsonProperty("Message")]
            public string Message;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<MsgConfig>();
            _messages = new MsgCollection { MessagesList = _config.Msgs };
            _messagesQueue = new MsgCollection { MessagesList = _config.QueueMsgs };
            if (_config.EnableQueueMessages || _config.QueueMsgs != null)
                return;
            _config.QueueMsgs = new List<MsgEntry>
            {
                new MsgEntry
                {
                    IconName = "Bolt",
                    Message = "<color=#add8e6>You're in queue...",
                }
            };
            SaveConfig();
            PrintWarning("Detected probably outdated config. New entries added. Check your config.");
        }

        protected override void LoadDefaultConfig()
        {
            _config = new MsgConfig
            {
                EnableCyclicity = true,
                EnableRandomCyclicity = false,
                CyclicityFreq = 5.0f,
                Msgs = new List<MsgEntry>
                {
                    new MsgEntry
                    {
                        IconName = "Bolt",
                        Message = "<color=#add8e6>{PLAYERNAME}, welcome to our server!",
                    },
                    new MsgEntry
                    {
                        IconName = "Bolt",
                        Message = "<color=#add8e6>Enjoy your stay.",
                    }
                },
                EnableQueueMessages = false,
                QueueMsgs = new List<MsgEntry>
                {
                    new MsgEntry
                    {
                        IconName = "Bolt",
                        Message = "<color=#add8e6>You're in queue...",
                    }
                },
                LastMessage = new MsgEntry
                {
                    IconName = "Bolt",
                    Message = "<color=#008000>Entering game..."
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void Unload()
        {
            _messages = null;
            _messagesQueue = null;
            if (_config.EnableQueueMessages)
                ServerMgr.Instance.connectionQueue.nextMessageTime = 0f;
        }

        private void Loaded()
        {
            if (_config?.Msgs == null || _config.Msgs.Count == 0)
            {
                Unsubscribe(nameof(OnUserApprove));
                Unsubscribe(nameof(OnPlayerConnected));
                PrintWarning("No loading messages defined! Check your config.");
                return;
            }
            if (_config.EnableCyclicity && _config.Msgs.Count <= 1)
            {
                _config.EnableCyclicity = false;
                PrintWarning("You have message cyclicity enabled, but only 1 message is defined. Check your config.");
            }

            if (_config.EnableQueueMessages && _config.QueueMsgs == null || _config.QueueMsgs.Count == 0)
            {
                _config.EnableQueueMessages = false;
                PrintWarning("You have queue messages enabled, but no queue messages is defined. Check your config.");
            }

            _messages.SelectFirst();
            if (_config.EnableQueueMessages)
                _messagesQueue.SelectFirst();
        }

        private void OnServerInitialized()
        {
            _queueConnections = ServerMgr.Instance.connectionQueue.queue;
        }

        private void OnUserApprove(Connection connection)
        {
            _clients[connection.userid] = connection;
            if (_timer == null)
                _timer = timer.Every(_config.CyclicityFreq, HandleClients);
            SendPacket(connection, GetCurrentMessage());

        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _clients.Remove(player.userID);
            SendPacket(player.Connection, GetLastMessage() ?? GetCurrentMessage());
        }

        #endregion

        #region Logic

        private void HandleClients()
        {
            if (_clients.Count == 0)
            {
                _timer.Destroy();
                _timer = null;
                return;
            }
            UpdateCurrentMessages();
            if (_config.EnableQueueMessages && ServerMgr.Instance.connectionQueue.Queued > 0)
                SuppressDefaultQueueMessage();
            foreach (var client in _clients.Values)
            {
                if (!client.active)
                {
                    _disconnectedClients.Add(client.userid);
                    continue;
                }

                if (client.state == Connection.State.InQueue)
                {
                    if (!_config.EnableQueueMessages)
                        continue;
                    SendPacket(client, GetCurrentQueueMessage());
                    continue;
                }
                SendPacket(client, GetCurrentMessage());
            }

            if (_disconnectedClients.Count == 0)
                return;
            _disconnectedClients.ForEach(uid => _clients.Remove(uid));
            _disconnectedClients.Clear();
        }

        private void SendPacket(Connection conn, MsgEntry entry)
        {
            var icon = entry.IconName;
            var message = entry.Message;
            if (IsValidStr(icon) && IsValidStr(message))
            {
                if (conn != null)
                {
                    var net = Net.sv.StartWrite();
                    net.PacketID(Message.Type.Message);
                    net.String(icon);
                    net.String(message.Replace("{PLAYERNAME}", conn.username).Replace("</color>", ""));
                    net.Send(new SendInfo(conn));
                }
            }
            else
            {
                PrintError($"Invalid MsgEntry!\nIconName: {icon}\nMessage: {message}");
            }
        }

        #endregion

        #region Utils

        private static bool IsValidStr(string str) => str != null && str.Length > 0;
        private static T PickRandom<T>(IReadOnlyList<T> list) => list[Random.Range(0, list.Count - 1)];
        private static MsgEntry GetCurrentMessage() => _messages.CurrentMessage;
        private static MsgEntry GetLastMessage() => _config.LastMessage;
        private static MsgEntry GetCurrentQueueMessage() => _messagesQueue.CurrentMessage;
        private static MsgCollection GetMessagesCollection() => _messages;
        private static MsgCollection GetQueueMessagesCollection() => _messagesQueue;
        private static void UpdateCurrentMessages()
        {
            GetMessagesCollection().AdvanceMessage();
            GetQueueMessagesCollection().AdvanceMessage();
        }
        private int GetQueuePosition(Connection con) => _queueConnections.IndexOf(con);
        private static void SuppressDefaultQueueMessage() => ServerMgr.Instance.connectionQueue.nextMessageTime = float.MaxValue;

        #endregion
    }
}

// --- End of file: LoadingMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/life-support ---
// --- Original File Path: L/LifeSupport/LifeSupport.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core;
using System.Collections.Generic;
using System;

namespace Oxide.Plugins
{
    [Info("Life Support", "OG61", "1.5.0")]
    [Description("Use reward points to prevent player from dying")]

    //Change log
    //1.4.0 Moved code from OnPlayerDeath to SaveLife and call from OnPlayerDeath and OnPlayerWound (when health below 1)
    //1.5.0 Added ability to suspend LifeSupport in DangerousTreasures zones and added support for zone manager.
    public class LifeSupport : CovalencePlugin
    {
        #region Plugin References
        [PluginReference]
        private Plugin RaidableBases, ServerRewards, DangerousTreasures, ZoneManager;
        
        #endregion

        #region Config
        private const string PERMISSION_BLOCKED = "lifesupport.blocked";

        private class Perms
        {
            public string Permission { get; set; }
            public int Cost { get; set; }
        }

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Use Zone Manager (true/false)")]
            public bool UseZoneManager = false;

            [JsonProperty(PropertyName = "Use Server Rewards (true/false)")]
            public bool UseServerRewards = false;

            [JsonProperty(PropertyName = "Disable LifeSupport in RaidableBases Zones (true/false)")]
            public bool UseRaidableBases = false;

            [JsonProperty(PropertyName = "Disable LifeSupport in DangerousTreasures Zones (true/false)")]
            public bool UseDangerousTreasures = false;

            [JsonProperty(PropertyName = "Enable Log file (true/false)")]
            public bool LogToFile = true;

            [JsonProperty(PropertyName = "Log output to console (true/false)")]
            public bool LogToConsole = true;

            [JsonProperty(PropertyName = "Permissions and cost", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Perms> perms = new List<Perms>()
            {
                new Perms() {Permission = "lifesupport.default", Cost = 400 },
                new Perms() {Permission = "lifesupport.vip", Cost = 200},
                new Perms() {Permission = "lifesupport.admin", Cost = 0}
            };
            
        }

        private PluginConfig config;

        protected override void LoadConfig()
        {
             base.LoadConfig();
            try
            {
                config = Config.ReadObject<PluginConfig>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
                Logger("ConfigError");
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new PluginConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Title)
            {
                case "RaidableBases":
                    {
                        RaidableBases = plugin;
                        break;
                    }
                case "DangerousTreasures":
                    {
                        DangerousTreasures = plugin;
                        break;
                    }
                case "ServerRewards":
                    {
                        ServerRewards = plugin;
                        break;
                    }
                case "ZoneManager":
                    {
                        ZoneManager = plugin;
                        break;
                    }
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            switch (plugin.Title)
            {
                case "RaidableBases":
                    {
                        RaidableBases = null;
                        break;
                    }
                case "DangerousTreasures":
                    {
                        DangerousTreasures = null;
                        break;
                    }
                case "ServerRewards":
                    {
                        ServerRewards = null;
                        break;
                    }
                case "ZoneManager":
                    {
                        ZoneManager = null;
                        break;
                    }
            }
        }

        #endregion //Config

        #region Data
        private Data data;

        private class Data
        {
            public List<string> activatedIDs = new List<string>();
            public List<string> excludedZones = new List<string>(); 
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, data);


        #endregion //Data

        #region Oxide Hooks
        private void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);

            config.perms.ForEach(p =>
            {
                    permission.RegisterPermission(p.Permission, this);
            });
            permission.RegisterPermission(PERMISSION_BLOCKED, this);
        }
        
        //Prevent player from entering wounded state
        private object OnPlayerWound(BasePlayer player)
        {
           if (player == null) return null;
           if (permission.UserHasPermission(player.UserIDString, PERMISSION_BLOCKED)) return null;
           if (config.UseRaidableBases)
           {
               if (RaidableBases != null && RaidableBases.IsLoaded)
               {
                    if (RaidableBases.Call<bool>("EventTerritory", player.transform.position))
                    {
                        Message("ExcludedZone", player.IPlayer);
                        Logger("RBZone", player.IPlayer);
                        return null;
                    }
               }
            }

            if (config.UseDangerousTreasures)
            {
                if (DangerousTreasures != null && DangerousTreasures.IsLoaded)
                {
                    if (DangerousTreasures.Call<bool>("EventTerritory", player.transform.position))
                    {
                        Message("ExcludedZone", player.IPlayer);
                        Logger("DTZone",player.IPlayer);
                        return null;
                    }
                }
            }

            if (config.UseZoneManager)
            {
                if (ZoneManager != null && ZoneManager.IsLoaded)
                {
                    foreach (string s in data.excludedZones)
                        if (ZoneManager.Call<bool>("IsPlayerInZone", s, player))
                        {
                            Message("ExcludedZone", player.IPlayer);
                            Logger("ZMZone",player.IPlayer);
                            return null;
                        }
                }
            }

            bool preventWounded = false;
            
            config.perms.ForEach(p =>
            {
                 if (permission.UserHasPermission(player.UserIDString, p.Permission)&&
                     data.activatedIDs.Contains(player.UserIDString)) 
                {
                    preventWounded = true;
                }
            });

            if (preventWounded) 
            {
                if (player.health < 1) return SaveLife(player); else return true;
               
            }
            else return null;
        }

       
        private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            return (SaveLife(player));
        }

        bool CanDropActiveItem(BasePlayer player)
        {
            try
            {
                if (player == null || player.IsNpc) return true;

                if (config.UseRaidableBases)
                {
                    if (RaidableBases != null && RaidableBases.IsLoaded)
                    {
                        if (RaidableBases.Call<bool>("EventTerritory", player.transform.position)) return true;
                    }
                }

                if (config.UseDangerousTreasures)
                {
                    if (DangerousTreasures != null && DangerousTreasures.IsLoaded)
                    {
                        if (DangerousTreasures.Call<bool>("EventTerritory", player.transform.position)) return true;
                    }
                }

                if (config.UseZoneManager)
                {
                    if (ZoneManager != null && ZoneManager.IsLoaded)
                    {
                        foreach (string s in data.excludedZones)
                            if (ZoneManager.Call<bool>("IsPlayerInZone", s, player)) return true;
                    }
                }
                return data.activatedIDs.Contains(player.UserIDString) ? false : true;
            }
            catch (System.Exception ex)
            {
                Puts("CanDropActiveItem trew Exception: " + ex) ;
                throw;
            }
        }

        #endregion //Oxide Hooks  

        #region Helpers

        private object SaveLife(BasePlayer player)
        {
            if (player == null || player.IsNpc || player.IsSleeping()) return null;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_BLOCKED)) return null;
            if (Interface.CallHook("OnLifeSupportSavingLife", player) != null)
            {
                Logger("CanceledByPlugin", player.IPlayer);
                return null;
            }
            bool preventDeath = false;
            int costOfLife = int.MaxValue;
            if (config.UseRaidableBases)
            {
                if (RaidableBases != null && RaidableBases.IsLoaded)
                {
                    if (RaidableBases.Call<bool>("EventTerritory", player.transform.position)) return null;
                }
            }
            if (config.UseDangerousTreasures)
            {
                if (DangerousTreasures != null && DangerousTreasures.IsLoaded)
                {
                    if (DangerousTreasures.Call<bool>("EventTerritory", player.transform.position)) return null;
                }
            }
            if (config.UseZoneManager)
            {
                if (ZoneManager != null && ZoneManager.IsLoaded)
                {
                    foreach(string s in data.excludedZones)
                    if (ZoneManager.Call<bool>("IsPlayerInZone", s, player)) return null;
                }
            }
            if (data.activatedIDs.Contains(player.UserIDString))
            {
                config.perms.ForEach(p =>
                {
                    if (permission.UserHasPermission(player.UserIDString, p.Permission))
                    {
                        preventDeath = true;
                        if (p.Cost < costOfLife) costOfLife = p.Cost;
                    }
                });
                if (!preventDeath) return null; //Player does not have permission so exit
                if (config.UseServerRewards)
                {
                    if (ServerRewards == null || !ServerRewards.IsLoaded)
                    {//Server Rewards enabled but not present. Log error and return
                        Message("ServerRewardsNull", player.IPlayer);
                        Logger("ServerRewardsNull");
                        return null;
                    }
                    if (costOfLife > 0)
                    {//object object CheckPoints(ulong ID) // Returns int, or null if no data is saved
                        var rp = ServerRewards.Call("CheckPoints", player.userID);
                        if ((rp is int ? (int)rp : 0) >= costOfLife)
                        {
                            ServerRewards.Call("TakePoints", player.UserIDString, costOfLife);
                        }
                        else
                        {
                            Message("CantAfford", player.IPlayer);
                            Logger("DiedCouldntAfford", player.IPlayer);
                            return null; //Player can't afford so exit
                        }
                    }
                    Message("SavedYourLifeCost", player.IPlayer, costOfLife);
                    Logger("SavedLife", player.IPlayer, costOfLife);
                }
                else //Not using ServerRewards
                {
                    Message("SavedYourLife", player.IPlayer);
                    Logger("ServerRewardsInactiveSavedLife", player.IPlayer);
                }
                player.health = 100f;
                if (player.IsWounded()) player.StopWounded();
                return true;
            }
            Logger("DiedNotActive", player.IPlayer);
            return null; //Life Support not activated for this player so exit
        }
        private string GetLang(string key, string id = "", params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void Logger(string key, IPlayer player = null, params object[] args)
        {
            string s = GetLang(key, player != null ? player.Id : "", args);
            string ps = "";
            if (player != null) ps = $"{player.Name} ({player.Id}) ";
            s = $"[{DateTime.Now}] {ps} {s}";
            if (config.LogToFile) LogToFile("LifeSupport", s, this);
            if (config.LogToConsole) Puts(s);
        }

        private void Message(string key, IPlayer player, params object[] args)
        {
            if (player != null)
            {
                player.Reply(GetLang(key, player.Id, args));
            }
        }

        #endregion //Helpers
            
        #region Commands
        [Command("lifesupport")]
        private void LifeSupportToggle(IPlayer player, string msg, string[] args)
        {
            if (permission.UserHasPermission(player.Id, PERMISSION_BLOCKED))
            {
                Message("NoPermission", player);
                return;
            }
            int costOfLife = int.MaxValue;
            bool hasPermission = false;

            if (args.Length > 0)
            {
                if (args.Length == 1 && args[0].ToLower() == "help")
                {
                    Message("Help", player);
                    return;
                }
                Message("DontUnderstand", player);
                return;
            }
            config.perms.ForEach(p =>
            {
                if (permission.UserHasPermission(player.Id, p.Permission))
                {
                    hasPermission = true;
                    if (p.Cost < costOfLife) costOfLife = p.Cost; //Get the lowest cost if player has multiple permissions
                }
            });

            if (data.activatedIDs.Contains(player.Id))
            {
                data.activatedIDs.Remove(player.Id);
                Message("Deactivated", player);
                Logger("Deactivated" , player);
                SaveData();
            }
            else if(hasPermission) 
            {
                data.activatedIDs.Add(player.Id);
                Message("Activated", player,  config.UseServerRewards ? costOfLife: 0);
                Logger("Activated", player, costOfLife);
                SaveData();
            }
            else Message("NoPermission", player);
        }

        [Command("lsZones")]
        private void LsZones(IPlayer player, string msg, string[] args)
        {
            //ToDo Limit to admins
            if (permission.UserHasPermission(player.Id, "lifesupport.admin"))
                {

                if (args.Length > 0)
                {
                    switch (args[0].ToLower())
                    {
                        case "add":
                            for (int i = 1; i < args.Length; i++)
                            {
                                data.excludedZones.Add(args[i]);
                            }
                            SaveData();
                            Message("ZoneAdded", player);
                            for (int i = 1; i < args.Length; i++)
                            {
                                Message(args[i], player);
                            }
                            break;
                        case "remove":
                            for (int i = 1; i < args.Length; i++)
                            {
                                data.excludedZones.Remove(args[i]);
                            }
                            SaveData();
                            Message("ZonesRemoved", player);
                            for (int i = 1; i < args.Length; i++)
                            {
                                Message(args[i], player);
                            }
                            break;
                        case "clear":
                            data.excludedZones.Clear();
                            SaveData();
                            Message("ZonesCleared", player);
                            break;
                        case "list":
                            Message("ListZones", player);
                            foreach (string s in data.excludedZones)
                            {
                                Message(s, player);
                            }
                            break;

                        default:
                            Message("DontUnderstand", player);
                            
                            break;
                    }
                    return;
                } 
            }else
            {
                Message("NoPermission", player);
                Logger("NoPermission", player);
                return;
            }
        }
        #endregion
        
        #region Localization
     
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ZoneAdded"] = "Added the following zone(s) to LifeSupport exclusionary list",
                ["ZoneRemoved"] = "Removed the following zone(s) from LifeSupport exclusionary list",
                ["ZonesCleared"] = "Cleared all zones from LifeSupport exclusionary list",
                ["ListZones"] = "LifeSupport is disabled in the following zones",
                ["ExcludedZone"] = "LifeSupport is disabled in this zone",
                ["RBZone"] = "LifeSupport is disabled in Raidable Bases zone",
                ["DTZone"] = "LifeSupport disabled in Dangerous Treasures zone",
                ["ZMZone"] = "LifeSupport disabled in Zone Manager zone",
                ["CanceledByPlugin"] = "LifeSupport canceled by another plugin",
                ["ServerRewardsNull"] = "LifeSupport could not save your life. \n"+
                "ServerRewards is enabled but the ServerRewards plugin is not available.",
                ["DontUnderstand"] = "Don't Understand.",
                ["DiedNotActive"] = "Player died. LifeSupport not active.",
                ["ConfigError"] = "Error reading config file. Defaut configuration used.",
                ["NoPermission"] = "You do not have permission to use this command.",
                ["CantAfford"] = "Sorry, insufficent reward points to use LifeSupport.",
                ["DiedCouldntAfford"] = "Player died. Could not afford LifeSupport.",
                ["Deactivated"] = "Life Support de-activated.",
                ["Activated"] = "Life Support activated.  Cost per life {0} RP",
                ["SavedYourLifeCost"] = "Life Support saved your life. Cost: {0} RP",
                ["SavedYourLife"] = "Life Support saved your life.",
                ["SavedLife"] = "Prevented death. Cost: {0} RP",
                ["ServerRewardsInactiveSavedLife"] = "Prevented death. Server Rewards inactive",
                ["Help"] = "When active LifeSupport will prevent a player's death if\n" +
                "they have permission and a sufficent amount of reward points \n" +
                "or if Server Rewards is turned off. \n" +
                "It also prevents dropping their active item.\n" +
                "Type /LifeSupport in chat to toggle on and off."
             }, this);
        }
        #endregion
    }
}

// --- End of file: LifeSupport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/lockable-shutters ---
// --- Original File Path: L/LockableShutters/LockableShutters.cs ---

﻿
using System;

namespace Oxide.Plugins
{
    [Info("Lockable Shutters", "OG61", "1.1.1")]
    [Description("Allows players to place locks on shutters")]
    public class LockableShutters : CovalencePlugin
    {
        const string _perm = "lockableshutters.use";
        #region Hooks
        private void OnServerInitialized()
        {
            CheckDoors();
        }

        private void CheckDoors()
        {
            var doors = UnityEngine.Object.FindObjectsOfType<Door>();
            foreach (var door in doors)
            {
                if (door.ShortPrefabName == "shutter.wood.a")
                {
                    if (permission.UserHasPermission(door.OwnerID.ToString(), _perm)) door.canTakeLock = true;
                    else door.canTakeLock = false;
                }
            }
        }

        private void Init()
        {
            permission.RegisterPermission(_perm, this);
        }

        private void OnEntitySpawned(Door door)
        {
            if (!permission.UserHasPermission(door.OwnerID.ToString(), _perm)) return;
            if (door.ShortPrefabName == "shutter.wood.a") door.canTakeLock = true;
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            if (permName == _perm) CheckDoors();
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
           if (permName == _perm) CheckDoors();
        }

        #endregion //Hooks  
    }
}


// --- End of file: LockableShutters.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/light-control ---
// --- Original File Path: L/LightControl/LightControl.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Rust.Modular;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Network;
using Oxide.Core.Configuration;
using Rust;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("Light Control", "Hovmodet", "1.0.4")]
    [Description("Toggle lights separately")]
    public class LightControl : RustPlugin
    {
        private const string UsePermission = "LightControl.use";

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LightHowto"] = "To toggle the light on your {0}, use the \"headtoggle\" command.",
                ["LightNoPermission"] = "You dont have permissions to use this command.",
            }, this);
        }

        public bool hasPerm(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), UsePermission))
                return false;

            return true;
        }

        [ConsoleCommand("headtoggle")]
        private void lightheadcmd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;
 
            if(!hasPerm(player))
            {
                SendReply(player, "<color=red>" + string.Format(lang.GetMessage("LightNoPermission", this, player.UserIDString)) + "</color>");
                return;
            }

            foreach (Item obj in player.inventory.containerWear.itemList)
            {
                ItemModWearable component = obj.info.GetComponent<ItemModWearable>();
                if ((bool)component && component.emissive)
                {
                    obj.SetFlag(global::Item.Flag.IsOn, !obj.HasFlag(global::Item.Flag.IsOn));
                    obj.MarkDirty();
                }
            }
        }

        private void lighthand(BasePlayer player)
        {
            if (player == null)
                return;

            if (!hasPerm(player))
            {
                SendReply(player, "<color=red>" + string.Format(lang.GetMessage("LightNoPermission", this, player.UserIDString)) + "</color>");
                return;
            }

            Item activeItem = player.GetActiveItem();
            if (activeItem != null)
            {
                BaseEntity heldEntity = activeItem.GetHeldEntity();
                if (heldEntity != null)
                {
                    HeldEntity component = heldEntity.GetComponent<HeldEntity>();
                    if ((bool)(UnityEngine.Object)component)
                        component.SendMessage("SetLightsOn", !component.LightsOn(), SendMessageOptions.DontRequireReceiver);
                }
            }

            if (!player.isMounted)
                return;
            player.GetMounted().LightToggle(player);
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.Name.ToLower() == "lighttoggle")
            {
                lighthand(arg.Player());
                return false;
            }
            return null;
        }

        object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
        {
            BasePlayer player = inventory.containerWear.playerOwner;

            if (player == null)
                return null;

            if (!hasPerm(player))
            {
                return null;
            }

            ItemModWearable component = item.info.GetComponent<ItemModWearable>();

            if (component == null)
                return null;

            if (component.emissive)
            {
                SendReply(player, "<color=yellow>" + string.Format(lang.GetMessage("LightHowto", this, player.UserIDString), item.info.displayName.english) + "</color>");
            }

            return null;
        }

    }
}

// --- End of file: LightControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/lusty-map ---
// --- Original File Path: L/LustyMap/LustyMap.cs ---

﻿// Requires: ImageLibrary

using System;
using System.Text;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Globalization;
using System.IO;
using System.Drawing;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Lusty Map", "k1lly0u", "2.1.42")]
    [Description("In-game map and minimap GUI")]
    class LustyMap : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Clans, EventManager, Friends;
        [PluginReference] ImageLibrary ImageLibrary;

        static MapSplitter mapSplitter;

        static LustyMap instance;
        static float mapSize;
        static string mapSeed;
        static string worldSize;
        static string level;

        private bool activated;
        private bool isNewSave;

        MarkerData storedMarkers;
        private DynamicConfigFile markerData;

        private Dictionary<string, MapUser> mapUsers;

        private List<MapMarker> staticMarkers;
        private Dictionary<string, MapMarker> customMarkers;
        private Dictionary<string, MapMarker> temporaryMarkers;
        private Dictionary<uint, ActiveEntity> entityMarkers;

        private Dictionary<string, List<string>> clanData;

        static string dataDirectory = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}LustyMap{Path.DirectorySeparatorChar}";
        #endregion

        #region User Class  
        class MapUser : MonoBehaviour
        {
            private Dictionary<string, List<string>> friends;
            public HashSet<string> friendList;

            public BasePlayer player;
            public MapMode mode;
            public MapMode lastMode;

            private MapMarker marker;

            private int mapX;
            private int mapZ;

            private int currentX;
            private int currentZ;
            private int mapZoom;

            private bool mapOpen;
            private bool inEvent;
            private bool adminMode;

            private int changeCount;
            private double lastChange;
            private bool isBlocked;

            private ConfigData.SpamOptions spam;

            private bool afkDisabled;
            private int lastMoveTime;
            private float lastX;
            private float lastZ;


            void Awake()
            {
                player = GetComponent<BasePlayer>();
                friends = new Dictionary<string, List<string>>
                {
                    {"Clans", new List<string>() },
                    {"Friends", new List<string>() }
                };
                friendList = new HashSet<string>();
                spam = instance.configData.Spam;
                inEvent = false;
                mapOpen = false;
                afkDisabled = false;
                enabled = false;
                mode = MapMode.None;
                lastMode = MapMode.None;
                adminMode = false;
                InvokeHandler.InvokeRepeating(this, UpdateMarker, 0.1f, 1f);
            }
            void OnDestroy()
            {
                InvokeHandler.CancelInvoke(this, UpdateMarker);
                InvokeHandler.CancelInvoke(this, UpdateMap);
                DestroyUI();
            }
            public void InitializeComponent()
            {
                if (MapSettings.friends)
                {
                    FillFriendList();
                }

                if (!instance.configData.Map.StartOpen)
                {
                    ToggleMapType(MapMode.None);
                    return;
                }

                if (MapSettings.complexmap)
                {
                    mapZoom = 1;
                    ToggleMapType(MapMode.Complex);

                    if (MapSettings.forcedzoom)
                        mapZoom = MapSettings.zoomlevel;
                }

                else if (MapSettings.minimap)
                {
                    mode = MapMode.Minimap;
                    ToggleMapType(mode);
                }
            }

            #region Friends
            private void FillFriendList()
            {
                if (instance.configData.Friends.UseClans)
                {
                    var clanTag = instance.GetClan(player.userID);
                    if (!string.IsNullOrEmpty(clanTag) && instance.clanData.ContainsKey(clanTag))
                        friends["Clans"] = instance.clanData[clanTag];
                }

                if (instance.configData.Friends.UseFriends)
                    friends["Friends"] = instance.GetFriends(player.userID);
                UpdateMembers();
            }
            private void UpdateMembers()
            {
                friendList.Clear();
                foreach (var list in friends)
                {
                    foreach (var member in list.Value)
                        friendList.Add(member);
                }
            }
            #endregion

            #region Maps
            public float Rotation() => GetDirection(player?.transform?.rotation.eulerAngles.y ?? 0);
            public int Position(bool x) => x ? mapX : mapZ;
            public void Position(bool x, int pos)
            {
                if (x) mapX = pos;
                else mapZ = pos;
            }

            public void ToggleMapType(MapMode mapMode)
            {
                if (isBlocked || IsSpam()) return;

                DestroyUI();

                if (mapMode == MapMode.None)
                {
                    InvokeHandler.CancelInvoke(this, UpdateMap);
                    mode = MapMode.None;
                    mapOpen = false;

                    if (MapSettings.minimap)
                        instance.CreateShrunkUI(player);
                }
                else
                {
                    mapOpen = true;
                    switch (mapMode)
                    {
                        case MapMode.Main:
                            mode = MapMode.Main;
                            instance.OpenMainMap(player);
                            break;
                        case MapMode.Complex:
                            mode = MapMode.Complex;
                            instance.OpenComplexMap(player);
                            break;
                        case MapMode.Minimap:
                            mode = MapMode.Minimap;
                            instance.OpenMiniMap(player);
                            break;
                    }
                    if (!IsInvoking("UpdateMap"))
                        InvokeHandler.InvokeRepeating(this, UpdateMap, 0.1f, instance.configData.Map.UpdateSpeed);
                }
            }
            public void UpdateMap()
            {
                switch (mode)
                {
                    case MapMode.None:
                        break;
                    case MapMode.Main:
                        instance.UpdateOverlay(player, LustyUI.MainOverlay, LustyUI.MainMin, LustyUI.MainMax, 0.01f);
                        break;
                    case MapMode.Complex:
                        CheckForChange();
                        instance.UpdateCompOverlay(player);
                        break;
                    case MapMode.Minimap:
                        instance.UpdateOverlay(player, LustyUI.MiniOverlay, LustyUI.MiniMin, LustyUI.MiniMax, 0.03f);
                        break;
                }
            }
            #endregion

            #region Complex
            public bool HasMapOpen() => (mapOpen && mode == MapMode.Main);
            public int Zoom() => mapZoom;
            public void Zoom(bool zoomIn)
            {
                var zoom = mapZoom;
                if (zoomIn)
                {
                    if (zoom < 3)
                        zoom++;
                    else return;
                }
                else
                {
                    if (zoom > 0)
                        zoom--;
                    else return;
                }
                InvokeHandler.CancelInvoke(this, UpdateMap);
                SwitchZoom(zoom);
            }
            private void SwitchZoom(int zoom)
            {
                if (zoom == 0 && MapSettings.minimap)
                {
                    mapZoom = zoom;
                    ToggleMapType(MapMode.Minimap);
                }
                else
                {
                    if (zoom == 0 && !MapSettings.minimap)
                        zoom = 1;

                    mapZoom = zoom;
                    currentX = 0;
                    currentZ = 0;
                    ToggleMapType(MapMode.Complex);
                }
            }
            public int Current(bool x) => x ? currentX : currentZ;
            public void Current(bool x, int num)
            {
                if (x) currentX = num;
                else currentZ = num;
            }
            private void CheckForChange()
            {
                var mapSlices = ZoomToCount(mapZoom);
                float x = player.transform.position.x + mapSize / 2f;
                float z = player.transform.position.z + mapSize / 2f;
                var mapres = mapSize / mapSlices;

                var newX = Convert.ToInt32(Math.Ceiling(x / mapres)) - 1;
                var newZ = mapSlices - Convert.ToInt32(Math.Ceiling(z / mapres));

                if (currentX != newX || currentZ != newZ)
                {
                    DestroyUI();
                    currentX = newX;
                    currentZ = newZ;
                    instance.OpenComplexMap(player);
                }
            }
            #endregion

            #region Spam Checking
            private bool IsSpam()
            {
                if (!spam.Enabled) return false;

                changeCount++;
                var current = GrabCurrentTime();
                if (current - lastChange < spam.TimeBetweenAttempts)
                {
                    lastChange = current;
                    if (changeCount > spam.WarningAttempts && changeCount < spam.DisableAttempts)
                    {
                        instance.SendReply(player, instance.msg("spamWarning", player.UserIDString));
                        return false;
                    }
                    if (changeCount >= spam.DisableAttempts)
                    {
                        instance.SendReply(player, string.Format(instance.msg("spamDisable", player.UserIDString), spam.DisableSeconds));
                        Block();
                        Invoke("Unblock", spam.DisableSeconds);
                        return true;
                    }
                }
                else
                {
                    lastChange = current;
                    changeCount = 0;
                }
                return false;
            }
            private void Block()
            {
                isBlocked = true;
                OnDestroy();
            }
            private void Unblock()
            {
                isBlocked = false;
                ToggleMapType(lastMode);
                instance.SendReply(player, instance.msg("spamEnable", player.UserIDString));
            }
            #endregion

            #region Other
            public bool InEvent() => inEvent;
            public bool IsAdmin => adminMode;
            public void ToggleEvent(bool isPlaying) => inEvent = isPlaying;
            public void ToggleAdmin(bool enabled) => adminMode = enabled;
            public void DestroyUI() => LustyUI.DestroyUI(player);
            private void UpdateMarker()
            {
                var currentX = (float)Math.Round(transform.position.x, 1);
                var currentZ = (float)Math.Round(transform.position.z, 1);

                marker = new MapMarker { name = RemoveSpecialCharacters(player.displayName), r = GetDirection(player?.eyes?.rotation.eulerAngles.y ?? 0), x = GetPosition(transform.position.x), z = GetPosition(transform.position.z) };

                if (instance.configData.Map.EnableAFKTracking)
                {
                    if (lastX == currentX && lastZ == currentZ)
                        ++lastMoveTime;
                    else
                    {
                        lastX = currentX;
                        lastZ = currentZ;
                        lastMoveTime = 0;
                        if (afkDisabled)
                        {
                            afkDisabled = false;
                            EnableUser();
                        }
                    }

                    if (lastMoveTime == 90)
                    {
                        afkDisabled = true;
                        DisableUser();
                    }
                }
            }
            public MapMarker GetMarker() => marker;

            public void ToggleMain()
            {
                if (HasMapOpen())
                {
                    if (MapSettings.minimap)
                    {
                        if (Zoom() > 0)
                            ToggleMapType(MapMode.Complex);
                        else ToggleMapType(MapMode.Minimap);
                    }
                    else ToggleMapType(MapMode.None);
                }
                else
                {
                    lastMode = mode;
                    CuiHelper.DestroyUi(player, LustyUI.Buttons);
                    ToggleMapType(MapMode.Main);
                }
            }
            public void DisableUser()
            {
                if (!mapOpen) return;
                InvokeHandler.CancelInvoke(this, UpdateMap);
                CuiHelper.DestroyUi(player, LustyUI.Buttons);
                if (mode != MapMode.None)
                    LustyUI.DestroyUI(player);
                mapOpen = false;
            }
            public void EnableUser()
            {
                if (mapOpen) return;
                ToggleMapType(mode);
            }
            public void EnterEvent() => inEvent = true;
            public void ExitEvent() => inEvent = false;

            #region Friends
            public bool HasFriendList(string name) => friends.ContainsKey(name);
            public void AddFriendList(string name, List<string> friendlist) { friends.Add(name, friendlist); UpdateMembers(); }
            public void RemoveFriendList(string name) { friends.Remove(name); UpdateMembers(); }
            public void UpdateFriendList(string name, List<string> friendlist) { friends[name] = friendlist; UpdateMembers(); }

            public bool HasFriend(string name, string friendId) => friends[name].Contains(friendId);
            public void AddFriend(string name, string friendId) { friends[name].Add(friendId); UpdateMembers(); }
            public void RemoveFriend(string name, string friendId) { friends[name].Remove(friendId); UpdateMembers(); }
            #endregion
            #endregion
        }

        MapUser GetUser(BasePlayer player) => player.GetComponent<MapUser>() ?? null;
        MapUser GetUserByID(string playerId) => mapUsers.ContainsKey(playerId) ? mapUsers[playerId] : null;
        #endregion

        #region Markers
        class ActiveEntity : MonoBehaviour
        {
            public BaseEntity entity;
            private MapMarker marker;
            public AEType type;
            private string icon;

            void Awake()
            {
                entity = GetComponent<BaseEntity>();
                marker = new MapMarker();
                enabled = false;
            }
            void OnDestroy()
            {
                InvokeHandler.CancelInvoke(this, UpdatePosition);
            }
            public void SetType(AEType type)
            {
                this.type = type;
                switch (type)
                {

                    case AEType.None:
                        break;
                    case AEType.Plane:
                        icon = "plane";
                        marker.name = instance.msg("Plane");
                        break;
                    case AEType.SupplyDrop:
                        icon = "supply";
                        marker.name = instance.msg("Supply Drop");
                        break;
                    case AEType.Helicopter:
                        icon = "heli";
                        marker.name = instance.msg("Helicopter");
                        break;
                    case AEType.Debris:
                        icon = "debris";
                        marker.name = instance.msg("Debris");
                        break;
                    case AEType.Vending:
                        icon = "vending";
                        marker.name = instance.msg("Vending");
                        break;
                    case AEType.Tank:
                        icon = "tank";
                        marker.name = instance.msg("Tank");
                        break;
                    case AEType.Car:
                        icon = "car";
                        marker.name = instance.msg("Car");
                        break;
                }
                InvokeHandler.InvokeRepeating(this, UpdatePosition, 0.1f, 1f);
            }
            public MapMarker GetMarker() => marker;
            void UpdatePosition()
            {
                if (type == AEType.Helicopter || type == AEType.Plane || type == AEType.Car || type == AEType.Tank)
                {
                    marker.r = GetDirection(entity?.transform?.rotation.eulerAngles.y ?? 0);
                    marker.icon = $"{icon}{marker.r}";
                }
                else marker.icon = $"{icon}";
                marker.x = GetPosition(entity.transform.position.x);
                marker.z = GetPosition(entity.transform.position.z);
                if (type == AEType.Vending || type == AEType.SupplyDrop || type == AEType.Debris)
                    InvokeHandler.CancelInvoke(this, UpdatePosition);
            }
        }
        class MapMarker
        {
            public string name { get; set; }
            public float x { get; set; }
            public float z { get; set; }
            public float r { get; set; }
            public string icon { get; set; }
        }
        static class MapSettings
        {
            static public bool minimap, complexmap, monuments, names, compass, caves, plane, heli, supply, debris, player, allplayers, friends, vending, forcedzoom, cars, tanks;
            static public int zoomlevel;
        }
        public enum MapMode
        {
            None,
            Main,
            Complex,
            Minimap
        }
        enum AEType
        {
            None,
            Plane,
            SupplyDrop,
            Helicopter,
            Debris,
            Vending,
            Car,
            Tank
        }
        #endregion

        #region UI
        class LMUI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Hud")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 0, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0 },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel, CuiHelper.GetGuid());
            }
            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }
        }
        #endregion

        #region Oxide Hooks
        void OnNewSave(string filename)
        {
            isNewSave = true;
        }
        void Loaded()
        {
            markerData = Interface.Oxide.DataFileSystem.GetFile($"LustyMap{Path.DirectorySeparatorChar}CustomData");

            mapUsers = new Dictionary<string, MapUser>();
            staticMarkers = new List<MapMarker>();
            customMarkers = new Dictionary<string, MapMarker>();
            temporaryMarkers = new Dictionary<string, MapMarker>();
            entityMarkers = new Dictionary<uint, ActiveEntity>();
            clanData = new Dictionary<string, List<string>>();

            permission.RegisterPermission("lustymap.admin", this);
        }
        void OnServerInitialized()
        {
            instance = this;

            worldSize = ConVar.Server.worldsize.ToString();
            mapSeed = ConVar.Server.seed.ToString();
            level = ConVar.Server.level;
            mapSize = TerrainMeta.Size.x;

            mapSplitter = new MapSplitter();

            LoadVariables();
            LoadData();
            LoadSettings();

            FindStaticMarkers();
            FindVendingMachines();
            FindVehicles();
            ValidateImages();

            GetClans();
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot) || player.IsSleeping())
            {
                timer.In(2, () => OnPlayerConnected(player));
                return;
            }
            if (activated)
            {
                var user = GetUser(player);
                if (user != null)
                {
                    UnityEngine.Object.DestroyImmediate(user);
                    if (mapUsers.ContainsKey(player.UserIDString))
                        mapUsers.Remove(player.UserIDString);
                }

                var mapUser = player.gameObject.AddComponent<MapUser>();
                if (!mapUsers.ContainsKey(player.UserIDString))
                    mapUsers.Add(player.UserIDString, mapUser);
                mapUser.InitializeComponent();
            }
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null) return;
            if (mapUsers.ContainsKey(player.UserIDString))
            {
                UnityEngine.Object.Destroy(mapUsers[player.UserIDString]);
                mapUsers.Remove(player.UserIDString);
            }

            LustyUI.DestroyUI(player);
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if (!activated) return;
            if (entity == null) return;
            if (entity is CargoPlane || entity is SupplyDrop || entity is BaseHelicopter || entity is HelicopterDebris || entity is VendingMachine || entity is BasicCar || entity is BradleyAPC)
                AddTemporaryEntityMarker(entity);
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            var activeEntity = entity?.GetComponent<ActiveEntity>();
            if (activeEntity == null) return;
            if (entity?.net?.ID == null) return;
            if (entityMarkers.ContainsKey(entity.net.ID))
                entityMarkers.Remove(entity.net.ID);
            UnityEngine.Object.Destroy(activeEntity);
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerDisconnected(player);

            var mapUsers = UnityEngine.Object.FindObjectsOfType<MapUser>();
            if (mapUsers != null)
                foreach (var user in mapUsers)
                    UnityEngine.Object.DestroyImmediate(user);

            var tempMarkers = UnityEngine.Object.FindObjectsOfType<ActiveEntity>();
            if (tempMarkers != null)
                foreach (var marker in tempMarkers)
                    UnityEngine.Object.DestroyImmediate(marker);
        }
        #endregion

        #region Static UI Generation
        static class LustyUI
        {
            public static string Main = "LMUI_MapMain";
            public static string Mini = "LMUI_MapMini";
            public static string Complex = "LMUI_Complex";
            public static string MainOverlay = "LMUI_MainOverlay";
            public static string MiniOverlay = "LMUI_MiniOverlay";
            public static string ComplexOverlay = "LMUI_ComplexOverlay";
            public static string Buttons = "LMUI_Buttons";

            public static string MainMin;
            public static string MainMax;
            public static string MiniMin;
            public static string MiniMax;

            public static CuiElementContainer StaticMain;
            public static CuiElementContainer StaticMini;
            public static Dictionary<int, CuiElementContainer[,]> StaticComplex = new Dictionary<int, CuiElementContainer[,]>();

            private static Dictionary<ulong, List<string>> OpenUI = new Dictionary<ulong, List<string>>();

            public static void RenameComponents()
            {
                if (StaticMain != null)
                {
                    foreach (var element in StaticMain)
                    {
                        if (element.Name == "AddUI CreatedPanel")
                            element.Name = CuiHelper.GetGuid();
                    }
                }
                if (StaticMini != null)
                {
                    foreach (var element in StaticMini)
                    {
                        if (element.Name == "AddUI CreatedPanel")
                            element.Name = CuiHelper.GetGuid();
                    }
                }
                if (StaticComplex != null)
                {
                    foreach (var size in StaticComplex)
                    {
                        foreach (var piece in size.Value)
                        {
                            foreach (var element in piece)
                            {
                                if (element.Name == "AddUI CreatedPanel")
                                    element.Name = CuiHelper.GetGuid();
                            }
                        }
                    }
                }
                instance.activated = true;
                if (instance.configData.Map.StartOpen)
                    instance.ActivateMaps();
            }
            public static void AddBaseUI(BasePlayer player, MapMode type)
            {
                try
                {
                    var user = instance.GetUser(player);
                    if (user == null) return;

                    DestroyUI(player);
                    CuiElementContainer element = null;
                    switch (type)
                    {
                        case MapMode.None:
                            return;
                        case MapMode.Main:
                            element = StaticMain;
                            CuiHelper.AddUi(player, StaticMain);
                            AddElementIds(player, ref element);
                            return;
                        case MapMode.Complex:
                            element = StaticComplex[(MapSettings.forcedzoom ? MapSettings.zoomlevel : user.Zoom())][user.Current(true), user.Current(false)];
                            instance.AddMapButtons(player);
                            CuiHelper.AddUi(player, element);
                            AddElementIds(player, ref element);
                            return;
                        case MapMode.Minimap:
                            element = StaticMini;
                            instance.AddMapButtons(player);
                            CuiHelper.AddUi(player, element);
                            AddElementIds(player, ref element);
                            return;
                    }
                }
                catch
                {
                }
            }
            private static void AddElementIds(BasePlayer player, ref CuiElementContainer container)
            {
                if (!OpenUI.ContainsKey(player.userID))
                    OpenUI.Add(player.userID, new List<string>());
                foreach (var piece in container)
                    OpenUI[player.userID].Add(piece.Name);
            }
            public static void DestroyUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Buttons);
                CuiHelper.DestroyUi(player, Main);
                CuiHelper.DestroyUi(player, MainOverlay);
                CuiHelper.DestroyUi(player, Mini);
                CuiHelper.DestroyUi(player, MiniOverlay);
                CuiHelper.DestroyUi(player, Complex);
                CuiHelper.DestroyUi(player, ComplexOverlay);
                if (!OpenUI.ContainsKey(player.userID)) return;
                foreach (var piece in OpenUI[player.userID])
                    CuiHelper.DestroyUi(player, piece);
            }
            public static string Color(string hexColor, float alpha)
            {
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        void GenerateMaps(bool main, bool mini, bool complex)
        {
            if (!ImageLibrary.IsReady())
            {
                timer.In(30, () => GenerateMaps(main, mini, complex));
                Puts("[Warning] Waiting for Image Library to finish processing images");
                return;
            }
            if (main) CreateStaticMain();
            SetMinimapSize();
            if (mini) CreateStaticMini();
            if (complex) CreateStaticComplex();
        }
        void SetMinimapSize()
        {
            float startx = 0f + configData.MiniMap.OffsetSide;
            float endx = startx + (0.13f * configData.MiniMap.HorizontalScale);
            float endy = 1f - configData.MiniMap.OffsetTop;
            float starty = endy - (0.2301f * configData.MiniMap.VerticalScale);
            if (!configData.MiniMap.OnLeftSide)
            {
                endx = 1 - configData.MiniMap.OffsetSide;
                startx = endx - (0.13f * configData.MiniMap.HorizontalScale);
            }
            LustyUI.MiniMin = $"{startx} {starty}";
            LustyUI.MiniMax = $"{endx} {endy}";
        }
        void CreateStaticMain()
        {
            Puts("[Warning] Generating the main map");
            string mapimage = string.Empty;
            if (ImageLibrary.HasImage("mapimage", 0))
                mapimage = GetImage("mapimage");
            else if (ImageLibrary.HasImage("mapimage_high", 0))
                mapimage = GetImage("mapimage_high");
            if (string.IsNullOrEmpty(mapimage))
            {
                Puts("[Error] Unable to load the map image from file storage. This may be caused by slow processing of the images being uploaded to your server. Wait for 5 minutes and reload the plugin. \nIf this problem persists after multiple attempts then unload the plugin and delete your ImageData.json data file or run the 'resetmap' command");
                activated = false;
                return;
            }
            float iconsize = 0.01f;
            LustyUI.MainMin = "0.2271875 0.015";
            LustyUI.MainMax = "0.7728125 0.985";

            var mapContainer = LMUI.CreateElementContainer(LustyUI.Main, "0 0 0 1", LustyUI.MainMin, LustyUI.MainMax, true);
            LMUI.LoadImage(ref mapContainer, LustyUI.Main, mapimage, "0 0", "1 1");
            LMUI.CreatePanel(ref mapContainer, LustyUI.Main, LustyUI.Color("2b627a", 0.4f), "0 0.96", "1 1");
            LMUI.CreateLabel(ref mapContainer, LustyUI.Main, "", $"{Title}  v{Version}", 14, "0.01 0.96", "0.99 1");

            foreach (var marker in staticMarkers)
            {
                var image = GetImage(marker.icon);
                if (string.IsNullOrEmpty(image)) continue;
                LMUI.LoadImage(ref mapContainer, LustyUI.Main, image, $"{marker.x - iconsize} {marker.z - iconsize}", $"{marker.x + iconsize} {marker.z + iconsize}");
                if (MapSettings.names)
                    LMUI.CreateLabel(ref mapContainer, LustyUI.Main, "", marker.name, 10, $"{marker.x - 0.1} {marker.z - iconsize - 0.03}", $"{marker.x + 0.1} {marker.z - iconsize}");
            }
            LustyUI.StaticMain = mapContainer;
            Puts("[Warning] Main map generated successfully!");
            if (!MapSettings.minimap)
                LustyUI.RenameComponents();
        }
        void CreateStaticMini()
        {
            Puts("[Warning] Generating the mini-map");
            var mapimage = GetImage("mapimage");
            if (string.IsNullOrEmpty(mapimage))
            {
                Puts("[Error] Unable to load the map image from file storage. This may be caused by slow processing of the images being uploaded to your server. Wait for 5 minutes and reload the plugin. \nIf this problem persists after multiple attempts then unload the plugin and delete your ImageData.json data file or run the 'resetmap' command");
                activated = false;
                return;
            }
            float iconsize = 0.03f;

            var mapContainer = LMUI.CreateElementContainer(LustyUI.Mini, "0 0 0 1", LustyUI.MiniMin, LustyUI.MiniMax);
            LMUI.LoadImage(ref mapContainer, LustyUI.Mini, mapimage, "0 0", "1 1");

            foreach (var marker in staticMarkers)
            {
                var image = GetImage(marker.icon);
                if (string.IsNullOrEmpty(image)) continue;
                LMUI.LoadImage(ref mapContainer, LustyUI.Mini, image, $"{marker.x - iconsize} {marker.z - iconsize}", $"{marker.x + iconsize} {marker.z + iconsize}");
            }
            LustyUI.StaticMini = mapContainer;
            Puts("[Warning] Mini map generated successfully!");
            if (!MapSettings.complexmap)
                LustyUI.RenameComponents();
        }
        void CreateStaticComplex()
        {
            Puts("[Warning] Generating the complex map. This may take a few moments, please wait!");
            foreach (var mapslices in new List<int> { 6, 12, 26 })//, 32 })
            {
                for (int number = 0; number < (mapslices * mapslices); number++)
                {
                    int rowNum = 0;
                    int colNum = 0;
                    if (number > mapslices - 1)
                    {
                        colNum = Convert.ToInt32(Math.Floor((float)number / (float)mapslices));
                        rowNum = number - (colNum * mapslices);
                    }
                    else rowNum = number;

                    var mapContainer = LMUI.CreateElementContainer(LustyUI.Complex, "0 0 0 1", LustyUI.MiniMin, LustyUI.MiniMax);

                    string imageId = GetImage($"map-{mapslices}-{rowNum}-{colNum}");
                    if (!string.IsNullOrEmpty(imageId))
                        LMUI.LoadImage(ref mapContainer, LustyUI.Complex, imageId, $"0 0", $"1 1");
                    else
                    {
                        PrintError($"Missing map piece (Slices: {mapslices}, Column: {colNum}, Row: {rowNum}). When the plugin is splitting the map you must wait for it to finish otherwise the split will not complete and this error will occur");
                        PrintError($"Creating a new load order with ImageLibrary");
                        LoadImages();
                        LoadMapImage();
                        return;
                    }

                    double width = ((double)1 / (double)mapslices);
                    float iconsize = 0.03f;

                    var column = colNum;
                    var row = rowNum;
                    if (column < 1) column = 1;
                    if (column > mapslices - 2) column = mapslices - 2;
                    if (row < 1) row = 1;
                    if (row > mapslices - 2) row = mapslices - 2;

                    double colStart = (width * column) - width;
                    double colEnd = colStart + (width * 3);

                    double rowStart = 1 - ((width * row) - width);
                    double rowEnd = (rowStart - (width * 3));

                    foreach (var marker in staticMarkers)
                    {
                        string markerId = GetImage(marker.icon);
                        if (string.IsNullOrEmpty(markerId)) continue;

                        float x = marker.x;
                        float z = marker.z;
                        if ((x > colStart && x < colEnd) && (z > rowEnd && z < rowStart))
                        {
                            var average = 1 / (colEnd - colStart);
                            double posX = (x - colStart) * average;
                            double posZ = (z - rowEnd) * average;
                            LMUI.LoadImage(ref mapContainer, LustyUI.Complex, markerId, $"{posX - iconsize} {posZ - iconsize}", $"{posX + iconsize} {posZ + iconsize}");
                        }
                    }
                    int zoom = CountToZoom(mapslices);

                    if (!LustyUI.StaticComplex.ContainsKey(zoom))
                        LustyUI.StaticComplex.Add(zoom, new CuiElementContainer[mapslices, mapslices]);
                    LustyUI.StaticComplex[zoom][colNum, rowNum] = mapContainer;
                }
            }
            Puts("[Warning] Complex map generated successfully!");
            LustyUI.RenameComponents();
        }

        static int ZoomToCount(int zoom)
        {
            switch (zoom)
            {
                case 1:
                    return 6;
                case 2:
                    return 12;
                case 3:
                    return 26;
                case 4:
                    return 32;
                default:
                    return 0;
            }
        }
        static int CountToZoom(int count)
        {
            switch (count)
            {
                case 6:
                    return 1;
                case 12:
                    return 2;
                case 26:
                    return 3;
                case 32:
                    return 4;
                default:
                    return 0;
            }
        }
        #endregion

        #region Maps
        void ActivateMaps()
        {
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
        void AddMapCompass(BasePlayer player, ref CuiElementContainer mapContainer, string panel, int fontsize, string offsetMin, string offsetMax)
        {
            string direction = null;
            if (player?.eyes?.rotation == null) return;
            float lookRotation = player?.eyes?.rotation.eulerAngles.y ?? 0;
            int playerdirection = (Convert.ToInt16((lookRotation - 5) / 10 + 0.5) * 10);
            if (lookRotation >= 355) playerdirection = 0;
            if (lookRotation > 337.5 || lookRotation < 22.5) { direction = msg("cpsN"); }
            else if (lookRotation > 22.5 && lookRotation < 67.5) { direction = msg("cpsNE"); }
            else if (lookRotation > 67.5 && lookRotation < 112.5) { direction = msg("cpsE"); }
            else if (lookRotation > 112.5 && lookRotation < 157.5) { direction = msg("cpsSE"); }
            else if (lookRotation > 157.5 && lookRotation < 202.5) { direction = msg("cpsS"); }
            else if (lookRotation > 202.5 && lookRotation < 247.5) { direction = msg("cpsSW"); }
            else if (lookRotation > 247.5 && lookRotation < 292.5) { direction = msg("cpsW"); }
            else if (lookRotation > 292.5 && lookRotation < 337.5) { direction = msg("cpsNW"); }
            LMUI.CreateLabel(ref mapContainer, panel, "", $"<size={fontsize + 4}>{direction}</size> \n{player.transform.position}", fontsize, offsetMin, offsetMax, TextAnchor.UpperCenter);
        }
        void AddMapButtons(BasePlayer player)
        {
            float startx = 0f + configData.MiniMap.OffsetSide;
            float endx = startx + (0.13f * configData.MiniMap.HorizontalScale);
            float endy = 1f - configData.MiniMap.OffsetTop;
            float starty = endy - (0.2301f * configData.MiniMap.VerticalScale);
            string b_text = "<<<";
            var container = LMUI.CreateElementContainer(LustyUI.Buttons, "0 0 0 0", $"{endx + 0.001f} {starty}", $"{endx + 0.02f} {endy}");

            if (!configData.MiniMap.OnLeftSide)
            {
                endx = 1 - configData.MiniMap.OffsetSide;
                startx = endx - (0.13f * configData.MiniMap.HorizontalScale);
                b_text = ">>>";
                container = LMUI.CreateElementContainer(LustyUI.Buttons, "0 0 0 0", $"{startx - 0.02f} {starty}", $"{startx - 0.001f} {endy}");
            }

            LMUI.CreateButton(ref container, LustyUI.Buttons, LustyUI.Color("696969", 0.6f), b_text, 12, $"0 0.9", $"1 1", "LMUI_Control shrink");
            if (MapSettings.complexmap && !MapSettings.forcedzoom)
            {
                LMUI.CreateButton(ref container, LustyUI.Buttons, LustyUI.Color("696969", 0.6f), "+", 14, $"0 0.79", $"1 0.89", "LMUI_Control zoomin");
                LMUI.CreateButton(ref container, LustyUI.Buttons, LustyUI.Color("696969", 0.6f), "-", 14, $"0 0.68", $"1 0.78", "LMUI_Control zoomout");
            }
            CuiHelper.DestroyUi(player, LustyUI.Buttons);
            CuiHelper.AddUi(player, container);
        }
        void CreateShrunkUI(BasePlayer player)
        {
            var user = GetUser(player);
            if (user == null) return;

            float b_endy = 0.999f - configData.MiniMap.OffsetTop;
            float b_startx = 0.001f + configData.MiniMap.OffsetSide;
            float b_endx = b_startx + 0.02f;
            string b_text = ">>>";

            if (!configData.MiniMap.OnLeftSide)
            {
                b_endx = 0.999f - configData.MiniMap.OffsetSide;
                b_startx = b_endx - 0.02f;
                b_text = "<<<";
            }
            var container = LMUI.CreateElementContainer(LustyUI.Buttons, "0 0 0 0", $"{b_startx} {b_endy - 0.025f}", $"{b_endx} {b_endy}");
            LMUI.CreateButton(ref container, LustyUI.Buttons, LustyUI.Color("696969", 0.6f), b_text, 12, "0 0", "1 1", "LMUI_Control expand");
            CuiHelper.DestroyUi(player, LustyUI.Buttons);
            CuiHelper.AddUi(player, container);
        }

        #region Standard Maps
        void OpenMainMap(BasePlayer player) => LustyUI.AddBaseUI(player, MapMode.Main);
        void OpenMiniMap(BasePlayer player) => LustyUI.AddBaseUI(player, MapMode.Minimap);
        void UpdateOverlay(BasePlayer player, string panel, string posMin, string posMax, float iconsize)
        {
            var mapContainer = LMUI.CreateElementContainer(panel, "0 0 0 0", posMin, posMax);

            var user = GetUser(player);
            if (user == null) return;
            foreach (var marker in customMarkers)
            {
                var image = GetImage(marker.Key);
                if (string.IsNullOrEmpty(image)) continue;
                AddIconToMap(ref mapContainer, panel, image, marker.Value.name, iconsize * 1.25f, marker.Value.x, marker.Value.z);
            }
            foreach (var marker in temporaryMarkers)
            {
                var image = GetImage(marker.Key);
                if (string.IsNullOrEmpty(image)) continue;
                AddIconToMap(ref mapContainer, panel, image, marker.Value.name, iconsize * 1.25f, marker.Value.x, marker.Value.z);
            }
            foreach (var entity in entityMarkers)
            {
                if (entity.Value.type == AEType.Car && (entity.Value.entity as BasicCar).IsMounted())
                    continue;
                var marker = entity.Value.GetMarker();
                if (marker == null) continue;
                var image = GetImage(marker.icon);
                if (string.IsNullOrEmpty(image)) continue;
                AddIconToMap(ref mapContainer, panel, image, "", entity.Value.type == AEType.Vending ? iconsize : iconsize * 1.4f, marker.x, marker.z);
            }
            if (user.IsAdmin || MapSettings.allplayers)
            {
                foreach (var mapuser in mapUsers)
                {
                    if (mapuser.Key == player.UserIDString) continue;

                    var marker = mapuser.Value.GetMarker();
                    if (marker == null) continue;
                    var image = GetImage($"other{marker.r}");
                    if (string.IsNullOrEmpty(image)) continue;
                    AddIconToMap(ref mapContainer, panel, image, marker.name, iconsize * 1.25f, marker.x, marker.z);
                }
            }
            else if (MapSettings.friends)
            {
                foreach (var friendId in user.friendList)
                {
                    if (friendId == player.UserIDString) continue;

                    if (mapUsers.ContainsKey(friendId))
                    {
                        var friend = mapUsers[friendId];
                        if (friend.InEvent() && configData.Map.HideEventPlayers) continue;
                        var marker = friend.GetMarker();
                        if (marker == null) continue;
                        var image = GetImage($"friend{marker.r}");
                        if (string.IsNullOrEmpty(image)) continue;
                        AddIconToMap(ref mapContainer, panel, image, marker.name, iconsize * 1.25f, marker.x, marker.z);
                    }
                }
            }
            if (MapSettings.player)
            {
                var selfMarker = user.GetMarker();
                if (selfMarker != null)
                {
                    var selfImage = GetImage($"self{selfMarker.r}");
                    AddIconToMap(ref mapContainer, panel, selfImage, "", iconsize * 1.25f, selfMarker.x, selfMarker.z);
                }
            }

            if (panel == LustyUI.MainOverlay)
            {
                LMUI.CreateButton(ref mapContainer, panel, LustyUI.Color("88a8b6", 1), "X", 14, "0.95 0.961", "0.999 0.999", "LMUI_Control map");
                if (MapSettings.compass)
                    AddMapCompass(player, ref mapContainer, panel, 14, "0.75 0.88", "1 0.95");
            }

            if (panel == LustyUI.MiniOverlay)
            {
                if (MapSettings.compass)
                    AddMapCompass(player, ref mapContainer, panel, 10, "0 -0.25", "1 -0.02");
            }

            CuiHelper.DestroyUi(player, panel);
            CuiHelper.AddUi(player, mapContainer);
        }
        void AddIconToMap(ref CuiElementContainer mapContainer, string panel, string image, string name, float iconsize, float posX, float posZ)
        {
            if (posX < iconsize || posX > 1 - iconsize || posZ < iconsize || posZ > 1 - iconsize) return;
            LMUI.LoadImage(ref mapContainer, panel, image, $"{posX - iconsize} {posZ - iconsize}", $"{posX + iconsize} {posZ + iconsize}");
            if (MapSettings.names)
                LMUI.CreateLabel(ref mapContainer, panel, "", name, 10, $"{posX - 0.1} {posZ - iconsize - 0.025}", $"{posX + 0.1} {posZ - iconsize}");
        }
        #endregion

        #region Complex Maps
        void OpenComplexMap(BasePlayer player) => LustyUI.AddBaseUI(player, MapMode.Complex);
        void UpdateCompOverlay(BasePlayer player)
        {
            var mapContainer = LMUI.CreateElementContainer(LustyUI.ComplexOverlay, "0 0 0 0", LustyUI.MiniMin, LustyUI.MiniMax);

            var user = GetUser(player);
            if (user == null) return;

            var colNum = user.Current(true);
            var rowNum = user.Current(false);

            var mapslices = ZoomToCount(user.Zoom());
            double width = ((double)1 / (double)mapslices);
            float iconsize = 0.04f;

            var column = colNum;
            var row = rowNum;
            if (column < 1) column = 1;
            if (column > mapslices - 2) column = mapslices - 2;
            if (row < 1) row = 1;
            if (row > mapslices - 2) row = mapslices - 2;

            double colStart = (width * column) - width;
            double colEnd = colStart + (width * 3);

            double rowStart = 1 - ((width * row) - width);
            double rowEnd = (rowStart - (width * 3));

            foreach (var marker in customMarkers)
            {
                var image = GetImage(marker.Key);
                if (string.IsNullOrEmpty(image)) continue;
                AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, image, "", iconsize * 1.3f, marker.Value.x, marker.Value.z, colStart, colEnd, rowStart, rowEnd);
            }
            foreach (var marker in temporaryMarkers)
            {
                var image = GetImage(marker.Key);
                if (string.IsNullOrEmpty(image)) continue;
                AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, image, "", iconsize * 1.3f, marker.Value.x, marker.Value.z, colStart, colEnd, rowStart, rowEnd);
            }
            foreach (var entity in entityMarkers)
            {
                if (entity.Value.type == AEType.Car && (entity.Value.entity as BasicCar).IsMounted())
                    continue;
                var marker = entity.Value.GetMarker();
                if (marker == null) continue;
                var image = GetImage(marker.icon);
                if (string.IsNullOrEmpty(image)) continue;
                AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, image, "", entity.Value.type == AEType.Vending ? iconsize : iconsize * 1.6f, marker.x, marker.z, colStart, colEnd, rowStart, rowEnd);
            }
            if (user.IsAdmin || MapSettings.allplayers)
            {
                foreach (var mapuser in mapUsers)
                {
                    if (mapuser.Key == player.UserIDString) continue;

                    var marker = mapuser.Value.GetMarker();
                    if (marker == null) continue;
                    var image = GetImage($"other{marker.r}");
                    if (string.IsNullOrEmpty(image)) continue;
                    AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, image, "", iconsize * 1.3f, marker.x, marker.z, colStart, colEnd, rowStart, rowEnd);
                }
            }
            else if (MapSettings.friends)
            {
                foreach (var friendId in user.friendList)
                {
                    if (friendId == player.UserIDString) continue;

                    if (mapUsers.ContainsKey(friendId))
                    {
                        var friend = mapUsers[friendId];
                        if (friend.InEvent() && configData.Map.HideEventPlayers) continue;
                        var marker = friend.GetMarker();
                        if (marker == null) continue;
                        var image = GetImage($"friend{marker.r}");
                        if (string.IsNullOrEmpty(image)) continue;
                        AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, image, "", iconsize * 1.3f, marker.x, marker.z, colStart, colEnd, rowStart, rowEnd);
                    }
                }
            }
            if (MapSettings.player)
            {
                var selfMarker = user.GetMarker();
                if (selfMarker != null)
                {
                    var selfImage = GetImage($"self{selfMarker.r}");
                    if (!string.IsNullOrEmpty(selfImage))
                        AddComplexIcon(ref mapContainer, LustyUI.ComplexOverlay, selfImage, "", iconsize * 1.25f, selfMarker.x, selfMarker.z, colStart, colEnd, rowStart, rowEnd);
                }
            }
            if (MapSettings.compass)
                AddMapCompass(player, ref mapContainer, LustyUI.ComplexOverlay, 10, "0 -0.25", "1 -0.02");

            CuiHelper.DestroyUi(player, LustyUI.ComplexOverlay);
            CuiHelper.AddUi(player, mapContainer);
        }
        void AddComplexIcon(ref CuiElementContainer mapContainer, string panel, string image, string name, float iconsize, float x, float z, double colStart, double colEnd, double rowStart, double rowEnd)
        {
            if ((x > colStart && x < colEnd) && (z > rowEnd && z < rowStart))
            {
                var average = 1 / (colEnd - colStart);
                double posX = (x - colStart) * average;
                double posZ = (z - rowEnd) * average;

                if (posX < 0 + iconsize || posX > 1 - iconsize || posZ < 0 + iconsize || posZ > 1 - iconsize) return;
                LMUI.LoadImage(ref mapContainer, panel, image, $"{posX - iconsize} {posZ - iconsize}", $"{posX + iconsize} {posZ + iconsize}");
                if (MapSettings.names)
                    LMUI.CreateLabel(ref mapContainer, panel, "", name, 10, $"{posX - 0.1} {posZ - iconsize - 0.025}", $"{posX + 0.1} {posZ - iconsize}");
            }
        }
        #endregion
        #endregion

        #region Commands
        [ConsoleCommand("LMUI_Control")]
        private void cmdLustyControl(ConsoleSystem.Arg arg)
        {
            if (!activated) return;
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var user = GetUser(player);
            if (user == null) return;
            switch (arg.Args[0].ToLower())
            {
                case "map":
                    user.ToggleMain();
                    return;
                case "shrink":
                    user.ToggleMapType(MapMode.None);
                    return;
                case "expand":
                    if (user.Zoom() > 0)
                        user.ToggleMapType(MapMode.Complex);
                    else user.ToggleMapType(MapMode.Minimap);
                    return;
                case "zoomin":
                    user.Zoom(true);
                    break;
                case "zoomout":
                    user.Zoom(false);
                    return;
                default:
                    return;
            }
        }
        [ConsoleCommand("resetmap")]
        void ccmdResetmap(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            SendReply(arg, "Map reset Confirmed! Creating a new image load order with ImageLibrary");
            LoadImages();
            LoadMapImage();
        }
        [ChatCommand("map")]
        void cmdOpenMap(BasePlayer player, string command, string[] args)
        {
            if (!activated)
            {
                SendReply(player, "LustyMap is not activated");
                return;
            }
            var user = GetUser(player);
            if (user == null)
            {
                user = player.gameObject.AddComponent<MapUser>();
                mapUsers.Add(player.UserIDString, user);
                user.InitializeComponent();
            }
            if (args.Length == 0)
                user.ToggleMapType(MapMode.Main);
            else
            {
                if (args[0].ToLower() == "mini")
                    user.ToggleMapType(MapMode.Minimap);
                if (args[0].ToLower() == "admin")
                {
                    if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, "lustymap.admin")) return;
                    if (user.IsAdmin)
                    {
                        user.ToggleAdmin(false);
                        SendReply(player, "Admin mode disabled");
                    }
                    else
                    {
                        user.ToggleAdmin(true);
                        SendReply(player, "Admin mode enabled");
                    }
                }
            }
        }

        [ChatCommand("marker")]
        void cmdMarker(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, "lustymap.admin")) return;
            if (args.Length == 0)
            {
                SendReply(player, "Add and remove markers / custom icons to the map. See the overview for information regarding using custom icons");
                SendReply(player, "/marker add <name> <opt:iconname> - Adds a new markers with the name specified at your location.");
                SendReply(player, "/marker remove <name> - Removes the marker with the name specified");
                return;
            }
            if (args.Length < 2)
            {
                SendReply(player, "You must enter a marker name!");
                return;
            }
            var name = args[1];
            switch (args[0].ToLower())
            {
                case "add":
                    string icon = "special";
                    if (args.Length > 2)
                        icon = args[2];
                    if (AddMarker(player.transform.position.x, player.transform.position.z, name, icon))
                        SendReply(player, $"You have successfully added a new map marker with the name: {name}");
                    else SendReply(player, $"A map marker with the name \"{name}\" already exists");
                    return;
                case "remove":
                    if (RemoveMarker(name))
                        SendReply(player, $"You have successfully removed the map marker with the name: {name}");
                    else SendReply(player, $"No map marker with the name \"{name}\" exists");
                    return;
                default:
                    SendReply(player, "Incorrect syntax used. type \"/marker\" for more information");
                    break;
            }
        }
        #endregion

        #region Functions    
        private void AddTemporaryEntityMarker(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity?.net?.ID == null) return;
            AEType type = AEType.None;
            if (entity is CargoPlane)
            {
                if (!configData.Markers.ShowPlanes) return;
                type = AEType.Plane;
            }
            else if (entity is BaseHelicopter)
            {
                if (!configData.Markers.ShowHelicopters) return;
                type = AEType.Helicopter;
            }
            else if (entity is BradleyAPC)
            {
                if (!configData.Markers.ShowTanks) return;
                type = AEType.Tank;
            }
            else if (entity is BasicCar)
            {
                if (!configData.Markers.ShowCars) return;
                type = AEType.Car;
            }
            else if (entity is SupplyDrop)
            {
                if (!configData.Markers.ShowSupplyDrops) return;
                type = AEType.SupplyDrop;
            }
            else if (entity is HelicopterDebris)
            {
                if (!configData.Markers.ShowDebris) return;
                type = AEType.Debris;
            }
            else if (entity is VendingMachine)
            {
                if (!configData.Markers.ShowPublicVendingMachines) return;
                if (!(entity as VendingMachine).IsBroadcasting()) return;
                type = AEType.Vending;
            }
            var actEnt = entity.gameObject.AddComponent<ActiveEntity>();
            actEnt.SetType(type);

            entityMarkers.Add(entity.net.ID, actEnt);
        }
        private void LoadSettings()
        {
            MapSettings.caves = configData.Markers.ShowCaves;
            MapSettings.compass = configData.Map.ShowCompass;
            MapSettings.debris = configData.Markers.ShowDebris;
            MapSettings.heli = configData.Markers.ShowHelicopters;
            MapSettings.monuments = configData.Markers.ShowMonuments;
            MapSettings.plane = configData.Markers.ShowPlanes;
            MapSettings.player = configData.Markers.ShowPlayer;
            MapSettings.allplayers = configData.Markers.ShowAllPlayers;
            MapSettings.supply = configData.Markers.ShowSupplyDrops;
            MapSettings.friends = configData.Markers.ShowFriends;
            MapSettings.names = configData.Markers.ShowMarkerNames;
            MapSettings.minimap = configData.MiniMap.UseMinimap;
            MapSettings.vending = configData.Markers.ShowPublicVendingMachines;
            MapSettings.complexmap = configData.ComplexOptions.UseComplexMap;
            MapSettings.forcedzoom = configData.ComplexOptions.ForceMapZoom;
            MapSettings.zoomlevel = configData.ComplexOptions.ForcedZoomLevel;
            MapSettings.cars = configData.Markers.ShowCars;
            MapSettings.tanks = configData.Markers.ShowTanks;

            if (MapSettings.zoomlevel < 1)
                MapSettings.zoomlevel = 1;
            if (MapSettings.zoomlevel > 3)
                MapSettings.zoomlevel = 3;
        }
        private void FindStaticMarkers()
        {
            if (MapSettings.monuments)
            {
                var monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
                foreach (var monument in monuments)
                {
                    MapMarker mon = new MapMarker
                    {
                        x = GetPosition(monument.transform.position.x),
                        z = GetPosition(monument.transform.position.z)
                    };

                    if (monument.name.Contains("lighthouse"))
                    {
                        mon.name = msg("lighthouse");
                        mon.icon = "lighthouse";
                        staticMarkers.Add(mon);
                        continue;
                    }
                    if (monument.Type == MonumentType.Cave && MapSettings.caves)
                    {
                        mon.name = msg("cave");
                        mon.icon = "cave";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("powerplant_1"))
                    {
                        mon.name = msg("powerplant");
                        mon.icon = "special";
                        staticMarkers.Add(mon);
                        continue;
                    }
                    if (monument.name.Contains("harbor_1"))
                    {
                        mon.name = msg("small harbor");
                        mon.icon = "harbor";
                        staticMarkers.Add(mon);
                        continue;
                    }
                    if (monument.name.Contains("harbor_2"))
                    {
                        mon.name = msg("big harbor");
                        mon.icon = "harbor";
                        staticMarkers.Add(mon);
                        continue;
                    }
                    if (monument.name.Contains("military_tunnel_1"))
                    {
                        mon.name = msg("militarytunnel");
                        mon.icon = "special";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("airfield_1"))
                    {
                        mon.name = msg("airfield");
                        mon.icon = "special";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("trainyard_1"))
                    {
                        mon.name = msg("trainyard");
                        mon.icon = "special";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("water_treatment_plant_1"))
                    {
                        mon.name = msg("waterplant");
                        mon.icon = "special";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("warehouse"))
                    {
                        mon.name = msg("warehouse");
                        mon.icon = "warehouse";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("satellite_dish"))
                    {

                        mon.name = msg("dish");
                        mon.icon = "dish";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("sphere_tank"))
                    {
                        mon.name = msg("spheretank");
                        mon.icon = "spheretank";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("radtown_small_3"))
                    {
                        mon.name = msg("radtown");
                        mon.icon = "radtown";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("launch_site_1"))
                    {
                        mon.name = msg("rocketfactory");
                        mon.icon = "rocketfactory";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("gas_station_1"))
                    {
                        mon.name = msg("gasstation");
                        mon.icon = "gasstation";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("supermarket_1"))
                    {
                        mon.name = msg("supermarket");
                        mon.icon = "supermarket";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("mining_quarry_c"))
                    {
                        mon.name = msg("quarryhqm");
                        mon.icon = "quarryhqm";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("mining_quarry_a"))
                    {
                        mon.name = msg("quarrysulfur");
                        mon.icon = "quarrysulfur";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("mining_quarry_b"))
                    {
                        mon.name = msg("quarrystone");
                        mon.icon = "quarrystone";
                        staticMarkers.Add(mon);
                        continue;
                    }

                    if (monument.name.Contains("junkyard_1"))
                    {
                        mon.name = msg("junkyard");
                        mon.icon = "junkyard";
                        staticMarkers.Add(mon);
                        continue;
                    }
                }
            }
        }
        private void FindVendingMachines()
        {
            if (!MapSettings.vending) return;
            var machines = UnityEngine.Object.FindObjectsOfType<VendingMachine>();
            foreach (var vendor in machines)
            {
                AddTemporaryEntityMarker(vendor);
            }
        }
        private void FindVehicles()
        {
            if (MapSettings.cars)
            {
                var cars = UnityEngine.Object.FindObjectsOfType<BasicCar>();
                foreach (var car in cars)
                {
                    AddTemporaryEntityMarker(car);
                }
            }

            if (MapSettings.tanks)
            {
                var tanks = UnityEngine.Object.FindObjectsOfType<BradleyAPC>();
                foreach (var tank in tanks)
                {
                    AddTemporaryEntityMarker(tank);
                }
            }
        }
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        #endregion

        #region Helpers
        public static string RemoveSpecialCharacters(string str)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in str)
            {
                if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= 'А' && c <= 'Я') || (c >= 'а' && c <= 'я') || c == '.' || c == '_')
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
        static float GetPosition(float pos) => (pos + mapSize / 2f) / mapSize;
        static int GetDirection(float rotation) => (int)((rotation - 5) / 10 + 0.5) * 10;
        #endregion

        #region API
        void EnableMaps(BasePlayer player)
        {
            var user = GetUser(player);
            if (user != null)
                user.EnableUser();
        }
        void DisableMaps(BasePlayer player)
        {
            var user = GetUser(player);
            if (user != null)
                user.DisableUser();
        }

        #region Markers
        bool AddMarker(float x, float z, string name, string icon = "special", float r = 0)
        {
            if (customMarkers.ContainsKey(name)) return false;
            MapMarker marker = new MapMarker
            {
                icon = icon,
                name = name,
                x = GetPosition(x),
                z = GetPosition(z),
                r = r
            };
            if (r > 0) marker.r = GetDirection(r);
            customMarkers.Add(name, marker);
            if (!string.IsNullOrEmpty(icon) && icon != "special")
            {
                string url = icon;
                if (!url.StartsWith("http") && !url.StartsWith("www") && !url.StartsWith("file://"))
                    url = $"{dataDirectory}custom{Path.DirectorySeparatorChar}{icon}.png";
                ImageLibrary.AddImage(url, name, 0);
            }
            SaveMarkers();
            return true;
        }
        void UpdateMarker(float x, float z, string name, string icon = "special", float r = 0)
        {
            if (!customMarkers.ContainsKey(name)) return;
            MapMarker marker = new MapMarker
            {
                icon = icon,
                name = name,
                x = GetPosition(x),
                z = GetPosition(z),
                r = r
            };
            if (r > 0) marker.r = GetDirection(r);
            customMarkers[name] = marker;

            if (!string.IsNullOrEmpty(icon) && icon != "special" && !ImageLibrary.HasImage(name, 0))
            {
                string url = icon;
                if (!url.StartsWith("http") && !url.StartsWith("www"))
                    url = $"{dataDirectory}custom{Path.DirectorySeparatorChar}{icon}.png";
                ImageLibrary.AddImage(url, name, 0);
            }
            SaveMarkers();
        }
        bool RemoveMarker(string name)
        {
            if (!customMarkers.ContainsKey(name)) return false;
            customMarkers.Remove(name);
            SaveMarkers();
            return true;
        }

        bool AddTemporaryMarker(float x, float z, string name, string icon = "special", float r = 0)
        {
            if (temporaryMarkers.ContainsKey(name)) return false;
            MapMarker marker = new MapMarker
            {
                icon = icon,
                name = name,
                x = GetPosition(x),
                z = GetPosition(z),
                r = r
            };
            if (r > 0) marker.r = GetDirection(r);
            temporaryMarkers.Add(name, marker);
            if (!string.IsNullOrEmpty(icon) && icon != "special")
            {
                string url = icon;
                if (!url.StartsWith("http") && !url.StartsWith("www") && !url.StartsWith("file://"))
                    url = $"{dataDirectory}custom{Path.DirectorySeparatorChar}{icon}.png";
                ImageLibrary.AddImage(url, name, 0);
            }
            return true;
        }
        void UpdateTemporaryMarker(float x, float z, string name, string icon = "special", float r = 0)
        {
            if (!temporaryMarkers.ContainsKey(name)) return;
            MapMarker marker = new MapMarker
            {
                icon = icon,
                name = name,
                x = GetPosition(x),
                z = GetPosition(z),
                r = r
            };
            if (r > 0) marker.r = GetDirection(r);
            temporaryMarkers[name] = marker;

            if (!string.IsNullOrEmpty(icon) && icon != "special" && !ImageLibrary.HasImage(name, 0))
            {
                string url = icon;
                if (!url.StartsWith("http") && !url.StartsWith("www"))
                    url = $"{dataDirectory}custom{Path.DirectorySeparatorChar}{icon}.png";
                ImageLibrary.AddImage(url, name, 0);
            }
        }
        bool RemoveTemporaryMarker(string name)
        {
            if (!temporaryMarkers.ContainsKey(name)) return false;
            temporaryMarkers.Remove(name);
            return true;
        }
        bool RemoveTemporaryMarkerStartsWith(string name)
        {
            var keyArray = temporaryMarkers.Keys.ToArray();
            for (int i = 0; i < temporaryMarkers.Count; i++)
            {
                string key = keyArray[i];
                if (key.StartsWith(name))
                    temporaryMarkers.Remove(key);

            }
            return true;
        }
        #endregion

        #region Friends
        bool AddFriendList(string playerId, string name, List<string> list, bool bypass = false)
        {
            if (!bypass && !configData.Friends.AllowCustomLists) return false;
            var user = GetUserByID(playerId);
            if (user == null) return false;
            if (user.HasFriendList(name))
                return false;

            user.AddFriendList(name, list);
            return true;
        }
        bool RemoveFriendList(string playerId, string name, bool bypass = false)
        {
            if (!bypass && !configData.Friends.AllowCustomLists) return false;
            var user = GetUserByID(playerId);
            if (user == null) return false;
            if (!user.HasFriendList(name))
                return false;

            user.RemoveFriendList(name);
            return true;
        }
        bool UpdateFriendList(string playerId, string name, List<string> list, bool bypass = false)
        {
            if (!bypass && !configData.Friends.AllowCustomLists) return false;
            var user = GetUserByID(playerId);
            if (user == null) return false;
            if (!user.HasFriendList(name))
                return false;

            user.UpdateFriendList(name, list);
            return true;
        }
        bool AddFriend(string playerId, string name, string friendId, bool bypass = false)
        {
            if (!bypass && !configData.Friends.AllowCustomLists) return false;
            var user = GetUserByID(playerId);
            if (user == null) return false;
            if (!user.HasFriendList(name))
                user.AddFriendList(name, new List<string>());
            if (user.HasFriend(name, friendId))
                return true;
            user.AddFriend(name, friendId);
            return true;
        }
        bool RemoveFriend(string playerId, string name, string friendId, bool bypass = false)
        {
            if (!bypass && !configData.Friends.AllowCustomLists) return false;
            var user = GetUserByID(playerId);
            if (user == null) return false;
            if (!user.HasFriendList(name))
                return false;
            if (!user.HasFriend(name, friendId))
                return true;
            user.RemoveFriend(name, friendId);
            return true;
        }
        #endregion

        string GetMap() => GetImage("mapimage");
        bool SplitMap(int splices)
        {
            mapSplitter.SplitMap(GetImage("mapimage_high"), splices);
            return true;
        }

        #endregion

        #region External API  
        void JoinedEvent(BasePlayer player)
        {
            var user = GetUser(player);
            if (user != null)
                user.EnterEvent();
        }
        void LeftEvent(BasePlayer player)
        {
            var user = GetUser(player);
            if (user != null)
                user.ExitEvent();
        }

        #region Friends
        List<string> GetFriends(ulong playerId)
        {
            var success = Friends?.Call("GetFriends", playerId);
            if (success is string[])
            {
                return (success as string[]).ToList();
            }
            return new List<string>();
        }
        void OnFriendAdded(object playerId, object friendId)
        {
            AddFriend(friendId.ToString(), "Friends", playerId.ToString(), true);
        }
        void OnFriendRemoved(object playerId, object friendId)
        {
            RemoveFriend(friendId.ToString(), "Friends", playerId.ToString(), true);
        }
        #endregion

        #region Clans
        void GetClans()
        {
            if (Clans)
            {
                var allClans = Clans?.Call("GetAllClans");
                if (allClans != null && allClans is JArray)
                {
                    foreach (var clan in (JArray)allClans)
                    {
                        var name = clan.ToString();
                        List<string> members = GetClanMembers(name);
                        if (!clanData.ContainsKey(name))
                            clanData.Add(name, new List<string>());
                        clanData[name] = members;
                    }
                }
            }
        }
        string GetClan(ulong playerId)
        {
            string clanName = Clans?.Call<string>("GetClanOf", playerId);
            if (!string.IsNullOrEmpty(clanName))
            {
                if (!clanData.ContainsKey(clanName))
                    clanData.Add(clanName, GetClanMembers(clanName));
            }
            return clanName;
        }
        List<string> GetClanMembers(string clanTag)
        {
            var newList = new List<string>();
            var clan = instance.Clans?.Call("GetClan", clanTag);
            if (clan != null && clan is JObject)
            {
                var members = (clan as JObject).GetValue("members");
                if (members != null && members is JArray)
                {
                    foreach (var member in (JArray)members)
                    {
                        newList.Add(member.ToString());
                    }
                }
            }
            return newList;
        }
        void OnClanCreate(string tag)
        {
            if (!clanData.ContainsKey(tag))
                clanData.Add(tag, GetClanMembers(tag));
        }
        void OnClanUpdate(string tag)
        {
            var members = GetClanMembers(tag);
            if (!clanData.ContainsKey(tag))
                clanData.Add(tag, members);
            else
            {
                foreach (var member in clanData[tag])
                    RemoveFriendList(member, "Clans", true);
                foreach (var member in members)
                    AddFriendList(member, "Clans", members, true);
                clanData[tag] = members;
            }
        }
        void OnClanDestroy(string tag)
        {
            if (clanData.ContainsKey(tag))
            {
                foreach (var member in clanData[tag])
                    RemoveFriendList(member, "Clans", true);
                clanData.Remove(tag);
            }
        }
        #endregion
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Friend Options")]
            public FriendOptions Friends { get; set; }
            [JsonProperty(PropertyName = "Marker Options")]
            public MapMarkers Markers { get; set; }
            [JsonProperty(PropertyName = "Map - Main Options")]
            public MapOptions Map { get; set; }
            [JsonProperty(PropertyName = "Map - Mini Options")]
            public Minimap MiniMap { get; set; }
            [JsonProperty(PropertyName = "Map - Complex Options")]
            public ComplexMap ComplexOptions { get; set; }
            [JsonProperty(PropertyName = "Spam Options")]
            public SpamOptions Spam { get; set; }

            public class FriendOptions
            {
                [JsonProperty(PropertyName = "Allow custom friend lists from other plugins")]
                public bool AllowCustomLists { get; set; }
                [JsonProperty(PropertyName = "Enable clans support")]
                public bool UseClans { get; set; }
                [JsonProperty(PropertyName = "Enable friends support")]
                public bool UseFriends { get; set; }
            }
            public class MapMarkers
            {
                [JsonProperty(PropertyName = "Show all players")]
                public bool ShowAllPlayers { get; set; }
                [JsonProperty(PropertyName = "Show caves")]
                public bool ShowCaves { get; set; }
                [JsonProperty(PropertyName = "Show debris")]
                public bool ShowDebris { get; set; }
                [JsonProperty(PropertyName = "Show friends and clanmates")]
                public bool ShowFriends { get; set; }
                [JsonProperty(PropertyName = "Show helicopters")]
                public bool ShowHelicopters { get; set; }
                [JsonProperty(PropertyName = "Show marker names")]
                public bool ShowMarkerNames { get; set; }
                [JsonProperty(PropertyName = "Show monuments")]
                public bool ShowMonuments { get; set; }
                [JsonProperty(PropertyName = "Show planes")]
                public bool ShowPlanes { get; set; }
                [JsonProperty(PropertyName = "Show self")]
                public bool ShowPlayer { get; set; }
                [JsonProperty(PropertyName = "Show supply drops")]
                public bool ShowSupplyDrops { get; set; }
                [JsonProperty(PropertyName = "Show vending machines (public broadcast only)")]
                public bool ShowPublicVendingMachines { get; set; }
                [JsonProperty(PropertyName = "Show cars (un-occupied only)")]
                public bool ShowCars { get; set; }
                [JsonProperty(PropertyName = "Show tanks")]
                public bool ShowTanks { get; set; }
            }
            public class MapOptions
            {
                [JsonProperty(PropertyName = "Enable AFK tracking")]
                public bool EnableAFKTracking { get; set; }
                [JsonProperty(PropertyName = "Hide event players")]
                public bool HideEventPlayers { get; set; }
                [JsonProperty(PropertyName = "Open map on for player's when they connect")]
                public bool StartOpen { get; set; }
                [JsonProperty(PropertyName = "Show map compass")]
                public bool ShowCompass { get; set; }
                [JsonProperty(PropertyName = "Map image options")]
                public MapImages MapImage { get; set; }
                [JsonProperty(PropertyName = "Map update time (seconds)")]
                public float UpdateSpeed { get; set; }

                public class MapImages
                {
                    [JsonProperty(PropertyName = "Beancan.io API key (if applicable)")]
                    public string APIKey { get; set; }
                    [JsonProperty(PropertyName = "Use custom map")]
                    public bool CustomMap_Use { get; set; }
                    [JsonProperty(PropertyName = "Custom map filename")]
                    public string CustomMap_Filename { get; set; }
                }
            }
            public class Minimap
            {
                [JsonProperty(PropertyName = "Enable the minimap")]
                public bool UseMinimap { get; set; }
                [JsonProperty(PropertyName = "Minimap horizontal scale")]
                public float HorizontalScale { get; set; }
                [JsonProperty(PropertyName = "Minimap vertical scale")]
                public float VerticalScale { get; set; }
                [JsonProperty(PropertyName = "Minimap docked on the left side of the screen")]
                public bool OnLeftSide { get; set; }
                [JsonProperty(PropertyName = "Minimap offset from side of the screen")]
                public float OffsetSide { get; set; }
                [JsonProperty(PropertyName = "Minimap offset from top of the screen")]
                public float OffsetTop { get; set; }
            }
            public class ComplexMap
            {
                [JsonProperty(PropertyName = "Enable the complex map")]
                public bool UseComplexMap { get; set; }
                [JsonProperty(PropertyName = "Force complex zoom mode")]
                public bool ForceMapZoom { get; set; }
                [JsonProperty(PropertyName = "Forced zoom number (1, 2 or 3)")]
                public int ForcedZoomLevel { get; set; }
            }
            public class SpamOptions
            {
                [JsonProperty(PropertyName = "Allowed time between map changes")]
                public int TimeBetweenAttempts { get; set; }
                [JsonProperty(PropertyName = "Attempts before warning the user they are spamming")]
                public int WarningAttempts { get; set; }
                [JsonProperty(PropertyName = "Attempts before disabling the users map")]
                public int DisableAttempts { get; set; }
                [JsonProperty(PropertyName = "Amount of time a users map will be disabled")]
                public int DisableSeconds { get; set; }
                [JsonProperty(PropertyName = "Enable spam monitoring")]
                public bool Enabled { get; set; }
            }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Friends = new ConfigData.FriendOptions
                {
                    AllowCustomLists = true,
                    UseClans = true,
                    UseFriends = true,
                },
                Markers = new ConfigData.MapMarkers
                {
                    ShowAllPlayers = false,
                    ShowCars = true,
                    ShowCaves = false,
                    ShowDebris = false,
                    ShowFriends = true,
                    ShowHelicopters = true,
                    ShowMarkerNames = true,
                    ShowMonuments = true,
                    ShowPlanes = true,
                    ShowPlayer = true,
                    ShowSupplyDrops = true,
                    ShowPublicVendingMachines = true,
                    ShowTanks = true
                },
                Map = new ConfigData.MapOptions
                {
                    EnableAFKTracking = true,
                    HideEventPlayers = true,
                    ShowCompass = true,
                    StartOpen = true,
                    MapImage = new ConfigData.MapOptions.MapImages
                    {
                        APIKey = "",
                        CustomMap_Filename = "",
                        CustomMap_Use = false
                    },
                    UpdateSpeed = 1f
                },
                MiniMap = new ConfigData.Minimap
                {
                    HorizontalScale = 1.0f,
                    VerticalScale = 1.0f,
                    OnLeftSide = true,
                    OffsetSide = 0,
                    OffsetTop = 0,
                    UseMinimap = true
                },
                ComplexOptions = new ConfigData.ComplexMap
                {
                    ForcedZoomLevel = 1,
                    ForceMapZoom = false,
                    UseComplexMap = true
                },
                Spam = new ConfigData.SpamOptions
                {
                    DisableAttempts = 10,
                    DisableSeconds = 120,
                    Enabled = true,
                    TimeBetweenAttempts = 3,
                    WarningAttempts = 5
                }

            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management        
        void SaveMarkers()
        {
            markerData.WriteObject(storedMarkers);
        }
        void LoadData()
        {
            try
            {
                storedMarkers = markerData.ReadObject<MarkerData>();
                customMarkers = storedMarkers.data;
            }
            catch
            {
                storedMarkers = new MarkerData();
            }
        }
        class MarkerData
        {
            public Dictionary<string, MapMarker> data = new Dictionary<string, MapMarker>();
        }
        #endregion

        #region Image Storage
        private string GetImage(string name)
        {
            if (string.IsNullOrEmpty(name)) return null;
            return ImageLibrary.GetImage(name, 0);
        }
        void ValidateImages()
        {
            Puts("[Warning] Validating imagery");
            if (isNewSave || !ImageLibrary.HasImage("mapimage", 0))
            {
                LoadImages();
                LoadMapImage();
            }
            else GenerateMaps(true, MapSettings.minimap, MapSettings.complexmap);
        }

        private void LoadImages()
        {
            Puts("[Warning] Icon images have not been found. Uploading images to file storage");

            string[] files = new string[] { "self", "friend", "other", "heli", "plane", "car", "tank" };
            string path = $"{dataDirectory}icons{Path.DirectorySeparatorChar}";

            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (string file in files)
            {
                for (int i = 0; i <= 360; i = i + 10)
                    newLoadOrder.Add($"{file}{i}", $"{path}{file}{i}.png");
            }

            newLoadOrder.Add("lighthouse", $"{path}lighthouse.png");
            newLoadOrder.Add("radtown", $"{path}radtown.png");
            newLoadOrder.Add("cave", $"{path}cave.png");
            newLoadOrder.Add("warehouse", $"{path}warehouse.png");
            newLoadOrder.Add("dish", $"{path}dish.png");
            newLoadOrder.Add("rocketfactory", $"{path}rocket.png");
            newLoadOrder.Add("spheretank", $"{path}spheretank.png");
            newLoadOrder.Add("harbor", $"{path}harbor.png");
            newLoadOrder.Add("special", $"{path}special.png");
            newLoadOrder.Add("supply", $"{path}supply.png");
            newLoadOrder.Add("debris", $"{path}debris.png");
            newLoadOrder.Add("vending", $"{path}vending.png");
            newLoadOrder.Add("gasstation", $"{path}gas.png");
            newLoadOrder.Add("supermarket", $"{path}market.png");
            newLoadOrder.Add("quarryhqm", $"{path}quarryhqm.png");
            newLoadOrder.Add("quarrystone", $"{path}quarrystone.png");
            newLoadOrder.Add("quarrysulfur", $"{path}quarrysulfur.png");
            newLoadOrder.Add("junkyard", $"{path}junkyard.png");

            foreach (var image in customMarkers)
            {
                string icon = image.Value.icon;
                if (icon != "special" && !newLoadOrder.ContainsKey(icon))
                {
                    if (!icon.StartsWith("http") && !icon.StartsWith("www") && !icon.StartsWith("file://"))
                        icon = $"{dataDirectory}custom{Path.DirectorySeparatorChar}{icon}.png";
                    newLoadOrder.Add(image.Value.icon, icon);
                }
            }
            ImageLibrary.ImportImageList(Title, newLoadOrder, 0, true);
        }
        private void LoadMapImage()
        {
            if (configData.Map.MapImage.CustomMap_Use)
            {
                Puts("[Warning] Downloading map image to file storage. Please wait!");
                ImageLibrary.AddImage(dataDirectory + configData.Map.MapImage.CustomMap_Filename, "mapimage_high", 0);
                ScaleMapImage();
                if (MapSettings.complexmap)
                {
                    Puts("[Warning] Attempting to split and store the complex mini-map. This may take a few moments! Failure to wait for this process to finish WILL result in error!");
                    AttemptSplit();
                }
                else GenerateMaps(true, MapSettings.minimap, false);
            }
            else DownloadMapImage();
        }
        #endregion

        #region Map Generation - Credits to Calytic, Nogrod, kraz and beancan.io for the awesome looking map images and API to make this possible!
        void DownloadMapImage()
        {
            if (string.IsNullOrEmpty(configData.Map.MapImage.APIKey))
            {
                Puts("[Error] You must supply a valid API key to utilize the auto-download feature!\nVisit 'beancan.io' and register your server to retrieve your API key!");
                activated = false;
                return;
            }
            Puts("[Warning] Attempting to contact beancan.io to download your map image!");
            GetQueueID();
        }
        void GetQueueID()
        {
            var url = $"http://beancan.io/map-queue-generate?level={level}&seed={mapSeed}&size={mapSize}&key={configData.Map.MapImage.APIKey}";
            webrequest.Enqueue(url, "", (code, response) =>
            {
                if (code != 200 || string.IsNullOrEmpty(response))
                {
                    if (code == 403)
                        PrintError($"Error: {code} - Invalid API key. Unable to download map image");
                    else Puts($"[Warning] Error: {code} - Couldn't get an answer from beancan.io. Unable to download map image. Please try again in a few minutes");
                }
                else CheckAvailability(response);
            }, this);
        }
        void CheckAvailability(string queueId)
        {
            webrequest.Enqueue($"http://beancan.io/map-queue/{queueId}", "", (code, response) =>
            {
                if (string.IsNullOrEmpty(response))
                {
                    Puts($"[Warning] Error: {code} - Couldn't get an answer from beancan.io");
                }
                else ProcessResponse(queueId, response);
            }, this);
        }
        void ProcessResponse(string queueId, string response)
        {
            switch (response)
            {
                case "-1":
                    Puts("[Warning] Your map is still in the queue to be generated. Checking again in 10 seconds");
                    break;
                case "0":
                    Puts("[Warning] Your map is still being generated. Checking again in 10 seconds");
                    break;
                case "1":
                    GetMapURL(queueId);
                    return;
                default:
                    Puts($"[Warning] Error retrieving map: Invalid response from beancan.io: Response code {response}");
                    return;
            }
            timer.Once(10, () => CheckAvailability(queueId));
        }
        void GetMapURL(string queueId)
        {
            var url = $"http://beancan.io/map-queue-image/{queueId}";
            webrequest.Enqueue(url, "", (code, response) =>
            {
                if (string.IsNullOrEmpty(response))
                {
                    Puts($"[Warning] Error: {code} - Couldn't get an answer from beancan.io");
                }
                else DownloadMap(response);
            }, this);
        }
        void DownloadMap(string url)
        {
            Puts("[Warning] Map generation successful! Downloading map image to file storage. Please wait!");
            ImageLibrary.AddImage(url, "mapimage_high", 0);
            ScaleMapImage();

            if (MapSettings.complexmap)
            {
                Puts("[Warning] Attempting to split and store the complex mini-map. This may take a while, please wait!");
                AttemptSplit();
            }
            else GenerateMaps(true, MapSettings.minimap, false);
        }
        void ScaleMapImage()
        {
            if (ImageLibrary.HasImage("mapimage_high", 0))
            {
                System.Drawing.Image image = mapSplitter.ImageFromStorage(uint.Parse(GetImage("mapimage_high")));
                var bytes = mapSplitter.ResizeImage(image, 1024);
                ImageLibrary.ImportImageData($"{instance.Title} - Map Image", new Dictionary<string, byte[]> { { "mapimage", bytes } }, 0, true);
            }
            else timer.In(1, ScaleMapImage);
        }
        #endregion

        #region Map Splitter
        void AttemptSplit(int attempts = 0)
        {
            if (attempts == 5)
            {
                Puts("[Error] The plugin has timed out trying to find the map image to split! Complex map has been disabled");
                MapSettings.complexmap = false;
                return;
            }
            if (ImageLibrary.HasImage("mapimage_high", 0))
            {
                var imageId = GetImage("mapimage_high");
                bool hasSplit = true;
                foreach (var amount in new int[] { 6, 12, 26 })
                {
                    if (!mapSplitter.SplitMap(imageId, amount))
                        hasSplit = false;
                }
                if (hasSplit)
                {
                    Puts("[Warning] Map split was successful!");
                    GenerateMaps(true, MapSettings.minimap, true);
                }
                else
                {
                    MapSettings.complexmap = false;
                    GenerateMaps(true, MapSettings.minimap, MapSettings.complexmap);
                }
            }
            else
            {
                Puts($"[Warning] Map image not found in file store. Waiting for 10 seconds and trying again (Attempt: {attempts + 1} / 5)");
                timer.Once(10, () => AttemptSplit(attempts + 1));
            }
        }
        class MapSplitter
        {
            public bool SplitMap(string imageId, int amount)
            {
                System.Drawing.Image img = ImageFromStorage(uint.Parse(imageId));
                if (img == null)
                {
                    instance.Puts("[Error] Unable to load the map image from file storage. This may be caused by slow processing of the images being uploaded to your server. Wait for 5 minutes and reload the plugin. \nIf this problem persists after multiple attempts then unload the plugin and delete your ImageData.json data file or run the 'resetmap' command");
                    return false;
                }
                instance.Puts($"[Warning] Starting complex map split ({amount}x). Please wait!");
                Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();

                int width = (int)(img.Width / (double)amount);
                int height = (int)(img.Height / (double)amount);

                int rowCount = 0;
                int colCount = 0;
                for (int r = 0; r < amount; r++)
                {
                    colCount = 0;
                    for (int c = 0; c < amount; c++)
                    {
                        var column = colCount;
                        var row = rowCount;
                        if (column < 1) column = 1;
                        if (column > amount - 2) column = amount - 2;
                        if (row < 1) row = 1;
                        if (row > amount - 2) row = amount - 2;

                        Bitmap cutPiece = new Bitmap(width * 3, height * 3);
                        System.Drawing.Graphics graphic = System.Drawing.Graphics.FromImage(cutPiece);
                        graphic.DrawImage(img, new Rectangle(0, 0, width * 3, height * 3), new Rectangle((width * column) - width, (height * row) - height, width * 3, height * 3), GraphicsUnit.Pixel);
                        graphic.Dispose();
                        colCount++;

                        byte[] array = ResizeImage(cutPiece, 256);
                        newLoadOrder.Add($"map-{amount}-{r}-{c}", array);
                    }
                    rowCount++;
                }
                instance.ImageLibrary.ImportImageData($"{instance.Title} - Complex ({amount})", newLoadOrder, 0, true);
                return true;
            }
            public System.Drawing.Image ImageFromStorage(uint imageId)
            {
                byte[] imageData = FileStorage.server.Get(imageId, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
                System.Drawing.Image img = null;
                try
                {
                    img = (System.Drawing.Bitmap)((new System.Drawing.ImageConverter()).ConvertFrom(imageData));
                }
                catch (Exception ex)
                {
                    instance.PrintError($"Error whilst retrieving the map image from file storage: {ex.Message}\nIf you are running linux you must install LibGDIPlus using the following line: \"sudo apt install libgdiplus\", then restart your system for the changes to take affect");
                }
                return img;
            }
            public byte[] ResizeImage(Image image, int pixels)
            {
                var destRect = new Rectangle(0, 0, pixels, pixels);
                var destImage = new Bitmap(pixels, pixels);

                destImage.SetResolution(image?.HorizontalResolution ?? pixels, image?.VerticalResolution ?? pixels);

                using (var graphics = System.Drawing.Graphics.FromImage(destImage))
                {
                    graphics.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceCopy;
                    graphics.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;
                    graphics.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                    graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;
                    graphics.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.HighQuality;

                    using (var wrapMode = new System.Drawing.Imaging.ImageAttributes())
                    {
                        wrapMode.SetWrapMode(System.Drawing.Drawing2D.WrapMode.TileFlipXY);
                        graphics.DrawImage(image, destRect, 0, 0, image?.Width ?? pixels, image?.Height ?? pixels, GraphicsUnit.Pixel, wrapMode);
                    }
                }
                System.Drawing.ImageConverter converter = new System.Drawing.ImageConverter();
                byte[] array = (byte[])converter.ConvertTo(destImage, typeof(byte[]));
                return array;
            }
        }
        #endregion

        #region Localization
        string msg(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"cpsN", "North" },
                {"cpsNE", "North-East" },
                {"cpsE", "East" },
                {"cpsSE", "South-East" },
                {"cpsS", "South" },
                {"cpsSW", "South-West" },
                {"cpsW", "West" },
                {"cpsNW", "North-West" },
                {"Plane", "Plane" },
                {"Supply Drop", "Supply Drop" },
                {"Helicopter", "Helicopter" },
                {"Car", "Car" },
                {"Tank", "Tank" },
                {"Debris", "Debris" },
                {"Vending", "Vending Machine" },
                {"lighthouse", "lighthouse" },
                {"radtown", "radtown" },
                {"spheretank", "spheretank" },
                {"big harbor", "big harbor" },
                {"small harbor", "small harbor" },
                {"gasstation", "gas station" },
                {"supermarket", "super market" },
                {"dish","dish" },
                {"warehouse","warehouse" },
                {"waterplant", "waterplant" },
                {"trainyard", "trainyard" },
                {"airfield", "airfield" },
                {"militarytunnel", "militarytunnel" },
                {"powerplant", "powerplant" },
                {"rocketfactory", "rocketfactory" },
                {"cave", "cave" },
                {"spamWarning", "Please do not spam the map. If you continue to do so your map will be temporarily disabled" },
                {"spamDisable", "Your map has been disabled for {0} seconds" },
                {"spamEnable", "Your map has been enabled" }
            }, this);
        }
        #endregion
    }
}

// --- End of file: LustyMap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/life-vest ---
// --- Original File Path: L/LifeVest/LifeVest.cs ---

using System;
using System.Collections.Generic;
using System.Linq; 
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
            
namespace Oxide.Plugins
{    
    [Info("Life Vest", "baconjake", "0.6.2")]
    [Description("Allows players a way to revive at death location")]

    public class LifeVest : RustPlugin
    {
        private const string PERMISSION_USE = "lifevest.use";
        private const string PERMISSION_GIVE = "lifevest.give";
        private const string PERMISSION_NOCD = "lifevest.nocd";
        private Dictionary<string, float> lifeVestCooldowns = new Dictionary<string, float>();
        private BaseEntity parentEntity = null;
        private Vector3 deathPosition = Vector3.zero;

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LifeVestButtonText"] = "LifeVest",
                ["NoPermission"] = "You do not have permission to use the LifeVest.",
                ["Usage"] = "Usage: /giveLifeVest <playerName>",
                ["Cooldown"] = "Your LifeVest is on cooldown.",
                ["NoCooldown"] = "There is no cooldown on LifeVest",
                ["PlayerNotFound"] = "Player not found.",
                ["LifeVestError"] = "Error: LifeVest item not created.",
                ["LifeVestGranted"] = "LifeVest granted to {0}.",
                ["LifeVestsGranted"] = "LifeVests have been granted to all eligible players.",
                ["LifeVestReceived"] = "You've been granted a LifeVest. Use it wisely!",
                ["LifeVestNotGiven"] = "Error: LifeVest could not be given to the target player.",
                ["ServerMessage"] = "{0} has defied the odds and returned to the battlefield!"
            }, this);
    }
        
	private class ConfigData
	{
    	public string Version { get; set; }
   		public float LifeVestDurabilityLoss { get; set; }
    	public float StartingDurability { get; set; }
   		public int RevivePlayerHealth { get; set; }
    	public ulong ItemSkinId { get; set; }
    	public string ItemShortName { get; set; }
    	public string ItemDisplayName { get; set; }
    	public bool EnableDurabilityLoss { get; set; }
    	public bool EnableServerMessage { get; set; }
    	public int LifeVestCooldown { get; set; }  
	}

    private ConfigData configData;

    private bool IsWearingLifeVest(BasePlayer player)
    {
        Item chestplate = player.inventory.containerWear.FindItemByItemID(ItemManager.FindItemDefinition(configData.ItemShortName).itemid);
        return chestplate != null && chestplate.skin == configData.ItemSkinId && chestplate.condition > 0;
    }

    private void LoadConfigData()
    {
        configData = Config.ReadObject<ConfigData>();

        if (configData.Version != Version.ToString())
        {
        PrintWarning("Detected configuration mismatch. Updating to the current version...");
        LoadDefaultConfig();
        }
    }
 
    private void SaveConfigData()
    {
        Config.WriteObject(configData, true);
    }

    protected override void LoadDefaultConfig()
    {
        configData = new ConfigData
        {
        Version = Version.ToString(),
        LifeVestDurabilityLoss = 0.15f,
        StartingDurability = 0.95f,
        RevivePlayerHealth = 100,
        ItemSkinId = 2943487371,
        ItemShortName = "metal.plate.torso",
        ItemDisplayName = "LIFEVEST",
        LifeVestCooldown = 60,
        EnableDurabilityLoss = true,
        EnableServerMessage = true
        };
        SaveConfigData();
    }

    private void Init()
    {
        LoadConfigData();
        permission.RegisterPermission(PERMISSION_USE, this);
        permission.RegisterPermission(PERMISSION_GIVE, this);
        permission.RegisterPermission(PERMISSION_NOCD, this);
    }

    private Quaternion deathRotation = Quaternion.identity;
    void OnPlayerDeath(BasePlayer player, HitInfo info)
	{   
    	if (!IsWearingLifeVest(player)) return;
       
    	Item chestplate = player.inventory.containerWear.FindItemByItemID(ItemManager.FindItemDefinition(configData.ItemShortName).itemid);
    	if (configData.EnableDurabilityLoss && chestplate != null)
    	{
        chestplate.conditionNormalized -= configData.LifeVestDurabilityLoss;  // Reduce the chestplate's durability and update it
        chestplate.MarkDirty();
    	}
    	parentEntity = player.GetParentEntity();

    	if (parentEntity != null && !parentEntity.IsDestroyed)
    	{
            deathPosition = parentEntity.transform.InverseTransformPoint(player.transform.position);
            deathRotation = Quaternion.Inverse(parentEntity.transform.rotation) * player.transform.rotation;  // Store the relative rotation

            var grandparentEntity = parentEntity.GetParentEntity();  // Check for an additional parent
            if (grandparentEntity != null && !grandparentEntity.IsDestroyed)
            {
            deathPosition = grandparentEntity.transform.InverseTransformPoint(parentEntity.transform.TransformPoint(deathPosition));
            deathRotation = Quaternion.Inverse(grandparentEntity.transform.rotation) * parentEntity.transform.rotation * deathRotation;
            parentEntity = grandparentEntity;
            }
        }
   	 	else
        {
        deathPosition = player.transform.position;
        deathRotation = player.transform.rotation;
        }
        CreateLifeVestButton(player);
	}

    private void CreateLifeVestButton(BasePlayer player)  // Revive Button Customization
    {
        var elements = new CuiElementContainer();
        var lifeVestButton = elements.Add(new CuiButton
        {
            Button = { Command = "lifevest.revive", Color = "0.576 0.706 0.145 0.40" },
            RectTransform = { AnchorMin = "0.83 0.89", AnchorMax = "0.95 0.97" },
            Text = {
                    Text = lang.GetMessage("LifeVestButtonText", this, player.UserIDString),
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                    }       
        }, "Hud.Menu", "LifeVestButton");
       CuiHelper.AddUi(player, elements);
    }

    private void RemoveLifeVestButton(BasePlayer player)
    {
       CuiHelper.DestroyUi(player, "LifeVestButton");
    }

   	private void RevivePlayer(BasePlayer player, float lifeVestCondition = -1f)
	{
    	if (IsWearingLifeVest(player) && parentEntity != null && !parentEntity.IsDestroyed)
    	{
        Vector3 worldPosition = parentEntity.transform.TransformPoint(deathPosition);
        Quaternion worldRotation = parentEntity.transform.rotation * deathRotation;  // Calculate the world rotation

        player.RespawnAt(worldPosition, worldRotation);
        player.health = configData.RevivePlayerHealth;
        player.inventory.Strip();
    	}
    	else
    	{
        player.RespawnAt(player.transform.position, player.transform.rotation);
        player.health = configData.RevivePlayerHealth;
        player.inventory.Strip();

        parentEntity = null;  // Resets the parent entity and position if the player revives without LifeVest
        deathPosition = Vector3.zero;
        deathRotation = Quaternion.identity;
        }
 
    	if (lifeVestCondition > 0) // Give back the LifeVest to the player if the condition is specified
    	{
            ItemDefinition itemDef = ItemManager.FindItemDefinition(configData.ItemShortName);
            Item item = ItemManager.Create(itemDef, 1, configData.ItemSkinId);

            if (item != null)
            {
        	item.name = configData.ItemDisplayName;
        	item.condition = lifeVestCondition;
        	item.MarkDirty();

        	player.inventory.GiveItem(item);
            }
        }
        RemoveLifeVestButton(player);
    }

	void OnPlayerRespawned(BasePlayer player)
	{
    	RemoveLifeVestButton(player);  // Remove the lifevest button
        
    	parentEntity = null;  // Reset necessary variables
    	deathPosition = Vector3.zero;
    	deathRotation = Quaternion.identity;
	}

[ConsoleCommand("lifevest.revive")]
    private void LifeVestReviveCommand(ConsoleSystem.Arg args)
    {
        var player = args.Player();
        if (player == null) return;
        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
        {
        player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
        return;
        }
       	if (!permission.UserHasPermission(player.UserIDString, PERMISSION_NOCD))   // Check if the player has the cooldown bypass permission
    	{
        	float lastUseTime;
        	if (lifeVestCooldowns.TryGetValue(player.UserIDString, out lastUseTime))
        	{
            	if (Time.realtimeSinceStartup - lastUseTime < configData.LifeVestCooldown)
				{
    			player.ChatMessage(lang.GetMessage("Cooldown", this, player.UserIDString)); 
   				return;
				}
        	}
            lifeVestCooldowns[player.UserIDString] = Time.realtimeSinceStartup;  // Update the cooldown
    	}
        if (player.IsDead())  // Ensure the player is actually dead and not just downed
        {
            if (IsWearingLifeVest(player))
            {
            Item chestplate = player.inventory.containerWear.FindItemByItemID(ItemManager.FindItemDefinition(configData.ItemShortName).itemid);
            float lifeVestCondition = chestplate.condition;  // Save the LifeVest's condition
            RevivePlayer(player, lifeVestCondition);
            }
            else
            {
            RevivePlayer(player);
            }
            RemoveLifeVestButton(player); // Always remove the button after the player has been revived
    
            if (configData.EnableServerMessage) 
            {
            string announcement = string.Format(lang.GetMessage("ServerMessage", this, player.UserIDString), player.displayName);
            Server.Broadcast(announcement);
            }
        }
    }

[ChatCommand("givelifevestall")]
    private void GiveLifeVestAllCommand(BasePlayer player, string command, string[] args)
    {
        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_GIVE)) return;

            foreach (BasePlayer target in BasePlayer.activePlayerList)
            {
                if (permission.UserHasPermission(target.UserIDString, PERMISSION_USE))
                {
                GiveLifeVestToPlayer(target);
                }
            }

        player.ChatMessage(lang.GetMessage("LifeVestsGranted", this, player.UserIDString));
    } 

    private void GiveLifeVestToPlayer(BasePlayer target)
    {
        ItemDefinition itemDef = ItemManager.FindItemDefinition(configData.ItemShortName);
        Item item = ItemManager.Create(itemDef, 1, configData.ItemSkinId);

        if (item == null) return;

        item.name = configData.ItemDisplayName;
        item.condition = item.maxCondition * configData.StartingDurability;
        item.MarkDirty();

        target.inventory.GiveItem(item);
    }

[ChatCommand("giveLifeVest")]
    private void GiveLifeVestCommand(BasePlayer player, string command, string[] args)
    {
        if (!permission.UserHasPermission(player.UserIDString, PERMISSION_GIVE)) return;

        if (args.Length == 0)
        {
        player.ChatMessage(lang.GetMessage("Usage", this, player.UserIDString)); 
        return;
        }
        string targetName = args[0];
        BasePlayer target = BasePlayer.activePlayerList.FirstOrDefault(p => p.displayName.Equals(targetName, StringComparison.OrdinalIgnoreCase));
        if (target == null)
        {
        player.ChatMessage(lang.GetMessage("PlayerNotFound", this, player.UserIDString)); 
        return;
        }
        ItemDefinition itemDef = ItemManager.FindItemDefinition(configData.ItemShortName); 
        Item item = ItemManager.Create(itemDef, 1, configData.ItemSkinId); 

        if (item == null)
        {
        player.ChatMessage(lang.GetMessage("LifeVestError", this, player.UserIDString)); 
        return;
        }
        else
		{
    	player.ChatMessage(string.Format(lang.GetMessage("LifeVestGranted", this, player.UserIDString), target.displayName));
    	target.ChatMessage(lang.GetMessage("LifeVestReceived", this, target.UserIDString)); 
		}

    	item.name = configData.ItemDisplayName; // Set item name 
    	item.condition = item.maxCondition * configData.StartingDurability; 
    	item.MarkDirty();

   	 	target.inventory.GiveItem(item);

        if (target.inventory.containerMain.FindItemByUID(item.uid) == null &&  // Check if the LifeVest item is present in the target's inventory
            target.inventory.containerBelt.FindItemByUID(item.uid) == null &&
            target.inventory.containerWear.FindItemByUID(item.uid) == null)
        {
        player.ChatMessage(lang.GetMessage("LifeVestNotGiven", this, player.UserIDString)); 
        return;
        }
    }

 [ChatCommand("lvc")]
        private void LifeVestCooldownCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
            player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString)); 
            return;
            }

            float lastUseTime;
            if (lifeVestCooldowns.TryGetValue(player.UserIDString, out lastUseTime))
            {
                float timePassed = Time.realtimeSinceStartup - lastUseTime;
                float timeRemaining = configData.LifeVestCooldown - timePassed;

                if (timeRemaining > 0)
                {
                player.ChatMessage($"Cooldown remaining: {timeRemaining.ToString("0.##")} seconds");
                }
                else
                {
                player.ChatMessage(lang.GetMessage("NoCooldown", this, player.UserIDString)); 
                }
            }
            else
            {
                player.ChatMessage(lang.GetMessage("NoCooldown", this, player.UserIDString)); 
            }
        }
    }
} 


// --- End of file: LifeVest.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-bouncer ---
// --- Original File Path: L/LootBouncer/LootBouncer.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("Loot Bouncer", "Sorrow/Arainrr", "1.0.10")]
    [Description("Empty the containers when players do not pick up all the items")]
    public class LootBouncer : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Slap, Trade;

        private readonly Dictionary<ulong, int> _lootEntities = new Dictionary<ulong, int>();
        private readonly Dictionary<ulong, HashSet<ulong>> _entityPlayers = new Dictionary<ulong, HashSet<ulong>>();
        private readonly Dictionary<ulong, Timer> _lootDestroyTimer = new Dictionary<ulong, Timer>();

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnPlayerAttack));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            if (configData.slapPlayer && Slap == null)
            {
                PrintError("Slap is not loaded, get it at https://umod.org/plugins/slap");
            }
            if (configData.lootContainers.Any(x => IsBarrel(x.Key) && x.Value))
            {
                Subscribe(nameof(OnEntityDeath));
                Subscribe(nameof(OnPlayerAttack));
            }
        }

        private void Unload()
        {
            foreach (var value in _lootDestroyTimer.Values)
            {
                value?.Destroy();
            }
        }

        private void OnLootEntity(BasePlayer player, LootContainer lootContainer)
        {
            if (lootContainer == null || lootContainer.net == null || player == null)
            {
                return;
            }
            var obj = Trade?.Call("IsTradeBox", lootContainer);
            if (obj is bool && (bool)obj)
            {
                return;
            }
            bool enabled;
            if (configData.lootContainers.TryGetValue(lootContainer.ShortPrefabName, out enabled) && !enabled)
            {
                return;
            }

            var entityID = lootContainer.net.ID.Value;
            if (!_lootEntities.ContainsKey(entityID))
            {
                _lootEntities.Add(entityID, lootContainer.inventory.itemList.Count);
            }

            HashSet<ulong> looters;
            if (_entityPlayers.TryGetValue(entityID, out looters))
            {
                looters.Add(player.userID);
            }
            else
            {
                _entityPlayers.Add(entityID, new HashSet<ulong> { player.userID });
            }

            // If looted again, the timer for emptying will stop
            Timer value;
            if (_lootDestroyTimer.TryGetValue(entityID, out value))
            {
                _lootEntities[entityID] = 666;
                value?.Destroy();
                _lootDestroyTimer.Remove(entityID);
            }
        }

        private void OnLootEntityEnd(BasePlayer player, LootContainer lootContainer)
        {
            if (lootContainer == null || lootContainer.net == null || player == null)
            {
                return;
            }
            var entityID = lootContainer.net.ID.Value;
            HashSet<ulong> looters;
            if (!(lootContainer.inventory?.itemList?.Count > 0))
            {
                _lootEntities.Remove(entityID);
                if (_entityPlayers.TryGetValue(entityID, out looters))
                {
                    looters.Remove(player.userID);
                }
                return;
            }

            int tempItemsCount;
            if (_lootEntities.TryGetValue(entityID, out tempItemsCount))
            {
                _lootEntities.Remove(entityID);
                if (lootContainer.inventory.itemList.Count < tempItemsCount)
                {
                    if (!_lootDestroyTimer.ContainsKey(entityID))
                    {
                        _lootDestroyTimer.Add(entityID, timer.Once(configData.timeBeforeLootEmpty, () => DropItems(lootContainer)));
                    }
                }
                else if (_entityPlayers.TryGetValue(entityID, out looters))
                {
                    looters.Remove(player.userID);
                }
                EmptyJunkPile(lootContainer);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || !attacker.userID.IsSteamId())
            {
                return;
            }
            var barrel = info?.HitEntity as LootContainer;
            if (barrel == null || barrel.net == null)
            {
                return;
            }
            if (!IsBarrel(barrel.ShortPrefabName))
            {
                return;
            }
            bool enabled;
            if (configData.lootContainers.TryGetValue(barrel.ShortPrefabName, out enabled) && !enabled)
            {
                return;
            }

            var barrelID = barrel.net.ID.Value;
            HashSet<ulong> attackers;
            if (_entityPlayers.TryGetValue(barrelID, out attackers))
            {
                attackers.Add(attacker.userID);
            }
            else
            {
                _entityPlayers.Add(barrelID, new HashSet<ulong> { attacker.userID });
            }

            if (!_lootDestroyTimer.ContainsKey(barrelID))
            {
                _lootDestroyTimer.Add(barrelID, timer.Once(configData.timeBeforeLootEmpty, () => DropItems(barrel)));
            }
            EmptyJunkPile(barrel);
        }

        private void OnEntityDeath(LootContainer barrel, HitInfo info)
        {
            if (barrel == null || barrel.net == null)
            {
                return;
            }
            if (!IsBarrel(barrel.ShortPrefabName))
            {
                return;
            }
            var attacker = info?.InitiatorPlayer;
            if (attacker == null || !attacker.userID.IsSteamId())
            {
                return;
            }

            HashSet<ulong> attackers;
            if (!_entityPlayers.TryGetValue(barrel.net.ID.Value, out attackers))
            {
                return;
            }
            attackers.Remove(attacker.userID);
        }

        private void OnEntityKill(LootContainer lootContainer)
        {
            if (lootContainer == null || lootContainer.net == null)
            {
                return;
            }
            var entityID = lootContainer.net.ID.Value;
            _lootEntities.Remove(entityID);

            Timer value;
            if (_lootDestroyTimer.TryGetValue(entityID, out value))
            {
                value?.Destroy();
                _lootDestroyTimer.Remove(entityID);
            }

            HashSet<ulong> playerIDs;
            if (!_entityPlayers.TryGetValue(entityID, out playerIDs))
            {
                return;
            }
            _entityPlayers.Remove(entityID);
            if (configData.slapPlayer && Slap != null)
            {
                foreach (var playerID in playerIDs)
                {
                    var player = BasePlayer.FindByID(playerID);
                    if (player == null || player.IPlayer == null)
                    {
                        continue;
                    }
                    Slap.Call("SlapPlayer", player.IPlayer);
                    Print(player, Lang("SlapMessage", player.UserIDString));
                }
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private static bool IsBarrel(string shortPrefabName)
        {
            return shortPrefabName.Contains("barrel") || shortPrefabName.Contains("roadsign");
        }

        private void DropItems(LootContainer lootContainer)
        {
            if (lootContainer == null || lootContainer.IsDestroyed)
            {
                return;
            }
            if (configData.removeItems)
            {
                lootContainer.inventory?.Clear();
            }
            else
            {
                DropUtil.DropItems(lootContainer.inventory, lootContainer.GetDropPosition());
            }
            lootContainer.RemoveMe();
        }

        private void EmptyJunkPile(LootContainer lootContainer)
        {
            if (!configData.emptyJunkpile)
            {
                return;
            }
            var spawnGroup = lootContainer.GetComponent<SpawnPointInstance>()?.parentSpawnPointUser as SpawnGroup;
            if (spawnGroup == null)
            {
                return;
            }
            var junkPiles = Pool.GetList<JunkPile>();
            Vis.Entities(lootContainer.transform.position, 10f, junkPiles, Layers.Solid);
            var junkPile = junkPiles.FirstOrDefault(x => x.spawngroups.Contains(spawnGroup));
            var flag = junkPile == null || junkPile.net == null;
            Pool.FreeList(ref junkPiles);
            if (flag)
            {
                return;
            }

            if (_lootDestroyTimer.ContainsKey(junkPile.net.ID.Value))
            {
                return;
            }
            _lootDestroyTimer.Add(junkPile.net.ID.Value, timer.Once(configData.timeBeforeJunkpileEmpty, () =>
            {
                if (junkPile != null && !junkPile.IsDestroyed)
                {
                    if (configData.dropNearbyLoot)
                    {
                        var lootContainers = Pool.GetList<LootContainer>();
                        Vis.Entities(junkPile.transform.position, 10f, lootContainers, Layers.Solid);
                        foreach (var loot in lootContainers)
                        {
                            var lootSpawnGroup = loot.GetComponent<SpawnPointInstance>()?.parentSpawnPointUser as SpawnGroup;
                            if (lootSpawnGroup != null && junkPile.spawngroups.Contains(lootSpawnGroup))
                            {
                                DropItems(loot);
                            }
                        }
                        Pool.FreeList(ref lootContainers);
                    }
                    junkPile.SinkAndDestroy();
                }
            }));
        }

        private void UpdateConfig()
        {
            foreach (var prefab in GameManifest.Current.entities)
            {
                var lootContainer = GameManager.server.FindPrefab(prefab.ToLower())?.GetComponent<LootContainer>();
                if (lootContainer == null || string.IsNullOrEmpty(lootContainer.ShortPrefabName))
                {
                    continue;
                }
                if (!configData.lootContainers.ContainsKey(lootContainer.ShortPrefabName))
                {
                    configData.lootContainers.Add(lootContainer.ShortPrefabName, !lootContainer.ShortPrefabName.Contains("stocking") && !lootContainer.ShortPrefabName.Contains("roadsign"));
                }
            }
            SaveConfig();
        }

        #endregion Methods

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Time before the loot containers are empties (seconds)")]
            public float timeBeforeLootEmpty = 30f;

            [JsonProperty(PropertyName = "Empty the entire junkpile when automatically empty loot")]
            public bool emptyJunkpile = false;

            [JsonProperty(PropertyName = "Empty the nearby loot when emptying junkpile")]
            public bool dropNearbyLoot = false;

            [JsonProperty(PropertyName = "Time before the junkpile are empties (seconds)")]
            public float timeBeforeJunkpileEmpty = 150f;

            [JsonProperty(PropertyName = "Slaps players who don't empty containers")]
            public bool slapPlayer = false;

            [JsonProperty(PropertyName = "Remove instead bouncing")]
            public bool removeItems = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chat = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[BackPumpJack]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon;
            }

            [JsonProperty(PropertyName = "Loot container settings")]
            public Dictionary<string, bool> lootContainers = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat prefix") && GetConfigValue(out prefixColor, "Chat prefix color"))
                    {
                        configData.chat.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }

                    ulong steamID;
                    if (GetConfigValue(out steamID, "Chat steamID icon"))
                    {
                        configData.chat.steamIDIcon = steamID;
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chat.prefix, configData.chat.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SlapMessage"] = "You didn't empty the container. You got slapped by the container!!!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SlapMessage"] = "wdnmd，不清空容器，给你个大耳刮子"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: LootBouncer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-scanner ---
// --- Original File Path: L/LootScanner/LootScanner.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Loot Scanner", "Sorrow", "0.4.0")]
    [Description("Allows player to scan loot container with binoculars")]

    class LootScanner : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin PopupNotifications;

        private const int BinocularsId = -1262185308;
        private const string SupplyDrop = "supply_drop";
        private const string CH47Crate = "codelockedhackablecrate";
        private static readonly Dictionary<string, string> PrefabList = new Dictionary<string, string>();

        private const string PermissionWorld = "lootscanner.world";
        private const string PermissionPlayerContainer = "lootscanner.player";
        private const string PermissionSupplyDrop = "lootscanner.supplydrop";
        private const string PermissionCh47Crate = "lootscanner.ch47crate";
        private const string PermissionPlayerCorpse = "lootscanner.playercorpse";
        private const string PermissionAlivePlayer = "lootscanner.aliveplayer";
        private const string PermissionBackpack = "lootscanner.backpack";

        internal static string SideOfGui;
        internal static float PositionY;
        internal static string ColorNone;
        internal static string ColorCommon;
        internal static string ColorUncommon;
        internal static string ColorRare;
        internal static string ColorVeryRare;
        internal static bool HideAirdrop;
        internal static bool HideCh47Crate;
        internal static bool HideCrashSiteCrate;
        internal static bool HideCommonLootableCrate;
        internal static bool HidePlayerName;
        internal static bool HideCorpseName;
        #endregion

        #region uMod Hooks
        private void OnServerInitialized()
        {
            InitPrefabList();

            permission.RegisterPermission(PermissionWorld, this);
            permission.RegisterPermission(PermissionPlayerContainer, this);
            permission.RegisterPermission(PermissionSupplyDrop, this);
            permission.RegisterPermission(PermissionCh47Crate, this);
            permission.RegisterPermission(PermissionPlayerCorpse, this);
            permission.RegisterPermission(PermissionAlivePlayer, this);
            permission.RegisterPermission(PermissionBackpack, this);

            SideOfGui = Convert.ToString(Config["Define the side of GUI (Left - Right)"]);
            PositionY = Convert.ToSingle(Config["Define the y position of GUI"]);
            ColorNone = Convert.ToString(Config["Color None"]);
            ColorCommon = Convert.ToString(Config["Color Common"]);
            ColorUncommon = Convert.ToString(Config["Color Uncommon"]);
            ColorRare = Convert.ToString(Config["Color Rare"]);
            ColorVeryRare = Convert.ToString(Config["Color Very Rare"]);
            HideAirdrop = Convert.ToBoolean(Config["Hide Airdrop's content"]);
            HideCh47Crate = Convert.ToBoolean(Config["Hide CH47 crate content"]);
            HideCrashSiteCrate = Convert.ToBoolean(Config["Hide heli and Bradley crate content"]);
            HideCommonLootableCrate = Convert.ToBoolean(Config["Hide common lootable container"]);
            HidePlayerName = Convert.ToBoolean(Config["Hide player name"]);
            HideCorpseName = Convert.ToBoolean(Config["Hide corpse name"]);
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!player.IsValid() || !input.IsDown(BUTTON.FIRE_SECONDARY) && player.GetActiveItem()?.info.itemid == BinocularsId)
            {
                CuiHelper.DestroyUi(player, player.UserIDString);
                return;
            }

            if (!input.WasJustPressed(BUTTON.USE) || player.GetActiveItem()?.info.itemid != BinocularsId)
                return;

            BaseEntity entity = GetEntityScanned(player, input);
            if (!entity.IsValid())
                return;           

            StorageContainer storageContainer = entity as StorageContainer;
            LootableCorpse playerCorpse = entity as LootableCorpse;
            BasePlayer targetPlayer = entity as BasePlayer;
            DroppedItemContainer backpack = entity as DroppedItemContainer;

            if (storageContainer != null)
                ProcessStorageEntity(player, storageContainer);

            if (playerCorpse != null)
                ProcessCorpseEntity(player, playerCorpse);

            if (targetPlayer != null && targetPlayer.userID.IsSteamId() == true)
                ProcessTargetPlayer(player, targetPlayer);

            if (backpack != null)
                ProcessBackpack(player, backpack);
        }

        private void ProcessBackpack(BasePlayer player, DroppedItemContainer backpack)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionBackpack))
            {
                var backpackName = HidePlayerName ? "Unknown" : backpack.playerName;
                var title = "<color=orange>[Loot Scanner]</color>\n> " + backpackName + " <";

                if (backpack.inventory.itemList.Count > 0)
                {
                    var scannerMessage = "";
                    foreach (var item in backpack.inventory.itemList)
                    {
                        scannerMessage = BuildScannerMessage(scannerMessage, item);
                    }

                    CreateUi(player, title, scannerMessage);
                }
                else
                {
                    var ui = UI.ConstructScanUi(player, title, "> " + string.Format(lang.GetMessage("EmptyStorage", this, player.UserIDString), backpackName));
                    CuiHelper.DestroyUi(player, player.UserIDString);
                    CuiHelper.AddUi(player, ui);
                }
            }
            else
            {
                SendPermissionMessage(player);
            }
        }

        private void ProcessTargetPlayer(BasePlayer player, BasePlayer targetPlayer)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionAlivePlayer))
            {
                var targetPlayerName = HidePlayerName ? "Unknown" : targetPlayer.displayName;
                var title = "<color=orange>[Loot Scanner]</color>\n> " + targetPlayerName + " <";

                if (targetPlayer.inventory.containerMain.itemList.Count > 0)
                {
                    var scannerMessage = "";
                    foreach (var item in targetPlayer.inventory.containerMain.itemList)
                    {
                        scannerMessage = BuildScannerMessage(scannerMessage, item);
                    }

                    if (targetPlayer.inventory.containerBelt.itemList.Count > 0)
                        foreach (var item in targetPlayer.inventory.containerBelt.itemList)
                        {
                            scannerMessage = BuildScannerMessage(scannerMessage, item);
                        }

                    CreateUi(player, title, scannerMessage);
                }
                else
                {
                    var ui = UI.ConstructScanUi(player, title, "> " + string.Format(lang.GetMessage("EmptyStorage", this, player.UserIDString), targetPlayerName));
                    CuiHelper.DestroyUi(player, player.UserIDString);
                    CuiHelper.AddUi(player, ui);
                }
            }
            else
            {
                SendPermissionMessage(player);
            }
        }

        private void ProcessCorpseEntity(BasePlayer player, LootableCorpse corpse)
        {
            if (permission.UserHasPermission(player.UserIDString, PermissionPlayerCorpse))
            {
                var corpseName = HideCorpseName ? "Unknown" : corpse.playerName;
                var title = "<color=orange>[Loot Scanner]</color>\n> " + corpseName + " <";

                foreach (ItemContainer container in corpse.containers)
                {
                    if (container.itemList.Count == 0)
                    {
                        var ui = UI.ConstructScanUi(player, title, "> " + string.Format(lang.GetMessage("EmptyStorage", this, player.UserIDString), corpseName));
                        CuiHelper.DestroyUi(player, player.UserIDString);
                        CuiHelper.AddUi(player, ui);
                    }
                    else
                    {
                        var scannerMessage = "";
                        foreach (var item in container.itemList)
                        {
                            scannerMessage = BuildScannerMessage(scannerMessage, item);
                        }

                        CreateUi(player, title, scannerMessage);
                    }
                }
            }
            else
            {
                SendPermissionMessage(player);
            }
        }

        private void ProcessStorageEntity(BasePlayer player, StorageContainer storage)
        {
            if (storage.OwnerID != 0 && permission.UserHasPermission(player.UserIDString, PermissionPlayerContainer) ||
                storage.ShortPrefabName == SupplyDrop &&
                permission.UserHasPermission(player.UserIDString, PermissionSupplyDrop) ||
                storage.ShortPrefabName == CH47Crate &&
                permission.UserHasPermission(player.UserIDString, PermissionCh47Crate) ||
                storage.OwnerID == 0 && permission.UserHasPermission(player.UserIDString, PermissionWorld))
            {
                var itemDefinition = ItemManager.FindItemDefinition(storage.ShortPrefabName);

                var storageName = itemDefinition != null ? itemDefinition.displayName.english : GetPrefabName(storage);

                var title = "<color=orange>[Loot Scanner]</color>\n> " + storageName + " <";

                if (storage.inventory.itemList.Count > 0)
                {
                    var scannerMessage = "";
                    if (storage.ShortPrefabName == SupplyDrop && HideAirdrop || storage.ShortPrefabName == CH47Crate && HideCh47Crate ||
                        LootContainer.spawnType.CRASHSITE.Equals(storage.GetComponent<LootContainer>()?.SpawnType) && HideCrashSiteCrate ||
                        (LootContainer.spawnType.TOWN.Equals(storage.GetComponent<LootContainer>()?.SpawnType) || LootContainer.spawnType.ROADSIDE.Equals(storage.GetComponent<LootContainer>()?.SpawnType))
                        && HideCommonLootableCrate)
                    {
                        scannerMessage = BuildRarityScannerMessage(scannerMessage, storage.inventory.itemList);
                    }
                    else
                    {
                        foreach (var item in storage.inventory.itemList)
                        {
                            scannerMessage = BuildScannerMessage(scannerMessage, item);
                        }
                    }

                    CreateUi(player, title, scannerMessage);
                }
                else
                {
                    var ui = UI.ConstructScanUi(player, title, "> " + string.Format(lang.GetMessage("EmptyStorage", this, player.UserIDString), storageName));
                    CuiHelper.DestroyUi(player, player.UserIDString);
                    CuiHelper.AddUi(player, ui);
                }
            }
            else
            {
                SendPermissionMessage(player);
            }
        }

        private void SendPermissionMessage(BasePlayer player)
        {
            var permissions = permission.GetUserPermissions(player.UserIDString).Where(p => p.Contains("lootscanner")).ToList();

            if (permissions.Count > 1)
            {
                SendInfoMessage(player, string.Format(lang.GetMessage("TwoPermissions", this, player.UserIDString), BeautifyPermissionName(permissions[0]), BeautifyPermissionName(permissions[1])));
            }
            else if (permissions.Count == 1)
            {
                SendInfoMessage(player, string.Format(lang.GetMessage("OnePermission", this, player.UserIDString), BeautifyPermissionName(permissions[0])));
            }
            else
            {
                SendInfoMessage(player, lang.GetMessage("NoPermissions", this, player.UserIDString));
            }
        }

        private void CreateUi(BasePlayer player, string headerMessage, string contentMessage)
        {
            CuiElementContainer ui = UI.ConstructScanUi(player, headerMessage, contentMessage);
            CuiHelper.DestroyUi(player, player.UserIDString);
            CuiHelper.AddUi(player, ui);
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem?.info.itemid == BinocularsId &&
                (permission.UserHasPermission(player.UserIDString, PermissionWorld) ||
                permission.UserHasPermission(player.UserIDString, PermissionPlayerContainer) ||
                permission.UserHasPermission(player.UserIDString, PermissionSupplyDrop) ||
                permission.UserHasPermission(player.UserIDString, PermissionCh47Crate)))
            {
                SendInfoMessage(player, string.Format(lang.GetMessage("InfoMessage", this, player.UserIDString), BUTTON.USE));
            }

            if (oldItem?.info.itemid == BinocularsId)
            {
                CuiHelper.DestroyUi(player, player.UserIDString);
            }
        }

        #endregion

        #region Helpers
        private static void InitPrefabList()
        {
            foreach (var item in ItemManager.GetItemDefinitions())
            {
                var itemModDeployable = item?.GetComponent<ItemModDeployable>();
                if (itemModDeployable == null) continue;

                var resourcePath = itemModDeployable.entityPrefab.resourcePath;
                var name = SplitPrefabName(resourcePath);
                if (!PrefabList.ContainsKey(name)) PrefabList.Add(name, item.displayName.english);
            }
        }

        private static string BuildScannerMessage(string scannerMessage, Item item)
        {
            var sb = new StringBuilder();

            sb.Append(scannerMessage);
            sb.Append(" > ");
            sb.Append("<color=" + GetColorOfItem(item) + ">");
            sb.Append(item.info.displayName.english);
            sb.Append("</color>");
            if (item.amount > 1)
            {
                sb.Append(" ");
                sb.Append("x");
                sb.Append(item.amount);
            }
            sb.Append("\n");
            return sb.ToString();
        }

        private static string BuildRarityScannerMessage(string scannerMessage, List<Item> itemList)
        {
            var none = 0;
            var common = 0;
            var uncommon = 0;
            var rare = 0;
            var veryRare = 0;

            foreach (var item in itemList)
            {
                if (item?.info == null) continue;
                switch ((int)item?.info?.rarity)
                {
                    case 0:
                        none += 1;
                        break;
                    case 1:
                        common += 1;
                        break;
                    case 2:
                        uncommon += 1;
                        break;
                    case 3:
                        rare += 1;
                        break;
                    case 4:
                        veryRare += 1;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            var sb = new StringBuilder();
            sb.Append(scannerMessage);

            if (veryRare > 0)
            {
                var item = veryRare > 1 ? "Items" : "Item";
                sb.Append(" > ");
                sb.Append("<color=" + ColorVeryRare + ">");
                sb.Append("Very Rare " + item);
                sb.Append("</color>");
                sb.Append(" ");
                sb.Append("x");
                sb.Append(veryRare);
                sb.Append("\n");
            }

            if (rare > 0)
            {
                var item = rare > 1 ? "Items" : "Item";
                sb.Append(" > ");
                sb.Append("<color=" + ColorRare + ">");
                sb.Append("Rare " + item);
                sb.Append("</color>");
                sb.Append(" ");
                sb.Append("x");
                sb.Append(rare);
                sb.Append("\n");
            }

            if (uncommon > 0)
            {
                var item = uncommon > 1 ? "Items" : "Item";
                sb.Append(" > ");
                sb.Append("<color=" + ColorUncommon + ">");
                sb.Append("Uncommon " + item);
                sb.Append("</color>");
                sb.Append(" ");
                sb.Append("x");
                sb.Append(uncommon);
                sb.Append("\n");
            }

            if (common > 0)
            {
                var item = common > 1 ? "Items" : "Item";
                sb.Append(" > ");
                sb.Append("<color=" + ColorCommon + ">");
                sb.Append("Common " + item);
                sb.Append("</color>");
                sb.Append(" ");
                sb.Append("x");
                sb.Append(common);
                sb.Append("\n");
            }

            if (none > 0)
            {
                var item = none > 1 ? "Items" : "Item";
                sb.Append(" > ");
                sb.Append("<color=" + ColorNone + ">");
                sb.Append("None " + item);
                sb.Append("</color>");
                sb.Append(" ");
                sb.Append("x");
                sb.Append(none);
                sb.Append("\n");
            }


            return sb.ToString();
        }

        private void SendInfoMessage(BasePlayer player, string message)
        {
            player?.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(3f, () => player?.SendConsoleCommand("gametip.hidegametip"));
        }

        private static string GetColorOfItem(Item item)
        {
            var color = ColorNone;
            if (item?.info == null) return color;
            switch ((int)item?.info?.rarity)
            {
                case 0:
                    color = ColorNone;
                    break;
                case 1:
                    color = ColorCommon;
                    break;
                case 2:
                    color = ColorUncommon;
                    break;
                case 3:
                    color = ColorRare;
                    break;
                case 4:
                    color = ColorVeryRare;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            return color;
        }

        private static BaseEntity GetEntityScanned(BasePlayer player, InputState input) // Thanks to ignignokt84
        {
            // Get player position + 1.6y as eye-level
            var playerEyes = player.transform.position + new Vector3(0f, 1.6f, 0f);
            var direction = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            // Raycast in the direction the player is looking
            var hits = Physics.RaycastAll(playerEyes, direction);
            // Maximum distance when player can use loot scanner
            var closest = 10000f;
            var target = Vector3.zero;
            Collider collider = null;
            // Find the closest hit
            foreach (var hit in hits)
            {
                var name = hit.collider.gameObject.name;
                if (hit.collider.gameObject.layer == 18 || hit.collider.gameObject.layer == 29) // Skip Triggers layer
                    continue;
                // Ignore zones, meshes, and landmark nobuild hits
                if (name.StartsWith("Zone Manager") ||
                    name == "prevent_building" ||
                    name == "preventBuilding" ||
                    name == "Mesh")
                    continue;

                if (!(hit.distance < closest)) continue;
                closest = hit.distance;
                target = hit.point;
                collider = hit.collider;
            }
            if (target == Vector3.zero) return null;
            var entity = collider?.gameObject.ToBaseEntity();
            return entity;
        }

        private static string GetPrefabName(BaseNetworkable entity)
        {
            var name = SplitPrefabName(entity.gameObject.name).Replace("static", "deployed");

            return PrefabList.ContainsKey(name) ? PrefabList[name] : BeautifyPrefabName(entity.ShortPrefabName);
        }

        private static string SplitPrefabName(string prefabName)
        {
            return prefabName.Split('/').Last();
        }

        private static string BeautifyPrefabName(string str)
        {
            str = Regex.Replace(str, "[0-9\\(\\)]", string.Empty).Replace('_', ' ').Replace('-', ' ').Replace('.', ' ').Replace("static", string.Empty);
            var textInfo = new CultureInfo("en-US").TextInfo;
            return textInfo.ToTitleCase(str).Trim();
        }

        private static string BeautifyPermissionName(string str)
        {
            return str.Split('.').Last();
        }

        #endregion

        #region UI
        private class UI
        {
            private static CuiElementContainer CreateElementContainer(string name, string color, string anchorMin, string anchorMax, string parent = "Overlay")
            {
                var elementContainer = new CuiElementContainer()
                {
                    new CuiElement()
                    {
                        Name = name,
                        Parent = parent,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = color,
                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = anchorMin,
                                AnchorMax = anchorMax
                            }
                        }
                    },
                };
                return elementContainer;
            }

            private static void CreateLabel(string name, string parent, ref CuiElementContainer container, TextAnchor textAnchor, string text, string color, int fontSize, string anchorMin, string anchorMax)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = text,
                            Align = textAnchor,
                            FontSize = fontSize,
                            Font = "droidsansmono.ttf",
                            Color = color

                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = anchorMin,
                            AnchorMax = anchorMax
                        }
                    }
                });
            }

            private static void CreateElement(string name, string parent, ref CuiElementContainer container, string anchorMin, string anchorMax, string color)
            {
                container.Add(new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = color
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = anchorMin,
                            AnchorMax = anchorMax
                        }
                    }
                });
            }

            public static CuiElementContainer ConstructScanUi(BasePlayer player, string title, string message)
            {
                var height = 0.66f;
                var anchorX = "0.78" + " " + (PositionY - height);
                var anchorY = "0.990" + " " + PositionY;

                if (SideOfGui.Equals("Left", StringComparison.InvariantCultureIgnoreCase))
                {
                    anchorX = "0.01" + " " + (PositionY - height);
                    anchorY = "0.22" + " " + PositionY;
                }

                var container = CreateElementContainer(player.UserIDString, "1 1 1 0.0", anchorX, anchorY);
                CreateElement("uiLabel", player.UserIDString, ref container, "0.05 0.05", "0.95 0.95", "0.3 0.3 0.3 0.0");
                CreateElement("uiLabelPadded", "uiLabel", ref container, "0.05 0.05", "0.95 0.95", "0 0 0 0");
                CreateLabel("uiLabelText", "uiLabelPadded", ref container, TextAnchor.MiddleCenter, title, "0.98 0.996 0.98 1", 14, "0 0.80", "1 1");
                CreateLabel("uiLabelText", "uiLabelPadded", ref container, TextAnchor.UpperLeft, message, "0.98 0.996 0.98 1", 11, "0 0", "1 0.80");

                return container;
            }
        }
        #endregion

        #region Config
        private new void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();

            Config["Color None"] = "white";
            Config["Color Common"] = "#56c63f";
            Config["Color Uncommon"] = "#0097ff";
            Config["Color Rare"] = "#b675f3";
            Config["Color Very Rare"] = "#ffbf17";

            Config["Define the side of GUI (Left - Right)"] = "Right";
            Config["Define the y position of GUI"] = 0.98f;

            Config["Hide Airdrop's content"] = false;
            Config["Hide CH47 crate content"] = false;
            Config["Hide heli and Bradley crate content"] = false;
            Config["Hide common lootable container"] = false;
            Config["Hide player name"] = true;
            Config["Hide corpse name"] = false;

            SaveConfig();
        }
        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"InfoMessage", "Press {0} while looking through the binoculars to scan a container."},
                {"TwoPermissions", "You're only allowed to use Loot Scanner on {0}'s and {1}'s loot containers."},
                {"OnePermission", "You're only allowed to use Loot Scanner on {0}'s loot containers."},
                {"NoPermissions", "You're not allowed to use Loot Scanner."},
                {"EmptyStorage", "{0} is empty."},
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"InfoMessage", "Appuyez sur {0} tout en regardant à travers les jumelles pour scanner un conteneur."},
                {"TwoPermissions", "Vous n'êtes autorisé à utiliser Loot Scanner que sur les conteneurs de butin de {0} et {1}."},
                {"OnePermission", "Vous n'êtes autorisé à utiliser Loot Scanner que sur les conteneurs de butin de {0}."},
                {"NoPermissions", "Vous n'êtes pas autorisé à utiliser Loot Scanner."},
                {"EmptyStorage", "{0} est vide."},
            }, this, "fr");
        }

        #endregion
    }
}

// --- End of file: LootScanner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-snitch ---
// --- Original File Path: L/LootSnitch/LootSnitch.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Loot Snitch", "August", "1.0.7")]
    [Description("Players with permission get messaged who/when a player is looting their body.")]
    
    public class LootSnitch : RustPlugin
    {
        #region Initialization
        
        private const string PermUse = "lootsnitch.use";
        private const string PermOverride = "lootsnitch.override";
        private const string PermMangage = "lootsnitch.manage";
        private bool IsEnabled = true;
        private int Cooldown = 60;

        void Init()
        {
            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermOverride, this);
            permission.RegisterPermission(PermMangage, this);
            
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
            }
            catch { }

            if (data == null)
                data = new Data();

            if (Cooldown <= 0)
                data.Cooldowns.Clear();
        }
        
        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Snitch Message"] = "{0} just looted your body!",

                ["Enabled"] = "Loot Snitcher is now Enabled.",
                ["Disabled"] = "Loot Snitcher is now Disabled.",
                
                ["NoPermission"] = "Error: No Permission",
                ["Syntax"] = "Error: Syntax",
                
                ["NewCooldown"] = "The cooldown is now {0} seconds."
            }, this);
        }
        #endregion
        
        #region Cooldown (by nivex)
        private static Data data = new Data();
        private class Data
        {
            public Dictionary<string, long> Cooldowns = new Dictionary<string, long>();
            
        }
        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);
        public uint GetUnixTimestamp() => (uint)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
        #endregion
        
        #region Hooks and Commands
        private void OnLootEntityEnd(BasePlayer player, LootableCorpse corpse)
        {
            var target = BasePlayer.FindByID(corpse.playerSteamID);

            if (!target)
            {
                return;
            }
            
            if (permission.UserHasPermission(player.UserIDString, PermOverride))
            {
                return;
            }
            if (!permission.UserHasPermission(target.UserIDString, PermUse))
            {
                return;
            }

            if (Cooldown > 0 && data.Cooldowns.ContainsKey(player.UserIDString))
            {
                if (data.Cooldowns[target.UserIDString] - GetUnixTimestamp() > 0)
                {
                    return;
                }
                data.Cooldowns.Remove(target.UserIDString);
            }

            if (Cooldown > 0 && !data.Cooldowns.ContainsKey(target.UserIDString))
            {
                data.Cooldowns.Add(target.UserIDString, GetUnixTimestamp() + Cooldown);
            }
            
            target.ChatMessage(Lang("Snitch Message", target.UserIDString, player.displayName));
        }

        [ChatCommand("snitch")]
        private void SnitchChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermMangage))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "toggle":
                    
                    ToggleSnitch(player);
                    break;
                
                default:
                    int cooldown;

                    if (int.TryParse(args[0], out cooldown))
                    {
                        Cooldown = cooldown;
                        player.ChatMessage(Lang("NewCooldown", player.UserIDString, Cooldown));
                        break;
                    }

                    player.ChatMessage(Lang("Syntax", player.UserIDString));;
                    return;
            }
        }
        #endregion
        
        #region Helpers and Functions
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void ToggleSnitch(BasePlayer player)
        {
            if (IsEnabled == true)
            {
                player.ChatMessage(Lang("Disabled", player.UserIDString));
                Unsubscribe(nameof(OnLootEntityEnd));
            }
            else
            {
                player.ChatMessage(Lang("Enabled", player.UserIDString));
                Subscribe(nameof(OnLootEntityEnd));
            }
            IsEnabled = !IsEnabled;
        }       
        #endregion

    }
}

// --- End of file: LootSnitch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/landlord ---
// --- Original File Path: L/LandLord/LandLord.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LandLord", "bravoavo", "1.0.17")]
    [Description("Take control of the map")]
    class LandLord : RustPlugin
    {
        [PluginReference] Plugin ZoneManager, Clans;

        ConfigData configData;
        private DynamicConfigFile data;

        //Constant initialization
        readonly uint bannerprefabid = 3188315846;
        readonly float size = 146.33f;
        readonly bool debug = true;
        int notrespassgather = 1;
        int onlyconnected = 1;
        int gatherratio = 3;
        int graycircles = 1;
        readonly string zonenameprefix = "LandlordZone";
        readonly string datafile_name = "Landlord.data";
        private const string permUse = "landlord.admin";
        readonly Color[] colorArray = new Color[] { Color.black, Color.white, Color.red, Color.blue, Color.green, Color.yellow, Color.cyan, Color.gray, new Color32(255, 157, 0, 1) };
        private Color colors;
        public Dictionary<string, int> currentsettings = new Dictionary<string, int>();
        public Dictionary<ulong, HashSet<int[]>> flagi = new Dictionary<ulong, HashSet<int[]>>();
        public Dictionary<ulong, List<string>> quadrants = new Dictionary<ulong, List<string>>();
        public Dictionary<string, Vector3> poles = new Dictionary<string, Vector3>();
        public Dictionary<ulong, int> gatherMultiplier = new Dictionary<ulong, int>();
        public Dictionary<string, ulong> teamList = new Dictionary<string, ulong>();

        public Dictionary<string, MapMarkerGenericRadius> allmarkers = new Dictionary<string, MapMarkerGenericRadius>();
        public Dictionary<string, List<MapMarkerGenericRadius>> flagmarkers = new Dictionary<string, List<MapMarkerGenericRadius>>();

        public List<string> blockedItemsList { get; set; } = new List<string>();

        #region Localization
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LordStatus"] = "<color=orange>LANDLORD:</color> Grounds seized: {0} TeamID is: {1}",
                ["UsageAdmin"] = "<color=orange>LANDLORD:</color> Usage:\n /lordadmin notrespass enable|disable \n " +
                "/lordadmin onlyconnected enable|disable " +
                "\n /lordadmin graycircles enable|disable " +
                "\n /lordadmin gatherratio [from 1 to 1000] " +
                "\n /lordadmin settings " +
                "\n /lordadmin blockitem [item] \n /lordadmin unblockitem [item] \n /lordadmin blockitemlist \n /lordadmin blockitemclear",
                ["NoPermission"] = "<color=orange>LANDLORD:</color> You do not have the permissions to use this command.",
                ["LordStatusZero"] = "<color=orange>LANDLORD:</color> Grounds seized: 0 TeamID is: {0}",
                ["TeamClearSuccess"] = "<color=orange>LANDLORD:</color> Team clear: Success!",
                ["BlockedItemsEditSuccess"] = "<color=orange>LANDLORD:</color> Blocked items list edit: Success!",
                ["BlockedItemsClearSuccess"] = "<color=orange>LANDLORD:</color> Blocked items clear: Success!",
                ["BlockedItems"] = "<color=orange>LANDLORD:</color> Blocked Items: {0}",
                ["HaveNoTeam"] = "<color=orange>LANDLORD:</color> You are have no team!",
                ["CellHasPole"] = "<color=orange>LANDLORD:</color> This map cell already has a pole! Destroy it before build a new one",
                ["SettingsChanged"] = "<color=orange>LANDLORD:</color> Settings changed!",
                ["CurrentSettings"] = "<color=orange>LANDLORD:</color> notrespass {0} \n onlyconnected {1} \n graycircles {2} \n gatherratio {3}",
                ["NotrespassStatus"] = "<color=orange>LANDLORD:</color> notrespass mode is {0} to switch use /lordadmin notrespass enable|disable ",
                ["OnlyconnectedStatus"] = "<color=orange>LANDLORD:</color> onlyconected mode is {0}",
                ["GatherratioStatus"] = "<color=orange>LANDLORD:</color> Gatherratio set to {0}",
                ["GraycirclesStatus"] = "<color=orange>LANDLORD:</color> graycircles is {0}",
                ["CellNotConnected"] = "<color=orange>LANDLORD:</color> The cell you try to capture not connected to another yours",
                ["CellCaptured"] = "<color=orange>LANDLORD:</color> You deploy pole! Your gather rate increased!",
                ["CellCapturedGlobal"] = "<color=orange>LANDLORD:</color> Player {0} has captured the cell {1}",
                ["CellFreedGlobal"] = "<color=orange>LANDLORD:</color> The cell {0} has freed up"
            }, this);
        }

        #endregion Localization

        #region ZoneInitialization
        private void MyZonesInit()
        {
            float mapsize = TerrainMeta.Size.x;
            int counter = 0;
            int j = 100;
            var celltogenerate = Math.Pow(Math.Round(mapsize / size), 2);
            Puts("Generating the cell map. Nubmer to generate is " + celltogenerate);
            for (var x = -mapsize / 2 + size / 2; x <= mapsize / 2; x = x + size)
            {
                int i = 100;
                for (var z = -mapsize / 2 + size / 2; z <= mapsize / 2; z = z + size)
                {
                    string[] array = new string[] { "name", zonenameprefix + j + i, "size", "146.3 500 146.3", "location", x + " 0 " + z };
                    ZoneManager.Call("EraseZone", j + i.ToString().PadLeft(3, '0'));
                    ZoneManager.Call("CreateOrUpdateZone", j + i.ToString().PadLeft(3, '0'), array);
                    i++;
                    counter++;
                }
                j++;
                Puts("Generating...> " + counter + " of " + celltogenerate);
            }
            Puts("Generating is done!");
            var InitFile = Interface.Oxide.DataFileSystem.GetFile(datafile_name);

            InitFile.Save();

        }

        #endregion

        #region InitPlugin
        private void OnServerInitialized()
        {
            permission.RegisterPermission(permUse, this);
            if (Clans == null || !Clans.IsLoaded)
            {
                PrintError("Missing plugin dependency Clans: https://umod.org/plugins/clans");
                return;
            }
            if (ZoneManager != null && ZoneManager.IsLoaded)
            {
                if (!Interface.Oxide.DataFileSystem.ExistsDatafile(datafile_name))
                {
                    MyZonesInit();
                }
            }
            else
            {
                PrintError("Missing plugin dependency Zone Manager: https://umod.org/plugins/zone-manager");
                return;
            }
            if (Interface.Oxide.DataFileSystem.ExistsDatafile(datafile_name))
            {
                data = Interface.Oxide.DataFileSystem.GetDatafile(datafile_name);
            }
            LoadData();
        }

        #endregion

        #region PlayerInit

        void OnPlayerSleepEnded(BasePlayer player)
        {
            foreach (var quadrat in quadrants)
            {
                foreach (var zone in quadrat.Value)
                {
                    if (currentsettings["graycircles"] == 1) allmarkers[zone].SendUpdate();
                    flagmarkers[zone][0].SendUpdate();
                    flagmarkers[zone][1].SendUpdate();
                    flagmarkers[zone][2].SendUpdate();

                }
            }
            if (!flagi.ContainsKey(player.userID)) GenarateFlag(player.userID);
        }

        private void GenarateFlag(ulong playerId)
        {
            if (flagi.Count < 900)
            {
                System.Random rnd = new System.Random();
                int[] colorsArrayTmp;
                flagi.Add(playerId, new HashSet<int[]>());
                do
                {
                    int color1 = rnd.Next(0, 8);
                    int color2 = rnd.Next(0, 8);
                    int color3 = rnd.Next(0, 8);
                    colorsArrayTmp = new int[] { color1, color2, color3 };
                } while (!flagi[playerId].Add(colorsArrayTmp));
            }
        }

        #endregion

        #region OxideHooks

        void OnEntityKill(BaseEntity entity)
        {
            if (entity.prefabID == bannerprefabid)
            {
                if (debug) Puts("Entity 'Banner on Pole' killed - Prefab ID is " + entity.prefabID.ToString() + " Location " + entity.ServerPosition);

                var zoneid = poles.FirstOrDefault(x => x.Value == entity.ServerPosition).Key;
                if (zoneid != null)
                {
                    if (debug) Puts("ZoneID id " + zoneid);
                    if (currentsettings["graycircles"] == 1)
                    {
                        DeleteMarkerFromMap(allmarkers[zoneid]);
                        allmarkers.Remove(zoneid);
                    }
                    DeleteMarkerFromMap(flagmarkers[zoneid][0]);
                    DeleteMarkerFromMap(flagmarkers[zoneid][1]);
                    DeleteMarkerFromMap(flagmarkers[zoneid][2]);
                    flagmarkers.Remove(zoneid);
                    ulong teampid = 0;
                    foreach (KeyValuePair<ulong, List<string>> playerid in quadrants)
                    {
                        var match = playerid.Value.FirstOrDefault(stringToCheck => stringToCheck.Contains(zoneid));
                        if (match != null)
                        {
                            teampid = playerid.Key;
                            break;
                        }
                    }
                    if (teampid == 0)
                    {
                        if (debug) Puts("Can't found cell owner");
                        return;
                    }
                    quadrants[teampid].Remove(zoneid);
                    if (quadrants[teampid].Count == 0) quadrants.Remove(teampid);
                    poles.Remove(zoneid);
                    if (gatherMultiplier.ContainsKey(teampid))
                    {
                        if (gatherMultiplier[teampid] > 0) gatherMultiplier[teampid]--;
                    }
                    PrintToChat(Lang("CellFreedGlobal", "1", GetGrid(entity.ServerPosition)));
                    SaveData();
                }
                else if (debug) Puts("Zone id not found");
            }
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            ulong teampid;
            string playerClan = Clans.Call<string>("GetClanOf", player);
            if (playerClan != null && teamList.ContainsKey(playerClan)) teampid = teamList[playerClan];
            else teampid = player.userID;
            string[] zids = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
            var entity = go.ToBaseEntity();
            if (entity.prefabID == bannerprefabid && zids.Length > 0)
            {
                string curentZoneId = GetLordZoneId(zids);
                if (debug) Puts("Banner entity was built. Prefab ID is " + entity.prefabID + " zone ID is " + curentZoneId);
                if (!quadrants.ContainsKey(teampid))
                {
                    quadrants.Add(teampid, new List<string>());
                    quadrants[teampid].Add(curentZoneId);
                }
                else
                {
                    var match = quadrants[teampid].FirstOrDefault(stringToCheck => stringToCheck.Contains(curentZoneId));
                    if (match != null) return;
                    else
                    {
                        quadrants[teampid].Add(curentZoneId);
                    }
                }
                if (!gatherMultiplier.ContainsKey(teampid))
                {
                    gatherMultiplier.Add(teampid, 1);
                }
                else
                {
                    gatherMultiplier[teampid]++;
                }
                poles.Add(curentZoneId, entity.ServerPosition);
                if (debug) Puts("Server position " + entity.ServerPosition.ToString());
                var zonelocation = (Vector3)ZoneManager.Call("GetZoneLocation", curentZoneId);
                if (currentsettings["graycircles"] == 1) SpawnMarkerOnMap(zonelocation, curentZoneId);
                SpawnFlag(zonelocation, curentZoneId, teampid);
                player.ChatMessage(Lang("CellCaptured", player.UserIDString));
                PrintToChat(Lang("CellCapturedGlobal", player.UserIDString, player.displayName, GetGrid(entity.ServerPosition)));
                SaveData();
            }
            else if (debug) Puts("After build - Not found zone ID or prefab!");
        }

        void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            ulong teampid;
            string playerClan = Clans.Call<string>("GetClanOf", player);
            if (playerClan != null && teamList.ContainsKey(playerClan)) teampid = teamList[playerClan];
            else teampid = player.userID;
            // Check if the player has at least a captured cell and if not skip further processing 
            if (!quadrants.ContainsKey(teampid)) return;
            string[] zids = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
            string match = null;

            foreach (ItemAmount item in collectible.itemList)
            {
                if (blockedItemsList.Contains(item.itemDef.shortname)) return;

                if (currentsettings["notrespassgather"] == 1)
                {
                    if (zids.Length > 0)
                    {
                        if (debug) Puts("Looking for exact landlord zone");
                        string curentZoneId = GetLordZoneId(zids);
                        if (curentZoneId == "None")
                        {
                            if (debug) Puts("Landlord zone not found!");
                            return;
                        }
                        match = quadrants[teampid].FirstOrDefault(stringToCheck => stringToCheck.Contains(curentZoneId));
                        if (!poles.ContainsKey(curentZoneId) || (poles.ContainsKey(curentZoneId) && match != null))
                        {
                            if (gatherMultiplier.ContainsKey(teampid))
                            {
                                if (gatherMultiplier[teampid] > 0)
                                {
                                    float multiplier = (float)gatherMultiplier[teampid] * currentsettings["gatherratio"] / 100;
                                    item.amount = (int)(item.amount + 1 + item.amount * multiplier);
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (gatherMultiplier.ContainsKey(teampid))
                    {
                        if (gatherMultiplier[teampid] > 0)
                        {
                            float multiplier = (float)gatherMultiplier[teampid] * currentsettings["gatherratio"] / 100;
                            item.amount = (int)(item.amount + 1 + item.amount * multiplier);
                        }
                    }
                }
            }
        }

        object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ulong teampid;
            if (blockedItemsList.Contains(item.info.shortname)) return null;

            string[] zids = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
            string match = null;
            string playerClan = Clans.Call<string>("GetClanOf", player);
            if (playerClan != null && teamList.ContainsKey(playerClan)) teampid = teamList[playerClan];
            else teampid = player.userID;
            // Check if the player has at least a captured cell and if not skip further processing 
            if (!quadrants.ContainsKey(teampid)) return null;
            if (debug) Puts("Dispenser. Start amount is " + item.amount);
            if (currentsettings["notrespassgather"] == 1)
            {
                if (zids.Length > 0)
                {
                    if (debug) Puts("Looking for exact landlord zone");
                    string curentZoneId = GetLordZoneId(zids);
                    if (curentZoneId == "None")
                    {
                        if (debug) Puts("Landlord zone not found!");
                        return null;
                    }

                    match = quadrants[teampid].FirstOrDefault(stringToCheck => stringToCheck.Contains(curentZoneId));

                    if (!poles.ContainsKey(curentZoneId) || (poles.ContainsKey(curentZoneId) && match != null))
                    {
                        if (gatherMultiplier.ContainsKey(teampid))
                        {
                            if (gatherMultiplier[teampid] > 0)
                            {
                                float multiplier = (float)gatherMultiplier[teampid] * currentsettings["gatherratio"] / 100;
                                if (debug) Puts("Multiplier is " + multiplier);
                                item.amount = (int)(item.amount + 5 + item.amount * multiplier);
                            }
                        }
                    }
                }

            }
            else
            {
                if (gatherMultiplier.ContainsKey(teampid))
                {
                    if (gatherMultiplier[teampid] > 0)
                    {
                        float multiplier = (float)gatherMultiplier[teampid] * currentsettings["gatherratio"] / 100;
                        if (debug) Puts("Multiplier is " + multiplier);
                        item.amount = (int)(item.amount + 5 + item.amount * multiplier);
                    }
                }
            }

            return null;
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            ulong teampid;
            string playerClan = Clans.Call<string>("GetClanOf", player);
            if (playerClan != null && teamList.ContainsKey(playerClan)) teampid = teamList[playerClan];
            else teampid = player.userID;
            string[] zids = (string[])ZoneManager.Call("GetPlayerZoneIDs", player);
            if (prefab.prefabID == bannerprefabid && zids.Length > 0)
            {
                if (debug) Puts("Looking for exact landlord zone");
                string curentZoneId = GetLordZoneId(zids);
                if (curentZoneId == "None")
                {
                    if (debug) Puts("Error! Landlord zone not found!");
                    return false;
                }
                if (currentsettings["onlyconnected"] == 1 && quadrants.ContainsKey(teampid))
                {
                    if (!CheckConnected(curentZoneId, teampid))
                    {
                        player.ChatMessage(Lang("CellNotConnected", player.UserIDString));
                        if (debug) Puts("Zone not connected to another!");
                        return false;
                    }
                }

                if (poles.ContainsKey(curentZoneId))
                {
                    player.ChatMessage(Lang("CellHasPole", player.UserIDString));
                    if (debug) Puts("Zone has a pole already!");
                    return false;
                }
                if (debug) Puts("Banner building allowed. Prefab ID is " + prefab.prefabID + " zone ID is " + curentZoneId);
                return null;
            }
            else if (debug) Puts("Before build - Not found zone ID or banner prefab.");
            return null;
        }

        private void OnClanCreate(string tag)
        {
            timer.Once(1f, () =>
            {
                JObject clan = GetClan(tag);
                if (debug) Puts("Clan owner " + clan["owner"]);
                teamList.Add(tag, (ulong)clan["owner"]);
                SaveData();
            });
        }

        private void OnClanDestroy(string tag)
        {
            if (debug) Puts("Existing clan destroyed");
            teamList.Remove(tag);
            SaveData();
        }

        #endregion

        #region MarkersAndMap

        private void DeleteMarkerFromMap(MapMarkerGenericRadius marker)
        {
            marker.Kill();
            marker.SendUpdate();
        }

        private void SpawnMarkerOnMap(Vector3 position, string curentZoneId)
        {
            int mapsize = (int)TerrainMeta.Size.x;
            colors = Color.black;
            float zoneradius = (100000f / mapsize) * 0.02f;
            float markeralpha = 0.5f;
            var mapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position) as MapMarkerGenericRadius;
            mapMarker.alpha = markeralpha;
            mapMarker.color1 = colors;
            mapMarker.color2 = colors;
            mapMarker.radius = (float)Math.Round(zoneradius, 2);
            mapMarker.Spawn();
            mapMarker.SendUpdate();

            if (!allmarkers.ContainsKey(curentZoneId))
            {
                allmarkers.Add(curentZoneId, mapMarker);
            }
            else
            {
                if (debug) Puts("Marker already in dictionary");
            }
        }

        private void SpawnFlag(Vector3 position, string curentZoneId, ulong playerId)
        {
            if (!flagi.ContainsKey(playerId)) GenarateFlag(playerId);
            HashSet<int[]> array = flagi[playerId];
            List<int> listik = new List<int>();
            foreach (var ids in array)
            {
                listik.Add(ids[0]);
                listik.Add(ids[1]);
                listik.Add(ids[2]);
            }
            float mapsize = TerrainMeta.Size.x;
            Color color1 = colorArray[listik[0]];
            Color color2 = colorArray[listik[1]];
            Color color3 = colorArray[listik[2]];
            Vector3 position1;
            Vector3 position2;
            Vector3 position3;
            float zoneradius = (100000f / mapsize) * 0.002f;
            float markeralpha = 0.7f;
            position1.x = position.x - 63; position1.y = position.y; position1.z = position.z - 63;
            position2.x = position.x - 48; position2.y = position.y; position2.z = position.z - 63;
            position3.x = position.x - 33; position3.y = position.y; position3.z = position.z - 63;
            var mapMarker1 = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position1) as MapMarkerGenericRadius;
            mapMarker1.alpha = markeralpha; mapMarker1.color1 = color1; mapMarker1.color2 = color1; mapMarker1.radius = (float)Math.Round(zoneradius, 2);
            var mapMarker2 = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position2) as MapMarkerGenericRadius;
            mapMarker2.alpha = markeralpha; mapMarker2.color1 = color2; mapMarker2.color2 = color2; mapMarker2.radius = (float)Math.Round(zoneradius, 2);
            var mapMarker3 = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position3) as MapMarkerGenericRadius;
            mapMarker3.alpha = markeralpha; mapMarker3.color1 = color3; mapMarker3.color2 = color3; mapMarker3.radius = (float)Math.Round(zoneradius, 2);

            mapMarker1.Spawn(); mapMarker1.SendUpdate();
            mapMarker2.Spawn(); mapMarker2.SendUpdate();
            mapMarker3.Spawn(); mapMarker3.SendUpdate();

            if (!flagmarkers.ContainsKey(curentZoneId))
            {
                flagmarkers.Add(curentZoneId, new List<MapMarkerGenericRadius>());
                flagmarkers[curentZoneId].Add(mapMarker1);
                flagmarkers[curentZoneId].Add(mapMarker2);
                flagmarkers[curentZoneId].Add(mapMarker3);
            }
            else
            {
                if (debug) Puts("Flag marker already in dictionary");
            }
        }

        #endregion

        #region DataManagement

        class ConfigData
        {
            public Dictionary<ulong, HashSet<int[]>> FlagiData = new Dictionary<ulong, HashSet<int[]>>();
            public Dictionary<ulong, List<string>> QuadrantsData = new Dictionary<ulong, List<string>>();
            public Dictionary<string, Vector3> PolesLocationData = new Dictionary<string, Vector3>();
            public Dictionary<ulong, int> GatherRateData = new Dictionary<ulong, int>();
            public Dictionary<string, ulong> TeamListData = new Dictionary<string, ulong>();
            public Dictionary<string, int> LandlordSettings = new Dictionary<string, int>();
            public List<string> BlockedItems = new List<string>();
        }

        private void LoadData()
        {
            quadrants.Clear();
            flagi.Clear();
            gatherMultiplier.Clear();
            teamList.Clear();
            poles.Clear();
            currentsettings.Clear();
            blockedItemsList.Clear();
            try
            {
                if (debug) Puts("A try to use existing configuration");
                configData = data.ReadObject<ConfigData>();
                quadrants = configData.QuadrantsData;
                blockedItemsList = configData.BlockedItems;
                flagi = configData.FlagiData;
                gatherMultiplier = configData.GatherRateData;
                teamList = configData.TeamListData;
                poles = configData.PolesLocationData;
                currentsettings = configData.LandlordSettings;
                if (quadrants.Count > 0)
                {
                    foreach (var marker in UnityEngine.Object.FindObjectsOfType<MapMarkerGenericRadius>())
                    {
                        DeleteMarkerFromMap(marker);
                    }
                    foreach (var quadrat in quadrants)
                    {
                        foreach (var zone in quadrat.Value)
                        {
                            var zonelocation = (Vector3)ZoneManager.Call("GetZoneLocation", zone);
                            if (currentsettings["graycircles"] == 1) SpawnMarkerOnMap(zonelocation, zone);
                            SpawnFlag(zonelocation, zone, quadrat.Key);
                        }
                    }

                }
                if (!currentsettings.ContainsKey("notrespassgather"))
                {
                    currentsettings["notrespassgather"] = notrespassgather;
                }
                if (!currentsettings.ContainsKey("onlyconnected"))
                {
                    currentsettings["onlyconnected"] = onlyconnected;
                }
                if (!currentsettings.ContainsKey("graycircles"))
                {
                    currentsettings["graycircles"] = graycircles;
                }
                if (!currentsettings.ContainsKey("gatherratio"))
                {
                    currentsettings["gatherratio"] = gatherratio;
                }
                if (debug) Puts("Existing configuration found and loaded");
            }
            catch
            {
                if (debug) Puts("Existing configuration not found. A new configuration creating.");
                configData = new ConfigData();
                quadrants = configData.QuadrantsData;
                flagi = configData.FlagiData;
                gatherMultiplier = configData.GatherRateData;
                teamList = configData.TeamListData;
                poles = configData.PolesLocationData;
                currentsettings = configData.LandlordSettings;
                currentsettings["notrespassgather"] = notrespassgather;
                currentsettings["onlyconnected"] = onlyconnected;
                currentsettings["graycircles"] = graycircles;
                currentsettings["gatherratio"] = gatherratio;
            }
            SaveData();
        }

        private void SaveData()
        {
            data = Interface.Oxide.DataFileSystem.GetDatafile(datafile_name);
            data.WriteObject(configData);
        }

        private JObject GetClan(string tag)
        {
            JObject clan = (JObject)Clans.Call("GetClan", tag);
            if (clan == null)
            {
                if (debug) Puts("Clan " + tag + " not found");
                return null;
            }
            return clan;
        }

        #endregion

        #region ChatCommands

        [ChatCommand("lord")]
        private void CmdChatLordStats(BasePlayer player, string command, string[] args)
        {
            ulong teampid;
            string playerClan = Clans.Call<string>("GetClanOf", player);
            if (playerClan != null && teamList.ContainsKey(playerClan)) teampid = teamList[playerClan];
            else teampid = player.userID;

            if (gatherMultiplier.ContainsKey(teampid) && gatherMultiplier[teampid] > 0)
            {
                player.ChatMessage(Lang("LordStatus", player.UserIDString, gatherMultiplier[teampid].ToString(), teampid.ToString()));
            }
            else player.ChatMessage(Lang("LordStatusZero", player.UserIDString, teampid.ToString()));
        }

        [ChatCommand("lordadmin")]
        void LordAdminCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }
            if (debug) Puts("Args lenght " + args.Length);
            string cstatus, tstatus, gcstatus;
            if (args.Length > 0)
            {
                switch (args[0])
                {
                    default:
                        player.ChatMessage(Lang("UsageAdmin", player.UserIDString));
                        break;
                    case "nt":
                    case "notrespass":
                        if (args.Length == 2)
                        {
                            if (args[1] == "enable") currentsettings["notrespassgather"] = 1;
                            if (args[1] == "disable") currentsettings["notrespassgather"] = 0;
                        }
                        tstatus = (currentsettings["notrespassgather"] == 1) ? "Enabled" : "Disabled";
                        player.ChatMessage(Lang("NotrespassStatus", player.UserIDString, tstatus));
                        SaveData();
                        break;
                    case "oc":
                    case "onlyconnected":
                        if (args.Length == 2)
                        {
                            if (args[1] == "enable") currentsettings["onlyconnected"] = 1;
                            if (args[1] == "disable") currentsettings["onlyconnected"] = 0;
                        }
                        cstatus = (currentsettings["onlyconnected"] == 1) ? "Enabled" : "Disabled";
                        player.ChatMessage(Lang("OnlyconnectedStatus", player.UserIDString, cstatus));
                        SaveData();
                        break;
                    case "gc":
                    case "graycircles":
                        if (args.Length == 2)
                        {
                            if (args[1] == "enable" && currentsettings["graycircles"] == 0)
                            {
                                foreach (var quadrat in quadrants)
                                {
                                    foreach (var zoneid in quadrat.Value)
                                    {
                                        var zonelocation = (Vector3)ZoneManager.Call("GetZoneLocation", zoneid);
                                        if (debug) Puts("Spawn marker" + zoneid);
                                        SpawnMarkerOnMap(zonelocation, zoneid);
                                    }
                                }
                                currentsettings["graycircles"] = 1;
                            }
                            if (args[1] == "disable" && currentsettings["graycircles"] == 1)
                            {
                                foreach (var quadrat in quadrants)
                                {
                                    foreach (var zoneid in quadrat.Value)
                                    {
                                        if (debug) Puts("Delete marker" + zoneid);
                                        DeleteMarkerFromMap(allmarkers[zoneid]);
                                        allmarkers.Remove(zoneid);
                                    }
                                }
                                currentsettings["graycircles"] = 0;
                            }
                        }
                        gcstatus = (currentsettings["graycircles"] == 1) ? "Enabled" : "Disabled";
                        player.ChatMessage(Lang("GraycirclesStatus", player.UserIDString, gcstatus));
                        SaveData();
                        break;
                    case "gr":
                    case "gatherratio":
                        if (args.Length == 2)
                        {
                            int grtmp = Convert.ToInt32(args[1]);
                            if (grtmp > 0 && grtmp < 1001)
                            {
                                currentsettings["gatherratio"] = grtmp;
                            }
                            else
                            {
                                player.ChatMessage(Lang("UsageAdmin", player.UserIDString));
                            }
                        }
                        player.ChatMessage(Lang("GatherratioStatus", player.UserIDString, args[1]));
                        SaveData();
                        break;
                    case "st":
                    case "settings":
                        player.ChatMessage(Lang("CurrentSettings", player.UserIDString, tstatus = (currentsettings["notrespassgather"] == 1) ? "Enabled" : "Disabled", cstatus = (currentsettings["onlyconnected"] == 1) ? "Enabled" : "Disabled", gcstatus = (currentsettings["graycircles"] == 1) ? "Enabled" : "Disabled", currentsettings["gatherratio"]));
                        SaveData();
                        break;
                    case "blk":
                    case "blockitem":
                        if (args.Length == 2)
                        {
                            string item = Convert.ToString(args[1]);
                            blockedItemsList.Add(item);
                        }
                        SaveData();
                        player.ChatMessage(Lang("BlockedItemsEditSuccess", player.UserIDString));
                        break;
                    case "unblk":
                    case "unblockitem":
                        if (args.Length == 2)
                        {
                            string item = Convert.ToString(args[1]);
                            blockedItemsList.Remove(item);
                        }
                        SaveData();
                        player.ChatMessage(Lang("BlockedItemsEditSuccess", player.UserIDString));
                        break;
                    case "blklist":
                    case "blockitemlist":
                        string itemlist = string.Join(", ", blockedItemsList);
                        if (debug) Puts("Items: " + itemlist);
                        player.ChatMessage(Lang("BlockedItems", player.UserIDString, itemlist));
                        break;
                    case "blkclr":
                    case "blockitemclear":
                        blockedItemsList.Clear();
                        SaveData();
                        player.ChatMessage(Lang("BlockedItemsClearSuccess", player.UserIDString));
                        break;
                }
                return;
            }
            else
            {
                player.ChatMessage(Lang("UsageAdmin", player.UserIDString));
                return;
            }
        }

        #endregion

        #region Helpers

        private string GetLordZoneId(string[] zids)
        {
            string czd = "None";
            for (int i = 0; i < zids.Length; i++)
            {
                string zonename = (string)ZoneManager.Call("GetZoneName", zids[i]);
                if (debug) Puts("Found zone " + zonename);
                if (zonename.StartsWith(zonenameprefix))
                {
                    if (debug) Puts("Landlord zone found");
                    czd = zids[i];
                }
            }
            return czd;
        }

        private static string GetGrid(Vector3 position)
        {
            var chars = new string[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "AA", "AB", "AC", "AD", "AE", "AF", "AG", "AH", "AI", "AJ", "AK", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT", "AU", "AV", "AW", "AX", "AY", "AZ" };

            const float block = 146;

            float size = ConVar.Server.worldsize;
            float offset = size / 2;

            float xpos = position.x + offset;
            float zpos = position.z + offset;

            int maxgrid = (int)(size / block);

            float xcoord = Mathf.Clamp(xpos / block, 0, maxgrid - 1);
            float zcoord = Mathf.Clamp(maxgrid - (zpos / block), 0, maxgrid - 1);

            string pos = string.Concat(chars[(int)xcoord], (int)zcoord);

            return pos;
        }

        private bool CheckConnected(string zid, ulong teampid)
        {
            ulong uzid = Convert.ToUInt64(zid);
            ulong[] uzids = new ulong[] { uzid + 1, uzid - 1, uzid + 1000, uzid - 1000 };
            for (int i = 0; i < uzids.Length; i++)
            {
                var match = quadrants[teampid].FirstOrDefault(stringToCheck => stringToCheck.Contains(Convert.ToString(uzids[i])));
                if (match != null) return true;
            }
            return false;
        }

        #endregion
    }
}


// --- End of file: LandLord.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limited-ladders ---
// --- Original File Path: L/LimitedLadders/LimitedLadders.cs ---

namespace Oxide.Plugins
{
    [Info("LimitedLadders", "redBDGR", "2.0.1")]
    [Description("Prevents the placement of ladders where building is blocked")]

    class LimitedLadders : RustPlugin
    {
        private void Unload()
        {
            AllowBuildingBypass(true);
        }

        private void OnServerInitialized()
        {
            AllowBuildingBypass(false);
        }

        private void AllowBuildingBypass(bool allow)
        {
            Construction con = PrefabAttribute.server.Find<Construction>(2150203378);
            if (con)
                con.canBypassBuildingPermission = allow;
        }
    }
}


// --- End of file: LimitedLadders.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/lights-on ---
// --- Original File Path: L/LightsOn/LightsOn.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading.Tasks;
using System;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Lights On", "mspeedie", "1.6.19")]
	[Description("Toggle lights on/off either as configured or by name")]
	// big thank you to FastBurn for helping fix Fluid Splitters and adding Flashing Lights and Siren Lights
	public class LightsOn : CovalencePlugin
	//RustPlugin
	{

		//[PluginReference] Plugin ZoneManager;
		const string perm_lightson     = "lightson.allowed";
		private bool InitialPassNight  = true;
		private bool NightToggleactive = false;
		private bool nightcross24      = false;
		private bool config_changed    = false;
		private Timer Nighttimer;
		private Timer Alwaystimer;
		private Timer Devicetimer;

		// strings to compare to check object names
		const string auto_turret_name        = "autoturret";
		const string bbq_name                = "bbq";
		const string campfire_name           = "campfire";
		const string cctv_name               = "cctv";
		const string ceilinglight_name       = "ceilinglight";
		const string chineselantern_name     = "chineselantern";
		const string cursedcauldron_name     = "cursedcauldron";
		const string deluxe_lightstring_name = "xmas.lightstring.advanced";
		const string elevator_name           = "elevator";
		const string fireplace_name          = "fireplace";
		const string fluidswitch_name        = "fluidswitch";
		const string fogmachine_name         = "fogmachine";
		const string furnace_large_name      = "furnace.large";
		const string furnace_name            = "furnace";
		const string hatcandle_name          = "hat.candle";
		const string hatminer_name           = "hat.miner";
		const string heater_name             = "electrical.heater";
		const string hobobarrel_name         = "hobobarrel";
		const string igniter_name            = "igniter";
		const string jackolanternangry_name  = "jackolantern.angry";
		const string jackolanternhappy_name  = "jackolantern.happy";
		const string lantern_name            = "lantern";
		const string largecandleset_name     = "largecandleset";
		const string mixingtable_name        = "mixingtable";
		const string reactivetarget_name     = "reactivetarget";
		const string rfbroadcaster_name      = "rfbroadcaster";
		const string rfreceiver_name         = "rfreceiver";
		const string sam_site_name           = "samsite";
		const string refinerysmall_name      = "small_refinery";
		const string searchlight_name        = "searchlight";
		const string simplelight_name        = "simplelight";
		const string skullfirepit_name       = "skull_fire_pit";
		const string smallcandleset_name     = "smallcandleset";
		const string smallrefinery_name      = "small.oil.refinery";
		const string smart_alarm_name        = "smart.alarm";
		const string smart_switch_name       = "smart.switch";
		const string snowmachine_name        = "snowmachine";
		const string storage_monitor_name    = "storagemonitor";
		const string telephone_name          = "telephone";
		const string teslacoil_name          = "teslacoil";
		const string tunalight_name          = "tunalight";
		const string vehiclelift_name        = "modularcarlift";
		const string water_purifier_name     = "poweredwaterpurifier";
		const string waterpump_name          = "water.pump";
        const string flasherlight_name       = "electric.flasherlight";
        const string sirenlight_name         = "electric.sirenlight";
        const string spookyspeaker_name      = "spookyspeaker";
        const string strobelight_name        = "strobelight";
		const string sign_name               = "sign";

		#region Configuration

		private Configuration config;

		public class Configuration
		{
			// True means turn them on
			[JsonProperty(PropertyName = "Hats do not use fuel (true/false)")]
			public bool Hats { get; set; } = true;

			//[JsonProperty(PropertyName = "Auto Turrets (true/false)")]
			//public bool AutoTurrets { get; set; } = false;

			[JsonProperty(PropertyName = "BBQs (true/false)")]
			public bool BBQs { get; set; } = false;

			[JsonProperty(PropertyName = "Campfires (true/false)")]
			public bool Campfires { get; set; } = false;

			[JsonProperty(PropertyName = "Candles (true/false)")]
			public bool Candles { get; set; } = true;

			[JsonProperty(PropertyName = "Cauldrons (true/false)")]
			public bool Cauldrons { get; set; } = false;

			[JsonProperty(PropertyName = "CCTVs (true/false)")]
			public bool CCTVs { get; set; } = true;

			[JsonProperty(PropertyName = "Ceiling Lights (true/false)")]
			public bool CeilingLights { get; set; } = true;

			[JsonProperty(PropertyName = "Deluxe Light Strings (true/false)")]
			public bool Deluxe_lightstrings { get; set; } = true;

			[JsonProperty(PropertyName = "Elevators (true/false)")]
			public bool Elevators { get; set; } = true;

			[JsonProperty(PropertyName = "Fire Pits (true/false)")]
			public bool FirePits { get; set; } = false;

			[JsonProperty(PropertyName = "Fireplaces (true/false)")]
			public bool Fireplaces { get; set; } = true;

            [JsonProperty(PropertyName = "Flasher Lights (true/false)")]
            public bool FlasherLights { get; set; } = false;

			[JsonProperty(PropertyName = "FluidSwitches (true/false)")]
			public bool FluidSwitches { get; set; } = true;

			[JsonProperty(PropertyName = "Fog Machines (true/false)")]
			public bool Fog_Machines { get; set; } = true;

			[JsonProperty(PropertyName = "Furnaces (true/false)")]
			public bool Furnaces { get; set; } = false;

			[JsonProperty(PropertyName = "Hobo Barrels (true/false)")]
			public bool HoboBarrels { get; set; } = true;

			[JsonProperty(PropertyName = "Heaters (true/false)")]
			public bool Heaters { get; set; } = true;

			[JsonProperty(PropertyName = "Igniters (true/false)")]
			public bool Igniters { get; set; } = true;

			[JsonProperty(PropertyName = "Lanterns (true/false)")]
			public bool Lanterns { get; set; } = true;

			[JsonProperty(PropertyName = "Mixing Tables (true/false)")]
			public bool MixingTables { get; set; } = true;

			[JsonProperty(PropertyName = "Reactive Targets (true/false)")]
			public bool ReactiveTargets { get; set; } = false;

			[JsonProperty(PropertyName = "RF Broadcasters (true/false)")]
			public bool RFBroadcasters { get; set; } = false;

			[JsonProperty(PropertyName = "RF Receivers (true/false)")]
			public bool RFReceivers { get; set; } = false;

			[JsonProperty(PropertyName = "Refineries (true/false)")]
			public bool Refineries { get; set; } = false;

			[JsonProperty(PropertyName = "SAM Sites (true/false)")]
			public bool SamSites { get; set; } = true;

			[JsonProperty(PropertyName = "Search Lights (true/false)")]
			public bool SearchLights { get; set; } = true;

			[JsonProperty(PropertyName = "Signs (true/false)")]
			public bool Signs { get; set; } = true;

            [JsonProperty(PropertyName = "Simple Lights (true/false)")]
            public bool SimpleLights { get; set; } = false;

            [JsonProperty(PropertyName = "Siren Lights (true/false)")]
            public bool SirenLights { get; set; } = false;

            [JsonProperty(PropertyName = "Smart Alarms (true/false)")]
            public bool SmartAlarms { get; set; } = false;

            [JsonProperty(PropertyName = "Smart Switches (true/false)")]
            public bool SmartSwitches { get; set; } = false;

			[JsonProperty(PropertyName = "SnowMachines (true/false)")]
			public bool Snow_Machines { get; set; } = true;

            [JsonProperty(PropertyName = "SpookySpeakers (true/false)")]
			public bool Speakers { get; set; } = false;

            [JsonProperty(PropertyName = "Storage Monitor (true/false)")]
            public bool StorageMonitors { get; set; } = false;

			[JsonProperty(PropertyName = "Strobe Lights (true/false)")]
			public bool StrobeLights { get; set; } = false;

			[JsonProperty(PropertyName = "Telephones (true/false)")]
			public bool Telephones { get; set; } = false;

			//[JsonProperty(PropertyName = "Tesla Coils (true/false)")]
			//public bool TeslaCoils { get; set; } = false;

			[JsonProperty(PropertyName = "VehicleLifts (true/false)")]
			public bool VehicleLifts { get; set; } = true;

			[JsonProperty(PropertyName = "Water Pumps (true/false)")]
			public bool WaterPumps { get; set; } = true;

			[JsonProperty(PropertyName = "Water Purifier s(true/false)")]
			public bool WaterPurifiers { get; set; } = true;

			[JsonProperty(PropertyName = "Protect BBQs (true/false)")]
			public bool ProtectBBQs { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Campfires (true/false)")]
			public bool ProtectCampfires { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Cauldrons (true/false)")]
			public bool ProtectCauldrons { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Fire Pits (true/false)")]
			public bool ProtectFirePits { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Fireplaces (true/false)")]
			public bool ProtectFireplaces { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Furnaces (true/false)")]
			public bool ProtectFurnaces { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Hobo Barrels (true/false)")]
			public bool ProtectHoboBarrels { get; set; } = false;

			[JsonProperty(PropertyName = "Protect Mixing Tables (true/false)")]
			public bool ProtectMixingTables { get; set; } = true;

			[JsonProperty(PropertyName = "Protect Refineries (true/false)")]
			public bool ProtectRefineries { get; set; } = true;

			[JsonProperty(PropertyName = "Devices Always On (true/false)")]
			public bool DevicesAlwaysOn { get; set; } = true;

			[JsonProperty(PropertyName = "Always On (true/false)")]
			public bool AlwaysOn { get; set; } = false;

			[JsonProperty(PropertyName = "Night Toggle (true/false)")]
			public bool NightToggle { get; set; } = true;

			[JsonProperty(PropertyName = "Console Output (true/false)")]
			public bool ConsoleMsg { get; set; } = true;

			// this is checked more frequently to get the lights on/off closer to the time the operator sets
			[JsonProperty(PropertyName = "Night Toggle Check Frequency (in seconds)")]
			public int NightCheckFrequency { get; set; } = 30;

			// these less frequent checks as most entities will be on when placed
			[JsonProperty(PropertyName = "Always On Check Frequency (in seconds)")]
			public int AlwaysCheckFrequency { get; set; } = 300;

			// these less frequent checks as most devices will be on when placed
			[JsonProperty(PropertyName = "Device Check Frequency (in seconds)")]
			public int DeviceCheckFrequency { get; set; } = 300;


			[JsonProperty(PropertyName = "Dusk Time (HH in a 24 hour clock)")]
			public float DuskTime { get; set; } = 17.5f;

			[JsonProperty(PropertyName = "Dawn Time (HH in a 24 hour clock)")]
			public float DawnTime { get; set; } = 09.0f;

//			[JsonProperty(PropertyName = "Use Zone Manager Plugin")]
//			public bool UseZoneManagerPlugin { get; set; } = false;

			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
		}

		protected override void LoadDefaultConfig() => config = new Configuration();

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
				{
					throw new JsonException();
				}

				if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
				{
					LogWarning("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}
			}
			catch
			{
				LogWarning($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
			CheckConfig();
		}

		protected override void SaveConfig()
		{
			LogWarning($"Configuration changes saved to {Name}.json");
			Config.WriteObject(config, true);
		}

		#endregion Configuration

		string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["bad check frequency"] = "Check frequency must be between 10 and 600",
				["bad check frequency2"] = "Check frequency must be between 60 and 6000",
				["bad prefab"] = "Bad Prefab Name, not found in devices or lights: ",
				["bad dusk time"] = "Dusk time must be between 0 and 24",
				["bad dawn time"] = "Dawn time must be between 0 and 24",
				["dawn=dusk"] = "Dawn can't be the same value as dusk",
				["dawn"] = "Lights going off.  Next lights on at ",
				["default"] = "Loading default config for LightsOn",
				["dusk"] = "Lights coming on.  Ending at ",
				["lights off"] = "Lights Off",
				["lights on"] = "Lights On",
				["nopermission"] = "You do not have permission to use that command.",
				["one or the other"] = "Please select one (and only one) of Always On or Night Toggle",
				["prefix"] = "LightsOn: ",
				["state"] = "unknown state: please use on or off",
				["syntax"] = "syntax: Lights State (on/off) Optional: prefabshortname (part of the prefab name) to change their state, use all to force all lights' state",
				["zone"] = "Zone Manager requested but not found loaded"
			}, this);
		}

		protected void CheckConfig()
		{
			config_changed = false;

			// check data is ok because people can make mistakes
			if (config.AlwaysOn == config.NightToggle)
			{
				Puts(Lang("Please pick one or the other of Always On or Night Toggle, setting to Always on"));
				config.NightToggle = false;
				config.AlwaysOn = true;
				config_changed = true;
			}
			if (config.AlwaysOn && config.DevicesAlwaysOn == false)
			{
				Puts(Lang("if Always on then Devices need to be always be on"));
				config.DevicesAlwaysOn = true;
				config_changed = true;
			}

			if (config.DuskTime < 0f || config.DuskTime > 24f)
			{
				Puts(Lang("bad dusk time (outside of 0 to 24)"));
				config.DuskTime = 17f;
				config_changed = true;
			}
			if (config.DawnTime < 0f || config.DawnTime > 24f)
			{
				Puts(Lang("bad dawn time (outside of 0 to 24)"));
				config.DawnTime = 9f;
				config_changed = true;
			}
			if (config.DawnTime == config.DuskTime)
			{
				Puts(Lang("dawn can't be equal to dusk"));
				config.DawnTime = 9f;
				config.DuskTime = 17f;
				config_changed = true;
			}
			if (config.NightCheckFrequency < 10 || config.NightCheckFrequency > 600)
			{
				Puts(Lang("bad Night check frequency (too small or too large)"));
				config.NightCheckFrequency = 30;
				config_changed = true;
			}

			if (config.AlwaysCheckFrequency < 60 || config.AlwaysCheckFrequency > 6000)
			{
				Puts(Lang("bad Always on check frequency (too small or too large)"));
				config.AlwaysCheckFrequency = 300;
				config_changed = true;
			}

			if (config.DeviceCheckFrequency < 60 || config.DeviceCheckFrequency > 6000)
			{
				Puts(Lang("bad Device check frequency (too small or too large)"));
				config.DeviceCheckFrequency = 300;
				config_changed = true;
			}

			// determine correct light timing logic
			if  (config.DuskTime > config.DawnTime)
				nightcross24 = true;
			else
				nightcross24 = false;

			if (config.AlwaysOn)
			{
				// start timer to lights always on
				Alwaystimer = timer.Once(config.AlwaysCheckFrequency, AlwaysTimerProcess);
			}
			else if (config.NightToggle)
			{
				// start timer to toggle lights based on time
				InitialPassNight = true;
				Nighttimer = timer.Once(config.NightCheckFrequency, NightTimerProcess);
			}

			if (config.DevicesAlwaysOn)
			{
				// start timer to toggle devices
				Devicetimer = timer.Once(config.DeviceCheckFrequency, DeviceTimerProcess);
			}

			if (config_changed)
				SaveConfig();
		}

		private void OnServerInitialized()
		{
			if (!permission.PermissionExists(perm_lightson))
				permission.RegisterPermission(perm_lightson,this);
			// give the server time to spawn entities
			//if (config.AutoTurrets)         timer.Once(60, () => {AutoTurretChangePower(); return;});
			if (config.CCTVs)               timer.Once(60, () => {CCTVChangePower(); return;});
			if (config.Elevators)           timer.Once(60, () => {ElevatorChangePower(); return;});
			if (config.FlasherLights)       timer.Once(60, () => {FlasherLightChangePower(); return;});
			if (config.FluidSwitches)       timer.Once(60, () => {FluidSwitchChangePower(); return;});
			if (config.Heaters)             timer.Once(60, () => {HeaterChangePower(); return;});
			if (config.Igniters)            timer.Once(60, () => {IgniterChangePower(); return;});
			if (config.Deluxe_lightstrings) timer.Once(60, () => {LightStringChangePower(); return;});
			if (config.RFBroadcasters)      timer.Once(60, () => {RFBroadcasterChangePower(); return;});
			if (config.RFReceivers)         timer.Once(60, () => {RFReceiverChangePower(); return;});
			if (config.ReactiveTargets)     timer.Once(60, () => {ReactiveTargetChangePower(); return;});
			if (config.SamSites)            timer.Once(60, () => {SamSiteChangePower(); return;});
			if (config.SearchLights)        timer.Once(60, () => {SearchLightChangePower(); return;});
			if (config.Signs)               timer.Once(60, () => {SignChangePower(); return;});
			if (config.SirenLights)         timer.Once(60, () => {SirenLightChangePower(); return;});
			if (config.SmartAlarms)         timer.Once(60, () => {SmartAlarmChangePower(); return;});
			if (config.SmartSwitches)       timer.Once(60, () => {SmartSwitchChangePower(); return;});
			if (config.StorageMonitors)     timer.Once(60, () => {StorageMonitorChangePower(); return;});
			if (config.Telephones)          timer.Once(60, () => {TelephoneChangePower(); return;});
			//if (config.TeslaCoils)          timer.Once(60, () => {TeslaCoilChangePower(); return;});
			if (config.VehicleLifts)        timer.Once(60, () => {VehicleLiftChangePower(); return;});
			if (config.WaterPumps)          timer.Once(60, () => {WaterPumpChangePower(); return;});
			if (config.WaterPurifiers)      timer.Once(60, () => {WaterPurifierChangePower(); return;});
		}

		string CleanedName(string prefabName)
		{
			if (string.IsNullOrEmpty(prefabName))
				return prefabName;

			string CleanedString = prefabName;
			int clean_loc = CleanedString.IndexOf("deployed");
			if (clean_loc > 1)
				CleanedString = CleanedString.Remove(clean_loc-1);
			clean_loc = CleanedString.IndexOf("static");
			if (clean_loc > 1)
				CleanedString = CleanedString.Remove(clean_loc-1);

			return CleanedString;
		}

		bool IsOvenPrefabName(string prefabName)
		{
			if (furnace_name.Contains(prefabName))
				return true;
			else if (furnace_large_name.Contains(prefabName))
				return true;
			else if (bbq_name.Contains(prefabName))
				return true;
			else if (campfire_name.Contains(prefabName))
				return true;
			else if (chineselantern_name.Contains(prefabName))
				return true;
			else if (fireplace_name.Contains(prefabName))
				return true;
			else if (hobobarrel_name.Contains(prefabName))
				return true;
			else if (lantern_name.Contains(prefabName))
				return true;
			else if (tunalight_name.Contains(prefabName))
				return true;
			else if (cursedcauldron_name.Contains(prefabName))
				return true;
			else if (skullfirepit_name.Contains(prefabName))
				return true;
			else if (refinerysmall_name.Contains(prefabName))
				return true;
			else if (smallrefinery_name.Contains(prefabName))
				return true;
			else if (jackolanternangry_name.Contains(prefabName))
				return true;
			else if (jackolanternhappy_name.Contains(prefabName))
				return true;
			else
				return false;
		}

		bool IsLightToggle(string prefabName)
		{
			if (lantern_name.Contains(prefabName))
				return true;
			else if (tunalight_name.Contains(prefabName))
				return true;
			else if (chineselantern_name.Contains(prefabName))
				return true;
			//else if (jackolanternangry_name.Contains(prefabName))
			//	return true;
			//else if (jackolanternhappy_name.Contains(prefabName))
			//	return true;
			//else if (largecandleset_name.Contains(prefabName))
			//	return true;
			//else if (smallcandleset_name.Contains(prefabName))
			//	return true;
			//else if (searchlight_name.Contains(prefabName))
			//	return true;
			//else if (simplelight_name.Contains(prefabName))
			//	return true;
			else
				return false;
		}

		bool IsLightPrefabName(string prefabName)
		{
			if (lantern_name.Contains(prefabName))
				return true;
			else if (tunalight_name.Contains(prefabName))
				return true;
			else if (ceilinglight_name.Contains(prefabName))
				return true;
            else if (deluxe_lightstring_name.Contains(prefabName))
                return true;
            else if (flasherlight_name.Contains(prefabName))
                return true;
            else if (jackolanternangry_name.Contains(prefabName))
				return true;
			else if (jackolanternhappy_name.Contains(prefabName))
				return true;
			else if (chineselantern_name.Contains(prefabName))
				return true;
			else if (largecandleset_name.Contains(prefabName))
				return true;
			else if (smallcandleset_name.Contains(prefabName))
				return true;
			else if (searchlight_name.Contains(prefabName))
				return true;
            else if (simplelight_name.Contains(prefabName))
                return true;
            else if (sirenlight_name.Contains(prefabName))
                return true;
            else
                return false;
		}

		bool IsHatPrefabName(string prefabName)
		{
			// this uses only internal names so do not need the Contains logic
			switch (prefabName)
			{
				case hatminer_name: 	return true;
				case hatcandle_name:	return true;
				default:				return false;
			}
		}

		bool IsDevicePrefabName(string prefabName)
		{
			if (auto_turret_name.Contains(prefabName))
				return true;
			else if (fogmachine_name.Contains(prefabName))
				return true;
			else if (snowmachine_name.Contains(prefabName))
				return true;
			else if (strobelight_name.Contains(prefabName))
				return true;
			else if (spookyspeaker_name.Contains(prefabName))
				return true;
			else if (heater_name.Contains(prefabName))
				return true;
			else if (elevator_name.Contains(prefabName))
				return true;
			else if (water_purifier_name.Contains(prefabName))
				return true;
			else if (waterpump_name.Contains(prefabName))
				return true;
			else if (fluidswitch_name.Contains(prefabName))
				return true;
			else if (cctv_name.Contains(prefabName))
				return true;
			else if (sign_name.Contains(prefabName))
				return true;
			else if (smart_alarm_name.Contains(prefabName))
				return true;
			else if (smart_switch_name.Contains(prefabName))
				return true;
			else if (storage_monitor_name.Contains(prefabName))
				return true;
			else if (mixingtable_name.Contains(prefabName))
				return true;
			else if (reactivetarget_name.Contains(prefabName))
				return true;
			else if (rfbroadcaster_name.Contains(prefabName))
				return true;
			else if (rfreceiver_name.Contains(prefabName))
				return true;
			else if (sam_site_name.Contains(prefabName))
				return true;
			else if (telephone_name.Contains(prefabName))
				return true;
			else if (teslacoil_name.Contains(prefabName))
				return true;
			else if (SignShortPrefabName(prefabName))
				return true;
			else
				return false;
		}

		bool CanCookShortPrefabName(string prefabName)
		{
			if (furnace_name.Contains(prefabName))
				return true;
			else if (furnace_large_name.Contains(prefabName))
				return true;
			else if (campfire_name.Contains(prefabName))
				return true;
			else if (bbq_name.Contains(prefabName))
				return true;
			else if (fireplace_name.Contains(prefabName))
				return true;
			else if (refinerysmall_name.Contains(prefabName))
				return true;
			else if (smallrefinery_name.Contains(prefabName))
				return true;
			else if (skullfirepit_name.Contains(prefabName))
				return true;
			else if (hobobarrel_name.Contains(prefabName))
				return true;
			else if (cursedcauldron_name.Contains(prefabName))
				return true;
			else
				return false;
		}

		bool ProtectShortPrefabName(string prefabName)
		{
			switch (CleanedName(prefabName))
			{
				case "bbq":					return config.ProtectBBQs;
				case "campfire":			return config.ProtectCampfires;
				case "cursedcauldron":		return config.ProtectCauldrons;
				case "fireplace":			return config.ProtectFireplaces;
				case "furnace":				return config.ProtectFurnaces;
				case "furnace.large":		return config.ProtectFurnaces;
				case "hobobarrel":			return config.ProtectHoboBarrels;
				case "refinery_small":		return config.ProtectRefineries;
				case "small.oil.refinery":	return config.ProtectRefineries;
				case "skull_fire_pit":		return config.ProtectFirePits;
				case "mixingtable":         return config.ProtectMixingTables;
				default:
				{
					return false;
				}
			}
		}

		bool SignShortPrefabName(string prefabName)
		{
			switch (CleanedName(prefabName))
			{
                case "sign.neon.xl.animated":      return config.Signs;
                case "sign.neon.125x215.animated": return config.Signs;
                case "sign.neon.xl":               return config.Signs;
                case "sign.neon.125x215":          return config.Signs;
                case "sign.neon.125x125":          return config.Signs;

				default:
				{
					return false;
				}
			}
		}

		bool ProcessShortPrefabName(string prefabName)
		{
			switch (CleanedName(prefabName))
			{
			 //case "autoturret":				    return config.AutoTurrets;
			 case "bbq":					    return config.BBQs;
			 case "campfire":			        return config.Campfires;
			 case "cctv":                       return config.CCTVs;
			 case "ceilinglight":		        return config.CeilingLights;
			 case "chineselantern":		        return config.Lanterns;
			 case "cursedcauldron":		        return config.Cauldrons;
			 case "electric.flasherlight":      return config.FlasherLights;
			 case "electric.sirenlight":        return config.SirenLights;
			 case "electrical.heater":          return config.Heaters;
			 case "elevator":                   return config.Elevators;
			 case "fireplace":			        return config.Fireplaces;
			 case "fluidswitch":                return config.FluidSwitches;
			 case "fogmachine":			        return config.Fog_Machines;
			 case "furnace":				    return config.Furnaces;
			 case "furnace.large":		        return config.Furnaces;
			 case "hat.candle": 			    return config.Hats;
			 case "hat.miner": 			        return config.Hats;
			 case "hobobarrel":			        return config.HoboBarrels;
			 case "igniter":                    return config.Igniters;
			 case "jackolantern.angry":	        return config.Lanterns;
			 case "jackolantern.happy":	        return config.Lanterns;
			 case "lantern":				    return config.Lanterns;
			 case "largecandleset":		        return config.Candles;
			 case "mixingtable":			    return config.MixingTables;
			 case "poweredwaterpurifier":       return config.WaterPurifiers;
			 case "reactivetarget":		        return config.ReactiveTargets;
			 case "rfbroadcaster":		        return config.RFBroadcasters;
			 case "rfreceiver":					return config.RFReceivers;
			 case "refinery_small":		        return config.Refineries;
			 case "samsite":					return config.SamSites;
			 case "searchlight":			    return config.SearchLights;
			 case "sign.neon.125x125":          return config.Signs;
			 case "sign.neon.125x215":          return config.Signs;
			 case "sign.neon.125x215.animated": return config.Signs;
			 case "sign.neon.xl":               return config.Signs;
			 case "sign.neon.xl.animated":      return config.Signs;
			 case "simplelight":                return config.SimpleLights;
			 case "skull_fire_pit":		        return config.FirePits;
			 case "small.oil.refinery":	        return config.Refineries;
			 case "smallcandleset":		        return config.Candles;
			 case "smart.alarm":                return config.SmartAlarms;
			 case "smart.switch":               return config.SmartSwitches;
			 case "snowmachine":			    return config.Snow_Machines;
			 case "spookyspeaker":		        return config.Speakers;
			 case "storagemonitor":             return config.StorageMonitors;
			 case "strobelight":			    return config.StrobeLights;
			 case "telephone":					return config.Telephones;
			 //case "teslacoil":					return config.TeslaCoils;
			 case "tunalight":			        return config.Lanterns;
			 case "vehiclelift":                return config.VehicleLifts;
			 case "water.pump":                 return config.WaterPumps;
			 case "xmas.lightstring.advanced":  return config.Deluxe_lightstrings;
			 default:
				{
					return false;
				}
			}
		}

		private void AlwaysTimerProcess()
		{
			if (config.AlwaysOn)
			{
				ProcessLights(true, "all");
				// submit for the next pass
				Alwaystimer = timer.Once(config.AlwaysCheckFrequency, AlwaysTimerProcess);
			}
		}

		private void DeviceTimerProcess()
		{
			if (config.DevicesAlwaysOn)
			{
				ProcessDevices(true, "all");
				// submit for the next pass
				Devicetimer = timer.Once(config.DeviceCheckFrequency, DeviceTimerProcess);
			}
		}

		private void NightTimerProcess()
		{
			if (config.NightToggle)
			{
				ProcessNight();
				// clear the Inital flag as we now accurately know the state
				InitialPassNight = false;
				// submit for the next pass
				Nighttimer = timer.Once(config.NightCheckFrequency, NightTimerProcess);
			}
		}

		private void ProcessNight()
		{
			var gtime = TOD_Sky.Instance.Cycle.Hour;
			if ((nightcross24 == false && gtime >= config.DuskTime && gtime < config.DawnTime) ||
				(nightcross24 && ((gtime >= config.DuskTime && gtime < 24) || gtime < config.DawnTime))
				&& (!NightToggleactive || InitialPassNight))
			{
				NightToggleactive = true;
				ProcessLights(true,"all");
				if (!config.DevicesAlwaysOn)
					ProcessDevices(true,"all");
				if (config.ConsoleMsg)
					Puts(Lang("dusk") + config.DawnTime);
			}
			else if ((nightcross24 == false &&  gtime >= config.DawnTime) ||
					(nightcross24 && (gtime <  config.DuskTime && gtime >= config.DawnTime))
					&& (NightToggleactive || InitialPassNight))
			{
				NightToggleactive = false;
				ProcessLights(false,"all");
				if (!config.DevicesAlwaysOn)
					ProcessDevices(false,"all");
				if (config.ConsoleMsg)
					Puts(Lang("dawn") + config.DuskTime);
			}
		}

		private void ProcessLights(bool state, string prefabName)
		{
			if (prefabName == "all" || IsOvenPrefabName(prefabName))
			{
				//if (string.IsNullOrEmpty(prefabName) || prefabName == "all")
				//	Puts("all lights");
				//else
				//	Puts("turing on: " + prefabName);

				BaseOven[] ovens = BaseNetworkable.serverEntities.OfType<BaseOven>().ToArray() as BaseOven[];

				foreach (BaseOven oven in ovens)
				{
					if (oven == null || oven.IsDestroyed || oven.IsOn() == state)
						continue;
					else if (state == false && ProtectShortPrefabName(prefabName))
						continue;

					// not super efficient find a better way
					if (prefabName != "all" &&
					   (furnace_name.Contains(prefabName) ||
					    furnace_large_name.Contains(prefabName) ||
					    lantern_name.Contains(prefabName) ||
					    tunalight_name.Contains(prefabName) ||
					    jackolanternangry_name.Contains(prefabName) ||
					    jackolanternhappy_name.Contains(prefabName) ||
					    campfire_name.Contains(prefabName) ||
					    fireplace_name.Contains(prefabName) ||
					    bbq_name.Contains(prefabName) ||
					    cursedcauldron_name.Contains(prefabName) ||
					    skullfirepit_name.Contains(prefabName) ||
					    hobobarrel_name.Contains(prefabName) ||
					    smallrefinery_name.Contains(prefabName) ||
					    refinerysmall_name.Contains(prefabName) ||
					    chineselantern_name.Contains(prefabName)
						))
					{
						oven.SetFlag(BaseEntity.Flags.On, state);
					}
					// not super efficient find a better way
					else
					{
						string oven_name = CleanedName(oven.ShortPrefabName).ToLower();

						if ((config.Furnaces    && (furnace_name.Contains(oven_name) ||
													 furnace_large_name.Contains(oven_name))) ||
							 (config.Lanterns    && (lantern_name.Contains(oven_name) ||
													 chineselantern_name.Contains(oven_name) ||
													 tunalight_name.Contains(oven_name) ||
													 jackolanternangry_name.Contains(oven_name) ||
													 jackolanternhappy_name.Contains(oven_name))) ||
							 (config.Campfires   && campfire_name.Contains(oven_name)) ||
							 (config.Fireplaces  && fireplace_name.Contains(oven_name)) ||
							 (config.BBQs        && bbq_name.Contains(oven_name)) ||
							 (config.Cauldrons   && cursedcauldron_name.Contains(oven_name)) ||
							 (config.FirePits    && skullfirepit_name.Contains(oven_name)) ||
							 (config.HoboBarrels && hobobarrel_name.Contains(oven_name)) ||
							 (config.Refineries  && (smallrefinery_name.Contains(oven_name) || refinerysmall_name.Contains(oven_name)))
							)
						{
							oven.SetFlag(BaseEntity.Flags.On, state);
						}
					}
				}
			}

			if ((prefabName == "all" || searchlight_name.Contains(prefabName)) && config.SearchLights)
			{
				SearchLight[] searchlights = BaseNetworkable.serverEntities.OfType<SearchLight>().ToArray() as SearchLight[];

				foreach (SearchLight search_light in searchlights)
				{
					if (search_light != null && !search_light.IsDestroyed && search_light.IsOn() != state && search_light.inputs[0].connectedTo.Get() == null)
					{
						if (state == false)
							search_light.UpdateHasPower(0, 1);
						else
							search_light.UpdateHasPower(200, 1);
						search_light.SetFlag(BaseEntity.Flags.On, state);
					}
				}
			}

			if ((prefabName == "all" || (largecandleset_name.Contains(prefabName) || smallcandleset_name.Contains(prefabName))) && config.Candles)
			{
				Candle[] candles = BaseNetworkable.serverEntities.OfType<Candle>().ToArray() as Candle[];
				foreach (Candle candle in candles)
				{
					if (candle != null && !candle.IsDestroyed && candle.IsOn() != state)
					{
						candle.SetFlag(BaseEntity.Flags.On, state);
						candle.lifeTimeSeconds = 999999f;
						candle.burnRate = 0.0f;
					}
				}
			}

			if ((prefabName == "all" || ceilinglight_name.Contains(prefabName)) && config.CeilingLights)
			{
				CeilingLight[] ceilinglights = BaseNetworkable.serverEntities.OfType<CeilingLight>().ToArray() as CeilingLight[];

				foreach (CeilingLight ceiling_light in ceilinglights)
				{
					if (ceiling_light != null && !ceiling_light.IsDestroyed && ceiling_light.IsOn() != state)
					{
						ceiling_light.SetFlag(BaseEntity.Flags.On, state);
					}
				}
			}

			if ((prefabName == "all" || deluxe_lightstring_name.Contains(prefabName)) && config.Deluxe_lightstrings)
			{
				AdvancedChristmasLights[] lightstring = BaseNetworkable.serverEntities.OfType<AdvancedChristmasLights>().ToArray() as AdvancedChristmasLights[];

				foreach (AdvancedChristmasLights light_string in lightstring)
				{

					if (light_string != null && !light_string.IsDestroyed && light_string.inputs[0].connectedTo.Get() == null)
					{

						if (state == false)
							light_string.UpdateHasPower(0, 1);
						else
							light_string.UpdateHasPower(200, 1);
						light_string.SetFlag(BaseEntity.Flags.On, state);
						light_string.SendNetworkUpdateImmediate();
					}
				}
			}

            if ((prefabName == "all" || simplelight_name.Contains(prefabName)) && config.SimpleLights)
            {
                SimpleLight[] simplelights = BaseNetworkable.serverEntities.OfType<SimpleLight>().ToArray() as SimpleLight[];

                foreach (SimpleLight simple_light in simplelights)
                {
                    if (simple_light != null && !simple_light.IsDestroyed && simple_light.IsOn() != state && simple_light.inputs[0].connectedTo.Get() == null)
                    {
                        simple_light.SetFlag(BaseEntity.Flags.On, state);
                    }
                }
            }

            if ((prefabName == "all" || flasherlight_name.Contains(prefabName)) && config.FlasherLights)
            {
                FlasherLight[] flasherlights = BaseNetworkable.serverEntities.OfType<FlasherLight>().ToArray() as FlasherLight[];

                foreach (FlasherLight flasher_light in flasherlights)
                {
                    if (flasher_light != null && !flasher_light.IsDestroyed && flasher_light.IsOn() != state && flasher_light.inputs[0].connectedTo.Get() == null)
                    {
                        if (state == false)
                            flasher_light.UpdateHasPower(0, 1);
                        else
                            flasher_light.UpdateHasPower(200, 1);
                        flasher_light.SetFlag(BaseEntity.Flags.On, state);
                        flasher_light.SendNetworkUpdateImmediate();
                    }
                }
            }

            if ((prefabName == "all" || sirenlight_name.Contains(prefabName)) && config.SirenLights)
            {
                SirenLight[] sirenlights = BaseNetworkable.serverEntities.OfType<SirenLight>().ToArray() as SirenLight[];

                foreach (SirenLight siren_light in sirenlights)
                {
                    if (siren_light != null && !siren_light.IsDestroyed && siren_light.IsOn() != state && siren_light.inputs[0].connectedTo.Get() == null)
                    {
                        if (state == false)
                            siren_light.UpdateHasPower(0, 1);
                        else
                            siren_light.UpdateHasPower(200, 1);
                        siren_light.SetFlag(BaseEntity.Flags.On, state);
                        siren_light.SendNetworkUpdateImmediate();
                    }
                }
            }
        }

		private void ProcessDevices(bool state, string prefabName)
		{
			//Puts("In ProcessDevices ");


			//if ((prefabName == "all" || auto_turret_name.Contains(prefabName)) && config.AutoTurrets)
			//{
			//	AutoTurret[] autoturrets = BaseNetworkable.serverEntities.OfType<AutoTurret>().ToArray() as AutoTurret[];
			//
			//	foreach (AutoTurret autoturret in autoturrets)
			//	{
			//		if (autoturret != null && !autoturret.IsDestroyed)
			//		{
			//			autoturret.SetFlag(BaseEntity.Flags.Reserved8, state); 
			//			//autoturret.InitiateStartup();
			//			autoturret.SendNetworkUpdateImmediate();
			//		}
			//	}
			//}

			if ((prefabName == "all" || mixingtable_name.Contains(prefabName)) && config.MixingTables)
			{
				MixingTable[] mixingtables = BaseNetworkable.serverEntities.OfType<MixingTable>().ToArray() as MixingTable[];
				foreach (MixingTable mixingtable in mixingtables)
				{
					if (mixingtable != null && !mixingtable.IsDestroyed)
					{
						if (state)
						{
							//Puts("ProcessDevices Mixing Table On");
							mixingtable.RemainingMixTime = 999999f;
							mixingtable.TotalMixTime = 999999f;
							mixingtable.SetFlag(BaseEntity.Flags.On, true);
						}
						else
						{
							//Puts("ProcessDevices Mixing Table Off");
							mixingtable.RemainingMixTime = 0f;
							mixingtable.TotalMixTime = 0f;
							mixingtable.SetFlag(BaseEntity.Flags.On, false);
						}
					}
				}
			}

			if ((prefabName == "all" || fogmachine_name.Contains(prefabName)) && config.Fog_Machines)
			{
				FogMachine[] fogmachines = BaseNetworkable.serverEntities.OfType<FogMachine>().ToArray() as FogMachine[];
				foreach (FogMachine fog_machine in fogmachines)
				{
					if (!(fog_machine == null || fog_machine.IsDestroyed))
					{
						// there is bug with IsOn so force state
						if (state) // if (fogmachine.IsOn() != state)
						{
							fog_machine.fuelPerSec = 0f;
							fog_machine.EnableFogField();
							fog_machine.StartFogging();
						}
						else
						{
							fog_machine.FinishFogging();
							fog_machine.DisableNozzle();
						}
						fog_machine.SetFlag(BaseEntity.Flags.On, state);
					}
				}
			}

			//if (!string.IsNullOrEmpty(prefabName) && snowmachine_name.Contains(prefabName)) Puts ("Snow machine"); else Puts("Not snow: " + prefabName);
			//if (config.Snow_Machines) Puts("Snow is configure"); else Puts("Snow is not active");
			if ((prefabName == "all" || snowmachine_name.Contains(prefabName)) && config.Snow_Machines)
			{
				//if (state) Puts("Snow On"); else Puts("Snow Off");
				SnowMachine[] snowmachines = BaseNetworkable.serverEntities.OfType<SnowMachine>().ToArray() as SnowMachine[];
				foreach (SnowMachine snow_machine in snowmachines)
				{
					if (!(snow_machine == null || snow_machine.IsDestroyed))
					{
						// there is bug with IsOn so force state
						if (state) // if (fogmachine.IsOn() != state)
						{
							snow_machine.fuelPerSec = 0f;
							snow_machine.EnableFogField();
							snow_machine.StartFogging();
						}
						else
						{
							snow_machine.FinishFogging();
							snow_machine.DisableNozzle();
						}
						snow_machine.SetFlag(BaseEntity.Flags.On, state);

					}
				}
			}

			if ((prefabName == "all" || cctv_name.Contains(prefabName)) && config.CCTVs)
			{
				CCTV_RC[] cctvs = BaseNetworkable.serverEntities.OfType<CCTV_RC>().ToArray() as CCTV_RC[];

				foreach (CCTV_RC cctv in cctvs)
				{
					if (cctv != null && !cctv.IsDestroyed)
					{
						if (state == false)
							cctv.UpdateHasPower(0, 1);
						else
							cctv.UpdateHasPower(200, 1);
						cctv.SetFlag(BaseEntity.Flags.On, state);
						cctv.SendNetworkUpdateImmediate();
					}
				}
			}

			if ((prefabName == "all" || SignShortPrefabName(prefabName)) && config.Signs)
			{

				NeonSign[] signs = BaseNetworkable.serverEntities.OfType<NeonSign>().ToArray() as NeonSign[];

				foreach (NeonSign neon_sign in signs)
				{
					if (neon_sign != null && !neon_sign.IsDestroyed)
					{
						if (neon_sign.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								neon_sign.UpdateHasPower(0, 1);
							else
								neon_sign.UpdateHasPower(200, 1);
							neon_sign.SetFlag(BaseEntity.Flags.On, state);
							neon_sign.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || igniter_name.Contains(prefabName)) && config.Igniters)
			{
				Igniter[] igniters = BaseNetworkable.serverEntities.OfType<Igniter>().ToArray() as Igniter[];

				foreach (Igniter igniter in igniters)
				{
					if (igniter != null && !igniter.IsDestroyed)
					{
						if (igniter.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								igniter.UpdateHasPower(0, 1);
							else
								igniter.UpdateHasPower(200, 1);
							igniter.SetFlag(BaseEntity.Flags.On, state);
							igniter.SelfDamagePerIgnite = 0.0f;
							igniter.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || vehiclelift_name.Contains(prefabName)) && config.VehicleLifts)
			{
				ModularCarGarage[] lifts = BaseNetworkable.serverEntities.OfType<ModularCarGarage>().ToArray() as ModularCarGarage[];

				foreach (ModularCarGarage lift in lifts)
				{
					if (lift != null && !lift.IsDestroyed)
					{
						if (lift.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								lift.UpdateHasPower(0, 1);
							else
								lift.UpdateHasPower(200, 1);
							lift.SetFlag(IOEntity.Flag_HasPower, state);
							lift.SetFlag(BaseEntity.Flags.On, state);
							lift.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || heater_name.Contains(prefabName)) && config.Heaters)
			{
				ElectricalHeater[] heaters = BaseNetworkable.serverEntities.OfType<ElectricalHeater>().ToArray() as ElectricalHeater[];
				foreach (ElectricalHeater heater in heaters)
				{
					if (heater != null && !heater.IsDestroyed)
					{
						if (heater.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								heater.UpdateHasPower(0, 1);
							else
								heater.UpdateHasPower(200, 1);
							heater.SetFlag(BaseEntity.Flags.On, state);
							heater.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || elevator_name.Contains(prefabName)) && config.Elevators)
			{
				ElevatorIOEntity[] elevators = BaseNetworkable.serverEntities.OfType<ElevatorIOEntity>().ToArray() as ElevatorIOEntity[];
				foreach (ElevatorIOEntity elevator in elevators)
				{
					if (elevator != null && !elevator.IsDestroyed)
					{
						if (elevator.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								elevator.UpdateHasPower(0, 1);
							else
								elevator.UpdateHasPower(200, 1);
							elevator.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							elevator.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							elevator.SetFlag(IOEntity.Flag_HasPower, state);
							elevator.SetFlag(BaseEntity.Flags.On, state);
							elevator.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || smart_alarm_name.Contains(prefabName)) && config.SmartAlarms)
			{
				SmartAlarm[] smartalarms = BaseNetworkable.serverEntities.OfType<SmartAlarm>().ToArray() as SmartAlarm[];

				foreach (SmartAlarm smartalarm in smartalarms)
				{
					if (smartalarm != null && !smartalarm.IsDestroyed)
					{
						if (smartalarm.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								smartalarm.UpdateHasPower(0, 0);
							else
								smartalarm.UpdateHasPower(200, 0);
							smartalarm.SetFlag(BaseEntity.Flags.On, state);
							smartalarm.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || smart_switch_name.Contains(prefabName)) && config.SmartSwitches)
			{
				SmartSwitch[] smartswitches = BaseNetworkable.serverEntities.OfType<SmartSwitch>().ToArray() as SmartSwitch[];

				foreach (SmartSwitch smartswitch in smartswitches)
				{
					if (smartswitch != null && !smartswitch.IsDestroyed)
					{
						if (smartswitch.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								smartswitch.UpdateHasPower(0, 0);
							else
								smartswitch.UpdateHasPower(200, 0);
							smartswitch.SetFlag(BaseEntity.Flags.On, state);
							smartswitch.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || storage_monitor_name.Contains(prefabName)) && config.StorageMonitors)
			{
				StorageMonitor[] storage_monitors = BaseNetworkable.serverEntities.OfType<StorageMonitor>().ToArray() as StorageMonitor[];

				foreach (StorageMonitor storage_monitor in storage_monitors)
				{
					if (storage_monitor != null && !storage_monitor.IsDestroyed)
					{
						if (storage_monitor.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								storage_monitor.UpdateHasPower(0, 0);
							else
								storage_monitor.UpdateHasPower(200, 0);
							storage_monitor.SetFlag(BaseEntity.Flags.On, state);
							storage_monitor.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || waterpump_name.Contains(prefabName)) && config.WaterPumps)
			{
				WaterPump[] waterpumps = BaseNetworkable.serverEntities.OfType<WaterPump>().ToArray() as WaterPump[];

				foreach (WaterPump waterpump in waterpumps)
				{
					if (waterpump != null && !waterpump.IsDestroyed)
					{
						if (waterpump.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
							{
								waterpump.PowerConsumption = 10;
								waterpump.UpdateHasPower(0, 0);						}
							else
							{
								waterpump.PowerConsumption = 0;
								waterpump.UpdateHasPower(200, 0);
							}
							waterpump.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							waterpump.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							waterpump.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || water_purifier_name.Contains(prefabName)) && config.WaterPurifiers)
			{
				WaterPurifier[] waterpurifiers = BaseNetworkable.serverEntities.OfType<WaterPurifier>().ToArray() as WaterPurifier[];

				foreach (WaterPurifier waterpurifier in waterpurifiers)
				{
					if (waterpurifier != null && !waterpurifier.IsDestroyed)
					{
						if (waterpurifier.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								waterpurifier.UpdateHasPower(0, 1);
							else
								waterpurifier.UpdateHasPower(200, 1);

							waterpurifier.SetFlag(BaseEntity.Flags.On, state);
							waterpurifier.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							waterpurifier.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							waterpurifier.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || fluidswitch_name.Contains(prefabName)) && config.FluidSwitches)
			{
				FluidSwitch[] fluidswitches = BaseNetworkable.serverEntities.OfType<FluidSwitch>().ToArray() as FluidSwitch[];

				foreach (FluidSwitch fluidswitch in fluidswitches)
				{
					if (fluidswitch != null && !fluidswitch.IsDestroyed)
					{
						if (fluidswitch.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								fluidswitch.UpdateHasPower(0, 1);
							else
								fluidswitch.UpdateHasPower(200, 1);
							fluidswitch.SetFlag(BaseEntity.Flags.On, state);
							fluidswitch.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							fluidswitch.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							fluidswitch.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || strobelight_name.Contains(prefabName)) && config.StrobeLights)
			{
				StrobeLight[] strobelights = BaseNetworkable.serverEntities.OfType<StrobeLight>().ToArray() as StrobeLight[];
				foreach (StrobeLight strobelight in strobelights)
				{
					if (!(strobelight == null || strobelight.IsDestroyed) && strobelight.IsOn() != state)
					{
						strobelight.SetFlag(BaseEntity.Flags.On, state);
						strobelight.burnRate = 0.0f;
						strobelight.SendNetworkUpdateImmediate();
					}
				}
			}

			if ((prefabName == "all" || reactivetarget_name.Contains(prefabName)) && config.ReactiveTargets)
			{
				ReactiveTarget[] reactivetargets = BaseNetworkable.serverEntities.OfType<ReactiveTarget>().ToArray() as ReactiveTarget[];

				foreach (ReactiveTarget reactivetarget in reactivetargets)
				{
					if (reactivetarget != null && !reactivetarget.IsDestroyed)
					{
						if (reactivetarget.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								reactivetarget.UpdateHasPower(0, 1);
							else
								reactivetarget.UpdateHasPower(200, 1);
							reactivetarget.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							reactivetarget.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
							reactivetarget.SetFlag(BaseEntity.Flags.On, state);
							reactivetarget.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || rfbroadcaster_name.Contains(prefabName)) && config.RFBroadcasters)
			{
				RFBroadcaster[] rfbroadcasters = BaseNetworkable.serverEntities.OfType<RFBroadcaster>().ToArray() as RFBroadcaster[];

				foreach (RFBroadcaster rfbroadcaster in rfbroadcasters)
				{
					if (rfbroadcaster != null && !rfbroadcaster.IsDestroyed)
					{
						if (rfbroadcaster.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								rfbroadcaster.UpdateHasPower(0, 1);
							else
								rfbroadcaster.UpdateHasPower(200, 1);
							rfbroadcaster.SetFlag(BaseEntity.Flags.On, state);
							rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							rfbroadcaster.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || rfreceiver_name.Contains(prefabName)) && config.RFReceivers)
			{
				RFReceiver[] rfreceivers = BaseNetworkable.serverEntities.OfType<RFReceiver>().ToArray() as RFReceiver[];

				foreach (RFReceiver rfreceiver in rfreceivers)
				{
					if (rfreceiver != null && !rfreceiver.IsDestroyed)
					{
						if (rfreceiver.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
						{
							if (state == false)
								rfreceiver.UpdateHasPower(0, 1);
							else
								rfreceiver.UpdateHasPower(200, 1);
							rfreceiver.SetFlag(BaseEntity.Flags.On, state);
							rfreceiver.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
							rfreceiver.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
							rfreceiver.SendNetworkUpdateImmediate();
						}
					}
				}
			}

			if ((prefabName == "all" || telephone_name.Contains(prefabName)) && config.Telephones)
			{
				Telephone[] telephones = BaseNetworkable.serverEntities.OfType<Telephone>().ToArray() as Telephone[];

				foreach (Telephone telephone in telephones)
				{
					if (telephone != null && !telephone.IsDestroyed)
					{
						if (state == false)
							telephone.UpdateHasPower(0, 1);
						else
							telephone.UpdateHasPower(200, 1);
						telephone.SetFlag(BaseEntity.Flags.On, state);
						telephone.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						telephone.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
						telephone.SendNetworkUpdateImmediate();
					}
				}
			}

			//if ((prefabName == "all" || teslacoil_name.Contains(prefabName)) && config.TeslaCoils)
			//{
			//	TeslaCoil[] teslacoils = BaseNetworkable.serverEntities.OfType<TeslaCoil>().ToArray() as TeslaCoil[];
			//
			//	foreach (TeslaCoil teslacoil in teslacoils)
			//	{
			//		if (teslacoil != null && !teslacoil.IsDestroyed)
			//		{
			//			if (state == false)
			//				teslacoil.UpdateHasPower(0, 1);
			//			else
			//				teslacoil.UpdateHasPower(200, 1);
			//			teslacoil.SetFlag(BaseEntity.Flags.On, state);
			//			teslacoil.maxDischargeSelfDamageSeconds = 0f;
			//			teslacoil.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
			//			teslacoil.SetFlag(BaseEntity.Flags.Reserved8, state);  // has power
			//			teslacoil.SendNetworkUpdateImmediate();
			//		}
			//	}
			//}

			if ((prefabName == "all" || sam_site_name.Contains(prefabName)) && config.SamSites)
			{
				SamSite[] samsites = BaseNetworkable.serverEntities.OfType<SamSite>().ToArray() as SamSite[];

				foreach (SamSite samsite in samsites)
				{
					if (samsite != null && !samsite.IsDestroyed)
					{
						if (state == false)
							samsite.UpdateHasPower(0, 1);
						else
							samsite.UpdateHasPower(200, 1);
						samsite.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						samsite.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						samsite.SendNetworkUpdateImmediate();
					}
				}
			}

			if ((prefabName == "all" || spookyspeaker_name.Contains(prefabName)) && config.Speakers)
			{
				SpookySpeaker[] spookyspeakers = BaseNetworkable.serverEntities.OfType<SpookySpeaker>().ToArray() as SpookySpeaker[];
				foreach (SpookySpeaker spookyspeaker in spookyspeakers)
				{
					if (!(spookyspeaker == null || spookyspeaker.IsDestroyed) && spookyspeaker.IsOn() != state)
					{
						spookyspeaker.SetFlag(BaseEntity.Flags.On, state);
						if (state == true)
						{
							spookyspeaker.SendPlaySound();
						}
					}
				}
			}
		}
		private object OnFindBurnable(BaseOven oven)
		{

			if (oven == null || string.IsNullOrEmpty(oven.ShortPrefabName) ||
				oven.OwnerID == 0U || oven.OwnerID.ToString() == null)
				return null;

			if (!ProcessShortPrefabName(oven.ShortPrefabName) ||	!IsLightPrefabName(oven.ShortPrefabName))
				return null;
			//else if (config.UseZoneManagerPlugin && !(bool)ZoneManager?.Call("EntityHasFlag", oven as BaseEntity, "autolights"))
			//	return null;
			else
			{
				//Puts("OnFindBurnable: " + oven.ShortPrefabName + " : " + oven.cookingTemperature);
				oven.StopCooking();
				oven.allowByproductCreation = false;
				oven.SetFlag(BaseEntity.Flags.On, true);
				if (oven.fuelType != null)
					return ItemManager.CreateByItemID(oven.fuelType.itemid);
			}
			// catch all
			return null;
		}

		// for jack o laterns
		private void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
		{
			if (oven == null || string.IsNullOrEmpty(oven.ShortPrefabName) ||
				oven.OwnerID == 0U || oven.OwnerID.ToString() == null)
				return;

			if (!ProcessShortPrefabName(oven.ShortPrefabName) ||
				!IsLightPrefabName(oven.ShortPrefabName))
				return;
			//else if (config.UseZoneManagerPlugin && !(bool)ZoneManager?.Call("EntityHasFlag", oven as BaseEntity, "autolights"))
			//	return;
			else
			{
				fuel.amount += 1;
				oven.StopCooking();
				oven.allowByproductCreation = false;
				oven.SetFlag(BaseEntity.Flags.On, true);
			}
			// catch all
			return;
		}

		// for hats
		private void OnItemUse(Item item, int amount)
		{
			if (!config.Hats) return;
			string ShortPrefabName = item?.parent?.parent?.info?.shortname ?? item?.GetRootContainer()?.entityOwner?.ShortPrefabName;
			BasePlayer player = null;

			if (string.IsNullOrEmpty(ShortPrefabName) || !IsHatPrefabName(ShortPrefabName) || !config.Hats)
				return;
			try
			{
				player = item?.GetRootContainer()?.playerOwner;
			}
			catch
			{
				player = null;
			}

			if (player == null && string.IsNullOrEmpty(player.UserIDString))
			{
				return;  // no owner so no permission
			}
			item.amount += amount;
			return;
		}

		object OnOvenToggle(BaseOven oven, BasePlayer player)
		{
			string cleanedname = null;
			if (oven == null || string.IsNullOrEmpty(oven.ShortPrefabName) ||
				player == null || player.UserIDString == null)
				return null;
			else
			{
				cleanedname = CleanedName(oven.ShortPrefabName);
				//Puts(oven.ShortPrefabName + " : " + cleanedname + " : " + oven.IsOn());
			}
			if (!IsLightToggle(cleanedname)
				//(!IsLightPrefabName(cleanedname)) // && !(IsOvenPrefabName(cleanedname) && ProcessShortPrefabName(oven.ShortPrefabName))))
				)
			{
				return null;
			}
			if (!ProcessShortPrefabName(oven.ShortPrefabName))
				return null;
			else if (oven.IsOn() != true)
			{
				//Puts("off going on and allowed " +  oven.temperature.ToString() + " : " + oven.cookingTemperature);
				oven.SetFlag(BaseEntity.Flags.On, true);
				oven.StopCooking();
				oven.allowByproductCreation = false;
				oven.SetFlag(BaseEntity.Flags.On, true);
			}
			else
			{
				//Puts("on going off and allowed " +  oven.temperature.ToString() + " : " + oven.cookingTemperature);
				oven.SetFlag(BaseEntity.Flags.On, false);
				oven.StopCooking();
				oven.SetFlag(BaseEntity.Flags.On, false);
			}
			// catch all
			return null;
		}

		//void AutoTurretChangePower()
		//{
		//	if (config.AutoTurrets)
		//	{
		//		foreach (AutoTurret autoturret in BaseNetworkable.serverEntities.OfType<AutoTurret>())
		//		{
		//			if (autoturret != null)
		//			{
		//				autoturret.SetFlag(BaseEntity.Flags.Reserved8, true); 
		//				//autoturret.InitiateStartup();
		//				autoturret.SendNetworkUpdateImmediate();
		//			}
		//		}
		//	}
		//}

		void SamSiteChangePower()
		{
			if (config.SamSites)
			{
				foreach (SamSite samsite in BaseNetworkable.serverEntities.OfType<SamSite>())
				{
					if (samsite != null) // skip if they have power connected as they might want to toggle them off
					{
						samsite.UpdateHasPower(200, 1);
						samsite.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						samsite.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						samsite.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void LightStringChangePower()
		{
			if ((config.AlwaysOn || NightToggleactive) && config.Deluxe_lightstrings)
			{
				foreach (AdvancedChristmasLights light_string in BaseNetworkable.serverEntities.OfType<AdvancedChristmasLights>())
				{
					if (light_string != null && light_string.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						light_string.UpdateHasPower(200, 1);
						light_string.SetFlag(BaseEntity.Flags.On, true);
						light_string.SendNetworkUpdateImmediate();
					}
				}
			}
		}

        void FlasherLightChangePower()
        {
			if ((config.AlwaysOn || NightToggleactive) && config.FlasherLights)
			{
				foreach (FlasherLight flasherlight in BaseNetworkable.serverEntities.OfType<FlasherLight>())
				{
					if (flasherlight != null && flasherlight.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						flasherlight.UpdateHasPower(200, 1);
						flasherlight.SetFlag(BaseEntity.Flags.On, true);
						flasherlight.SendNetworkUpdateImmediate();
					}
                }
            }
        }

        void SirenLightChangePower()
        {
			if ((config.AlwaysOn || NightToggleactive) && config.SirenLights)
			{
				foreach (SirenLight sirenlight in BaseNetworkable.serverEntities.OfType<SirenLight>())
				{
					if (sirenlight != null && sirenlight.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						sirenlight.UpdateHasPower(200, 1);
						sirenlight.SetFlag(BaseEntity.Flags.On, true);
						sirenlight.SendNetworkUpdateImmediate();
					}
                }
            }
        }

        void SmartAlarmChangePower()
        {
			if (config.SmartAlarms)
			{
				foreach (SmartAlarm smartalarm in BaseNetworkable.serverEntities.OfType<SmartAlarm>())
				{
					if (smartalarm != null && smartalarm.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						smartalarm.UpdateHasPower(200, 0);
						smartalarm.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						smartalarm.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						smartalarm.SetFlag(BaseEntity.Flags.On, true);
						smartalarm.SendNetworkUpdateImmediate();
					}
                }
            }
        }

        void SmartSwitchChangePower()
        {
			if (config.SmartSwitches)
			{
				foreach (SmartSwitch smartswitch in BaseNetworkable.serverEntities.OfType<SmartSwitch>())
				{
					if (smartswitch != null && smartswitch.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						smartswitch.UpdateHasPower(200, 0);
						smartswitch.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						smartswitch.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						smartswitch.SetFlag(BaseEntity.Flags.On, true);
						smartswitch.SendNetworkUpdateImmediate();
					}
                }
            }
        }

        void StorageMonitorChangePower()
        {
			if (config.StorageMonitors)
			{
				foreach (StorageMonitor storage_monitor in BaseNetworkable.serverEntities.OfType<StorageMonitor>())
				{
					if (storage_monitor != null && storage_monitor.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						storage_monitor.UpdateHasPower(200, 0);
						storage_monitor.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						storage_monitor.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						storage_monitor.SetFlag(BaseEntity.Flags.On, true);
						storage_monitor.SendNetworkUpdateImmediate();
					}
                }
            }
        }

        void CCTVChangePower()
		{
			if (config.CCTVs)
			{
				foreach (CCTV_RC cctv in BaseNetworkable.serverEntities.OfType<CCTV_RC>())
				{
					if (cctv != null && cctv.inputs[0].connectedTo.Get() == null)
					{
					cctv.UpdateHasPower(200, 1);
				    cctv.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    cctv.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
					cctv.SetFlag(BaseEntity.Flags.On, true);
					cctv.SendNetworkUpdateImmediate();
					}
				}
			}
		}

        void SignChangePower()
		{
			if (config.Signs)
			{
				foreach (NeonSign neon_sign in BaseNetworkable.serverEntities.OfType<NeonSign>())
				{
					if (neon_sign != null && neon_sign.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						neon_sign.UpdateHasPower(200, 1);
						neon_sign.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						neon_sign.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						neon_sign.SetFlag(BaseEntity.Flags.On, true);
						neon_sign.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void IgniterChangePower()
		{
			if (config.Igniters)
			{
				foreach (Igniter igniter in BaseNetworkable.serverEntities.OfType<Igniter>())
				{
					if (igniter != null && igniter.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						igniter.UpdateHasPower(200, 1);
						igniter.SetFlag(BaseEntity.Flags.On, true);
						igniter.SelfDamagePerIgnite = 0.0f;
						igniter.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void VehicleLiftChangePower()
		{
			if (config.VehicleLifts)
			{
				foreach (ModularCarGarage lift in BaseNetworkable.serverEntities.OfType<ModularCarGarage>())
				{
					if (lift != null && lift.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						lift.UpdateHasPower(200, 1);
						lift.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						lift.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						lift.SetFlag(BaseEntity.Flags.On, true);
						lift.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void HeaterChangePower()
		{
			if (config.Heaters)
			{
				foreach (ElectricalHeater heater in BaseNetworkable.serverEntities.OfType<ElectricalHeater>())
				{
					if (heater != null && heater.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						heater.UpdateHasPower(200, 1);
						heater.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						heater.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						heater.SetFlag(BaseEntity.Flags.On, true);
						heater.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void ElevatorChangePower()
		{
			if (config.Elevators)
			{
				foreach (Elevator elevator in BaseNetworkable.serverEntities.OfType<Elevator>())
				{
					if (elevator != null && elevator.inputs[0].connectedTo.Get() == null)
					{
						elevator.UpdateHasPower(200, 1);
						elevator.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						elevator.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						elevator.SetFlag(IOEntity.Flag_HasPower, true);
						elevator.SetFlag(BaseEntity.Flags.On, true);
						elevator.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void SearchLightChangePower()
		{
			if (config.SearchLights)
			{
				foreach (SearchLight searchlight in BaseNetworkable.serverEntities.OfType<SearchLight>())
				{
					if (searchlight != null && searchlight.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						searchlight.UpdateHasPower(200, 1);
						searchlight.IOStateChanged(200, 100);
						searchlight.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						searchlight.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						searchlight.SetFlag(BaseEntity.Flags.On, true);
						searchlight.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void WaterPumpChangePower()
		{
			if (config.WaterPumps)
			{
				foreach (WaterPump waterpump in BaseNetworkable.serverEntities.OfType<WaterPump>())
				{
					if (waterpump != null && waterpump.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						waterpump.PowerConsumption = 0;
						waterpump.UpdateHasPower(200, 0);
						waterpump.SetFlag(BaseEntity.Flags.Reserved6, true);
						waterpump.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						waterpump.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						waterpump.SetFlag(BaseEntity.Flags.On, true);
						waterpump.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void WaterPurifierChangePower()
		{
			if (config.WaterPurifiers)
			{
				foreach (WaterPurifier waterpurifier in BaseNetworkable.serverEntities.OfType<WaterPurifier>())
				{
					if (waterpurifier != null && waterpurifier.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						waterpurifier.UpdateHasPower(200, 1);
						waterpurifier.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						waterpurifier.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						waterpurifier.SetFlag(BaseEntity.Flags.On, true);
						waterpurifier.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void FluidSwitchChangePower()
		{
			if (config.FluidSwitches)
			{
				foreach (FluidSwitch fluidswitch in BaseNetworkable.serverEntities.OfType<FluidSwitch>())
				{
					if (fluidswitch != null && fluidswitch.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						fluidswitch.UpdateHasPower(200, 1);
						fluidswitch.SetFlag(BaseEntity.Flags.Reserved6, true);
						fluidswitch.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						fluidswitch.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						fluidswitch.SetFlag(BaseEntity.Flags.On, true);
						fluidswitch.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void ReactiveTargetChangePower()
		{
			if (config.ReactiveTargets)
			{
				foreach (ReactiveTarget reactivetarget in BaseNetworkable.serverEntities.OfType<ReactiveTarget>())
				{
					if (reactivetarget != null) // skip if they have power connected as they might want to toggle them off
					{
						reactivetarget.UpdateHasPower(200, 1);
						reactivetarget.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						reactivetarget.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						reactivetarget.SetFlag(BaseEntity.Flags.On, true);
						reactivetarget.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void RFBroadcasterChangePower()
		{
			if (config.RFBroadcasters)
			{
				foreach (RFBroadcaster rfbroadcaster in BaseNetworkable.serverEntities.OfType<RFBroadcaster>())
				{
					if (rfbroadcaster != null && rfbroadcaster.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						rfbroadcaster.UpdateHasPower(200, 1);
						rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved6, true);
						rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						rfbroadcaster.SetFlag(BaseEntity.Flags.On, true);
						rfbroadcaster.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void RFReceiverChangePower()
		{
			if (config.RFReceivers)
			{
				foreach (RFReceiver rfreceiver in BaseNetworkable.serverEntities.OfType<RFReceiver>())
				{
					if (rfreceiver != null && rfreceiver.inputs[0].connectedTo.Get() == null) // skip if they have power connected as they might want to toggle them off
					{
						rfreceiver.UpdateHasPower(200, 1);
						rfreceiver.SetFlag(BaseEntity.Flags.Reserved6, true);
						rfreceiver.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						rfreceiver.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						rfreceiver.SetFlag(BaseEntity.Flags.On, true);
						rfreceiver.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		void TelephoneChangePower()
		{
			if (config.Telephones)
			{
				foreach (Telephone telephone in BaseNetworkable.serverEntities.OfType<Telephone>())
				{
					if (telephone != null) // skip if they have power connected as they might want to toggle them off
					{
						telephone.UpdateHasPower(200, 1);
						telephone.SetFlag(BaseEntity.Flags.Reserved6, true);
						telephone.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
						telephone.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
						telephone.SetFlag(BaseEntity.Flags.On, true);
						telephone.SendNetworkUpdateImmediate();
					}
				}
			}
		}

		//void TeslaCoilChangePower()
		//{
		//	if (config.TeslaCoils)
		//	{
		//		foreach (TeslaCoil teslacoil in BaseNetworkable.serverEntities.OfType<TeslaCoil>())
		//		{
		//			if (teslacoil != null) // skip if they have power connected as they might want to toggle them off
		//			{
		//				teslacoil.UpdateHasPower(200, 1);
		//				teslacoil.SetFlag(BaseEntity.Flags.Reserved6, true);
		//				teslacoil.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
		//				teslacoil.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
		//				teslacoil.SetFlag(BaseEntity.Flags.On, true);
		//				teslacoil.maxDischargeSelfDamageSeconds = 0f;
		//				teslacoil.SendNetworkUpdateImmediate();
		//			}
		//		}
		//	}
		//}

		void OnEntityBuilt(Planner plan, GameObject go)
        {
            FluidSwitch fs = go.GetComponent<FluidSwitch>();
            if (fs != null && config.FluidSwitches)
			{
				fs.UpdateHasPower(200, 0)