;
				fs.SetFlag(BaseEntity.Flags.On, true);
				fs.SetFlag(BaseEntity.Flags.Reserved6, true);
				fs.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				fs.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				fs.SetFlag(BaseEntity.Flags.On, true);
				fs.SendNetworkUpdateImmediate();
				return;
			}
            SmartAlarm sa = go.GetComponent<SmartAlarm>();
            if (sa != null && config.SmartAlarms)
            {
				sa.UpdateHasPower(200, 0);
				sa.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				sa.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				sa.SetFlag(BaseEntity.Flags.On, true);
				sa.SendNetworkUpdateImmediate();
				return;
			}
            SmartSwitch ss = go.GetComponent<SmartSwitch>();
            if (ss != null && config.SmartSwitches)
            {
				ss.UpdateHasPower(200, 0);
				ss.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				ss.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				ss.SetFlag(BaseEntity.Flags.On, true);
				ss.SendNetworkUpdateImmediate();
				return;
			}
            StorageMonitor sm = go.GetComponent<StorageMonitor>();
            if (sm != null && config.StorageMonitors)
            {
				sm.UpdateHasPower(200, 0);
				sm.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				sm.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				sm.SetFlag(BaseEntity.Flags.On, true);
				sm.SendNetworkUpdateImmediate();
				return;
			}
            FlasherLight fl = go.GetComponent<FlasherLight>();
            if (fl != null && config.FlasherLights)
            {
				fl.UpdateHasPower(200, 0);
				fl.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				fl.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				fl.SetFlag(BaseEntity.Flags.On, true);
				fl.SendNetworkUpdateImmediate();
				return;
			}
            SirenLight sl = go.GetComponent<SirenLight>();
            if (sl != null && config.SirenLights)
            {
				sl.UpdateHasPower(200, 0);
				sl.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				sl.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				sl.SetFlag(BaseEntity.Flags.On, true);
				sl.SendNetworkUpdateImmediate();
				return;
			}
			//TeslaCoil tc = go.GetComponent<TeslaCoil>();
			//if (tc != null && config.TeslaCoils)
			//{
			//	tc.UpdateHasPower(200, 0);
			//	tc.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
			//	tc.SetFlag(BaseEntity.Flags.On, true);
			//	tc.maxDischargeSelfDamageSeconds = 0f;
			//	tc.SendNetworkUpdateImmediate();
			//	return;
			//}
        }

		// automatically set lights on that are deployed if the lights are in the on state
		// private void OnItemDeployed(Deployer deployer, BaseEntity entity)
		private void OnEntitySpawned(BaseNetworkable entity)
		{
			if (!ProcessShortPrefabName(entity.ShortPrefabName))
				return;
			//Puts("OES: " + entity.ShortPrefabName);

			//if (entity is AutoTurret && config.AutoTurrets)
			//{
			//	var autoturret = entity as AutoTurret;
			//	autoturret.SetFlag(BaseEntity.Flags.Reserved8, true); 
			//	//autoturret.InitiateStartup();
			//	autoturret.SendNetworkUpdateImmediate();
			//	return;
			//}
			if (entity is SamSite && config.SamSites)
			{
				var samsite = entity as SamSite;
				samsite.UpdateHasPower(200, 1);
				samsite.SetFlag(BaseEntity.Flags.Reserved7, false);  // Flag Short Circuit
				samsite.SetFlag(BaseEntity.Flags.Reserved8, true);   // Flag Has Power
				samsite.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is FogMachine && config.Fog_Machines)
			{
				var fm = entity as FogMachine;
				fm.fuelPerSec = 0f;
				fm.SetFlag(BaseEntity.Flags.On, true);
				fm.EnableFogField();
				fm.StartFogging();
				return;
			}
			if (entity is SnowMachine && config.Snow_Machines)
			{
				var sm = entity as SnowMachine;
				sm.fuelPerSec = 0f;
				sm.SetFlag(BaseEntity.Flags.On, true);
				sm.EnableFogField();
				sm.StartFogging();
				return;
			}
			if (entity is ElectricalHeater && config.Heaters)
			{
				var heater = entity as ElectricalHeater;
				heater.UpdateHasPower(200, 1);
				heater.SetFlag(BaseEntity.Flags.On, true);
				heater.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is NeonSign && config.Signs)
			{
				var neon_sign = entity as NeonSign;
				neon_sign.UpdateHasPower(200, 1);
				neon_sign.SetFlag(BaseEntity.Flags.On, true);
				neon_sign.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is CCTV_RC && config.CCTVs)
			{
				var cctv = entity as CCTV_RC;
				cctv.UpdateHasPower(200, 1);
				cctv.SetFlag(BaseEntity.Flags.On, true);
				cctv.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is Elevator && config.Elevators)
			{
				var elevator = entity as Elevator;
				elevator.UpdateHasPower(200, 1);
				elevator.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				elevator.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				elevator.SetFlag(IOEntity.Flag_HasPower, true);
				elevator.SetFlag(BaseEntity.Flags.On, true);
				elevator.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is WaterPump && config.WaterPumps)
			{
				var waterpump = entity as WaterPump;
				//waterpump.UpdateHasPower(200, 1);
				waterpump.IOStateChanged(999999, 0);
				//waterpump.SetFlag(BaseEntity.Flags.On, true);
				waterpump.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				waterpump.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				waterpump.SetFlag(BaseEntity.Flags.On, true);
				waterpump.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is WaterPurifier && config.WaterPurifiers)
			{
				var waterpurifier = entity as WaterPurifier;
				waterpurifier.UpdateHasPower(200, 1);
				waterpurifier.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				waterpurifier.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				waterpurifier.SetFlag(BaseEntity.Flags.On, true);
				waterpurifier.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is FluidSwitch && config.FluidSwitches)
			{
				var fluidswitch = entity as FluidSwitch;
				fluidswitch.UpdateHasPower(200, 1);
				fluidswitch.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				fluidswitch.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				fluidswitch.SetFlag(BaseEntity.Flags.On, true);
				fluidswitch.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is ReactiveTarget && config.ReactiveTargets)
			{
				var reactivetarget = entity as ReactiveTarget;
				reactivetarget.UpdateHasPower(200, 1);
				reactivetarget.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				reactivetarget.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				reactivetarget.SetFlag(BaseEntity.Flags.On, true);
				reactivetarget.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is RFBroadcaster && config.RFBroadcasters)
			{
				var rfbroadcaster = entity as RFBroadcaster;
				rfbroadcaster.UpdateHasPower(200, 1);
				rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				rfbroadcaster.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				rfbroadcaster.SetFlag(BaseEntity.Flags.On, true);
				rfbroadcaster.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is RFReceiver && config.RFReceivers)
			{
				var rfreceiver = entity as RFReceiver;
				rfreceiver.UpdateHasPower(200, 1);
				rfreceiver.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				rfreceiver.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				rfreceiver.SetFlag(BaseEntity.Flags.On, true);
				rfreceiver.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is Telephone && config.Telephones)
			{
				var telephones = entity as Telephone;
				telephones.UpdateHasPower(200, 1);
				telephones.SetFlag(BaseEntity.Flags.Reserved7, false );  // Flag Short Circuit
				telephones.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
				telephones.SetFlag(BaseEntity.Flags.On, true);
				telephones.SendNetworkUpdateImmediate();
				return;
			}
			//if (entity is TeslaCoil && config.TeslaCoils)
			//{
			//	var teslacoil = entity as TeslaCoil;
			//	teslacoil.UpdateHasPower(200, 1);
			//	teslacoil.SetFlag(BaseEntity.Flags.Reserved8, true );   // Flag Has Power
			//	teslacoil.SetFlag(BaseEntity.Flags.On, true);
			//	teslacoil.maxDischargeSelfDamageSeconds = 0f;
			//	teslacoil.SendNetworkUpdateImmediate();
			//	return;
			//}
			if (entity is SmartAlarm && config.SmartAlarms)
			{
				var sa = entity as SmartAlarm;
				sa.UpdateHasPower(200, 1);
				sa.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				sa.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				sa.SetFlag(BaseEntity.Flags.On, true);
				sa.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is SmartSwitch && config.SmartSwitches)
			{
				var ss = entity as SmartSwitch;
				ss.UpdateHasPower(200, 1);
				ss.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				ss.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				ss.SetFlag(BaseEntity.Flags.On, true);
				ss.SendNetworkUpdateImmediate();
				return;
			}
			if (entity is StorageMonitor && config.StorageMonitors)
			{
				var stm = entity as StorageMonitor;
				stm.UpdateHasPower(200, 1);
				stm.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				stm.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
				stm.SetFlag(BaseEntity.Flags.On, true);
				stm.SendNetworkUpdateImmediate();
				return;
			}

			if (config.AlwaysOn || NightToggleactive)
			{
				if (entity is BaseOven)
				{
					var bo = entity as BaseOven;
					bo.SetFlag(BaseEntity.Flags.On, true);
					bo.SendNetworkUpdateImmediate();
					return;
				}
				if (entity is CeilingLight && config.CeilingLights)
				{
					var cl = entity as CeilingLight;
					cl.UpdateHasPower(200, 1);
				    cl.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    cl.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
					cl.SetFlag(BaseEntity.Flags.On, true);
					cl.SendNetworkUpdateImmediate();
					return;
				}
                if (entity is FlasherLight && config.FlasherLights)
                {
                    var fl = entity as FlasherLight;
                    fl.UpdateHasPower(200, 1);
				    fl.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    fl.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
                    fl.SetFlag(BaseEntity.Flags.On, true);
                    fl.SendNetworkUpdateImmediate();
					return;
                }
                if (entity is SimpleLight && config.SimpleLights)
                {
                    var sl = entity as SimpleLight;
                    sl.UpdateHasPower(200, 1);
				    sl.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    sl.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
                    sl.SetFlag(BaseEntity.Flags.On, true);
                    sl.SendNetworkUpdateImmediate();
					return;
                }
                if (entity is SirenLight && config.SirenLights)
                {
                    var sil = entity as SirenLight;
                    sil.UpdateHasPower(200, 1);
				    sil.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    sil.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
                    sil.SetFlag(BaseEntity.Flags.On, true);
                    sil.SendNetworkUpdateImmediate();
					return;
                }
                if (entity is SearchLight && config.SearchLights)
				{
					var sel = entity as SearchLight;
                    sel.UpdateHasPower(200, 1);
				    sel.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    sel.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
                    sel.SetFlag(BaseEntity.Flags.On, true);
                    sel.SendNetworkUpdateImmediate();
					return;
				}
				if (entity is Candle && config.Candles)
				{
					var candle = entity as Candle;
					candle.lifeTimeSeconds = 999999f;
					candle.burnRate = 0.0f;
					candle.SetFlag(BaseEntity.Flags.On, true);
					candle.SendNetworkUpdateImmediate();
					return;
				}
				if (entity is AdvancedChristmasLights && config.Deluxe_lightstrings)
				{
					var light_string = entity as AdvancedChristmasLights;
					light_string.UpdateHasPower(200, 1);
				    light_string.SetFlag(BaseEntity.Flags.Reserved7, false); // short circuit
				    light_string.SetFlag(BaseEntity.Flags.Reserved8, true);  // has power
					light_string.SetFlag(BaseEntity.Flags.On, true);
					light_string.SendNetworkUpdateImmediate();
					return;
				}
			}

			if (config.DevicesAlwaysOn || NightToggleactive)
			{
				if (entity is MixingTable && config.MixingTables)
				{
					var mt = entity as MixingTable;
					mt.RemainingMixTime = 999999f;
					mt.TotalMixTime = 999999f;
					mt.SetFlag(BaseEntity.Flags.On, true);
					mt.SendNetworkUpdateImmediate();
					return;
				}
				if (entity is StrobeLight && config.StrobeLights)
				{
					var sl = entity as StrobeLight;
					sl.burnRate = 0.0f;
					sl.SetFlag(BaseEntity.Flags.On, true);
					sl.SendNetworkUpdateImmediate();
					return;
				}
				if (entity is SpookySpeaker  && config.Speakers)
				{
					var ss = entity as SpookySpeaker;
					ss.SetFlag(BaseEntity.Flags.On, true);
					ss.SendPlaySound();
					return;
				}
				if (entity is Igniter && config.Igniters)
				{
					var igniter = entity as Igniter;
					igniter.SelfDamagePerIgnite = 0.0f;
					igniter.UpdateHasPower(200, 1);
					igniter.SetFlag(BaseEntity.Flags.On, true);
					igniter.SendNetworkUpdateImmediate();
					return;
				}
			}
		}

		[Command("lights")]
		private void ChatCommandlo(IPlayer player, string cmd, string[] args)
		{
			if (!permission.UserHasPermission(player.Id, perm_lightson))
			{
				player.Message(String.Concat(Lang("prefix", player.Id), Lang("nopermission", player.Id)));
				return;
			}
			else if (args == null || args.Length < 1)
			{
				player.Message(String.Concat(Lang("prefix", player.Id), Lang("syntax", player.Id)));
				return;
			}

			bool   state		= false;
			string statestring	= null;
			string prefabName	= null;

			// set the parameters
			statestring = args[0].ToLower();

			// make sure we have something to process default to all on
			if (string.IsNullOrEmpty(statestring))
				state = true;
			else if (statestring == "off" || statestring == "false" || statestring == "0" || statestring == "out")
				state = false;
			else if (statestring == "on" || statestring == "true" || statestring == "1" || statestring == "go")
				state = true;
			else
			{
				player.Message(String.Concat(Lang("prefix", player.Id), Lang("state", player.Id)) + " " + statestring);
				return;
			}

			// see if there is a prefabname specified and if so that it is valid
			if (args.Length > 1)
			{
				prefabName = CleanedName(args[1].ToLower());

				if(string.IsNullOrEmpty(prefabName))
					prefabName = "all";
				else if (prefabName.ToUpper() != "ALL" &&
						!IsLightPrefabName(prefabName) &&
						!CanCookShortPrefabName(prefabName) &&
						!IsDevicePrefabName(prefabName)
						)
				{
					player.Message(String.Concat(Lang("prefix") , Lang("bad prefab", player.Id))+ " " + prefabName);
					return;
				}
			}
			else
				prefabName = "all";

			if (prefabName == "all")
			{
				ProcessLights(state, prefabName);
				ProcessDevices(state, prefabName);
			}
			else
			{
				if (IsDevicePrefabName(prefabName))
					ProcessDevices(state, prefabName);
				if (IsLightPrefabName(prefabName) || CanCookShortPrefabName(CleanedName(prefabName)))
					ProcessLights(state, prefabName);
			}

			if (state)
				player.Message(String.Concat(Lang("prefix") , Lang("lights on", player.Id)) + " " + prefabName);
			else
				player.Message(String.Concat(Lang("prefix") , Lang("lights off", player.Id)) + " " + prefabName);
		}
	}
}


// --- End of file: LightsOn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-scaling ---
// --- Original File Path: L/LootScaling/LootScaling.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Loot Scaling", "Kyrah Abattoir/Arainrr", "1.0.0", ResourceId = 1874)]
    [Description("Scale loot spawn rate/density by player count.")]
    internal class LootScaling : RustPlugin
    {
        //NOTE the minimum spawn rate/density are two arbitrary values in the engine from 0.1 to 1.0 (10%/100%)
        //you can override them by passing new values to the server with:
        //
        //spawn.min_rate
        //spawn.max_rate
        //spawn.min_density
        //spawn.max_density
        //
        //I have NOT tested changing these, but setting min_rate/density to 0 is probably NOT a good idea so don't do it!

        private void OnServerInitialized()
        {
            Dictionary<string, bool> newConfig = new Dictionary<string, bool>();
            foreach (SpawnPopulation spawnPopulation in SingletonComponent<SpawnHandler>.Instance.SpawnPopulations)
            {
                if (configData.populationScaling.ContainsKey(spawnPopulation.name))
                {
                    //Well since FacePunch already implemented it all for us, we should probably use it.
                    spawnPopulation.ScaleWithServerPopulation = configData.populationScaling[spawnPopulation.name];
                    newConfig.Add(spawnPopulation.name, configData.populationScaling[spawnPopulation.name]); 
                }
                else
                    newConfig.Add(spawnPopulation.name, false);
            }
            configData.populationScaling = newConfig.OrderBy(x => x.Key).ToDictionary(p => p.Key, o => o.Value);
            SaveConfig();
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            //you can put here which of the spawn categories you wish to enable player count scaling on.
            //Rust will then adjust item density based on the percentage of players online from 10% rate/density to 100% rate/density
            [JsonProperty(PropertyName = "Population Scaling")]
            public Dictionary<string, bool> populationScaling;

            public static ConfigData DefaultConfig()
            {
                return new ConfigData()
                {
                    populationScaling = new Dictionary<string, bool>(),
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = ConfigData.DefaultConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: LootScaling.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limit-rcon ---
// --- Original File Path: L/LimitRCON/LimitRCON.cs ---

﻿using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

namespace Oxide.Plugins
{
    [Info("Limit RCON", "Wulf", "1.0.0")]
    [Description("Limits RCON access to specific IP addresses")]
    class LimitRCON : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Allow local IP addresses")]
            public bool AllowLocal = true;

            [JsonProperty("List of allowed IP addresses to allow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> IpAddresses = new List<string> { "1.1.1.1", "8.8.8.8" };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region IP Handling

        private object OnRconConnection(IPAddress ipAddress)
        {
            if (config.AllowLocal && IsLocalIp(ipAddress.ToString()))
            {
                Log($"{ipAddress} is a local IP address, allowing connection to RCON");
                return null;
            }

            if (!config.IpAddresses.Contains(ipAddress.ToString()))
            {
                Log($"{ipAddress} is not allowed to connect to RCON, denying");
                return true;
            }

            return null;
        }

        private static bool IsLocalIp(string ipAddress)
        {
            string[] split = ipAddress.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
            int[] ip = new[] { int.Parse(split[0]), int.Parse(split[1]), int.Parse(split[2]), int.Parse(split[3]) };
            return ip[0] == 10 || ip[0] == 127 || (ip[0] == 192 && ip[1] == 168) || (ip[0] == 172 && (ip[1] >= 16 && ip[1] <= 31));
        }

        #endregion IP Handling
    }
}


// --- End of file: LimitRCON.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loadoutless ---
// --- Original File Path: L/Loadoutless/Loadoutless.cs ---

﻿using Oxide.Core;
using System;
using System.Collections;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/*
 * This is a partial rewrite 2.0.0
 * Now Supports Skins + Ammo Types + Reset Command
 *
 * Updated API hook
 *
 * This update 2.0.2 fixes issues with commands
 * Updated reset lang msg
 *
 * This update 2.0.3
 * Added ability for multiple loadouts per player assuming they have the permission loadoutless.save
 * Added Select command
 * Added Remove command
 * Added Clear command
 * Updated Save command
 * updated lang files
 * Added Item limits defaults to server stacksize limits
 * Added Auto Limit adjuster based on StackSizeChanges on the server.
 *
 * Warning Delete Lang file!
 * This update 2.0.4
 * Updated lang files
 * Fixed command issues
 * Updated permissions to be cleaner
 *
 * Updated Lang
 * Added overwrite command
 *
 * Update 2.0.7
 * Updated Commands / Code Cleanup
 * Imported WhiteThunders Memory leak patch
 *
 * Update 2.0.8
 * Fixed Item Limits set to 0/enabled not allowing admins to set default loadout.
 *
 * Update 2.0.9
 * Fixed error after creating a ban file and attempting to reset players data files
 *
 * Update 2.1.0
 * Fixed Clearing Data Files
 * Fixed Duplication issues
 * Fixed performance hits on high pop servers now runs coroutines on reset/clear
 *
 * Update 2.1.1
 * Fixes extended mag issue ( now you don't have to re-load to get the 38 limit )
 * Fixes 3 msg responses not being sent properly.
 * Fixed Syntax msg missing /overwrite name command option.
 * Delete lang file
 */

namespace Oxide.Plugins
{
    [Info("Loadoutless", "Khan", "2.1.2")]
    [Description("Players can respawn with a loadout")]
    public class Loadoutless : RustPlugin
    {
        #region Variables

        private const string Default = "loadoutless.spawn";
        private const string Use = "loadoutless.use";
        private const string Admin = "loadoutless.admin";

        private const string FileBanlist = "Loadoutless_itembanlist";
        private const string FileMain = "Loadoutless_folder/";

        private static Loadoutless _instance;

        private Dictionary<string, PlayerLoadout> _playerLoadouts = new Dictionary<string, PlayerLoadout>();

        private PluginConfig _config;

        #endregion

        #region Localization
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error_Insuffarg"] = "Insufficient arguments! player options are \n <color=#32CD32>/loadout save name, overwrite name, remove name, select name</color>",
                ["Error_Insuffarg2"] = "Insufficient arguments! options are \n setdefault : sets server loadout, \n banitem, baninv, removebanitem, \n reset : resets players loadouts to server defaults \n clear : will delete all players saved loadouts",
                ["Error_Noitem"] = "No item selected!",
                ["Error_Itemnotfound"] = "Item not found!",
                ["Error_Filenotexist"] = "Playerfile doesn't exist.",
                ["Error_Creatingnewfile"] = "Creating a new playerfile...",
                ["Cmd_Removebanitem"] = "Item is removed from the banfile.",
                ["Cmd_Removebanitem_notinfile"] = "Item was not banned!",
                ["Cmd_Banitem_already"] = "Item is already banned!",
                ["Cmd_Banitem"] = "Item <color=#32CD32>sucessfully added</color> to the banfile!",
                ["Cmd_Setdefault"] = "Default Server loadout has <color=#32CD32>succesfully been set!</color>",
                ["Cmd_Processing"] = "coroutine has begun processing data files for update. will take a min or two.",
                ["Cmd_Wait"] = "Coroutine is still running please wait a min or two and try again.",
                ["Cmd_Noperm"] = "You don't have the permsission to do that!",
                ["Cmd_Saved"] = "Loadout <color=#32CD32>{0} was sucessfully saved!</color>",
                ["Cmd_inv_added"] = "All inventory Items are saved in the ban file",
                ["Cmd_Reset"] = "All players loadouts have been reset to default \n By user {0}",
                ["Cmd_MaxLoadOut"] = "Maximum number of loadouts is {0} please remove 1 to add another",
                ["Cmd_MaxLimit"] = "{0} stack amount is greater than item stack limit set {1}",
                ["Cmd_Select"] = "Available loadouts are <color=#32CD32> {0} </color>",
                ["Cmd_Remove"] = "Available loadouts to remove are <color=#32CD32> {0} </color>",
                ["Cmd_SelectMia"] = "Loadout {0} doesn't exist, your current loadouts are <color=#32CD32> {1} </color>",
                ["Cmd_Selected"] = "Loadout {0} is now set",
                ["Cmd_Cleared"] = "Player {0} has cleared everyone's loadouts, only default loadout remains",
                ["Cmd_Savedalready"] = "Loadout <color=#32CD32>{0}</color> already exists",
                ["Cmd_NotEnough"] = "You must save a loadout with a name! \n /loadout save primary",
                ["Cmd_NotEnough2"] = "Available loadouts to remove are <color=#32CD32> {0} </color>",
                ["Cmd_Overwritten"] = "Loadout <color=#32CD32>{0} was successfully overwritten!</color>",
                ["Cmd_Overwrite"] = "Available loadouts to overwite are <color=#32CD32> {0} </color>",

            }, this);
        }

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = new PluginConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys)) return;

                PrintWarning("Loaded updated config.");
                SaveConfig();
            }
            catch
            {
                PrintWarning("You have messed up your config please run it through Json Validation @ https://jsonlint.com/");
                //LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private void CheckConfig()
        {
            foreach (ItemDefinition item in ItemManager.itemList)
            {
                if (!(item.isHoldable || item.isUsable || item.isWearable)) continue;
                if (!_config.Limits.ContainsKey(item.shortname))
                {
                    _config.Limits.Add(item.shortname, new Limit
                    {
                        DisplayName = item.displayName.english,
                        Amount = item.stackable
                    });
                }

                if (!_config.EnableAutoLimits) continue;
                _config.Limits[item.shortname].DisplayName = item.displayName.english;
                _config.Limits[item.shortname].Amount = item.stackable;
            }

            if (_config.DefaultLoadout == null)
            {
                _config.DefaultLoadout = new List<LoadoutItem>
                {
                    new LoadoutItem
                    {
                        Itemid = 20489901,
                        Amount = 1,
                        Slot = 0,
                        Container = "wear",
                        Bp = false,
                        Weapon = false
                    },
                    new LoadoutItem
                    {
                        Itemid = -1754948969,
                        Amount = 1,
                        Slot = 0,
                        Container = "main",
                        Bp = false,
                        Weapon = false
                    },
                    new LoadoutItem
                    {
                        Itemid = 963906841,
                        Amount = 1,
                        Slot = 0,
                        Container = "belt",
                        Bp = false,
                        Weapon = false
                    },
                    new LoadoutItem
                    {
                        Itemid = 795236088,
                        Amount = 1,
                        Slot = 1,
                        Container = "belt",
                        Bp = false,
                        Weapon = false
                    },
                    new LoadoutItem
                    {
                        Itemid = -1583967946,
                        Amount = 1,
                        Slot = 2,
                        Container = "belt",
                        Bp = false,
                        Weapon = false
                    },
                    new LoadoutItem
                    {
                        Itemid = 171931394,
                        Amount = 1,
                        Slot = 3,
                        Container = "belt",
                        Bp = false,
                        Weapon = false
                    },
                };
            }
            SaveConfig();
        }

        public class Limit
        {
            public string DisplayName;
            public double Amount;
        }

        private class PluginConfig
        {
            [JsonProperty("Set Max Player Loadouts", Order = 1)] public int MaxLoadouts = 3;

            [JsonProperty("Enable Item Limits", Order = 2)] public bool EnableLimits = true;

            [JsonProperty("Enable Auto Update Limits", Order = 3)] public bool EnableAutoLimits = false;

            [JsonProperty(Order = 4)] public List<LoadoutItem> DefaultLoadout;

            [JsonProperty("Item Loadout Limits Defaults to your Servers Stack Size", Order = 5)]

            public Dictionary<string, Limit> Limits = new Dictionary<string, Limit>();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(Use, this);
            permission.RegisterPermission(Default, this);
            permission.RegisterPermission(Admin, this);
            _instance = this;
        }

        private void OnServerInitialized()
        {
            CheckConfig();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                PlayerLoadout.TryLoad(player);
            }
        }

        private void Unload()
        {
            if (_coroutine != null)
                ServerMgr.Instance.StopCoroutine(_coroutine);

            _instance = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            PlayerLoadout.TryLoad(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, Default))
            {
                GiveLoadout(player);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerLoadouts.Remove(player.UserIDString);
        }

        #endregion

        #region Methodes

        private Coroutine _coroutine;

        private IEnumerator ResetPlayersLoadout()
        {
            string[] files = Interface.Oxide.DataFileSystem.GetFiles(FileMain);

            if (files == null)
            {
                _coroutine = null;
                yield return null;
            }

            int count = 0;
            foreach (string filePath in files)
            {
                if (filePath.Contains(FileBanlist)) continue;
                string fileName = RemoveFilePath(filePath).Replace(".json", "");
                if (_playerLoadouts.ContainsKey(fileName))
                {
                    _playerLoadouts[fileName].AvailableLoadouts["default"] = _config.DefaultLoadout;
                    _playerLoadouts[fileName].Loadout = "default";

                    Interface.Oxide.DataFileSystem.WriteObject($"{FileMain}/{fileName}", _playerLoadouts[fileName]);
                }
                else
                {
                    PlayerLoadout playerLoadout = Interface.Oxide.DataFileSystem.ReadObject<PlayerLoadout>($"{FileMain}/{fileName}");
                    playerLoadout.AvailableLoadouts["default"] = _config.DefaultLoadout;
                    playerLoadout.Loadout = "default";
                    playerLoadout.Save();
                }

                count++;
                Puts($"Setting Defaults Loadouts processing file {count} {files.Length - 1}");

                yield return CoroutineEx.waitForSeconds(0.5f);
            }

            _coroutine = null;
            yield return null;
        }

        private IEnumerator ClearPlayersLoadouts()
        {
            string[] files = Interface.Oxide.DataFileSystem.GetFiles(FileMain);

            if (files == null)
            {
                _coroutine = null;
                yield break;
            }

            int count = 0;
            foreach (string filePath in files)
            {
                if (filePath.Contains(FileBanlist)) continue;
                string fileName = RemoveFilePath(filePath).Replace(".json", "");
                if (_playerLoadouts.ContainsKey(fileName))
                {
                    _playerLoadouts[fileName].AvailableLoadouts.Clear();
                    _playerLoadouts[fileName].AvailableLoadouts["default"] = _config.DefaultLoadout;
                    _playerLoadouts[fileName].Loadout = "default";
                    Interface.Oxide.DataFileSystem.WriteObject($"{FileMain}/{fileName}", _playerLoadouts[fileName]);
                }
                else
                {
                    PlayerLoadout playerLoadout = Interface.Oxide.DataFileSystem.ReadObject<PlayerLoadout>($"{FileMain}/{fileName}");
                    playerLoadout.AvailableLoadouts.Clear();
                    playerLoadout.AvailableLoadouts["default"] = _config.DefaultLoadout;
                    playerLoadout.Loadout = "default";
                    playerLoadout.Save();
                }

                count++;
                Puts($"Clearing All Loadouts processing file {count} {files.Length - 1}");

                yield return CoroutineEx.waitForSeconds(0.5f);
            }

            _coroutine = null;
            yield return null;
        }

        public string RemoveFilePath(string value)
        {
            value = value.Substring(value.LastIndexOf('/') + 1);

            return value;
        }

        public void AddInvBan(Item[] invItems)
        {
            List<string> banFile = LoadBanFile();

            foreach (var item in invItems)
            {
                if (CheckBanFile(item.info.itemid.ToString()) == false)
                {
                    banFile.Add(item.info.itemid.ToString());
                }
                else
                {
                    PrintToConsole(item.info.shortname + "already in banfile");
                }

                UpdateBanFile(banFile);
            }
        }

        void UpdateBanFile(List<string> ban_list)
        {
            Interface.Oxide.DataFileSystem.WriteObject<string>(FileMain + FileBanlist, JsonConvert.SerializeObject(ban_list));
        }

        bool CheckBanFile(string itemid)
        {
            List<string> banFile = LoadBanFile();

            return banFile.Contains(itemid);
        }

        List<string> RemoveItemBanlist(List<string> banfile, string itemid)
        {
            List<string> newBanfile = new List<string>();
            foreach (string item in banfile)
            {
                if (item != itemid)
                {
                    newBanfile.Add(item);
                }
            }
            return newBanfile;
        }

        List<string> LoadBanFile()
        {
            List<string> banFile;
            //When ban file is needed checks if it exists if not, it will create one.
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(FileMain + FileBanlist))
            {
                banFile = new List<string>();
            }
            else
            {
                string rawBanfile = Interface.Oxide.DataFileSystem.ReadObject<string>(FileMain + FileBanlist);
                banFile = JsonConvert.DeserializeObject<List<string>>(rawBanfile);
            }

            return banFile;
        }

        private static List<LoadoutItem> GetPlayerLoadout(BasePlayer player, bool admin = false)
        {
            List<LoadoutItem> loadoutItems = new List<LoadoutItem>();

            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item == null) continue;
                if (admin == false)
                {
                    if (_instance._config.EnableLimits && _instance._config.Limits.ContainsKey(item.info.shortname) && item.amount > _instance._config.Limits[item.info.shortname].Amount)
                    {
                        _instance.SendMessage(player,_instance.Lang("Cmd_MaxLimit", player.UserIDString, item.info.displayName.english, _instance._config.Limits[item.info.shortname].Amount));
                        return null;
                    }
                }
                LoadoutItem loadoutItem = ProcessItem(item, "wear");
                loadoutItems.Add(loadoutItem);
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item == null) continue;
                if (admin == false)
                {
                    if (_instance._config.EnableLimits && _instance._config.Limits.ContainsKey(item.info.shortname) && item.amount > _instance._config.Limits[item.info.shortname].Amount)
                    {
                        _instance.SendMessage(player,_instance.Lang("Cmd_MaxLimit", player.UserIDString, item.info.displayName.english, _instance._config.Limits[item.info.shortname].Amount));
                        return null;
                    }
                }
                LoadoutItem loadoutItem = ProcessItem(item, "main");
                loadoutItems.Add(loadoutItem);
            }

            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item == null) continue;
                if (admin == false)
                {
                    if (_instance._config.EnableLimits && _instance._config.Limits.ContainsKey(item.info.shortname) && item.amount > _instance._config.Limits[item.info.shortname].Amount)
                    {
                        _instance.SendMessage(player,_instance.Lang("Cmd_MaxLimit", player.UserIDString, item.info.displayName.english, _instance._config.Limits[item.info.shortname].Amount));
                        return null;
                    }
                }
                LoadoutItem loadoutItem = ProcessItem(item, "belt");
                loadoutItems.Add(loadoutItem);
            }

            return loadoutItems;
        }

        private static LoadoutItem ProcessItem(Item item, string container)
        {
            LoadoutItem iItem = new LoadoutItem();
            iItem.Amount = item.amount;
            iItem.Mods = new List<int>();
            iItem.Container = container;
            iItem.Skinid = item.skin;
            iItem.Itemid = item.info.itemid;
            iItem.Weapon = false;
            iItem.Slot = item.position;
            iItem.Ammotype = 0;
            iItem.AmmoAmount = 0;

            if (item.info.category.ToString() != "Weapon")
            {
                return iItem;
            }

            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;

            if (weapon == null || weapon.primaryMagazine == null)
            {
                return iItem;
            }

            iItem.Weapon = true;
            iItem.Ammotype = weapon.primaryMagazine.ammoType.itemid;
            iItem.AmmoAmount = weapon.primaryMagazine.contents;

            if (item.contents == null)
            {
                return iItem;
            }

            foreach (var mod in item.contents.itemList)
            {
                if (mod.info.itemid != 0)
                {
                    iItem.Mods.Add(mod.info.itemid);
                }
            }

            return iItem;
        }

        private static Item BuildWeapon(int id, ulong skin, int Ammotype, int ammoAmount, List<int> mods)
        {
            Item item = CreateByItemID(id, 1, skin);
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                weapon.primaryMagazine.contents = ammoAmount;
                weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(Ammotype);
            }

            if (mods == null)
            {
                return item;
            }

            bool mag = false;
            foreach (var mod in mods)
            {
                item.contents.AddItem(ItemManager.FindItemDefinition(mod), 1);
                if (mod == 2005491391) //extended mag
                {
                    mag = true;
                }
            }

            if (mag)
            {
                int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(weapon, (x => x.magazineCapacity), (y => y.scalar), 1f) * weapon.primaryMagazine.definition.builtInSize);
                weapon.primaryMagazine.contents = ammoAmount;
                weapon.primaryMagazine.capacity = num;
            }

            return item;
        }

        private static Item BuildItem(int itemid, int amount, ulong skin)
        {
            if (amount < 1) amount = 1;
            Item item = CreateByItemID(itemid, amount, skin);
            return item;
        }

        private static Item CreateByItemID(int itemID, int amount = 1, ulong skin = 0)
        {
            return ItemManager.CreateByItemID(itemID, amount, skin);
        }

        private static bool GiveItem(PlayerInventory inv, Item item, ItemContainer container = null, int position = 0)
        {
            if (item == null) { return false; }
            return container != null && item.MoveToContainer(container, position, true) || item.MoveToContainer(inv.containerMain, position, true) || item.MoveToContainer(inv.containerBelt, position, true);
        }

        List<LoadoutItem> CheckBannedList(List<LoadoutItem> list)
        {
            List<LoadoutItem> newList = new List<LoadoutItem>();
            List<string> banFile = LoadBanFile();

            foreach (LoadoutItem item in list)
            {
                if (!banFile.Contains(item.Itemid.ToString()))
                {
                    newList.Add(item);
                }
            }

            return newList;
        }

        public object GiveLoadout(BasePlayer player)
        {
            return PlayerLoadout.Find(player)?.GiveLoadout(player);
        }

        public void SendMessage(BasePlayer player, string message)
        {
            PrintToChat(player, lang.GetMessage(message, this, player.UserIDString));
        }

        #endregion

        #region Classes

        public class PlayerLoadout
        {
            public ulong ID;
            public string Name;
            //public List<LoadoutItem> Items = new List<LoadoutItem>();
            public string Loadout;
            public Dictionary<string, List<LoadoutItem>> AvailableLoadouts = new Dictionary<string, List<LoadoutItem>>();

            internal static void TryLoad(BasePlayer player)
            {
                if (Find(player) != null)
                {
                    return;
                }

                PlayerLoadout data = Interface.Oxide.DataFileSystem.ReadObject<PlayerLoadout>($"{FileMain}/{player.userID}");

                if (data == null || data.ID == 0)
                {
                    data = new PlayerLoadout{ID = player.userID, Name = player.displayName, Loadout = "default", AvailableLoadouts = new Dictionary<string, List<LoadoutItem>>{{"default", _instance._config.DefaultLoadout}}};
                }
                else
                {
                    data.Update(player);
                }

                data.Save();

                if (!_instance._playerLoadouts.ContainsKey(player.UserIDString))
                {
                    _instance._playerLoadouts.Add(player.UserIDString, data);
                }
            }

            internal void Update(BasePlayer player)
            {
                ID = player.userID;
                Name = player.displayName;
                
                Save();
            }

            internal void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{FileMain}/{ID}", this);
            }

            internal static PlayerLoadout Find(BasePlayer player)
            {
                PlayerLoadout playerLoadout;

                return _instance._playerLoadouts.TryGetValue(player.UserIDString, out playerLoadout) ? playerLoadout : null;
            }

            internal object GiveLoadout(BasePlayer player)
            {
                if (!AvailableLoadouts.ContainsKey(Loadout))
                {
                    return null;
                }
                player.inventory.Strip();

                foreach (var kitem in AvailableLoadouts[Loadout])
                {
                    GiveItem(player.inventory,
                        kitem.Weapon
                            ? BuildWeapon(kitem.Itemid, kitem.Skinid, kitem.Ammotype, kitem.AmmoAmount, kitem.Mods)
                            : BuildItem(kitem.Itemid, kitem.Amount, kitem.Skinid),
                        kitem.Container == "belt"
                            ? player.inventory.containerBelt
                            : kitem.Container == "wear"
                                ? player.inventory.containerWear
                                : player.inventory.containerMain, kitem.Slot);
                }

                return true;
            }
        }

        public class LoadoutItem
        {
            public int Itemid;
            public bool Bp;
            public ulong Skinid;
            public string Container;
            public int Slot;
            public int Amount;
            public bool Weapon;
            public int Ammotype;
            public int AmmoAmount;
            public List<int> Mods = new List<int>();
        }

        #endregion

        #region Commands

        [ChatCommand("loadout")]
        private void LoadoutLessCommand(BasePlayer player, string command, string[] args)
        {
            if (_coroutine != null)
            {
                SendMessage(player, "Cmd_Wait");
                return;
            }
            if (args.Length == 0)
            {
                if (permission.UserHasPermission(player.UserIDString, Admin))
                {
                    SendMessage(player,"Error_Insuffarg2");
                }

                if (permission.UserHasPermission(player.UserIDString, Use))
                {
                    SendMessage(player, "Error_Insuffarg");
                }
            }
            else
            {
                PlayerLoadout user = PlayerLoadout.Find(player);
                switch (args[0].ToLower())
                {
                    case "overwrite":
                        if (permission.UserHasPermission(player.UserIDString, Use))
                        {
                            if (args.Length < 2)
                            {
                                SendMessage(player, Lang("Cmd_NotEnough", player.UserIDString));
                                return;
                            }
                            if (!user.AvailableLoadouts.ContainsKey(args[1]))
                            {
                                SendMessage(player, Lang("Cmd_Overwrite", player.UserIDString, string.Join("\n", user.AvailableLoadouts.Keys.ToArray())));
                                return;
                            }

                            user.Loadout = args[1];
                            List<LoadoutItem> loadout = GetPlayerLoadout(player);
                            if (loadout == null) return;
                            user.AvailableLoadouts[args[1]] = CheckBannedList(loadout);
                            SendMessage(player, Lang("Cmd_Overwritten", player.UserIDString, user.Loadout));
                            user.Save();
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "save":
                        if (permission.UserHasPermission(player.UserIDString, Use))
                        {
                            if (args.Length < 2)
                            {
                                SendMessage(player, Lang("Cmd_NotEnough", player.UserIDString));
                                return;
                            }
                            if (user.AvailableLoadouts.Count >= _config.MaxLoadouts)
                            {
                                SendMessage(player, Lang("Cmd_MaxLoadOut", player.UserIDString, _config.MaxLoadouts));
                                return;
                            }
                            if (user.AvailableLoadouts.ContainsKey(args[1]))
                            {
                                SendMessage(player, Lang("Cmd_Savedalready", player.UserIDString, args[1]));
                                return;
                            }
                            user.Loadout = args[1];
                            List<LoadoutItem> loadout = GetPlayerLoadout(player);
                            if (loadout == null) return;
                            user.AvailableLoadouts.Add(args[1], CheckBannedList(loadout));
                            SendMessage(player, Lang("Cmd_Saved", player.UserIDString, user.Loadout));
                            user.Save();
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "remove":
                        if (permission.UserHasPermission(player.UserIDString, Use))
                        {
                            if (args.Length < 2)
                            {
                                SendMessage(player, _instance.Lang("Cmd_Remove", player.UserIDString, string.Join("\n", user.AvailableLoadouts.Keys.ToArray())));
                                return;
                            }
                            if (!user.AvailableLoadouts.ContainsKey(args[1]))
                            {
                                SendMessage(player, _instance.Lang("Cmd_Remove", player.UserIDString, string.Join("\n", user.AvailableLoadouts.Keys.ToArray())));
                                return;
                            }

                            user.AvailableLoadouts.Remove(args[1]);
                            user.Save();
                            SendMessage(player, $"Loadout {args[1]} was removed");
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "select":
                        if (permission.UserHasPermission(player.UserIDString, Use))
                        {
                            if (args.Length == 1)
                            {
                                SendMessage(player, _instance.Lang("Cmd_Select", player.UserIDString, string.Join("\n", user.AvailableLoadouts.Keys.ToArray())));
                                return;
                            }
                            if (!user.AvailableLoadouts.ContainsKey(args[1]))
                            {
                                SendMessage(player, _instance.Lang("Cmd_SelectMia", player.UserIDString, args[1], string.Join("\n", user.AvailableLoadouts.Keys.ToArray())));
                                return;
                            }

                            user.Loadout = args[1];
                            user.Save();
                            SendMessage(player, _instance.Lang("Cmd_Selected", player.UserIDString, args[1]));
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "setdefault":
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            List<LoadoutItem> loadout = GetPlayerLoadout(player, true);
                            if (loadout == null) return;
                            _config.DefaultLoadout = loadout;
                            SaveConfig();
                            _coroutine = ServerMgr.Instance.StartCoroutine(ResetPlayersLoadout());
                            SendMessage(player, "Cmd_Setdefault");
                            SendMessage(player, "Cmd_Processing");
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "banitem":
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            try
                            {
                                List<string> ban_list = LoadBanFile();
                                string itemid = player.GetActiveItem().info.itemid.ToString();
                                if (CheckBanFile(itemid) == false)
                                {
                                    ban_list.Add(itemid);
                                    UpdateBanFile(ban_list);
                                    SendMessage(player, "Cmd_Banitem");
                                }
                                else
                                {
                                    SendMessage(player, "Cmd_Banitem_already");
                                }
                            }
                            catch (NullReferenceException)
                            {

                                SendMessage(player, "Error_Noitem");

                            }
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "removebanitem":
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            try
                            {
                                string itemid = player.GetActiveItem().info.itemid.ToString();
                                if (CheckBanFile(itemid) == true)
                                {
                                    UpdateBanFile(RemoveItemBanlist(LoadBanFile(), itemid));
                                    SendMessage(player, "Cmd_Removebanitem");
                                }
                                else
                                {
                                    SendMessage(player, "Cmd_Removebanitem_notinfile");
                                }
                            }
                            catch (NullReferenceException)
                            {
                                SendMessage(player, "Cmd_Error_Noitem");
                            }
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "baninv":
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            AddInvBan(player.inventory.AllItems());
                            SendMessage(player, "Cmd_inv_added");
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "reset":
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            _coroutine = ServerMgr.Instance.StartCoroutine(ResetPlayersLoadout());
                            SendMessage(player, Lang("Cmd_Reset", player.UserIDString, player.displayName));
                            SendMessage(player, "Cmd_Processing");
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    case "clear" :
                        if (permission.UserHasPermission(player.UserIDString, Admin))
                        {
                            _coroutine = ServerMgr.Instance.StartCoroutine(ClearPlayersLoadouts());
                            SendMessage(player, _instance.Lang("Cmd_Cleared", player.UserIDString, player.displayName));
                            SendMessage(player, "Cmd_Processing");
                        }
                        else
                        {
                            SendMessage(player, "Cmd_Noperm");
                        }
                        break;
                    default:
                        SendMessage(player, "Error_Insuffarg");
                        break;
                }
            }
        }

        #endregion
    }
}

// --- End of file: Loadoutless.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/localize ---
// --- Original File Path: L/Localize/Localize.cs ---

//#define DEBUG
// Requires: TranslationAPI

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Localize", "Wulf", "1.0.1")]
    [Description("Generates localization files for other languages using existing plugin localization")]
    public class Localize : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandLocalize"] = "localize",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["LocalizationExists"] = "Localization already exists for '{0}'",
                ["PluginNotFound"] = "Plugin '{0}' could not be found or is not loaded",
                ["SameLanguage"] = "Cannot localize to and from the same language ('{0}' and '{1}')",
                ["StringsToTranslate"] = "Translating {0} strings from '{1}'",
                ["StringsTranslated"] = "Translated {0} strings to '{1}'",
                ["TranslationFailed"] = "Translation failed else nothing to translate. Please try again later",
                ["UsageLocalize"] = "Usage: {0} <plugin name> <language code>"
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private Plugin TranslationAPI;

        private const string permUse = "localize.use";

        private void OnServerInitialized()
        {
            AddLocalizedCommand(nameof(CommandLocalize));

            permission.RegisterPermission(permUse, this);
            MigratePermission("langgen.use", permUse);

            /*foreach (string language in config.DefaultLanguages) // TODO: Add configuration check to enable/disable this
            {
                // TODO: Generate default languages from configuration
            }*/
        }

        #endregion Initialization

        #region Localization

        // TODO: Add command to output localization for specified language, and see locale list

        private void CommandLocalize(IPlayer player, string command, string[] args)
        {
            // TODO: Add optional arg to force overwriting existing

            if (!player.HasPermission(permUse))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args.Length < 2)
            {
                Message(player, "CommandUsage", command);
                return;
            }

            string pluginName = args[0];
            Plugin[] pluginList = plugins.GetAll().ToArray();
            Plugin plugin = pluginList.FirstOrDefault(x => x.Name.ToLower().Equals(pluginName.ToLower()));
            if (plugin == null)
            {
                Message(player, "PluginNotFound", pluginName);
                return;
            }

            string[] pluginLocales = lang.GetLanguages(plugin);
            string langTo = args[1];

            bool overwrite = false;
            if (args.Length >= 3)
            {
                bool.TryParse(args[2], out overwrite);
            }

            string langFrom = pluginLocales.Contains(lang.GetServerLanguage()) ? lang.GetServerLanguage() : pluginLocales.Contains("en") ? "en" : pluginLocales[0];
            Dictionary<string, string> fromLang = lang.GetMessages(langFrom, plugin);

            if (pluginLocales.Contains(langTo) && !overwrite) // TODO: Configuration check for overwrite
            {
                Dictionary<string, string> toLang = lang.GetMessages(langTo, plugin);
                if (fromLang.Count == toLang.Count && fromLang.Keys.SequenceEqual(toLang.Keys))
                {
                    Message(player, "LocalizationExists", langTo);
                    return;
                }
            }

            if (langFrom == langTo)
            {
                Message(player, "SameLanguage", langTo, langFrom);
                return;
            }

            Message(player, "StringsToTranslate", fromLang.Count, langFrom);

            int processed = 0;
            Dictionary<string, string> newLang = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> pair in fromLang)
            {
                string original = pair.Value.Replace("><", "> <").Replace("<", "< ").Replace(">", " >").Replace("#", "/=").Replace(".", "/_"); // TODO: Fix some languages not translating when > is by (
                Action<string> callback = translation =>
                {
                    processed++;

                    if (translation == original)
                    {
                        if (processed == fromLang.Count)
                        {
                            Message(player, "TranslationFailed");
                        }
                        return;
                    }

                    translation = translation.Replace("><", "> <").Replace("< ", "<").Replace(" >", ">").Replace("/=", "#") // TODO: Find a better way to do this
                        .Replace("/ =", "#").Replace("# ", "#").Replace("/_", ".").Replace("/ _", ".").Replace("</ ", "</")
                        .Replace("{ ", "{").Replace(" }", "}").Replace(" &gt;", ">");
#if DEBUG
                    player.Reply($"Original: {pair.Value}");
                    player.Reply($"Translated: {translation}");
#endif
                    newLang.Add(pair.Key, translation);

                    if (processed == fromLang.Count)
                    {
                        lang.RegisterMessages(newLang, plugin, langTo);

                        Message(player, "StringsTranslated", processed, langTo);
#if DEBUG
                        player.Reply($"Available languages: {string.Join(", ", lang.GetLanguages(plugin))}");
#endif
                    }
                };

                TranslationAPI.Call("Translate", original, langTo, langFrom, callback);
            }
        }

        #endregion Localization

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        private void MigratePermission(string oldPerm, string newPerm)
        {
            foreach (string groupName in permission.GetPermissionGroups(oldPerm))
            {
                permission.GrantGroupPermission(groupName, newPerm, null);
                permission.RevokeGroupPermission(groupName, oldPerm);
            }

            foreach (string playerId in permission.GetPermissionUsers(oldPerm))
            {
                permission.GrantUserPermission(Regex.Replace(playerId, "[^0-9]", ""), newPerm, null);
                permission.RevokeUserPermission(Regex.Replace(playerId, "[^0-9]", ""), oldPerm);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: Localize.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-multiplier ---
// --- Original File Path: L/LootMultiplier/LootMultiplier.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Loot Multiplier", "Rick", "1.3.0")]
    [Description("Multiply items in all loot containers in the game")]
    public class LootMultiplier : RustPlugin
    {
        private static LootMultiplier _instance;
        private bool _initialised = false;

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalS = new GlobalSettings();

            [JsonProperty(PropertyName = "Items and containers settings")]
            public ItemSettings itemS = new ItemSettings();

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Default Multiplier for new containers")]
                public int defaultContainerMultiplier = 1;

                [JsonProperty(PropertyName = "Default Multiplier for new Categories")]
                public int defaultCategoryMultiplier = 1;

                [JsonProperty(PropertyName = "Multiply items with condition")]
                public bool multiplyItemsWithCondition = false;

                [JsonProperty(PropertyName = "Multiply blueprints")]
                public bool multiplyBlueprints = false;

                [JsonProperty(PropertyName = "Delay after spawning container to multiply it")]
                public float delay = 1f;

            }

            public class ItemSettings
            {
                [JsonProperty(PropertyName = "Containers list (shortPrefabName: multiplier)")]
                public Dictionary<string, int> containers = new Dictionary<string, int>()
                {
                    {"bradley_crate", 1},
                    {"codelockedhackablecrate", 1},
                    {"codelockedhackablecrate_oilrig", 1},
                    {"crate_basic", 1},
                    {"crate_elite", 1},
                    {"crate_mine", 1},
                    {"crate_normal", 1},
                    {"crate_normal_2", 1},
                    {"crate_normal_2_food", 1},
                    {"crate_normal_2_medical", 1},
                    {"crate_tools", 1},
                    {"crate_underwater_advanced", 1},
                    {"crate_underwater_basic", 1},
                    {"foodbox", 1},
                    {"heli_crate", 1},
                    {"loot-barrel-1", 1},
                    {"loot-barrel-2", 1},
                    {"loot_barrel_1", 1},
                    {"loot_barrel_2", 1},
                    {"minecart", 1},
                    {"oil_barrel", 1},
                    {"supply_drop", 1},
                    {"trash-pile-1", 1},
                    {"vehicle_parts", 1},
                    {"crate_ammunition", 1},
                    {"crate_food_1", 1},
                    {"crate_food_2", 1},
                    {"crate_fuel", 1},
                    {"roadsign1", 1},
                    {"roadsign2", 1},
                    {"roadsign4", 1},
                    {"roadsign5", 1},
                    {"roadsign6", 1},
                    {"roadsign7", 1},
                    {"roadsign8", 1},
                    {"roadsign9", 1},
                    {"tech_parts_1", 1},
                    {"tech_parts_2", 1},
                    {"wagon_crate_normal", 1}
                };

                [JsonProperty(PropertyName = "Categories list (Category: multiplier)")]
                public Dictionary<string, int> categories = new Dictionary<string, int>()
                {
                    {"Ammunition", 1},
                    {"Attire", 1},
                    {"Component", 1},
                    {"Construction", 1},
                    {"Electrical", 1},
                    {"Food", 1},
                    {"Fun", 1},
                    {"Items", 1},
                    {"Medical", 1},
                    {"Misc", 1},
                    {"Resources", 1},
                    {"Tool", 1},
                    {"Traps", 1},
                    {"Weapon", 1}
                };

                [JsonProperty(PropertyName = "Items list (shortname: multiplier)")]
                public Dictionary<string, int> items = new Dictionary<string, int>()
                {
                    {"metalpipe", 1},
                    {"scrap", 1},
                    {"tarp", 1}
                };

                [JsonProperty(PropertyName = "Item | Multiplier Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> multiblacklist = new List<string>()
                {
                    {"Attire"},
                    {"Weapon"}
                };

                [JsonProperty(PropertyName = "Item | Item Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> blacklistitems = new List<string>()
                {
                    {"ammo.rocket.smoke"}
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                configData = Config.ReadObject<ConfigData>();

                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        #endregion

        #region Oxide Hooks

        private void OnLootSpawn(StorageContainer container)
        {
            timer.Once(configData.globalS.delay, () =>
            {
                Multiply(container);
            });
        }

        private void OnServerInitialised()
        {
            _instance = this;
            _initialised = true;
            LoadConfig();
            ItemManager.Initialize();
        }
        private void Unload()
        {
            _instance = null;
            _initialised = false;
        }
        #endregion

        #region Core

        private void Multiply(StorageContainer container)
        {
            if (container == null) return;

            int containerMultiplier = GetContainerMultiplier(container.ShortPrefabName);

            foreach (var item in container.inventory.itemList)
            {
                var shortname = item.info.shortname;
                var category = item.info.category.ToString();
                if (configData.itemS.blacklistitems.Contains(shortname) || configData.itemS.blacklistitems.Contains(category))
                    continue;

                if (configData.itemS.multiblacklist.Contains(shortname) || configData.itemS.multiblacklist.Contains(category))
                    continue;

                if (!configData.globalS.multiplyItemsWithCondition && item.hasCondition)
                    continue;

                if (!configData.globalS.multiplyBlueprints && item.IsBlueprint())
                    continue;

                int categoryMultiplier = GetCategoryMultiplier(category);
                int itemMultiplier;
                if (!configData.itemS.items.TryGetValue(shortname, out itemMultiplier))
                {
                    itemMultiplier = 1;
                }

                if (containerMultiplier * categoryMultiplier * itemMultiplier <= 1)
                {
                    continue;
                }

                item.amount *= containerMultiplier * categoryMultiplier * itemMultiplier;
            }
        }

        #endregion

        #region Helpers
        private int GetContainerMultiplier(string containerName)
        {
            int multiplier;
            if (configData.itemS.containers.TryGetValue(containerName, out multiplier))
            {
                return multiplier;
            }

            configData.itemS.containers[containerName] = configData.globalS.defaultContainerMultiplier;
            configData.itemS.containers = SortDictionary(configData.itemS.containers);
            SaveConfig();
            return configData.globalS.defaultContainerMultiplier;
        }

        private int GetCategoryMultiplier(string category)
        {
            int multiplier;
            if (configData.itemS.categories.TryGetValue(category, out multiplier))
            {
                return multiplier;
            }

            configData.itemS.categories[category] = configData.globalS.defaultCategoryMultiplier;
            configData.itemS.categories = SortDictionary(configData.itemS.categories);
            SaveConfig();
            return configData.globalS.defaultContainerMultiplier;
        }
        private Dictionary<string, int> SortDictionary(Dictionary<string, int> dic)
        {
            return dic.OrderBy(key => key.Key)
                .ToDictionary(key => key.Key, value => value.Value);
        }

        #endregion Helpers
    }
}

// --- End of file: LootMultiplier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/lock-master ---
// --- Original File Path: L/LockMaster/LockMaster.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Newtonsoft.Json;


namespace Oxide.Plugins
{
    [Info("Lock Master", "FastBurst", "1.1.8")]
    [Description("Lock all your storages and deployables")]
    class LockMaster : RustPlugin
    {
        #region Vars
        private static bool isPlayer(ulong id) => id > 76560000000000000L;
        private const string COMPOSTER_PREFAB = "assets/prefabs/deployable/composter/composter.prefab";
        private const string DROPBOX_PREFAB = "assets/prefabs/deployable/dropbox/dropbox.deployed.prefab";
        private const string VENDING_PREFAB = "assets/prefabs/deployable/vendingmachine/vendingmachine.deployed.prefab";
        private const string FURNACE_PREFAB = "assets/prefabs/deployable/furnace/furnace.prefab";
        private const string LARGE_FURNACE_PREFAB = "assets/prefabs/deployable/furnace.large/furnace.large.prefab";
        private const string REFINERY_PREFAB = "assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab";
        private const string BBQ_PREFAB = "assets/prefabs/deployable/bbq/bbq.deployed.prefab";
        private const string SMALL_PLANTER_PREFAB = "assets/prefabs/deployable/planters/planter.small.deployed.prefab";
        private const string LARGE_PLANTER_PREFAB = "assets/prefabs/deployable/planters/planter.large.deployed.prefab";
        private const string STATIC_REFINERY_PREFAB = "assets/bundled/prefabs/static/small_refinery_static.prefab";
        private const string STATIC_BBQ_PREFAB = "assets/bundled/prefabs/static/bbq.static.prefab";
        private const string HITCH_PREFAB = "assets/prefabs/deployable/hitch & trough/hitchtrough.deployed.prefab";
        private const string MIXINGTABLE_PREFAB = "assets/prefabs/deployable/mixingtable/mixingtable.deployed.prefab";
        public static LockMaster Instance;
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            Instance = this;

            permission.RegisterPermission(configData.GeneralSettings.permissionName, this);
            cmd.AddChatCommand(configData.GeneralSettings.commandOption, this, "CmdRefresh");
        }

        private void CmdRefresh(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, configData.GeneralSettings.permissionName))
            {
                Message(player, "Usage");
                return;
            }
            NextTick(() =>
            {
                if (configData.ConfigSettings.lockOvens)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseOven>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            if (entity is BaseOven && (!entity.PrefabName.Contains("bbq.static", CompareOptions.IgnoreCase) || !entity.PrefabName.Contains("small_refinery_static", CompareOptions.IgnoreCase)))
                            {
                                var oven = entity as BaseOven;
                                oven.isLockable = true;
                                oven.SendNetworkUpdate();
                                oven.SendNetworkUpdateImmediate(true);
                            }
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseOven>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            if (entity is BaseOven && (!entity.PrefabName.Contains("bbq.static", CompareOptions.IgnoreCase) || !entity.PrefabName.Contains("small_refinery_static", CompareOptions.IgnoreCase)))
                            {
                                var oven = entity as BaseOven;
                                oven.isLockable = false;
                                oven.SendNetworkUpdate();
                                oven.SendNetworkUpdateImmediate(true);
                            }
                        }
                    }

                if (configData.ConfigSettings.lockHitch)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<HitchTrough>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var troughs = entity as HitchTrough;
                            troughs.isLockable = true;
                            troughs.SendNetworkUpdate();
                            troughs.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<HitchTrough>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var troughs = entity as HitchTrough;
                            troughs.isLockable = false;
                            troughs.SendNetworkUpdate();
                            troughs.SendNetworkUpdateImmediate(true);
                        }
                    }


                if (configData.ConfigSettings.lockComposter)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<Composter>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var composters = entity as Composter;
                            composters.isLockable = true;
                            composters.SendNetworkUpdate();
                            composters.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<Composter>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var composters = entity as Composter;
                            composters.isLockable = false;
                            composters.SendNetworkUpdate();
                            composters.SendNetworkUpdateImmediate(true);
                        }
                    }

                if (configData.ConfigSettings.lockDropBox)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<DropBox>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var dropboxes = entity as DropBox;
                            dropboxes.isLockable = true;
                            dropboxes.SendNetworkUpdate();
                            dropboxes.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<DropBox>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var dropboxes = entity as DropBox;
                            dropboxes.isLockable = false;
                            dropboxes.SendNetworkUpdate();
                            dropboxes.SendNetworkUpdateImmediate(true);
                        }
                    }

                if (configData.ConfigSettings.lockVending)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<VendingMachine>())
                    {
                        if (entity == null && entity.ShortPrefabName.Contains("vendingmachine.deployed") == true) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var vendingBoxes = entity as VendingMachine;
                            vendingBoxes.isLockable = true;
                            vendingBoxes.SendNetworkUpdate();
                            vendingBoxes.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<VendingMachine>())
                    {
                        if (entity == null && entity.ShortPrefabName.Contains("vendingmachine.deployed") == true) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var vendingBoxes = entity as VendingMachine;
                            vendingBoxes.isLockable = false;
                            vendingBoxes.SendNetworkUpdate();
                            vendingBoxes.SendNetworkUpdateImmediate(true);
                        }
                    }

                if (configData.ConfigSettings.lockPlanter)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<PlanterBox>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var planters = entity as PlanterBox;
                            planters.isLockable = true;
                            planters.SendNetworkUpdate();
                            planters.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<PlanterBox>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var planters = entity as PlanterBox;
                            planters.isLockable = false;
                            planters.SendNetworkUpdate();
                            planters.SendNetworkUpdateImmediate(true);
                        }
                    }

                if (configData.ConfigSettings.lockMixing)
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<MixingTable>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var mixingtables = entity as MixingTable;
                            mixingtables.isLockable = true;
                            mixingtables.SendNetworkUpdate();
                            mixingtables.SendNetworkUpdateImmediate(true);
                        }
                    }
                else
                    foreach (var entity in UnityEngine.Object.FindObjectsOfType<MixingTable>())
                    {
                        if (entity == null) continue;
                        if (isPlayer(entity.OwnerID))
                        {
                            var mixingtables = entity as MixingTable;
                            mixingtables.isLockable = false;
                            mixingtables.SendNetworkUpdate();
                            mixingtables.SendNetworkUpdateImmediate(true);
                        }
                    }
                Message(player, "Success");
            });
        }

        private void OnServerInitialized()
        {
            if (configData.ConfigSettings.lockHitch)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<HitchTrough>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var troughs = entity as HitchTrough;
                        troughs.isLockable = true;
                        troughs.SendNetworkUpdate();
                        troughs.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<HitchTrough>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var troughs = entity as HitchTrough;
                        troughs.isLockable = false;
                        troughs.SendNetworkUpdate();
                        troughs.SendNetworkUpdateImmediate(true);
                    }
                }


            if (configData.ConfigSettings.lockComposter)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<Composter>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var composters = entity as Composter;
                        composters.isLockable = true;
                        composters.SendNetworkUpdate();
                        composters.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<Composter>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var composters = entity as Composter;
                        composters.isLockable = false;
                        composters.SendNetworkUpdate();
                        composters.SendNetworkUpdateImmediate(true);
                    }
                }

            if (configData.ConfigSettings.lockDropBox)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<DropBox>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var dropboxes = entity as DropBox;
                        dropboxes.isLockable = true;
                        dropboxes.SendNetworkUpdate();
                        dropboxes.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<DropBox>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var dropboxes = entity as DropBox;
                        dropboxes.isLockable = false;
                        dropboxes.SendNetworkUpdate();
                        dropboxes.SendNetworkUpdateImmediate(true);
                    }
                }

            if (configData.ConfigSettings.lockPlanter)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<PlanterBox>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var planters = entity as PlanterBox;
                        planters.isLockable = true;
                        planters.SendNetworkUpdate();
                        planters.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<PlanterBox>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var planters = entity as PlanterBox;
                        planters.isLockable = false;
                        planters.SendNetworkUpdate();
                        planters.SendNetworkUpdateImmediate(true);
                    }
                }

            if (configData.ConfigSettings.lockMixing)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<MixingTable>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var mixingtables = entity as MixingTable;
                        mixingtables.isLockable = true;
                        mixingtables.SendNetworkUpdate();
                        mixingtables.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<MixingTable>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var mixingtables = entity as MixingTable;
                        mixingtables.isLockable = false;
                        mixingtables.SendNetworkUpdate();
                        mixingtables.SendNetworkUpdateImmediate(true);
                    }
                }

            if (configData.ConfigSettings.lockVending)
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<VendingMachine>())
                {
                    if (entity == null && entity.ShortPrefabName.Contains("vendingmachine.deployed") == true) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var vendingBoxes = entity as VendingMachine;
                        vendingBoxes.isLockable = true;
                        vendingBoxes.SendNetworkUpdate();
                        vendingBoxes.SendNetworkUpdateImmediate(true);
                    }
                }
            else
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<VendingMachine>())
                {
                    if (entity == null && entity.ShortPrefabName.Contains("vendingmachine.deployed") == true) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        var vendingBoxes = entity as VendingMachine;
                        vendingBoxes.isLockable = false;
                        vendingBoxes.SendNetworkUpdate();
                        vendingBoxes.SendNetworkUpdateImmediate(true);
                    }
                }

            if (configData.ConfigSettings.lockOvens)
            {
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseOven>())
                {
                    if (entity == null) continue;
                    if (isPlayer(entity.OwnerID))
                    {
                        if (entity is BaseOven && (!entity.ShortPrefabName.Contains("bbq.static", CompareOptions.IgnoreCase) || !entity.ShortPrefabName.Contains("small_refinery_static", CompareOptions.IgnoreCase)))
                        {
                            var oven = entity as BaseOven;
                            oven.isLockable = true;
                            oven.SendNetworkUpdate();
                            oven.SendNetworkUpdateImmediate(true);
                        }
                    }

                }
            }

            foreach (var entity in UnityEngine.Object.FindObjectsOfType<StorageContainer>())
            {
                OnEntitySpawned(entity);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            // Lock Hitch & Trough
            if (configData.ConfigSettings.lockHitch)
            {
                if (entity is HitchTrough)
                {
                    var hitchLock = entity as HitchTrough;
                    hitchLock.isLockable = true;
                    hitchLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockhitch = (entity as BaseLock)?.GetParentEntity() as HitchTrough;
                if (lockhitch != null)
                {
                    switch (lockhitch.PrefabName)
                    {
                        case HITCH_PREFAB:
                            entity.transform.localPosition = new Vector3(0f, 0.4f, 0.3f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                    }
                }
            }

            // Lock Composters
            if (configData.ConfigSettings.lockComposter)
            {
                if (entity is Composter)
                {
                    var composterLock = entity as Composter;
                    composterLock.isLockable = true;
                    composterLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockcompster = (entity as BaseLock)?.GetParentEntity() as Composter;
                if (lockcompster != null)
                {
                    switch (lockcompster.PrefabName)
                    {
                        case COMPOSTER_PREFAB:
                            entity.transform.localPosition = new Vector3(0f, 1.3f, 0.6f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                    }
                }
            }

            // Lock Planters
            if (configData.ConfigSettings.lockPlanter)
            {
                if (entity is PlanterBox)
                {
                    var planterLock = entity as PlanterBox;
                    planterLock.isLockable = true;
                    planterLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockplanter = (entity as BaseLock)?.GetParentEntity() as PlanterBox;
                if (lockplanter != null)
                {
                    switch (lockplanter.PrefabName)
                    {
                        case LARGE_PLANTER_PREFAB:
                            entity.transform.localPosition = new Vector3(0f, 0.45f, 0f);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 90);
                            break;
                        case SMALL_PLANTER_PREFAB:
                            entity.transform.localPosition = new Vector3(0f, 0.45f, 0f);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 90);
                            break;
                    }
                }
            }

            // Lock DropbBoxes
            if (configData.ConfigSettings.lockDropBox)
            {
                if (entity is DropBox)
                {
                    var dropboxLock = entity as DropBox;
                    dropboxLock.isLockable = true;
                    dropboxLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockboxes = (entity as BaseLock)?.GetParentEntity() as DropBox;
                if (lockboxes != null)
                {
                    switch (lockboxes.PrefabName)
                    {
                        case DROPBOX_PREFAB:
                            entity.transform.localPosition = new Vector3(0, 0, 0);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 0);
                            break;
                    }
                }
            }

            // Lock VendingMachines
            if (configData.ConfigSettings.lockVending)
            {
                if (entity is VendingMachine && entity.ShortPrefabName.Contains("vendingmachine.deployed", CompareOptions.IgnoreCase) == true)
                {
                    var vendingLock = entity as VendingMachine;
                    vendingLock.isLockable = true;
                    vendingLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var vendingBoxes = (entity as BaseLock)?.GetParentEntity() as VendingMachine;
                if (vendingBoxes != null)
                {
                    switch (vendingBoxes.PrefabName)
                    {
                        case VENDING_PREFAB:
                            entity.transform.localPosition = new Vector3(0, 0, 0);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 0);
                            break;
                    }
                }
            }

            // Lock Mixing Tables
            if (configData.ConfigSettings.lockMixing)
            {
                if (entity is MixingTable)
                {
                    var mixingLock = entity as MixingTable;
                    mixingLock.isLockable = true;
                    mixingLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockmixtables = (entity as BaseLock)?.GetParentEntity() as MixingTable;
                if (lockmixtables != null)
                {
                    switch (lockmixtables.PrefabName)
                    {
                        case MIXINGTABLE_PREFAB:
                            entity.transform.localPosition = new Vector3(0, 0.8f, 0.375f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                    }
                }
            }


            // Lock All Ovens
            // If A Static Refinery or BBQ, Place lock and remove immediately, and make entity not lockable
            if (configData.ConfigSettings.lockOvens)
            {
                if (entity is BaseOven && (!entity.ShortPrefabName.Contains("bbq.static", CompareOptions.IgnoreCase) || !entity.ShortPrefabName.Contains("small_refinery_static", CompareOptions.IgnoreCase)))
                {
                    var ovenLock = entity as BaseOven;
                    ovenLock.isLockable = true;
                    ovenLock.SendNetworkUpdate();
                    ovenLock.SendNetworkUpdateImmediate(true);
                    return;
                }
                var lockovens = (entity as BaseLock)?.GetParentEntity() as BaseOven;
                if (lockovens != null)
                {
                    switch (lockovens.PrefabName)
                    {
                        case FURNACE_PREFAB:
                            entity.transform.localPosition = new Vector3(-0.02f, 0.3f, 0.5f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                        case LARGE_FURNACE_PREFAB:
                            entity.transform.localPosition = new Vector3(0.65f, 1.25f, -0.65f);
                            entity.transform.localRotation = Quaternion.Euler(0, 45, 0);
                            break;
                        case REFINERY_PREFAB:
                            entity.transform.localPosition = new Vector3(-0.01f, 1.25f, -0.6f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                        case BBQ_PREFAB:
                            entity.transform.localPosition = new Vector3(0.3f, 0.75f, 0f);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 0);
                            break;
                        case STATIC_BBQ_PREFAB:
                            if (lockovens is BaseOven && lockovens.prefabID == 28449714 || (lockovens.ShortPrefabName.Contains("bbq.static", CompareOptions.IgnoreCase)))
                            {
                                lockovens.isLockable = false;
                                lockovens.SendNetworkUpdate();
                                lockovens.SendNetworkUpdateImmediate(true);

                                var codelock = lockovens.GetComponentInChildren<CodeLock>();
                                var woodlock = lockovens.GetComponentInChildren<KeyLock>();
                                if (codelock != null)
                                {
                                    Effect.server.Run(codelock.effectUnlocked.resourcePath, codelock, 0, Vector3.zero, Vector3.forward, null, false);
                                    codelock.SetFlag(BaseEntity.Flags.Locked, false);

                                    timer.Once(0.05f, delegate () {
                                        codelock.Kill();
                                    });
                                }
                                if (woodlock != null)
                                {
                                    woodlock.SetFlag(BaseEntity.Flags.Locked, false);

                                    timer.Once(0.05f, delegate () {
                                        woodlock.Kill();
                                    });
                                }
                            }

                            entity.transform.localPosition = new Vector3(0.3f, 0.75f, 0f);
                            entity.transform.localRotation = Quaternion.Euler(0, 0, 0);
                            break;
                        case STATIC_REFINERY_PREFAB:
                            if (lockovens is BaseOven && lockovens.prefabID == 919097516 || (lockovens.ShortPrefabName.Contains("small_refinery_static", CompareOptions.IgnoreCase)))
                            {
                                lockovens.isLockable = false;
                                lockovens.SendNetworkUpdate();
                                lockovens.SendNetworkUpdateImmediate(true);

                                var codelock = lockovens.GetComponentInChildren<CodeLock>();
                                var woodlock = lockovens.GetComponentInChildren<KeyLock>();
                                if (codelock != null)
                                {
                                    Effect.server.Run(codelock.effectUnlocked.resourcePath, codelock, 0, Vector3.zero, Vector3.forward, null, false);
                                    codelock.SetFlag(BaseEntity.Flags.Locked, false);

                                    timer.Once(0.05f, delegate () {
                                        codelock.Kill();
                                    });
                                }
                                if (woodlock != null)
                                {
                                    woodlock.SetFlag(BaseEntity.Flags.Locked, false);

                                    timer.Once(0.05f, delegate () {
                                        woodlock.Kill();
                                    });
                                }
                            }
                            entity.transform.localPosition = new Vector3(-0.01f, 1.25f, -0.6f);
                            entity.transform.localRotation = Quaternion.Euler(0, 90, 0);
                            break;
                    }
                }

            }
        }
        #endregion

        #region Config
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "General Options")]
            public GeneralOptions GeneralSettings { get; set; }
            [JsonProperty(PropertyName = "Configuration")]
            public ConfigOptions ConfigSettings { get; set; }

            public class GeneralOptions
            {
                [JsonProperty(PropertyName = "Command")]
                public string commandOption { get; set; }
                [JsonProperty(PropertyName = "Permission Name")]
                public string permissionName { get; set; }
            }

            public class ConfigOptions
            {
                [JsonProperty(PropertyName = "Enable Locks on Composters")]
                public bool lockComposter { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on DropBoxes")]
                public bool lockDropBox { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on Vending Machines")]
                public bool lockVending { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on Ovens (Furnaces, BBQ Grills, Small Oil Refineries)")]
                public bool lockOvens { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on Small & Large Planters")]
                public bool lockPlanter { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on Hitch & Trough")]
                public bool lockHitch { get; set; }
                [JsonProperty(PropertyName = "Enable Locks on Mixing Table")]
                public bool lockMixing { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                GeneralSettings = new ConfigData.GeneralOptions
                {
                    commandOption = "refreshall",
                    permissionName = "lockmaster.admin"
                },
                ConfigSettings = new ConfigData.ConfigOptions
                {
                    lockComposter = true,
                    lockDropBox = true,
                    lockVending = true,
                    lockOvens = true,
                    lockPlanter = true,
                    lockHitch = true,
                    lockMixing = true
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(1, 1, 5))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(1, 1, 6))
                configData.ConfigSettings.lockHitch = true;

            if (configData.Version < new Core.VersionNumber(1, 1, 8))
                configData.ConfigSettings.lockMixing = true;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Usage", "You do not have permission to use this command"},
                {"Success", "Refreshing is done"}
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Message(BasePlayer player, string key, params object[] args)
        {
            SendReply(player, Lang(key, player.UserIDString, args));
        }
        #endregion
    }
}


// --- End of file: LockMaster.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/land-on-cargo-ship ---
// --- Original File Path: L/LandOnCargoShip/LandOnCargoShip.cs ---

using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Land On Cargo Ship", "Arainrr", "1.0.0")]
    [Description("Allow the mini copter to land on the cargo ship")]
    public class LandOnCargoShip : RustPlugin
    {
        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            foreach (var serverEntity in BaseNetworkable.serverEntities)
            {
                var miniCopter = serverEntity as MiniCopter;
                if (miniCopter != null)
                {
                    OnEntitySpawned(miniCopter);
                    continue;
                }
                var cargoShip = serverEntity as CargoShip;
                if (cargoShip != null)
                {
                    OnEntitySpawned(cargoShip);
                }
            }
        }

        private void OnEntitySpawned(MiniCopter miniCopter)
        {
            if (miniCopter == null) return;
            var parentTrigger = new GameObject("ParentTrigger");
            parentTrigger.transform.SetParent(miniCopter.transform);
            parentTrigger.transform.position = miniCopter.transform.position;
            var sphereCollider = parentTrigger.gameObject.AddComponent<SphereCollider>();
            sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
            sphereCollider.radius = 1.5f;
            sphereCollider.isTrigger = true;
        }

        private void OnEntitySpawned(CargoShip cargoShip)
        {
            if (cargoShip == null) return;
            var triggerParent = cargoShip.GetComponentInChildren<TriggerParent>();
            if (triggerParent == null) return;
            triggerParent.interestLayers |= (1 << (int)Rust.Layer.Reserved1);
        }

        private void Unload()
        {
            foreach (var miniCopter in BaseNetworkable.serverEntities.OfType<MiniCopter>())
            {
                var child = miniCopter.transform.Find("ParentTrigger");
                if (child != null)
                {
                    UnityEngine.Object.Destroy(child.gameObject);
                }
            }
        }
    }
}

// --- End of file: LandOnCargoShip.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/life-stealer ---
// --- Original File Path: L/LifeStealer/LifeStealer.cs ---

﻿// #define DEBUG

using System;
using System.Linq;
using System.Collections.Generic;
using Rust;
using Oxide.Core;
using Newtonsoft.Json;

// Thanks to redBDGR the original creator of this plugin
// Thanks to Krungh Crow previous maintainer

namespace Oxide.Plugins
{
    [Info("LifeStealer", "beee", "1.2.0")]
    [Description("Applies lifesteal based on player damage")]

    class LifeStealer : RustPlugin
    {
        private static PluginConfig _config;

        private Dictionary<ulong, string> PlayersPermissionsCache = new Dictionary<ulong, string>();

        void OnServerInitialized()
        {
            RegisterPermissions();
        }

        void Unload()
        {
            _config = null;
        }

        #region Hooks

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var attacker = info.InitiatorPlayer as BasePlayer;
            if (attacker == null || !attacker.IsConnected || !attacker.userID.IsSteamId())
                return;

            string cachedPerm = "";

            KeyValuePair<string, PermissionSettings> attackerLFSettings;
            if(!PlayersPermissionsCache.TryGetValue(attacker.userID, out cachedPerm))
            {
                attackerLFSettings = GetPlayerPermission(attacker);
                if(attackerLFSettings.Equals(default(KeyValuePair<string, PermissionSettings>)))
                    return;

                PlayersPermissionsCache.Add(attacker.userID, attackerLFSettings.Key);
#if DEBUG
                PrintWarning($"Added to cache [{attacker.userID}, {attackerLFSettings.Key}]");
#endif
            }
            else
            {
                attackerLFSettings = new KeyValuePair<string, PermissionSettings>(cachedPerm, _config.Permissions[cachedPerm]);
#if DEBUG
                PrintWarning($"Found in cache [{attacker.userID}, {attackerLFSettings.Key}]");
#endif
            }

            if(attackerLFSettings.Value.VictimPrefabs != null && attackerLFSettings.Value.VictimPrefabs.Contains(entity.ShortPrefabName))
                goto skip;
            
            BasePlayer victimPlayer = entity as BasePlayer;
            if (victimPlayer != null)
            {
                if(victimPlayer.IsNpc || !victimPlayer.userID.IsSteamId())
                {
                    if(attackerLFSettings.Value.FromScientists)
                        goto skip;
                    else
                        return;
                }
                else
                {
                    if(attackerLFSettings.Value.FromPlayers)
                        goto skip;
                    else
                        return;
                }
            }
            else if (entity is BaseAnimalNPC)
            {
                if(attackerLFSettings.Value.FromAnimals)
                    goto skip;
                else
                    return;
            }
            else if (entity is PatrolHelicopter)
            {
                if(attackerLFSettings.Value.FromHelicopters)
                    goto skip;
                else
                    return;
            }
            else if (entity is BradleyAPC)
            {
                if(attackerLFSettings.Value.FromBradley)
                    goto skip;
                else
                    return;
            }
            else
                return;

            skip:

            if (info.damageTypes.GetMajorityDamageType() == DamageType.Bleeding)
                return;
                
            NextFrame(() =>
            {
                float totalDmg = info.damageTypes.Total();
                float lifestealTotal = attackerLFSettings.Value.LifestealPercent > 0 ? totalDmg * (attackerLFSettings.Value.LifestealPercent / 100f) : 0;
                float staticHeal = attackerLFSettings.Value.StaticHeal > 0 ? attackerLFSettings.Value.StaticHeal : 0;
                
                float healAmount = lifestealTotal + staticHeal;
                if (healAmount < 1)
                    return;

#if DEBUG
                PrintWarning($"totalDmg: {totalDmg}, lifestealTotal: {lifestealTotal}, staticHeal: {staticHeal}, healAmount: {healAmount}");
#endif
                attacker.Heal(healAmount);
            });
        }

        void OnUserPermissionGranted(string userId, string permName)
        {
            if(_config.Permissions.ContainsKey(permName.Replace($"{Name.ToLower()}.", "")) && PlayersPermissionsCache.ContainsKey(Convert.ToUInt64(userId)))
            {
                PlayersPermissionsCache.Remove(Convert.ToUInt64(userId));
#if DEBUG
                PrintWarning($"Removed from cache {userId}");
#endif
            }
        }

        void OnUserPermissionRevoked(string userId, string permName)
        {
            if(_config.Permissions.ContainsKey(permName.Replace($"{Name.ToLower()}.", "")) && PlayersPermissionsCache.ContainsKey(Convert.ToUInt64(userId)))
            {
                PlayersPermissionsCache.Remove(Convert.ToUInt64(userId));
#if DEBUG
                PrintWarning($"Removed from cache {userId}");
#endif
            }
        }

        private void OnUserGroupAdded(string userId, string groupName)
        {
            if(PlayersPermissionsCache.ContainsKey(Convert.ToUInt64(userId)))
            {
                PlayersPermissionsCache.Remove(Convert.ToUInt64(userId));
#if DEBUG
                PrintWarning($"Removed from cache {userId}");
#endif
            }
        }

        private void OnUserGroupRemoved(string userId, string groupName)
        {
            if(PlayersPermissionsCache.ContainsKey(Convert.ToUInt64(userId)))
            {
                PlayersPermissionsCache.Remove(Convert.ToUInt64(userId));
#if DEBUG
                PrintWarning($"Removed from cache {userId}");
#endif
            }
        }

        #endregion

        #region Functions

        private void RegisterPermissions()
        {
            if(_config == null || _config.Permissions == null)
                return;

            foreach(var perm in _config.Permissions)
                permission.RegisterPermission($"{Name.ToLower()}.{perm.Key.ToLower()}", this);
        }

        private KeyValuePair<string, PermissionSettings> GetPlayerPermission(BasePlayer player)
        {
            if(_config == null || _config.Permissions == null)
                return default(KeyValuePair<string, PermissionSettings>);

            foreach(var perm in _config.Permissions.Reverse())
            {
                if(permission.UserHasPermission(player.UserIDString, $"{Name.ToLower()}.{perm.Key}"))
                    return perm;
            }
            
            return default(KeyValuePair<string, PermissionSettings>);
        }

        #endregion

        #region Config

        private class PluginConfig
        {
            public Oxide.Core.VersionNumber Version;

            [JsonProperty("Permissions")]
            public Dictionary<string, PermissionSettings> Permissions { get; set; }
        }

        private class PermissionSettings
        {
            [JsonProperty("Lifesteal % (of damage dealt)")]
            public int LifestealPercent { get; set; }

            [JsonProperty("Static Heal")]
            public int StaticHeal { get; set; }

            [JsonProperty("Heal from Players?")]
            public bool FromPlayers { get; set; }

            [JsonProperty("Heal from Scientists?")]
            public bool FromScientists { get; set; }

            [JsonProperty("Heal from Animals?")]
            public bool FromAnimals { get; set; }

            [JsonProperty("Heal from Patrol Helicopter?")]
            public bool FromHelicopters { get; set; }

            [JsonProperty("Heal from Bradley APC?")]
            public bool FromBradley { get; set; }

            [JsonProperty("Custom Victims ShortPrefabName (Optional)")]
            public List<string> VictimPrefabs { get; set; }
        }

        private PluginConfig GetDefaultConfig()
        {
            PluginConfig result = new PluginConfig
            {
                Version = Version,
                Permissions = new Dictionary<string, PermissionSettings>
                {
                    ["default"] = new PermissionSettings()
                    {
                        LifestealPercent = 50,
                        StaticHeal = 0,
                        FromPlayers = true,
                        FromScientists = true,
                        VictimPrefabs = new List<string>()
                    },
                    ["vip1"] = new PermissionSettings()
                    {
                        LifestealPercent = 60,
                        StaticHeal = 0,
                        FromPlayers = true,
                        FromScientists = true,
                        FromAnimals = true,
                        VictimPrefabs = new List<string>()
                    },
                    ["vip2"] = new PermissionSettings()
                    {
                        LifestealPercent = 70,
                        StaticHeal = 5,
                        FromPlayers = true,
                        FromScientists = true,
                        FromAnimals = true,
                        FromHelicopters = true,
                        FromBradley = true,
                        VictimPrefabs = new List<string>()
                        {
                            "autoturret_deployed", "guntrap.deployed"
                        }
                    }
                }
            };

            return result;
        }

        private void CheckForConfigUpdates()
        {
            bool changes = false;

            if (_config == null || _config.Permissions == null)
            {
                PluginConfig tmpDefaultConfig = GetDefaultConfig();
                _config = tmpDefaultConfig;
                changes = true;
            }

            if(_config.Version != Version)
                changes = true;

            if (changes)
            {
                _config.Version = Version;

                PrintWarning("Config updated");
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            CheckForConfigUpdates();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: LifeStealer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/logger ---
// --- Original File Path: L/Logger/Logger.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;

// TODO: Finish implementing ItemList and ItemListType config settings
// TODO: Finish implementing RotateLog config option
// TODO: Fix RCON clients screwing up with log output from select commands
/*
    playerlist
    status
    banlist
    banlistex
    bans
    server.fps
    server.hostname
    server.description
    serverinfo
    plugins
*/

namespace Oxide.Plugins
{
    [Info("Logger", "Wulf/lukespragg", "2.2.2")]
    [Description("Configurable logging of chat, commands, connections, and more")]
    public class Logger : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Log chat messages (true/false)")]
            public bool LogChat { get; set; } = true;

            [JsonProperty(PropertyName = "Log command usage (true/false)")]
            public bool LogCommands { get; set; } = true;

            [JsonProperty(PropertyName = "Log player connections (true/false)")]
            public bool LogConnections { get; set; } = true;

            [JsonProperty(PropertyName = "Log player disconnections (true/false)")]
            public bool LogDisconnections { get; set; } = true;

            [JsonProperty(PropertyName = "Log player respawns (true/false)")]
            public bool LogRespawns { get; set; } = true;

#if RUST

            [JsonProperty(PropertyName = "Log when crafting started (true/false)")]
            public bool LogCraftingStarted { get; set; } = true;

            [JsonProperty(PropertyName = "Log when crafting cancelled (true/false)")]
            public bool LogCraftingCancelled { get; set; } = true;

            [JsonProperty(PropertyName = "Log when crafting finished (true/false)")]
            public bool LogCraftingFinished { get; set; } = true;

            [JsonProperty(PropertyName = "Log items dropped by players (true/false)")]
            public bool LogItemDrops { get; set; } = true;

#endif

            [JsonProperty(PropertyName = "Log output to console (true/false)")]
            public bool LogToConsole { get; set; } = false;

            // TODO: Option to listen to commands from admin, moderator, or all

            [JsonProperty(PropertyName = "Rotate logs daily (true/false)")]
            public bool RotateLogs { get; set; } = true;

            [JsonProperty(PropertyName = "Command list (full or short commands)")]
            public List<string> CommandList { get; set; } = new List<string>
            {
                /*"help", "version", "chat.say", "craft.add", "craft.canceltask", "global.kill",
                "global.respawn", "global.respawn_sleepingbag", "global.status", "global.wakeup",
                "inventory.endloot", "inventory.unlockblueprint"*/
            };

            [JsonProperty(PropertyName = "Command list type (blacklist or whitelist)")]
            public string CommandListType { get; set; } = "blacklist";

            //[JsonProperty(PropertyName = "Item list (full or short names)")]
            //public List<string> ItemList { get; set; } = new List<string>
            //{
            //    /*"rock", "torch"*/
            //};

            //[JsonProperty(PropertyName = "Item list type (blacklist or whitelist)")]
            //public string ItemListType { get; set; } = "blacklist";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandReason"] = "reason",
                ["CraftingCancelled"] = "{0} ({1}) cancelled crafting {2} {3}",
                ["CraftingFinished"] = "{0} ({1}) finished crafting {2} {3}",
                ["CraftingStarted"] = "{0} ({1}) started crafting {2} {3}",
                ["ItemDropped"] = "{0} ({1}) dropped {2} {3}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerCommand"] = "{0} ({1}) ran command: {2} {3}",
                ["PlayerConnected"] = "{0} ({1}) connected from {2}",
                ["PlayerDisconnected"] = "{0} ({1}) disconnected",
                ["PlayerMessage"] = "{0} ({1}) said: {2}",
                ["PlayerRespawned"] = "{0} ({1}) respawned at {2}",
                ["RconCommand"] = "{0} ran command: {1} {2}",
                ["ServerCommand"] = "SERVER ran command: {0} {1}"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string commandReason = "loggerreason";
        private const string permReason = "logger.reason";

        private void Init()
        {
            permission.RegisterPermission(permReason, this);

            AddCovalenceCommand(commandReason, "ReasonCommand");
            AddLocalizedCommand("CommandReason", "ReasonCommand");

            if (!config.LogChat) Unsubscribe("OnUserChat");
            if (!config.LogCommands) Unsubscribe("OnServerCommand");
            if (!config.LogConnections) Unsubscribe("OnUserConnected");
            if (!config.LogDisconnections) Unsubscribe("OnUserDisconnected");
            if (!config.LogRespawns) Unsubscribe("OnUserRespawned");
#if RUST
            if (!config.LogCraftingStarted) Unsubscribe("OnItemCraft");
            if (!config.LogCraftingCancelled) Unsubscribe("OnItemCraftCancelled");
            if (!config.LogCraftingFinished) Unsubscribe("OnItemCraftFinished");
            if (!config.LogItemDrops) Unsubscribe("OnItemAction");
#endif
        }

        #endregion Initialization

        #region Logging

        private void OnUserChat(IPlayer player, string message) => Log("chat", "PlayerMessage", player.Name, player.Id, message);

        private void OnUserConnected(IPlayer player) => Log("connections", "PlayerConnected", player.Name, player.Id, player.Address);

        private void OnUserDisconnected(IPlayer player) => Log("disconnections", "PlayerDisconnected", player.Name, player.Id);

        private void OnUserRespawned(IPlayer player) => Log("respawns", "PlayerRespawned", player.Name, player.Id, player.Position().ToString());

#if RUST
        private void OnItemAction(Item item, string action)
        {
            BasePlayer player = item.parent?.playerOwner;

            if (action.ToLower() == "drop" && player != null)
            {
                Log("itemdrops", "ItemDropped", player.displayName.Sanitize(), player.UserIDString, item.amount, item.info.displayName?.english ?? item.name);
            }
        }

        private void OnItemCraft(ItemCraftTask task, BasePlayer player)
        {
            ItemDefinition item = task.blueprint.targetItem;
            Log("crafting", "CraftingStarted", player.displayName.Sanitize(), player.UserIDString, task.amount, item.displayName.english);
        }

        private void OnItemCraftCancelled(ItemCraftTask task, ItemCrafter crafter)
        {
            BasePlayer player = crafter.owner;
            ItemDefinition item = task.blueprint.targetItem;
            Log("crafting", "CraftingCancelled", player.displayName.Sanitize(), player.UserIDString, task.amount, item.displayName.english);
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter crafter)
        {
            BasePlayer player = crafter.owner;
            Log("crafting", "CraftingFinished", player.displayName.Sanitize(), player.UserIDString, item.amount, item.info.displayName.english);
        }

        private void OnRconCommand(IPEndPoint ip, string command, string[] args)
        {
            if (command == "chat.say" || command == "say")
            {
                return;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(command))
            {
                return;
            }

            Log("commands", "RconCommand", ip.Address, command, string.Join(" ", args));
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;

            if (fullCommand == "chat.say")
            {
                return;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(fullCommand))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(fullCommand))
            {
                return;
            }

            if (arg.Connection != null)
            {
                Log("commands", "PlayerCommand", arg.Connection.username.Sanitize(), arg.Connection.userid, fullCommand, arg.FullString);
            }
            else
            {
                Log("commands", "ServerCommand", fullCommand, arg.FullString);
            }
        }
#endif

        private void OnUserCommand(IPlayer player, string command, string[] args)
        {
            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains("/" + command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains("/" + command))
            {
                return;
            }

            Log("commands", "PlayerCommand", player.Name, player.Id, command, string.Join(" ", args));
        }

        // TODO: Add command logged message in player's console/chat?
        // TODO: Prompt for reason within X seconds when command is used?

        #endregion Logging

        #region Command

        private void ReasonCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permReason))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            Log("reasons", "Reason");
            Message(player, "ReasonLogged", string.Join(" ", args));
        }

        #endregion Command

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (config.LogToConsole)
            {
                Puts(Lang(key, null, args));
            }
            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private void Message(IPlayer player, string key, params object[] args)
        {
            player.Reply(Lang(key, player.Id, args));
        }

        #endregion Helpers
    }
}


// --- End of file: Logger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/last-man-standing ---
// --- Original File Path: L/LastManStanding/LastManStanding.cs ---

﻿// Requires: EventManager
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LastManStanding", "k1lly0u", "3.0.1"), Description("Last man standing event mode for EventManager")]
    class LastManStanding : RustPlugin, IEventPlugin
    {
        #region Oxide Hooks
        private void OnServerInitialized()
        {
            EventManager.RegisterEvent(Title, this);

            GetMessage = Message;
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void Unload()
        {
            if (!EventManager.IsUnloading)
                EventManager.UnregisterEvent(Title);

            Configuration = null;
        }
        #endregion

        #region Event Checks
        public bool InitializeEvent(EventManager.EventConfig config) => EventManager.InitializeEvent<LastManStandingEvent>(this, config);

        public bool CanUseClassSelector => true;

        public bool RequireTimeLimit => true;

        public bool RequireScoreLimit => false;

        public bool UseScoreLimit => false;

        public bool UseTimeLimit => true;

        public bool IsTeamEvent => false;

        public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2)
        {
            score1 = string.Empty;
            score2 = string.Format(Message("Score.Kills", langUserId), scoreEntry.value2);
        }

        public List<EventManager.EventParameter> AdditionalParameters { get; } = null;

        public string ParameterIsValid(string fieldName, object value) => null;
        #endregion

        #region Functions
        private static string ToOrdinal(int i) => (i + "th").Replace("1th", "1st").Replace("2th", "2nd").Replace("3th", "3rd");
        #endregion

        #region Event Classes
        public class LastManStandingEvent : EventManager.BaseEventGame
        {
            public EventManager.BaseEventPlayer winner;

            protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player) => player.gameObject.AddComponent<LastManStandingPlayer>();

            internal override void PrestartEvent()
            {
                CloseEvent();
                base.PrestartEvent();
            }

            internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker = null, HitInfo info = null)
            {
                if (victim == null)
                    return;

                victim.OnPlayerDeath(attacker, Configuration.RespawnTime);

                if (attacker != null && victim != attacker)
                {
                    attacker.OnKilledPlayer(info);

                    if (GetAlivePlayerCount() <= 1)
                    {
                        winner = attacker;
                        InvokeHandler.Invoke(this, EndEvent, 0.1f);
                        return;
                    }
                }

                UpdateScoreboard();

                base.OnEventPlayerDeath(victim, attacker);
            }

            protected override void GetWinningPlayers(ref List<EventManager.BaseEventPlayer> winners)
            {
                if (winner == null)
                {
                    if (eventPlayers.Count > 0)
                    {
                        int kills = 0;

                        for (int i = 0; i < eventPlayers.Count; i++)
                        {
                            EventManager.BaseEventPlayer eventPlayer = eventPlayers[i];
                            if (eventPlayer == null)
                                continue;

                            if (eventPlayer.Kills > kills)
                            {
                                winner = eventPlayer;
                                kills = eventPlayer.Kills;
                            }                            
                        }
                    }
                }

                if (winner != null)
                    winners.Add(winner);
            }

            #region Scoreboards
            protected override void BuildScoreboard()
            {
                scoreContainer = EMInterface.CreateScoreboardBase(this);

                int index = -1;

                if (Config.ScoreLimit > 0)
                    EMInterface.CreatePanelEntry(scoreContainer, string.Format(GetMessage("Score.Remaining", 0UL), eventPlayers.Count), index += 1);

                EMInterface.CreateScoreEntry(scoreContainer, string.Empty, string.Empty, "K", index += 1);

                for (int i = 0; i < Mathf.Min(scoreData.Count, 15); i++)
                {
                    EventManager.ScoreEntry score = scoreData[i];
                    EMInterface.CreateScoreEntry(scoreContainer, score.displayName, string.Empty, ((int)score.value2).ToString(), i + index + 1);
                }
            }

            protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer) => 0;

            protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer) => eventPlayer.Kills;

            protected override void SortScores(ref List<EventManager.ScoreEntry> list)
            {
                list.Sort(delegate (EventManager.ScoreEntry a, EventManager.ScoreEntry b)
                {                    
                    return a.value2.CompareTo(b.value2);
                });
            }
            #endregion
        }

        private class LastManStandingPlayer : EventManager.BaseEventPlayer
        {
            internal override void OnPlayerDeath(EventManager.BaseEventPlayer attacker = null, float respawnTime = 5)
            {
                AddPlayerDeath(attacker);

                DestroyUI();

                int position = Event.GetAlivePlayerCount();

                string message = attacker != null ? string.Format(GetMessage("Death.Killed", Player.userID), attacker.Player.displayName, ToOrdinal(position + 1), position) :
                                 IsOutOfBounds ? string.Format(GetMessage("Death.OOB", Player.userID), ToOrdinal(position + 1), position) :
                                 string.Format(GetMessage("Death.Suicide", Player.userID), ToOrdinal(position + 1), position);

                EMInterface.DisplayDeathScreen(this, message, false);
            }
        }
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTime = 5,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        public string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private static Func<string, ulong, string> GetMessage;

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Score.Kills"] = "Kills: {0}",
            ["Score.Name"] = "Kills",
            ["Score.Remaining"] = "Players Remaining : {0}",
            ["Death.Killed"] = "You were killed by {0}\nYou placed {1}\n{2} players remain",
            ["Death.Suicide"] = "You died...\nYou placed {0}\n{1} players remain",
            ["Death.OOB"] = "You left the playable area\nYou placed {0}\n{1} players remain",
        };
        #endregion
    }
}


// --- End of file: LastManStanding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/layers-of-risk ---
// --- Original File Path: L/LayersOfRisk/LayersOfRisk.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Layers of Risk", "Mike Danielsson", 1.24)]
    [Description("Play in this new game changing world where more focus is on how you choose your Risks.")]
    class LayersOfRisk : RustPlugin
    {
        #region Variables
        //Default variables
        bool hasLateInitializedBeenRun = false;
        float TimeLookPlayerUiIsDrawn = 2.4f;
        Vector3 middlePosition = new Vector3(0, 0, 0);
        Vector3 downDirection = new Vector3(0, -1, 0);
        Vector3 vectormultiplier = new Vector3(0, 2, 0);
        int hackableCrateDefaultHackTime = 900;
        //Changable
        bool enableZoneIndicators = false;
        int zoneIndicatorStrength = 12;
        int outerWall = 723;
        int middleWall = 437;
        int InnerWall = 182;
        int distanceToBuildFromWalls = 25;
        int hackAbleWarZoneExtraTime = 20;
        int maxHackableCrateSpawns = 25;
        int hackableCratesSpawedAtPluginStart = 8;
        int timeBetweenHackableSpawnTries = 300;
        int hackableCrateZone1Time = 780;
        int hackableCrateZone2Time = 660;
        int hackableCrateZone3Time = 480;
        int hackableCrateZone4Time = 180;

        int hackableCrateZone1ArmourStart = 0;
        int hackableCrateZone1ArmourEnd = 4;
        int hackableCrateZone2ArmourStart = 2;
        int hackableCrateZone2ArmourEnd = 10;
        int hackableCrateZone3ArmourStart = 9;
        int hackableCrateZone3ArmourEnd = 16;
        int hackableCrateZone4ArmourStart = 15;
        int hackableCrateZone4ArmourEnd = 22;

        int hackableCrateZone1WeaponStart = 1;
        int hackableCrateZone1WeaponEnd = 21;
        int hackableCrateZone2WeaponStart = 17;
        int hackableCrateZone2WeaponEnd = 30;
        int hackableCrateZone3WeaponStart = 25;
        int hackableCrateZone3WeaponEnd = 35;
        int hackableCrateZone4WeaponStart = 32;
        int hackableCrateZone4WeaponEnd = 44;

        //War zone variables
        int totalWarZones = 0;
        int warZoneTimeBetweenIntervalls = 1;
        float playerWarZoneStartDecreser = 0.001f;
        //Changable
        int warZoneSize = 150;
        int warZoneRaidAliveTimer = 600;
        int playerWarZone1Delay = 3600;
        int playerWarZone2Delay = 2100;
        int playerWarZone3Delay = 1500;
        int playerWarZone4Delay = 900;
        int timeBeforePlayerTakeDamageWhenEnterWarZone = 6;
        int startWarZoneAfterDamageToStructure = 25;
        int warZoneEnterDamage = 20;
        bool canDieWhenEnteringWarZone = false;

        //Timer variables
        float updateTierRefreshRate = 0.2f;
        float initializeTimerDelay = 1f;
        float tierPointChangeDelay = 0;
        //Changable
        int updateTierTime = 20;

        //Prefabs
        string hackableCreate = "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab";
        string warZoneSphere = "assets/prefabs/visualization/sphere.prefab";

        //VFX prefabs
        string vomit = "assets/bundled/prefabs/fx/gestures/drink_vomit.prefab";

        //GUI elements
        string uiTierBox = "ui_tier_box";
        string uiTierRangeBox = "ui_tier_range_box";
        string uiZoneBox = "ui_zone_box";
        string uiMeterZoneBox = "ui_meter_zone_box";
        string uiTierLoading = "ui_tier_loading ";
        string uiTierPoints = "ui_tier_points";
        string uiInfoText = "ui_info_text";
        string uiGetPlayerTierOnLook = "ui_get_player_tier_on_look";
        string uiTierPointsChange = "ui_tier_points_change";

        //Tier box
        float tierBoxPosX = 0.3445f;
        float tierBoxPosY = 0.113f;
        float tierBoxSizeX = 0.0457f;
        float tierBoxSizeY = 0.041f;

        //Tier progress bar box
        float tierProgressPosX = 0.394f;
        float tierProgressPosY = 0.113f;
        float tierProgressSizeX = 0.2464f;
        float tierProgressSizeY = 0.041f;

        //Tier range box
        float tierRangeBoxPosX = 0.112f;
        float tierRangeBoxPosY = 0.025f;
        float tierRangeBoxSizeX = 0.1494f;
        float tierRangeBoxSizeY = 0.041f;

        //Zone box
        float zoneBoxPosX = 0.112f;
        float zoneBoxPosY = 0.0725f;
        float zoneBoxSizeX = 0.045f;
        float zoneBoxSizeY = 0.041f;

        //Meters to next zone box
        float meterZoneBoxPosX = 0.1602f;
        float meterZoneBoxPosY = 0.0725f;
        float meterZoneBoxSizeX = 0.03f;
        float meterZoneBoxSizeY = 0.041f;

        //Get tier on look text box
        float getTierOnLookPosX = 0.39f;
        float getTierOnLookPosY = 0.85f;
        float getTierOnLookSizeX = 0.22f;
        float getTierOnLookSizeY = 0.041f;

        //Get tier on look text box
        float getTierPointsChangePosX = 0.443f;
        float getTierPointsChangePosY = 0.14f;
        float getTierPointsChangeSizeX = 0.15f;
        float getTierPointsChangeSizeY = 0.1f;

        //Data files
        DynamicConfigFile weaponsDataFile;
        DynamicConfigFile armoursDataFile;
        DynamicConfigFile tiersDataFile;
        DynamicConfigFile hackableCreatPositionsDataFile;

        class playerDataClass
        {
            public bool isUpdateTierTimerRunning { get; set; }
            public bool isPlayerInitialized { get; set; }
            public int currentTier {get; set; }
            public int nextTier {get; set; }
            public int oldTier { get; set; }
            public int currentZone { get; set; }
            public float distanceFromMiddle { get; set; }
            public float cantStartRaidZoneTimer { get; set; }
            public float startRaidZoneAfterDamageDealtToStructure { get; set; }
            public float currentUpdateCycle { get; set; }
            public int tierId { get; set; }
            public float lookPlayerDelay { get; set; }
        }

        class tierDataClass
        {
            public string tierLetter { get; set; }
            public int min { get; set; }
            public int max { get; set; }
        }

        class itemDataClass
        {
            public string shortName { get; set; }
            public int value { get; set; }
            public int followItem { get; set; }
        }

        class warZoneDataClass
        {
            public int zone { get; set; }
            public float size { get; set; }
            public float currentUpTime { get; set; }
            public float aliveTime { get; set; }
            public Vector3 position { get; set; }
        }

        class hackableCrateDataClass
        {
            public bool inUse { get; set; }
        }

        //Player data dictionary
        Dictionary<ulong, playerDataClass> playerDataDic = new Dictionary<ulong, playerDataClass>();

        //Tier data dictionary
        Dictionary<int, tierDataClass> tierDataDic = new Dictionary<int, tierDataClass>();

        //Weapons data dictionary
        Dictionary<int, itemDataClass> weaponDataDic = new Dictionary<int, itemDataClass>();

        //Armours data dictionary
        Dictionary<int, itemDataClass> armourDataDic = new Dictionary<int, itemDataClass>();

        //War zone data dictionary
        Dictionary<int, warZoneDataClass> warZoneDataDic = new Dictionary<int, warZoneDataClass>();

        //War zone timer dictionary
        Dictionary<int, Timer> timerHolderDic = new Dictionary<int, Timer>();

        //Hackable crate data dictionary
        Dictionary<Vector3, hackableCrateDataClass> hackableCrateDataDic = new Dictionary<Vector3, hackableCrateDataClass>();
        #endregion

        #region Initialization
        void Init()
        {
            updateSettingsFromConfigFile();

            //Check if weaponConfigFile exits and name the json file.
            weaponsDataFile = createConfigFileIfDontExist("LayersOfRiskWeapons");

            //Check if armourConfigFile exits and name the json file.
            armoursDataFile = createConfigFileIfDontExist("LayersOfRiskArmours");

            //Check if layersOfRiskTierData exits and name the json file.
            tiersDataFile = createConfigFileIfDontExist("LayersOfRiskTierData");

            hackableCreatPositionsDataFile = createConfigFileIfDontExist("LayersOfRiskHackableCratePositions");

            //Get tier data from data files
            dataInitialization();
        }

        protected override void LoadDefaultConfig()
        {
            Config["world", "outerWall"] = outerWall;
            Config["world", "middleWall"] = middleWall;
            Config["world", "InnerWall"] = InnerWall;
            Config["world", "distanceToBuildFromWalls"] = distanceToBuildFromWalls;
            Config["world", "enableZoneIndicators"] = enableZoneIndicators;
            Config["world", "zoneIndicatorStrength"] = zoneIndicatorStrength;

            Config["player tiers", "updateTierTime"] = updateTierTime;

            Config["hackable crates", "maxHackableCrateSpawns"] = maxHackableCrateSpawns;
            Config["hackable crates", "hackAbleWarZoneExtraTime"] = hackAbleWarZoneExtraTime;
            Config["hackable crates", "hackableCratesSpawedAtPluginStart"] = hackableCratesSpawedAtPluginStart;
            Config["hackable crates", "timeBetweenHackableSpawnTries"] = timeBetweenHackableSpawnTries;
            Config["hackable crates", "hackableCrateZone1Time"] = hackableCrateZone1Time;
            Config["hackable crates", "hackableCrateZone2Time"] = hackableCrateZone2Time;
            Config["hackable crates", "hackableCrateZone3Time"] = hackableCrateZone3Time;
            Config["hackable crates", "hackableCrateZone4Time"] = hackableCrateZone4Time;

            Config["hackable crates", "content", "hackableCrateZone1ArmourStart"] = hackableCrateZone1ArmourStart;
            Config["hackable crates", "content", "hackableCrateZone1ArmourEnd"] = hackableCrateZone1ArmourEnd;
            Config["hackable crates", "content", "hackableCrateZone2ArmourStart"] = hackableCrateZone2ArmourStart;
            Config["hackable crates", "content", "hackableCrateZone2ArmourEnd"] = hackableCrateZone2ArmourEnd;
            Config["hackable crates", "content", "hackableCrateZone3ArmourStart"] = hackableCrateZone3ArmourStart;
            Config["hackable crates", "content", "hackableCrateZone3ArmourEnd"] = hackableCrateZone3ArmourEnd;
            Config["hackable crates", "content", "hackableCrateZone4ArmourStart"] = hackableCrateZone4ArmourStart;
            Config["hackable crates", "content", "hackableCrateZone4ArmourEnd"] = hackableCrateZone4ArmourEnd;
            Config["hackable crates", "content", "hackableCrateZone1WeaponStart"] = hackableCrateZone1WeaponStart;
            Config["hackable crates", "content", "hackableCrateZone1WeaponEnd"] = hackableCrateZone1WeaponEnd;
            Config["hackable crates", "content", "hackableCrateZone2WeaponStart"] = hackableCrateZone2WeaponStart;
            Config["hackable crates", "content", "hackableCrateZone2WeaponEnd"] = hackableCrateZone2WeaponEnd;
            Config["hackable crates", "content", "hackableCrateZone3WeaponStart"] = hackableCrateZone3WeaponStart;
            Config["hackable crates", "content", "hackableCrateZone3WeaponEnd"] = hackableCrateZone3WeaponEnd;
            Config["hackable crates", "content", "hackableCrateZone4WeaponStart"] = hackableCrateZone4WeaponStart;
            Config["hackable crates", "content", "hackableCrateZone4WeaponEnd"] = hackableCrateZone4WeaponEnd;

            Config["war zones", "warZoneSize"] = warZoneSize;
            Config["war zones", "warZoneRaidAliveTimer"] = warZoneRaidAliveTimer;
            Config["war zones", "playerWarZone1Delay"] = playerWarZone1Delay;
            Config["war zones", "playerWarZone2Delay"] = playerWarZone2Delay;
            Config["war zones", "playerWarZone3Delay"] = playerWarZone3Delay;
            Config["war zones", "playerWarZone4Delay"] = playerWarZone4Delay;
            Config["war zones", "timeBeforePlayerTakeDamageWhenEnterWarZone"] = timeBeforePlayerTakeDamageWhenEnterWarZone;
            Config["war zones", "startWarZoneAfterDamageToStructure"] = startWarZoneAfterDamageToStructure;
            Config["war zones", "warZoneEnterDamage"] = warZoneEnterDamage;
            Config["war zones", "canDieWhenEnteringWarZone"] = canDieWhenEnteringWarZone;
        }

        void updateSettingsFromConfigFile()
        {
            LoadConfig();

            outerWall = (int)Config["world", "outerWall"];
            middleWall = (int)Config["world", "middleWall"];
            InnerWall = (int)Config["world", "InnerWall"];
            distanceToBuildFromWalls = (int)Config["world", "distanceToBuildFromWalls"];
            enableZoneIndicators = (bool)Config["world", "enableZoneIndicators"];
            zoneIndicatorStrength = (int)Config["world", "zoneIndicatorStrength"];

            updateTierTime = (int)Config["player tiers", "updateTierTime"];

            maxHackableCrateSpawns = (int)Config["hackable crates", "maxHackableCrateSpawns"];
            hackAbleWarZoneExtraTime = (int)Config["hackable crates", "hackAbleWarZoneExtraTime"];
            hackableCratesSpawedAtPluginStart = (int)Config["hackable crates", "hackableCratesSpawedAtPluginStart"];
            timeBetweenHackableSpawnTries = (int)Config["hackable crates", "timeBetweenHackableSpawnTries"];
            hackableCrateZone1Time = (int)Config["hackable crates", "hackableCrateZone1Time"];
            hackableCrateZone2Time = (int)Config["hackable crates", "hackableCrateZone2Time"];
            hackableCrateZone3Time = (int)Config["hackable crates", "hackableCrateZone3Time"];
            hackableCrateZone4Time = (int)Config["hackable crates", "hackableCrateZone4Time"];

            hackableCrateZone1ArmourStart = (int)Config["hackable crates", "content", "hackableCrateZone1ArmourStart"];
            hackableCrateZone1ArmourEnd = (int)Config["hackable crates", "content", "hackableCrateZone1ArmourEnd"];
            hackableCrateZone2ArmourStart = (int)Config["hackable crates", "content", "hackableCrateZone2ArmourStart"];
            hackableCrateZone2ArmourEnd = (int)Config["hackable crates", "content", "hackableCrateZone2ArmourEnd"];
            hackableCrateZone3ArmourStart = (int)Config["hackable crates", "content", "hackableCrateZone3ArmourStart"];
            hackableCrateZone3ArmourEnd = (int)Config["hackable crates", "content", "hackableCrateZone3ArmourEnd"];
            hackableCrateZone4ArmourStart = (int)Config["hackable crates", "content", "hackableCrateZone4ArmourStart"];
            hackableCrateZone4ArmourEnd = (int)Config["hackable crates", "content", "hackableCrateZone4ArmourEnd"];
            hackableCrateZone1WeaponStart = (int)Config["hackable crates", "content", "hackableCrateZone1WeaponStart"];
            hackableCrateZone1WeaponEnd = (int)Config["hackable crates", "content", "hackableCrateZone1WeaponEnd"];
            hackableCrateZone2WeaponStart = (int)Config["hackable crates", "content", "hackableCrateZone2WeaponStart"];
            hackableCrateZone2WeaponEnd = (int)Config["hackable crates", "content", "hackableCrateZone2WeaponEnd"];
            hackableCrateZone3WeaponStart = (int)Config["hackable crates", "content", "hackableCrateZone3WeaponStart"];
            hackableCrateZone3WeaponEnd = (int)Config["hackable crates", "content", "hackableCrateZone3WeaponEnd"];
            hackableCrateZone4WeaponStart = (int)Config["hackable crates", "content", "hackableCrateZone4WeaponStart"];
            hackableCrateZone4WeaponEnd = (int)Config["hackable crates", "content", "hackableCrateZone4WeaponEnd"];

            warZoneSize = (int)Config["war zones", "warZoneSize"];
            warZoneRaidAliveTimer = (int)Config["war zones", "warZoneRaidAliveTimer"];
            playerWarZone1Delay = (int)Config["war zones", "playerWarZone1Delay"];
            playerWarZone2Delay = (int)Config["war zones", "playerWarZone2Delay"];
            playerWarZone3Delay = (int)Config["war zones", "playerWarZone3Delay"];
            playerWarZone4Delay = (int)Config["war zones", "playerWarZone4Delay"];
            timeBeforePlayerTakeDamageWhenEnterWarZone = (int)Config["war zones", "timeBeforePlayerTakeDamageWhenEnterWarZone"];
            startWarZoneAfterDamageToStructure = (int)Config["war zones", "startWarZoneAfterDamageToStructure"];
            warZoneEnterDamage = (int)Config["war zones", "warZoneEnterDamage"];
            canDieWhenEnteringWarZone = (bool)Config["war zones", "canDieWhenEnteringWarZone"];

            if(zoneIndicatorStrength > 50)
            {
                zoneIndicatorStrength = 50;
            }

            if(hackableCratesSpawedAtPluginStart > 500)
            {
                hackableCratesSpawedAtPluginStart = 500;
            }

            if (timeBetweenHackableSpawnTries < 2)
            {
                hackableCratesSpawedAtPluginStart = 2;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantDamagePlayer"] = "<color=#ec3636>[Warning]</color> Cant damage players in <color=#3683ec>tier {0}</color>!",
                ["CantDamageUpdatingTier"] = "<color=#ec3636>[Warning]</color> Cant deal damage while updating tier!",
                ["CantDamageInOtherZones"] = "<color=#ec3636>[Warning]</color> Cant damage players in other Zones!",
                ["CantDamageBuldings"] = "<color=#ec3636>[Warning]</color> Cant damage buldings for {0}!",
                ["StartWarZoneIfDamageDealt"] = "<color=#ec3636>[Warning]</color> Starting warzone zone if {0} more damage dealt!",
                ["OnlyWood"] = "<color=#ec3636>[Warning]</color> Can only use <color=#3683ec>Wood</color> in Zone 1!",
                ["OnlyWoodStone"] = "<color=#ec3636>[Warning]</color> Can only use <color=#3683ec>Wood</color> and <color=#3683ec>Stone</color> in Zone 2!",
                ["OnlyWoodStoneMetal"] = "<color=#ec3636>[Warning]</color> Can only use <color=#3683ec>Wood</color>, <color=#3683ec>Stone</color> and <color=#3683ec>Metal</color> in Zone 3!",
                ["Vomited"] = "<color=#ec3636>[Vomited]</color> Lost {0} health!",
                ["UpdatingTier"] = "updating",
                ["OnlyWoodenDoors"] = "<color=#ec3636>[Warning]</color> You can only build <color=#3683ec>wooden</color> doors in Zone 1!",
                ["OnlyWoodenMetalDoors"] = "<color=#ec3636>[Warning]</color> You can only build <color=#3683ec>wooden</color> and <color=#3683ec>metal</color> doors in Zone 2!",
                ["CantBuildCloseToEdge"] = "<color=#ec3636>[Warning]</color> Cant build so close to the edge of a zone!",
                ["NoDamageWhileUpdatingTier"] = "<color=#ec3636>[Warning]</color> While updating tier everyone can kill you, but you cant deal damage to players!",
                ["ChangingTier"] = "Changing",
                ["CrateSpawn"] = "Added crate spawn at position: {0}",
            }, this);
        }

        DynamicConfigFile createConfigFileIfDontExist(string file)
        {
            Debug.Log(Config["LeaveMessage"]);
            bool didExist = false;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(file))
            {
                Puts("File " + file + " allready exists. No need to create one.");

                didExist = true;
            }

            DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile(file);

            if (didExist == false)
            {
                if (file == "LayersOfRiskWeapons")
                {
                    dataFile["1", "id"] = 963906841; dataFile["1", "shortName"] = "rock"; dataFile["1", "value"] = 5; dataFile["1", "followItem"] = 0;
                    dataFile["2", "id"] = 1711033574; dataFile["2", "shortName"] = "bone.club"; dataFile["2", "value"] = 20; dataFile["2", "followItem"] = 1;
                    dataFile["3", "id"] = -1583967946; dataFile["3", "shortName"] = "stonehatchet"; dataFile["3", "value"] = 35; dataFile["3", "followItem"] = 1;
                    dataFile["4", "id"] = 171931394; dataFile["4", "shortName"] = "stone.pickaxe"; dataFile["4", "value"] = 35; dataFile["4", "followItem"] = 1;
                    dataFile["5", "id"] = 1814288539; dataFile["5", "shortName"] = "knife.bone"; dataFile["5", "value"] = 50; dataFile["5", "followItem"] = 1;
                    dataFile["6", "id"] = 1540934679; dataFile["6", "shortName"] = "spear.wooden"; dataFile["6", "value"] = 70; dataFile["6", "followItem"] = 1;
                    dataFile["7", "id"] = 1602646136; dataFile["7", "shortName"] = "spear.stone"; dataFile["7", "value"] = 100; dataFile["7", "followItem"] = 1;
                    dataFile["8", "id"] = -1252059217; dataFile["8", "shortName"] = "hatchet"; dataFile["8", "value"] = 100; dataFile["8", "followItem"] = 1;
                    dataFile["9", "id"] = -1302129395; dataFile["9", "shortName"] = "pickaxe"; dataFile["9", "value"] = 100; dataFile["9", "followItem"] = 1;

                    dataFile["10", "id"] = -1137865085; dataFile["10", "shortName"] = "machete"; dataFile["10", "value"] = 110; dataFile["10", "followItem"] = 1;
                    dataFile["11", "id"] = -1966748496; dataFile["11", "shortName"] = "mace"; dataFile["11", "value"] = 130; dataFile["11", "followItem"] = 1;
                    dataFile["12", "id"] = -1978999529; dataFile["12", "shortName"] = "salvaged.cleaver"; dataFile["12", "value"] = 140; dataFile["12", "followItem"] = 1;
                    dataFile["13", "id"] = -1506397857; dataFile["13", "shortName"] = "hammer.salvaged"; dataFile["13", "value"] = 140; dataFile["13", "followItem"] = 1;
                    dataFile["14", "id"] = -1780802565; dataFile["14", "shortName"] = "icepick.salvaged"; dataFile["14", "value"] = 160; dataFile["14", "followItem"] = 1;
                    dataFile["15", "id"] = -262590403; dataFile["15", "shortName"] = "axe.salvaged"; dataFile["15", "value"] = 160; dataFile["15", "followItem"] = 1;
                    dataFile["16", "id"] = -1469578201; dataFile["16", "shortName"] = "longsword"; dataFile["16", "value"] = 180; dataFile["16", "followItem"] = 1;
                    dataFile["17", "id"] = 1326180354; dataFile["17", "shortName"] = "salvaged.sword"; dataFile["17", "value"] = 180; dataFile["17", "followItem"] = 1;
                    dataFile["18", "id"] = -75944661; dataFile["18", "shortName"] = "pistol.eoka"; dataFile["18", "value"] = 195; dataFile["18", "followItem"] = 588596902;
                    dataFile["19", "id"] = 1443579727; dataFile["19", "shortName"] = "bow.hunting"; dataFile["19", "value"] = 210; dataFile["19", "followItem"] = -1234735557;

                    dataFile["20", "id"] = -1367281941; dataFile["20", "shortName"] = "shotgun.waterpipe"; dataFile["20", "value"] = 270; dataFile["20", "followItem"] = 588596902;
                    dataFile["21", "id"] = 1953903201; dataFile["21", "shortName"] = "pistol.nailgun"; dataFile["21", "value"] = 270; dataFile["21", "followItem"] = 588596902;
                    dataFile["22", "id"] = -1215753368; dataFile["22", "shortName"] = "flamethrower"; dataFile["22", "value"] = 310; dataFile["22", "followItem"] = 0;
                    dataFile["23", "id"] = 1104520648; dataFile["23", "shortName"] = "chainsaw"; dataFile["23", "value"] = 320; dataFile["23", "followItem"] = 0;
                    dataFile["24", "id"] = 1488979457; dataFile["24", "shortName"] = "jackhammer"; dataFile["24", "value"] = 320; dataFile["24", "followItem"] = 0;
                    dataFile["25", "id"] = -765183617; dataFile["25", "shortName"] = "shotgun.double"; dataFile["25", "value"] = 320; dataFile["25", "followItem"] = -727717969;
                    dataFile["26", "id"] = 1965232394; dataFile["26", "shortName"] = "crossbow"; dataFile["26", "value"] = 320; dataFile["26", "followItem"] = -1234735557;
                    dataFile["27", "id"] = 884424049; dataFile["27", "shortName"] = "bow.compound"; dataFile["27", "value"] = 340; dataFile["27", "followItem"] = -1234735557;
                    dataFile["28", "id"] = 649912614; dataFile["28", "shortName"] = "pistol.revolver"; dataFile["28", "value"] = 395; dataFile["28", "followItem"] = 785728077;
                    dataFile["29", "id"] = 818877484; dataFile["29", "shortName"] = "pistol.semiauto"; dataFile["29", "value"] = 405; dataFile["29", "followItem"] = 785728077;

                    dataFile["30", "id"] = 795371088; dataFile["30", "shortName"] = "shotgun.pump"; dataFile["30", "value"] = 440; dataFile["30", "followItem"] = -727717969;
                    dataFile["31", "id"] = -852563019; dataFile["31", "shortName"] = "pistol.m92"; dataFile["31", "value"] = 460; dataFile["31", "followItem"] = 785728077;
                    dataFile["32", "id"] = 1373971859; dataFile["32", "shortName"] = "pistol.python"; dataFile["32", "value"] = 500; dataFile["32", "followItem"] = 785728077;
                    dataFile["33", "id"] = 1796682209; dataFile["33", "shortName"] = "smg.2"; dataFile["33", "value"] = 610; dataFile["33", "followItem"] = 785728077;
                    dataFile["34", "id"] = -1758372725; dataFile["34", "shortName"] = "smg.thompson"; dataFile["34", "value"] = 620; dataFile["34", "followItem"] = 785728077;
                    dataFile["35", "id"] = -41440462; dataFile["35", "shortName"] = "shotgun.spas12"; dataFile["35", "value"] = 640; dataFile["35", "followItem"] = -727717969;
                    dataFile["36", "id"] = 1318558775; dataFile["36", "shortName"] = "smg.mp5"; dataFile["36", "value"] = 660; dataFile["36", "followItem"] = 785728077;
                    dataFile["37", "id"] = 442886268; dataFile["37", "shortName"] = "rocket.launcher"; dataFile["37", "value"] = 680; dataFile["37", "followItem"] = 1;
                    dataFile["38", "id"] = -904863145; dataFile["38", "shortName"] = "rifle.semiauto"; dataFile["38", "value"] = 680; dataFile["38", "followItem"] = -1211166256;
                    dataFile["39", "id"] = 1588298435; dataFile["39", "shortName"] = "rifle.bolt"; dataFile["39", "value"] = 680; dataFile["39", "followItem"] = -1211166256;

                    dataFile["40", "id"] = -1812555177; dataFile["40", "shortName"] = "rifle.lr300"; dataFile["40", "value"] = 795; dataFile["40", "followItem"] = -1211166256;
                    dataFile["41", "id"] = 1545779598; dataFile["41", "shortName"] = "rifle.ak"; dataFile["41", "value"] = 795; dataFile["41", "followItem"] = -1211166256;
                    dataFile["42", "id"] = 28201841; dataFile["42", "shortName"] = "rifle.m39"; dataFile["42", "value"] = 810; dataFile["42", "followItem"] = -1211166256;
                    dataFile["43", "id"] = -1123473824; dataFile["43", "shortName"] = "multiplegrenadelauncher"; dataFile["43", "value"] = 830; dataFile["43", "followItem"] = 0;
                    dataFile["44", "id"] = -778367295; dataFile["44", "shortName"] = "rifle.l96"; dataFile["44", "value"] = 850; dataFile["44", "followItem"] = -1211166256;
                    dataFile["45", "id"] = -2069578888; dataFile["45", "shortName"] = "lmg.m249"; dataFile["45", "value"] = 880; dataFile["45", "followItem"] = -1211166256;
                }
                else if (file == "LayersOfRiskArmours")
                {
                    dataFile["1", "id"] = 223891266; dataFile["1", "shortName"] = "tshirt"; dataFile["1", "value"] = 8; dataFile["1", "followItem"] = -2072273936;
                    dataFile["2", "id"] = 1608640313; dataFile["2", "shortName"] = "shirt.tanktop"; dataFile["2", "value"] = 8; dataFile["2", "followItem"] = -2072273936;
                    dataFile["3", "id"] = -1695367501; dataFile["3", "shortName"] = "pants.shorts"; dataFile["3", "value"] = 8; dataFile["3", "followItem"] = -2072273936;
                    dataFile["4", "id"] = -2025184684; dataFile["4", "shortName"] = "shirt.collared"; dataFile["4", "value"] = 8; dataFile["4", "followItem"] = -2072273936;
                    dataFile["5", "id"] = 237239288; dataFile["5", "shortName"] = "pants"; dataFile["5", "value"] = 8; dataFile["5", "followItem"] = -2072273936;
                    dataFile["6", "id"] = 935692442; dataFile["6", "shortName"] = "tshirt.long"; dataFile["6", "value"] = 8; dataFile["6", "followItem"] = -2072273936;
                    dataFile["7", "id"] = 1366282552; dataFile["7", "shortName"] = "burlap.gloves"; dataFile["7", "value"] = 8; dataFile["7", "followItem"] = -2072273936;
                    dataFile["8", "id"] = -1000573653; dataFile["8", "shortName"] = "boots.frog"; dataFile["8", "value"] = 8; dataFile["8", "followItem"] = -2072273936;
                    dataFile["9", "id"] = 1992974553; dataFile["9", "shortName"] = "burlap.trousers"; dataFile["9", "value"] = 8; dataFile["9", "followItem"] = -2072273936;

                    dataFile["10", "id"] = -761829530; dataFile["10", "shortName"] = "burlap.shoes"; dataFile["10", "value"] = 8; dataFile["10", "followItem"] = -2072273936;
                    dataFile["11", "id"] = 602741290; dataFile["11", "shortName"] = "burlap.shirt"; dataFile["11", "value"] = 8; dataFile["11", "followItem"] = -2072273936;
                    dataFile["12", "id"] = 1877339384; dataFile["12", "shortName"] = "burlap.headwrap"; dataFile["12", "value"] = 8; dataFile["12", "followItem"] = -2072273936;
                    dataFile["13", "id"] = 21402876; dataFile["13", "shortName"] = "burlap.gloves.new"; dataFile["13", "value"] = 8; dataFile["13", "followItem"] = -2072273936;
                    dataFile["14", "id"] = -1549739227; dataFile["14", "shortName"] = "shoes.boots"; dataFile["14", "value"] = 10; dataFile["14", "followItem"] = -2072273936;
                    dataFile["15", "id"] = -23994173; dataFile["15", "shortName"] = "hat.boonie"; dataFile["15", "value"] = 10; dataFile["15", "followItem"] = -2072273936;
                    dataFile["16", "id"] = 1675639563; dataFile["16", "shortName"] = "hat.beenie"; dataFile["16", "value"] = 10; dataFile["16", "followItem"] = -2072273936;
                    dataFile["17", "id"] = -1022661119; dataFile["17", "shortName"] = "hat.cap"; dataFile["17", "value"] = 10; dataFile["17", "followItem"] = -2072273936;
                    dataFile["18", "id"] = 196700171; dataFile["18", "shortName"] = "attire.hide.vest"; dataFile["18", "value"] = 14; dataFile["18", "followItem"] = -2072273936;
                    dataFile["19", "id"] = -1773144852; dataFile["19", "shortName"] = "attire.hide.skirt"; dataFile["19", "value"] = 14; dataFile["19", "followItem"] = -2072273936;

                    dataFile["20", "id"] = 1722154847; dataFile["20", "shortName"] = "attire.hide.pants"; dataFile["20", "value"] = 14; dataFile["20", "followItem"] = -2072273936;
                    dataFile["21", "id"] = 3222790; dataFile["21", "shortName"] = "attire.hide.helterneck"; dataFile["21", "value"] = 14; dataFile["21", "followItem"] = -2072273936;
                    dataFile["22", "id"] = 794356786; dataFile["22", "shortName"] = "attire.hide.boots"; dataFile["22", "value"] = 14; dataFile["22", "followItem"] = -2072273936;
                    dataFile["23", "id"] = -702051347; dataFile["23", "shortName"] = "mask.bandana"; dataFile["23", "value"] = 15; dataFile["23", "followItem"] = -2072273936;
                    dataFile["24", "id"] = 850280505; dataFile["24", "shortName"] = "bucket.helmet"; dataFile["24", "value"] = 20; dataFile["24", "followItem"] = -2072273936;
                    dataFile["25", "id"] = -2012470695; dataFile["25", "shortName"] = "mask.balaclava"; dataFile["25", "value"] = 20; dataFile["25", "followItem"] = -2072273936;
                    dataFile["26", "id"] = -699558439; dataFile["26", "shortName"] = "roadsign.gloves"; dataFile["26", "value"] = 20; dataFile["26", "followItem"] = -2072273936;
                    dataFile["27", "id"] = 1751045826; dataFile["27", "shortName"] = "hoodie"; dataFile["27", "value"] = 20; dataFile["27", "followItem"] = -2072273936;
                    dataFile["28", "id"] = -2094954543; dataFile["28", "shortName"] = "wood.armor.helmet"; dataFile["28", "value"] = 25; dataFile["28", "followItem"] = -2072273936;
                    dataFile["29", "id"] = -1163532624; dataFile["29", "shortName"] = "jacket"; dataFile["29", "value"] = 25; dataFile["29", "followItem"] = -2072273936;

                    dataFile["30", "id"] = -48090175; dataFile["30", "shortName"] = "jacket.snow"; dataFile["30", "value"] = 30; dataFile["30", "followItem"] = -2072273936;
                    dataFile["31", "id"] = 418081930; dataFile["31", "shortName"] = "wood.armor.jacket"; dataFile["31", "value"] = 30; dataFile["31", "followItem"] = -2072273936;
                    dataFile["32", "id"] = 832133926; dataFile["32", "shortName"] = "wood.armor.pants"; dataFile["32", "value"] = 30; dataFile["32", "followItem"] = -2072273936;
                    dataFile["33", "id"] = 980333378; dataFile["33", "shortName"] = "attire.hide.poncho"; dataFile["33", "value"] = 30; dataFile["33", "followItem"] = -2072273936;
                    dataFile["34", "id"] = -1903165497; dataFile["34", "shortName"] = "deer.skull.mask"; dataFile["34", "value"] = 30; dataFile["34", "followItem"] = -2072273936;
                    dataFile["35", "id"] = 968019378; dataFile["35", "shortName"] = "clatter.helmet"; dataFile["35", "value"] = 40; dataFile["35", "followItem"] = 1079279582;
                    dataFile["36", "id"] = -2002277461; dataFile["36", "shortName"] = "roadsign.jacket"; dataFile["36", "value"] = 40; dataFile["36", "followItem"] = 1079279582;
                    dataFile["37", "id"] = 1850456855; dataFile["37", "shortName"] = "roadsign.kilt"; dataFile["37", "value"] = 40; dataFile["37", "followItem"] = 1079279582;
                    dataFile["38", "id"] = 1746956556; dataFile["38", "shortName"] = "bone.armor.suit"; dataFile["38", "value"] = 40; dataFile["38", "followItem"] = -2072273936;
                    dataFile["39", "id"] = -1478212975; dataFile["39", "shortName"] = "hat.wolf"; dataFile["39", "value"] = 50; dataFile["39", "followItem"] = 1079279582;

                    dataFile["40", "id"] = -803263829; dataFile["40", "shortName"] = "coffeecan.helmet"; dataFile["40", "value"] = 55; dataFile["40", "followItem"] = 1079279582;
                    dataFile["41", "id"] = -1108136649; dataFile["41", "shortName"] = "tactical.gloves"; dataFile["41", "value"] = 100; dataFile["41", "followItem"] = 1079279582;
                    dataFile["42", "id"] = 671063303; dataFile["42", "shortName"] = "riot.helmet"; dataFile["42", "value"] = 100; dataFile["42", "followItem"] = 1079279582;
                    dataFile["43", "id"] = 1266491000; dataFile["43", "shortName"] = "hazmatsuit"; dataFile["43", "value"] = 150; dataFile["43", "followItem"] = 1079279582;
                    dataFile["44", "id"] = 1110385766; dataFile["44", "shortName"] = "metal.plate.torso"; dataFile["44", "value"] = 150; dataFile["44", "followItem"] = 254522515;
                    dataFile["45", "id"] = -194953424; dataFile["45", "shortName"] = "metal.facemask"; dataFile["45", "value"] = 175; dataFile["45", "followItem"] = 254522515;
                    dataFile["46", "id"] = -1102429027; dataFile["46", "shortName"] = "heavy.plate.jacket"; dataFile["46", "value"] = 200; dataFile["46", "followItem"] = 254522515;
                    dataFile["47", "id"] = 1181207482; dataFile["47", "shortName"] = "heavy.plate.helmet"; dataFile["47", "value"] = 225; dataFile["47", "followItem"] = 254522515;
                    dataFile["48", "id"] = -1778159885; dataFile["48", "shortName"] = "heavy.plate.pants"; dataFile["48", "value"] = 250; dataFile["48", "followItem"] = 254522515;
                }
                else if (file == "LayersOfRiskTierData")
                {
                    dataFile["1", "tier"] = "E";dataFile["1", "min"] = 0;dataFile["1", "max"] = 199;
                    dataFile["2", "tier"] = "D";dataFile["2", "min"] = 200;dataFile["2", "max"] = 399;
                    dataFile["3", "tier"] = "C";dataFile["3", "min"] = 400;dataFile["3", "max"] = 599;
                    dataFile["4", "tier"] = "B";dataFile["4", "min"] = 600;dataFile["4", "max"] = 799;
                    dataFile["5", "tier"] = "A";dataFile["5", "min"] = 800;dataFile["5", "max"] = 99999;
                }
                else if(file == "LayersOfRiskHackableCratePositions")
                {
                    dataFile["1", "posX"] = 0;
                    dataFile["1", "posY"] = 0;
                    dataFile["1", "posZ"] = 0;
                }

                dataFile.Save();

                Puts("Data file " + file + " did not exists and was created with default values!");
            }

            return dataFile;
        }

        void dataInitialization()
        {
            int count = 0;

            //Tier data dictionary initialization
            for (int i = 1; i <= tiersDataFile.Count();i++)
            {
                tierDataDic.Add(i,
                new tierDataClass
                {
                    tierLetter = tiersDataFile[i.ToString(), "tier"].ToString(),
                    min = Int32.Parse(tiersDataFile[i.ToString(), "min"].ToString()),
                    max = Int32.Parse(tiersDataFile[i.ToString(), "max"].ToString()),
                });
                count++;
            }

            Puts("Added " + count + " Keys with values in tierDataDic!");

            //Weapon data dictionary initialization
            count = 0;
            for (int i = 1; i <= weaponsDataFile.Count(); i++)
            {
                weaponDataDic.Add(Int32.Parse(weaponsDataFile[i.ToString(), "id"].ToString()),
                new itemDataClass
                {
                    shortName = weaponsDataFile[i.ToString(), "shortName"].ToString(),
                    value = Int32.Parse(weaponsDataFile[i.ToString(), "value"].ToString()),
                    followItem = Int32.Parse(weaponsDataFile[i.ToString(), "followItem"].ToString()),
                });
                count++;
            }

            Puts("Added " + count + " Keys with values in weaponDataDic!");

            //Armour data dictionary initialization
            count = 0;
            for (int i = 1; i <= armoursDataFile.Count(); i++)
            {
                armourDataDic.Add(Int32.Parse(armoursDataFile[i.ToString(), "id"].ToString()),
                new itemDataClass
                {
                    shortName = armoursDataFile[i.ToString(), "shortName"].ToString(),
                    value = Int32.Parse(armoursDataFile[i.ToString(), "value"].ToString()),
                    followItem = Int32.Parse(armoursDataFile[i.ToString(), "followItem"].ToString()),
                });
                count++;
            }

            Puts("Added " + count + " Keys with values in armourDataDic!");

            //Hackable crate data dictionary initialization
            count = 0;
            for (int i = 1; i <= hackableCreatPositionsDataFile.Count(); i++)
            {
                float posX = float.Parse(hackableCreatPositionsDataFile[i.ToString(), "posX"].ToString());
                float posY = float.Parse(hackableCreatPositionsDataFile[i.ToString(), "posY"].ToString());
                float posZ = float.Parse(hackableCreatPositionsDataFile[i.ToString(), "posZ"].ToString());

                hackableCrateDataDic.Add(new Vector3(posX, posY, posZ),
                new hackableCrateDataClass
                {
                    inUse = false,
                });
                count++;
            }

            Puts("Added " + count + " Keys with values in hackableCreateDataDic!");
        }
        void lateInitializing()
        {
            //Check if lateInitializing has been run after plugin start.
            if (hasLateInitializedBeenRun == false)
            {
                //Delete all spheres in the world
                rust.RunServerCommand("del " + warZoneSphere);

                //Delete all hackable crates in the world
                rust.RunServerCommand("del " + hackableCreate);

                //Spawn world spheres
                if(enableZoneIndicators)
                {
                    for (int i = 0; i < zoneIndicatorStrength; i++)
                    {
                        spawnSpherePreFab((outerWall * 2) + 6, middlePosition);
                        spawnSpherePreFab((middleWall * 2) + 6, middlePosition);
                        spawnSpherePreFab((InnerWall * 2) + 3, middlePosition);
                    }
                }

                //Start controller for hackable crates
                hackableCrateSpawnTimer();

                hasLateInitializedBeenRun = true;
            }
        }

        BaseEntity spawnSpherePreFab(float size, Vector3 spawnPos)
        {
            //Sphere prefab
            string SphereEnt = warZoneSphere;

            BaseEntity sphere = GameManager.server.CreateEntity(SphereEnt, spawnPos, new Quaternion(), true);
            SphereEntity ent = sphere.GetComponent<SphereEntity>();
            ent.currentRadius = size;
            ent.lerpSpeed = 0f;

            sphere.Spawn();

            return sphere;
        }

        void hackableCrateSpawnTimer()
        {
            //Spawn multipule hackable crates one time at plugin start up.
            for(int i = 0; i < hackableCratesSpawedAtPluginStart; i++)
            {
                hackableCrateSpawnController();
            }

            //Create timer
            Timer controllTimer;

            controllTimer = timer.Every(timeBetweenHackableSpawnTries, () =>
            {
                hackableCrateSpawnController();
            });
        }

        void hackableCrateSpawnController()
        {
            //Get random position
            Random randNum = new Random();
            int totalhackableSpawnPositions = hackableCrateDataDic.Count();

            //Get random position
            int getRandomSpawn = randNum.Next(0, totalhackableSpawnPositions );

            //If random position is not in use and not maximum amount of hackable crates has spawned.
            if (hackableCrateDataDic.Values.ElementAt(getRandomSpawn) != null && hackableCrateDataDic.Values.ElementAt(getRandomSpawn).inUse == false && getHowManyHackableCratesSpawned() < maxHackableCrateSpawns)
            {
                //Get spawn position
                Vector3 spawnPos = hackableCrateDataDic.Keys.ElementAt(getRandomSpawn);

                //Spawn hackable crate
                spawnHackableCreate(spawnPos);
            }
        }

        void spawnHackableCreate(Vector3 spawnPos)
        {
            if(spawnPos != Vector3.zero)
            {
                //Get base entity
                BaseEntity crate = GameManager.server.CreateEntity(hackableCreate, spawnPos, new Quaternion(), true);

                //Spawn crate
                crate.Spawn();
            }
        }

        int getHowManyHackableCratesSpawned()
        {

            //How many hackable crates is spawned varaible
            int hackableCratesSpawned = 0;

            //Go through all items in hackableCrateDataDic
            foreach (var item in hackableCrateDataDic)
            {
                //Set position and direction for ray cast
                Ray ray = new Ray(item.Key + vectormultiplier, downDirection);

                BaseEntity entity = getEntityFromRayCastHit(ray);

                //If ray cast hit an entity
                if (entity != null)
                {
                    //If ray cast did hit a hackable crate
                    if (entity.PrefabName == hackableCreate)
                    {
                        //Hackable crate exists on that position
                        item.Value.inUse = true;

                        //Add 1
                        hackableCratesSpawned++;
                    }
                }
                else
                {
                    //Hackable crate does not exists on that position
                    item.Value.inUse = false;
                }
            }

            return hackableCratesSpawned;
        }

        //Update content in container. Only runs when a player starts to hack a hackablecrate.
        void updateHackableCrateContainer(BaseEntity crate)
        {
            //Get crates storage container
            StorageContainer crateContainer = crate.GetComponent<StorageContainer>();

            //Create new container
            ItemContainer newContainer = new ItemContainer();
            newContainer.ServerInitialize(null, 6);
            newContainer.GiveUID();

            //Set crates container invetory to new containers inventory
            crateContainer.inventory = newContainer;

            Random randNum = new Random();
            int randWeaponDicElement = 0;
            int randArmourDicElement = 0;
            int randHackTime = 0;
            int randAmmoAmount;
            int randMedicAmount;

            //Add item
            Item weaponItem;
            Item weaponItemExtra = null;
            Item armourItem;
            Item armourItemExtra = null;

            //Zone 1
            if (getCurrentZone(getDistanceFromPosition(crate.transform.position, middlePosition, true)) == 1)
            {
                randWeaponDicElement = randNum.Next(hackableCrateZone1WeaponStart, hackableCrateZone1WeaponEnd);
                randArmourDicElement = randNum.Next(hackableCrateZone1ArmourStart, hackableCrateZone1ArmourEnd);
                randHackTime = hackableCrateZone1Time;
            }
            //Zone 2
            else if(getCurrentZone(getDistanceFromPosition(crate.transform.position, middlePosition, true)) == 2)
            {
                randWeaponDicElement = randNum.Next(hackableCrateZone2WeaponStart, hackableCrateZone2WeaponEnd);
                randArmourDicElement = randNum.Next(hackableCrateZone2ArmourStart, hackableCrateZone2ArmourEnd);
                randHackTime = hackableCrateZone2Time;
            }
            //Zone 3
            else if (getCurrentZone(getDistanceFromPosition(crate.transform.position, middlePosition, true)) == 3)
            {
                randWeaponDicElement = randNum.Next(hackableCrateZone3WeaponStart, hackableCrateZone3WeaponEnd);
                randArmourDicElement = randNum.Next(hackableCrateZone3ArmourStart, hackableCrateZone3ArmourEnd);
                randHackTime = hackableCrateZone3Time;
            }
            //Zone 4
            else if (getCurrentZone(getDistanceFromPosition(crate.transform.position, middlePosition, true)) == 4)
            {
                randWeaponDicElement = randNum.Next(hackableCrateZone4WeaponStart, hackableCrateZone4WeaponEnd);
                randArmourDicElement = randNum.Next(hackableCrateZone4ArmourStart, hackableCrateZone4ArmourEnd);
                randHackTime = hackableCrateZone4Time;
            }

            //Get weapon items from dictionary
            weaponItem = ItemManager.CreateByItemID(weaponDataDic.ElementAt(randWeaponDicElement).Key);
            if (weaponDataDic.ElementAt(randWeaponDicElement).Value.followItem != 1 && weaponDataDic.ElementAt(randWeaponDicElement).Value.followItem != 0)
            {
                randAmmoAmount = randNum.Next(15, 40);
                weaponItemExtra = ItemManager.CreateByItemID(weaponDataDic.ElementAt(randWeaponDicElement).Value.followItem, randAmmoAmount);
            }

            //Get armour items from dictionary
            armourItem = ItemManager.CreateByItemID(armourDataDic.ElementAt(randArmourDicElement).Key);
            if (armourDataDic.ElementAt(randArmourDicElement).Value.followItem != 1 && armourDataDic.ElementAt(randArmourDicElement).Value.followItem != 0)
            {
                randMedicAmount = randNum.Next(1, 3);
                armourItemExtra = ItemManager.CreateByItemID(armourDataDic.ElementAt(randArmourDicElement).Value.followItem, randMedicAmount);
            }

            //Add items to crate container
            weaponItem.MoveToContainer(newContainer);
            armourItem.MoveToContainer(newContainer);

            if(weaponItemExtra != null)
            {
                weaponItemExtra.MoveToContainer(newContainer);
            }

            if (armourItemExtra != null)
            {
                armourItemExtra.MoveToContainer(newContainer);
            }

            //Get HackableLockedCrate
            HackableLockedCrate ent = crate.GetComponent<HackableLockedCrate>();

            //Set how many seconds before crate will be unlocked (minus the default value on 15 min).
            ent.hackSeconds = randHackTime;

            //Set how long warzones will be up on hackable crates position.
            int getWarZoneUpTime;
            getWarZoneUpTime = (hackableCrateDefaultHackTime - randHackTime) + hackAbleWarZoneExtraTime;

            //Start war zone
            startWarZone(crate.transform.position, warZoneSize, getWarZoneUpTime);
        }
        #endregion

        #region Hooks
        void OnPlayerSleepEnded(BasePlayer player)
        {
            //Spawn world spheres if not spawned
            lateInitializing();

            //Set player data and start player initializing
            setPlayerData(player);

            //Create Tier GUI
            createInfoBox(player, uiTierBox, "Tier " + tierDataDic[playerDataDic[player.userID].tierId].tierLetter, tierBoxPosX, tierBoxPosY, tierBoxSizeX, tierBoxSizeY);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            //Get BasePlayers
            BasePlayer victim = entity.ToPlayer();
            BasePlayer attacker = info.InitiatorPlayer;

            //Is both attacker and victim awake and is player
            if (isPlayerAwake(victim) && isPlayerAwake(attacker))
            {
                //Check if attacker in same zone
                if (playerDataDic[attacker.userID].currentZone == playerDataDic[victim.userID].currentZone)
                {
                    //Check if attacker is not in warzone
                    if (playerDataDic[attacker.userID].currentZone < 5)
                    {
                        //Check if attacker is updating tier
                        if (playerDataDic[attacker.userID].currentUpdateCycle == 0)
                        {
                            //Check if victim is in teir range
                            if (canVictimTakeDamage(victim, attacker) == true)
                            {
                                info.damageTypes.ScaleAll(1);
                            }
                            else
                            {
                                string CantDamagePlayer = lang.GetMessage("CantDamagePlayer", this, attacker.UserIDString);
                                PrintToChat(attacker, string.Format(CantDamagePlayer, tierDataDic[playerDataDic[victim.userID].tierId].tierLetter));
                                info.damageTypes.ScaleAll(0);
                            }
                        }
                        else
                        {
                            PrintToChat(attacker, lang.GetMessage("CantDamageUpdatingTier", this, attacker.UserIDString));
                            info.damageTypes.ScaleAll(0);
                        }
                    }
                    else
                    {
                        //Always deal damage in warzones
                        info.damageTypes.ScaleAll(1);
                    }
                }
                else
                {
                    PrintToChat(attacker, lang.GetMessage("CantDamageInOtherZones", this, attacker.UserIDString));
                    info.damageTypes.ScaleAll(0);
                }
            }
            else
            {
                //If attacked entity has a density of 0.5 or lower the attacker will always do full damage.
                bool ignoreAttackedEntity = entity.baseProtection.density <= 0.5f;

                //Is attacker shooting on player made buildings
                if(isPlayerAwake(attacker) && entity.OwnerID != 0 && ignoreAttackedEntity == false)
                {
                    //Attacker is not inside raid zone.
                    if (playerDataDic[attacker.userID].currentZone != 5)
                    {
                        //Attacker damaging buildings not owned by the attacker
                        if (victim == null && entity.OwnerID != attacker.userID)
                        {
                            //Attacker cant damage other players buildings
                            if(playerDataDic[attacker.userID].cantStartRaidZoneTimer > 0)
                            {
                                string CantDamageBuldings = lang.GetMessage("CantDamageBuldings", this, attacker.UserIDString);
                                PrintToChat(attacker, string.Format(CantDamageBuldings, timeFormating((int)playerDataDic[attacker.userID].cantStartRaidZoneTimer)));
                                info.damageTypes.ScaleAll(0);
                            }
                            else
                            {
                                //Update startRaidZone variable, if its over a specific value a raid zone will spawn.
                                playerDataDic[attacker.userID].startRaidZoneAfterDamageDealtToStructure -= info.damageTypes.Total();

                                string StartWarZoneIfDamageDealt = lang.GetMessage("StartWarZoneIfDamageDealt", this, attacker.UserIDString);
                                PrintToChat(attacker, string.Format(StartWarZoneIfDamageDealt, Math.Round(playerDataDic[attacker.userID].startRaidZoneAfterDamageDealtToStructure)));

                                info.damageTypes.ScaleAll(1);

                                //Spawn and start raid zone
                                if (playerDataDic[attacker.userID].startRaidZoneAfterDamageDealtToStructure < 0)
                                {
                                    //Set to default value
                                    playerDataDic[attacker.userID].startRaidZoneAfterDamageDealtToStructure = startWarZoneAfterDamageToStructure;

                                    //If in zone 1
                                    playerDataDic[attacker.userID].cantStartRaidZoneTimer = playerWarZone1Delay;

                                    //If in zone 2 to 4
                                    if (playerDataDic[attacker.userID].currentZone == 2)
                                    {
                                        playerDataDic[attacker.userID].cantStartRaidZoneTimer = playerWarZone2Delay;
                                    }
                                    else if(playerDataDic[attacker.userID].currentZone == 3)
                                    {
                                        playerDataDic[attacker.userID].cantStartRaidZoneTimer = playerWarZone3Delay;
                                    }
                                    else if(playerDataDic[attacker.userID].currentZone == 4)
                                    {
                                        playerDataDic[attacker.userID].cantStartRaidZoneTimer = playerWarZone4Delay;
                                    }

                                    startWarZone(entity.transform.position, warZoneSize, warZoneRaidAliveTimer);
                                }
                            }
                        }
                        //Destroying own buildings
                        else
                        {
                            info.damageTypes.ScaleAll(1);
                        }
                    }
                    else
                    {
                        info.damageTypes.ScaleAll(1);
                    }
                }
                else
                {
                    info.damageTypes.ScaleAll(1);
                }
            }
        }

        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            //Upgrade materials
            bool isWood = grade.ToString() == "Wood";
            bool isStone = grade.ToString() == "Stone";
            bool isMetal = grade.ToString() == "Metal";

            if (playerDataDic[player.userID].currentZone == 1)
            {
                if(isWood)
                {
                    return null;
                }
                else
                {
                    PrintToChat(player, lang.GetMessage("OnlyWood", this, player.UserIDString));
                    return 1;
                }
            }
            else if (playerDataDic[player.userID].currentZone == 2)
            {
                if (isWood || isStone)
                {
                    return null;
                }
                else
                {
                    PrintToChat(player, lang.GetMessage("OnlyWoodStone", this, player.UserIDString));
                    return 1;
                }
            }
            else if(playerDataDic[player.userID].currentZone == 3)
            {
                if (isWood || isStone || isMetal)
                {
                    return null;
                }
                else
                {
                    PrintToChat(player, lang.GetMessage("OnlyWoodStoneMetal", this, player.UserIDString));
                    return 1;
                }
            }
            else
            {
                return null;
            }
        }

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            if(canPlayerBuild(planner, prefab) == true)
            {
                return null;
            }
            else
            {
                return 1;
            }
        }

        void OnCrateHack(HackableLockedCrate crate)
        {
            //Update crate container
            updateHackableCrateContainer(crate);
        }
        #endregion

        #region Player data
        void setPlayerData(BasePlayer player)
        {
            //Player steam id key
            bool doPlayerDataExist = playerDataDic.ContainsKey(player.userID);

            //Get tier points for player
            int getCurrentTier = getTierPointsForPlayer(player);

            if (doPlayerDataExist)
            {
                playerDataDic[player.userID].isUpdateTierTimerRunning = false;
                playerDataDic[player.userID].isPlayerInitialized = false;
                playerDataDic[player.userID].currentTier = getCurrentTier;
                playerDataDic[player.userID].nextTier = getCurrentTier;
                playerDataDic[player.userID].oldTier = getCurrentTier;
                playerDataDic[player.userID].distanceFromMiddle = getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true);
                //playerDataDic[player.userID].raidZoneTimer = 0;
                playerDataDic[player.userID].currentZone = getCurrentZone(getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true));
                //playerDataDic[player.userID].startRaidZoneAfterDamageDEalt = 0;
                playerDataDic[player.userID].currentUpdateCycle = 0;
                playerDataDic[player.userID].tierId = getTierId(getCurrentTier);
                playerDataDic[player.userID].lookPlayerDelay = 0;
            }
            else
            {
                //Set player data
                playerDataDic.Add(player.userID,
                new playerDataClass
                {
                    isUpdateTierTimerRunning = false,
                    isPlayerInitialized = false,
                    currentTier = getCurrentTier,
                    nextTier = getCurrentTier,
                    oldTier = getCurrentTier,
                    distanceFromMiddle = getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true),
                    cantStartRaidZoneTimer = 0,
                    currentZone = getCurrentZone(getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true)),
                    startRaidZoneAfterDamageDealtToStructure = startWarZoneAfterDamageToStructure,
                    currentUpdateCycle = 0,
                    tierId = getTierId(getCurrentTier),
                    lookPlayerDelay = 0
                });
            }

            //Start player initializing
            playerInitializeTimer(player);
        }

        //Return current player tier.
        int getTierPointsForPlayer(BasePlayer player)
        {
            int weaponPoints;
            int armourPoints;

            //Item conteiners
            ItemContainer containerBelt = player.inventory.containerBelt;
            ItemContainer containerWear = player.inventory.containerWear;
            ItemContainer containerMain = player.inventory.containerMain;

            //Loop through containerBelt and get highest valued weapon
            weaponPoints = getHighestWeaponValueFromContainer(containerBelt);

            //If containerMain has any item with higher value then containerBelt
            if(getHighestWeaponValueFromContainer(containerMain) > weaponPoints)
            {
                weaponPoints = getHighestWeaponValueFromContainer(containerMain);
            }

            //Loop through all containers and get the 5 highest valued items.
            armourPoints = getArmourItemPointsFromContainer(containerBelt, containerWear, containerMain, 5);

            return weaponPoints + armourPoints;
        }

        int getArmourItemPointsFromContainer(ItemContainer containerBelt, ItemContainer containerWear, ItemContainer containerMain, int maxItemsCounted)
        {
            //7 Best armour item values
            int countItemsInList = 0;
            int points = 0;

            ItemContainer[] containers = new ItemContainer[3];

            containers[0] = containerWear;
            containers[1] = containerMain;
            containers[2] = containerBelt;

            //Get items from highest to lowest
            foreach (var item in armourDataDic.OrderByDescending(key => key.Value.value))
            {
                //Loop through all 3 containers
                for (int i = 0; i < 3; i++)
                {
                    //Loop through one container
                    for (int y = 0; y < containers[i].itemList.Count; y++)
                    {
                        //Get item id
                        int getItemId = containers[i].itemList[y].info.itemid;
                        string getItemShortName = containers[i].itemList[y].info.shortname;

                        //Is item id same as item in armourDataDic.
                        if (getItemId == item.Key)
                        {
                            points += item.Value.value;
                            countItemsInList++;
                        }

                        //Exit after 7 items
                        if (countItemsInList >= maxItemsCounted)
                        {
                            return points;
                        }
                    }
                }
            }

            return points;
        }

        int getHighestWeaponValueFromContainer(ItemContainer container)
        {
            int points = 0;

            //Loop trough container
            for (int i = 0; i < container.itemList.Count; i++)
            {
                //Get item id
                int getItemId = container.itemList[i].info.itemid;

                //Check if item exists in weaponDataDic
                if (weaponDataDic.ContainsKey(getItemId))
                {
                    //Get weapon value
                    int getItemValue = weaponDataDic[getItemId].value;

                    if (getItemValue > points)
                    {
                        points = getItemValue;
                    }
                }
            }

            return points;
        }

        int getTierId(int value)
        {
            int tierId = 0;

            foreach (var item in tierDataDic)
            {
                //Check item point range
                if(value >= item.Value.min && value <= item.Value.max)
                {
                    tierId = item.Key;

                    break;
                }
            }

            return tierId;
        }

        //Used by playerTierTimer
        void updatePlayer(BasePlayer player, int nextTier, bool setTierData)
        {
            updatePlayerData(player, nextTier, setTierData);

            updatePlayerGui(player, nextTier, setTierData);
        }

        void updatePlayerData(BasePlayer player, int nextTier, bool setTierData)
        {
            if (setTierData == true)
            {
                //Update platyer old tier value
                playerDataDic[player.userID].oldTier = playerDataDic[player.userID].currentTier;

                //Updater player currentTier
                playerDataDic[player.userID].currentTier = nextTier;
                playerDataDic[player.userID].tierId = getTierId(nextTier);

                //Reset player update cycles
                playerDataDic[player.userID].currentUpdateCycle = 0;
            }

            //Update player distanceToMiddle
            playerDataDic[player.userID].distanceFromMiddle = getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true);

            ////////Update player zone (start)
            bool isInsideWarZone = false;
            foreach (var item in warZoneDataDic)
            {
                if(isPlayerInsideRaidZone(player, item.Value.position, item.Value.size / 2))
                {
                    //If raidZone has been alive more then x seconds, players health is over 25 and players old zone was not a raid zone.
                    if(item.Value.currentUpTime > timeBeforePlayerTakeDamageWhenEnterWarZone && (player.health > warZoneEnterDamage + 5 || canDieWhenEnteringWarZone == true) && playerDataDic[player.userID].currentZone != 5) 
                    {
                        player.Heal(-warZoneEnterDamage);

                        string vomited = lang.GetMessage("Vomited", this, player.UserIDString);
                        PrintToChat(player, string.Format(vomited, warZoneEnterDamage));

                        Effect.server.Run(vomit, player.transform.position);
                    }

                    playerDataDic[player.userID].currentZone = 5;
                    isInsideWarZone = true;
                    break;
                }
            }
            
            //If not in raid zone set regular zone.
            if(isInsideWarZone == false)
            {
                playerDataDic[player.userID].currentZone = getCurrentZone(playerDataDic[player.userID].distanceFromMiddle);
            }
            ////////Update player zone (end)

            //Update player cantStartRaidZoneTimer
            if (playerDataDic[player.userID].cantStartRaidZoneTimer > 0)
            {
                playerDataDic[player.userID].cantStartRaidZoneTimer -= updateTierRefreshRate;
            }

            //Update startRaidZoneAfterDamageDealtToStructure
            if (playerDataDic[player.userID].startRaidZoneAfterDamageDealtToStructure > 0 && playerDataDic[player.userID].startRaidZoneAfterDamageDealtToStructure <= startWarZoneAfterDamageToStructure)
            {
                playerDataDic[player.userID].startRaidZoneAfterDamageDealtToStructure += playerWarZoneStartDecreser;
            }
        }

        void updatePlayerGui(BasePlayer player, int nextTier, bool setTierData)
        {
            if (setTierData == true)
            {
                //Update tier box gui
                createInfoBox(player, uiTierBox, "Tier " + tierDataDic[playerDataDic[player.userID].tierId].tierLetter, tierBoxPosX, tierBoxPosY, tierBoxSizeX, tierBoxSizeY);

                //Update tier points changed ui
                if (playerDataDic[player.userID].currentTier != playerDataDic[player.userID].oldTier)
                {
                    //Get chnage in tier points
                    float getTierPointsChanged = playerDataDic[player.userID].currentTier - playerDataDic[player.userID].oldTier;

                    string positive = "";

                    if(getTierPointsChanged > 0)
                    {
                        positive = "+";
                    }

                    //Update UI
                    createInfoText(player, uiTierPointsChange, positive + getTierPointsChanged.ToString(), getTierPointsChangePosX, getTierPointsChangePosY, getTierPointsChangeSizeX, getTierPointsChangeSizeY);
                    
                    //Stop updating the ui.
                    playerDataDic[player.userID].oldTier = playerDataDic[player.userID].currentTier;

                    //Set delay to 0 becouse an update happened.
                    tierPointChangeDelay = 0;
                }
                else
                {
                    //Update delay. After a set amount this delay will destroy tier points changed.
                    tierPointChangeDelay += updateTierRefreshRate;

                    if (tierPointChangeDelay > 4)
                    {
                        //If ui element exists destroy it.
                        destroyGuiElement(player, uiTierPointsChange);
                    }
                }

                ////////Loading ui start
                //Destroy loading gui element
                destroyGuiElement(player, uiTierLoading);

                //Tier point text
                string tierPointsText = nextTier.ToString() + " / " + tierDataDic[playerDataDic[player.userID].tierId].max.ToString();

                //Tier point loading bar
                float lowValue = nextTier - tierDataDic[playerDataDic[player.userID].tierId].min;
                float highValue = tierDataDic[playerDataDic[player.userID].tierId].max - tierDataDic[playerDataDic[player.userID].tierId].min;
                float loadingBar = lowValue / highValue;

                //Create loading gui element
                //Set progress bar to max if player is A tier.
                if (playerDataDic[player.userID].tierId == tierDataDic.Count())
                {
                    createTierProgressBar(player, uiTierLoading, playerDataDic[player.userID].currentTier.ToString(), 1.0f, tierProgressPosX, tierProgressPosY, tierProgressSizeX, tierProgressSizeY);
                }
                else
                {
                    createTierProgressBar(player, uiTierLoading, tierPointsText, loadingBar, tierProgressPosX, tierProgressPosY, tierProgressSizeX, tierProgressSizeY);
                }
                ////////Loading ui end
            }

            ////////Update lookPlayer ui
            /////////////////////////////////////////////////
            BaseEntity entity = getEntityFromRayCastHit(player.eyes.HeadRay());

            //Entity is not null
            if (entity != null)
            {
                //Get player from entity
                BasePlayer lookPlayer = entity.ToPlayer();

                //Check if entity is player and if player is alive and mobile
                if (isPlayerAliveAndMobile(lookPlayer))
                {
                    playerDataDic[player.userID].lookPlayerDelay = 0;
                    displayTierFromLookPlayer(player, lookPlayer);
                }
            }

            playerDataDic[player.userID].lookPlayerDelay += updateTierRefreshRate;

            if (playerDataDic[player.userID].lookPlayerDelay > TimeLookPlayerUiIsDrawn)
            {
                destroyGuiElement(player, uiGetPlayerTierOnLook);
            }
            /////////////////////////////////////////////////

            //Update tier range box gui
            createTearRangeBox(player, uiTierRangeBox, checkTierRange(player, 5), checkTierRange(player, 4), checkTierRange(player, 3), checkTierRange(player, 2), checkTierRange(player, 1));

            //Update zone box gui
            createInfoBox(player, uiZoneBox, "Zone " + playerDataDic[player.userID].currentZone, zoneBoxPosX, zoneBoxPosY, zoneBoxSizeX, zoneBoxSizeY);

            //Update distance to next zone gui
            createInfoBox(player, uiMeterZoneBox, getDistanceToNextZone(playerDataDic[player.userID].distanceFromMiddle).ToString(), meterZoneBoxPosX, meterZoneBoxPosY, meterZoneBoxSizeX, meterZoneBoxSizeY);
        }

        bool isPlayerAwake(BasePlayer player)
        {
            if (player != null && player.IsConnected == true && player.IsDead() == false && player.IsSleeping() == false && player.IsSpectating() == false)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        bool isPlayerAliveAndMobile(BasePlayer player)
        {
            if (player != null && player.IsConnected == true && player.IsDead() == false && player.IsWounded() == false && player.IsSleeping() == false && player.IsSpectating() == false)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        int getCurrentZone(float distance)
        {
            int currentZone;

            if (distance > outerWall)
            {
                currentZone = 1;
            }
            else if(distance > middleWall)
            {
                currentZone = 2;
            }
            else if(distance > InnerWall)
            {
                currentZone = 3;
            }
            else
            {
                currentZone = 4;
            }

            return currentZone;
        }

        int getDistanceToNextZone(float distanceToMiddle)
        {
            int distanceToNextZone;

            if (distanceToMiddle > outerWall)
            {
                distanceToNextZone = Convert.ToInt32(distanceToMiddle) - outerWall;
            }
            else if (distanceToMiddle > middleWall)
            {
                distanceToNextZone = Convert.ToInt32(distanceToMiddle) - middleWall;
            }
            else if (distanceToMiddle > InnerWall)
            {
                distanceToNextZone = Convert.ToInt32(distanceToMiddle) - InnerWall;
            }
            else
            {
                distanceToNextZone = Convert.ToInt32(distanceToMiddle);
            }

            return distanceToNextZone;
        }

        float getDistanceFromPosition(Vector3 pos, Vector3 pos2, bool ignoreY)
        {
            float dist;

            if (ignoreY == true)
            {
                Vector3 posNoY = new Vector3(pos.x, 0, pos.z);
                Vector3 pos2NoY = new Vector3(pos2.x, 0, pos2.z);
                dist = Vector3.Distance(posNoY, pos2NoY);
            }
            else
            {
                dist = Vector3.Distance(pos, pos2);
            }

            return dist;
        }

        bool canVictimTakeDamage(BasePlayer victim, BasePlayer attacker)
        {
            //Victim tier id
            int getVictimTierId = playerDataDic[victim.userID].tierId;
            //Victim current zone (1,2,3,4)
            int getVictimZone = playerDataDic[victim.userID].currentZone;
            //Attacker tier id
            int getAttackerTierId = playerDataDic[attacker.userID].tierId;

            bool isVictimUpdatingTier = playerDataDic[victim.userID].currentUpdateCycle > 0;
            bool isAttackerUpdatingTier = playerDataDic[attacker.userID].currentUpdateCycle > 0;

            bool canTakeDamage = false;
            int tierRange;

            //Attacker cant deal damage while updating tier
            if(isAttackerUpdatingTier == false)
            {
                //Get tier range
                if (getVictimZone == 1 && isVictimUpdatingTier == false)
                {
                    tierRange = 0;
                }
                else if (getVictimZone == 2 && isVictimUpdatingTier == false)
                {
                    tierRange = 1;
                }
                else if (getVictimZone == 3 && isVictimUpdatingTier == false)
                {
                    tierRange = 2;
                }
                else if (getVictimZone == 4 && isVictimUpdatingTier == false)
                {
                    tierRange = 3;
                }
                else
                {
                    tierRange = 4;
                }

                bool range1 = getAttackerTierId <= getVictimTierId + tierRange;
                bool range2 = getAttackerTierId >= getVictimTierId - tierRange;

                //Check if victim is in zone range and can take damage
                if (range1 && range2)
                {
                    canTakeDamage = true;
                }
            }

            return canTakeDamage;
        }

        int checkTierRange(BasePlayer player, int tierId)
        {
            //Victim tier id
            int getPlayerTierId = playerDataDic[player.userID].tierId;
            //Victim current zone (1,2,3,4,5)
            int getPlayerZone = playerDataDic[player.userID].currentZone;

            bool isPlayerUpdatingTier = playerDataDic[player.userID].currentUpdateCycle > 0;

            int canAttackTier = 0;
            int tierRange;

            //Get tier range
            if (getPlayerZone == 1 && isPlayerUpdatingTier == false)
            {
                tierRange = 0;
            }
            else if (getPlayerZone == 2 && isPlayerUpdatingTier == false)
            {
                tierRange = 1;
            }
            else if (getPlayerZone == 3 && isPlayerUpdatingTier == false)
            {
                tierRange = 2;
            }
            else if (getPlayerZone == 4 && isPlayerUpdatingTier == false)
            {
                tierRange = 3;
            }
            else
            {
                tierRange = 4;
            }

            bool range1 = tierId <= getPlayerTierId + tierRange;
            bool range2 = tierId >= getPlayerTierId - tierRange;

            //Check if victim is in zone range and can take damage
            if (range1 && range2)
            {
                canAttackTier = 1;
            }

            return canAttackTier;
        }

        bool isPlayerInsideRaidZone(BasePlayer player, Vector3 position, float raidZoneSize)
        {
            if(getDistanceFromPosition(player.GetNetworkPosition(), position, false) < raidZoneSize)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        void startWarZone(Vector3 spawnPos, float size, int timeAlive)
        {
            //Update total war zones variable
            totalWarZones++;

            //War zone variables
            int counter = 0;
            int counterStop = 8;
            int warZoneSizeDecreser = 0;
            int warZoneId = totalWarZones;
            List<BaseEntity> sphereList = new List<BaseEntity>(24);

            //Add raid zone to dictionary
            warZoneDataDic.Add(warZoneId,
            new warZoneDataClass
            {
                zone = getCurrentZone(getDistanceFromPosition(spawnPos, middlePosition, true)),
                size = size,
                currentUpTime = 0,
                aliveTime = timeAlive,
                position = spawnPos,
            });

            //Timer
            Timer sphereWarZoneTimer;

            //Start timer
            sphereWarZoneTimer = timer.Repeat(0.2f, 3, () =>
            {
                //Spawn 8 spheres
                while (counter < counterStop)
                {
                    sphereList.Add(spawnSpherePreFab(warZoneDataDic[warZoneId].size - warZoneSizeDecreser, spawnPos));
                    counter++;
                }

                counterStop += 8;
                warZoneSizeDecreser += 1;
            });

            //Timer
            Timer warZoneUpdateTimer;

            //Timer start
            warZoneUpdateTimer = timer.Every(warZoneTimeBetweenIntervalls, () =>
            {
                bool shrinkSpheres = true;
                warZoneDataDic[warZoneId].currentUpTime += warZoneTimeBetweenIntervalls;

                if (warZoneDataDic[warZoneId].currentUpTime >= warZoneDataDic[warZoneId].aliveTime)
                {
                    for (int i = 0; i < sphereList.Count(); i++)
                    {
                        sphereList[i].Kill();
                    }

                    //Remove raid zone from dictionary
                    warZoneDataDic.Remove(warZoneId);

                    //Destroy timer
                    timerHolderDic[warZoneId].Destroy();

                    //Remove timer from dictionary
                    timerHolderDic.Remove(warZoneId);
                }
                else if (warZoneDataDic[warZoneId].currentUpTime >= warZoneDataDic[warZoneId].aliveTime - 3 && shrinkSpheres == true)
                {
                    //Timer
                    Timer shrinkSpheresTimer;
                    counter = 0;
                    counterStop = 8;
                    shrinkSpheres = false;

                    //Start timer
                    shrinkSpheresTimer = timer.Repeat(0.2f, 3, () =>
                    {
                        //Spawn 8 spheres
                        while (counter < counterStop)
                        {
                            SphereEntity ent = sphereList[counter].GetComponent<SphereEntity>();
                            ent.currentRadius = 1;
                            counter++;
                        }

                        counterStop += 8;
                    });
                }
            });

            //Set player data
            timerHolderDic.Add(warZoneId, warZoneUpdateTimer);
        }

        BaseEntity getEntityFromRayCastHit(Ray ray)
        {
            //var layers = LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World");

            RaycastHit hit;

            if (UnityEngine.Physics.Raycast(ray, out hit, float.MaxValue))
            {
                BaseEntity entity = hit.GetEntity();

                return entity;
            }

            return null;
        }

        void displayTierFromLookPlayer(BasePlayer player, BasePlayer lookPlayer)
        {
            string color = "1.0 1.0 1.0 1.0";
            string text = lookPlayer.displayName + " - tier " + tierDataDic[playerDataDic[lookPlayer.userID].tierId].tierLetter;

            if(canVictimTakeDamage(lookPlayer, player))
            {
                color = "1.0 0.3 0.3 1.0";
            }

            if(playerDataDic[lookPlayer.userID].currentUpdateCycle > 0)
            {
                text = lookPlayer.displayName + " - " + lang.GetMessage("UpdatingTier", this, player.UserIDString) + " tier!";
            }

            getPlayerTierOnLookTextBox(player, uiGetPlayerTierOnLook, text, color, getTierOnLookPosX, getTierOnLookPosY, getTierOnLookSizeX, getTierOnLookSizeY);
        }

        bool canPlayerBuild(Planner planner, Construction prefab)
        {
            bool canBuild = true;

            //Get player
            BasePlayer player = planner.GetOwnerPlayer();

            //Prefab is a door
            bool ifDoor = prefab.fullName.Contains("door") == true && prefab.fullName.Contains("doorway") == false;

            //Prefab is wooden door
            bool isWoodenDoor = prefab.fullName.Contains("wood") == true;

            //Prefab is metal door
            bool isMetalDoor = prefab.fullName.Contains("metal") == true;

            //Is prefab door
            if (ifDoor)
            {
                if (playerDataDic[player.userID].currentZone == 1)
                {
                    if (isWoodenDoor == false)
                    {
                        PrintToChat(player, lang.GetMessage("OnlyWoodenDoors", this, player.UserIDString));
                        canBuild = false;
                    }
                }
                else if (playerDataDic[player.userID].currentZone == 2)
                {
                    if (isWoodenDoor == false && isMetalDoor == false)
                    {
                        PrintToChat(player, lang.GetMessage("OnlyWoodenMetalDoors", this, player.UserIDString));
                         canBuild = false;
                    }
                }
            }
            else
            {
                float playerDistanceToMid = getDistanceFromPosition(player.GetNetworkPosition(), middlePosition, true);

                bool toCloseToOuterWall = playerDistanceToMid > outerWall - distanceToBuildFromWalls && playerDistanceToMid < outerWall + distanceToBuildFromWalls;
                bool toCloseToMiddleWall = playerDistanceToMid > middleWall - distanceToBuildFromWalls && playerDistanceToMid < middleWall + distanceToBuildFromWalls;
                bool toCloseToInnerWall = playerDistanceToMid > InnerWall - distanceToBuildFromWalls && playerDistanceToMid < InnerWall + distanceToBuildFromWalls;

                if (toCloseToOuterWall || toCloseToMiddleWall || toCloseToInnerWall)
                {
                    PrintToChat(player, lang.GetMessage("CantBuildCloseToEdge", this, player.UserIDString));
                     canBuild = false;
                }
            }

            return canBuild;
        }

        string timeFormating(int time)
        {
            string timeFormatWithText;

            if(time > 60)
            {
                timeFormatWithText = (time / 60) + " min";
            }
            else
            {
                timeFormatWithText = time + " sec";
            }

            return timeFormatWithText;
        }

        Vector3 getRayCastHitPosition(Ray ray)
        {
            //var layers = LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World");

            RaycastHit hit;

            if (UnityEngine.Physics.Raycast(ray, out hit, float.MaxValue))
            {
                return hit.point;
            }
            else
            {
                return ray.origin;
            }
        }
        #endregion

        #region Timers
        void playerInitializeTimer(BasePlayer player)
        {
            Timer initializeTimer;

            initializeTimer = timer.Once(initializeTimerDelay, () =>
            {
                //Check if playerTierTimer is running or not. If not running start it.
                if (playerDataDic[player.userID].isUpdateTierTimerRunning == false)
                {
                    playerTierTimer(player);

                    Puts(player.displayName + " is now initilized! Needed to start playerTierTimer.");
                }
                else
                {
                    Puts(player.displayName + " is now initilized! Did not start playerTierTimer.");
                }

                //Player has been initialized
                playerDataDic[player.userID].isPlayerInitialized = true;
            });
        }

        void playerTierTimer(BasePlayer player)
        {
            //Timer
            Timer tierTimer;

            ////////Timer start
            //////////////////////////////////////////////////////////////
            tierTimer = timer.Every(updateTierRefreshRate, () =>
            {
                //Check if player is online and not dead.
                if (isPlayerAliveAndMobile(player))
                {
                    //Check if player has gone throw the initialize process.
                    //This is needed if the player reconect. The timer seems to not destroy itself on player leave and will be reused when the player connects again insted of using 2 or more timers.
                    if (playerDataDic[player.userID].isPlayerInitialized == true)
                    {
                        int nextTier = getTierPointsForPlayer(player);
                        int currentTier = playerDataDic[player.userID].currentTier;

                        //Check if tier points has changed
                        if (nextTier != currentTier)
                        {
                            //Check if tier rank has changed
                            if (getTierId(nextTier) != getTierId(currentTier))
                            {
                                //If set amount of cycles are reached.
                                if (playerDataDic[player.userID].currentUpdateCycle >= (updateTierTime * 5))
                                {
                                    updatePlayer(player, nextTier, true);
                                }
                                else
                                {
                                    if(playerDataDic[player.userID].currentUpdateCycle == 0 && playerDataDic[player.userID].currentZone < 5)
                                    {
                                        PrintToChat(player, lang.GetMessage("NoDamageWhileUpdatingTier", this, player.UserIDString));
                                    }

                                    //Update player currentUpdateCycle
                                    playerDataDic[player.userID].currentUpdateCycle++;

                                    //Update player data but do not reset currentUpdateCycle
                                    updatePlayer(player, nextTier, false);

                                    //Update loading bar value
                                    float loadingTierValue = playerDataDic[player.userID].currentUpdateCycle / (updateTierTime * 5);

                                    //Update loading ui
                                    createTierProgressBar(player, uiTierLoading, lang.GetMessage("ChangingTier", this, player.UserIDString) + " tier...", loadingTierValue, tierProgressPosX, tierProgressPosY, tierProgressSizeX, tierProgressSizeY);
                                }
                            }
                            else
                            {
                                updatePlayer(player, nextTier, true);
                            }
                        }
                        else
                        {
                            updatePlayer(player, nextTier, true);
                        }
                    }
                    else
                    {
                        updatePlayer(player, playerDataDic[player.userID].currentTier, true);

                        //Check if the timer is running
                        playerDataDic[player.userID].isUpdateTierTimerRunning = true;
                    }
                }
                else
                {
                    destroyAllUiForPlayer(player);
                }
                //////////////////////////////////////////////////////////////
                ////////Timer end
            });
        }
        #endregion

        #region Player ui
        void destroyGuiElement(BasePlayer player, string element)
        {
            if (player != null && element != null)
            {
                CuiHelper.DestroyUi(player, element);
            }
        }

        void destroyAllUiForPlayer(BasePlayer player)
        {
            destroyGuiElement(player, uiZoneBox);
            destroyGuiElement(player, uiMeterZoneBox);
            destroyGuiElement(player, uiTierLoading);
            destroyGuiElement(player, uiTierPoints);
            destroyGuiElement(player, uiTierRangeBox);
            destroyGuiElement(player, uiInfoText);
            destroyGuiElement(player, uiTierBox);
            destroyGuiElement(player, uiGetPlayerTierOnLook);
            destroyGuiElement(player, uiTierPointsChange);
        }

        void createInfoBox(BasePlayer player, string uiElement, string text, float posX, float posY, float sizeX, float sizeY)
        {
            int fontSize = 16;
            if (text == "Zone 5")
            {
                text = "Warzone";
                fontSize = 16;
            }

            destroyGuiElement(player, uiElement);
            var Container = new CuiElementContainer();

            float heigth = posX + sizeX;
            float width = posY + sizeY;

            Container.Add(new CuiElement
            {
                Name = uiElement,
                Components =
                {
                    new CuiImageComponent 
                    {
                        Color = "0.2 0.2 0.2 0.7"
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = posX.ToString() + " " + posY.ToString(), AnchorMax = heigth.ToString() + " " + width.ToString(),
                    },
                }
            });
            Container.Add(new CuiElement
            {
                Parent = uiElement,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = fontSize,
                        Align = TextAnchor.MiddleCenter
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0", AnchorMax = "1.0 0.9",
                    },
                }
            });

            CuiHelper.AddUi(player, Container);
        }

        void createInfoText(BasePlayer player, string uiElement, string text, float posX, float posY, float sizeX, float sizeY)
        {
            destroyGuiElement(player, uiElement);
            var Container = new CuiElementContainer();

            float heigth = posX + sizeX;
            float width = posY + sizeY;

            Container.Add(new CuiElement
            {
                Name = uiElement,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = 30,
                        Align = TextAnchor.MiddleCenter,
                        Color = "1.0 1.0 1.0 1.0"
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = posX.ToString() + " " + posY.ToString(), AnchorMax = heigth.ToString() + " " + width.ToString(),
                    },
                }
            });

            CuiHelper.AddUi(player, Container);
        }

        void createTierProgressBar(BasePlayer player, string uiElement, string text, float loadingValue, float posX, float posY, float sizeX, float sizeY)
        {
            destroyGuiElement(player, uiElement);
            var Container = new CuiElementContainer();

            float heigth = posX + sizeX;
            float width = posY + sizeY;

            Container.Add(new CuiElement
            {
                Name = uiElement,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0.2 0.2 0.2 0.7"
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = posX.ToString() + " " + posY.ToString(), AnchorMax = heigth.ToString() + " " + width.ToString(),
                    },
                }
            });
            Container.Add(new CuiElement
            {
                Parent = uiElement,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0.8 0.8 0.8 0.5"
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0", AnchorMax = loadingValue.ToString() + " 1.0",
                    },
                }
            });
            Container.Add(new CuiElement
            {
                Parent = uiElement,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = 16,
                        Color = "0.0 0.0 0.0 0.8",
                        Align = TextAnchor.MiddleCenter
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0", AnchorMax = "1.0 0.9",
                    },
                }
            });

            CuiHelper.AddUi(player, Container);
        }

        void createTearRangeBox(BasePlayer player, string uiElement, int a, int b, int c, int d, int e)
        {
            destroyGuiElement(player, uiElement);
            var Container = new CuiElementContainer();

            int[] isLetterWhite = new int[5];
            string[] letterArray = new string[5];
            float spaceMin = 0.05f;
            float spaceMax = 0.05f;
            float amountSpace = 0.18f;
            string textColor;

            isLetterWhite[0] = a; isLetterWhite[1] = b; isLetterWhite[2] = c; isLetterWhite[3] = d; isLetterWhite[4] = e;
            letterArray[0] = "A"; letterArray[1] = "B"; letterArray[2] = "C"; letterArray[3] = "D"; letterArray[4] = "E";

            float heigth = tierRangeBoxSizeY + tierRangeBoxSizeX;
            float width = tierRangeBoxPosY + tierRangeBoxSizeY;

            Container.Add(new CuiElement
            {
                Name = uiElement,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0.2 0.2 0.2 0.7"
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = tierRangeBoxPosX.ToString() + " " + tierRangeBoxPosY.ToString(), AnchorMax = heigth.ToString() + " " + width.ToString(),
                    },
                }
            });
            for(int i = 0;i < isLetterWhite.Length;i++)
            {
                spaceMax = spaceMax + amountSpace;

                if(isLetterWhite[i] == 1)
                {
                    textColor = "1.0 0.6 0.2 1.0";
                }
                else
                {
                    textColor = "1.0 1.0 1.0 0.1";
                }

                Container.Add(new CuiElement
                {
                    Parent = uiElement,
                    Components =
                {
                    new CuiTextComponent
                    {
                        Text = letterArray[i],
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter,
                        Color = textColor
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = spaceMin + " 0.0", AnchorMax = spaceMax + " 0.9",
                    },
                }
                });

                spaceMin = spaceMin + amountSpace;
            }

            CuiHelper.AddUi(player, Container);
        }

        void getPlayerTierOnLookTextBox(BasePlayer player, string uiElement, string text, string color, float posX, float posY, float sizeX, float sizeY)
        {
            destroyGuiElement(player, uiElement);
            var Container = new CuiElementContainer();

            float heigth = posX + sizeX;
            float width = posY + sizeY;

            Container.Add(new CuiElement
            {
                Name = uiElement,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter,
                        Color = color,
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = posX.ToString() + " " + posY.ToString(), AnchorMax = heigth.ToString() + " " + width.ToString(),
                    },
                }
            });

            Container.Add(new CuiElement
            {
                Parent = uiElement,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0.2 0.2 0.2 0.7",
                    },

                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0",
                    },
                }
            });

            CuiHelper.AddUi(player, Container);
        }
        #endregion

        #region Commands

        [ChatCommand("cratepos")]
        void addHackableCreateSpawnPos(BasePlayer player)
        {
            if (isPlayerAwake(player) && player.IsAdmin)
            {
                //Variables
                string fileName = "LayersOfRiskHackableCratePositions";
                Vector3 playerEyesLookPos = getRayCastHitPosition(player.eyes.HeadRay());
                Timer timerOnce;

                BaseEntity crate = GameManager.server.CreateEntity(hackableCreate, getRayCastHitPosition(player.eyes.HeadRay()), new Quaternion(), true);

                crate.Spawn();

                StorageContainer crateContainer = crate.GetComponent<StorageContainer>();
                ItemContainer newContainer = new ItemContainer();
                newContainer.ServerInitialize(null, 6);
                newContainer.GiveUID();
                crateContainer.inventory = newContainer;

                timerOnce = timer.Once(2, () =>
                {
                    //Get datafile
                    DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile(fileName);
                    string item = (hackableCrateDataDic.Count() + 1).ToString();

                    if (hackableCrateDataDic.Keys.ElementAt(0).x == 0 && hackableCrateDataDic.Keys.ElementAt(0).y == 0 && hackableCrateDataDic.Keys.ElementAt(0).z == 0)
                    {
                        hackableCrateDataDic.Remove(Vector3.zero);
                        item = "1";
                    }

                    dataFile[item, "posX"] = crate.transform.position.x;
                    dataFile[item, "posY"] = crate.transform.position.y;
                    dataFile[item, "posZ"] = crate.transform.position.z;

                    dataFile.Save();

                    hackableCrateDataDic.Add(new Vector3(crate.transform.position.x, crate.transform.position.y, crate.transform.position.z),
                    new hackableCrateDataClass
                    {
                        inUse = false,
                    });

                    crate.Kill();

                    string CrateSpawn = lang.GetMessage("CrateSpawn", this, player.UserIDString);
                    PrintToChat(player, string.Format(CrateSpawn, playerEyesLookPos));
                });
            }
        }
        #endregion
    }

}

// --- End of file: LayersOfRisk.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/limited-drone-range ---
// --- Original File Path: L/LimitedDroneRange/LimitedDroneRange.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Limited Drone Range", "WhiteThunder", "1.1.1")]
    [Description("Limits how far RC drones can be controlled from computer stations.")]
    internal class LimitedDroneRange : CovalencePlugin
    {
        #region Fields

        private readonly object False = false;
        private const float VanillaStaticDistanceFraction = 0.73f;
        private const int ForcedMaxRange = 100000;
        private const string DroneMaxControlRangeConVar = "drone.maxcontrolrange";
        private readonly string ForcedMaxRangeString = ForcedMaxRange.ToString();

        private Configuration _config;
        private UIManager _uiManager = new UIManager();

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);
        }

        private void OnServerInitialized()
        {
            if (Drone.maxControlRange < ForcedMaxRange)
            {
                Drone.maxControlRange = ForcedMaxRange;
                LogWarning($"Updated {DroneMaxControlRangeConVar} ConVar to {ForcedMaxRange} so that the plugin can control drone max range.");
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var station = player.GetMounted() as ComputerStation;
                if (station == null)
                    continue;

                var drone = station.currentlyControllingEnt.Get(serverside: true) as Drone;
                if (drone == null)
                    continue;

                OnBookmarkControlStarted(station, player, string.Empty, drone);
            }
        }

        private void Unload()
        {
            RangeLimiter.DestroyAll();
        }

        private object OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            int maxRange;
            if (!ShouldLimitRange(drone, station, player, out maxRange)
                || IsWithinRange(drone, station, maxRange))
                return null;

            _uiManager.CreateOutOfRangeUI(this, player);
            return False;
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            int maxRange;
            if (!ShouldLimitRange(drone, station, player, out maxRange))
            {
                SendMaxRangeConVar(player, ForcedMaxRangeString);
                return;
            }

            RangeLimiter.AddToPlayer(this, player, station, drone, maxRange);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            RangeLimiter.RemoveFromPlayer(player);
        }

        #endregion

        #region Helper Methods

        private static bool LimitRangeWasBlocked(Drone drone, ComputerStation station, BasePlayer player)
        {
            var hookResult = Interface.CallHook("OnDroneRangeLimit", drone, station, player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool IsWithinRange(Drone drone, ComputerStation station, float range)
        {
            return (station.transform.position - drone.transform.position).sqrMagnitude < range * range;
        }

        private static void SendReplicatedVar(Connection connection, string fullName, string value)
        {
            var netWrite = Net.sv.StartWrite();
            netWrite.PacketID(Message.Type.ConsoleReplicatedVars);
            netWrite.Int32(1);
            netWrite.String(fullName);
            netWrite.String(value);
            netWrite.Send(new SendInfo(connection));
        }

        private static void SendMaxRangeConVar(BasePlayer player, string value)
        {
            SendReplicatedVar(player.Connection, DroneMaxControlRangeConVar, value);
        }

        private bool ShouldLimitRange(Drone drone, ComputerStation station, BasePlayer player, out int maxRange)
        {
            maxRange = _config.GetMaxRangeForPlayer(this, player.UserIDString);
            if (maxRange <= 0)
                return false;

            return !LimitRangeWasBlocked(drone, station, player);
        }

        #endregion

        private class RangeLimiter : FacepunchBehaviour
        {
            public static RangeLimiter AddToPlayer(LimitedDroneRange plugin, BasePlayer player, ComputerStation station, Drone drone, int maxDistance)
            {
                var component = player.gameObject.AddComponent<RangeLimiter>();

                component._plugin = plugin;
                component._player = player;
                component._station = station;
                component._stationTransform = station.transform;
                component._droneTransform = drone.transform;
                component._maxDistance = maxDistance;

                var secondsBetweenUpdates = plugin._config.UISettings.SecondsBetweenUpdates;

                component.InvokeRandomized(() =>
                {
                    plugin.TrackStart();
                    component.CheckRange();
                    plugin.TrackEnd();
                }, 0, secondsBetweenUpdates, secondsBetweenUpdates * 0.1f);

                // Show 25% of vanilla static.
                var staticFraction = Mathf.Lerp(VanillaStaticDistanceFraction, 1, 0.25f);
                SendMaxRangeConVar(player, Mathf.CeilToInt(maxDistance / staticFraction).ToString());

                return component;
            }

            public static void RemoveFromPlayer(BasePlayer player)
            {
                var component = player.GetComponent<RangeLimiter>();
                if (component != null)
                {
                    DestroyImmediate(component);
                }
            }

            public static void DestroyAll()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RemoveFromPlayer(player);
                }
            }

            private LimitedDroneRange _plugin;
            private BasePlayer _player;
            private ComputerStation _station;
            private Transform _stationTransform;
            private Transform _droneTransform;
            private int _maxDistance;
            private int _previousDisplayedDistance;

            private void CheckRange()
            {
                var sqrDistance = (_stationTransform.position - _droneTransform.position).sqrMagnitude;
                if (sqrDistance > _maxDistance * _maxDistance)
                {
                    _station.StopControl(_player);
                    _plugin._uiManager.CreateOutOfRangeUI(_plugin, _player);
                    return;
                }

                var distance = Mathf.CeilToInt(Mathf.Sqrt(sqrDistance));
                if (distance == _previousDisplayedDistance)
                    return;

                _plugin._uiManager.CreateDistanceUI(_plugin, _player, distance, _maxDistance);
                _previousDisplayedDistance = distance;
            }

            public void OnDestroy() => UIManager.Destroy(_player);
        }

        #region UI

        private class UIManager
        {
            private const string UIName = "LimitedDroneRange";

            private const string PlaceholderText = "__TEXT__";
            private const string PlaceholderColor = "__COLOR__";

            private string _cachedJson;

            public static void Destroy(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, UIName);
            }

            private string GetJsonWithPlaceholders(LimitedDroneRange plugin)
            {
                if (_cachedJson == null)
                {
                    var uiSettings = plugin._config.UISettings;

                    var cuiElements = new CuiElementContainer
                    {
                        new CuiElement
                        {
                            Parent = "Overlay",
                            Name = UIName,
                            DestroyUi = UIName,
                            Components =
                            {
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = uiSettings.AnchorMin,
                                    AnchorMax = uiSettings.AnchorMax,
                                    OffsetMin = uiSettings.OffsetMin,
                                    OffsetMax = uiSettings.OffsetMax,
                                }
                            },
                        },
                        new CuiElement
                        {
                            Parent = UIName,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = PlaceholderText,
                                    Align = TextAnchor.MiddleCenter,
                                    Color = PlaceholderColor,
                                    FontSize = uiSettings.TextSize,
                                },
                                new CuiOutlineComponent
                                {
                                    Color = "0 0 0 1",
                                    Distance = "0.75 0.75"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "0 0",
                                    OffsetMin = $"{uiSettings.TextSize * -4} 0",
                                    OffsetMax = $"{uiSettings.TextSize * 4} {uiSettings.TextSize * 1.5f}",
                                },
                            },
                        },
                    };

                    _cachedJson = CuiHelper.ToJson(cuiElements);
                }

                return _cachedJson;
            }

            public void CreateDistanceUI(LimitedDroneRange plugin, BasePlayer player, int distance, int maxDistance)
            {
                CreateLabel(
                    plugin,
                    player,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIDistance, distance.ToString(), maxDistance.ToString()),
                    plugin._config.UISettings.GetDynamicColor(distance, maxDistance)
                );
            }

            public void CreateOutOfRangeUI(LimitedDroneRange plugin, BasePlayer player)
            {
                CreateLabel(
                    plugin,
                    player,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIOutOfRange),
                    plugin._config.UISettings.OutOfRangeColor
                );

                plugin.timer.Once(1, () => Destroy(player));
            }

            private void CreateLabel(LimitedDroneRange plugin, BasePlayer player, string text, string color)
            {
                var json = GetJsonWithPlaceholders(plugin)
                    .Replace(PlaceholderText, text)
                    .Replace(PlaceholderColor, color);

                CuiHelper.AddUi(player, json);
            }
        }

        #endregion

        #region Configuration

        private class RangeProfile
        {
            [JsonProperty("PermissionSuffix")]
            public string PermissionSuffix;

            [JsonProperty("MaxRange")]
            public int MaxRange;

            [JsonIgnore]
            public string Permission;

            public void Init(LimitedDroneRange plugin)
            {
                if (string.IsNullOrWhiteSpace(PermissionSuffix))
                    return;

                Permission = $"{nameof(LimitedDroneRange)}.{PermissionSuffix}".ToLower();
                plugin.permission.RegisterPermission(Permission, plugin);
            }
        }

        private class ColorConfig
        {
            [JsonProperty("DistanceRemaining")]
            public int DistanceRemaining;

            [JsonProperty("Color")]
            public string Color;
        }

        private class UISettings
        {
            [JsonProperty("AnchorMin")]
            public string AnchorMin = "0.5 0";

            [JsonProperty("AnchorMax")]
            public string AnchorMax = "0.5 0";

            [JsonProperty("OffsetMin")]
            public string OffsetMin = "0 75";

            [JsonProperty("OffsetMax")]
            public string OffsetMax = "0 75";

            [JsonProperty("TextSize")]
            public int TextSize = 24;

            [JsonProperty("DefaultColor")]
            public string DefaultColor = "0.75 0.75 0.75 1";

            [JsonProperty("OutOfRangeColor")]
            public string OutOfRangeColor = "1 0.2 0.2 1";

            [JsonProperty("DynamicColors")]
            public ColorConfig[] DynamicColors =
            {
                new ColorConfig
                {
                    DistanceRemaining = 100,
                    Color = "1 0.5 0 1",
                },
                new ColorConfig
                {
                    DistanceRemaining = 50,
                    Color = "1 0.2 0.2 1",
                },
            };

            [JsonProperty("SecondsBetweenUpdates")]
            public float SecondsBetweenUpdates = 0.5f;

            public string GetDynamicColor(int distance, int maxDistance)
            {
                var distanceFromMax = maxDistance - distance;

                foreach (var colorConfig in DynamicColors)
                {
                    if (distanceFromMax <= colorConfig.DistanceRemaining)
                        return colorConfig.Color;
                }

                return DefaultColor;
            }

            public void Init()
            {
                var colorConfigs = DynamicColors.ToList();
                colorConfigs.Sort((config1, config2) => config1.DistanceRemaining.CompareTo(config2.DistanceRemaining));
                DynamicColors = colorConfigs.ToArray();
            }
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("DefaultMaxRange")]
            public int DefaultMaxRange = 500;

            [JsonProperty("ProfilesRequiringPermission")]
            public RangeProfile[] ProfilesRequiringPermission =
            {
                new RangeProfile
                {
                    PermissionSuffix = "short",
                    MaxRange = 250,
                },
                new RangeProfile
                {
                    PermissionSuffix = "medium",
                    MaxRange = 500,
                },
                new RangeProfile
                {
                    PermissionSuffix = "long",
                    MaxRange = 1000,
                },
                new RangeProfile
                {
                    PermissionSuffix = "unlimited",
                    MaxRange = 0,
                },
            };

            [JsonProperty("UISettings")]
            public UISettings UISettings = new UISettings();

            public void Init(LimitedDroneRange pluginInstance)
            {
                foreach (var profile in ProfilesRequiringPermission)
                    profile.Init(pluginInstance);

                UISettings.Init();
            }

            public int GetMaxRangeForPlayer(LimitedDroneRange plugin, string userId)
            {
                if (ProfilesRequiringPermission == null)
                    return DefaultMaxRange;

                for (var i = ProfilesRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var profile = ProfilesRequiringPermission[i];
                    if (profile.Permission != null && plugin.permission.UserHasPermission(userId, profile.Permission))
                        return profile.MaxRange;
                }

                return DefaultMaxRange;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                var changed = MaybeUpdateConfig(_config);

                if (_config.UISettings.AnchorMin == "0.5 0"
                    && _config.UISettings.AnchorMax == "0.5 0"
                    && _config.UISettings.OffsetMin == "0 75"
                    && _config.UISettings.OffsetMax == "0 75")
                {
                    _config.UISettings.OffsetMin = "0 47";
                    _config.UISettings.OffsetMax = "0 47";
                    changed = true;
                }

                if (changed)
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private class LangEntry
        {
            public static readonly List<LangEntry> AllLangEntries = new List<LangEntry>();

            public static readonly LangEntry UIOutOfRange = new LangEntry("UI.OutOfRange", "{0}m / {1}m");
            public static readonly LangEntry UIDistance = new LangEntry("UI.Distance", "OUT OF RANGE");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }

        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2);

        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion
    }
}


// --- End of file: LimitedDroneRange.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-lottery ---
// --- Original File Path: L/Lottery/Lottery.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Lottery", "Sami37", "1.2.5", ResourceId = 2145)]
    internal class Lottery : RustPlugin
    {
        #region Economy Support

        [PluginReference("Economics")]
        Plugin Economy;

        #endregion

        #region serverreward

        [PluginReference("ServerRewards")]
        Plugin ServerRewards;


        #endregion

        #region humanNPC

        [PluginReference("HumanNPC")]
        Plugin HumanNPC;


        #endregion

        #region generalClass/function
        internal class playerinfo
        {
            public int multiplicator { get; set; } = 1;
            public double currentbet { get; set; }
            public double totalbet { get; set; }

        }

        int[] GetIntArray(int num)
        {
            List<int> listOfInts = new List<int>();
            while(num > 0)
            {
                listOfInts.Add(num % 10);
                num = num / 10;
            }
            listOfInts.Reverse();
            return listOfInts.ToArray();
        }

        private object DoRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = Physics.RaycastAll(Pos, Aim);
            float distance = 3f;
            object target = false;
            foreach (var hit in hits)
            {
                if (hit.distance < distance)
                {
                    distance = hit.distance;
                    target = hit.GetEntity();
                }
            }
            return target;
        }
        #endregion

        #region general_variable
        private bool newConfig, UseSR, UseNPC, AutoCloseAfterPlaceingBet;
        public Dictionary<ulong, playerinfo> Currentbet = new Dictionary<ulong, playerinfo>();
        private string container, containerwin, BackgroundUrl, BackgroundColor, WinBackgroundUrl, WinBackgroundColor, anchorMin, anchorMax;
        private DynamicConfigFile data;
        private List<object> NPCID = new List<object>();
        private double jackpot, SRMinBet, SRjackpot, MinBetjackpot, MinBetjackpotEco;
        private int JackpotNumber, SRJackpotNumber, DefaultMaxRange, DefaultMinRange;
        public Dictionary<string, object> IndividualRates { get; private set; }
        public Dictionary<string, int> SRRates { get; private set; }
        private Dictionary<string, object> DefaultWinRates = null;
        private Dictionary<string, object> SRWinRates = null;
        private List<object> DefaultBasePoint = null;
		private FieldInfo serverinput;
        private Vector3 eyesAdjust;
        private string MainContainer = "MainContainer";
        #endregion

        #region config
        private T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                newConfig = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            newConfig = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        private void SetConfigValue<T>(string category, string setting, T newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data != null && data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                newConfig = true;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadConfig();
		}

        void LoadConfig()
        {
            jackpot = GetConfigValue("Global", "Jackpot", 50000);
            DefaultWinRates = GetConfigValue("Global", "WinRate", DefaultPay());
            DefaultBasePoint = GetConfigValue("ServerRewards", "Match", DefaultSRPay());
            SRWinRates = GetConfigValue("ServerRewards", "WinPoint", DefautSRWinPay());
            SRjackpot = GetConfigValue("ServerRewards", "Jackpot", 10);
            SRMinBet = GetConfigValue("ServerRewards", "MinBet", 1000);
            MinBetjackpot = GetConfigValue("ServerRewards", "MinBetJackpot", 100000);
            MinBetjackpotEco = GetConfigValue("Global", "MinBetJackpot", 100000);
            SRJackpotNumber = GetConfigValue("ServerRewards", "JackpotMatch", 1869);
            JackpotNumber = GetConfigValue("Global", "JackpotMatch", 1058);
            DefaultMinRange = GetConfigValue("Global", "RollMinRange", 1000);
            DefaultMaxRange = GetConfigValue("Global", "RollMaxRange", 9999);
            UseSR = GetConfigValue("ServerRewards", "Enabled", false);
            AutoCloseAfterPlaceingBet = GetConfigValue("Global", "Place Bet Auto-close", false);
            UseNPC = GetConfigValue("HumanNPC", "Enabled", false);
            NPCID = GetConfigValue("HumanNPC", "npcID", new List<object>());
            BackgroundUrl = GetConfigValue("UI", "BackgroundMainURL",
                "http://wac.450f.edgecastcdn.net/80450F/kool1079.com/files/2016/05/RS2397_126989085.jpg");
            BackgroundColor = GetConfigValue("UI", "BackgroundMainColor",
                "0.1 0.1 0.1 1");
            WinBackgroundUrl = GetConfigValue("UI", "BackgroundWinURL",
                "http://wac.450f.edgecastcdn.net/80450F/kool1079.com/files/2016/05/RS2397_126989085.jpg");
            WinBackgroundColor = GetConfigValue("UI", "BackgroundWinColor",
                "0.1 0.1 0.1 1");
            anchorMin = GetConfigValue("CUI", "anchorMin", "0.8 0.2");
            anchorMax = GetConfigValue("CUI", "anchorMax", "1 0.8");
		    if (!newConfig) return;
		    SaveConfig();
		    newConfig = false;
        }

        static Dictionary<string, object> DefaultPay()
        {
            var d = new Dictionary<string, object>
            {
                { "111x", 1 },
                { "222x", 10 },
                { "333x", 50 },
                { "444x", 10 },
                { "555x", 75 },
                { "666x", 5 },
                { "777x", 75 },
                { "888x", 56 },
                { "999x", 42 },
                { "99x9", 52 },
                { "9x99", 57 },
                { "x999", 85 },
                { "99xx", 86 },
                { "9xxx", 86 }
            };
            return d;
        }

        static List<object> DefaultSRPay()
        {
            var d = new List<object>
            {
                "111x",
                "222x",
                "333x",
                "444x",
                "555x",
                "666x",
                "777x",
                "888x",
                "999x",
                "99x9",
                "9x99",
                "x999",
                "99xx",
                "9xxx"
            };
            return d;
        }

        static Dictionary<string, object> DefautSRWinPay()
        {
            var d = new Dictionary<string, object>
            {
                { "Match1Number", 1 },
                { "Match2Number", 2 },
                { "Match3Number", 3 },
                { "Match4Number", 4 }
            };
            return d;
        }

        #endregion

        #region data_init

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"NoPerm", "You don't have permission to do it."},
                {"NoWin", "You roll {0} but don't win anything."},
                {"NoPoint", "You don't have any point to use."},
                {"NoEconomy", "Economics isn't installed."},
                {"NoServerRewards", "Server Rewards isn't installed."},
                {"NotEnoughMoney", "You don't have enough money."},
                {"AddedNPC", "You successfully added the npc to the usable list."},
                {"NotInList", "The npc you are looking is not in the list."},
                {"RemovedNPC", "You successfully removed the npc to the usable list."},
                {"Win", "You roll {0} and won {1}$"},
                {"WinPoints", "You roll {0} and won {1} point(s)"},
                {"NoBet", "You must bet before."},
                {"NPCOnly", "You must find the NPC to use the lottery."},
                {"Balance", "Your current balance is {0}$"},
                {"BalanceSR", "Your current balance is {0} point(s)"},
                {"CurrentBet", "Your current bet is {0}$"},
                {"CurrentBetSR", "Your current bet is {0} point(s)"},
                {"Roll", "Roll {0} to win \nthe current jackpot:\n {1}$"},
                {"Jackpot", "You roll {0} and won the jackpot : {1}$ !!!!!!"},
                {"MiniSRBet", "You need to bet more to place bet. (Min: {0})"},
                {"BetMore", "If you had bet more you could win the jackpot. (Min: {0})"},
                {"MinimumSRBet", "Minimum bet of {0} to win the current jackpot: {1} point(s)"},
                {"CantOpen", "You must have Economics or ServerRewards installed and loaded."},
                {"WinRateText", "Win rate"},
                {"PointsText", "{0} : {1} point(s)"},
                {"MultiplierText", "Multiplier : x{0}"},
                {"BetmodifiersText", "Bet modifiers :"}
            };
            lang.RegisterMessages(messages, this);
            Puts("Messages loaded...");
        }

		void OnServerInitialized() {
            LoadConfig();
			LoadDefaultMessages();
            permission.RegisterPermission("Lottery.canuse", this);
            permission.RegisterPermission("Lottery.canconfig", this);
		    if (DefaultWinRates != null)
		    {
		        IndividualRates = new Dictionary<string, object>();
		        foreach (var entry in DefaultWinRates)
		        {
		            int rate;
		            if (!int.TryParse(entry.Value.ToString(), out rate)) continue;
		            IndividualRates.Add(entry.Key, rate);
		        }
		    }
		    if (SRWinRates != null)
		    {
		        var serverRewardsDict = SRWinRates;
		        SRRates = new Dictionary<string, int>();
		        if (serverRewardsDict != null)
		        {
		            foreach (var entry in serverRewardsDict)
		            {
		                int rate;
		                if (!int.TryParse(entry.Value.ToString(), out rate)) continue;
		                SRRates.Add(entry.Key, rate);
		            }
		        }
		    }

		    data = Interface.Oxide.DataFileSystem.GetFile(Name);
		    try
		    {
		        Currentbet = data.ReadObject<Dictionary<ulong, playerinfo>>();
		    }
		    catch (Exception e)
		    {
		        Currentbet = new Dictionary<ulong, playerinfo>();
		        Puts(e.Message);
		    }
		    data.WriteObject(Currentbet);
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            eyesAdjust = new Vector3(0f, 1.5f, 0f);
		}

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                GUIDestroy(player);
                GUIDestroy(player);
            }
            Puts("Data saved.");
            if(Currentbet != null)
            SaveData(Currentbet);
        }
        #endregion
        
        #region save_data
        void SaveData(Dictionary<ulong, playerinfo> datas)
        {
            data.WriteObject(datas);
        }
        #endregion

        #region Lotery

        private CuiElement CreateImage(string panelName, bool win = false)
        {
            var element = new CuiElement();
            var url = !win ? BackgroundUrl : WinBackgroundUrl;
            var color = !win ? BackgroundColor : WinBackgroundColor;
            var image = new CuiRawImageComponent
            {
                Url = url,
                Color = color
            };

            var rectTransform = new CuiRectTransformComponent
            {
                AnchorMin = "0 0",
                AnchorMax = "1 1"
            };
            element.Components.Add(image);
            element.Components.Add(rectTransform);
            element.Name = CuiHelper.GetGuid();
            element.Parent = panelName;
            return element;
        }

        void RefreshUI(BasePlayer player, string[] args)
        {
            CuiHelper.DestroyUi(player, "containerLotery");
            CuiHelper.DestroyUi(player, "containerwinLotery");
            CuiHelper.DestroyUi(player, "ButtonBackLotery");
            CuiHelper.DestroyUi(player, "ButtonForwardLotery");

            if(Economy != null && Economy.IsLoaded && !UseSR)
                ShowLotery(player, args);
            else if(ServerRewards != null && ServerRewards.IsLoaded)
                ShowSrLotery(player,  args);
        }

        void GUIDestroy(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "MainContainer");
            CuiHelper.DestroyUi(player, "containerLotery");
            CuiHelper.DestroyUi(player, "containerwinLotery");
            CuiHelper.DestroyUi(player, "ButtonBackLotery");
            CuiHelper.DestroyUi(player, "ButtonForwardLotery");
        }
        
        void ShowLotery(BasePlayer player, string[] args)
        {
            if (Economy == null || !Economy.IsLoaded)
            {
                SendReply(player, lang.GetMessage("NoEconomy", this, player.UserIDString));
                return;
            }
            int from = 0;
            var currentBalance = Economy.Call("Balance", player.UserIDString);
            playerinfo playerbet;
            if(Currentbet == null)
                Currentbet = new Dictionary<ulong, playerinfo>();
            if (Currentbet.ContainsKey(player.userID))
            {
                Currentbet.TryGetValue(player.userID, out playerbet);
            }
            else
            {
                Currentbet.Add(player.userID, new playerinfo());
            }
            playerbet = Currentbet[player.userID];
            if (args != null && args.Length > 0 && playerbet != null)
            {
                if (args[0].Contains("less") || args[0].Contains("plus"))
                {
                    if (args[0].Contains("plus"))
                    {
                        if ((double)currentBalance >= playerbet.currentbet*(playerbet.multiplicator + 1))
                        {
                            int multiplier;
                            int.TryParse(args[1], out multiplier);
                            playerbet.multiplicator += multiplier;
                        }
                    }
                    if (args[0].Contains("less"))
                    {
                        if (playerbet.multiplicator > 1)
                            playerbet.multiplicator -= 1;
                    }
                }
                if (args[0].Contains("bet"))
                {
                    int bet;
                    int.TryParse(args[1], out bet);
                    if((double)currentBalance < (playerbet.currentbet+bet)*playerbet.multiplicator)
                        SendReply(player, lang.GetMessage("NotEnoughMoney", this, player.UserIDString));
                    else
                        playerbet.currentbet += bet;
                }
                if (args[0].Contains("page"))
                {
                    int.TryParse(args[1], out from);
                }
            }
            int i = 0;
            double jackpots = Math.Round(Currentbet.Sum(v => v.Value.totalbet));
            jackpots += jackpot;
            var win = new CuiElementContainer();
            var containerwin = win.Add(new CuiPanel
            {
                Image =
                {
                    Color = WinBackgroundColor
                },
                RectTransform =
                {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                },
                CursorEnabled = true
            }, "Hud", "containerwinLotery");
            win.Add(new CuiLabel
            {
                Text =
                {
                    Text = lang.GetMessage("WinRateText", this, player.UserIDString),
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.1 0.85",
                    AnchorMax = "0.9 1"
                }
            }, containerwin);
            var backgroundImageWin = CreateImage("containerwinLotery", true);
            win.Add(backgroundImageWin);
            foreach (var elem in IndividualRates)
            {
                if (i == 0)
                {
                    var pos = 0.81 - (i - from)/10.0;
                    var pos2 = 0.86 - (i - from)/20.0;
                    win.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = elem.Key + ": " + elem.Value + " %",
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{0.1} {pos}",
                            AnchorMax = $"{0.9} {pos2}"
                        }
                    }, containerwin);
                }
                else if (i >= from && i < from + 9)
                {
                    var pos = 0.81 - (i - from)/10.0;
                    var pos2 = 0.86 - (i - from)/20.0;
                    win.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = elem.Key + ": " + elem.Value + " %",
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{0.1} {pos}",
                            AnchorMax = $"{0.9} {pos2}"
                        }
                    }, containerwin);
                }
                i++;
            }
            var minfrom = from <= 10 ? 0 : from - 10;
            var maxfrom = from + 10 >= i ? from : from + 10;
            win.AddRange(ChangeBonusPage(minfrom, maxfrom));

            var elements = new CuiElementContainer();
        #region background
            var container = elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = BackgroundColor
                },
                RectTransform =
                {
                    AnchorMin = "0 0.2",
                    AnchorMax = "0.8 0.8"
                },
                CursorEnabled = true
            }, "Hud", "containerLotery");
            var backgroundImage = CreateImage("containerLotery");

            elements.Add(backgroundImage);
        #endregion
        #region closebutton
            var closeButton = new CuiButton
            {
                Button =
                {
                    Command = "cmdDestroyUI",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                RectTransform =
                {
                    AnchorMin = "0.86 0.92",
                    AnchorMax = "0.97 0.98"
                },
                Text =
                {
                    Text = "X",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            };
            elements.Add(closeButton, container);
        #endregion
        #region currency
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = string.Format(lang.GetMessage("Balance", this, player.UserIDString), currentBalance),
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.1 0.91",
                    AnchorMax = "0.9 0.98"
                }
            }, container);
        #endregion
        #region multiplier

            if (playerbet != null)
            {
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "Multiplier : x" + playerbet.multiplicator,
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.81",
                        AnchorMax = "0.15 0.88"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdLess Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "-",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.2 0.81",
                        AnchorMax = "0.3 0.88"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdPlus Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.31 0.81",
                        AnchorMax = "0.41 0.88"
                    }
                }, container);
                #endregion
        #region bet
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "Bet modifiers :",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.61",
                        AnchorMax = "0.15 0.68"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 1 Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+1",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.51",
                        AnchorMax = "0.15 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 5 Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+5",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.155 0.51",
                        AnchorMax = "0.255 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 10 Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+10",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.26 0.51",
                        AnchorMax = "0.36 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 100 Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+100",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.365 0.51",
                        AnchorMax = "0.485 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 1000 Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+1000",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.41",
                        AnchorMax = "0.15 0.48"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 10000 Eco",
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+10000",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.155 0.41",
                        AnchorMax = "0.255 0.48"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdPlaceBet Eco",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "Place Bet",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.31",
                        AnchorMax = "0.255 0.38"
                    }
                }, container);

                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdResetBet lot",
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "Reset Bet",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.21",
                        AnchorMax = "0.255 0.28"
                    }
                }, container);

                #endregion
                #region winpart
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = string.Format(lang.GetMessage("CurrentBet", this, player.UserIDString), playerbet.currentbet*playerbet.multiplicator),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.71 0.71",
                        AnchorMax = "0.99 0.81"
                    }
                }, container);
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = string.Format(lang.GetMessage("Roll", this, player.UserIDString), JackpotNumber, jackpots),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.71 0.39",
                        AnchorMax = "0.99 0.59"
                    }
                }, container);
            }
            #endregion
            CuiHelper.AddUi(player, elements);
            CuiHelper.AddUi(player, win);
            Currentbet.Remove(player.userID);
            Currentbet.Add(player.userID, playerbet);
            SaveData(Currentbet);
        }
        
        void ShowSrLotery(BasePlayer player, string[] args)
        {
            if (ServerRewards == null || !ServerRewards.IsLoaded)
            {
                SendReply(player, lang.GetMessage("NoServerRewards", this, player.UserIDString));
                return;
            }
            int from = 0;
            var currentBalance = ServerRewards.Call("CheckPoints", player.userID);
            if (currentBalance != null)
            {
                playerinfo playerbet;
                if (Currentbet.ContainsKey(player.userID))
                {
                    Currentbet.TryGetValue(player.userID, out playerbet);
                }
                else
                {
                    Currentbet.Add(player.userID, new playerinfo());
                    Currentbet.TryGetValue(player.userID, out playerbet);
                }
                playerbet = Currentbet[player.userID];
                if (playerbet != null && args != null && args.Length > 0)
                {
                    if (args[0].Contains("less") || args[0].Contains("plus"))
                    {
                        if (args[0].Contains("plus"))
                        {
                            if ((int) currentBalance >= playerbet.currentbet*(playerbet.multiplicator + 1))
                            {
                                int multiplier;
                                int.TryParse(args[1], out multiplier);
                                playerbet.multiplicator += multiplier;
                            }
                        }
                        if (args[0].Contains("less"))
                        {
                            if (playerbet.multiplicator > 1)
                                playerbet.multiplicator -= 1;
                        }
                    }
                    if (args[0].Contains("bet"))
                    {
                        int bet;
                        int.TryParse(args[1], out bet);
                        if ((int) currentBalance < (playerbet.currentbet + bet)*playerbet.multiplicator)
                            SendReply(player, lang.GetMessage("NotEnoughMoney", this, player.UserIDString));
                        else playerbet.currentbet += bet;
                    }
                    if (args[0].Contains("page"))
                    {
                        int.TryParse(args[1], out @from);
                    }
                }
                var i = 0;
                double jackpots = Math.Round(Currentbet.Sum(v => v.Value.totalbet));
                jackpots += jackpot;
                var win = new CuiElementContainer();
                var containerwinlocal = win.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = WinBackgroundColor
                    },
                    RectTransform =
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax
                    },
                    CursorEnabled = true
                }, "Hud", "containerwinLotery");
                win.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("WinRateText", this, player.UserIDString),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.1 0.85",
                        AnchorMax = "0.9 1"
                    }
                }, containerwinlocal);
                var backgroundImageWin = CreateImage("containerwinLotery", true);
                win.Add(backgroundImageWin);
                foreach (var elem in SRRates)
                {
                    var pos = 0.86 - (i - @from)/10.0;
                    var pos2 = 0.91 - (i - @from)/20.0;
                    win.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = lang.GetMessage("PointsText", this, player.UserIDString).Replace("{0}", elem.Key).Replace("{1}", elem.Value.ToString()),
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{0.1} {pos}",
                            AnchorMax = $"{0.9} {pos2}"
                        }
                    }, containerwinlocal);
                    i++;
                }
                var elements = new CuiElementContainer();
                #region background
                var container = elements.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = BackgroundColor
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0.2",
                        AnchorMax = "0.8 0.8"
                    },
                    CursorEnabled = true
                }, "Hud", "containerLotery");
                var backgroundImage = CreateImage("containerLotery");
                elements.Add(backgroundImage);
                #endregion
                #region closebutton
                var closeButton = new CuiButton
                {
                    Button =
                    {
                        Command = "cmdDestroyUI",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.86 0.92",
                        AnchorMax = "0.97 0.98"
                    },
                    Text =
                    {
                        Text = "X",
                        FontSize = 22,
                        Align = TextAnchor.MiddleCenter
                    }
                };
                elements.Add(closeButton, container);
                #endregion
                #region currency
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = string.Format(lang.GetMessage("BalanceSR", this, player.UserIDString), currentBalance),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.1 0.91",
                        AnchorMax = "0.9 0.98"
                    }
                }, container);
                #endregion
                #region multiplier
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("MultiplierText", this, player.UserIDString).Replace("{0}", playerbet.multiplicator.ToString()),
                        FontSize = 18,
                        Align = TextAnchor.MiddleLeft
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.81",
                        AnchorMax = "0.30 0.88"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdLess",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "-",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.2 0.81",
                        AnchorMax = "0.3 0.88"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdPlus",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.31 0.81",
                        AnchorMax = "0.41 0.88"
                    }
                }, container);
                #endregion
                #region bet
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = lang.GetMessage("BetmodifiersText", this, player.UserIDString),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.61",
                        AnchorMax = "0.15 0.68"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 1",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+1",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.51",
                        AnchorMax = "0.15 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 5",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+5",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.155 0.51",
                        AnchorMax = "0.255 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 10",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+10",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.26 0.51",
                        AnchorMax = "0.36 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 100",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+100",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.365 0.51",
                        AnchorMax = "0.485 0.58"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 1000",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+1000",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.41",
                        AnchorMax = "0.15 0.48"
                    }
                }, container);
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdBet 10000",
                        Close = container,
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "+10000",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.155 0.41",
                        AnchorMax = "0.255 0.48"
                    }
                }, container);
                
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdPlaceBet",
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "Place Bet",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.31",
                        AnchorMax = "0.255 0.38"
                    }
                }, container);

                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "cmdResetBet",
                        Color = "0.8 0.8 0.8 0.2"
                    },
                    Text =
                    {
                        Text = "Reset Bet",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.05 0.21",
                        AnchorMax = "0.255 0.28"
                    }
                }, container);

                #endregion
                #region winpart
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = string.Format(lang.GetMessage("CurrentBetSR", this, player.UserIDString), playerbet.currentbet*playerbet.multiplicator),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.71 0.71",
                        AnchorMax = "0.99 0.81"
                    }
                }, container);

                if (UseSR && ServerRewards.IsLoaded)
                {
                    var mini = string.Format(lang.GetMessage("MinimumSRBet", this, player.UserIDString), MinBetjackpot, SRjackpot);
                    elements.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = mini,
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.71 0.39",
                            AnchorMax = "0.99 0.59"
                        }
                    }, container);
                }
                else
                {
                    elements.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = string.Format(lang.GetMessage("Roll", this, player.UserIDString), JackpotNumber, jackpots),
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.71 0.39",
                            AnchorMax = "0.99 0.59"
                        }
                    }, container);
                }
                #endregion
                CuiHelper.AddUi(player, elements);
                CuiHelper.AddUi(player, win);
                Currentbet.Remove(player.userID);
                Currentbet.Add(player.userID, playerbet);
            }
            else
                SendReply(player, lang.GetMessage("NoPoint", this, player.UserIDString));
            SaveData(Currentbet);
        }
        
        private static CuiElementContainer ChangeBonusPage(int pageless, int pagemore)
        {
            return new CuiElementContainer
            {
                {
                    new CuiButton
                    {
                        Button = {Command = $"cmdPage page {pageless}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.83 0.25", AnchorMax = "0.91 0.3"},
                        Text = {Text = "<<", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    "Hud",
                    "ButtonBackLotery"
                },
                {
                    new CuiButton
                    {
                        Button = {Command = $"cmdPage page {pagemore}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.92 0.25", AnchorMax = "1 0.30"},
                        Text = {Text = ">>", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    "Hud",
                    "ButtonForwardLotery"
                }
            };
        }
        #endregion

        #region reward

        private object FindReward(BasePlayer player, int bet, int reference, int multiplicator = 1)
        {
            object findReward = 0;
            double reward = 0;
            int[] number = GetIntArray(reference);
            string newreference;
            if (UseSR && ServerRewards.IsLoaded)
            {
                #region jackpot

                if (reference == SRJackpotNumber)
                {
                    if (bet*multiplicator >= MinBetjackpot)
                    {
                        findReward = (int)findReward*bet*multiplicator + (int) SRjackpot;
                        return (int)findReward;
                    }
                    SendReply(player, string.Format(lang.GetMessage("BetMore", this, player.UserIDString), MinBetjackpot));
                }

                #endregion

                #region full_match
                if (DefaultBasePoint.Contains(reference.ToString()))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }

                #endregion

                #region three_match

                newreference = number[0].ToString() + number[1].ToString() + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match3Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = number[0].ToString() + number[1].ToString() + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + number[1].ToString() + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }

                #endregion

                #region two_match

                newreference = number[0].ToString() + number[1].ToString() + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = number[0].ToString() + "x" + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + "x" + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + number[1].ToString() + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + number[1].ToString() + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }

                #endregion

                #region one_match

                newreference = number[0].ToString() + "x" + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + number[1].ToString() + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + "x" + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }
                newreference = "x" + "x" + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return (int)findReward*bet*multiplicator;
                }

                #endregion

                return findReward;
            }
            if(!UseSR && Economy.IsLoaded)
            {
                object rws = 0;
                #region jackpot
                if (reference == JackpotNumber)
                {
                    if (bet*multiplicator >= MinBetjackpotEco)
                    {
                        int jackpots = (int) Math.Round(Currentbet.Sum(v => v.Value.totalbet));
                        return bet + bet*multiplicator + jackpots + Convert.ToInt32(jackpot);
                    }
                    SendReply(player, string.Format(lang.GetMessage("BetMore", this, player.UserIDString), MinBetjackpotEco));
                }
                #endregion

                #region full_match

                if (IndividualRates.ContainsKey(reference.ToString()))
                {
                    IndividualRates.TryGetValue(reference.ToString(), out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }

                #endregion

                #region three_match
                newreference = number[0].ToString() + number[1].ToString() + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = number[0].ToString() + number[1].ToString() + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference =  "x" + number[1].ToString() + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                #endregion

                #region two_match
                newreference = number[0].ToString() + number[1].ToString() + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = number[0].ToString() + "x" + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference =  "x" + "x" + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = "x" + number[1].ToString() + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference =  "x" + number[1].ToString() + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }

                #endregion

                #region one_match
                newreference = number[0].ToString() + "x" + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference =  "x" + number[1].ToString() + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference =  "x" + "x" + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }
                newreference = "x" + "x" + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out rws);
                    reward = (bet+bet*(Convert.ToInt32(rws)/100.0d)) * multiplicator;
                    return reward;
                }

                #endregion
                return rws;
            }
            return null;
        }
        #endregion

        #region Command
        [ChatCommand("lot")]
        private void cmdLotery(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "Lottery.canuse"))
            {
                SendReply(player, string.Format(lang.GetMessage("NoPerm", this, player.UserIDString)));
                return;
            }
            if (args.Length != 0)
            {
                if (args[0].ToLower() == "add")
                {
                    if (!permission.UserHasPermission(player.UserIDString, "Lottery.canconfig"))
                    {
                        SendReply(player, string.Format(lang.GetMessage("NoPerm", this, player.UserIDString)));
                        return;
                    }
                    var input = serverinput.GetValue(player) as InputState;
                    var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
                    var target = DoRay(player.transform.position + eyesAdjust, currentRot);
                    if (!(target is bool) && target is BasePlayer)
                    {
                        var bases = target as BasePlayer;
                        NPCID.Add(bases.UserIDString);
                        SetConfigValue("HumanNPC", "npcID", NPCID);
                        SendReply(player, lang.GetMessage("AddedNPC", this, player.UserIDString));
                        return;
                    }
                }
                if (args[0].ToLower() == "remove")
                {
                    if (!permission.UserHasPermission(player.UserIDString, "Lottery.canconfig"))
                    {
                        SendReply(player, string.Format(lang.GetMessage("NoPerm", this, player.UserIDString)));
                        return;
                    }
                    var input = serverinput.GetValue(player) as InputState;
                    var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
                    var target = DoRay(player.transform.position + eyesAdjust, currentRot);
                    if (!(target is bool) && target is BasePlayer)
                    {
                        var bases = target as BasePlayer;
                        if (NPCID.Contains(bases.UserIDString))
                        {
                            NPCID.Remove(bases.UserIDString);
                            SetConfigValue("HumanNPC", "npcID", NPCID);
                            SendReply(player, lang.GetMessage("RemovedNPC", this, player.UserIDString));
                        }
                        else
                            SendReply(player, lang.GetMessage("NotInList", this, player.UserIDString));
                        return;
                    }
                }
            }
            if (UseNPC)
            {
                SendReply(player, string.Format(lang.GetMessage("NPCOnly", this, player.UserIDString)));
                return;
            }
            if (Economy != null && Economy.IsLoaded && !UseSR)
            {
                var win = new CuiElementContainer();
                win.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = WinBackgroundColor
                    },
                    RectTransform =
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax
                    },
                    CursorEnabled = true
                }, "Hud", MainContainer);
                CuiHelper.AddUi(player, win);
                ShowLotery(player, null);
            }
            else if (ServerRewards != null && ServerRewards.IsLoaded && UseSR)
            {
                var win = new CuiElementContainer();
                win.Add(new CuiPanel
                {
                    Image =
                    {
                        Color = WinBackgroundColor
                    },
                    RectTransform =
                    {
                        AnchorMin = anchorMin,
                        AnchorMax = anchorMax
                    },
                    CursorEnabled = true
                }, "Hud", MainContainer);
                CuiHelper.AddUi(player, win);
                ShowSrLotery(player, null);
            }
            else
            {
                SendReply(player, lang.GetMessage("CantOpen", this, player.UserIDString));
            }
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player, Vector3 destination)
        {
            if (NPCID != null && NPCID.Contains(npc.UserIDString) && UseNPC)
            {
                RefreshUI(player, null);
            }
        }

        [ConsoleCommand("cmdDestroyUI")]
        void cmdDestroyUI(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
        }

        [ConsoleCommand("cmdLess")]
        void cmdLess(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            RefreshUI(arg.Player(), new[] {"less", "-1"});
        }

        [ConsoleCommand("cmdBet")]
        void cmdBet(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            RefreshUI(arg.Player(), new[] {"bet", arg.Args[0]});
        }

        [ConsoleCommand("cmdPlus")]
        void cmdPlus(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            RefreshUI(arg.Player(), new[] {"plus", "1"});
        }

        [ConsoleCommand("cmdPage")]
        void cmdPage(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            RefreshUI(arg.Player(), new[] {"page", arg.Args[1]});
        }

        [ConsoleCommand("cmdPlaceBet")]
        void cmdPlaceBet(ConsoleSystem.Arg arg)
        {
            Dictionary<ulong, playerinfo> playerinfos = new Dictionary<ulong, playerinfo>();
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
            playerinfo playerbet = new playerinfo();
            if (Currentbet == null)
                return;
            if (!Currentbet.ContainsKey(arg.Player().userID))
            {
                Currentbet.Add(arg.Player().userID, new playerinfo());
            }
            else
            {
                Currentbet.TryGetValue(arg.Player().userID, out playerbet);
            }
            if (playerbet != null && Math.Abs(playerbet.currentbet) < 0.0000001)
            {
                SendReply(arg.Player(), lang.GetMessage("NoBet", this, arg.Player().UserIDString));
                return;
            }
            int random = UnityEngine.Random.Range(DefaultMinRange, DefaultMaxRange);
            if (UseSR && ServerRewards != null && ServerRewards.IsLoaded)
            {
                int rwd;
                if (playerbet != null)
                {
                    var reward = FindReward(arg.Player(), (int)playerbet.currentbet, random, playerbet.multiplicator);
                    if (SRMinBet <= playerbet.currentbet*playerbet.multiplicator)
                    {
                        if (reward != null && Convert.ToInt32(reward) != 0)
                        {
                            rwd = (int)reward;
                            if (playerbet.currentbet*playerbet.multiplicator >= MinBetjackpot)
                                if (random == SRJackpotNumber)
                                {
                                    foreach (var resetbet in Currentbet)
                                    {
                                        resetbet.Value.totalbet = 0;
                                        resetbet.Value.multiplicator = 1;
                                        playerinfos.Add(resetbet.Key, resetbet.Value);
                                    }
                                    Currentbet.Clear();
                                    Currentbet = playerinfos;
                                    ServerRewards?.Call("AddPoints", new object[] {arg.Player().userID, rwd});
                                    SendReply(arg.Player(),
                                        string.Format(lang.GetMessage("Jackpot", this, arg.Player().UserIDString), random,
                                            rwd));
                                    return;
                                }
                            if (Math.Abs(rwd) > 0 && random != SRJackpotNumber)
                            {
                                Currentbet.Remove(arg.Player().userID);
                                Currentbet.Add(arg.Player().userID, playerbet);
                                ServerRewards?.Call("AddPoints", new object[] {arg.Player().userID, rwd});
                                SendReply(arg.Player(),
                                    string.Format(lang.GetMessage("WinPoints", this, arg.Player().UserIDString), random,
                                                rwd));
                            }
                            else
                            {
                                ServerRewards?.Call("AddPoints", new object[] {arg.Player().userID, rwd});
                                SendReply(arg.Player(),
                                    string.Format(lang.GetMessage("WinPoints", this, arg.Player().UserIDString), random,
                                        rwd));
                            }

                            playerbet.totalbet += playerbet.currentbet*(10/100.0);
                            ServerRewards?.Call("TakePoints", arg.Player().userID, (int)playerbet.currentbet*playerbet.multiplicator);
                            playerbet.currentbet = 0;
                            playerbet.multiplicator = 1;
                        }
                        else
                        {
                            playerbet.totalbet += playerbet.currentbet*(10/100.0);
                            ServerRewards?.Call("TakePoints", arg.Player().userID, (int)playerbet.currentbet*playerbet.multiplicator);
                            playerbet.currentbet = 0;
                            playerbet.multiplicator = 1;
                            SendReply(arg.Player(), string.Format(lang.GetMessage("NoWin", this, arg.Player().UserIDString), random));
                        }
                    }
                    else
                    {
                        SendReply(arg.Player(), string.Format(lang.GetMessage("MiniSRBet", this, arg.Player().UserIDString), SRMinBet));
                    }
                }
            }
            else if(!UseSR && Economy != null && Economy.IsLoaded)
            {
                if (playerbet != null)
                {
                    var reward = FindReward(arg.Player(), (int)playerbet.currentbet, random, playerbet.multiplicator);
                    if (reward != null && Convert.ToInt32(reward) != 0)
                    {
                        var rwd = (double) reward;
                        if (playerbet.currentbet*playerbet.multiplicator >= MinBetjackpotEco)
                            if (random == JackpotNumber)
                            {
                                foreach (var resetbet in Currentbet)
                                {
                                    resetbet.Value.totalbet = 0;
                                    resetbet.Value.multiplicator = 1;
                                    playerinfos.Add(resetbet.Key, resetbet.Value);
                                }
                                Currentbet.Clear();
                                Currentbet = playerinfos;
                                Economy?.CallHook("Deposit", arg.Player().UserIDString, rwd);
                                SendReply(arg.Player(),
                                    string.Format(lang.GetMessage("Jackpot", this, arg.Player().UserIDString), random,
                                        rwd));
                                return;
                            }
                        if (Math.Abs(rwd) > 0 && random != JackpotNumber)
                        {
                            Currentbet.Remove(arg.Player().userID);
                            Currentbet.Add(arg.Player().userID, playerbet);
                            Economy?.CallHook("Deposit", arg.Player().UserIDString, rwd);
                            SendReply(arg.Player(),
                                string.Format(lang.GetMessage("Win", this, arg.Player().UserIDString), random, rwd));
                        }
                        else
                        {
                            Economy?.CallHook("Deposit", arg.Player().UserIDString, rwd);
                            SendReply(arg.Player(),
                                string.Format(lang.GetMessage("Win", this, arg.Player().UserIDString), random, rwd));
                        }
                        playerbet.totalbet += playerbet.currentbet*(10/100.0);
                        Economy?.CallHook("Withdraw", arg.Player().UserIDString, playerbet.currentbet*playerbet.multiplicator);
                        playerbet.currentbet = 0;
                        playerbet.multiplicator = 1;
                    }
                    else
                    {
                        playerbet.totalbet += playerbet.currentbet*(10/100.0);
                        Economy?.CallHook("Withdraw", arg.Player().UserIDString, playerbet.currentbet*playerbet.multiplicator);
                        playerbet.currentbet = 0;
                        playerbet.multiplicator = 1;
                        SendReply(arg.Player(),
                            string.Format(lang.GetMessage("NoWin", this, arg.Player().UserIDString), random));
                    }
                }
            }
            SaveData(Currentbet);
            if (!AutoCloseAfterPlaceingBet)
            {
                if (arg.Args != null && arg.Args.Length > 0)
                    ShowLotery(arg.Player(), new[] {"bet", arg.Args[0]});
                else
                    ShowSrLotery(arg.Player(), null);
            }
        }

        [ConsoleCommand("cmdResetBet")]
        void cmdResetBet(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
            {
                Puts(arg.FullString);
                BasePlayer player = arg.Player();
                GUIDestroy(player);
                playerinfo playerbet;
                Currentbet.TryGetValue(player.userID, out playerbet);
                if(playerbet != null)
                Currentbet[player.userID].currentbet = 0;
                if (arg.Args != null && arg.Args.Length > 0)
                    ShowLotery(arg.Player(), null);
                else
                    ShowSrLotery(arg.Player(), null);
            }
        }
        #endregion
    }
}

// --- End of file: Lottery.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-defender ---
// --- Original File Path: L/LootDefender/LootDefender.cs ---

﻿using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Loot Defender", "Author Egor Blagov, Maintainer nivex", "2.2.4")]
    [Description("Defends loot from other players who dealt less damage than you.")]
    internal class LootDefender : RustPlugin
    {
        [PluginReference]
        Plugin PersonalHeli, Friends, Clans, RustRewards, HeliSignals, BradleyDrops, HelpfulSupply, ShoppyStock, XLevels, XPerience, SkillTree;

        private static LootDefender Instance;
        private static StringBuilder sb;
        private const ulong supplyDropSkinID = 234501;
        private const string bypassLootPerm = "lootdefender.bypass.loot";
        private const string bypassDamagePerm = "lootdefender.bypass.damage";
        private const string bypassLockoutsPerm = "lootdefender.bypass.lockouts";
        private Dictionary<ulong, List<DamageKey>> _apcAttackers = new();
        private Dictionary<ulong, List<DamageKey>> _heliAttackers = new();
        private Dictionary<ulong, ulong> _locked { get; set; } = new();
        private List<ulong> _personal { get; set; } = new();
        private List<ulong> _boss { get; set; } = new();
        private List<string> _sent { get; set; } = new();
        private static StoredData data { get; set; } = new();
        private MonumentInfo launchSite { get; set; }
        private List<MonumentInfo> harbors { get; set; } = new();
        private List<ulong> ownerids = new() { 0, 1337422, 3566257, 123425345634634 };

        public enum DamageEntryType
        {
            Bradley,
            Corpse,
            Heli,
            NPC,
            None
        }

        public class Lockout
        {
            public double Bradley { get; set; }

            public double Heli { get; set; }

            public bool Any() => Bradley > 0 ||  Heli > 0;
        }

        private class StoredData
        {
            public Dictionary<string, Lockout> Lockouts { get; } = new();
            public Dictionary<string, UI.Info> UI { get; set; } = new();
            [JsonProperty(PropertyName = "DamageInfo")]
            public Dictionary<ulong, DamageInfo> Damage { get; set; } = new();
            [JsonProperty(PropertyName = "LockInfo")]
            public Dictionary<ulong, LockInfo> Lock { get; set; } = new();

            public void Sanitize()
            {
                foreach (var (uid, damageInfo) in Damage.ToList())
                {
                    damageInfo._entity = BaseNetworkable.serverEntities.Find(new(uid)) as BaseEntity;

                    if (damageInfo.damageEntryType == DamageEntryType.NPC && !config.Npc.Enabled)
                    {
                        if (damageInfo._entity.IsValid())
                        {
                            damageInfo._entity.OwnerID = 0uL;
                        }

                        Damage.Remove(uid);
                    }
                    else if (damageInfo._entity == null)
                    {
                        Damage.Remove(uid);
                    }
                    else
                    {
                        foreach (var x in damageInfo.damageKeys)
                        {
                            x.attacker = BasePlayer.FindByID(x.userid);
                        }

                        damageInfo.Start();
                    }
                }

                foreach (var (uid, lockInfo) in Lock.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new(uid)) as BaseEntity;

                    if (lockInfo.damageInfo.damageEntryType == DamageEntryType.NPC && !config.Npc.Enabled)
                    {
                        if (entity.IsValid())
                        {
                            entity.OwnerID = 0uL;
                        }

                        Lock.Remove(uid);
                    }
                    else if (entity == null)
                    {
                        Lock.Remove(uid);
                    }
                }
            }
        }

        private class DamageEntry
        {
            public float DamageDealt { get; set; }
            public DateTime Timestamp { get; set; }
            public string TeamID { get; set; }

            public DamageEntry() { }

            public DamageEntry(ulong teamID)
            {
                Timestamp = DateTime.Now;
                TeamID = teamID.ToString();
            }

            public bool IsOutdated(int timeout) => timeout > 0 && DateTime.Now.Subtract(Timestamp).TotalSeconds >= timeout;
        }

        private class DamageKey
        {
            public ulong userid { get; set; }
            public string name { get; set; }
            public DamageEntry damageEntry { get; set; }
            internal BasePlayer attacker { get; set; }

            public DamageKey() { }

            public DamageKey(BasePlayer attacker)
            {
                this.attacker = attacker;
                userid = attacker.userID;
                name = attacker.displayName;
            }
        }

        private class DamageInfo
        {
            public List<DamageKey> damageKeys { get; set; } = new();
            [JsonIgnore]
            public Dictionary<ulong, BasePlayer> interact { get; set; } = new();
            private List<ulong> participants { get; set; } = new();
            public DamageEntryType damageEntryType { get; set; } = DamageEntryType.None;
            public string NPCName { get; set; }
            public ulong OwnerID { get; set; }
            public ulong SkinID { get; set; }
            public DateTime start { get; set; }
            internal int _lockTime { get; set; }
            [JsonIgnore]
            internal BaseEntity _entity { get; set; }
            internal Vector3 _position { get; set; }
            internal Vector3 lastAttackedPosition { get; set; }
            internal ulong _uid { get; set; }
            [JsonIgnore]
            internal Timer _timer { get; set; }
            internal List<DamageKey> keys { get; set; } = new();

            List<DamageGroup> damageGroups;

            internal float FullDamage
            {
                get
                {
                    return damageKeys.Sum(x => x.damageEntry.DamageDealt);
                }
            }

            public DamageInfo() { }

            public DamageInfo(DamageEntryType damageEntryType, string NPCName, BaseEntity entity, DateTime start)
            {
                SkinID = entity.skinID;
                _entity = entity;
                _uid = entity.net.ID.Value;

                this.damageEntryType = damageEntryType;
                this.NPCName = NPCName;
                this.start = start;

                Start();
            }

            public void Start()
            {
                _lockTime = GetLockTime(damageEntryType);
                _timer = Instance.timer.Every(1f, CheckExpiration);
            }

            public void DestroyTimer()
            {
                _timer?.Destroy();
            }

            private void CheckExpiration()
            {
                damageKeys.ForEach(x =>
                {
                    if (x.damageEntry.IsOutdated(_lockTime))
                    {
                        if (x.userid == OwnerID)
                        {
                            Unlock();
                        }

                        keys.Add(x);
                    }
                });

                keys.ForEach(x => damageKeys.Remove(x));
                keys.Clear();
            }

            public void Unlock()
            {
                OwnerID = 0;

                if (_entity != null)
                {
                    _entity.OwnerID = 0;
                }

                if (!Instance._locked.Remove(_uid))
                {
                    return;
                }

                if (damageEntryType == DamageEntryType.Bradley && config.Bradley.Messages.NotifyChat)
                {
                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        CreateMessage(target, "BradleyUnlocked", PositionToGrid(_position));
                    }
                }

                if (damageEntryType == DamageEntryType.Heli && config.Helicopter.Messages.NotifyChat)
                {
                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        CreateMessage(target, "HeliUnlocked", PositionToGrid(_position));
                    }
                }

                if (damageEntryType == DamageEntryType.NPC && config.Npc.Messages.NotifyChat)
                {
                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        CreateMessage(target, "NpcUnlocked", NPCName, PositionToGrid(_position));
                    }
                }
            }

            private void Lock(BaseEntity entity, ulong id)
            {
                Instance._locked[_uid] = entity.OwnerID = OwnerID = id;
                _position = entity.transform.position;
            }

            public void AddDamage(BaseCombatEntity entity, BasePlayer attacker, DamageEntry entry, float amount)
            {
                entry.DamageDealt += amount;
                entry.Timestamp = DateTime.Now;
                _position = entity.transform.position;
                lastAttackedPosition = attacker.transform.position;

                if (SkinID == 0)
                {
                    SkinID = entity.skinID;
                }

                if (damageEntryType == DamageEntryType.NPC && !Instance.CanLockNpc(entity))
                {
                    return;
                }

                if (damageEntryType == DamageEntryType.Bradley && !Instance.CanLockBradley(entity))
                {
                    return;
                }

                if (entity.OwnerID.IsSteamId())
                {
                    OwnerID = entity.OwnerID;
                }

                if (OwnerID != 0uL)
                {
                    return;
                }

                float damage = 0f;
                var grid = PositionToGrid(entity.transform.position);

                if (entry.TeamID != "0")
                {
                    foreach (var x in damageKeys)
                    {
                        if (x.damageEntry.TeamID == entry.TeamID)
                        {
                            damage += x.damageEntry.DamageDealt;
                        }
                    }
                }
                else damage = entry.DamageDealt;

                if (config.Helicopter.Threshold > 0f && entity is PatrolHelicopter)
                {
                    if (damage >= entity.MaxHealth() * config.Helicopter.Threshold && !Instance.HasPermission(attacker, "lootdefender.bypasshelilock"))
                    {
                        if (config.Helicopter.Messages.NotifyLocked == true)
                        {
                            foreach (var target in BasePlayer.activePlayerList)
                            {
                                CreateMessage(target, "Locked Heli", grid, attacker.displayName);
                            }
                        }

                        Lock(entity, attacker.userID);
                    }
                }
                else if (config.Bradley.Threshold > 0f && entity is BradleyAPC && Instance.CanLockBradley(entity))
                {
                    if (damage >= entity.MaxHealth() * config.Bradley.Threshold && !Instance.HasPermission(attacker, "lootdefender.bypassbradleylock"))
                    {
                        if (config.Bradley.Messages.NotifyLocked == true)
                        {
                            foreach (var target in BasePlayer.activePlayerList)
                            {
                                CreateMessage(target, "Locked Bradley", grid, attacker.displayName);
                            }
                        }

                        Lock(entity, attacker.userID);
                    }
                }
                else if (config.Npc.Threshold > 0f && entity is BasePlayer npc && Instance.CanLockNpc(npc))
                {
                    if (!npc.userID.IsSteamId() && damage >= entity.MaxHealth() * config.Npc.Threshold && !Instance.HasPermission(attacker, "lootdefender.bypassnpclock"))
                    {
                        if (config.Npc.Messages.NotifyLocked == true)
                        {
                            foreach (var target in BasePlayer.activePlayerList)
                            {
                                CreateMessage(target, "Locked Npc", grid, npc.displayName, attacker.displayName);
                            }
                        }
                        Lock(entity, attacker.userID);
                    }
                }
            }

            public DamageEntry TryGet(ulong id)
            {
                foreach (var x in damageKeys)
                {
                    if (x.userid == id)
                    {
                        return x.damageEntry;
                    }
                }

                return null;
            }

            public DamageEntry Get(BasePlayer attacker)
            {
                DamageEntry entry = TryGet(attacker.userID);

                if (entry == null)
                {
                    damageKeys.Add(new(attacker)
                    {
                        damageEntry = entry = new(attacker.currentTeam),
                    });
                }

                return entry;
            }

            public bool isKilled;

            public void OnKilled(Vector3 position, HitInfo hitInfo, float distance)
            {
                if (isKilled) return;
                isKilled = true;
                SetCanInteract();
                DisplayDamageReport();
                FindLooters(position, hitInfo, distance);
            }

            private void FindLooters(Vector3 position, HitInfo hitInfo, float distance)
            {
                var weapon = hitInfo?.Weapon?.GetItem()?.info?.shortname ?? hitInfo?.WeaponPrefab?.ShortPrefabName ?? "";
                HashSet<ulong> looters = new();
                HashSet<ulong> users = new();
                
                foreach (var x in damageKeys)
                {
                    if (CanInteract(x.userid, x.attacker))
                    {
                        if (TryGet(x.userid)?.DamageDealt > 0)
                        {
                            users.Add(x.userid);
                        }
                        looters.Add(x.userid);
                    }
                }

                foreach (var userid in users)
                {
                    Instance.GiveXpReward(_entity, this, userid, weapon, distance, users.Count);
                    Instance.GiveRustReward(_entity, this, userid, weapon, users.Count);
                    Instance.GiveShopReward(_entity, this, userid, weapon, distance, users.Count);
                }

                if (damageEntryType == DamageEntryType.Bradley || damageEntryType == DamageEntryType.Heli)
                {
                    Instance.LockoutLooters(looters, position, damageEntryType, SkinID);
                }
            }

            public void DisplayDamageReport()
            {
                if (damageEntryType == DamageEntryType.Bradley || damageEntryType == DamageEntryType.Heli)
                {
                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        if (CanDisplayReport(target))
                        {
                            Message(target, GetDamageReport(target.userID));
                        }
                    }
                }
                else if (damageEntryType == DamageEntryType.NPC)
                {
                    foreach (var x in damageKeys)
                    {
                        if (CanDisplayReport(x.attacker))
                        {
                            Message(x.attacker, GetDamageReport(x.userid));
                        }
                    }
                }
            }

            private bool CanDisplayReport(BasePlayer target)
            {
                if (target == null || !target.IsConnected || damageEntryType == DamageEntryType.None)
                {
                    return false;
                }

                if (damageEntryType == DamageEntryType.Bradley)
                {
                    if (config.Bradley.Messages.NotifyKiller && IsParticipant(target.userID, target))
                    {
                        return true;
                    }

                    return config.Bradley.Messages.NotifyChat;
                }

                if (damageEntryType == DamageEntryType.Heli)
                {
                    if (config.Helicopter.Messages.NotifyKiller && IsParticipant(target.userID, target))
                    {
                        return true;
                    }

                    return config.Helicopter.Messages.NotifyChat;
                }

                if (damageEntryType == DamageEntryType.NPC)
                {
                    if (config.Npc.Messages.NotifyKiller && IsParticipant(target.userID, target))
                    {
                        return true;
                    }

                    return config.Npc.Messages.NotifyChat;
                }

                return false;
            }

            public void SetCanInteract()
            {
                var damageGroups = GetDamageGroups();
                var topDamageGroups = GetTopDamageGroups(damageGroups, damageEntryType);
                if (damageGroups.Count > 0)
                {
                    foreach (var damageGroup in damageGroups)
                    {
                        if (topDamageGroups.Contains(damageGroup) || Instance.IsAlly(OwnerID, damageGroup.FirstDamagerDealer.userid))
                        {
                            interact[damageGroup.FirstDamagerDealer.userid] = damageGroup.FirstDamagerDealer.attacker;
                        }
                        else
                        {
                            var damage = TryGet(damageGroup.FirstDamagerDealer.userid)?.DamageDealt ?? 0f;
                            var dmgRatio = damage > 0 && FullDamage > 0 ? damage / FullDamage : 0;
                            float threshold = config.Npc.Threshold;
                            if (damageEntryType == DamageEntryType.Bradley)
                            {
                                threshold = config.Bradley.Threshold;
                            }
                            else if (damageEntryType == DamageEntryType.Heli)
                            {
                                threshold = config.Helicopter.Threshold;
                            }
                            if (OwnerID == 0 && dmgRatio >= threshold)
                            {
                                OwnerID = damageGroup.FirstDamagerDealer.userid;
                                interact[damageGroup.FirstDamagerDealer.userid] = damageGroup.FirstDamagerDealer.attacker;
                            }
                            else
                            {
                                participants.Add(damageGroup.FirstDamagerDealer.userid);
                            }
                        }
                    }
                }
                this.damageGroups = damageGroups;
            }

            public string GetDamageReport(ulong targetId)
            {
                var userid = targetId.ToString();
                var nameKey = damageEntryType == DamageEntryType.Bradley ? _("BradleyAPC", userid) : damageEntryType == DamageEntryType.Heli ? _("Helicopter", userid) : NPCName;
                var firstDamageDealer = string.Empty;

                sb.Length = 0;
                sb.AppendLine($"{_("DamageReport", userid, $"<color={config.Report.Ok}>{nameKey}</color>")}:");

                if (damageEntryType == DamageEntryType.Bradley || damageEntryType == DamageEntryType.Heli)
                {
                    var seconds = Math.Ceiling((DateTime.Now - start).TotalSeconds);

                    sb.AppendLine($"{_("DamageTime", userid, nameKey, seconds)}");
                }

                if (damageGroups.Count > 0)
                {
                    foreach (var damageGroup in damageGroups)
                    {
                        if (interact.ContainsKey(damageGroup.FirstDamagerDealer.userid))
                        {
                            sb.Append($"<color={config.Report.Ok}>√</color> ");
                            firstDamageDealer = damageGroup.FirstDamagerDealer.name;
                        }
                        else
                        {
                            sb.Append($"<color={config.Report.NotOk}>X</color> ");
                        }

                        sb.Append($"{damageGroup.ToReport(damageGroup.FirstDamagerDealer, this)}\n");
                    }

                    if (damageEntryType == DamageEntryType.NPC && !string.IsNullOrEmpty(firstDamageDealer) && damageGroups.Count > 1)
                    {
                        sb.Append($" {_("FirstLock", userid, firstDamageDealer, config.Npc.Threshold * 100f)}");
                    }
                }

                return sb.ToString();
            }

            public bool IsParticipant(ulong userid, BasePlayer player)
            {
                return participants.Contains(userid) || CanInteract(userid, player);
            }

            public bool CanInteract(ulong userid, BasePlayer player)
            {
                if (damageEntryType == DamageEntryType.NPC && !config.Npc.Enabled)
                {
                    return true;
                }

                if (damageGroups == null)
                {
                    interact.Clear();
                    participants.Clear();
                    SetCanInteract();
                }

                if (interact.Count == 0 || interact.ContainsKey(userid))
                {
                    return true;
                }

                if (Instance.IsAlly(userid, OwnerID))
                {
                    interact.Add(userid, player);
                    return true;
                }

                return false;
            }

            private List<DamageGroup> GetTopDamageGroups(List<DamageGroup> damageGroups, DamageEntryType damageEntryType)
            {
                List<DamageGroup> topDamageGroups = new();

                if (damageGroups.Count == 0)
                {
                    return topDamageGroups;
                }

                var topDamageGroup = damageGroups.OrderByDescending(x => x.TotalDamage).First();

                foreach (var damageGroup in damageGroups)
                {
                    foreach (var playerId in damageGroup.Players)
                    {
                        if (Instance.IsAlly(playerId, OwnerID))
                        {
                            topDamageGroups.Add(damageGroup);
                            break;
                        }
                    }
                }

                return topDamageGroups;
            }

            private List<DamageGroup> GetDamageGroups()
            {
                List<DamageGroup> damageGroups = new();

                foreach (var x in damageKeys)
                {
                    damageGroups.Add(new(x));
                }

                damageGroups.Sort((x, y) => y.TotalDamage.CompareTo(x.TotalDamage));

                return damageGroups;
            }
        }

        private class LockInfo
        {
            public DamageInfo damageInfo { get; set; }

            private DateTime LockTimestamp { get; set; }

            private int LockTimeout { get; set; }

            internal bool IsLockOutdated => LockTimeout > 0 && DateTime.Now.Subtract(LockTimestamp).TotalSeconds >= LockTimeout;

            public LockInfo() { }

            public LockInfo(DamageInfo damageInfo, int lockTimeout)
            {
                LockTimestamp = DateTime.Now;
                LockTimeout = lockTimeout;
                this.damageInfo = damageInfo;
            }

            public bool CanInteract(ulong userId, BasePlayer target) => damageInfo.CanInteract(userId, target);

            public string GetDamageReport(ulong userId) => damageInfo.GetDamageReport(userId);
        }

        private class DamageGroup
        {
            public float TotalDamage { get; set; }

            public DamageKey FirstDamagerDealer { get; set; }

            private List<ulong> additionalPlayers { get; set; } = new();

            [JsonIgnore]
            public List<ulong> Players
            {
                get
                {
                    List<ulong> players = new()
                    {
                        FirstDamagerDealer.userid
                    };

                    foreach (var targetId in additionalPlayers)
                    {
                        if (!players.Contains(targetId))
                        {
                            players.Add(targetId);
                        }
                    }

                    return players;
                }
            }

            public DamageGroup() { }

            public DamageGroup(DamageKey x)
            {
                TotalDamage = x.damageEntry.DamageDealt;
                FirstDamagerDealer = x;

                if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(x.userid, out var team))
                {
                    for (int i = 0; i < team.members.Count; i++)
                    {
                        ulong member = team.members[i];

                        if (member == x.userid || additionalPlayers.Contains(member))
                        {
                            continue;
                        }

                        additionalPlayers.Add(member);
                    }
                }

                // add clan
            }

            public string ToReport(DamageKey damageKey, DamageInfo damageInfo)
            {
                var damage = damageInfo.TryGet(damageKey.userid)?.DamageDealt ?? 0f;
                var percent = damage > 0 && damageInfo.FullDamage > 0 ? damage / damageInfo.FullDamage * 100 : 0;
                var color = additionalPlayers.Count == 0 ? config.Report.SinglePlayer : config.Report.Team;
                var damageLine = _("Format", damageKey.userid.ToString(), damage, percent);

                return $"<color={color}>{damageKey.name}</color> {damageLine}";
            }
        }

        #region Hooks

        private void OnServerSave()
        {
            timer.Once(15f, SaveData);
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEventTrigger));
            Unsubscribe();
            Instance = this;
            sb = new();
            if (!string.IsNullOrEmpty(config.Lockout.Command)) 
                AddCovalenceCommand(config.Lockout.Command, nameof(CommandLockouts));
            if (!string.IsNullOrEmpty(config.UI.Command)) 
                AddCovalenceCommand(config.UI.Command, nameof(CommandUI));
            AddCovalenceCommand("lo", nameof(CommandLootDefender));
            RegisterPermissions();
            LoadData();
        }

        private void OnServerInitialized(bool serverinit)
        {
            if (config.Hackable.Enabled)
            {
                Subscribe(nameof(CanHackCrate));
                Subscribe(nameof(OnGuardedCrateEventEnded));
            }

            if (config.SupplyDrop.Lock)
            {
                if (config.SupplyDrop.LockTime > 0)
                {
                    if (config.SupplyDrop.NpcRandomRaids)
                    {
                        Subscribe(nameof(OnRandomRaidWin));
                    }
                    Subscribe(nameof(OnSupplyDropLanded));
                }

                if (config.SupplyDrop.Excavator)
                {
                    Subscribe(nameof(OnExcavatorSuppliesRequested));
                }

                if (config.SupplyDrop.HelpfulSupply && HelpfulSupply != null)
                {
                    Subscribe(nameof(OnEntitySpawned));
                }

                Subscribe(nameof(OnExplosiveDropped));
                Subscribe(nameof(OnExplosiveThrown));
                Subscribe(nameof(OnSupplyDropDropped));
                Subscribe(nameof(OnCargoPlaneSignaled));
            }

            if (config.SupplyDrop.DestroyTime > 0f || config.CH47Gibs)
            {
                Subscribe(nameof(OnEntitySpawned));
            }

            if (config.Npc.BossMonster)
            {
                Unsubscribe(nameof(OnBossSpawn));
                Unsubscribe(nameof(OnBossKilled));
            }

            if (!config.Bradley.LockPersonal)
            {
                Subscribe(nameof(OnPersonalApcSpawned));
            }

            if (!config.Helicopter.LockPersonal)
            {
                Subscribe(nameof(OnPersonalHeliSpawned));
            }

            if (config.UI.Bradley.Enabled || config.UI.Heli.Enabled)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    UI.ShowLockouts(player);
                }

                Subscribe(nameof(OnPlayerSleepEnded));
            }

            if (config.Bradley.Threshold != 0f || config.Helicopter.Threshold != 0f || config.Hackable.Laptop)
            {
                Subscribe(nameof(OnPlayerAttack));
            }

            if (!config.SupplyDrop.Skins.Contains(0uL))
            {
                config.SupplyDrop.Skins.Add(0uL);
            }

            if (config.Lockout.F15)
            {
                Subscribe(nameof(OnEventTrigger));
            }
            
            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(OnEntityKill));
            Subscribe(nameof(CanLootEntity));
            Subscribe(nameof(CanBradleyTakeDamage));
            SetupLaunchSite();
        }

        private bool IsF15EventActive;

        private void OnEventTrigger(TriggeredEventPrefab prefab)
        {
            if (config.Lockout.F15 && !IsF15EventActive && prefab.name == "assets/bundled/prefabs/world/event_f15e.prefab")
            {
                Puts("F15 event has started; bypassing player lockouts!");
                IsF15EventActive = true;
            }
        }

        private void Unload()
        {
            UI.DestroyAllLockoutUI();
            SaveData();
            Instance = null;
            data = null;
            sb = null;
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            UI.DestroyLockoutUI(player);
            UI.ShowLockouts(player);
        }

        private object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player) => HandleTeam(team, player.userID);

        private object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong targetId) => HandleTeam(team, targetId);

        private object OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (attacker == null || HasPermission(attacker, bypassDamagePerm) || hitInfo == null)
            {
                return null;
            }

            if (config.Hackable.Laptop && hitInfo.HitBone == 242862488 && hitInfo.HitEntity is HackableLockedCrate crate && IsDefended(crate)) // laptopcollision
            {
                hitInfo.HitBone = 0;
                return null;
            }

            if (config.Bradley.Threshold != 0f || config.Helicopter.Threshold != 0f)
            {
                if (hitInfo.HitEntity is ServerGib gibs && gibs.IsValid() && data.Lock.TryGetValue(gibs.net.ID.Value, out var lockInfo))
                {
                    if (gibs.OwnerID != 0 && !lockInfo.IsLockOutdated)
                    {
                        if (!lockInfo.CanInteract(attacker.userID, attacker))
                        {
                            if (CanMessage(attacker))
                            {
                                CreateMessage(attacker, "CannotMine");
                                Message(attacker, lockInfo.GetDamageReport(attacker.userID));
                            }

                            CancelDamage(hitInfo);
                            return false;
                        }
                    }
                    else
                    {
                        data.Lock.Remove(gibs.net.ID.Value);
                        gibs.OwnerID = 0;
                    }
                }
            }

            return null;
        }

        private object OnEntityTakeDamage(PatrolHelicopter heli, HitInfo hitInfo)
        {
            if (config.Helicopter.Threshold == 0f || !heli.IsValid() || _personal.Contains(heli.net.ID.Value) || hitInfo == null || heli.myAI == null || heli.myAI.isDead || CanHeliTakeDamage(heli, hitInfo) != null)
            {
                return null;
            }

            return OnEntityTakeDamageHandler(heli, hitInfo, DamageEntryType.Heli, string.Empty);
        }

        private object OnEntityTakeDamage(BradleyAPC apc, HitInfo hitInfo)
        {
            if (config.Bradley.Threshold == 0f || !apc.IsValid() || hitInfo == null || CanBradleyTakeDamage(apc, hitInfo) != null)
            {
                return null;
            }

            return OnEntityTakeDamageHandler(apc, hitInfo, DamageEntryType.Bradley, string.Empty);
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (!config.Npc.Enabled || !player.IsValid() || player.userID.IsSteamId() || hitInfo == null)
            {
                return null;
            }

            if (config.Npc.Min > 0 && player.startHealth < config.Npc.Min)
            {
                return null;
            }

            return OnEntityTakeDamageHandler(player, hitInfo, DamageEntryType.NPC, player.displayName);
        }

        private object OnEntityTakeDamageHandler(BaseCombatEntity entity, HitInfo hitInfo, DamageEntryType damageEntryType, string npcName)
        {
            if (!config.Bradley.LockConvoy && entity.skinID == 755446 && entity is BradleyAPC)
            {
                return null;
            }

            if (!config.Helicopter.LockConvoy && entity.skinID == 755446 && entity is PatrolHelicopter)
            {
                return null;
            }

            if (!(hitInfo.Initiator is BasePlayer attacker) || !attacker.userID.IsSteamId())
            {
                return null;
            }

            if (_locked.TryGetValue(entity.net.ID.Value, out var ownerId) && !HasPermission(attacker, bypassDamagePerm) && !IsAlly(attacker.userID, ownerId))
            {
                if (!BlockDamage(damageEntryType))
                {
                    return null;
                }

                if (CanMessage(attacker))
                {
                    CreateMessage(attacker, "CannotDamageThis");
                }

                CancelDamage(hitInfo);
                return true;
            }

            if (!data.Damage.TryGetValue(entity.net.ID.Value, out var damageInfo))
            {
                data.Damage[entity.net.ID.Value] = damageInfo = new(damageEntryType, npcName, entity, DateTime.Now);
            }

            DamageEntry entry = damageInfo.Get(attacker);

            float total = hitInfo.damageTypes.Total();

            if (hitInfo.isHeadshot) total *= 2f;

            damageInfo.AddDamage(entity, attacker, entry, total);

            if (damageEntryType == DamageEntryType.Heli)
            {
                float prevHealth = entity.health;

                NextTick(() =>
                {
                    if (entity == null)
                    {
                        return;
                    }

                    damageInfo.AddDamage(entity, attacker, entry, Mathf.Abs(prevHealth - entity.health));
                });
            }

            return null;
        }

        public static bool IsKilled(BaseNetworkable a) => a == null || a.IsDestroyed || !a.isSpawned;

        private bool BlockDamage(DamageEntryType damageEntryType)
        {
            if (damageEntryType == DamageEntryType.NPC && config.Npc.LootingOnly)
            {
                return false;
            }
            else if (damageEntryType == DamageEntryType.Heli && config.Helicopter.LootingOnly)
            {
                return false;
            }
            else if (damageEntryType == DamageEntryType.Bradley && config.Bradley.LootingOnly)
            {
                return false;
            }

            return true;
        }

        private object CanBradleyTakeDamage(BradleyAPC apc, HitInfo hitInfo)
        {
            if (config.Lockout.Bradley <= 0 || !apc.IsValid() || !(hitInfo.Initiator is BasePlayer attacker))
            {
                return null;
            }

            if (HasLockout(attacker, DamageEntryType.Bradley, apc.skinID))
            {
                CancelDamage(hitInfo);
                return false;
            }

            if (!data.Lockouts.ContainsKey(attacker.UserIDString))
            {
                if (!_apcAttackers.TryGetValue(apc.net.ID.Value, out var attackers))
                {
                    _apcAttackers[apc.net.ID.Value] = attackers = new();
                }

                if (!attackers.Exists(x => x.userid == attacker.userID))
                {
                    attackers.Add(new(attacker));
                }
            }

            return null;
        }

        private object CanHeliTakeDamage(PatrolHelicopter heli, HitInfo hitInfo)
        {
            if (config.Lockout.Heli <= 0 || !heli.IsValid() || !(hitInfo.Initiator is BasePlayer attacker))
            {
                return null;
            }

            if (HasLockout(attacker, DamageEntryType.Heli, heli.skinID))
            {
                CancelDamage(hitInfo);
                return false;
            }

            if (!data.Lockouts.ContainsKey(attacker.UserIDString))
            {
                if (!_heliAttackers.TryGetValue(heli.net.ID.Value, out var attackers))
                {
                    _heliAttackers[heli.net.ID.Value] = attackers = new();
                }

                if (!attackers.Exists(x => x.userid == attacker.userID))
                {
                    attackers.Add(new(attacker));
                }
            }

            return null;
        }

        private void OnEntityDeath(PatrolHelicopter heli, HitInfo hitInfo)
        {
            if (!heli.IsValid())
            {
                return;
            }

            _personal.Remove(heli.net.ID.Value);
            _heliAttackers.Remove(heli.net.ID.Value);

            OnEntityDeathHandler(heli, DamageEntryType.Heli, hitInfo);
        }

        private void OnEntityKill(PatrolHelicopter heli) => OnEntityDeath(heli, null);

        private void OnEntityDeath(BradleyAPC apc, HitInfo hitInfo)
        {
            if (!apc.IsValid())
            {
                return;
            }

            _apcAttackers.Remove(apc.net.ID.Value);

            OnEntityDeathHandler(apc, DamageEntryType.Bradley, hitInfo);
        }

        private void OnEntityDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (!config.Npc.Enabled || !player.IsValid() || player.userID.IsSteamId())
            {
                return;
            }

            OnEntityDeathHandler(player, DamageEntryType.NPC, hitInfo);
        }

        private void OnEntityDeath(NPCPlayerCorpse corpse, HitInfo hitInfo)
        {
            if (!config.Npc.Enabled || !corpse.IsValid())
            {
                return;
            }

            OnEntityDeathHandler(corpse, DamageEntryType.Corpse, hitInfo);
        }

        private void OnEntityKill(NPCPlayerCorpse corpse) => OnEntityDeath(corpse, null);

        private bool IsInBounds(MonumentInfo monument, Vector3 target)
        {
            return monument.IsInBounds(target) || new OBB(monument.transform.position, monument.transform.rotation, new Bounds(monument.Bounds.center, new Vector3(300f, 300f, 300f))).Contains(target);
        }

        private bool CanLockBradley(BaseEntity entity)
        {
            if (config.Bradley.Threshold <= 0f || _personal.Contains(entity.net.ID.Value))
            {
                return false;
            }

            if (BradleyDrops && BradleyDrops.CallHook("IsBradleyDrop", entity.skinID) != null)
            {
                return false;
            }

            if (entity.name.Contains($"BradleyApc[{entity.net.ID}]"))
            {
                return config.Bradley.LockBradleyTiers;
            }

            if (entity.skinID != 0)
            {
                if (entity.skinID == 755446)
                {
                    return config.Bradley.LockConvoy;
                }
                if (entity.skinID == 81182151852251420)
                {
                    return config.Bradley.LockHarbor;
                }
                if (entity.skinID == 8675309)
                {
                    return config.Bradley.LockMonument;
                }
                return false;
            }

            if (launchSite != null && IsInBounds(launchSite, entity.ServerPosition))
            {
                return config.Bradley.LockLaunchSite;
            }

            if (harbors.Exists(mi => IsInBounds(mi, entity.ServerPosition)))
            {
                return config.Bradley.LockHarbor;
            }

            return config.Bradley.LockWorldly;
        }

        private bool CanLockHeli(BaseCombatEntity entity)
        {
            if (HeliSignals && HeliSignals.CallHook("IsHeliSignalObject", entity.skinID) != null)
            {
                return false;
            }
            if (entity.skinID != 0)
            {
                if (entity.skinID == 755446)
                {
                    return config.Helicopter.LockConvoy;
                }
                if (entity.skinID == 81182151852251420)
                {
                    return config.Helicopter.LockHarbor == true;
                }
                return false;
            }
            return config.Helicopter.Threshold > 0f;
        }

        private bool CanLockNpc(BaseEntity entity)
        {
            if (entity.OwnerID.ToString().Length == 5)
            {
                return false;
            }
            return config.Npc.Threshold > 0f && !_boss.Contains(entity.net.ID.Value);
        }

        private void OnEntityDeathHandler(BaseCombatEntity entity, DamageEntryType damageEntryType, HitInfo hitInfo)
        {
            if (data.Damage.TryGetValue(entity.net.ID.Value, out var damageInfo) && !damageInfo.isKilled)
            {
                if (damageEntryType == DamageEntryType.Bradley && !CanLockBradley(entity)) return;
                if (damageEntryType == DamageEntryType.Heli && !CanLockHeli(entity)) return;
                if (damageEntryType == DamageEntryType.NPC && !CanLockNpc(entity)) return;

                if (damageEntryType == DamageEntryType.Bradley || damageEntryType == DamageEntryType.Heli)
                {
                    var lockInfo = new LockInfo(damageInfo, damageEntryType == DamageEntryType.Heli ? config.Helicopter.LockTime : config.Bradley.LockTime);
                    var position = entity.transform.position;

                    if (entity is PatrolHelicopter && (position - Vector3.zero).magnitude > World.Size / 1.25f)
                    {
                        return;
                    }
                    
                    damageInfo.OnKilled(position, hitInfo, hitInfo?.ProjectileDistance ?? Vector3.Distance(position, damageInfo.lastAttackedPosition));

                    timer.Once(0.1f, () =>
                    {
                        LockInRadius<LockedByEntCrate>(position, lockInfo, damageEntryType);
                        LockInRadius<HelicopterDebris>(position, lockInfo, damageEntryType);
                        RemoveFireFromCrates(position, damageEntryType);
                    });

                    damageInfo.DestroyTimer();
                }
                else if (damageEntryType == DamageEntryType.NPC && config.Npc.Enabled && entity is BasePlayer npc)
                {
                    var position = entity.transform.position;
                    var npcId = npc.userID;
                    var damageKey = npc.net.ID.Value;

                    damageInfo.OnKilled(position, hitInfo, hitInfo?.ProjectileDistance ?? Vector3.Distance(position, damageInfo.lastAttackedPosition));
                    damageInfo.DestroyTimer();

                    timer.Once(0.1f, () => LockInRadius(position, damageKey, damageInfo, npcId));
                }
                else if (damageEntryType == DamageEntryType.NPC && config.Npc.Enabled && entity is LootableCorpse corpse)
                {
                    var position = entity.transform.position;
                    var npcId = corpse.playerSteamID;
                    var damageKey = corpse.net.ID.Value;

                    damageInfo.OnKilled(position, hitInfo, hitInfo?.ProjectileDistance ?? Vector3.Distance(position, damageInfo.lastAttackedPosition));
                    damageInfo.DestroyTimer();

                    timer.Once(0.1f, () => LockInRadius(position, damageKey, damageInfo, npcId));
                }
            }

            if (data.Lock.Remove(entity.net.ID.Value, out var lockInfo2) && damageEntryType == DamageEntryType.Corpse && config.Npc.Enabled && entity is LootableCorpse corpse2)
            {
                var corpsePos = corpse2.transform.position;
                var corpseId = corpse2.playerSteamID;

                timer.Once(0.1f, () => LockInRadius(corpsePos, lockInfo2, corpseId));
            }
        }

        //void OnEntitySpawned(DroppedItemContainer container)
        //{
        //    if (!config.Npc.Enabled || !container.IsValid() || container.playerSteamID.IsSteamId() || data.Lock.ContainsKey(container.net.ID.Value))
        //    {
        //        return;
        //    }
        //    foreach (var damageInfo in data.Damage.Values)
        //    {
        //        if (damageInfo.damageEntryType == DamageEntryType.NPC && container.Distance(damageInfo._position) <= 3f)
        //        {
        //            if (config.Npc.LockTime > 0f)
        //            {
        //                var uid = container.net.ID.Value;

        //                timer.Once(config.Npc.LockTime, () => data.Lock.Remove(uid));
        //                container.Invoke(() => container.OwnerID = 0, config.Npc.LockTime);
        //            }

        //            ulong ownerid = damageInfo.OwnerID;
        //            container.OwnerID = ownerid;
        //            container.Invoke(() => container.OwnerID = ownerid, 1f);
        //            data.Lock[container.net.ID.Value] = new(damageInfo, config.Npc.LockTime);
        //        }
        //    }
        //}

        void GiveRustReward(BaseEntity entity, DamageInfo damageInfo, ulong userid, string weapon, int total)
        {
            if (RustRewards == null)
            {
                return;
            }

            BasePlayer attacker = BasePlayer.FindByID(userid);

            if (attacker == null || !attacker.userID.IsSteamId())
            {
                return;
            }

            var amount = damageInfo.damageEntryType == DamageEntryType.Bradley ? config.Bradley.RRP : damageInfo.damageEntryType == DamageEntryType.Heli ? config.Helicopter.RRP : config.Npc.RRP;

            if (amount <= 0.0)
            {
                return;
            }

            var distance = Vector3.Distance(attacker.transform.position, entity.transform.position);
            
            ApplyWeaponMultiplierReward(damageInfo, weapon, ref amount, distance);

            if (amount <= 0) return;

            RustRewards?.Call("GiveRustReward", attacker, 0, amount, entity, weapon, distance, entity.ShortPrefabName);
        }

        void GiveXpReward(BaseEntity entity, DamageInfo damageInfo, ulong userid, string weapon, float distance, int total)
        {
            var amount = damageInfo.damageEntryType == DamageEntryType.Bradley ? config.Bradley.XP : damageInfo.damageEntryType == DamageEntryType.Heli ? config.Helicopter.XP : config.Npc.XP;

            if (amount <= 0.0 || !userid.IsSteamId())
            {
                return;
            }

            var attacker = BasePlayer.FindByID(userid);

            ApplyWeaponMultiplierReward(damageInfo, weapon, ref amount, distance);

            if (amount <= 0) return;

            if (SkillTree != null)
            {
                if (attacker) SkillTree?.Call("AwardXP", attacker, amount, Name);
                else SkillTree?.Call("AwardXP", userid, amount, Name);
            }

            if (XPerience != null)
            {
                XPerience?.Call("GiveXPID", userid, amount);
            }

            if (XLevels != null && attacker != null)
            {
                XLevels?.Call("API_GiveXP", attacker, (float)amount);
            }
        }

        void GiveShopReward(BaseEntity entity, DamageInfo damageInfo, ulong userid, string weapon, float distance, int total)
        {
            if (ShoppyStock == null)
            {
                return;
            }

            var amount = damageInfo.damageEntryType == DamageEntryType.Bradley ? config.Bradley.SS : damageInfo.damageEntryType == DamageEntryType.Heli ? config.Helicopter.SS : config.Npc.SS;

            if (amount <= 0.0)
            {
                return;
            }

            var storeName = damageInfo.damageEntryType == DamageEntryType.Bradley ? config.Bradley.ShoppyStockShopName : damageInfo.damageEntryType == DamageEntryType.Heli ? config.Helicopter.ShoppyStockShopName : config.Npc.ShoppyStockShopName;

            if (string.IsNullOrEmpty(storeName))
            {
                return;
            }

            ApplyWeaponMultiplierReward(damageInfo, weapon, ref amount, distance);

            if (amount <= 0) return;

            amount /= total;
            amount = Math.Round(amount, 0);

            ShoppyStock?.Call("GiveCurrency", storeName, userid, Mathf.Max(1, (int)amount));

            if (!(BasePlayer.FindByID(userid) is BasePlayer attacker) || !attacker.IsConnected)
                return;

            CreateMessage(attacker, "ShoppyStockReward", amount, storeName);
        }

        private static void ApplyWeaponMultiplierReward(DamageInfo damageInfo, string weapon, ref double amount, float distance)
        {
            if (damageInfo.damageEntryType == DamageEntryType.NPC)
            {
                if (distance > 400) distance = 401;
                var distanceMulti = config.Npc.Distance.GetDistanceMult(distance);
                amount = Math.Round(distanceMulti * amount, 0);
                if (config.Npc.WeaponMultipliers.TryGetValue(weapon, out double weaponMulti))
                {
                    amount = Math.Round(weaponMulti * amount, 0);
                    if (amount < 1) amount = 1;
                }
            }
        }

        private object OnAutoPickupEntity(BasePlayer player, BaseEntity entity) => CanLootEntityHandler(player, entity);

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container) => CanLootEntityHandler(player, container);

        private object CanLootEntity(BasePlayer player, LootableCorpse corpse) => CanLootEntityHandler(player, corpse);

        private object CanLootEntity(BasePlayer player, StorageContainer container) => CanLootEntityHandler(player, container);

        private object CanLootEntityHandler(BasePlayer player, BaseEntity entity)
        {
            if (!entity.IsValid())
            {
                return null;
            }

            if (HasPermission(player, bypassLootPerm))
            {
                return null;
            }

            if (entity.OwnerID == 0)
            {
                return null;
            }

            if (ownerids.Contains(entity.OwnerID))
            {
                return null;
            }

            if (entity is SupplyDrop && entity.skinID == supplyDropSkinID || config.Hackable.Enabled && entity is HackableLockedCrate crate && IsDefended(crate))
            {
                if (Convert.ToBoolean(Interface.CallHook("OnLootLockedEntity", player, entity)))
                {
                    return null;
                }

                if (!IsAlly(player.userID, entity.OwnerID))
                {
                    if (CanMessage(player))
                    {
                        CreateMessage(player, entity is SupplyDrop ? "CannotLootIt" : "CannotLootCrate");
                    }

                    return true;
                }

                return null;
            }

            if (!data.Lock.TryGetValue(entity.net.ID.Value, out var lockInfo))
            {
                return null;
            }

            if (entity.OwnerID == 0 || lockInfo.IsLockOutdated)
            {
                data.Lock.Remove(entity.net.ID.Value);
                entity.OwnerID = 0;
                return null;
            }

            if (!lockInfo.CanInteract(player.userID, player) && Interface.CallHook("OnLootLockedEntity", player, entity) == null)
            {
                if (CanMessage(player))
                {
                    CreateMessage(player, "CannotLoot");
                    Message(player, lockInfo.GetDamageReport(player.userID));
                }

                return true;
            }

            return null;
        }

        private void OnBossSpawn(ScientistNPC boss)
        {
            if (boss.IsValid())
            {
                _boss.Add(boss.net.ID.Value);
            }
        }

        private void OnBossKilled(ScientistNPC boss, BasePlayer attacker)
        {
            if (boss.IsValid())
            {
                _boss.Remove(boss.net.ID.Value);
            }
        }

        private void OnPersonalHeliSpawned(BasePlayer player, PatrolHelicopter heli)
        {
            if (heli.IsValid())
            {
                _personal.Add(heli.net.ID.Value);
            }
        }

        private void OnPersonalApcSpawned(BasePlayer player, BradleyAPC apc)
        {
            if (apc.IsValid())
            {
                _personal.Add(apc.net.ID.Value);
            }
        }

        private void OnEntitySpawned(CH47Helicopter heli)
        {
            if (!config.CH47Gibs || heli == null) return;
            heli.serverGibs.guid = string.Empty;
        }

        #region SupplyDrops

        private void OnExplosiveDropped(BasePlayer player, SupplySignal ss, ThrownWeapon tw) => OnExplosiveThrown(player, ss, tw);

        private void OnExplosiveThrown(BasePlayer player, SupplySignal ss, ThrownWeapon tw)
        {
            if (player == null || ss == null || !config.SupplyDrop.Skins.Contains(tw.skinID))
            {
                return;
            }

            if (tw.GetItem() is Item item && !config.SupplyDrop.Skins.Contains(item.skin))
            {
                return;
            }

            ss.OwnerID = player.userID;
            ss.skinID = supplyDropSkinID;

            if (config.SupplyDrop.Bypass)
            {
                var userid = player.userID;
                var position = ss.transform.position;
                var resourcePath = ss.EntityToCreate.resourcePath;

                ss.CancelInvoke(ss.Explode);
                ss.Invoke(() => Explode(ss, userid, position, resourcePath, player), 3f);
            }

            if (config.SupplyDrop.NotifyChat && !thrown.Contains(player.userID))
            {
                if (config.SupplyDrop.NotifyCooldown > 0)
                {
                    var userid = player.userID;
                    thrown.Add(userid);
                    timer.In(config.SupplyDrop.NotifyCooldown, () => thrown.Remove(userid));
                }
                foreach (var target in BasePlayer.activePlayerList)
                {
                    if (config.SupplyDrop.ThrownAt)
                    {
                        CreateMessage(target, "ThrownSupplySignalAt", player.displayName, PositionToGrid(player.transform.position));
                    }
                    else CreateMessage(target, "ThrownSupplySignal", player.displayName);
                }
            }

            if (config.SupplyDrop.NotifyConsole)
            {
                Puts(_("ThrownSupplySignalAt", null, player.displayName, PositionToGrid(player.transform.position)));
            }

            Interface.CallHook("OnModifiedSupplySignal", player, ss, tw);
        }

        private List<ulong> crateLock = new();
        private List<ulong> thrown = new();

        private void Explode(SupplySignal ss, ulong userid, Vector3 position, string resourcePath, BasePlayer player)
        {
            if (!ss.IsDestroyed)
            {
                var smokeDuration = config.SupplyDrop.Smoke > -1 ? config.SupplyDrop.Smoke : 4.5f;
                position = ss.transform.position;
                if (smokeDuration > 0f)
                {
                    ss.Invoke(ss.FinishUp, smokeDuration);
                    ss.SetFlag(BaseEntity.Flags.On, true, false, true);
                    ss.SendNetworkUpdateImmediate(false);
                }
                else ss.FinishUp();
            }

            if (GameManager.server.CreateEntity(StringPool.Get(3632568684), position) is SupplyDrop drop)
            {
                drop.OwnerID = userid;
                drop.skinID = supplyDropSkinID;
                drop.Spawn();
                drop.Invoke(() => drop.OwnerID = userid, 1f);

                if (config.SupplyDrop.LockTime > 0)
                {
                    OnSupplyDropLanded(drop);
                }
                else DelayedDestroySupplyDrop(drop);
            }
        }

        private void DelayedDestroySupplyDrop(SupplyDrop drop)
        {
            if (config.SupplyDrop.DestroyTime > 0f)
            {
                drop.Invoke(() =>
                {
                    if (!drop.IsDestroyed)
                    {
                        drop.Kill();
                    }
                }, config.SupplyDrop.DestroyTime);
            }
        }

        private void OnExcavatorSuppliesRequested(ExcavatorSignalComputer computer, BasePlayer player, CargoPlane plane)
        {
            SetupCargoPlane(plane, computer, player.userID);

            cargoPlanes.Add(plane);
        }

        private void OnRandomRaidWin(SupplyDrop drop, List<ulong> playerID)
        {
            if (drop)
            {
                if (playerID.Count > 0 && !drop.OwnerID.IsSteamId())
                {
                    drop.OwnerID = playerID[0];
                }
                drop.skinID = supplyDropSkinID;
                OnSupplyDropLanded(drop);
            }
        }

        private void OnCargoPlaneSignaled(CargoPlane plane, SupplySignal ss)
        {
            if (ss?.skinID != supplyDropSkinID)
            {
                return;
            }
            
            SetupCargoPlane(plane, ss, ss.OwnerID);

            if (config.SupplyDrop.Smoke > -1)
            {
                if (config.SupplyDrop.Smoke < 1)
                {
                    ss.FinishUp();
                }
                else NextTick(() =>
                {
                    if (ss != null && !ss.IsDestroyed)
                    {
                        ss.CancelInvoke(ss.FinishUp);
                        ss.Invoke(ss.FinishUp, config.SupplyDrop.Smoke);
                    }
                });
            }

            cargoPlanes.Add(plane);

            Interface.CallHook("OnModifiedCargoPlaneSignaled", plane, ss);
        }

        private void SetupCargoPlane(CargoPlane plane, BaseEntity entity, ulong userid)
        {
            float y = plane.transform.position.y;
            float j = config.SupplyDrop.DistanceFromSignal;

            if (config.SupplyDrop.LowDrop) y /= Core.Random.Range(2, 4); // Change Y, fast drop

            plane.transform.position = new Vector3(plane.transform.position.x, y, plane.transform.position.z);
            plane.startPos = new Vector3(plane.startPos.x, y, plane.startPos.z);

            if (j > -1)
            {
                plane.dropPosition = entity.transform.position + new Vector3(UnityEngine.Random.Range(-j, j), 0f, UnityEngine.Random.Range(-j, j));
                plane.endPos = plane.dropPosition + (plane.endPos - plane.startPos).normalized * (plane.dropPosition - plane.startPos).magnitude;
                //Vector3 b = plane.dropPosition - plane.startPos;
                //plane.endPos = plane.dropPosition + b.normalized * b.magnitude;
                plane.endPos.y = y;
            }
            else
            {
                plane.endPos = new Vector3(plane.endPos.x, y, plane.endPos.z);
                plane.dropPosition = entity.transform.position;
            }

            plane.dropPosition.y = 0f;
            plane.secondsToTake = Vector3.Distance(plane.startPos, plane.endPos) / Mathf.Clamp(config.SupplyDrop.Speed, 40f, World.Size);
            plane.OwnerID = userid;
            plane.skinID = supplyDropSkinID;
        }

        private void OnSupplyDropDropped(SupplyDrop drop, CargoPlane plane)
        {
            if (plane?.skinID != supplyDropSkinID)
            {
                return;
            }

            if (drop.TryGetComponent(out Rigidbody rb))
            {
                rb.drag = Mathf.Clamp(config.SupplyDrop.Drag, 0.1f, 3f);
                rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
            }

            DelayedDestroySupplyDrop(drop);

            drop.OwnerID = plane.OwnerID;
            drop.skinID = supplyDropSkinID;

            Interface.CallHook("OnModifiedSupplyDropDropped", drop, plane);
        }

        private void OnSupplyDropLanded(SupplyDrop drop)
        {
            if (drop?.skinID != supplyDropSkinID)
            {
                return;
            }

            DelayedDestroySupplyDrop(drop);

            drop.Invoke(() => drop.OwnerID = 0, config.SupplyDrop.LockTime);

            Interface.CallHook("OnModifiedSupplyDropLanded", drop);
        }

        private List<CargoPlane> cargoPlanes = new();

        private void OnEntitySpawned(SupplyDrop drop)
        {
            if (drop.skinID == supplyDropSkinID)
            {
                DelayedDestroySupplyDrop(drop);
            }
            else OnHelpfulSupplyDropped(drop);
        }

        private void OnHelpfulSupplyDropped(SupplyDrop drop)
        {
            if (!config.SupplyDrop.HelpfulSupply || HelpfulSupply == null) return;
            if (drop == null || drop.IsDestroyed) return;
            if (BasePlayer.allPlayerList.Any(x => x.OwnerID == drop.OwnerID)) return;
            cargoPlanes.RemoveAll(x => x == null || x.IsDestroyed || !x.OwnerID.IsSteamId());
            if (cargoPlanes.Count == 0) return;
            cargoPlanes.Sort((x, y) => x.Distance(drop).CompareTo(y.Distance(drop)));
            drop.OwnerID = cargoPlanes[0].OwnerID;
            drop.skinID = cargoPlanes[0].skinID;
            DelayedDestroySupplyDrop(drop);
        }

        #endregion SupplyDrops

        private void OnGuardedCrateEventEnded(BasePlayer player, HackableLockedCrate crate)
        {
            NextTick(() =>
            {
                if (crate != null && crate.OwnerID == 0 && CanLockHackableCrate(player, crate))
                {
                    crate.OwnerID = player.userID;

                    SetupHackableCrate(player, crate);
                }
            });
        }

        private bool CanLockHackableCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (!config.Hackable.Harbor && harbors.Exists(mi => IsInBounds(mi, crate.ServerPosition)))
            {
                return false;
            }
            return Interface.CallHook("OnLootLockedEntity", player, crate) == null;
        }

        private void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (CanLockHackableCrate(player, crate))
            {
                crate.OwnerID = player.userID;

                SetupHackableCrate(player, crate);
            }
        }

        #endregion Hooks

        #region Helpers

        private void SetupLaunchSite()
        {
            if (TerrainMeta.Path == null || TerrainMeta.Path.Monuments == null || TerrainMeta.Path.Monuments.Count == 0)
            {
                timer.Once(10f, SetupLaunchSite);
                return;
            }

            foreach (var mi in TerrainMeta.Path.Monuments)
            {
                if (mi.name.Contains("harbor_1") || mi.name.Contains("harbor_2")) harbors.Add(mi);
                else if (mi.name.Contains("launch_site", CompareOptions.OrdinalIgnoreCase)) launchSite = mi;
            }
        }

        private void SetupHackableCrate(BasePlayer owner, HackableLockedCrate crate)
        {
            float hackSeconds = 0f;

            if (config.Hackable.Seconds && config.Hackable.Permissions.Count > 0)
            {
                foreach (var entry in config.Hackable.Permissions)
                {
                    if (permission.UserHasPermission(owner.UserIDString, entry.Permission))
                    {
                        if (entry.Value < HackableLockedCrate.requiredHackSeconds - hackSeconds)
                        {
                            hackSeconds = HackableLockedCrate.requiredHackSeconds - entry.Value;
                        }
                    }
                }

                crate.hackSeconds = hackSeconds;
            }

            var val = crate.net.ID.Value;
            var userid = owner.userID;
            var username = owner.displayName;
            var grid = PositionToGrid(owner.transform.position);

            _locked[val] = crate.OwnerID;

            if (config.Hackable.LockTime > 0f)
            {
                crate.Invoke(() =>
                {
                    crate.OwnerID = 0;
                    _locked.Remove(val);

                    if (config.Hackable.NotifyUnlocked && !crateLock.Contains(userid) && crate.inventory != null && !crate.inventory.IsEmpty())
                    {
                        if (config.Hackable.NotifyCooldown > 0)
                        {
                            crateLock.Add(userid);
                            timer.In(config.Hackable.NotifyCooldown, () => crateLock.Remove(userid));
                        }
                        foreach (var target in BasePlayer.activePlayerList)
                        {
                            CreateMessage(target, "CrateUnlocked", grid, username);
                        }
                    }
                }, config.Hackable.LockTime + (HackableLockedCrate.requiredHackSeconds - hackSeconds));
            }


            if (config.Hackable.NotifyLocked && !crateLock.Contains(userid))
            {
                if (config.Hackable.NotifyCooldown > 0)
                {
                    crateLock.Add(userid);
                    timer.In(config.Hackable.NotifyCooldown, () => crateLock.Remove(userid));
                }
                foreach (var target in BasePlayer.activePlayerList)
                {
                    CreateMessage(target, "CrateLocked", username, grid);
                }
            }
        }

        private void CancelDamage(HitInfo hitInfo)
        {
            hitInfo.damageTypes = new();
            hitInfo.DoHitEffects = false;
            hitInfo.DidHit = false;
        }

        private bool CanMessage(BasePlayer player)
        {
            if (_sent.Contains(player.UserIDString))
            {
                return false;
            }

            string uid = player.UserIDString;

            _sent.Add(uid);
            timer.Once(10f, () => _sent.Remove(uid));

            return true;
        }

        public bool HasLockout(BasePlayer player, DamageEntryType damageEntryType, ulong skinid)
        {
            if (config.Lockout.Exceptions.Contains(skinid))
            {
                return false;
            }

            if (damageEntryType == DamageEntryType.Bradley && config.Lockout.Bradley <= 0)
            {
                return false;
            }

            if (damageEntryType == DamageEntryType.Heli && config.Lockout.Heli <= 0)
            {
                return false;
            }

            if (!player.IsValid() || IsF15EventActive || HasPermission(player, bypassLockoutsPerm))
            {
                return false;
            }

            if (data.Lockouts.TryGetValue(player.UserIDString, out var lo))
            {
                double time = UI.GetLockoutTime(damageEntryType, lo, player.UserIDString);

                if (time > 0f)
                {
                    if (CanMessage(player))
                    {
                        CreateMessage(player, damageEntryType == DamageEntryType.Bradley ? "LockedOutBradley" : "LockedOutHeli", FormatTime(time));
                    }

                    return true;
                }
            }

            return false;
        }

        private string FormatTime(double seconds)
        {
            if (seconds < 0)
            {
                return "0s";
            }

            var ts = TimeSpan.FromSeconds(seconds);
            string format = "{0:D2}h {1:D2}m {2:D2}s";

            return string.Format(format, ts.Hours, ts.Minutes, ts.Seconds);
        }

        private void ApplyCooldowns(DamageEntryType damageEntryType)
        {
            foreach (var lo in data.Lockouts.ToList())
            {
                double time = UI.GetLockoutTime(damageEntryType);

                if (time <= 0f)
                {
                    continue;
                }

                bool update = false;

                if (damageEntryType == DamageEntryType.Bradley && lo.Value.Bradley - Epoch.Current > config.Lockout.Bradley)
                {
                    lo.Value.Bradley = Epoch.Current + time;

                    update = true;
                }

                if (damageEntryType == DamageEntryType.Heli && lo.Value.Heli - Epoch.Current > config.Lockout.Heli)
                {
                    lo.Value.Heli = Epoch.Current + time;

                    update = true;
                }

                if (update)
                {
                    var player = BasePlayer.Find(lo.Key);

                    if (player == null) continue;

                    UI.UpdateLockoutUI(player);
                }
            }
        }

        public void TrySetLockout(string userid, BasePlayer player, DamageEntryType damageEntryType, ulong skinID)
        {
            if (IsF15EventActive || config.Lockout.Exceptions.Contains(skinID))
            {
                return;
            }

            if (permission.UserHasPermission(userid, bypassLockoutsPerm))
            {
                return;
            }

            double time = UI.GetLockoutTime(damageEntryType);

            if (time <= 0)
            {
                return;
            }

            if (!data.Lockouts.TryGetValue(userid, out var lo))
            {
                data.Lockouts[userid] = lo = new();
            }

            switch (damageEntryType)
            {
                case DamageEntryType.Bradley:
                    {
                        if (lo.Bradley <= 0)
                        {
                            lo.Bradley = Epoch.Current + time;
                        }
                        break;
                    }
                case DamageEntryType.Heli:
                    {
                        if (lo.Heli <= 0)
                        {
                            lo.Heli = Epoch.Current + time;
                        }
                        break;
                    }
            }

            if (lo.Any())
            {
                UI.UpdateLockoutUI(player);
            }
        }

        private void LockoutLooters(HashSet<ulong> looters, Vector3 position, DamageEntryType damageEntryType, ulong skinID)
        {
            if (looters.Count == 0)
            {
                return;
            }

            HashSet<ulong> members = new(looters);
            HashSet<string> usernames = new();

            foreach (ulong looterId in looters)
            {
                var looter = RelationshipManager.FindByID(looterId);

                if (looter) usernames.Add(looter.displayName);

                TrySetLockout(looterId.ToString(), looter, damageEntryType, skinID);
                LockoutTeam(members, looterId, damageEntryType, skinID);
                LockoutClan(members, looterId, damageEntryType, skinID);
            }

            SendDiscordMessage(members, usernames.ToList(), position, damageEntryType);
        }

        private void LockoutTeam(HashSet<ulong> members, ulong looterId, DamageEntryType damageEntryType, ulong skinID)
        {
            if (!config.Lockout.Team || !RelationshipManager.ServerInstance.playerToTeam.TryGetValue(looterId, out var team))
            {
                return;
            }

            foreach (var memberId in team.members)
            {
                if (members.Contains(memberId))
                {
                    continue;
                }

                var member = RelationshipManager.FindByID(memberId);

                if (config.Lockout.Time > 0 && member != null && member.secondsSleeping > config.Lockout.Time * 60f)
                {
                    continue;
                }

                TrySetLockout(memberId.ToString(), member, damageEntryType, skinID);

                members.Add(memberId);
            }
        }

        private void LockoutClan(HashSet<ulong> members, ulong looterId, DamageEntryType damageEntryType, ulong skinID)
        {
            if (!config.Lockout.Clan || Instance?.Clans?.Call("GetClanMembers", looterId) is not List<string> clan)
            {
                return;
            }

            foreach (ulong memberId in clan.Select(ulong.Parse))
            {
                if (members.Contains(memberId))
                {
                    continue;
                }

                var member = RelationshipManager.FindByID(memberId);

                if (config.Lockout.Time > 0 && member != null && member.secondsSleeping > config.Lockout.Time * 60f)
                {
                    continue;
                }

                TrySetLockout(memberId.ToString(), member, damageEntryType, skinID);

                members.Add(memberId);
            }
        }

        private object HandleTeam(RelationshipManager.PlayerTeam team, ulong userid)
        {
            List<(string key, Dictionary<ulong, List<DamageKey>> dict)> attackers = new()
            {
                ("CannotLeaveBradley", _apcAttackers),
                ("CannotLeaveHeli", _heliAttackers)
            };

            foreach (var (key, dict) in attackers)
            {
                foreach (var list in dict.Values)
                {
                    foreach (var info in list)
                    {
                        if (info.userid == userid)
                        {
                            CreateMessage(info.attacker, key);
                            return true;
                        }
                    }
                }
            }

            return null;
        }

        private bool IsDefended(PatrolHelicopter heli) => heli.IsValid() && (data.Lock.ContainsKey(heli.net.ID.Value) || data.Damage.ContainsKey(heli.net.ID.Value));

        private bool IsDefended(BaseCombatEntity victim) => victim.IsValid() && (_locked.ContainsKey(victim.net.ID.Value) || data.Lock.ContainsKey(victim.net.ID.Value));

        private void DoLockoutRemoves()
        {
            foreach (var (userid, lo) in data.Lockouts.ToList())
            {
                if (lo.Bradley - Epoch.Current <= 0)
                {
                    lo.Bradley = 0;
                }

                if (lo.Heli - Epoch.Current <= 0)
                {
                    lo.Heli = 0;
                }

                if (!lo.Any())
                {
                    data.Lockouts.Remove(userid);
                }
            }
        }

        private void Unsubscribe()
        {
            Unsubscribe(nameof(OnBossSpawn));
            Unsubscribe(nameof(OnBossKilled));
            Unsubscribe(nameof(OnGuardedCrateEventEnded));
            Unsubscribe(nameof(CanHackCrate));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnSupplyDropLanded));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnSupplyDropDropped));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnExplosiveDropped));
            Unsubscribe(nameof(OnExplosiveThrown));
            Unsubscribe(nameof(OnExcavatorSuppliesRequested));
            Unsubscribe(nameof(OnCargoPlaneSignaled));
            Unsubscribe(nameof(OnPersonalApcSpawned));
            Unsubscribe(nameof(OnPersonalHeliSpawned));
            Unsubscribe(nameof(CanBradleyTakeDamage));
            Unsubscribe(nameof(OnRandomRaidWin));
        }

        private void SaveData()
        {
            DoLockoutRemoves();
            Interface.Oxide.DataFileSystem.WriteObject(Name, data, true);
        }

        private void LoadData()
        {
            try { data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); } catch { }

            if (data == null)
            {
                data = new();
                SaveData();
            }

            data.Sanitize();
        }

        private void RegisterPermissions()
        {
            foreach (var entry in config.Hackable.Permissions)
            {
                permission.RegisterPermission(entry.Permission, this);
            }

            permission.RegisterPermission(bypassLootPerm, this);
            permission.RegisterPermission(bypassDamagePerm, this);
            permission.RegisterPermission(bypassLockoutsPerm, this);
            permission.RegisterPermission("lootdefender.bypassnpclock", this);
            permission.RegisterPermission("lootdefender.bypasshelilock", this);
            permission.RegisterPermission("lootdefender.bypassbradleylock", this);

        }

        private bool IsAlly(ulong playerId, ulong targetId)
        {
            if (playerId == targetId)
            {
                return true;
            }

            if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out var team) && team.members.Contains(targetId))
            {
                return true;
            }

            if (Clans != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId)))
            {
                return true;
            }

            if (Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", playerId.ToString(), targetId.ToString())))
            {
                return true;
            }

            return false;
        }

        private static List<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseEntity
        {
            List<T> entities = Pool.Get<List<T>>();
            Vis.Entities(a, n, entities, m, QueryTriggerInteraction.Collide);
            entities.RemoveAll(x => x == null || x.IsDestroyed);
            return entities;
        }

        private bool CanRemoveFire(DamageEntryType damageEntryType)
        {
            if (damageEntryType == DamageEntryType.Bradley && !config.Bradley.RemoveFireFromCrates)
            {
                return false;
            }

            if (damageEntryType == DamageEntryType.Heli && !config.Helicopter.RemoveFireFromCrates)
            {
                return false;
            }

            return true;
        }

        private void RemoveFireFromCrates(Vector3 position, DamageEntryType damageEntryType)
        {
            var entities = FindEntitiesOfType<BaseEntity>(position, 25f);
            foreach (var e in entities)
            {
                if (CanRemoveFire(damageEntryType))
                {
                    if (e is LockedByEntCrate crate)
                    {
                        var lockingEnt = crate.lockingEnt;

                        if (lockingEnt == null) continue;

                        var entity = lockingEnt.ToBaseEntity();

                        if (entity != null && !entity.IsDestroyed)
                        {
                            entity.Kill();
                        }
                    }
                    else if (e is FireBall fireball)
                    {
                        fireball.Extinguish();
                    }
                }

                if (e is HelicopterDebris debris)
                {
                    float num = damageEntryType == DamageEntryType.Heli ? config.Helicopter.TooHotUntil : config.Bradley.TooHotUntil;

                    if (num > -1)
                    {
                        debris.tooHotUntil = Time.realtimeSinceStartup + num;
                    }
                }
            }
            Pool.FreeUnmanaged(ref entities);
        }

        private void LockInRadius<T>(Vector3 position, LockInfo lockInfo, DamageEntryType damageEntryType) where T : BaseEntity
        {
            var entities = FindEntitiesOfType<T>(position, damageEntryType == DamageEntryType.Heli ? 50f : 20f);
            foreach (var entity in entities)
            {
                if (data.Lock.ContainsKey(entity.net.ID.Value))
                {
                    continue;
                }

                ulong ownerid = lockInfo.damageInfo.OwnerID;
                entity.OwnerID = ownerid;
                data.Lock[entity.net.ID.Value] = lockInfo;

                float time = GetLockTime(damageEntryType);

                entity.Invoke(() => entity.OwnerID = ownerid, 1f);

                if (time > 0f)
                {
                    entity.Invoke(() => entity.OwnerID = 0, time);
                }
            }
            Pool.FreeUnmanaged(ref entities);
        }

        private void LockInRadius(Vector3 position, ulong damageKey, DamageInfo damageInfo, ulong playerSteamID)
        {
            var corpses = FindEntitiesOfType<LootableCorpse>(position, 3f);
            foreach (var corpse in corpses)
            {
                if (corpse.IsValid() && corpse.playerSteamID == playerSteamID && !data.Lock.ContainsKey(corpse.net.ID.Value))
                {
                    if (config.Npc.LockTime > 0f)
                    {
                        var uid = corpse.net.ID.Value;

                        timer.Once(config.Npc.LockTime, () => data.Lock.Remove(uid));
                        corpse.Invoke(() => corpse.OwnerID = 0, config.Npc.LockTime);
                    }

                    ulong ownerid = damageInfo.OwnerID;
                    corpse.OwnerID = ownerid;
                    corpse.Invoke(() => corpse.OwnerID = ownerid, 1f);
                    data.Lock[corpse.net.ID.Value] = new(damageInfo, config.Npc.LockTime);
                    timer.Once(3f, () => data.Damage.Remove(damageKey));
                }
            }
            Pool.FreeUnmanaged(ref corpses);
        }

        private void LockInRadius(Vector3 position, LockInfo lockInfo, ulong playerSteamID)
        {
            var containers = FindEntitiesOfType<DroppedItemContainer>(position, 3f);
            foreach (var container in containers)
            {
                if (container.IsValid() && container.playerSteamID == playerSteamID && !data.Lock.ContainsKey(container.net.ID.Value))
                {
                    if (config.Npc.LockTime > 0f)
                    {
                        var uid = container.net.ID.Value;

                        timer.Once(config.Npc.LockTime, () => data.Lock.Remove(uid));
                        container.Invoke(() => container.OwnerID = 0, config.Npc.LockTime);
                    }

                    ulong ownerid = lockInfo.damageInfo.OwnerID;
                    container.OwnerID = ownerid;
                    container.Invoke(() => container.OwnerID = ownerid, 1f);
                    data.Lock[container.net.ID.Value] = lockInfo;
                }
            }
            Pool.FreeUnmanaged(ref containers);
        }

        private static int GetLockTime(DamageEntryType damageEntryType)
        {
            int time = damageEntryType == DamageEntryType.Bradley ? config.Bradley.LockTime : damageEntryType == DamageEntryType.Heli ? config.Helicopter.LockTime : config.Npc.LockTime;

            return time > 0 ? time : int.MaxValue;
        }

        #endregion Helpers

        #region UI

        public class UI // Credits: Absolut & k1lly0u
        {
            private static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image =
                            {
                                Color = color
                            },
                            RectTransform =
                            {
                                AnchorMin = aMin,
                                AnchorMax = aMax
                            },
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            private static void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text =
                    {
                        Color = color,
                        FontSize = size,
                        Align = align,
                        FadeIn = 1.0f,
                        Text = text
                    },
                    RectTransform =
                    {
                        AnchorMin = aMin,
                        AnchorMax = aMax
                    }
                },
                panel);
            }

            private static string Color(string hexColor, float a = 1.0f)
            {
                a = Mathf.Clamp(a, 0f, 1f);
                hexColor = hexColor.TrimStart('#');
                int r = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int g = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int b = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {a}";
            }

            public static void DestroyLockoutUI(BasePlayer player)
            {
                if (player.IsValid() && player.IsConnected && Lockouts.Contains(player))
                {
                    CuiHelper.DestroyUi(player, BradleyPanelName);
                    CuiHelper.DestroyUi(player, HeliPanelName);
                    Lockouts.Remove(player);
                    DestroyLockoutUpdate(player);
                }
            }

            public static void DestroyAllLockoutUI()
            {
                foreach (var player in Lockouts)
                {
                    if (player.IsValid() && player.IsConnected && Lockouts.Contains(player))
                    {
                        CuiHelper.DestroyUi(player, BradleyPanelName);
                        CuiHelper.DestroyUi(player, HeliPanelName);
                        DestroyLockoutUpdate(player);
                    }
                }

                Lockouts.Clear();
            }

            private static void Create(BasePlayer player, string panelName, string text, int fontSize, string color, string panelColor, string aMin, string aMax)
            {
                var element = CreateElementContainer(panelName, panelColor, aMin, aMax, false, "Hud");

                CreateLabel(ref element, panelName, Color(color), text, fontSize, "0 0", "1 1");
                CuiHelper.AddUi(player, element);

                if (!Lockouts.Contains(player))
                {
                    Lockouts.Add(player);
                }
            }

            public static bool ShowTemporaryLockouts(BasePlayer player, string min, string max)
            {
                double bradleyTime = 3600;

                if (bradleyTime <= 0)
                {
                    return false;
                }

                string bradley = Math.Floor(TimeSpan.FromSeconds(bradleyTime).TotalMinutes).ToString();
                string bradleyBackgroundColor = Color(config.UI.Bradley.BackgroundColor, config.UI.Bradley.Alpha);

                Create(player, BradleyPanelName, _("Time", player.UserIDString, bradley), config.UI.Bradley.FontSize, config.UI.Bradley.TextColor, bradleyBackgroundColor, min, max);

                config.UI.Bradley.AnchorMin = min;
                config.UI.Bradley.AnchorMax = max;
                Instance.SaveConfig();

                player.Invoke(() => DestroyLockoutUI(player), 5f);
                return true;
            }

            public static void ShowLockouts(BasePlayer player)
            {
                if (Instance.IsF15EventActive || Instance.HasPermission(player, bypassLockoutsPerm))
                {
                    data.Lockouts.Remove(player.UserIDString);
                    return;
                }

                if (!data.Lockouts.TryGetValue(player.UserIDString, out var lo))
                {
                    data.Lockouts[player.UserIDString] = lo = new();
                }

                if (config.UI.Bradley.Enabled)
                {
                    double bradleyTime = GetLockoutTime(DamageEntryType.Bradley, lo, player.UserIDString);

                    if (bradleyTime > 0f)
                    {
                        string bradley = Math.Floor(TimeSpan.FromSeconds(bradleyTime).TotalMinutes).ToString();
                        string bradleyBackgroundColor = Color(config.UI.Bradley.BackgroundColor, config.UI.Bradley.Alpha);

                        Create(player, BradleyPanelName, _("Time", player.UserIDString, bradley), config.UI.Bradley.FontSize, config.UI.Bradley.TextColor, bradleyBackgroundColor, config.UI.Bradley.AnchorMin, config.UI.Bradley.AnchorMax);
                        SetLockoutUpdate(player);
                    }
                }

                if (config.UI.Heli.Enabled)
                {
                    double heliTime = GetLockoutTime(DamageEntryType.Heli, lo, player.UserIDString);

                    if (heliTime > 0)
                    {
                        string heli = Math.Floor(TimeSpan.FromSeconds(heliTime).TotalMinutes).ToString();
                        string heliBackgroundColor = Color(config.UI.Heli.BackgroundColor, config.UI.Heli.Alpha);

                        Create(player, HeliPanelName, _("Heli Time", player.UserIDString, heli), config.UI.Heli.FontSize, config.UI.Heli.TextColor, heliBackgroundColor, config.UI.Heli.AnchorMin, config.UI.Heli.AnchorMax);
                        SetLockoutUpdate(player);
                    }
                }
            }

            public static double GetLockoutTime(DamageEntryType damageEntryType)
            {
                switch (damageEntryType)
                {
                    case DamageEntryType.Bradley:
                        {
                            return config.Lockout.Bradley * 60;
                        }
                    case DamageEntryType.Heli:
                        {
                            return config.Lockout.Heli * 60;
                        }
                }

                return 0;
            }

            public static double GetLockoutTime(DamageEntryType damageEntryType, Lockout lo, string playerId)
            {
                double time = 0;

                switch (damageEntryType)
                {
                    case DamageEntryType.Bradley:
                        {
                            if ((time = lo.Bradley) <= 0 || (time -= Epoch.Current) <= 0)
                            {
                                lo.Bradley = 0;
                            }

                            break;
                        }
                    case DamageEntryType.Heli:
                        {
                            if ((time = lo.Heli) <= 0 || (time -= Epoch.Current) <= 0)
                            {
                                lo.Heli = 0;
                            }

                            break;
                        }
                }

                if (!lo.Any())
                {
                    data.Lockouts.Remove(playerId);
                }

                return time < 0 ? 0 : time;
            }

            public static void UpdateLockoutUI(BasePlayer player)
            {
                Lockouts.RemoveAll(p => p == null || !p.IsConnected);

                if (player == null || !player.IsConnected)
                {
                    return;
                }

                DestroyLockoutUI(player);

                var uii = GetSettings(player.UserIDString);

                if (!uii.Enabled || !uii.Lockouts)
                {
                    return;
                }

                ShowLockouts(player);
            }

            private static void SetLockoutUpdate(BasePlayer player)
            {
                if (!InvokeTimers.TryGetValue(player.userID, out var timers))
                {
                    InvokeTimers[player.userID] = timers = new();
                }

                if (timers.Lockout == null || timers.Lockout.Destroyed)
                {
                    timers.Lockout = Instance.timer.Once(60f, () => UpdateLockoutUI(player));
                }
                else
                {
                    timers.Lockout.Reset();
                }
            }

            public static void DestroyLockoutUpdate(BasePlayer player)
            {
                if (!InvokeTimers.TryGetValue(player.userID, out var timers))
                {
                    return;
                }

                if (timers.Lockout == null || timers.Lockout.Destroyed)
                {
                    return;
                }

                timers.Lockout.Destroy();
            }

            public static Info GetSettings(string playerId)
            {
                if (!data.UI.TryGetValue(playerId, out var uii))
                {
                    data.UI[playerId] = uii = new();
                }

                return uii;
            }

            private const string BradleyPanelName = "Lockouts_UI_Bradley";
            private const string HeliPanelName = "Lockouts_UI_Heli";

            public static List<BasePlayer> Lockouts { get; set; } = new();
            public static Dictionary<ulong, Timers> InvokeTimers { get; set; } = new();

            public class Timers
            {
                public Timer Lockout;
            }

            public class Info
            {
                public bool Enabled { get; set; } = true;
                public bool Lockouts { get; set; } = true;
            }
        }

        private void CommandUI(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;
            var uii = UI.GetSettings(user.Id);

            uii.Enabled = !uii.Enabled;

            if (!uii.Enabled)
            {
                UI.DestroyLockoutUI(player);
            }
            else
            {
                UI.UpdateLockoutUI(player);
            }
        }

        private void CommandLootDefender(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;

            if (user.IsServer || user.IsAdmin)
            {
                if (args.Length == 2)
                {
                    if (args[0] == "setbradleytime")
                    {
                        if (double.TryParse(args[1], out var time))
                        {
                            config.Lockout.Bradley = time;
                            SaveConfig();

                            user.Reply($"Cooldown changed to {time} minutes");
                            ApplyCooldowns(DamageEntryType.Bradley);
                        }
                        else user.Reply($"The specified time '{args[1]}' is not a valid number.");
                    }
                    if (args[0] == "sethelitime")
                    {
                        if (double.TryParse(args[1], out var time))
                        {
                            config.Lockout.Heli = time;
                            SaveConfig();

                            user.Reply($"Cooldown changed to {time} minutes");
                            ApplyCooldowns(DamageEntryType.Heli);
                        }
                        else user.Reply($"The specified time '{args[1]}' is not a valid number.");
                    }
                    else if (args[0] == "reset")
                    {
                        var value = args[1];

                        if (data.Lockouts.Remove(value))
                        {
                            UI.DestroyLockoutUI(RustCore.FindPlayerByIdString(value));
                            user.Reply($"Removed lockout for {value}");
                        }
                        else if (!value.IsSteamId())
                        {
                            user.Reply("You must specify a steam ID");
                        }
                        else user.Reply("Target not found");
                    }
                    else if (command == "unlock")
                    {
                        foreach (var pair in data.Lock.ToList())
                        {
                            if (player.Distance(pair.Value.damageInfo._position) < 25f || pair.Value.CanInteract(player.userID, player))
                            {
                                if (pair.Value.damageInfo._entity != null)
                                {
                                    pair.Value.damageInfo._entity.OwnerID = 0uL;
                                    Message(player, $"Unlocked {(pair.Value.damageInfo.damageEntryType == DamageEntryType.Bradley ? "bradley" : pair.Value.damageInfo.damageEntryType == DamageEntryType.NPC ? "npc" : pair.Value.damageInfo.damageEntryType == DamageEntryType.Heli ? "heli" : "corpse")}");
                                }
                                data.Lock.Remove(pair.Key);
                            }
                        }
                    }
                }
            }

            if (player.IsAdmin && args.Length == 3)
            {
                UI.ShowTemporaryLockouts(player, args[1], args[2]);
            }
        }

        private void CommandLockouts(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;

            if (data.Lockouts.TryGetValue(player.UserIDString, out var lo))
            {
                double time1 = UI.GetLockoutTime(DamageEntryType.Bradley, lo, player.UserIDString);

                if (time1 > 0f)
                {
                    CreateMessage(player, "LockedOutBradley", FormatTime(time1));
                }

                double time2 = UI.GetLockoutTime(DamageEntryType.Heli, lo, player.UserIDString);

                if (time2 > 0f)
                {
                    CreateMessage(player, "LockedOutHeli", FormatTime(time2));
                }
            }
            else
            {
                CreateMessage(player, "NoLockouts");
            }
        }

        #endregion UI

        #region Discord Messages

        private bool CanSendDiscordMessage()
        {
            if (string.IsNullOrEmpty(config.DiscordMessages.WebhookUrl) || config.DiscordMessages.WebhookUrl == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
            {
                return false;
            }

            return true;
        }

        private static string PositionToGrid(Vector3 position) => MapHelper.PositionToString(position);

        private void SendDiscordMessage(HashSet<ulong> members, List<string> usernames, Vector3 position, DamageEntryType damageEntryType)
        {
            if (config.DiscordMessages.NotifyConsole)
            {
                Puts($"{damageEntryType} killed by {string.Join(", ", usernames)} at {position}");
            }

            if (!CanSendDiscordMessage())
            {
                return;
            }

            Dictionary<string, string> players = new();

            foreach (ulong memberId in members)
            {
                var memberIdString = memberId.ToString();
                var memberName = covalence.Players.FindPlayerById(memberIdString)?.Name ?? memberIdString;

                if (config.DiscordMessages.BattleMetrics)
                {
                    players[memberName] = $"https://www.battlemetrics.com/rcon/players?filter%5Bsearch%5D={memberIdString}&filter%5Bservers%5D=false&filter%5BplayerFlags%5D=&sort=score&showServers=true";
                }
                else players[memberName] = memberIdString;
            }

            SendDiscordMessage(players, position, damageEntryType == DamageEntryType.Bradley ? _("BradleyKilled") : _("HeliKilled"));
        }

        private void SendDiscordMessage(Dictionary<string, string> members, Vector3 position, string text)
        {
            string grid = $"{PositionToGrid(position)} {position}";
            StringBuilder log = new();

            foreach (var member in members)
            {
                log.AppendLine($"[{DateTime.Now}] {member.Key} {member.Value} @ {grid}): {text}");
            }

            LogToFile("kills", log.ToString(), this);

            List<object> _fields = new();

            foreach (var member in members)
            {
                _fields.Add(new
                {
                    name = config.DiscordMessages.EmbedMessagePlayer,
                    value = $"[{member.Key}]({member.Value})",
                    inline = true
                });
            }

            _fields.Add(new
            {
                name = config.DiscordMessages.EmbedMessageMessage,
                value = text,
                inline = false
            });

            _fields.Add(new
            {
                name = ConVar.Server.hostname,
                value = grid,
                inline = false
            });

            _fields.Add(new
            {
                name = config.DiscordMessages.EmbedMessageServer,
                value = $"steam://connect/{ConVar.Server.ip}:{ConVar.Server.port}",
                inline = false
            });

            string json = JsonConvert.SerializeObject(_fields.ToArray());

            Interface.CallHook("API_SendFancyMessage", config.DiscordMessages.WebhookUrl, config.DiscordMessages.EmbedMessageTitle, config.DiscordMessages.MessageColor, json, null, this);
        }

        #endregion Discord Messages

        #region L10N

        private class NotifySettings
        {
            [JsonProperty(PropertyName = "Broadcast Kill Notification To Chat")]
            public bool NotifyChat { get; set; } = true;

            [JsonProperty(PropertyName = "Broadcast Kill Notification To Killer")]
            public bool NotifyKiller { get; set; } = true;

            [JsonProperty(PropertyName = "Broadcast Locked Notification To Chat", NullValueHandling = NullValueHandling.Ignore)]
            public bool? NotifyLocked { get; set; } = true;
        }

        private class HackPermission
        {
            [JsonProperty(PropertyName = "Permission")]
            public string Permission { get; set; }

            [JsonProperty(PropertyName = "Hack Time")]
            public float Value { get; set; }
        }

        private static List<HackPermission> DefaultHackPermissions
        {
            get
            {
                return new()
                {
                    new() { Permission = "lootdefender.hackedcrates.regular", Value = 750f },
                    new() { Permission = "lootdefender.hackedcrates.elite", Value = 500f },
                    new() { Permission = "lootdefender.hackedcrates.legend", Value = 300f },
                    new() { Permission = "lootdefender.hackedcrates.vip", Value = 120f },
                };
            }
        }

        private class HackableSettings
        {
            [JsonProperty(PropertyName = "Permissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<HackPermission> Permissions = DefaultHackPermissions;

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Permissions Enabled To Set Required Hack Seconds")]
            public bool Seconds { get; set; } = true;

            [JsonProperty(PropertyName = "Lock For X Seconds (0 = Forever)")]
            public int LockTime { get; set; } = 900;

            [JsonProperty(PropertyName = "Lock Hackable Crates At Harbor")]
            public bool Harbor { get; set; }

            [JsonProperty(PropertyName = "Block Timer Increase On Damage To Laptop")]
            public bool Laptop { get; set; } = true;

            [JsonProperty(PropertyName = "Broadcast Locked Notification To Chat", NullValueHandling = NullValueHandling.Ignore)]
            public bool NotifyLocked { get; set; }

            [JsonProperty(PropertyName = "Broadcast Unlocked Notification To Chat", NullValueHandling = NullValueHandling.Ignore)]
            public bool NotifyUnlocked { get; set; }

            [JsonProperty(PropertyName = "Cooldown Between Notifications For Each Player")]
            public float NotifyCooldown { get; set; }
        }

        private class BradleySettings
        {
            [JsonProperty(PropertyName = "Messages")]
            public NotifySettings Messages { get; set; } = new();

            [JsonProperty(PropertyName = "Damage Lock Threshold")]
            public float Threshold { get; set; } = 0.2f;

            [JsonProperty(PropertyName = "Harvest Too Hot Until (0 = Never)")]
            public float TooHotUntil { get; set; } = 480f;

            [JsonProperty(PropertyName = "Lock For X Seconds (0 = Forever)")]
            public int LockTime { get; set; } = 900;

            [JsonProperty(PropertyName = "Remove Fire From Crates")]
            public bool RemoveFireFromCrates { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Bradley At Launch Site")]
            public bool LockLaunchSite { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Bradley At Harbor")]
            public bool LockHarbor { get; set; }

            [JsonProperty(PropertyName = "Lock Bradley From Personal Apc Plugin")]
            public bool LockPersonal { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Bradley From Monument Bradley Plugin")]
            public bool LockMonument { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Bradley From Convoy Plugin")]
            public bool LockConvoy { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Bradley From Bradley Tiers Plugin")]
            public bool LockBradleyTiers { get; set; }

            [JsonProperty(PropertyName = "Lock Bradley From Everywhere Else")]
            public bool LockWorldly { get; set; } = true;

            [JsonProperty(PropertyName = "Block Looting Only")]
            public bool LootingOnly { get; set; }

            [JsonProperty(PropertyName = "Rust Rewards RP")]
            public double RRP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "XP Reward")]
            public double XP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "ShoppyStock Reward Value")]
            public double SS { get; set; }

            [JsonProperty(PropertyName = "ShoppyStock Shop Name")]
            public string ShoppyStockShopName { get; set; } = "";
        }

        private class HelicopterSettings
        {
            [JsonProperty(PropertyName = "Messages")]
            public NotifySettings Messages { get; set; } = new();

            [JsonProperty(PropertyName = "Damage Lock Threshold")]
            public float Threshold { get; set; } = 0.2f;

            [JsonProperty(PropertyName = "Harvest Too Hot Until (0 = Never)")]
            public float TooHotUntil { get; set; } = 480f;

            [JsonProperty(PropertyName = "Lock For X Seconds (0 = Forever)")]
            public int LockTime { get; set; } = 900;

            [JsonProperty(PropertyName = "Remove Fire From Crates")]
            public bool RemoveFireFromCrates { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Heli From Convoy Plugin")]
            public bool LockConvoy { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Heli At Harbor")]
            public bool? LockHarbor { get; set; } = null;

            [JsonProperty(PropertyName = "Lock Heli From Personal Heli Plugin")]
            public bool LockPersonal { get; set; } = true;

            [JsonProperty(PropertyName = "Block Looting Only")]
            public bool LootingOnly { get; set; }

            [JsonProperty(PropertyName = "Rust Rewards RP")]
            public double RRP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "XP Reward")]
            public double XP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "ShoppyStock Reward Value")]
            public double SS { get; set; }

            [JsonProperty(PropertyName = "ShoppyStock Shop Name")]
            public string ShoppyStockShopName { get; set; } = "";
        }

        private class NpcSettings
        {
            [JsonProperty(PropertyName = "Reward Distance Multiplier")]
            public DistanceMultiplierSettings Distance { get; set; } = new();

            [JsonProperty(PropertyName = "Reward Weapon Multiplier", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, double> WeaponMultipliers { get; set; } = new()
            {
                { "knife.skinning", 1.0 },
                { "gun.water", 1.0 },
                { "pistol.water", 1.0 },
                { "candycaneclub", 1.0 },
                { "snowball", 1.0 },
                { "snowballgun", 1.0 },
                { "rifle.ak", 1.0 },
                { "rifle.ak.diver", 1.0 },
                { "rifle.ak.ice", 1.0 },
                { "grenade.beancan", 1.0 },
                { "rifle.bolt", 1.0 },
                { "bone.club", 1.0 },
                { "knife.bone", 1.0 },
                { "bow.hunting", 1.0 },
                { "salvaged.cleaver", 1.0 },
                { "bow.compound", 1.0 },
                { "crossbow", 1.0 },
                { "shotgun.double", 1.0 },
                { "pistol.eoka", 1.0 },
                { "grenade.f1", 1.0 },
                { "flamethrower", 1.0 },
                { "grenade.flashbang", 1.0 },
                { "pistol.prototype17", 1.0 },
                { "multiplegrenadelauncher", 1.0 },
                { "mace.baseballbat", 1.0 },
                { "knife.butcher", 1.0 },
                { "pitchfork", 1.0 },
                { "vampire.stake", 1.0 },
                { "hmlmg", 1.0 },
                { "homingmissile.launcher", 1.0 },
                { "knife.combat", 1.0 },
                { "rifle.l96", 1.0 },
                { "rifle.lr300", 1.0 },
                { "lmg.m249", 1.0 },
                { "rifle.m39", 1.0 },
                { "pistol.m92", 1.0 },
                { "mace", 1.0 },
                { "machete", 1.0 },
                { "grenade.molotov", 1.0 },
                { "smg.mp5", 1.0 },
                { "pistol.nailgun", 1.0 },
                { "paddle", 1.0 },
                { "shotgun.waterpipe", 1.0 },
                { "pistol.python", 1.0 },
                { "pistol.revolver", 1.0 },
                { "rocket.launcher", 1.0 },
                { "shotgun.pump", 1.0 },
                { "pistol.semiauto", 1.0 },
                { "rifle.semiauto", 1.0 },
                { "smg.2", 1.0 },
                { "shotgun.spas12", 1.0 },
                { "speargun", 1.0 },
                { "spear.stone", 1.0 },
                { "longsword", 1.0 },
                { "salvaged.sword", 1.0 },
                { "smg.thompson", 1.0 },
                { "spear.wooden", 1.0 }
            };

            [JsonProperty(PropertyName = "Messages")]
            public NotifySettings Messages { get; set; } = new() { NotifyLocked = false };

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Damage Lock Threshold")]
            public float Threshold { get; set; } = 0.2f;

            [JsonProperty(PropertyName = "Lock For X Seconds (0 = Forever)")]
            public int LockTime { get; set; }

            [JsonProperty(PropertyName = "Minimum Starting Health Requirement")]
            public float Min { get; set; }

            [JsonProperty(PropertyName = "Lock BossMonster Npcs")]
            public bool BossMonster { get; set; }

            [JsonProperty(PropertyName = "Block Looting Only")]
            public bool LootingOnly { get; set; } = true;

            [JsonProperty(PropertyName = "Rust Rewards RP")]
            public double RRP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "XP Reward")]
            public double XP { get; set; } = 0.0;

            [JsonProperty(PropertyName = "ShoppyStock Reward Value")]
            public double SS { get; set; }

            [JsonProperty(PropertyName = "ShoppyStock Shop Name")]
            public string ShoppyStockShopName { get; set; } = "";
        }

        private class DistanceMultiplierSettings
        {
            [JsonProperty(PropertyName = "400 meters")]
            public float meters400 { get; set; } = 1f;

            [JsonProperty(PropertyName = "300 meters")]
            public float meters300 { get; set; } = 1f;

            [JsonProperty(PropertyName = "200 meters")]
            public float meters200 { get; set; } = 1f;

            [JsonProperty(PropertyName = "100 meters")]
            public float meters100 { get; set; } = 1f;

            [JsonProperty(PropertyName = "75 meters")]
            public float meters75 { get; set; } = 1f;

            [JsonProperty(PropertyName = "50 meters")]
            public float meters50 { get; set; } = 1f;

            [JsonProperty(PropertyName = "25 meters")]
            public float meters25 { get; set; } = 1f;

            [JsonProperty(PropertyName = "under")]
            public float under { get; set; } = 1f;

            public double GetDistanceMult(float distance) =>
                distance >= 400 ? meters400 :
                distance >= 300 ? meters300 :
                distance >= 200 ? meters200 :
                distance >= 100 ? meters100 :
                distance >= 75 ? meters75 :
                distance >= 50 ? meters50 :
                distance >= 25 ? meters25 :
                under;
        }

        private class SupplyDropSettings
        {
            [JsonProperty(PropertyName = "Allow Locking Signals With These Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> Skins { get; set; } = new() { 0 };

            [JsonProperty(PropertyName = "Lock Supply Drops To Players")]
            public bool Lock { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Supply Drops From Excavator")]
            public bool Excavator { get; set; } = true;

            [JsonProperty(PropertyName = "Lock Supply Drops From Helpful Supply Plugin")]
            public bool HelpfulSupply { get; set; }

            [JsonProperty(PropertyName = "Lock Supply Drops From Npc Random Raids Plugin")]
            public bool NpcRandomRaids { get; set; }

            [JsonProperty(PropertyName = "Lock To Player For X Seconds (0 = Forever)")]
            public float LockTime { get; set; }

            [JsonProperty(PropertyName = "Supply Drop Drag")]
            public float Drag { get; set; } = 0.6f;

            [JsonProperty(PropertyName = "Show Grid In Thrown Notification")]
            public bool ThrownAt { get; set; }

            [JsonProperty(PropertyName = "Show Thrown Notification In Chat")]
            public bool NotifyChat { get; set; }

            [JsonProperty(PropertyName = "Show Notification In Server Console")]
            public bool NotifyConsole { get; set; }

            [JsonProperty(PropertyName = "Cooldown Between Notifications For Each Player")]
            public float NotifyCooldown { get; set; }

            [JsonProperty(PropertyName = "Cargo Plane Speed (Meters Per Second)")]
            public float Speed { get; set; } = 40f;

            [JsonProperty(PropertyName = "Cargo Plane Low Altitude Drop")]
            public bool LowDrop { get; set; } = true;

            [JsonProperty(PropertyName = "Bypass Spawning Cargo Plane")]
            public bool Bypass { get; set; }

            [JsonProperty(PropertyName = "Smoke Duration")]
            public float Smoke { get; set; } = -1f;

            [JsonProperty(PropertyName = "Maximum Drop Distance From Signal")]
            public float DistanceFromSignal { get; set; } = 20;

            [JsonProperty(PropertyName = "Destroy Drop After X Seconds")]
            public float DestroyTime { get; set; }
        }

        private class DamageReportSettings
        {
            [JsonProperty(PropertyName = "Hex Color - Single Player")]
            public string SinglePlayer { get; set; } = "#6d88ff";

            [JsonProperty(PropertyName = "Hex Color - Team")]
            public string Team { get; set; } = "#ff804f";

            [JsonProperty(PropertyName = "Hex Color - Ok")]
            public string Ok { get; set; } = "#88ff6d";

            [JsonProperty(PropertyName = "Hex Color - Not Ok")]
            public string NotOk { get; set; } = "#ff5716";
        }

        public class PluginSettingsBaseLockout
        {
            [JsonProperty(PropertyName = "Bypass During F15 Server Wipe Event")]
            public bool F15 { get; set; }

            [JsonProperty(PropertyName = "Command To See Lockout Times")]
            public string Command { get; set; } = "lockouts";

            [JsonProperty(PropertyName = "Time Between Bradley In Minutes")]
            public double Bradley { get; set; }

            [JsonProperty(PropertyName = "Time Between Heli In Minutes")]
            public double Heli { get; set; }

            [JsonProperty(PropertyName = "Lockout Entire Team")]
            public bool Team { get; set; } = true;

            [JsonProperty(PropertyName = "Lockout Entire Clan")]
            public bool Clan { get; set; } = true;

            [JsonProperty(PropertyName = "Exclude Members Offline For More Than X Minutes")]
            public float Time { get; set; } = 15f;

            [JsonProperty(PropertyName = "Lockouts Ignored For Entities With Skin ID", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> Exceptions { get; set; } = new();
        }

        public class UIBradleyLockoutSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Bradley Anchor Min")]
            public string AnchorMin { get; set; } = "0.946 0.325";

            [JsonProperty(PropertyName = "Bradley Anchor Max")]
            public string AnchorMax { get; set; } = "0.986 0.360";

            [JsonProperty(PropertyName = "Bradley Background Color")]
            public string BackgroundColor { get; set; } = "#A52A2A";

            [JsonProperty(PropertyName = "Bradley Text Color")]
            public string TextColor { get; set; } = "#FFFF00";

            [JsonProperty(PropertyName = "Panel Alpha")]
            public float Alpha { get; set; } = 1f;

            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize { get; set; } = 18;
        }

        public class UIHeliLockoutSettings
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Heli Anchor Min")]
            public string AnchorMin { get; set; } = "0.896 0.325";

            [JsonProperty(PropertyName = "Heli Anchor Max")]
            public string AnchorMax { get; set; } = "0.936 0.360";

            [JsonProperty(PropertyName = "Heli Background Color")]
            public string BackgroundColor { get; set; } = "#1F51FF";

            [JsonProperty(PropertyName = "Heli Text Color")]
            public string TextColor { get; set; } = "#FFFF00";

            [JsonProperty(PropertyName = "Panel Alpha")]
            public float Alpha { get; set; } = 1f;

            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize { get; set; } = 18;
        }

        public class UISettings
        {
            [JsonProperty(PropertyName = "Command To Toggle UI")]
            public string Command { get; set; } = "lockui";

            [JsonProperty(PropertyName = "Bradley")]
            public UIBradleyLockoutSettings Bradley { get; set; } = new();

            [JsonProperty(PropertyName = "Heli")]
            public UIHeliLockoutSettings Heli { get; set; } = new();
        }

        public class DiscordMessagesSettings
        {
            [JsonProperty(PropertyName = "Message - Webhook URL")]
            public string WebhookUrl { get; set; } = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty(PropertyName = "Message - Embed Color (DECIMAL)")]
            public int MessageColor { get; set; } = 3329330;

            [JsonProperty(PropertyName = "Embed_MessageTitle")]
            public string EmbedMessageTitle { get; set; } = "Lockouts";

            [JsonProperty(PropertyName = "Embed_MessagePlayer")]
            public string EmbedMessagePlayer { get; set; } = "Player";

            [JsonProperty(PropertyName = "Embed_MessageMessage")]
            public string EmbedMessageMessage { get; set; } = "Message";

            [JsonProperty(PropertyName = "Embed_MessageServer")]
            public string EmbedMessageServer { get; set; } = "Connect via Steam:";

            [JsonProperty(PropertyName = "Add BattleMetrics Link")]
            public bool BattleMetrics { get; set; } = true;

            [JsonProperty(PropertyName = "Show Notification In Server Console")]
            public bool NotifyConsole { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Bradley Settings")]
            public BradleySettings Bradley { get; set; } = new();

            [JsonProperty(PropertyName = "Helicopter Settings")]
            public HelicopterSettings Helicopter { get; set; } = new();

            [JsonProperty(PropertyName = "Hackable Crate Settings")]
            public HackableSettings Hackable { get; set; } = new();

            [JsonProperty(PropertyName = "Npc Settings")]
            public NpcSettings Npc { get; set; } = new();

            [JsonProperty(PropertyName = "Supply Drop Settings")]
            public SupplyDropSettings SupplyDrop { get; set; } = new();

            [JsonProperty(PropertyName = "Damage Report Settings")]
            public DamageReportSettings Report { get; set; } = new();

            [JsonProperty(PropertyName = "Player Lockouts (0 = ignore)")]
            public PluginSettingsBaseLockout Lockout { get; set; } = new();

            [JsonProperty(PropertyName = "Lockout UI")]
            public UISettings UI { get; set; } = new();

            [JsonProperty(PropertyName = "Discord Messages")]
            public DiscordMessagesSettings DiscordMessages { get; set; } = new();

            [JsonProperty(PropertyName = "Disable CH47 Gibs")]
            public bool CH47Gibs { get; set; }

            [JsonProperty(PropertyName = "Chat ID")]
            public ulong ChatID { get; set; }
        }

        private static Configuration config;
        private bool configLoaded;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                if (config.Bradley.Threshold > 1f) config.Bradley.Threshold /= 100f;
                if (config.Helicopter.Threshold > 1f) config.Helicopter.Threshold /= 100f;
                if (config.Npc.Threshold > 1f) config.Npc.Threshold /= 100f;
                if (!config.Helicopter.LockHarbor.HasValue) config.Helicopter.LockHarbor = config.Bradley.LockHarbor;
                if (!config.Npc.Messages.NotifyLocked.HasValue) config.Npc.Messages.NotifyLocked = false;
                canSaveConfig = true;
                SaveConfig();
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }

        protected override void LoadDefaultConfig() => config = new();

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new()
            {
                ["NoPermission"] = "You do not have permission to use this command!",
                ["DamageReport"] = "Damage report for {0}",
                ["DamageTime"] = "{0} was taken down after {1} seconds",
                ["CannotLoot"] = "You cannot loot this as major damage was not from you.",
                ["CannotLootIt"] = "You cannot loot this supply drop.",
                ["CannotLootCrate"] = "You cannot loot this crate.",
                ["CannotMine"] = "You cannot mine this as major damage was not from you.",
                ["CannotDamageThis"] = "You cannot damage this!",
                ["Locked Heli"] = "{0}: Heli has been locked to <color=#FF0000>{1}</color> and their team",
                ["Locked Bradley"] = "{0}: Bradley has been locked to <color=#FF0000>{1}</color> and their team",
                ["Locked Npc"] = "{0}: {1} has been locked to <color=#FF0000>{2}</color> and their team",
                ["Helicopter"] = "Heli",
                ["BradleyAPC"] = "Bradley",
                ["ThrownSupplySignal"] = "{0} has thrown a supply signal!",
                ["ThrownSupplySignalAt"] = "{0} in {1} has thrown a supply signal!",
                ["Format"] = "<color=#C0C0C0>{0:0.00}</color> (<color=#C3FBFE>{1:0.00}%</color>)",
                ["CannotLeaveBradley"] = "You cannot leave your team until the Bradley is destroyed!",
                ["CannotLeaveHeli"] = "You cannot leave your team until the Heli is destroyed!",
                ["LockedOutBradley"] = "You are locked out from Bradley for {0}",
                ["LockedOutHeli"] = "You are locked out from Heli for {0}",
                ["NoLockouts"] = "You have no lockouts.",
                ["Time"] = "{0}m",
                ["Heli Time"] = "{0}m",
                ["HeliKilled"] = "A heli was killed.",
                ["BradleyKilled"] = "A bradley was killed.",
                ["BradleyUnlocked"] = "The bradley at {0} has been unlocked.",
                ["HeliUnlocked"] = "The heli at {0} has been unlocked.",
                ["FirstLock"] = "First locked to {0} at {1}% threshold",
                ["CrateLocked"] = "A crate has been locked to {0} at {1}",
                ["CrateUnlocked"] = "The crate at {0} is no longer locked to {1}",
                ["NpcUnlocked"] = "{0} at {1} has been unlocked.",
                ["ShoppyStockReward"] = "Added {0} {1} to your account.",
            }, this, "en");

            lang.RegisterMessages(new()
            {
                ["NoPermission"] = "У вас нет разрешения на использование этой команды!",
                ["DamageReport"] = "Нанесенный урон по {0}",
                ["DamageTime"] = "{0} был уничтожен за {1} секунд",
                ["CannotLoot"] = "Это не ваш лут, основная часть урона насена не вами.",
                ["CannotLootIt"] = "Вы не можете открыть этот ящик с припасами.",
                ["CannotLootCrate"] = "Вы не можете разграбить кратэ.",
                ["CannotMine"] = "Вы не можете добывать это, основная часть урона насена не вами.",
                ["CannotDamageThis"] = "Вы не можете повредить это!",
                ["Locked Heli"] = "{0}: Этот патрульный вертолёт принадлежит <color=#FF0000>{1}</color> и участникам команды",
                ["Locked Bradley"] = "{0}: Этот танк принадлежит <color=#FF0000>{1}</color> и участникам команды",
                ["Locked Npc"] = "{0}: {1} заблокирован на <color=#FF0000>{2}</color> и его команду.",
                ["Helicopter"] = "Патрульному вертолету",
                ["BradleyAPC"] = "Танку",
                ["ThrownSupplySignal"] = "{0} запросил сброс припасов!",
                ["ThrownSupplySignalAt"] = "{0} {1} запросил сброс припасов!",
                ["Format"] = "<color=#C0C0C0>{0:0.00}</color> (<color=#C3FBFE>{1:0.00}%</color>)",
                ["CannotLeaveBradley"] = "Вы не можете покинуть команду, пока танк не будет уничтожен!",
                ["CannotLeaveHeli"] = "Вы не можете покинуть свою команду, пока Heli не будет уничтожен!",
                ["LockedOutBradley"] = "Вы заблокированы от танка на {0}",
                ["LockedOutHeli"] = "Вы заблокированы в Heli на {0}",
                ["NoLockouts"] = "У тебя нет замок.",
                ["Time"] = "{0} м",
                ["Heli Time"] = "{0} м",
                ["HeliKilled"] = "Вертолёт был уничтожен.",
                ["BradleyKilled"] = "Танк был уничтожен.",
                ["BradleyUnlocked"] = "Танк на {0} разблокирован.",
                ["HeliUnlocked"] = "Вертолёт на {0} разблокирован.",
                ["FirstLock"] = "Добыча заблокирована на игрока {0}, потому что он нанёс {1}% урона.",
                ["CannotLootCrate"] = "Вы не можете ограбить этот ящик.",
                ["CrateLocked"] = "Ящик в квадрате {1} заблокирован на {0}",
                ["CrateUnlocked"] = "Ящик в квадрате {0} больше не заблокирован на {1}",
                ["NpcUnlocked"] = "{0} в координатах {1} разблокирован.",
                ["ShoppyStockReward"] = "Добавлено {0} {1} в ваш аккаунт.",

            }, this, "ru");
        }

        private static string _(string key, string userId = null, params object[] args)
        {
            string message = userId == "server_console" || userId == null ? RemoveFormatting(Instance.lang.GetMessage(key, Instance, userId)) : Instance.lang.GetMessage(key, Instance, userId);

            return args.Length > 0 ? string.Format(message, args) : message;
        }

        public static string RemoveFormatting(string source) => source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;

        private static void CreateMessage(BasePlayer player, string key, params object[] args)
        {
            if (player.IsValid())
            {
                Instance.Player.Message(player, _(key, player.UserIDString, args), config.ChatID);
            }
        }

        private static void Message(BasePlayer player, string message)
        {
            if (player.IsValid())
            {
                Instance.Player.Message(player, message, config.ChatID);
            }
        }

        #endregion
    }
}

// --- End of file: LootDefender.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hackable-crate-time-editor ---
// --- Original File Path: L/LockedCrateTimer/LockedCrateTimer.cs ---

using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Hackable Crate Time Editor", "Cltdj", "0.2.8")]
    [Description("Allows you to edit the amount time it takes to unlock locked crates.")]
    class LockedCrateTimer : CovalencePlugin
    {
        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
            Config["HackingSeconds"] = 900;
            Config["CheckTimer"] = true;
        }

        const float TOTAL_TIME = 15 * 60;
        public int HackingSeconds;
        public bool CheckTimer;

        private void Init()
        {
            permission.RegisterPermission("lockedcratetimer.conf.use", this);
            LoadConfig();
        }

        private void LoadConfig()
        {
            bool success;
            // load hacking seconds
            success = int.TryParse(Config["HackingSeconds"].ToString(), out this.HackingSeconds);
            if (!success) 
            {
                LogWarning("HackingSeconds needs to be set to an integer");
                LogWarning("Falling back to default: 900");
                this.HackingSeconds = 900;
            }

            // load check timer
            this.CheckTimer = bool.Parse(Config["CheckTimer"].ToString());
        }

        void OnCrateHack(HackableLockedCrate crate)
        {
            float newTime = TOTAL_TIME - this.HackingSeconds;
            if (crate.hackSeconds > newTime && this.CheckTimer)
            {
                return;
            }
            crate.hackSeconds = newTime;
        }

        [Command("lockedcratetimer.conf"), Permission("lockedcratetimer.conf.use")]
        private void TimeCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length == 0 || args[0] == "" || args[0] == null)
            {
                player.Reply("first argument must be a <Config key> or 'list' to get a list of keys");
                player.Reply("usage: lockedcratetimer.conf <Config key> <Value>");
                return;
            }

            if (args[0] == "list")
            {
                player.Reply("Config Keys:");
                player.Reply("HackingSeconds");
                player.Reply("CheckTimer");
                return;
            }

            if (args[0] == "?")
            {
                player.Reply("lockedcratetimer.conf <Config key> <Value>");
                return;
            }

            if (args.Length < 2 || args[1] == "")
            {
                player.Reply("Not enought arguments");
                return;
            }

            bool success;
            switch (args[0])
            {
                case "HackingSeconds":
                    int time;
                    success = int.TryParse(args[1], out time);
                    if (success) 
                    {
                        this.HackingSeconds = time;
                        Config["HackingSeconds"] = time;
                        SaveConfig();
                        player.Reply("success");
                    }
                    else
                    {
                        player.Reply("value must be an integer");
                    }
                    break;

                case "CheckTimer":
                    bool check;
                    success = bool.TryParse(args[1], out check);
                    if (success) 
                    {
                        this.CheckTimer = check;
                        Config["CheckTimer"] = check;
                        SaveConfig();
                        player.Reply("success");
                    }
                    else
                    {
                        player.Reply("value must be true or false");
                    }
                    break;

                default:
                    player.Reply(string.Format("Key '{0}' not found, try 'lockedcratetimer.conf list' to get a list of Config keys", args[0]));
                    break;
            }
        }
    }
}

// --- End of file: LockedCrateTimer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-checker ---
// --- Original File Path: L/LootChecker/LootChecker.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Loot Checker", "Rustoholics", "0.1.0")]
    [Description("View a summary of all the loot in crates and barrels")]

    public class LootChecker : CovalencePlugin
    {
        #region Variables

        private int DefaultPrefab = 4;
        private List<string> _prefabs = new List<string>
        {
            "assets/bundled/prefabs/radtown/crate_basic.prefab",
            "assets/bundled/prefabs/radtown/crate_elite.prefab",
            "assets/bundled/prefabs/radtown/crate_mine.prefab",
            "assets/bundled/prefabs/radtown/crate_normal.prefab",
            "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
            "assets/bundled/prefabs/radtown/crate_normal_2_food.prefab",
            "assets/bundled/prefabs/radtown/crate_normal_2_medical.prefab",
            "assets/bundled/prefabs/radtown/crate_tools.prefab",
            "assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab",
            "assets/bundled/prefabs/radtown/crate_underwater_basic.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm ammo.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm c4.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm construction resources.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm construction tools.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm food.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm medical.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm res.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm tier1 lootbox.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm tier2 lootbox.prefab",
            "assets/bundled/prefabs/radtown/dmloot/dm tier3 lootbox.prefab",
            "assets/bundled/prefabs/radtown/vehicle_parts.prefab",
            "assets/bundled/prefabs/radtown/foodbox.prefab",
            "assets/bundled/prefabs/radtown/loot_barrel_1.prefab",
            "assets/bundled/prefabs/radtown/loot_barrel_2.prefab",
            "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-1.prefab",
            "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-2.prefab",
            "assets/bundled/prefabs/autospawn/resource/loot/trash-pile-1.prefab",
            "assets/bundled/prefabs/radtown/loot_trash.prefab",
            "assets/bundled/prefabs/radtown/minecart.prefab",
            "assets/bundled/prefabs/radtown/oil_barrel.prefab",
            "assets/prefabs/npc/m2bradley/bradley_crate.prefab",
            "assets/prefabs/npc/patrol helicopter/heli_crate.prefab",
            "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab",
            "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate_oilrig.prefab",
            "assets/prefabs/misc/supply drop/supply_drop.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_normal.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_normal_2.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_elite.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_tools.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_food_2.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_ammunition.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_medical.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/crate_fuel.prefab",
            "assets/bundled/prefabs/radtown/underwater_labs/tech_parts_2.prefab",
            //"assets/prefabs/npc/scientist/scientist_corpse.prefab"
        };
        
        #endregion

        #region Permissions

        private void Init()
        {
            permission.RegisterPermission("lootchecker.use", this);
        }
        
        #endregion


        #region Language
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Item"] = "Item",
                ["Count"] = "Count",
                ["Percent"] = "Percent",
                ["Total"] = "Total",
                ["Average"] = "Average",
                ["LootExample"] = "For example: `loot.view {0}` command will show the loot for {1}",
                ["HelpMessage"] = "Below are list of available loot container types, enter the INDEX number with the loot.view command to view the loot."
            }, this);
        }
        
        #endregion


        #region Helpers

        private string GetPrefabName(string prefab)
        {
            TextInfo textInfo = new CultureInfo("en-US",false).TextInfo;
            return textInfo.ToTitleCase(prefab.Split('/').Last().Split('.').First().Replace('_',' ').Replace('-',' '));
        }
        
        private static string ToFixedLength(object obj, int length, char pad=' ')
        {
            var str = Convert.ToString(obj);
            if (str == null) return "";
            if (str.Length > length) str = str.Substring(0, length);
            return str.PadRight(length, pad);
        }
        #endregion


        #region Commands

        [Command("loot.help"), Permission("lootchecker.use")]
        private void ListPrefabsCommand(IPlayer iplayer, string command, string[] args)
        {
            iplayer.Reply(Lang("HelpMessage",iplayer.Id));
            iplayer.Reply(Lang("LootExample", iplayer.Id, DefaultPrefab, GetPrefabName(_prefabs[DefaultPrefab])));
            for (var x = 0; x < _prefabs.Count; x++)
            {
                iplayer.Reply($"{x} : {GetPrefabName(_prefabs[x])}");
            }
        }

        [Command("loot.view"), Permission("lootchecker.use")]
        private void ViewLootCommand(IPlayer iplayer, string command, string[] args)
        {
            int pindex;
            if (args.Length == 0 || !Int32.TryParse(args[0], out pindex))
            {
                pindex = DefaultPrefab;
            }
            
            var spawns = Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.PrefabName == _prefabs[pindex])
                .Where(c => c.isActiveAndEnabled)
                .ToList();
            
            Dictionary<string, int> LootQty = new Dictionary<string, int>();
            Dictionary<string, int> LootCount = new Dictionary<string, int>();
            
            foreach (var s in spawns)
            {
                if (s.inventory == null || s.inventory.itemList.Count == 0) continue;

                foreach (var item in s.inventory.itemList)
                {
                    if (item.amount <= 0) continue;
                    
                    if (!LootQty.ContainsKey(item.info.shortname))
                    {
                        LootQty.Add(item.info.shortname, item.amount);
                        LootCount.Add(item.info.shortname, 1);
                    }
                    else
                    {
                        LootQty[item.info.shortname] += item.amount;
                        LootCount[item.info.shortname]++;
                    }
                }
            }
            
            iplayer.Reply($"{GetPrefabName(_prefabs[pindex])} | {Lang("Total", iplayer.Id)} {spawns.Count}");
            
            iplayer.Reply($"| {ToFixedLength(Lang("Item", iplayer.Id),36)}| {ToFixedLength(Lang("Count", iplayer.Id),8)}| {ToFixedLength(Lang("Percent", iplayer.Id),10)}| {ToFixedLength(Lang("Total", iplayer.Id),10)}| {ToFixedLength(Lang("Average", iplayer.Id),10)}");
            iplayer.Reply($"|-{ToFixedLength("-", 36,'-')}|-{ToFixedLength("-", 8,'-')}|-{ToFixedLength("-", 10,'-')}|-{ToFixedLength("-", 10,'-')}|-{ToFixedLength("-", 10,'-')}");

            foreach (var list in LootCount.OrderByDescending(c => c.Value))
            {
                iplayer.Reply($"| {ToFixedLength(list.Key, 36)}| {ToFixedLength(list.Value, 8)}| {ToFixedLength(Math.Round(((double)list.Value / spawns.Count) * 100, 2), 10)}| {ToFixedLength(LootQty[list.Key], 10)}| {ToFixedLength(Math.Round(((double)LootQty[list.Key] / list.Value), 2), 10)}");
            }
        }

        #endregion

    }
}

// --- End of file: LootChecker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-protection ---
// --- Original File Path: L/LootProtection/LootProtection.cs ---

﻿using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Loot Protection", "Wulf", "1.0.1")]
    [Description("Protects lootables from being looted by other players")]
    class LootProtection : CovalencePlugin
    {
        #region Initialization

        private const string permBypass = "lootprotection.bypass";
        private const string permEnable = "lootprotection.enable";

        private void Init()
        {
            permission.RegisterPermission(permBypass, this);
            permission.RegisterPermission(permEnable, this);
            MigratePermission("lootprotection.corpse", permEnable);
            MigratePermission("lootprotection.sleeper", permEnable);
        }

        #endregion Initialization

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LootProtection"] = "{0} has loot protection enabled"
            }, this);
        }

        #endregion Localization

        #region Loot Protection

        private object ProtectLoot(BasePlayer looter, BaseEntity entity, string entityId, string entityName)
        {
            if (!permission.UserHasPermission(looter.UserIDString, permBypass))
            {
                if (entity != null && looter.userID != entity.OwnerID && permission.UserHasPermission(entityId, permEnable))
                {
                    NextFrame(looter.EndLooting);
                    looter.ChatMessage(string.Format(lang.GetMessage("LootProtection", this, looter.UserIDString), entityName));
                    return true;
                }
            }

            return null;
        }

        private object OnLootEntity(BasePlayer looter, BasePlayer sleeper)
        {
            return ProtectLoot(looter, sleeper, sleeper.UserIDString, sleeper.displayName);
        }

        private object OnLootEntity(BasePlayer looter, LootableCorpse corpse)
        {
            return ProtectLoot(looter, corpse, corpse.playerSteamID.ToString(), corpse.playerName);
        }

        private object OnLootEntity(BasePlayer looter, DroppedItemContainer container)
        {
            return ProtectLoot(looter, container, container.playerSteamID.ToString(), container.playerName);
        }

        #endregion Loot Protection

        #region Helpers

        private void MigratePermission(string oldPerm, string newPerm)
        {
            foreach (string groupName in permission.GetPermissionGroups(oldPerm))
            {
                permission.GrantGroupPermission(groupName, newPerm, null);
                permission.RevokeGroupPermission(groupName, oldPerm);
            }

            foreach (string playerId in permission.GetPermissionUsers(oldPerm))
            {
                permission.GrantUserPermission(Regex.Replace(playerId, "[^0-9]", ""), newPerm, null);
                permission.RevokeUserPermission(Regex.Replace(playerId, "[^0-9]", ""), oldPerm);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: LootProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/loot-despawn ---
// --- Original File Path: L/LootDespawn/LootDespawn.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Loot Despawn", "Iv Misticos", "2.0.3")]
    [Description("Customize loot despawn")]
    public class LootDespawn : RustPlugin
    {
        #region Configuration
        
        private static Configuration _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled = true;
            
            [JsonProperty(PropertyName = "Multiplier Inside Building Privilege")]
            public float MultiplierCupboard = 2;
            
            [JsonProperty(PropertyName = "Multiplier Outside Building Privilege")]
            public float MultiplierNonCupboard = 0.5f;
            
            [JsonProperty(PropertyName = "Items' Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> MultiplierItems = new Dictionary<string, float>
            {
                { "item.shortname", 1.0f }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);
        
        #endregion
        
        #region Hooks

        private void OnItemDropped(Item item, BaseEntity entity) => SetDespawnTime(item, entity as DroppedItem);
        
        #endregion

        #region Helpers
        
        private void SetDespawnTime(Item item, DroppedItem droppedItem)
        {
            if (!_config.Enabled || droppedItem == null || item?.info == null)
                return;
            
            droppedItem.CancelInvoke(nameof(DroppedItem.IdleDestroy));
            droppedItem.Invoke(nameof(DroppedItem.IdleDestroy), GetItemRate(item, droppedItem));
        }

        private float GetItemRate(Item item, DroppedItem droppedItem)
        {
            float current;
            if (!_config.MultiplierItems.TryGetValue(item.info.shortname, out current))
                current = 1.0f;

            current *= droppedItem.GetDespawnDuration() * (droppedItem.GetBuildingPrivilege() == null
                           ? _config.MultiplierNonCupboard
                           : _config.MultiplierCupboard);

            return current;
        }
        
        #endregion
    }
}

// --- End of file: LootDespawn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/balance-gui ---
// --- Original File Path: E/EconomicsBalanceGUI/EconomicsBalanceGUI.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Economics Balance GUI", "lethal_d0se & misticos", "1.1.4")]
    [Description("Displays a players economics balance on the HUD.")]
    public class EconomicsBalanceGUI : RustPlugin
    {
        // Do NOT edit this file, instead edit EconomicsBalanceGUI.json in server/<identity>/oxide/config

        [PluginReference]
        private Plugin Economics;
        private List<ulong> Looters = new List<ulong>();
        private Dictionary<ulong, double> Balances = new Dictionary<ulong, double>();
        private string GUIColor => GetConfig("GUIColor", "0.1 0.1 0.1 0.75");
        private string GUIAnchorMin => GetConfig("GUIAnchorMin", "0.024 0.04");
        private string GUIAnchorMax => GetConfig("GUIAnchorMax", "0.175 0.08");
        private string GUICurrency => GetConfig("GUICurrency", "M");
        private string GUICurrencySize => GetConfig("GUICurrencySize", "12");
        private string GUICurrencyColor => GetConfig("GUICurrencyColor", "1.0 1.0 1.0 1.0");
        private string GUIBalanceSize => GetConfig("GUIBalanceSize", "12");
        private string GUIBalanceColor => GetConfig("GUIBalanceColor", "1.0 1.0 1.0 1.0");

        private void OnServerInitialized()
        {
            if (Economics)
            {
                timer.Repeat(0.5f, 0, () =>
                {
                    if (Economics.IsLoaded)
                    {
                        foreach (BasePlayer player in BasePlayer.activePlayerList)
                        {
                            double currentBalance = Economics.Call<double>("Balance", player.UserIDString);

                            if (Balances.ContainsKey(player.userID))
                            {
                                double savedBalance = Balances[player.userID];

                                if (savedBalance != currentBalance)
                                {
                                    if (!Looters.Contains(player.userID))
                                    {
                                        Balances[player.userID] = currentBalance;
                                        GUIRefresh(player);
                                    }
                                }
                            }
                            else
                            {
                                Balances.Add(player.userID, currentBalance);
                                GUIRefresh(player);
                            }
                        }
                    }
                });
            }
        }

        private void Unload()
        {
            if (Economics)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    GUIDestroy(player);
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Plugin is loading default configuration.");

            Config["GUIColor"] = GUIColor;
            Config["GUIAnchorMin"] = GUIAnchorMin;
            Config["GUIAnchorMax"] = GUIAnchorMax;
            Config["GUICurrency"] = GUICurrency;
            Config["GUICurrencySize"] = GUICurrencySize;
            Config["GUICurrencyColor"] = GUICurrencyColor;
            Config["GUIBalanceSize"] = GUIBalanceSize;
            Config["GUIBalanceColor"] = GUIBalanceColor;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (Economics && Economics.IsLoaded)
                Balances.Add(player.userID, (double)Economics?.Call("Balance", player.UserIDString));
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (Economics) GUIRefresh(player);
        }

        // TODO: Inventory hook.
        // Figure out how to check if a player has their main inventory open, so we can do Looters.Add(player.userID) & GUIDestroy(player);

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            if (Economics)
            {
                BasePlayer player = inventory.GetComponent<BasePlayer>();
                if (player != null && Looters.Contains(player.userID))
                {
                    Looters.Remove(player.userID);
                    GUICreate(player);
                }
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (Economics) GUIDestroy(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (Economics)
            {
                GUIDestroy(player);
                Balances.Remove(player.userID);
            }
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if (Economics)
            {
                Looters.Add(looter.userID);
                GUIDestroy(looter);
            }
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer beingLooter)
        {
            if (Economics)
            {
                Looters.Add(looter.userID);
                GUIDestroy(looter);
            }
        }

        private void OnLootItem(BasePlayer looter, Item lootedItem)
        {
            if (Economics)
            {
                Looters.Add(looter.userID);
                GUIDestroy(looter);
            }
        }

        // Interface.

        private void GUICreate(BasePlayer player)
        {
            string currentBalance = (Economics.IsLoaded) ? GetFormattedMoney(player) : "...";

            var GUIElement = new CuiElementContainer();
            var GUIBackground = GUIElement.Add(new CuiPanel
            {
                Image =
                {
                    Color = GUIColor
                },
                RectTransform =
                {
                    AnchorMin = GUIAnchorMin,
                    AnchorMax = GUIAnchorMax
                },
                CursorEnabled = false
            }, "Hud", "GUIBackground");
            GUIElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = GUICurrency,
                    FontSize = int.Parse(GUICurrencySize),
                    Align = TextAnchor.MiddleCenter,
                    Color = GUICurrencyColor
                },
                RectTransform =
                {
                    AnchorMin = "0 0.1",
                    AnchorMax = "0.15 0.9"
                }
            }, GUIBackground);
            GUIElement.Add(new CuiLabel
            {
                Text =
                {
                    Text = currentBalance,
                    FontSize = int.Parse(GUIBalanceSize),
                    Align = TextAnchor.MiddleCenter,
                    Color = GUIBalanceColor
                },
                RectTransform =
                {
                    AnchorMin = "0.15 0.1",
                    AnchorMax = "1 0.9"
                }
            }, GUIBackground);

            CuiHelper.AddUi(player, GUIElement);
        }

        private void GUIDestroy(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "GUIBackground");
        }

        private void GUIRefresh(BasePlayer player)
        {
            GUIDestroy(player);
            GUICreate(player);
        }

        // Helpers.

        private string GetFormattedMoney(BasePlayer player)
        {
            string s = string.Format("{0:C}", (double)Economics?.Call("Balance", player.UserIDString));
            s = s.Substring(1);
            s = s.Remove(s.Length - 3);
            return s;
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
    }
}

// --- End of file: EconomicsBalanceGUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extra-seating ---
// --- Original File Path: E/ExtraSeating/ExtraSeating.cs ---

using UnityEngine;

namespace Oxide.Plugins {
    [Info("Extra Seating", "Pho3niX90", "1.1.2")]
    [Description("Allows extra seats on minicopters, attackcopters and horses")]
    class ExtraSeating : RustPlugin {
        #region Config
        public PluginConfig config;
        static ExtraSeating _instance;
        bool debug = false;
        int seats = 0;

        protected override void LoadDefaultConfig() { Config.WriteObject(GetDefaultConfig(), true); }
        public PluginConfig GetDefaultConfig() { return new PluginConfig { EnableMiniSideSeats = true, EnableMiniBackSeat = true, EnableExtraHorseSeat = true, EnableAttackSideSeats = true }; }
        public class PluginConfig { public bool EnableMiniSideSeats; public bool EnableMiniBackSeat; public bool EnableExtraHorseSeat; public bool EnableAttackSideSeats; }
        #endregion
        private void Init() {
            config = Config.ReadObject<PluginConfig>();
        }

        void LogDebug(string str) {
            if (debug) Puts(str);
        }

        void OnEntitySpawned(BaseNetworkable entity) {
            _instance = this;
            if (entity == null || !(entity is Minicopter || entity is RidableHorse || entity is AttackHelicopter)) return;
            BaseVehicle vehicle = entity as BaseVehicle;
            seats = vehicle.mountPoints.Count; // default

            if (entity is Minicopter && entity.ShortPrefabName.Equals("minicopter.entity"))
            {

                if (_instance.config.EnableMiniSideSeats) seats += 2;
                if (_instance.config.EnableMiniBackSeat) seats += 1;

                if (vehicle.mountPoints.Count < seats)
                    vehicle?.gameObject.AddComponent<Seating>();
            }

            if (entity is AttackHelicopter && entity.ShortPrefabName.Equals("attackhelicopter.entity"))
            {

                if (_instance.config.EnableAttackSideSeats) seats += 2;

                if (vehicle.mountPoints.Count < seats)
                    vehicle?.gameObject.AddComponent<Seating>();
            }

            if (entity is RidableHorse) {
                if (_instance.config.EnableExtraHorseSeat) seats += 1;
                if (vehicle.mountPoints.Count < seats)
                    vehicle?.gameObject.AddComponent<Seating>();
            }
        }

        void AddSeat(BaseVehicle ent, Vector3 locPos, Quaternion q) {
            BaseEntity seat = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/passengerchair.prefab", ent.transform.position, q) as BaseEntity;
            if (seat == null) return;

            seat.SetParent(ent);
            seat.Spawn();
            seat.transform.localPosition = locPos;
            seat.SendNetworkUpdateImmediate(true);
        }

        BaseVehicle.MountPointInfo CreateMount(Vector3 vec, BaseVehicle.MountPointInfo exampleSeat, Vector3 rotation) {
            return new BaseVehicle.MountPointInfo {
                pos = vec,
                rot = rotation != null ? rotation : new Vector3(0, 0, 0),
                bone = exampleSeat.bone,
                prefab = exampleSeat.prefab,
                mountable = exampleSeat.mountable
            };
        }

        #region Classes
        class HorsePassenger : BaseRidableAnimal {
            override public void PlayerServerInput(InputState inputState, BasePlayer player) {
                if (player.userID == GetDriver().userID) {
                    _instance.Puts("Player is driver");
                    base.PlayerServerInput(inputState, player);
                    return;
                }
                _instance.Puts("Player is NOT driver");
            }
        }

        class Seating : MonoBehaviour {
            public BaseVehicle entity;
            void Awake() {
                entity = GetComponent<BaseVehicle>();
                bool isMini = entity is Minicopter;
                bool isHorse = entity is RidableHorse;
                Vector3 emptyVector = new Vector3(0, 0, 0);
                if (isMini) {
                    _instance.LogDebug("Minicopter detected");
                }
                if (isHorse) {
                    _instance.LogDebug("Horse detected");
                }

                if (entity == null) { Destroy(this); return; }

                BaseVehicle.MountPointInfo pilot = entity.mountPoints[0];
                //entity.mountPoints.Clear();

                if (entity is RidableHorse) {
                    _instance.LogDebug("Adding passenger seat");
                    Vector3 horseVector = new Vector3(0f, -0.32f, -0.5f);
                    BaseVehicle.MountPointInfo horseBack = _instance.CreateMount(horseVector, pilot, emptyVector);
                    //entity.mountPoints.Add(pilot);
                    entity.mountPoints.Add(horseBack);
                    entity.SendNetworkUpdateImmediate();
                }

                if (entity is Minicopter) {
                    BaseVehicle.MountPointInfo pFront = entity.mountPoints[1];
                    Vector3 leftVector = new Vector3(0.6f, 0.2f, -0.2f);
                    Vector3 rightVector = new Vector3(-0.6f, 0.2f, -0.2f);
                    Vector3 backVector = new Vector3(0.0f, 0.4f, -1.2f);
                    Vector3 backVector2 = new Vector3(0.0f, 0.4f, -1.45f);

                    Vector3 playerOffsetVector = new Vector3(0f, 0f, -0.25f);
                    Quaternion backQuaternion = Quaternion.Euler(0f, 180f, 0f);

                    if (_instance.config.EnableMiniSideSeats) {
                        _instance.LogDebug("Adding side seats");
                        BaseVehicle.MountPointInfo pLeftSide = _instance.CreateMount(leftVector, pFront, emptyVector);
                        BaseVehicle.MountPointInfo pRightSide = _instance.CreateMount(rightVector, pFront, emptyVector);
                        entity.mountPoints.Add(pLeftSide);
                        entity.mountPoints.Add(pRightSide);
                        _instance.AddSeat(entity, leftVector + playerOffsetVector, new Quaternion());
                        _instance.AddSeat(entity, rightVector + playerOffsetVector, new Quaternion());
                    }

                    if (_instance.config.EnableMiniBackSeat) {
                        _instance.LogDebug("Adding back/rotor seat");
                        BaseVehicle.MountPointInfo pBackReverse = _instance.CreateMount(backVector2, pFront, new Vector3(0f, 180f, 0f));
                        entity.mountPoints.Add(pBackReverse);
                        _instance.AddSeat(entity, backVector, backQuaternion);
                    }
                }

                if(entity is AttackHelicopter)
                {
                    BaseVehicle.MountPointInfo pFront = entity.mountPoints[1];
                    Vector3 leftVector = new Vector3(1.1f, 0.7f, 0.3f);
                    Vector3 rightVector = new Vector3(-1.1f, 0.7f, 0.3f);

                    Vector3 playerOffsetVector = new Vector3(0f, 0f, -0.25f);

                    _instance.LogDebug("Adding side seats");
                    BaseVehicle.MountPointInfo pLeftSide = _instance.CreateMount(leftVector, pFront, emptyVector);
                    BaseVehicle.MountPointInfo pRightSide = _instance.CreateMount(rightVector, pFront, emptyVector);
                    entity.mountPoints.Add(pLeftSide);
                    entity.mountPoints.Add(pRightSide);
                    _instance.AddSeat(entity, leftVector + playerOffsetVector, new Quaternion());
                    _instance.AddSeat(entity, rightVector + playerOffsetVector, new Quaternion());
                }

            }
        }
        #endregion
    }
}


// --- End of file: ExtraSeating.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/easy-research ---
// --- Original File Path: E/EasyResearch/EasyResearch.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using WebSocketSharp;
using UnityEngine;
using System.Linq;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.EasyResearchEx;
using Rust;

/*
 *  Copyright 2022 khan
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0
 
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. 
 */

/*
* This is a re-write version 2.0.0
* Delete the old Language File and Config. (if updating from version 1x )
* Added Option to only notify that you have already researched the item.
* Added Economics Support
* Added ServerRewards Support
* Added Custom Currency options
* Updated PopupNotifications Support
* Added Sound Effect Options.
* Added Custom Currency Rust Default settings.
* Added ChatPrefix

* This update 2.0.1
Delete old lang file
* Added Research Requirement option
* Updated lang
* Added Research Duration options
* Updated Bypass permission 

* This update 2.0.2
* Added ability to set permissions to each item.
Warning will most likely over-ride the old config.
when it adds the new value. 

* This update 2.0.3
* Added Tech Tree support ( All that I can support )
* Added Block Tech Tree Researching toggle ( Default is false )
if that is false it will check if a blocked item 
is in the blocked list and block that from being unlocked as well.
if you have the bypass perm it will let you unlock the tech tree
stuff as well just like research table. 

* This update 2.0.4
* Added full Permission support to the tech tree.
* Updated Lang responses so it only shows the permission name 
and not the whole easyresearch. half 

( 2.1.0 Beta )
Beta Release for newly requested features. Stable Version 2.1.0
Added More Config Options 
Improved performance. 
Added First Time Research Cost ( if unlocking in TechTree )
Added Separate Earned amount from researching amount costs ( Research Table ) Added UI Systems for both TechTree and Research table.
( Tech Tree UI is still under work for better implementation but works for now )
Will auto take researched blueprint only if you have already learned it.
If you have not yet learned it and want to research it cheaper at the research table it will remain in there for you to take/learn.

( Beta 2.1.1 )
Beta Update 2.1.1
Fixed unlock path problem
Fixed a few UI Issues/bugs
Beta Release for newly requested features. Stable Version 2.1.0
Added More Config Options 
Improved performance. 
Added First Time Research Cost ( if unlocking in TechTree )
Added Separate Earned amount from researching amount costs ( Research Table ) Added UI Systems for both TechTree and Research table.
( Tech Tree UI is still under work for better implementation but works for now )
Will auto take researched blueprint only if you have already learned it.
If you have not yet learned it and want to research it cheaper at the research table it will remain in there for you to take/learn.

 Beta update 2.1.2
 Fixes for rust update + added support for XPerience plugin
 
 Beta Update 2.1.1
Fixed unlock path problem
Fixed a few UI Issues/bugs
Beta Release for newly requested features. Stable Version 2.1.0
Added More Config Options 
Improved performance. 

Added First Time Research Cost ( if unlocking in TechTree )
Added Separate Earned amount from researching amount costs ( Research Table ) Added UI Systems for both TechTree and Research table.
( Tech Tree UI is still under work for better implementation but works for now )

Will auto take researched blueprint only if you have already learned it.
If you have not yet learned it and want to research it cheaper at the research table it will remain in there for you to take/learn.

 ( Release stable 2.1.0 )
 * Major Update 2.1.0
 * Delete Lang File!
 * Fixes for rust update
 * Added Support for Notify By Mevent
 * Added Full Support to work with XPerience features!
 * Added Support for LangAPI
 * Fixed unlock path problem
 * Fixed a few UI Issues/bugs
 * Added More Config Options
 * Improved performance.
 * Added First Time Research Cost ( if unlocking in TechTree )
 * Added Separate Earned amount from researching amount costs ( Research Table ) 
 * Added UI Systems for both TechTree and Research table.
 * Added Random Success Chances for each item being researched ( Research Table )

 * Will auto take researched blueprint only if you have already learned it.
 * If you have not yet learned it and want to research it cheaper at the research table it will remain in there for you to take/learn.

( Tech Tree UI is still under work for better implementation but works for now )

* Update 2.1.1
 * Fixed plugin not working when xperience is not loaded.

 * Update 2.1.2
 * Fixed XPerience support
 * Fixed Plugin not working when XPerience was unloaded.
 * Fixed Tech Tree Not working properly
 * Fixed Research Table showing wrong values
 * Fixed Popup notification setting
 * Fixed Notify notification settings
 * Fixed Custom UI displays
 * Rewrote and added new hooks for XPerience plugin version 1.1.6+ update!
   Shout out to wajeeh93 for all the testing support!

 * Update 2.1.3
 * Added missing arguments to fix compilation error in rusts game update.
 * Ported changes to sync builds with Advanced Researching build.
 * Code Cleanup
 */

// TODO Update Message Systems between UI/PopUpResponses + Finish Custom UI Creation + Create UI Shop + Create UI Editor

namespace Oxide.Plugins
{
    [Info("Easy Research", "Khan", "2.1.3")]
    [Description("Adds new features to TechTree, Research Table & Research Systems")]

    public class EasyResearch : CovalencePlugin
    {
        #region License

        /*
         *  Copyright 2022 khan
        Licensed under the Apache License, Version 2.0 (the "License");
        you may not use this file except in compliance with the License.
        You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0
         
        Unless required by applicable law or agreed to in writing, software
        distributed under the License is distributed on an "AS IS" BASIS,
        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and
        limitations under the License. 
         */

        #endregion

        #region Plugin Reference

        [PluginReference]
        private Plugin PopupNotifications, Economics, ServerRewards, XPerience, Notify, LangAPI;

        #endregion

        #region Fields

        PluginConfig _confg;
        private const string UsePerm = "easyresearch.use";
        private const string ByPass = "easyresearch.bypass";

        #endregion

        #region Config

        private void CheckConfig()
        {
            foreach (ItemBlueprint item in ItemManager.GetBlueprints())
            {
                if (!item.isResearchable || item.defaultBlueprint) continue;
                if (_confg.ResearchSettings.ContainsKey(item.targetItem.shortname)) continue;
                _confg.ResearchSettings.Add(item.targetItem.shortname, new Research
                {
                    DisplayName = item.targetItem.displayName.english,
                    EarnCurrencyAmount = ResearchTable.ScrapForResearch(item.targetItem, ResearchTable.ResearchType.ResearchTable),
                    TechTreeFirstUnlockCost = ResearchTable.ScrapForResearch(item.targetItem, ResearchTable.ResearchType.TechTree),
                    CostToResearchAmount = ResearchTable.ScrapForResearch(item.targetItem, ResearchTable.ResearchType.ResearchTable),
                    ResearchDuration = item.time,
                    ResearchSuccessChance = 100
                });
            }

            SaveConfig();
        }

        private class PluginConfig
        {
            [JsonProperty("Chat Prefix")] 
            public string ChatPrefix = "<color=#32CD32>Easy Research</color>: ";
            
            [JsonProperty("Research Requirement this is the type of resource used to research items (Expects Item Shortname)")]
            public string Requirement = "scrap";
            
            [JsonProperty("Already Researched Toggle")]
            public bool Researched = false;
            
            [JsonProperty("Block Tech Tree Researching")]
            public bool BlockTechTree = false;

            [JsonProperty("Use Popup Notifications")]
            public bool Popup = false;
            
            [JsonProperty("Use Notify Notifications (Mevents Version CodeFling)")]
            public bool Notify = false;
            
            [JsonProperty("Notify Notification Type")]
            public int NotifyType = 0;

            [JsonProperty("Use CustomUI Overlay Notifications")]
            public bool CustomUI = true;

            [JsonProperty("Enable Economics")] 
            public bool Economics = true;

            [JsonProperty("Enable ServerRewards")] 
            public bool ServerRewards = false;

            [JsonProperty("Enable Custom Currency")]
            public bool Custom = false;

            [JsonProperty("Custom Name")] 
            public string CName = "";

            [JsonProperty("Custom Item ID")] 
            public int CId = 0;

            [JsonProperty("Custom SkinId")] 
            public ulong CSkinId = 0;
            
            [JsonProperty("Research Table UI Options")]
            public ResearchTableUI ResearchTableUI = new ResearchTableUI();
            
            [JsonProperty("TechTree UI Options")]
            public TechTreeUI TechTreeUI = new TechTreeUI();
            
            [JsonProperty("Blocked Items")] 
            public List<string> Blocked = new List<string>();

            [JsonProperty("Custom Research Options")]
            public Dictionary<string, Research> ResearchSettings = new Dictionary<string, Research>();

            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        public class Research
        {
            public string DisplayName;
            public double EarnCurrencyAmount;
            public int TechTreeFirstUnlockCost;
            public int CostToResearchAmount;
            public float ResearchDuration;
            public float ResearchSuccessChance = 100;
            public string SetPermission = "";
            [JsonIgnore]
            public string PrefixPermission => "easyresearch." + SetPermission;
        }

        public class ResearchTableUI
        {
            public string CostColor = "#FFFFFF";
            public string CurrencyColor = "#ff3333";
        }

        public class TechTreeUI
        {
            public string CostColor = "#ff3333";
        }

        #endregion

        #region LangSystem
        private string EasyResearchLang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AlreadyUnlocked"] = "You already unlocked {0}",
                ["AddedCurrency"] = "has deposited {0} coins into your account",
                ["Blocked"] = "{0} is not researchable",
                ["Requires"] = "New requirement for researching is now {0}",
                ["NoPerm"] = "You do not have permission {0} to research {1}",
                ["AmountTo"] = "{0} needs {1} {2} to research it",
                ["TechTreeUI"] = "{0} requires {1} {2} to research",
                ["ResearchedRolled"] = "Researching {0} Failed!",
                ["InvalidShortname"] = "Not a valid item shortname {0} set for research requirement! \n List of valid item shortnames can be found at https://www.corrosionhour.com/rust-item-list/",
                ["NowResearching"] = "Now Researching {0} for {1} {2}",
            }, this);
        }
        private void PopupMessage(IPlayer player, string message)
        {
            if (_confg.CustomUI)
            {
                player.Reply(_confg.ChatPrefix + message);
                return;
            }
            if (_confg.Popup && PopupNotifications != null)
            {
                PopupNotifications?.Call("CreatePopupNotification", _confg.ChatPrefix + message);
                return;
            }
            if (_confg.Notify && Notify.IsLoaded)
            {
                string msg = string.Format(_confg.ChatPrefix + message);
                Notify?.Call("SendNotify", player.Object as BasePlayer, _confg.NotifyType, msg);
                return;
            }
            player.Reply(_confg.ChatPrefix + message);
        }

        #endregion

        #region Oxide

        protected override void LoadDefaultConfig() => _confg = new PluginConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _confg = Config.ReadObject<PluginConfig>();
                if (_confg == null)
                {
                    throw new JsonException();
                }
                if (!_confg.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("EasyResearch Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_confg, true);

        private void Loaded()
        {
            foreach (var item in _confg.ResearchSettings.Values)
            {
                if (item.SetPermission.IsNullOrEmpty()) continue;
                
                if (permission.PermissionExists(item.PrefixPermission, this)) continue;

                permission.RegisterPermission(item.PrefixPermission, this);
            }
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(UsePerm, this);
            permission.RegisterPermission(ByPass, this);
            CheckConfig();
            UpdateResearchTables(_confg.Requirement);
        }

        private void Unload()
        {
            UpdateResearchTables();
            foreach (IPlayer player in players.Connected)
            {
                if (player != null && player.Id.IsSteamId())
                    DestroyUI(player.Object as BasePlayer);
            }
        }

        #endregion

        #region CoreSystem

        // Setting Custom Research Cost Item on newly spawned tables
        private void OnEntitySpawned(ResearchTable table)
        {
            if (permission.UserHasPermission(table.OwnerID.ToString(), UsePerm))
                table.researchResource = ItemManager.FindItemDefinition(_confg.Requirement);
        }

        // Need to make sure the ui system is clear before creating any on the Research Table
        private void OnLootEntity(BasePlayer player, ResearchTable table)
        {
            if (player == null || table == null || !player.UserIDString.IsSteamId()) return;
            if (table is ResearchTable)
            {
                DestroyUI(player);
                if (table.inventory.IsEmpty() || table.GetTargetItem() == null || table.GetTargetItem()?.amount == 0) return;
               var item = table?.inventory?.GetSlot(0);
               if (table.GetTargetItem().info.shortname == _confg.Requirement || item.isBroken || item.IsBlueprint()) return;
               if (item.amount <= 1)
                {
                    Research research = FindResearch(table.GetTargetItem().info.shortname);
                    int amount = 0;
                    if (research != null)
                    {
                        if (XPerience != null && XPerience.IsLoaded)
                            amount = XPerience.Call<int>("OnResearchCost", research.CostToResearchAmount, player);
                        else
                            amount = research.CostToResearchAmount;
                    }
                    string msg = amount > 0 ? amount.ToString() : "N/A";
                    CuiElementContainer CostContainer = new CuiElementContainer();
                    PanelUI1(ref CostContainer, "Overlay", "RCost", "0.5 0", "0.5 0", "445 292", "572 372",  Color.ToRGB("#000000"));
                    LableUI2(ref CostContainer, "RCost", "Added", Color.ToRGB(_confg.ResearchTableUI.CostColor, 1f), msg, 50, "0 0", "1 1");
                    CuiHelper.AddUi(player, CostContainer);
                }
            }
        }

        // Make sure to clean up UI System if they are done with the ResearchTable
        private void OnLootEntityEnd(BasePlayer player, ResearchTable entity)
        {
            if (player == null || entity == null || !player.UserIDString.IsSteamId()) return;
            if (entity is ResearchTable)
                DestroyUI(player);
        }

        // Checking for other benches and cleaning up before opening ui
        private void OnEntityEnter(TriggerWorkbench trigger, BasePlayer player)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return;
            DestroyUI(player);
        }

        // When they walk away from benches clean up
        private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId()) return;
            DestroyUI(player);
        }

        private Dictionary<Rarity, int> _rarity = new Dictionary<Rarity, int>
        {
            {Rarity.None, 500},
            {Rarity.Common, 20},
            {Rarity.Uncommon, 75},
            {Rarity.Rare, 125},
            {Rarity.VeryRare, 500},
        };

        private object OnResearchCostDetermine(Item item, ResearchTable researchTable)
        {
            Research research = FindResearch(item.info.shortname);
            researchTable.researchResource = ItemManager.FindItemDefinition(_confg.Requirement);

            int amount = research?.CostToResearchAmount ?? _rarity[item.info.rarity];

            if (XPerience != null && XPerience.IsLoaded)
                amount = XPerience.Call<int>("OnResearchCost", amount, researchTable.user);

            return amount;
        }

        // Update UI + Null check everything...
        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container?.entityOwner == null || container?.entityOwner is ResearchTable == false || item == null) return;
            if (container.entityOwner is ResearchTable && item.info.Blueprint != null && container.GetSlot(0) != null && container.GetSlot(0).amount > 0 && container.GetSlot(0).info.Blueprint != null && !item.IsBlueprint() && item.info.shortname != _confg.Requirement && !item.isBroken && item.info.Blueprint.isResearchable)
            {
                var table = container.entityOwner as ResearchTable;
                var player = table?.user;
                if (player != null)
                    DestroyUI(player);
                if (table == null || !table.GetTargetItem().info.Blueprint.isResearchable) return;
                Research research = FindResearch(container.GetSlot(0).info.shortname);
                int amount = 0;
                if (research != null)
                {
                    if (XPerience != null && XPerience.IsLoaded)
                        amount = XPerience.Call<int>("OnResearchCost", research.CostToResearchAmount, player);
                    else
                        amount = research.CostToResearchAmount;
                }
                string msg = amount > 0 ? amount.ToString() : "N/A";
                CuiElementContainer CostContainer = new CuiElementContainer();
                PanelUI1(ref CostContainer, "Overlay", "RCost", "0.5 0", "0.5 0", "445 292", "572 372",  Color.ToRGB("#000000"));
                LableUI2(ref CostContainer, "RCost", "Added", Color.ToRGB(_confg.ResearchTableUI.CostColor, 1f), msg, 50, "0 0", "1 1");
                CuiHelper.AddUi(player, CostContainer);

                /*int test = 0;
                if (table?.inventory?.GetSlot(1)?.amount > 0)
                {
                    test = table.GetScrapItem().amount;
                }
                if (test < amount || amount == 0)
                {
                    CuiElementContainer ButtonContainer = new CuiElementContainer();
                    PanelUI1(ref ButtonContainer, "Overlay", "Button", "0.5 0", "0.5 0", "436 116", "565 148", Color.ToRGB("#000000"));
                    LableUI2(ref ButtonContainer, "Button", "Stop", Color.ToRGB("#FFFFFF", 1f), "CANT RESEARCH", 16, "0 0", "1 1");
                    CuiHelper.AddUi(player, ButtonContainer);
                }*/
            }
        }

        // Update UI
        private void OnItemRemovedFromContainer(ItemContainer itemContainer, Item item, ResearchTable researchTable)
        {
            if (itemContainer?.entityOwner is ResearchTable)
            {
                researchTable = itemContainer?.entityOwner as ResearchTable;
            }
            if (researchTable == null && item?.parent?.entityOwner is ResearchTable)
            {
                researchTable = item?.parent?.entityOwner as ResearchTable;
            }
            if (researchTable == null) return;
            CuiHelper.DestroyUi(researchTable.user, "RCost");
            CuiHelper.DestroyUi(researchTable.user, "Button");
        }

        // Research Table Checks First 0 is item, 1 is scrap
        private object CanResearchItem(BasePlayer player, Item targetItem)
        {
            if (player == null || targetItem == null || !permission.UserHasPermission(player.UserIDString, UsePerm)) return null;
            DestroyUI(player);
            Research research = FindResearch(targetItem.info.shortname);
            if (research == null) return null;
            var itemdefinition = ItemManager.FindItemDefinition(_confg.Requirement);
            if (itemdefinition == null)
            {
                PrintError(EasyResearchLang("InvalidShortname", null, _confg.Requirement));
                return null;
            }

            string text = LangAPI?.Call<string>("GetItemDisplayName", targetItem.info.shortname, targetItem.info.displayName.english, player.UserIDString) ?? targetItem.info.displayName.english;
            string require = LangAPI?.Call<string>("GetItemDisplayName", itemdefinition.shortname, itemdefinition.displayName.english, player.UserIDString) ?? itemdefinition.displayName.english;

            if (_confg.Blocked.Contains(targetItem.info.shortname) && !permission.UserHasPermission(player.UserIDString, ByPass))
            {
                PopupMessage(player.GetPlayer(), EasyResearchLang("Blocked", player.UserIDString, text)); return false;
            }
            if (!research.SetPermission.IsNullOrEmpty() && !permission.UserHasPermission(player.UserIDString, research.PrefixPermission))
            {
                PopupMessage(player.GetPlayer(), EasyResearchLang("NoPerm", player.UserIDString, research.SetPermission, text)); return false;
            }
            if (_confg.Researched && player.blueprints.HasUnlocked(targetItem.info))
            {
                PopupMessage(player.GetPlayer(), EasyResearchLang("AlreadyUnlocked", player.UserIDString, text)); return false;
            }

            var item = targetItem?.GetRootContainer()?.GetSlot(1);

            var cost = 0;
            if (XPerience != null && XPerience.IsLoaded)
                cost = XPerience.Call<int>("OnResearchCost", research.CostToResearchAmount, player);
            else
                cost = research.CostToResearchAmount > 0 ? research.CostToResearchAmount : 0;

            if (cost == 0)
                return null;

            if (item?.info.shortname != _confg.Requirement || item?.amount < cost)
            {
                DestroyUI(player);
                CuiElementContainer menuContainer = new CuiElementContainer();
                PanelUI2(ref menuContainer, "Overlay", "Main", "0.77 0.798", "0.9465 0.835", Color.ToRGB("FFF5E1", 0.16f));
                LabelUI1(ref menuContainer, "Main", "Status", new Rectangle(0.02m, 0, 1m, 1), Color.ToRGB(_confg.ResearchTableUI.CostColor), EasyResearchLang("TechTreeUI", player.UserIDString, text, cost, require), 12);
                CuiHelper.AddUi(player, menuContainer);
                return false;
            }

            if (player.blueprints.HasUnlocked(targetItem.info) && cost > 0 && GiveCurrency(player, targetItem.info.shortname))
            {
                if (_confg.CustomUI)
                {
                    DestroyUI(player);
                    CuiElementContainer menuContainer = new CuiElementContainer();
                    PanelUI2(ref menuContainer, "Overlay", "Main", "0.77 0.798", "0.9465 0.835", Color.ToRGB("FFF5E1", 0.16f));
                    string currencymsg = String.Empty;
                    if (_confg.Economics)
                        currencymsg = "Coins";
                    if (_confg.ServerRewards)
                        currencymsg = "RP";
                    if (_confg.Custom)
                        currencymsg = ItemManager.FindItemDefinition(_confg.CId).displayName.english;
                    LabelUI1(ref menuContainer, "Main", "Status", new Rectangle(0.02m, 0, 1m, 1), Color.ToRGB(_confg.ResearchTableUI.CurrencyColor), EasyResearchLang("NowResearching", player.UserIDString, text, research.EarnCurrencyAmount, currencymsg), 12);
                    CuiHelper.AddUi(player, menuContainer);
                }
            }

            if (player.blueprints.HasUnlocked(targetItem.info))
            {
                ItemContainer container = targetItem.GetRootContainer();
                Item scrapItem = container.GetSlot(1);
                if (scrapItem.amount != cost)
                {
                    container.Remove(targetItem);
                    targetItem.Remove();
                    scrapItem.UseItem(cost);
                }
                else
                {
                    container.Remove(targetItem);
                    targetItem.Remove();
                    scrapItem.removeTime = research.ResearchDuration;
                }
            }

            return null;
        }

        // Setting Research Duration times
        private void OnItemResearch(ResearchTable table, Item targetItem, BasePlayer player)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, UsePerm)) return;
            CuiHelper.DestroyUi(player, "Button");
            Research research = FindResearch(targetItem.info.shortname);
            if (research == null) return;

            float cost = research.ResearchDuration;
            if (XPerience != null && XPerience.IsLoaded)
                cost = XPerience.Call<float>("OnItemResearchReduction", research.ResearchDuration, player);

            table.researchDuration = cost;
        }

        private float OnItemResearched(ResearchTable table, float chance)
        {
            if (table.GetTargetItem() == null) return 1;
            var item = table.GetTargetItem();
            Research research = FindResearch(item.info.shortname);
            if (research == null) return 1;

            if ((int)research.ResearchSuccessChance != 100)
            {
                if (UnityEngine.Random.Range(0, 100) >= research.ResearchSuccessChance)
                    return 1;

                BasePlayer player = table.user;

                if (player == null)
                    player = item.GetOwnerPlayer();

                if (player != null)
                {
                    string text = LangAPI?.Call<string>("GetItemDisplayName", item.info.shortname, item.info.displayName.english, player.UserIDString) ?? item.info.displayName.english;
                    PopupMessage(player.IPlayer, EasyResearchLang("ResearchedRolled", player.UserIDString, text));
                }

            }
            
            return 0;
        }

        #endregion

        #region TechTree

        // hook broken/pointless
        /*private int? OnResearchCostDetermine(ItemDefinition itemDefinition, Research research)
        {
            _confg.ResearchSettings.TryGetValue(itemDefinition.shortname, out research);
            return research?.TechTreeFirstUnlockCost;
        }*/

        // Check Unlock Path
        private bool CheckUnlockPath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
        {
            if (node.inputs.Count == 0) return true;
            var unlockPath = false;

            foreach (int nodeId in node.inputs)
            {
                var selectNode = techTree.GetByID(nodeId);
                if (selectNode.itemDef == null) return true;

                if (!techTree.HasPlayerUnlocked(player, selectNode)) continue;

                if (CheckUnlockPath(player, selectNode, techTree))
                    unlockPath = true;
            }
            
            return unlockPath;
        }

        // Checking Everything First
        private object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, UsePerm))
                return null;

            DestroyUI(player);

            if (!player.blueprints.HasUnlocked(node.itemDef) && _confg.BlockTechTree)
                return false;

            var itemdefinition = ItemManager.FindItemDefinition(_confg.Requirement);
            if (itemdefinition == null)
            {
                PrintError(EasyResearchLang("InvalidShortname", null, _confg.Requirement));
                return null;
            }
            string text = LangAPI?.Call<string>("GetItemDisplayName", node.itemDef.shortname, node.itemDef.displayName.english, player.UserIDString) ?? node.itemDef.displayName.english;
            string require = LangAPI?.Call<string>("GetItemDisplayName", itemdefinition.shortname, itemdefinition.displayName.english, player.UserIDString) ?? itemdefinition.displayName.english;

            if (_confg.Blocked.Contains(node.itemDef.shortname) && !permission.UserHasPermission(player.UserIDString, ByPass))
            {
                PopupMessage(player.IPlayer, EasyResearchLang("Blocked", player.UserIDString, text)); 
                return false;
            }

            Research research = FindResearch(node.itemDef.shortname);
            if (research == null)
                return null;

            if (!research.SetPermission.IsNullOrEmpty() && !permission.UserHasPermission(player.UserIDString, research.PrefixPermission))
            {
                PopupMessage(player.IPlayer, EasyResearchLang("NoPerm", player.UserIDString, research.SetPermission, text)); 
                return false;
            }

            CuiHelper.DestroyUi(player, "Tree");

            // Added A new Hook for Research related plugins to use specifically for the tech tree.
            // Example expects thee item amount and the player
            var cost = 0;
            if (XPerience != null && XPerience.IsLoaded)
                cost = XPerience.Call<int>("OnResearchCost", research.TechTreeFirstUnlockCost, player);
            else
                cost = research.TechTreeFirstUnlockCost > 0 ? research.TechTreeFirstUnlockCost : 0;

            if (cost == 0)
                return null;

            techTree.GetEntryNode().costOverride = cost;

            if (player.inventory.GetAmount(itemdefinition.itemid) < cost)
            {
                if (_confg.Notify || _confg.Popup)
                    PopupMessage(player.IPlayer, EasyResearchLang("TechTreeUI", player.UserIDString, text, cost, require));
                else
                {
                    CuiElementContainer menuContainer = new CuiElementContainer();
                    PanelUI2(ref menuContainer, "Overlay", "Tree", "0.807 0.198", "0.992 0.235", Color.ToRGB("FFF5E1", 0.16f));
                    LabelUI1(ref menuContainer, "Tree", "Status", new Rectangle(0.02m, 0, 1m, 1), Color.ToRGB(_confg.TechTreeUI.CostColor), EasyResearchLang("TechTreeUI", player.UserIDString, text, cost, require), 12);
                    CuiHelper.AddUi(player, menuContainer);
                }
                return false;
            }

            if (!CheckUnlockPath(player, node, techTree))
                return false;

            CuiHelper.DestroyUi(player, "Tree");
            return true;
        }

        // Final Checks Finished Taking item cost for techtree first unlock.
        private object OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
        {
            Research research = FindResearch(node.itemDef.shortname);
            if (research == null || player == null || !permission.UserHasPermission(player.UserIDString, UsePerm)) return null;
            int itemid = ItemManager.FindItemDefinition(_confg.Requirement).itemid;

            var cost = 0;
            if (XPerience != null && XPerience.IsLoaded)
                cost = XPerience.Call<int>("OnResearchCost", research.TechTreeFirstUnlockCost, player);
            else
                cost = research.TechTreeFirstUnlockCost > 0 ? research.TechTreeFirstUnlockCost : 0;

            if (cost == 0)
                return null;

            player.inventory.Take(null, itemid, cost);
            player.blueprints.Unlock(node.itemDef);
            Interface.CallHook("OnTechTreeNodeUnlocked", workbench, node, player);
            CuiHelper.DestroyUi(player, "Tree");
            return false;
        }

        #endregion

        #region CurrencySystems / Misc Helpers

        // Set || Reset Research Table Requirements
        private void UpdateResearchTables(string shortname = "scrap")
        {
            foreach (ResearchTable table in BaseNetworkable.serverEntities.OfType<ResearchTable>())
            {
                var i = ItemManager.FindItemDefinition(shortname);
                if (i != null)
                    table.researchResource = i;
            }
        }

        public Research FindResearch(string item)
        {
            Research research;
            return _confg.ResearchSettings.TryGetValue(item, out research) ? research : null;
        }

        public int PriceRounder(double amount)
        {
            if (amount <= 0.5)
            {
                return (int)Math.Ceiling(amount);
            }

            return (int)Math.Round(amount);
        }

        private void AddCurrency(BasePlayer player, double amount)
        {
            if (_confg.Economics && Economics != null)
            {
                Economics?.Call("Deposit", player.UserIDString, amount);
            }

            if (_confg.ServerRewards && ServerRewards != null)
            {
                ServerRewards?.Call("AddPoints", player.UserIDString, PriceRounder(amount));
            }

            if (_confg.Custom)
            {
                Item currency = ItemManager.CreateByItemID(_confg.CId, PriceRounder(amount), _confg.CSkinId);
                if (!_confg.CName.IsNullOrEmpty())
                {
                    currency.name = _confg.CName;
                    currency.MarkDirty();
                }

                player.GiveItem(currency);
            }
        }

        private bool GiveCurrency(BasePlayer player, string shortname)
        {
            Research item = FindResearch(shortname);

            if (item == null)
                return false;

            if (_confg.Economics && Economics != null)
            {
                AddCurrency(player, item.EarnCurrencyAmount);
                PopupMessage(player.GetPlayer(), EasyResearchLang("AddedCurrency", player.UserIDString, item.EarnCurrencyAmount));
                return true;
            }

            if (_confg.ServerRewards && ServerRewards != null)
            {
                AddCurrency(player, item.EarnCurrencyAmount);
                PopupMessage(player.GetPlayer(), EasyResearchLang("AddedCurrency", player.UserIDString, item.EarnCurrencyAmount));
                return true;
            }

            if (!_confg.Custom) return false;
            AddCurrency(player, item.EarnCurrencyAmount);
            PopupMessage(player.GetPlayer(), EasyResearchLang("AddedCurrency", player.UserIDString, item.EarnCurrencyAmount));
            return true;
        }

        #endregion

        #region UIHelpers

        public class Rectangle
        {
            public decimal Height = 1;
            public decimal Width = 1;
            public decimal X;
            public decimal Y;

            public Rectangle() { }

            public Rectangle(decimal x, decimal y, decimal width, decimal height)
            {
                X = x;
                Y = y;
                Width = width;
                Height = height;
            }

            public string GetMinAnchor() => $"{Math.Max(0, X)} {Math.Max(0, 1 - Y - Height)}";

            public string GetMaxAnchor() => $"{Math.Min(1, X + Width)} {Math.Min(1, 1 - Y)}";

            public string[] ToAnchors()
            {
                return new[]
                {
                    GetMinAnchor(),
                    GetMaxAnchor(),
                };
            }
        }

        public void PanelUI1(ref CuiElementContainer container, string parent, string name, string min, string max, string offmin, string offmax, string bgColor, bool curser = false)
        {
            container.Add(new CuiPanel
            {
                CursorEnabled = curser,
                Image =
                {
                    Color = bgColor
                },
                RectTransform =
                {
                    AnchorMin = min,
                    AnchorMax = max,
                    OffsetMin = offmin,
                    OffsetMax = offmax,
                }
            }, parent, name);
        }

        public void PanelUI2(ref CuiElementContainer container, string parent, string name, string min, string max, string bgColor, bool curser = false)
        {
            container.Add(new CuiPanel
            {
                CursorEnabled = curser,
                Image =
                {
                    Color = bgColor
                },
                RectTransform =
                {
                    AnchorMin = min,
                    AnchorMax = max,
                }
            }, parent, name);
        }

        public void LabelUI1(ref CuiElementContainer container, string parent, string name, Rectangle rectangle, string textColor, string text, int fontSize = 14, TextAnchor textAnchor = TextAnchor.MiddleCenter, bool fontbold = false)
        {
            container.Add(new CuiLabel
            {
                Text = {
                    Text = text,
                    FontSize = fontSize,
                    Color = textColor,
                    Align = textAnchor,
                    Font = fontbold ? "RobotoCondensed-Bold.ttf" : "RobotoCondensed-Regular.ttf"
                },
                RectTransform =
                {
                   AnchorMin = rectangle.GetMinAnchor(),
                   AnchorMax = rectangle.GetMaxAnchor(),
                }
            }, parent, name);
        }

        public void LableUI2(ref CuiElementContainer container, string parent, string name, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align = TextAnchor.MiddleCenter, float fadeIn = 0f)
        {
            container.Add(new CuiLabel
            {
                Text =
                {
                    Color = textColor, 
                    FontSize = fontSize, 
                    Align = align, 
                    Text = text, 
                    FadeIn = fadeIn
                },
                RectTransform =
                {
                    AnchorMin = anchorMin, 
                    AnchorMax = anchorMax
                }
            }, parent, name);
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player,"Main");
            CuiHelper.DestroyUi(player, "Status");
            CuiHelper.DestroyUi(player, "RCost");
            CuiHelper.DestroyUi(player, "Button");
            CuiHelper.DestroyUi(player, "Tree");
        }

        #endregion

        #region Color Helper

        public class Color
        {
            public string HexColor;
            public float Alpha = 1f;

            public Color(string hexColor, float alpha = 1f)
            {
                HexColor = hexColor;
                Alpha = alpha;
            }

            public static string ToRGB(string hexColor, float alpha = 1f)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }

            public string ToRGB() => ToRGB(HexColor, Alpha);
        }

        #endregion
    }

    namespace EasyResearchEx
    {
        public static class PlayerEx
        {
            //public static BasePlayer GetPlayer2(this IPlayer player) => player?.Object as BasePlayer;
            public static IPlayer GetPlayer( this BasePlayer player) => player.IPlayer;
        }   
    }
}

// --- End of file: EasyResearch.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/easy-airdrop ---
// --- Original File Path: E/EasyAirdrop/EasyAirdrop.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Easy Airdrop", "LaserHydra", "3.2.5", ResourceId = 860)]
    [Description("Call airdrops using simple commands")]
    class EasyAirdrop : RustPlugin
    {
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("easyairdrop.call", this);
            permission.RegisterPermission("easyairdrop.call.player", this);
            permission.RegisterPermission("easyairdrop.call.position", this);
            permission.RegisterPermission("easyairdrop.call.mass", this);

            LoadMessages();
            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        new void LoadConfig()
        {
            SetConfig("Settings", "Broadcast to Chat", true);
            SetConfig("Settings", "Send to Console", true);
            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>{
                { "Chat Message", "<color=red>{player}</color> has called an airdrop."}, 
                { "Console Message", "{player} has called an airdrop. {location}"},
                { "Massdrop Chat Message", "<color=red>{player}</color> has called <color=red>{amount}</color> airdrops."},
                { "Massdrop Console Message", "{player} has called {amount} airdrops."}
            }, this);
        }

        string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new config file...");
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ConsoleCommand("airdrop")]
        void ccmdAirdrop(ConsoleSystem.Arg arg)
        {
            RunAsChatCommand(arg, cmdAirdrop);
        }

        [ConsoleCommand("massdrop")]
        void ccmdMassdrop(ConsoleSystem.Arg arg)
        {
            RunAsChatCommand(arg, cmdMassdrop);
        }

        [ChatCommand("airdrop")]
        void cmdAirdrop(BasePlayer player, string cmd, string[] args)
        {
            if(args.Length == 0)
            {
                SendChatMessage(player, "/airdrop <player|pos|random>");
                return;
            }

            if(args.Length > 0)
            {
                switch(args[0].ToLower())
                {
                    case "player":

                        if (!HasPermission(player, "player"))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }

                        if (args.Length != 2)
                        {
                            SendChatMessage(player, "Syntax: /airdrop player <player>");
                            return;
                        }

                        BasePlayer target = GetPlayer(args[1], player, null);
                        if (target == null) return;

                        SpawnPlayerAirdrop(player, target);

                        break;

                    case "pos":

                        if (!HasPermission(player, "position"))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }

                        if (args.Length != 3)
                        {
                            SendChatMessage(player, "Syntax: /airdrop pos <x> <z>");
                            return;
                        }

                        float x;
                        float y = UnityEngine.Random.Range(200, 300);
                        float z;

                        try
                        {
                            x = Convert.ToSingle(args[1]);
                            z = Convert.ToSingle(args[2]);
                        }
                        catch (FormatException)
                        {
                            SendChatMessage(player, "Arguments must be numbers!");
                            return;
                        }

                        SpawnAirdrop(new Vector3(x, y, z));
                        AnnounceAirdrop(player, new Vector3(x, y, z));

                        break;

                    case "random":

                        if (!HasPermission(player))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }
                        
                        SpawnRandomAirdrop(player);

                        break;

                    default:

                        break;
                }
            }
        }

        [ChatCommand("massdrop")]
        void cmdMassdrop(BasePlayer player, string cmd, string[] args)
        {
            if(!HasPermission(player, "mass"))
            {
                SendChatMessage(player, "You don't have permission to use this command.");
                return;
            }

            if(args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /massdrop <count>");
                return;
            }

            int amount;

            try
            {
                amount = Convert.ToInt32(args[0]);
            }
            catch(FormatException)
            {
                SendChatMessage(player, "Argument must be a number!");
                return;
            }

            SpawnMassdrop(player, amount);
        }

        ////////////////////////////////////////
        ///     Airdrop Related
        ////////////////////////////////////////
        
        void SpawnPlayerAirdrop(BasePlayer player, BasePlayer target)
        {
            SpawnAirdrop(target.transform.position);

            AnnounceAirdrop(player, target.transform.position);
        }

        void SpawnMassdrop(BasePlayer player, int amount)
        {
            List<Vector3> locations = new List<Vector3>();

            for (int i = 1; i <= amount; i++)
            {
                Vector3 location = GetRandomVector();
                locations.Add(location);

                SpawnAirdrop(location);
            }

            AnnounceAirdrop(player, locations.ToArray());
        }

        void SpawnRandomAirdrop(BasePlayer player)
        {
            Vector3 position = GetRandomVector();
            SpawnAirdrop(position);

            AnnounceAirdrop(player, position);
        }

        void SpawnAirdrop(Vector3 position)
        {
            BaseEntity planeEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3(), new Quaternion(1f, 0f, 0f, 0f));

            if (planeEntity != null)
            {
                CargoPlane plane = planeEntity.GetComponent<CargoPlane>();

                plane.InitDropPosition(position);
                planeEntity.Spawn();
            }
        }

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        bool HasPermission(BasePlayer player, string perm = "")
        {
            if (player == null)
                return true;

            if (string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, "easyairdrop.call"))
                return true;
            else
            {
                if (permission.UserHasPermission(player.UserIDString, "easyairdrop.call." + perm))
                    return true;
            }

            return false;
        }

        ////////////////////////////////////////
        ///     Vector Related
        ////////////////////////////////////////

        Vector3 GetRandomVector()
        {
            float max = ConVar.Server.worldsize / 2;

            float x = UnityEngine.Random.Range(-max, max);
            float y = UnityEngine.Random.Range(200, 300);
            float z = UnityEngine.Random.Range(-max, max);

            return new Vector3(x, y, z);
        }

        ////////////////////////////////////////
        ///     Console Command Handling
        ////////////////////////////////////////

        void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command)
        {
            if (arg == null) return;

            BasePlayer player = arg?.Connection?.player == null ? null : arg?.Connection?.player as BasePlayer;
            string cmd = arg.cmd?.Name ?? "unknown";
            string[] args = arg.HasArgs() ? arg.Args : new string[0];

            command(player, cmd, args);
        }

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix = null)
        {
            List<string> foundPlayers =
                (from player in BasePlayer.activePlayerList
                 where player.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select player.displayName).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    if(prefix == null)
                        SendChatMessage(executer, "The player can not be found.");
                    else
                        SendChatMessage(executer, prefix, "The player can not be found.");

                    break;

                case 1:
                    return BasePlayer.Find(foundPlayers[0]);

                default:
                    string players = ListToString(foundPlayers, 0, ", ");

                    if (prefix == null)
                        SendChatMessage(executer, "Multiple matching players found: \n" + players);
                    else
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);

                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////
        
        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null)
        {
            if (player != null)
                SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
            else
                Puts(msg == null ? prefix : msg);
        }

        void AnnounceAirdrop(BasePlayer player, params Vector3[] locations)
        {
            string name = player == null ?  "Server" : player.displayName;
            string loc = string.Empty;
            string amount = locations.Length.ToString();

            if (locations.Length > 1)
                loc = "multiple locations";
            else
                loc = locations[0].ToString();

            string chatMessage = msg("Chat Message").Replace("{player}", name).Replace("{location}", loc);
            string consoleMessage = msg("Console Message").Replace("{player}", name).Replace("{location}", loc);

            if(locations.Length > 1)
            {
                chatMessage = msg("Massdrop Chat Message").Replace("{player}", name).Replace("{location}", loc).Replace("{amount}", amount);
                consoleMessage = msg("Massdrop Console Message").Replace("{player}", name).Replace("{location}", loc).Replace("{amount}", amount);
            }

            if ((bool) Config["Settings", "Broadcast to Chat"])
                BroadcastChat(chatMessage);

            if ((bool) Config["Settings", "Send to Console"])
                Puts(consoleMessage);
        }
    }
}

// --- End of file: EasyAirdrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/elevator-speed ---
// --- Original File Path: E/ElevatorSpeed/ElevatorSpeed.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Elevator Speed", "Lincoln", "1.0.6")]
    [Description("Adjust the speed of the elevator.")]
    public class ElevatorSpeed : RustPlugin
    {
        private const string PermUse = "ElevatorSpeed.use";
        private const string PermAdmin = "ElevatorSpeed.admin";
        private const int MinSpeed = 1;
        private static Configuration config;

        private class Configuration
        {
            [JsonProperty("Maximum Speed")]
            public int MaximumSpeed { get; set; } = 10;

            public static Configuration DefaultConfig() => new Configuration();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating new configuration file!");
            config = Configuration.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermAdmin, this);
        }

        private List<Elevator> FindElevators(BasePlayer player, float radius = 3f)
        {
            var hits = Physics.SphereCastAll(player.transform.position, radius, Vector3.up);
            var elevators = new List<Elevator>();

            foreach (var hit in hits)
            {
                var elevator = hit.GetEntity()?.GetComponent<Elevator>();
                if (elevator != null && !elevators.Contains(elevator))
                    elevators.Add(elevator);
            }

            return elevators;
        }

        [ChatCommand("ls")]
        private void LiftSpeedCommandAlt(BasePlayer player, string command, string[] args) =>
            CmdLiftSpeed(player, command, args);

        [ChatCommand("liftspeed")]
        private void LiftSpeedCommand(BasePlayer player, string command, string[] args) =>
            CmdLiftSpeed(player, command, args);

        [ChatCommand("lc")]
        private void LiftCheckCommandAlt(BasePlayer player, string command, string[] args) =>
            CmdLiftCheck(player, command, args);

        [ChatCommand("liftcheck")]
        private void LiftCheckCommand(BasePlayer player, string command, string[] args) =>
            CmdLiftCheck(player, command, args);

        private void CmdLiftSpeed(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                Message(player, "NoPerm");
                return;
            }

            if (args.Length == 0 || !int.TryParse(args[0], out int speed))
            {
                Message(player, "SpeedInvalid", config.MaximumSpeed);
                return;
            }

            var elevators = FindElevators(player);
            if (elevators.Count == 0)
            {
                Message(player, "NoElevators");
                return;
            }

            if (speed < MinSpeed || (!permission.UserHasPermission(player.UserIDString, PermAdmin) && speed > config.MaximumSpeed))
            {
                Message(player, "SpeedInvalid", config.MaximumSpeed);
                return;
            }

            bool success = false;
            foreach (var elevator in elevators)
            {
                if (permission.UserHasPermission(player.UserIDString, PermAdmin) || elevator.OwnerID == player.userID)
                {
                    elevator.LiftSpeedPerMetre = speed;
                    success = true;
                }
            }

            Message(player, success ? "SpeedUpdate" : "NotOwner", speed);
        }

        private void CmdLiftCheck(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                Message(player, "NoPerm");
                return;
            }

            var elevators = FindElevators(player);
            if (elevators.Count == 0)
            {
                Message(player, "NoElevators");
                return;
            }

            var elevator = elevators[0];
            if (permission.UserHasPermission(player.UserIDString, PermAdmin) || elevator.OwnerID == player.userID)
                Message(player, "SpeedCheck", elevator.LiftSpeedPerMetre);
            else
                Message(player, "NotOwner");
        }

        private void Message(BasePlayer player, string messageKey, params object[] args) =>
            player.ChatMessage(string.Format(lang.GetMessage(messageKey, this, player.UserIDString), args));

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>
        {
            ["NoElevators"] = "<color=#ffc34d>Elevator Speed: </color> No owned elevators found. Please stand near by your elevator.",
            ["NotOwner"] = "<color=#ffc34d>Elevator Speed: </color> You do not own this elevator.",
            ["SpeedUpdate"] = "<color=#ffc34d>Elevator Speed: </color>Updating elevator speed to <color=#b0fa66>{0}</color>.",
            ["SpeedCheck"] = "<color=#ffc34d>Elevator Speed: </color>This elevator speed is set to <color=#b0fa66>{0}</color>.",
            ["NoPerm"] = "<color=#ffc34d>Elevator Speed</color>: You do not have permissions to use this.",
            ["SpeedInvalid"] = "<color=#ffc34d>Elevator Speed</color>: Please choose a speed between <color=#b0fa66>1</color> and <color=#b0fa66>{0}</color>. Default speed is <color=#b0fa66>1</color>.",
        }, this);
    }
}


// --- End of file: ElevatorSpeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/electric-generator-tweaker ---
// --- Original File Path: E/ElectricGeneratorTweaker/ElectricGeneratorTweaker.cs ---

using System.Collections.Generic;
using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Electric Generator Tweaker", "FastBurst", "1.0.1")]
    [Description("Change Electric Generator Attributes")]

    public class ElectricGeneratorTweaker : RustPlugin
    {
        private const string PERMS = "electricgeneratortweaker.tweak";

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(PERMS, this);
        }

        private void OnServerInitialized()
        {
            if (configData.General.ElectricGeneratorWorld)
                SetAnElectricGeneratorWorld();
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            ElectricGenerator generator = entity.GetComponent<ElectricGenerator>();
            if (generator != null)
            {
                if (configData.General.enableDebug)
                    Puts($"ELECTRIC GENERATOR SPAWN!");

                bool istweaker = permission.UserHasPermission(generator.OwnerID.ToString(), PERMS);

                if (configData.General.ElectricGeneratorWorld || istweaker)
                    ElectricGeneratorTweakerizer(generator);
            }
        }
        #endregion

        #region Functions
        private void SetAnElectricGeneratorWorld()
        {
            foreach (var generator in UnityEngine.Object.FindObjectsOfType<ElectricGenerator>())
                ElectricGeneratorTweakerizer(generator);
        }

        private void ElectricGeneratorTweakerizer(ElectricGenerator generator)
        {
            if (generator.OwnerID == 0)
                return;

            generator.electricAmount = configData.Output.electricAmount;

            if (configData.General.enableDebug)
                Puts($"electricAmount {generator.electricAmount}");
        }
        #endregion

        #region Config        
        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Electric Generator")]
            public GeneralSettings General { get; set; }
            [JsonProperty(PropertyName = "Electric Generator Attributes")]
            public OutputSettings Output { get; set; }

            public class GeneralSettings
            {
                [JsonProperty(PropertyName = "Setting for all World")]
                public bool ElectricGeneratorWorld { get; set; }
                [JsonProperty(PropertyName = "Enable Debug option to console output (default false)")]
                public bool enableDebug { get; set; }
            }

            public class OutputSettings
            {
                [JsonProperty(PropertyName = "Amount of electricity (100 by default)")]
                public float electricAmount { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                General = new ConfigData.GeneralSettings
                {
                    ElectricGeneratorWorld = true,
                    enableDebug = false
                },
                Output = new ConfigData.OutputSettings
                {
                    electricAmount = 100f
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(1, 0, 0))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(1, 0, 1))
                configData.General.enableDebug = false;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

    }
}


// --- End of file: ElectricGeneratorTweaker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/enderpearl ---
// --- Original File Path: E/Enderpearl/Enderpearl.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Enderpearl", "Wolfleader101", "0.4.1")]
    [Description("Throw an ender pearl and teleport to its location")]
    class Enderpearl : RustPlugin
    {
        #region Variables

        private PluginConfig config;
        public const string enderPearlPerms = "enderpearl.use";

        #endregion

        #region Hooks

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();

            permission.RegisterPermission(enderPearlPerms, this);
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (info == null) return;
            if (!permission.UserHasPermission(attacker.UserIDString, enderPearlPerms)) return;
            if (!info.IsProjectile()) return;
            
            //var weapon = info.Weapon.GetItem();  // ONLY WORKS FOR GUNS
            //Puts(info.WeaponPrefab.name);

            string entName = info.WeaponPrefab.name;
            if (entName != config.enderpearl) return;

            Teleport(attacker, info);
        }

        #endregion

        #region Custom Methods

        void Teleport(BasePlayer attacker, HitInfo info)
        {
            Vector3 entLoc = info.HitPositionWorld;
            attacker.transform.position = entLoc;
            info.ProjectilePrefab.conditionLoss += 1f;
        }

        #endregion

        #region Config

        private class PluginConfig
        {
            [JsonProperty("Enderpearl")] public string enderpearl { get; set; }
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                enderpearl = "snowball.entity"
            };
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        #endregion
    }
}


// --- End of file: Enderpearl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/event-statistics ---
// --- Original File Path: E/EventStatistics/EventStatistics.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Event Statistics", "k1lly0u", "1.0.1"), Description("Manages and provides API for statistics gathered from EventManager")]
    public class EventStatistics : RustPlugin
    {
        #region Fields
        private DynamicConfigFile statisticsData;
        
        public static Statistics Data { get; private set; }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            statisticsData = Interface.Oxide.DataFileSystem.GetFile("EventManager/statistics_data");

            LoadData();

            Data.UpdateRankingScores();
        }

        private void OnServerSave() => SaveData();

        private void Unload()
        {
            if (!ServerMgr.Instance.Restarting)
                SaveData();

            Data = null;
        }
        #endregion

        #region API
        [HookMethod("AddStatistic")]
        public void AddStatistic(BasePlayer player, string statistic, int amount = 1) => Data.AddStatistic(player, statistic, amount);

        [HookMethod("AddStatistic")]
        public void AddStatistic(ulong playerId, string statistic, int amount = 1) => Data.AddStatistic(playerId, statistic, amount);

        [HookMethod("AddGlobalStatistic")]
        public void AddGlobalStatistic(string statistic, int amount = 1) => Data.AddGlobalStatistic(statistic, amount);

        [HookMethod("OnGamePlayed")]
        public void OnGamePlayed(string eventName) => Data.OnGamePlayed(eventName);

        [HookMethod("OnGamePlayed")]
        public void OnGamePlayed(BasePlayer player, string eventName) => Data.OnGamePlayed(player, eventName);

        [HookMethod("GetStatistic")]
        public int GetStatistic(ulong playerId, string statistic) => Data.GetStatistic(playerId, statistic);

        [HookMethod("GetRank")]
        public int GetRank(ulong playerId) => Data.GetRank(playerId);

        [HookMethod("GetEventStatistic")]
        public int GetEventStatistic(ulong playerId, string eventName) => Data.GetEventStatistic(playerId, eventName);

        [HookMethod("GetPlayerStatistics")]
        public void GetPlayerStatistics(ref List<KeyValuePair<string, int>> list, ulong playerId) => Data.GetPlayerStatistics(ref list, playerId);

        [HookMethod("GetPlayerEvents")]
        public void GetPlayerEvents(ref List<KeyValuePair<string, int>> list, ulong playerId) => Data.GetPlayerEvents(ref list, playerId);

        [HookMethod("GetGlobalStatistic")]
        public int GetGlobalStatistic(string statistic) => Data.GetGlobalStatistic(statistic);

        [HookMethod("GetGlobalEventStatistic")]
        public int GetGlobalEventStatistic(string eventName) => Data.GetGlobalEventStatistic(eventName);

        [HookMethod("GetGlobalStatistics")]
        public void GetGlobalStatistics(ref List<KeyValuePair<string, int>> list) => Data.GetGlobalStatistics(ref list);

        [HookMethod("GetGlobalEvents")]
        public void GetGlobalEvents(ref List<KeyValuePair<string, int>> list) => Data.GetGlobalEvents(ref list);

        [HookMethod("GetStatisticNames")]
        public void GetStatisticNames(ref List<string> list) => Data.GetStatisticNames(ref list);
        #endregion

        #region Helpers
        private static string RemoveTags(string str)
        {
            foreach (KeyValuePair<string, string> kvp in _tags)
            {
                if (str.StartsWith(kvp.Key) && str.Contains(kvp.Value) && str.Length > str.IndexOf(kvp.Value))
                {
                    str = str.Substring(str.IndexOf(kvp.Value) + 1).Trim();
                }
            }
            return str;
        }

        private static List<KeyValuePair<string, string>> _tags = new List<KeyValuePair<string, string>>
        {
            new KeyValuePair<string, string>("[", "]"),
            new KeyValuePair<string, string>("{", "}"),
            new KeyValuePair<string, string>("(", ")"),
            new KeyValuePair<string, string>("<", ">"),
        };
        #endregion

        #region Statistics
        public enum Statistic { Rank, Name, Kills, Deaths, Assists, Headshots, Melee, Wins, Losses, Played }

        public class Statistics
        {
            public Hash<ulong, Data> players = new Hash<ulong, Data>();

            public Data global = new Data(0UL, "Global");

            [JsonIgnore]
            private Hash<Statistic, List<Data>> _cachedSortResults = new Hash<Statistic, List<Data>>();

            public Data Find(ulong playerId)
            {
                if (players.TryGetValue(playerId, out Data data))
                    return data;
                return null;
            }            
            
            public void OnGamePlayed(string eventName)
            {
                global.AddGamePlayed(eventName);
                ClearCachedSortResults();
                UpdateRankingScores();
            }

            public void OnGamePlayed(BasePlayer player, string eventName)
            {
                if (!players.TryGetValue(player.userID, out Data data))
                    players[player.userID] = data = new Data(player.userID, player.displayName);
                else data.UpdateName(player.displayName);

                data.AddGamePlayed(eventName);

                data.UpdateRankingScore();
            }

            public void OnGamePlayed(ulong playerId, string eventName)
            {
                if (!players.TryGetValue(playerId, out Data data))
                    players[playerId] = data = new Data(playerId, "Unknown");

                data.AddGamePlayed(eventName);

                data.UpdateRankingScore();
            }

            public void AddStatistic(BasePlayer player, string statistic, int amount = 1)
            {
                global.AddStatistic(statistic, amount);

                if (!players.TryGetValue(player.userID, out Data data))
                    players[player.userID] = data = new Data(player.userID, player.displayName);

                data.AddStatistic(statistic, amount);
            }

            public void AddStatistic(ulong playerId, string statistic, int amount = 1)
            {
                global.AddStatistic(statistic, amount);

                if (!players.TryGetValue(playerId, out Data data))
                    players[playerId] = data = new Data(playerId, "Unknown");

                data.AddStatistic(statistic, amount);
            }

            public void AddGlobalStatistic(string statistic, int amount = 1)
            {
                global.AddStatistic(statistic, amount);
            }

            public int GetStatistic(ulong playerId, string statistic)
            {
                if (players.TryGetValue(playerId, out Data data))
                {
                    if (data.statistics.TryGetValue(statistic, out int amount))
                        return amount;
                }
                return 0;
            }

            public void GetPlayerStatistics(ref List<KeyValuePair<string, int>> list, ulong playerId)
            {
                if (players.TryGetValue(playerId, out Data data))                
                    list.AddRange(data.statistics);
            }

            public void GetPlayerEvents(ref List<KeyValuePair<string, int>> list, ulong playerId)
            {
                if (players.TryGetValue(playerId, out Data data))
                    list.AddRange(data.events);
            }

            public int GetRank(ulong playerId)
            {
                List<Data> list = SortStatisticsBy(Statistic.Rank);

                for (int i = 0; i < list.Count; i++)
                {
                    Data data = list[i];
                    if (data.UserID.Equals(playerId))
                        return i + 1;
                }               
                
                return -1;
            }

            public int GetEventStatistic(ulong playerId, string eventName)
            {
                if (players.TryGetValue(playerId, out Data data))
                {
                    if (data.events.TryGetValue(eventName, out int amount))
                        return amount;
                }
                return 0;
            }

            public int GetGlobalStatistic(string statistic)
            {
                if (global.statistics.TryGetValue(statistic, out int amount))
                    return amount;
                return 0;
            }

            public int GetGlobalEventStatistic(string eventName)
            {
                if (global.events.TryGetValue(eventName, out int amount))
                    return amount;
                return 0;
            }

            public void GetGlobalStatistics(ref List<KeyValuePair<string, int>> list)
            {
                list.AddRange(global.statistics);
            }

            public void GetGlobalEvents(ref List<KeyValuePair<string, int>> list)
            {
                list.AddRange(global.events);                
            }

            public void GetStatisticNames(ref List<string> list) => list.AddRange(global.statistics.Keys);

            public void ClearCachedSortResults()
            {
                foreach (KeyValuePair<Statistic, List<Data>> kvp in _cachedSortResults)
                {
                    List<Data> list = kvp.Value;
                    Facepunch.Pool.FreeUnmanaged(ref list);
                }

                _cachedSortResults.Clear();
            }

            public List<Data> SortStatisticsBy(Statistic statistic)
            {
                if (_cachedSortResults.TryGetValue(statistic, out List<Data> list))
                    return list;
                else
                {
                    _cachedSortResults[statistic] = list = Facepunch.Pool.Get<List<Data>>();

                    string statisticString = statistic.ToString();

                    list.AddRange(players.Values);
                    list.Sort(delegate (Data a, Data b)
                    {
                        if (a == null || b == null)
                            return 0;

                        switch (statistic)
                        {
                            case Statistic.Rank:
                                return a.Score.CompareTo(b.Score);
                            case Statistic.Name:
                                return a.DisplayName.CompareTo(b.DisplayName);
                            case Statistic.Kills:
                            case Statistic.Deaths:
                            case Statistic.Assists:
                            case Statistic.Headshots:
                            case Statistic.Melee:
                            case Statistic.Wins:
                            case Statistic.Losses:
                            case Statistic.Played:
                                return a.GetStatistic(statisticString).CompareTo(b.GetStatistic(statisticString));
                        }

                        return 0;
                    });

                    if (statistic != Statistic.Name)
                        list.Reverse();

                    return list;
                }
            }

            public void UpdateRankingScores()
            {
                foreach (KeyValuePair<ulong, Data> player in players)
                    player.Value.UpdateRankingScore();

                List<Data> list = SortStatisticsBy(Statistic.Rank);

                for (int i = 0; i < list.Count; i++)
                {
                    list[i].Rank = i + 1;
                }
            }

            public class Data
            {
                public Hash<string, int> events = new Hash<string, int>();

                public Hash<string, int> statistics = new Hash<string, int>()
                {
                    ["Kills"] = 0,
                    ["Deaths"] = 0,
                    ["Assists"] = 0,
                    ["Headshots"] = 0,
                    ["Melee"] = 0,
                    ["Wins"] = 0,
                    ["Losses"] = 0,
                    ["Played"] = 0
                };   
                               
                public string DisplayName { get; set; }

                public ulong UserID { get; set; }

                [JsonIgnore]
                public float Score { get; private set; }

                [JsonIgnore]
                public int Rank { get; set; }
                               
                public Data(ulong userID, string displayName)
                {
                    this.UserID = userID;
                    this.DisplayName = RemoveTags(displayName);
                }

                public void UpdateName(string displayName)
                {
                    this.DisplayName = RemoveTags(displayName);
                }

                public void AddStatistic(string statisticName, int value)
                {
                    statistics[statisticName] += value;
                }

                public void AddGamePlayed(string name)
                {
                    events[name] += 1;
                    UpdateRankingScore();
                }

                public int GetStatistic(string statistic)
                {
                    statistics.TryGetValue(statistic, out int value);
                    return value;
                }

                public void UpdateRankingScore()
                {
                    Score = 0;
                    Score += GetStatistic("Kills");
                    Score += Mathf.CeilToInt(GetStatistic("Assists") * 0.25f);
                    Score += Mathf.CeilToInt(GetStatistic("Melee") * 0.25f);
                    Score += Mathf.CeilToInt(GetStatistic("Headshots") * 0.5f);
                    Score += Mathf.CeilToInt(GetStatistic("Played") * 0.5f);
                    Score += GetStatistic("Wins") * 2;
                }
            }
        }
        #endregion

        #region Data Management
        private void SaveData() => statisticsData.WriteObject(Data);

        private void LoadData()
        {
            try
            {
                Data = statisticsData.ReadObject<Statistics>();

                if (Data == null)
                    Data = new Statistics();
            }
            catch
            {
                Data = new Statistics();
            }
        }
        #endregion
    }
}


// --- End of file: EventStatistics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/everlight ---
// --- Original File Path: E/Everlight/Everlight.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Everlight", "ohhRezyyy/Wulf/lukespragg/Arainrr", "3.5.1")]
    [Description("Allows infinite light from configured objects by not consuming fuel")]
    public class Everlight : RustPlugin
    {
        #region Fields

        private bool _enabled = true;
        private Dictionary<ulong, Item> _baseOvenFuelItems;
        private readonly Dictionary<ItemModBurnable, ItemDefinition> _itemModBurnables = new Dictionary<ItemModBurnable, ItemDefinition>();
        private readonly Dictionary<string, EverlightEntry> _everlightItems = new Dictionary<string, EverlightEntry>(StringComparer.OrdinalIgnoreCase);

        private readonly Dictionary<string, EverlightEntry> _defaultEverlightItems = new Dictionary<string, EverlightEntry>
        {
            //OnFindBurnable
            ["Barbeque"] = new EverlightEntry("bbq.deployed", new EverlightS(false, false, "everlight.bbq")),
            ["Camp Fire"] = new EverlightEntry("campfire", new EverlightS(false, false, "everlight.campfire")),
            ["Cursed Cauldron"] = new EverlightEntry("cursedcauldron.deployed", new EverlightS(false, false, "everlight.cursedcauldron")),
            ["Chinese Lantern"] = new EverlightEntry("chineselantern.deployed", new EverlightS(false, false, "everlight.chineselantern")),
            ["Stone Fireplace"] = new EverlightEntry("fireplace.deployed", new EverlightS(false, false, "everlight.fireplace")),
            ["Furnace"] = new EverlightEntry("furnace", new EverlightS(false, false, "everlight.furnace")),
            ["Large Furnace"] = new EverlightEntry("furnace.large", new EverlightS(false, false, "everlight.furnace.large")),
            ["Jack O Lantern Angry"] = new EverlightEntry("jackolantern.angry", new EverlightS(false, false, "everlight.jackolantern.angry")),
            ["Jack O Lantern Happy"] = new EverlightEntry("jackolantern.happy", new EverlightS(false, false, "everlight.jackolantern.happy")),
            ["Carvable Pumpkin"] = new EverlightEntry("carvable.pumpkin", new EverlightS(false, false, "everlight.carvable.pumpkin")),
            ["Lantern"] = new EverlightEntry("lantern.deployed", new EverlightS(false, false, "everlight.lantern")),
            ["Skull Fire Pit"] = new EverlightEntry("skull_fire_pit", new EverlightS(false, false, "everlight.skull_fire_pit")),
            ["Small Oil Refinery"] = new EverlightEntry("refinery_small_deployed", new EverlightS(false, false, "everlight.refinery_small")),
            ["Tuna Can Lamp"] = new EverlightEntry("tunalight.deployed", new EverlightS(false, false, "everlight.tunalight")),
            ["Hobo Barrel"] = new EverlightEntry("hobobarrel.deployed", new EverlightS(false, false, "everlight.hobobarrel")),
            ["Sky Lantern Green"] = new EverlightEntry("skylantern.skylantern.green", new EverlightS(false, false, "everlight.skylanterngreen")),
            ["Sky Lantern Orange"] = new EverlightEntry("skylantern.skylantern.orange", new EverlightS(false, false, "everlight.skylanternorange")),
            ["Sky Lantern Purple"] = new EverlightEntry("skylantern.skylantern.purple", new EverlightS(false, false, "everlight.skylanternpurple")),
            ["Sky Lantern Red"] = new EverlightEntry("skylantern.skylantern.red", new EverlightS(false, false, "everlight.skylanternred")),
            ["Sky Lantern"] = new EverlightEntry("skylantern.deployed", new EverlightS(false, false, "everlight.skylantern")),
            ["Chinese Lantern White"] = new EverlightEntry("chineselantern_white.deployed", new EverlightS(false, false, "everlight.chineselanternwhite")),
            ["Legacy Furnace"] = new EverlightEntry("legacy_furnace", new EverlightS(false, false, "everlight.legacyfurnace")),

            //OnLoseCondition
            ["Night Vision Goggles"] = new EverlightEntry("nightvisiongoggles", new EverlightS(false, false, "everlight.nightvisiongoggles")),
            ["Torch"] = new EverlightEntry("torch", new EverlightS(false, false, "everlight.torch")),
            ["Cultist Deer Torch"] = new EverlightEntry("torch.torch.skull", new EverlightS(false, false, "everlight.torch.torch.skull")),
            ["Abyss Torch"] = new EverlightEntry("divertorch", new EverlightS(false, false, "everlight.divertorch")),
            

            //OnItemUse,
            ["Miners Hat"] = new EverlightEntry("hat.miner", new EverlightS(false, false, "everlight.hat.miner")),
            ["Candle Hat"] = new EverlightEntry("hat.candle", new EverlightS(false, false, "everlight.hat.candle")),
            


            //OnEntitySpawned
            ["Search Light"] = new EverlightEntry("searchlight.deployed", new EverlightS(false, false, "everlight.searchlight")),
            ["Small Candle Set"] = new EverlightEntry("smallcandleset", new EverlightS(false, false, "everlight.smallcandleset")),
            ["Large Candle Set"] = new EverlightEntry("largecandleset", new EverlightS(false, false, "everlight.largecandleset")),
            ["Ceiling Light"] = new EverlightEntry("ceilinglight.deployed", new EverlightS(false, false, "everlight.ceilinglight")),
            ["Siren Light"] = new EverlightEntry("electric.sirenlight.deployed", new EverlightS(false, false, "everlight.sirenlight")),
            ["Flasher Light"] = new EverlightEntry("electric.flasherlight.deployed", new EverlightS(false, false, "everlight.flasherlight")),
            ["Simple Light"] = new EverlightEntry("simplelight", new EverlightS(false, false, "everlight.simplelight")),
            ["Strobe Light"] = new EverlightEntry("strobelight", new EverlightS(false, false, "everlight.strobelight")),
            ["Deluxe Christmas Lights"] = new EverlightEntry("xmas.advanced.lights.deployed", new EverlightS(false, false, "everlight.advanced.lights")),
            ["Igniter"] = new EverlightEntry("igniter.deployed", new EverlightS(false, false, "everlight.igniter")),
            ["Firework"] = new EverlightEntry("firework", new EverlightS(false, false, "everlight.firework")),
            ["Neon Sign"] = new EverlightEntry("neonSign", new EverlightS(false, false, "everlight.neonSign")),
            ["Industrial"] = new EverlightEntry("industrial.wall.lamp.deployed", new EverlightS(false, false, "everlight.industrial")),
            ["Industrial Green"] = new EverlightEntry("industrial.wall.lamp.green.deployed", new EverlightS(false, false, "everlight.industrialgreen")),
            ["Industrial Red"] = new EverlightEntry("industrial.wall.lamp.red.deployed", new EverlightS(false, false, "everlight.industrialred")),
            ["Electric Heater"] = new EverlightEntry("electrical.heater", new EverlightS(false, false, "everlight.electrical.heater")),
            ["Electric Furnace"] = new EverlightEntry("electricfurnace.deployed", new EverlightS(false, false, "everlight.electricfurnace.deployed")),
            ["Water Pump"] = new EverlightEntry("water.pump.deployed", new EverlightS(false, false, "everlight.water.pump.deployed")),
            //["Gunrack Horizontal"] = new EverlightEntry("gunrack.horizontal.deployed", new EverlightS(false, false, "everlight.gunrack.horizontal.deployed")),
            //["Weapon Rack Light"] = new EverlightEntry("weaponracklight", new EverlightS(false, false, "everlight.weaponracklight")),
            //["Weapon Rack Light Double"] = new EverlightEntry("weaponracklightdouble", new EverlightS(false, false, "everlight.weaponracklightdouble")),


        };

        private readonly Dictionary<string, List<string>> _hookItems = new Dictionary<string, List<string>>
        {
            [nameof(OnItemUse)] = new List<string>
            {
                "Miners Hat", "Candle Hat",
            },
            [nameof(OnLoseCondition)] = new List<string>
            {
                "Night Vision Goggles", "Torch", "Cultist Deer Torch", "Abyss Torch",
            },
            [nameof(OnEntitySpawned)] = new List<string>
            {
                "Search Light", "Small Candle Set", "Large Candle Set", "Ceiling Light", "Siren Light", "Flasher Light",
                "Simple Light", "Strobe Light", "Deluxe Christmas Lights", "Igniter", "Firework", "Neon Sign", "Industrial",
                "Industrial Green", "Industrial Red", "Electric Heater", "Electric Furnace",
	            "Water Pump", /*"Weapon Rack Light", "Weapon Rack Light Double",*/
            },
            [nameof(OnFindBurnable)] = new List<string>
            {
                "Barbeque", "Camp Fire", "Cursed Cauldron", "Chinese Lantern", "Stone Fireplace", "Furnace", "Large Furnace",
                "Jack O Lantern Angry", "Jack O Lantern Happy", "Lantern", "Skull Fire Pit", "Small Oil Refinery", "Tuna Can Lamp",
                "Hobo Barrel", "Sky Lantern Green", "Sky Lantern Orange", "Sky Lantern Purple", "Sky Lantern Red", "Sky Lantern",
	            "Carvable Pumpkin", "Chinese Lantern White", "Legacy Furnace",
            },
            [nameof(OnEntityDistanceCheck)] = new List<string>
            {
                "Barbeque", "Camp Fire", "Cursed Cauldron", "Chinese Lantern", "Stone Fireplace", "Furnace", "Large Furnace",
                "Jack O Lantern Angry", "Jack O Lantern Happy", "Lantern", "Skull Fire Pit", "Small Oil Refinery", "Tuna Can Lamp",
                "Hobo Barrel", 
            },
        };

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            UpdateConfig();
            Unsubscribe(nameof(OnItemUse));
            Unsubscribe(nameof(OnLoseCondition));
            Unsubscribe(nameof(OnEntitySpawned));
            //Unsubscribe(nameof(OnFindBurnable));
            Unsubscribe(nameof(OnEntityDistanceCheck));
            foreach (var entry in configData.EverlightList)
            {
                if (!permission.PermissionExists(entry.Value.Permission))
                {
                    permission.RegisterPermission(entry.Value.Permission, this);
                }
            }
        }

        private void OnServerInitialized()
        {
            if (configData.Global.ProduceCharcoal)
            {
                _baseOvenFuelItems = new Dictionary<ulong, Item>();
            }
            foreach (var entry in _defaultEverlightItems)
            {
                _everlightItems.Add(entry.Value.name, entry.Value);
            }
            foreach (var entry in _hookItems)
            {
                if (entry.Value.Any(x => _defaultEverlightItems[x].everlightS.Enabled))
                {
                    Subscribe(entry.Key);
                    if (entry.Key == nameof(OnEntitySpawned))
                    {
                        foreach (var serverEntity in BaseNetworkable.serverEntities)
                        {
                            OnEntitySpawned(serverEntity as BaseCombatEntity);
                        }
                    }
                }
                else
                {
                    Unsubscribe(nameof(entry.Key));
                }
            }

            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var itemModBurnable = itemDefinition.GetComponent<ItemModBurnable>();
                if (itemModBurnable != null)
                {
                    _itemModBurnables.Add(itemModBurnable, itemDefinition);
                }
            }
        }

        private void OnEntitySpawned(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity == null) return;
            if (baseCombatEntity is Candle || baseCombatEntity is IOEntity || baseCombatEntity is StrobeLight || baseCombatEntity is BaseFirework)
            {
                if (!CanEverlight(baseCombatEntity is NeonSign ? "neonSign"
                    : baseCombatEntity is BaseFirework ? "firework"
                    : baseCombatEntity.ShortPrefabName, baseCombatEntity.OwnerID.ToString())) return;
                var candle = baseCombatEntity as Candle;
                if (candle != null)
                {
                    candle.burnRate = 0f;
                    return;
                }

                var light = baseCombatEntity as StrobeLight;
                if (light != null)
                {
                    light.burnRate = 0f;
                    return;
                }

                var baseFirework = baseCombatEntity as BaseFirework;
                if (baseFirework != null)
                {
                    baseFirework.limitActiveCount = false;
                    baseFirework.StaggeredTryLightFuse();
                    baseFirework.Invoke(() => baseFirework.CancelInvoke(baseFirework.OnExhausted), baseFirework.fuseLength + 1);
                    var repeatingFirework = baseFirework as RepeatingFirework;
                    if (repeatingFirework != null)
                    {
                        repeatingFirework.maxRepeats = int.MaxValue;
                    }
                    return;
                }

                var iOEntity = (IOEntity)baseCombatEntity;
                iOEntity.UpdateHasPower(1000, 100);
                iOEntity.IOStateChanged(1000, 100);
                iOEntity.SendNetworkUpdate();

                var igniter = iOEntity as Igniter;
                if (igniter != null)
                {
                    igniter.SelfDamagePerIgnite = 0;
                }
            }
        }
        private void OnLoseCondition(Item item, ref float amount)
        {
            if (item?.info.shortname == "nightvisiongoggles")
            if (item?.info.shortname == "torch")
            if (item?.info.shortname == "torch.torch.skull")
            if (item?.info.shortname == "divertorch")
            {
                return;
            }
            var player = item.GetOwnerPlayer();
            if (player == null || !CanEverlight(item.info.shortname, player.UserIDString))
            {
                return;
            }
            amount = 0f;
        }


        private object OnFindBurnable(BaseOven baseOven)
        {
            if (baseOven == null || baseOven.net == null) return null;
            if (!CanEverlight(baseOven.ShortPrefabName, baseOven.OwnerID.ToString()))
            {
                return null;
            }

            if (configData.Global.ProduceCharcoal)
            {
                Item fuel;
                if (_baseOvenFuelItems.TryGetValue(baseOven.net.ID.Value, out fuel) && fuel.IsValid())
                {
                    return fuel;
                }
            }

            foreach (var entry in _itemModBurnables)
            {
                if (baseOven.fuelType == null || entry.Value == baseOven.fuelType)
                {
                    var fuel = ItemManager.CreateByItemID(entry.Value.itemid);
                    if (configData.Global.ProduceCharcoal)
                    {
                        if (!_baseOvenFuelItems.ContainsKey(baseOven.net.ID.Value))
                        {
                            _baseOvenFuelItems.Add(baseOven.net.ID.Value, fuel);
                        }
                        else
                        {
                            _baseOvenFuelItems[baseOven.net.ID.Value] = fuel;
                        }
                    }
                    return fuel;
                }
            }

            return null;
        }

        private void OnEntityDistanceCheck(BaseOven baseOven, BasePlayer player, uint id, string debugName, float maximumDistance)
        {
            if (id != 4167839872u || debugName != "SVSwitch")
            {
                return;
            }
            if (baseOven.Distance(player.eyes.position) > maximumDistance)
            {
                return;
            }

            if (baseOven.IsOn())
            {
                return;
            }
            var hasFuel = baseOven.inventory?.itemList?.Any(x => x.info.GetComponent<ItemModBurnable>() != null && (baseOven.fuelType == null || x.info == baseOven.fuelType));
            if (hasFuel.HasValue && hasFuel.Value)
            {
                return;
            }
            if (Interface.CallHook("OnOvenToggle", baseOven, player) == null && (!baseOven.needsBuildingPrivilegeToUse || player.CanBuild()))
            {
                if (CanEverlight(baseOven.ShortPrefabName, baseOven.OwnerID.ToString()))
                {
                    baseOven.StartCooking();
                }
            }
        }

        private object OnItemUse(Item item, int amount)
        {
            if (item?.info.shortname != "lowgradefuel")
            {
                return null;
            }
            var shortName = item.parent?.parent?.info?.shortname;
            if (shortName != "hat.candle" && shortName != "hat.miner")
            {
                return null;
            }
            var playerId = item.GetRootContainer()?.GetOwnerPlayer()?.UserIDString;
            if (!CanEverlight(shortName, playerId))
            {
                return null;
            }
            return 0;
        }

        #endregion Oxide Hooks

        #region Methods

        private bool CanEverlight(string name, string playerId)
        {
            if (!_enabled || string.IsNullOrEmpty(name))
            {
                return false;
            }
            EverlightEntry everlightEntry;
            if (_everlightItems.TryGetValue(name, out everlightEntry))
            {
                if (!everlightEntry.everlightS.Enabled)
                {
                    return false;
                }
                if (everlightEntry.everlightS.UsePermission && (string.IsNullOrEmpty(playerId) || !permission.UserHasPermission(playerId, everlightEntry.everlightS.Permission)))
                {
                    return false;
                }
                return true;
            }
            return false;
        }

        private void UpdateConfig()
        {
            foreach (var entry in _defaultEverlightItems)
            {
                EverlightS everlightS;
                if (configData.EverlightList.TryGetValue(entry.Key, out everlightS))
                {
                    entry.Value.everlightS = everlightS;
                }
                else
                {
                    configData.EverlightList.Add(entry.Key, entry.Value.everlightS);
                }
            }
            SaveConfig();
        }

        #endregion Methods

        #region ConfigurationFile

        private ConfigData configData;

        private class EverlightEntry
        {
            public string name;
            public EverlightS everlightS;

            public EverlightEntry(string name, EverlightS everlightS)
            {
                this.name = name;
                this.everlightS = everlightS;
            }
        }

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public GlobalSettings Global { get; set; } = new GlobalSettings();

            [JsonProperty(PropertyName = "Everlight entity list")]
            public Dictionary<string, EverlightS> EverlightList { get; set; } = new Dictionary<string, EverlightS>();
        }

        public class GlobalSettings
        {
            [JsonProperty(PropertyName = "Produce Charcoal")]
            public bool ProduceCharcoal { get; set; }
        }

        private class EverlightS
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; } = false;

            [JsonProperty(PropertyName = "Use permission")]
            public bool UsePermission { get; set; } = false;

            [JsonProperty(PropertyName = "Permission")]
            public string Permission { get; set; } = string.Empty;

            public EverlightS(bool enabled, bool usePermission, string permission)
            {
                this.Enabled = enabled;
                this.UsePermission = usePermission;
                this.Permission = permission;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: Everlight.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/easy-vote-highest-voter ---
// --- Original File Path: E/EasyVoteHighestvoter/EasyVoteHighestvoter.cs ---

﻿using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("EasyVote-HighestVoter", "Exel80", "1.0.2", ResourceId = 2671)]
    class EasyVoteHighestvoter : RustPlugin
    {
        // EasyVote is life and <3
        [PluginReference] private Plugin EasyVote;

        // Just make sure im no using other name...
        private const string StoredDataName = "HighestVoter";

        #region Hooks
        void onUserReceiveHighestVoterReward(Dictionary<string, object> RewardData)
        {
            // Convert to bool
            bool ReceivedReward = (bool)RewardData["ReceivedReward"];

            // Logging data to oxide/logs/EasyVoteHighestvoter
            if (config.logEnabled)
            {
                switch (RewardData["RewardType"].ToString())
                {
                    case "item":
                        {
                            LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [HighestPlayer: {RewardData["HighestPlayerName"].ToString()} Id: {RewardData["HighestPlayerID"].ToString()}] " +
                                $"Voter received his reward item(s) => {RewardData["Reward"].ToString()}", this);
                        }
                        break;
                    case "both":
                        {
                            // Items
                            LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [HighestPlayer: {RewardData["HighestPlayerName"].ToString()} Id: {RewardData["HighestPlayerID"].ToString()}] " +
                                $"Voter received his reward item(s) => {RewardData["Reward"].ToString()}", this);

                            // Group
                            // New
                            LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [HighestPlayer: {RewardData["HighestPlayerName"].ToString()} Id: {RewardData["HighestPlayerID"].ToString()}] " +
                                $"Voter has been added to his reward group => {config.group}", this);
                            // Old
                            if (!string.IsNullOrEmpty(RewardData["OldHighestPlayerID"].ToString()))
                            {
                                LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [OldHighestPlayerID: {RewardData["OldHighestPlayerID"]}] " +
                                $"Removed from his reward group => {config.group}", this);
                            }
                        }
                        break;
                    default:
                    case "group":
                        {
                            // New
                            LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [HighestPlayer: {RewardData["HighestPlayerName"].ToString()} Id: {RewardData["HighestPlayerID"].ToString()}] " +
                                $"Voter has been added to his reward group => {RewardData["Reward"].ToString()}", this);
                            // Old
                            if (!string.IsNullOrEmpty(RewardData["OldHighestPlayerID"].ToString()))
                            {
                                LogToFile("Highestvoter",
                                $"[{DateTime.UtcNow.ToString()}] [OldHighestPlayerID: {RewardData["OldHighestPlayerID"]}] " +
                                $"Removed from his reward group => {RewardData["Reward"].ToString()}", this);
                            }
                        }
                        break;
                }
            }

            // Mark that player received his reward
            _storedData.hasReceivedReward = ReceivedReward;
            Interface.GetMod().DataFileSystem.WriteObject(StoredDataName, _storedData);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            // If Highest voter havent received reward.
            if (_storedData.hasReceivedReward != true)
            {
                // If match happen
                if (player.UserIDString == _storedData.highestVoterID)
                {
                    GaveRewards(player.UserIDString);
                }
            }
        }
        #endregion

        #region Initializing
        void Init()
        {
            // Load data
            _storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(StoredDataName);

            // Start timer
            timer.Repeat(config.checkTime, 0, nextMonth);
        }

        // Now?!
        private void nextMonth()
        {
            // When new month arravie, then this protect spamming.
            bool triggered = false;

            // If month doesnt match
            if (_storedData.Month != DateTime.UtcNow.Month)
            {
                string HighestPlayer = EasyVote?.Call("getHighestvoter").ToString();
                List<string> steamIds = new List<string>();

                Puts(HighestPlayer);
                // Detect multiple IDs
                if (HighestPlayer.Contains(","))
                {
                    Puts("Detected multiple winners (more then one player has same amount of votes)");
                    foreach (var item in HighestPlayer.Split(','))
                    {
                        steamIds.Add(item);
                    }

                    System.Random rnd = new System.Random();
                    HighestPlayer = steamIds[rnd.Next(0, steamIds.Count)];
                    Puts($"Randomly picked lucky winner and the winner is => {HighestPlayer}");
                }

                if (string.IsNullOrEmpty(HighestPlayer))
                {
                    PrintWarning("HighestPlayer is NULL !!! No one have voted your server past month, updated month number.");

                    _storedData.Month = DateTime.UtcNow.Month;
                    Interface.GetMod().DataFileSystem.WriteObject(StoredDataName, _storedData);

                    return;
                }

                // TRIGGERED!
                triggered = true;

                // Gave reward + Hook
                GaveRewards(HighestPlayer);

                // Reset
                EasyVote?.Call("resetData");
            }

            // Triggered?
            if (!triggered)
                Announce();
        }
        #endregion

        #region Reward handlers
        private void GaveRewards(string HighestPlayer)
        {
            // For callhooks
            Dictionary<string, object> RewardData = new Dictionary<string, object>();
            RewardData.Add("HighestPlayerName", string.Empty);
            RewardData.Add("HighestPlayerID", HighestPlayer);

            // Check last month highest.
            string OldHighestPlayer = _storedData.highestVoterID;

            // Change this month highestID
            _storedData.highestVoterID = HighestPlayer;
            _storedData.Month = DateTime.UtcNow.Month;
            Interface.GetMod().DataFileSystem.WriteObject(StoredDataName, _storedData);

            // For callhooks
            RewardData.Add("OldHighestPlayerID", OldHighestPlayer);
            RewardData.Add("RewardType", config.rewardIs.Replace(" ", "").ToLower());
            RewardData.Add("Reward", string.Empty);
            RewardData.Add("ReceivedReward", false);

            // Try found player
            BasePlayer player = FindPlayer(HighestPlayer).FirstOrDefault();

            // If make sure that player isnt null <3
            if (player != null)
            {
                // Added for callhooks
                RewardData["HighestPlayerName"] = player.displayName;

                // Gave reward
                if (config.rewardIs.ToLower() == "item")
                {
                    RewardData = GaveItems(RewardData, player);
                }
                else if (config.rewardIs.ToLower() == "group")
                {
                    GaveGroup(HighestPlayer, OldHighestPlayer);
                    RewardData["Reward"] = config.group;
                    RewardData["ReceivedReward"] = true;
                }
                else if (config.rewardIs.ToLower() == "both")
                {
                    GaveGroup(HighestPlayer, OldHighestPlayer);
                    RewardData = GaveItems(RewardData, player);
                }
                else
                    PrintWarning($"{config.rewardIs.ToLower()} can not be detected. Please, use \"group\", \"item\" or \"both\" only!");

                // Congrats msg <3
                Congrats(player.displayName, player.UserIDString);
            }
            // Group reward
            else if (config.rewardIs.ToLower() == "group")
            {
                GaveGroup(HighestPlayer, OldHighestPlayer);

                // Congrats msg <3
                Congrats(HighestPlayer);
            }
            else
                PrintWarning($"{config.rewardIs.ToLower()} cant be detected. Please, use \"group\" or \"item\" only!");

            // Hook => void onUserReceiveHighestVoterReward(Dictionary<string, string> RewardData)
            Interface.CallHook("onUserReceiveHighestVoterReward", RewardData);
        }

        private void GaveGroup(string HighestPlayer, string OldHighestPlayer)
        {
            // Add user to group
            permission.AddUserGroup(HighestPlayer, config.group);

            // If there was old highest player, remove his from group
            if (!string.IsNullOrEmpty(OldHighestPlayer))
                permission.AddUserGroup(OldHighestPlayer, config.group);
        }

        private Dictionary<string, object> GaveItems(Dictionary<string, object> RewardData, BasePlayer player)
        {
            // Also make sure player is connected.
            if (player.IsConnected)
            {
                // Check if multiple items
                if (config.item.Contains(','))
                {
                    StringBuilder tempItems = new StringBuilder();
                    string[] RawItems = config.item.Replace(" ", "").Split(',');
                    for (int i = 0; i < RawItems.Count(); i++)
                    {
                        string[] Items = RawItems[i].Split(':');

                        string weapon = Items[0];
                        int amount = Convert.ToInt32(Items[1]);

                        try
                        {
                            Item itemToReceive = ItemManager.CreateByName(weapon, amount);

                            tempItems.Append($"{amount}x {itemToReceive.info.displayName.translated}, ");

                            RewardData["ReceivedReward"] = true;

                            //If the item does not end up in the inventory
                            //Drop it on the ground for them
                            if (!player.inventory.GiveItem(itemToReceive, player.inventory.containerMain))
                                itemToReceive.Drop(player.GetDropPosition(), player.GetDropVelocity());
                        }
                        catch (Exception e) { PrintWarning($"{e}"); }
                    }
                    RewardData["Reward"] = tempItems.ToString().Substring(0, tempItems.Length - 2);
                }
                else
                {
                    string[] Item = config.item.Split(':');

                    string weapon = Item[0];
                    int amount = Convert.ToInt32(Item[1]);

                    try
                    {
                        Item itemToReceive = ItemManager.CreateByName(weapon, amount);

                        RewardData["Reward"] = $"{amount}x {itemToReceive.info.displayName.translated}";

                        RewardData["ReceivedReward"] = true;

                        //If the item does not end up in the inventory
                        //Drop it on the ground for them
                        if (!player.inventory.GiveItem(itemToReceive, player.inventory.containerMain))
                            itemToReceive.Drop(player.GetDropPosition(), player.GetDropVelocity());
                    }
                    catch (Exception e) { PrintWarning($"{e}"); }
                }
            }
            return RewardData;
        }
        #endregion
        
        #region Localization
        string _lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["HighestGroup"] = "<color=cyan>The player with the highest number of votes per month gets a free</color> <color=yellow>{0}</color> " +
                "<color=cyan>rank for 1 month.</color> <color=yellow>/vote</color> <color=cyan>Vote now to get free rank!</color>",
                ["HighestGroupCongrats"] = "<color=yellow>{0}</color> <color=cyan>was highest voter past month.</color> <color=cyan>He earned free</color> " +
                "<color=yellow>{1}</color> <color=cyan>rank for 1 month. Vote now to earn it next month!</color>",
                ["HighestItems"] = "<color=cyan>The player with the highest number of votes per month gets </color> <color=yellow>{0}</color> " +
                "<color=cyan>to his inventory.</color> <color=yellow>/vote</color> <color=cyan>Vote now to get free stuff!</color>",
                ["HighestItemsCongrats"] = "<color=yellow>{0}</color> <color=cyan>was highest voter past month.</color> <color=cyan>He earned</color> " +
                "<color=yellow>{1}</color> <color=cyan>items. Vote now to earn it next month!</color>",
                ["HighestBoth"] = "<color=cyan>The player with the highest number of votes per month gets </color> <color=yellow>{0}</color> " +
                "<color=cyan>to his inventory &</color> <color=yellow>{1}</color> <color=cyan>rank for 1 month.</color> <color=yellow>/vote</color> <color=cyan>Vote now to get free stuff!</color>",
                ["HighestBothCongrats"] = "<color=yellow>{0}</color> <color=cyan>was highest voter past month.</color> <color=cyan>He earned</color> " +
                "<color=yellow>{1}</color> <color=cyan>items &</color> <color=yellow>{2}</color> <color=cyan>rank for 1 month. Vote now to earn it next month!</color>"
            }, this);
        }
        #endregion

        #region Storing
        class StoredData
        {
            public int Month = DateTime.UtcNow.Month;
            public string highestVoterID = string.Empty;
            public bool hasReceivedReward = false;

            public StoredData() { }
        }
        StoredData _storedData;
        #endregion

        #region Configuration
        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Enable logging, save to oxide/logs/EasyVoteHighestvoter (true / false)")]
            public bool logEnabled;

            [JsonProperty(PropertyName = "Interval timer (seconds)")]
            public int checkTime;

            [JsonProperty(PropertyName = "Highest voter reward (item, group or both)")]
            public string rewardIs;

            [JsonProperty(PropertyName = "Highest voter reward group (group name)")]
            public string group;

            [JsonProperty(PropertyName = "Highest voter reward item(s) (Item.Shortname:Amount => http://docs.oxidemod.org/rust/#item-list)")]
            public string item;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    logEnabled = true,
                    checkTime = 1800,
                    rewardIs = "group",
                    group = "hero",
                    item = "wood:1000,supply.signal:1"
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
            }
            catch
            {
                PrintWarning($"Could not read oxide/config/{Name}.json, creating new config file");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Helper 
        private void Announce()
        {
            if (config.rewardIs.ToLower() == "item")
                PrintToChat(_lang("HighestItems", null, $"\"{config.item.Replace(",", ", ")}\""));
            else if (config.rewardIs.ToLower() == "both")
                PrintToChat(_lang("HighestBoth", null, $"\"{config.item.Replace(",", ", ")}\"", config.group));
            else
                PrintToChat(_lang("HighestGroup", null, config.group));
        }

        private void Congrats(string name, string id = null)
        {
            if (config.rewardIs.ToLower() == "item")
                PrintToChat(_lang("HighestItemsCongrats", id, name, $"\"{config.item.Trim().Replace(",", ", ")}\""));
            else if (config.rewardIs.ToLower() == "both")
                PrintToChat(_lang("HighestBothCongrats", id, name, $"\"{config.item.Trim().Replace(",", ", ")}\"", config.group));
            else
                PrintToChat(_lang("HighestGroupCongrats", id, name, config.group));
        }

        private static HashSet<BasePlayer> FindPlayer(string nameOrIdOrIp)
        {
            var players = new HashSet<BasePlayer>();
            if (string.IsNullOrEmpty(nameOrIdOrIp)) return players;
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
                else if (!string.IsNullOrEmpty(activePlayer.displayName) && activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(activePlayer);
                else if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
                    players.Add(activePlayer);
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString.Equals(nameOrIdOrIp))
                    players.Add(sleepingPlayer);
                else if (!string.IsNullOrEmpty(sleepingPlayer.displayName) && sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.IgnoreCase))
                    players.Add(sleepingPlayer);
            }
            return players;
        }
        #endregion
    }
}

// --- End of file: EasyVoteHighestvoter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-owner ---
// --- Original File Path: E/EntityOwner/EntityOwner.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Owner", "Calytic", "3.4.1")]
    [Description("Modify entity ownership and cupboard/turret authorization")]
    class EntityOwner : RustPlugin
    {
        #region Data & Config
        readonly int layerMasks = LayerMask.GetMask("Construction", "Construction Trigger", "Trigger", "Deployed");

        int EntityLimit = 8000;
        float DistanceThreshold = 3f;
        float CupboardDistanceThreshold = 20f;

        bool debug;

        #endregion

        #region Data Handling & Initialization

        Dictionary<string, string> texts = new Dictionary<string, string> {
            {"Denied: Permission", "You are not allowed to use this command"},
            {"Error: Unknown", "Undefined error occurred. Look up the log for more info"},
            {"Target: None", "No target found"},
            {"Target: Owner", "Owner: {0}"},
            {"Target: Limit", "Exceeded entity limit."},
            {"Syntax: Owner", "Invalid syntax: /owner"},
            {"Syntax: SetOwner", "Incorrect Syntax.\n/setowner <playername|steamid>"},
            {"Syntax: Own", "Invalid Syntax. \n/own type player\nTypes: all/block/storage/cupboard/sign/sleepingbag/plant/oven/door/turret\n/own player"},
            {"Syntax: Unown", "Invalid Syntax. \n/unown type player\nTypes: all/block/storage/cupboard/sign/sleepingbag/plant/oven/door/turret\n/unown player"},
            {"Syntax: Prod2", "Invalid Syntax. \n/prod2 type \nTypes:\n all/block/entity/storage/cupboard/sign/sleepingbag/plant/oven/door/turret"},
            {"Syntax: Auth", "Invalid Syntax. \n/auth turret player\n/auth cupboard player/auth player\n/auth"},
            {"Syntax: Deauth", "Invalid Syntax. \n/deauth turret player\n/deauth cupboard player/deauth player\n/deauth"},
            {"Ownership: Changing", "Changing ownership.."},
            {"Ownership: Removing", "Removing ownership.."},
            {"Ownership: New", "New owner of all around is: {0}"},
            {"Ownership: New Self", "Owner: You were given ownership of this house and nearby deployables"},
            {"Ownership: Count", "Count ({0})"},
            {"Ownership: Removed", "Ownership removed"},
            {"Ownership: Changed", "Ownership changed"},
            {"Entities: None", "No entities found."},
            {"Entities: Authorized", "({0}) Authorized"},
            {"Entities: Count", "Counted {0} entities ({1}/{2})"},
            {"Structure: Prodding","Prodding structure.."},
            {"Structure: Condition Percent", "Condition: {0}%"},
            {"Player: Unknown Percent", "Unknown: {0}%"},
            {"Player: None", "Target player not found"},
            {"Cupboards: Prodding", "Prodding cupboards.."},
            {"Cupboards: Authorizing", "Authorizing cupboards.."},
            {"Cupboards: Authorized", "Authorized {0} on {1} cupboards"},
            {"Cupboards: Deauthorizing", "Deauthorizing cupboards.."},
            {"Cupboard: Deauthorized", "Deauthorized {0} on {1} cupboards"},
            {"Turrets: Authorized", "Authorized {0} on {1} turrets"},
            {"Turrets: Authorizing", "Authorizing turrets.."},
            {"Turrets: Prodding", "Prodding turrets.."},
            {"Turrets: Deauthorized", "Deauthorized {0} on {1} turrets"},
            {"Turrets: Deauthorizing", "Deauthorizing turrets.."},
            {"Lock: Code", "Code: {0}"},
            {"Lock: Owner", "Lock owner: {0}"},
            {"Bag: Assignee", "Assigned: {0}"}
        };

        // Loads the default configuration
        protected override void LoadDefaultConfig()
        {
            Config["Debug"] = false;
            Config["EntityLimit"] = EntityLimit;
            Config["DistanceThreshold"] = DistanceThreshold;
            Config["CupboardDistanceThreshold"] = CupboardDistanceThreshold;
            Config["VERSION"] = Version.ToString();
            Config.Save();
        }

        new void LoadDefaultMessages()
        {
            lang.RegisterMessages(texts, this);
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["Debug"] = false;
            Config["EntityLimit"] = EntityLimit;
            Config["DistanceThreshold"] = DistanceThreshold;
            Config["CupboardDistanceThreshold"] = CupboardDistanceThreshold;
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading Configuration File");
            SaveConfig();
        }

        // Gets a config value of a specific type
        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string GetMsg(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player == null ? null : player.UserIDString);
        }

        void OnServerInitialized()
        {
            try
            {
                LoadConfig();

                debug = GetConfig("Debug", false);
                EntityLimit = GetConfig("EntityLimit", 8000);
                DistanceThreshold = GetConfig("DistanceThreshold", 3f);
                CupboardDistanceThreshold = GetConfig("CupboardDistanceThreshold", 20f);

                if (DistanceThreshold >= 5)
                {
                    PrintWarning("ALERT: Distance threshold configuration option is ABOVE 5.  This may cause serious performance degradation (lag) when using EntityOwner commands");
                }

                permission.RegisterPermission("entityowner.cancheckowners", this);
                permission.RegisterPermission("entityowner.cancheckcodes", this);
                permission.RegisterPermission("entityowner.canchangeowners", this);
                permission.RegisterPermission("entityowner.seedetails", this);

                LoadData();
            }
            catch (Exception ex)
            {
                PrintError("OnServerInitialized failed: {0}", ex.Message);
            }
        }

        void LoadData()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig("VERSION", Version.ToString()) != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        [HookMethod("SendHelpText")]
        void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            if (canCheckOwners(player) || canChangeOwners(player))
            {
                sb.Append("<size=18>EntityOwner</size> by <color=#ce422b>Calytic</color> at <color=#ce422b>http://rustservers.io</color>\n");
            }

            if (canCheckOwners(player))
            {
                sb.Append("  ").Append("<color=\"#ffd479\">/prod</color> - Check ownership of entity you are looking at").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/prod2</color> - Check ownership of entire structure/all deployables").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/prod2 block</color> - Check ownership structure only").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/prod2 cupboard</color> - Check authorization on all nearby cupboards").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/auth</color> - Check authorization list of tool cupboard you are looking at").Append("\n");
            }

            if (canChangeOwners(player))
            {
                sb.Append("  ").Append("<color=\"#ffd479\">/own [all/block]</color> - Take ownership of entire structure").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/own [all/block] PlayerName</color> - Give ownership of entire structure to specified player").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/unown [all/block]</color> - Remove ownership from entire structure").Append("\n");
                sb.Append("  ").Append("<color=\"#ffd479\">/auth PlayerName</color> - Authorize specified player on all nearby cupboards").Append("\n");
            }

            SendReply(player, sb.ToString());
        }

        #endregion



        #region Chat Commands

        [ChatCommand("prod")]
        void cmdProd(BasePlayer player, string command, string[] args)
        {
            if (!canCheckOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }
            if (args == null || args.Length == 0)
            {
                //var input = serverinput.GetValue(player) as InputState;
                //var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
                //var target = RaycastAll<BaseEntity>(player.transform.position + new Vector3(0f, 1.5f, 0f), currentRot);
                var target = RaycastAll<BaseEntity>(player.eyes.HeadRay());
                if (target is bool)
                {
                    SendReply(player, GetMsg("Target: None", player));
                    return;
                }
                if (target is BaseEntity)
                {
                    var targetEntity = target as BaseEntity;
                    var owner = GetOwnerName((BaseEntity)target);
                    if (string.IsNullOrEmpty(owner))
                    {
                        owner = "N/A";
                    }

                    string msg = string.Format(GetMsg("Target: Owner", player), owner);

                    var baseLock = targetEntity.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
                    if (baseLock != null)
                    {
                        if (baseLock.OwnerID != 0 && baseLock.OwnerID != targetEntity.OwnerID)
                        {
                            var lockOwnerName = GetOwnerName(baseLock);
                            msg += "\n" + string.Format(GetMsg("Lock: Owner", player), lockOwnerName);
                        }
                    }

                    if (canSeeDetails(player))
                    {
                        msg += "\n<color=#D3D3D3>Name: " + targetEntity.ShortPrefabName + "</color>";
                        if (targetEntity.skinID > 0)
                        {
                            msg += "\n<color=#D3D3D3>Skin: " + targetEntity.skinID + "</color>";
                        }

                        if (targetEntity.PrefabName != targetEntity.ShortPrefabName)
                        {
                            msg += "\n<color=#D3D3D3>Prefab: \"" + targetEntity.PrefabName + "\"</color>";
                        }

                        msg += "\n<color=#D3D3D3>Outside: " + (targetEntity.IsOutside() ? "Yes" : "No") + "</color>";
                    }

                    if (canCheckCodes(player))
                    {
                        var codeLock = baseLock as CodeLock;
                        if (codeLock != null)
                        {
                            string keyCode = codeLock.code;
                            msg += "\n" + string.Format(GetMsg("Lock: Code", player), keyCode);
                        }
                    }

                    if (canCheckAssignee(player))
                    {
                        if (targetEntity is SleepingBag)
                        {
                            SleepingBag bag = (SleepingBag)targetEntity;
                            msg += "\n" + string.Format(GetMsg("Bag: Assignee", player), FindPlayerName(bag.deployerUserID));
                        }
                    }

                    SendReply(player, msg);
                }
            }
            else
            {
                SendReply(player, GetMsg("Syntax: Owner", player));
            }
        }


        //or any wanted new chat command. maybe even integrated in existing /own
        //this one will only change ownership of the one particular entity you are looking at
        [ChatCommand("setowner")]
        void cmdSetowner(BasePlayer player, string command, string[] args)
        {
            //check if user has permission
            if (!canChangeOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            //check if given argument exists and is not empty
            if (string.IsNullOrEmpty(args[0]))
            {
                SendReply(player, GetMsg("Syntax: SetOwner", player));
                return;
            }

            //getting valid UserID
            ulong new_ownerid = FindUserIDByPartialName(args[0].ToString());
            if (new_ownerid == 0)
            {
                SendReply(player, GetMsg("Player: None", player));
                return;
            }

            try
            {
                //try to get the entity user is looking at
                var target_entity = RaycastAll<BaseEntity>(player.eyes.HeadRay());

                if (target_entity is bool)
                {
                    SendReply(player, GetMsg("Target: None", player));
                    return;
                }
                else if (target_entity is BaseEntity)
                {
                    //just to make future usage of the var easier
                    var target_BaseEntity = target_entity as BaseEntity;
                    try
                    {
                        //get the current owner
                        var old_owner = GetOwnerName(target_BaseEntity);
                        if (string.IsNullOrEmpty(old_owner))
                        {
                            old_owner = "N/A";
                        }

                        ChangeOwner(target_BaseEntity, new_ownerid);

                        //check if the owner was actually changed
                        var new_owner = GetOwnerName(target_BaseEntity);
                        if (string.IsNullOrEmpty(new_owner))
                        {
                            new_owner = "N/A";
                        }

                        SendReply(player, "Changed owner of [" + target_BaseEntity.ShortPrefabName + "] from [" + old_owner + "] to [" + new_owner + "]");

                    }
                    catch (Exception ex)
                    {
                        SendReply(player, GetMsg("Error: Unknown", player));
                        Debug.LogException(ex);
                    }
                }
            }
            catch (Exception ex)
            {
                SendReply(player, GetMsg("Error: Unknown", player));
                Debug.LogException(ex);
            }
        }

        [ChatCommand("own")]
        void cmdOwn(BasePlayer player, string command, string[] args)
        {
            if (!canChangeOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            var massTrigger = false;
            string type = null;
            ulong target = player.userID;

            if (args.Length == 0)
            {
                args = new string[1] { "1" };
            }
            if (args.Length > 2)
            {
                SendReply(player, GetMsg("Syntax: Own", player));
                return;
            }
            if (args.Length == 1)
            {
                if (type == "all" || type == "storage" || type == "block" || type == "cupboard" || type == "sign" || type == "sleepingbag" || type == "plant" || type == "oven" || type == "door" || type == "turret")
                {
                    massTrigger = true;
                    target = player.userID;
                }
                else if (!string.IsNullOrEmpty(type))
                {
                    target = FindUserIDByPartialName(type);
                    type = "1";
                    if (target == 0)
                    {
                        SendReply(player, GetMsg("Player: None", player));
                    }
                    else
                    {
                        massTrigger = true;
                    }
                }
                else
                {
                    massTrigger = true;
                    type = "1";
                }
            }
            else if (args.Length == 2)
            {
                type = args[0];
                target = FindUserIDByPartialName(args[1]);
                if (target == 0)
                {
                    SendReply(player, GetMsg("Player: None", player));
                }
                else
                {
                    massTrigger = true;
                }
            }

            if (!massTrigger || type == null) return;
            switch (type)
            {
                case "1":
                    BaseEntity entity;
                    if (TryGetEntity<BaseEntity>(player, out entity))
                    {
                        ChangeOwner(entity, target);
                        SendReply(player, GetMsg("Ownership: Changed", player));
                    }
                    else
                    {
                        SendReply(player, GetMsg("Target: None", player));
                    }
                    break;
                case "all":
                    massChangeOwner<BaseEntity>(player, target);
                    break;
                case "block":
                    massChangeOwner<BuildingBlock>(player, target);
                    break;
                case "storage":
                    massChangeOwner<StorageContainer>(player, target);
                    break;
                case "sign":
                    massChangeOwner<Signage>(player, target);
                    break;
                case "sleepingbag":
                    massChangeOwner<SleepingBag>(player, target);
                    break;
                case "plant":
                    massChangeOwner<GrowableEntity>(player, target);
                    break;
                case "oven":
                    massChangeOwner<BaseOven>(player, target);
                    break;
                case "turret":
                    massChangeOwner<AutoTurret>(player, target);
                    break;
                case "door":
                    massChangeOwner<Door>(player, target);
                    break;
                case "cupboard":
                    massChangeOwner<BuildingPrivlidge>(player, target);
                    break;
            }
        }

        [ChatCommand("unown")]
        void cmdUnown(BasePlayer player, string command, string[] args)
        {
            if (!canChangeOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            if (args.Length == 0)
            {
                args = new[] { "1" };
            }

            if (args.Length > 1)
            {
                SendReply(player, GetMsg("Syntax: Unown", player));
                return;
            }
            if (args.Length != 1) return;
            switch (args[0])
            {
                case "1":
                    BaseEntity entity;
                    if (TryGetEntity<BaseEntity>(player, out entity))
                    {
                        RemoveOwner(entity);
                        SendReply(player, GetMsg("Ownership: Removed", player));
                    }
                    else
                    {
                        SendReply(player, GetMsg("Target: None", player));
                    }
                    break;
                case "all":
                    massChangeOwner<BaseEntity>(player);
                    break;
                case "block":
                    massChangeOwner<BuildingBlock>(player);
                    break;
                case "storage":
                    massChangeOwner<StorageContainer>(player);
                    break;
                case "sign":
                    massChangeOwner<Signage>(player);
                    break;
                case "sleepingbag":
                    massChangeOwner<SleepingBag>(player);
                    break;
                case "plant":
                    massChangeOwner<GrowableEntity>(player);
                    break;
                case "oven":
                    massChangeOwner<BaseOven>(player);
                    break;
                case "turret":
                    massChangeOwner<AutoTurret>(player);
                    break;
                case "door":
                    massChangeOwner<Door>(player);
                    break;
                case "cupboard":
                    massChangeOwner<BuildingPrivlidge>(player);
                    break;
            }
        }

        [ChatCommand("auth")]
        void cmdAuth(BasePlayer player, string command, string[] args)
        {
            if (!canChangeOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            var massCupboard = false;
            var massTurret = false;
            var checkCupboard = false;
            var checkTurret = false;
            var error = false;
            BasePlayer target = null;

            if (args.Length > 2)
            {
                error = true;
            }
            else if (args.Length == 1)
            {
                if (args[0] == "cupboard")
                {
                    checkCupboard = true;
                }
                else if (args[0] == "turret")
                {
                    checkTurret = true;
                }
                else
                {
                    massCupboard = true;
                    target = FindPlayerByPartialName(args[0]);
                }
            }
            else if (args.Length == 0)
            {
                checkCupboard = true;
            }
            else if (args.Length == 2)
            {
                if (args[0] == "cupboard")
                {
                    massCupboard = true;
                    target = FindPlayerByPartialName(args[1]);
                }
                else if (args[0] == "turret")
                {
                    massTurret = true;
                    target = FindPlayerByPartialName(args[1]);
                }
                else
                {
                    error = true;
                }
            }

            if ((massTurret || massCupboard) && target?.net?.connection == null)
            {
                SendReply(player, GetMsg("Player: None", player));
                return;
            }

            if (error)
            {
                SendReply(player, GetMsg("Syntax: Auth", player));
                return;
            }

            if (massCupboard)
            {
                massCupboardAuthorize(player, target);
            }

            if (checkCupboard)
            {
                var priv = RaycastAll<BuildingPrivlidge>(player.eyes.HeadRay());
                if (priv is bool)
                {
                    SendReply(player, GetMsg("Target: None", player));
                    return;
                }
                if (priv is BuildingPrivlidge)
                {
                    ProdCupboard(player, (BuildingPrivlidge)priv);
                }
            }

            if (massTurret)
            {
                massTurretAuthorize(player, target);
            }

            if (checkTurret)
            {
                var turret = RaycastAll<AutoTurret>(player.eyes.HeadRay());
                if (turret is bool)
                {
                    SendReply(player, GetMsg("Target: None", player));
                    return;
                }
                if (turret is AutoTurret)
                {
                    ProdTurret(player, (AutoTurret)turret);
                }
            }
        }

        [ChatCommand("deauth")]
        void cmdDeauth(BasePlayer player, string command, string[] args)
        {
            if (!canChangeOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            var massCupboard = false;
            var massTurret = false;
            var error = false;
            BasePlayer target = null;

            if (args.Length > 2)
            {
                error = true;
            }
            else if (args.Length == 1)
            {
                if (args[0] == "cupboard")
                {
                    SendReply(player, "Invalid Syntax. /deauth cupboard PlayerName");
                    return;
                }
                if (args[0] == "turret")
                {
                    SendReply(player, "Invalid Syntax. /deauth turret PlayerName");
                    return;
                }

                massCupboard = true;
                target = FindPlayerByPartialName(args[0]);
            }
            else if (args.Length == 0)
            {
                SendReply(player, "Invalid Syntax. /deauth PlayerName\n/deauth turret/cupboard PlayerName");
                return;
            }
            else if (args.Length == 2)
            {
                if (args[0] == "cupboard")
                {
                    massCupboard = true;
                    target = FindPlayerByPartialName(args[1]);
                }
                else if (args[0] == "turret")
                {
                    massTurret = true;
                    target = FindPlayerByPartialName(args[1]);
                }
                else
                {
                    error = true;
                }
            }

            if ((massTurret || massCupboard) && target?.net?.connection == null)
            {
                SendReply(player, GetMsg("Player: None", player));
                return;
            }

            if (error)
            {
                SendReply(player, GetMsg("Syntax: Deauth", player));
                return;
            }

            if (massCupboard)
            {
                massCupboardDeauthorize(player, target);
            }

            if (massTurret)
            {
                massTurretDeauthorize(player, target);
            }
        }

        [ChatCommand("prod2")]
        void cmdProd2(BasePlayer player, string command, string[] args)
        {
            if (!canCheckOwners(player))
            {
                SendReply(player, GetMsg("Denied: Permission", player));
                return;
            }

            bool highlight = false;
            if (args.Length > 0)
            {
                if (args[0] == "highlight")
                {
                    highlight = true;
                    args = args.Skip(1).ToArray();
                }
                if (args.Length == 0)
                {
                    massProd<BaseEntity>(player, highlight);
                    return;
                }

                switch (args[0])
                {
                    case "all":
                        args = args.Skip(1).ToArray();
                        massProd<BaseEntity>(player, highlight, args);
                        break;
                    case "block":
                        massProd<BuildingBlock>(player, highlight);
                        break;
                    case "storage":
                        massProd<StorageContainer>(player, highlight);
                        break;
                    case "sign":
                        massProd<Signage>(player, highlight);
                        break;
                    case "sleepingbag":
                        massProd<SleepingBag>(player, highlight);
                        break;
                    case "plant":
                        massProd<GrowableEntity>(player, highlight);
                        break;
                    case "oven":
                        massProd<BaseOven>(player, highlight);
                        break;
                    case "turret":
                        massProdTurret(player, highlight);
                        break;
                    case "cupboard":
                        massProdCupboard(player, highlight);
                        break;
                    default:
                        massProd<BaseEntity>(player, highlight, args);
                        break;
                }
            }
            else if (args.Length == 0)
            {
                massProd<BaseEntity>(player);
            }
            else
            {
                SendReply(player, GetMsg("Syntax: Prod2", player));
            }
        }

        #endregion

        #region Permission Checks

        bool canCheckOwners(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel > 0) return true;
            return permission.UserHasPermission(player.UserIDString, "entityowner.cancheckowners");
        }

        bool canCheckCodes(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel > 0) return true;
            return permission.UserHasPermission(player.UserIDString, "entityowner.cancheckcodes");
        }

        bool canCheckAssignee(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel > 0) return true;
            return permission.UserHasPermission(player.UserIDString, "entityowner.cancheckassignee");
        }

        bool canSeeDetails(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel > 0) return true;
            return permission.UserHasPermission(player.UserIDString, "entityowner.seedetails");
        }

        bool canChangeOwners(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel > 0) return true;
            return permission.UserHasPermission(player.UserIDString, "entityowner.canchangeowners");
        }

        #endregion

        #region Ownership Methods

        bool TryGetEntity<T>(BasePlayer player, out BaseEntity entity) where T : BaseEntity
        {
            entity = null;

            var target = RaycastAll<BaseEntity>(player.eyes.HeadRay());

            if (target is T)
            {
                entity = target as T;
                return true;
            }

            return false;
        }

        void massChangeOwner<T>(BasePlayer player, ulong target = 0) where T : BaseEntity
        {
            object entityObject = false;

            if (typeof(T) == typeof(BuildingBlock))
            {
                entityObject = FindBuilding(player.transform.position, DistanceThreshold);
            }
            else
            {
                entityObject = FindEntity(player.transform.position, DistanceThreshold);
            }

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                if (target == 0)
                {
                    SendReply(player, GetMsg("Ownership: Removing", player));
                }
                else
                {
                    SendReply(player, GetMsg("Ownership: Changing", player));
                }

                var entity = entityObject as T;
                var entityList = new HashSet<T>();
                var checkFrom = new List<Vector3>();
                entityList.Add((T)entity);
                checkFrom.Add(entity.transform.position);
                var c = 1;
                if (target == 0)
                {
                    RemoveOwner(entity);
                }
                else
                {
                    ChangeOwner(entity, target);
                }
                var current = 0;
                var bbs = 0;
                var ebs = 0;
                if (entity is BuildingBlock)
                {
                    bbs++;
                }
                else
                {
                    ebs++;
                }
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                        {
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);
                        }
                        SendReply(player, string.Format(GetMsg("Entities: Count", player), c, bbs, ebs));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Entities: Count", player), c, bbs, ebs));
                        break;
                    }

                    var hits = FindEntities<T>(checkFrom[current - 1], DistanceThreshold);

                    foreach (var entityComponent in hits.ToList())
                    {
                        if (!entityList.Add(entityComponent)) continue;
                        c++;
                        checkFrom.Add(entityComponent.transform.position);

                        if (entityComponent is BuildingBlock)
                        {
                            bbs++;
                        }
                        else
                        {
                            ebs++;
                        }

                        if (target == 0)
                        {
                            RemoveOwner(entityComponent);
                        }
                        else
                        {
                            ChangeOwner(entityComponent, target);
                        }
                    }
                    Pool.FreeList(ref hits);
                }

                if (target == 0)
                {
                    SendReply(player, string.Format(GetMsg("Ownership: New", player), "No one"));
                }
                else
                {
                    BasePlayer targetPlayer = BasePlayer.FindByID(target);

                    if (targetPlayer != null)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: New", player), targetPlayer.displayName));
                        SendReply(targetPlayer, GetMsg("Ownership: New Self", player));
                    }
                    else
                    {
                        IPlayer pl = covalence.Players.FindPlayerById(target.ToString());
                        SendReply(player, string.Format(GetMsg("Target: Owner", player), pl.Name));
                    }
                }
            }
        }

        void massProd<T>(BasePlayer player, bool highlight = false, params string[] filter) where T : BaseEntity
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);
            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                float health = 0f;
                float maxHealth = 0f;
                var prodOwners = new Dictionary<ulong, int>();
                var entity = entityObject as BaseEntity;
                if (entity.transform == null)
                {
                    SendReply(player, GetMsg("Entities: None", player));
                    return;
                }

                SendReply(player, GetMsg("Structure: Prodding", player));

                var entityList = new HashSet<T>();
                var checkFrom = new List<Vector3>();

                if (entity is T)
                {
                    entityList.Add((T)entity);
                }

                var total = 0;
                var skip = false;
                if (entity is T)
                {
                    if (filter.Length > 0)
                    {
                        skip = true;
                        foreach (var f in filter)
                        {
                            if (entity.name.ToLower().Contains(f.ToLower()))
                            {
                                skip = false;
                                break;
                            }
                        }
                    }

                    if (!skip)
                    {
                        prodOwners.Add(entity.OwnerID, 1);
                        health += entity.Health();
                        maxHealth += entity.MaxHealth();
                        total++;
                    }
                }

                var current = -1;
                var distanceThreshold = DistanceThreshold;
                if (typeof(T) != typeof(BuildingBlock) && typeof(T) != typeof(BaseEntity))
                    distanceThreshold += 30;

                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        break;
                    }

                    var hits = FindEntities<T>(checkFrom.Count > 0 ? checkFrom[current - 1] : entity.transform.position, distanceThreshold);
                    skip = false;
                    foreach (var fentity in hits)
                    {
                        if (fentity.transform == null || !entityList.Add(fentity) || fentity.name == "player/player")
                            continue;

                        if (filter.Length > 0)
                        {
                            skip = true;
                            foreach (var f in filter)
                            {
                                if (fentity.name.ToLower().Contains(f.ToLower()))
                                {
                                    skip = false;
                                    break;
                                }
                            }
                        }

                        checkFrom.Add(fentity.transform.position);

                        if (!skip)
                        {
                            total++;
                            if (highlight)
                            {
                                SendHighlight(player, fentity.transform.position);
                            }

                            var pid = fentity.OwnerID;
                            if (prodOwners.ContainsKey(pid))
                            {
                                prodOwners[pid]++;
                            }
                            else
                            {
                                prodOwners.Add(pid, 1);
                            }

                            health += fentity.Health();
                            maxHealth += fentity.MaxHealth();
                        }
                    }

                    Pool.FreeList(ref hits);
                }

                var unknown = 100;

                var msg = string.Empty;

                msg = "<size=16>Structure</size>\n";
                msg += $"Entities: {total}\n";

                if (health > 0 && maxHealth > 0)
                {
                    var condition = Mathf.Round(health * 100 / maxHealth);
                    msg += string.Format(GetMsg("Structure: Condition Percent", player), condition);
                }

                SendReply(player, msg);

                msg = "<size=16>Ownership</size>\n";

                if (total > 0)
                {
                    foreach (var kvp in prodOwners)
                    {
                        var perc = kvp.Value * 100 / total;
                        if (kvp.Key != 0)
                        {
                            var n = FindPlayerName(kvp.Key);
                            msg += $"{n}: {perc}%\n";
                            unknown -= perc;
                        }
                    }
                }

                if (unknown > 0)
                    msg += string.Format(GetMsg("Player: Unknown Percent", player), unknown);

                SendReply(player, msg);
            }
        }

        void SendHighlight(BasePlayer player, Vector3 position)
        {
            player.SendConsoleCommand("ddraw.sphere", 30f, Color.magenta, position, 2f);
            player.SendNetworkUpdateImmediate();
        }

        void ProdCupboard(BasePlayer player, BuildingPrivlidge cupboard)
        {
            List<string> authorizedUsers;
            var sb = new StringBuilder();
            if (TryGetCupboardUserNames(cupboard, out authorizedUsers))
            {
                sb.AppendLine(string.Format(GetMsg("Entities: Authorized", player), authorizedUsers.Count));
                foreach (var n in authorizedUsers)
                    sb.AppendLine(n);

            }
            else
                sb.Append(string.Format(GetMsg("Target: None", player)));

            SendReply(player, sb.ToString());
        }

        void ProdTurret(BasePlayer player, AutoTurret turret)
        {
            List<string> authorizedUsers;
            var sb = new StringBuilder();
            if (TryGetTurretUserNames(turret, out authorizedUsers))
            {
                sb.AppendLine(string.Format(GetMsg("Entities: Authorized", player), authorizedUsers.Count));
                foreach (var n in authorizedUsers)
                    sb.AppendLine(n);
            }
            else
            {
                sb.Append(string.Format(GetMsg("Target: None", player)));
            }

            SendReply(player, sb.ToString());
        }

        void massProdCupboard(BasePlayer player, bool highlight = false)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                var prodOwners = new Dictionary<ulong, int>();
                SendReply(player, GetMsg("Cupboards: Prodding", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BuildingPrivlidge>(checkFrom[current - 1], CupboardDistanceThreshold);

                    foreach (var e in entities)
                    {
                        if (!entityList.Add(e)) { continue; }
                        if (highlight)
                        {
                            SendHighlight(player, e.transform.position);
                        }
                        checkFrom.Add(e.transform.position);

                        foreach (var pnid in e.authorizedPlayers)
                        {
                            if (prodOwners.ContainsKey(pnid.userid))
                                prodOwners[pnid.userid]++;
                            else
                                prodOwners.Add(pnid.userid, 1);
                        }

                        total++;
                    }
                    Pool.FreeList(ref entities);
                }

                var percs = new Dictionary<ulong, int>();
                var unknown = 100;
                if (total > 0)
                {
                    foreach (var kvp in prodOwners)
                    {
                        var perc = kvp.Value * 100 / total;
                        percs.Add(kvp.Key, perc);
                        var n = FindPlayerName(kvp.Key);

                        if (!n.Contains("Unknown: "))
                        {
                            SendReply(player, n + ": " + perc + "%");
                            unknown -= perc;
                        }
                    }

                    if (unknown > 0)
                        SendReply(player, string.Format(GetMsg("Player: Unknown Percent", player), unknown));
                }
            }
        }

        void massProdTurret(BasePlayer player, bool highlight = false)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                var prodOwners = new Dictionary<ulong, int>();
                SendReply(player, GetMsg("Turrets: Prodding", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BaseEntity>(checkFrom[current - 1], DistanceThreshold);

                    foreach (var e in entities)
                    {
                        if (!entityList.Add(e)) { continue; }
                        if (highlight)
                        {
                            SendHighlight(player, e.transform.position);
                        }
                        checkFrom.Add(e.transform.position);

                        if (e is AutoTurret)
                        {
                            var turret = e as AutoTurret;
                            if (turret.OwnerID.IsSteamId())
                            {
                                if (prodOwners.ContainsKey(turret.OwnerID))
                                    prodOwners[turret.OwnerID]++;
                                else
                                    prodOwners.Add(turret.OwnerID, 1);
                            }

                            foreach (var pnid in turret.authorizedPlayers)
                            {
                                if (prodOwners.ContainsKey(pnid.userid))
                                    prodOwners[pnid.userid]++;
                                else
                                    prodOwners.Add(pnid.userid, 1);
                            }
                        }
                        else if (e is FlameTurret)
                        {
                            var turret = e as FlameTurret;
                            if (turret.OwnerID.IsSteamId())
                            {
                                if (prodOwners.ContainsKey(turret.OwnerID))
                                    prodOwners[turret.OwnerID]++;
                                else
                                    prodOwners.Add(turret.OwnerID, 1);
                            }
                        }
                        else
                        {
                            continue;
                        }



                        total++;
                    }

                    Pool.FreeList(ref entities);
                }

                var percs = new Dictionary<ulong, int>();
                var unknown = 100;
                if (total > 0)
                {
                    foreach (var kvp in prodOwners)
                    {
                        var perc = kvp.Value * 100 / total;
                        percs.Add(kvp.Key, perc);
                        var n = FindPlayerName(kvp.Key);

                        if (!n.Contains("Unknown: "))
                        {
                            SendReply(player, n + ": " + perc + "%");
                            unknown -= perc;
                        }
                    }

                    if (unknown > 0)
                        SendReply(player, string.Format(GetMsg("Player: Unknown Percent", player), unknown));
                }
            }
        }

        void massCupboardAuthorize(BasePlayer player, BasePlayer target)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                SendReply(player, GetMsg("Cupboards: Authorizing", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BuildingPrivlidge>(checkFrom[current - 1], CupboardDistanceThreshold);

                    foreach (var priv in entities)
                    {
                        if (!entityList.Add(priv)) continue;
                        checkFrom.Add(priv.transform.position);
                        if (HasCupboardAccess(priv, target)) continue;
                        priv.authorizedPlayers.Add(new ProtoBuf.PlayerNameID()
                        {
                            userid = target.userID,
                            username = target.displayName
                        });

                        priv.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                        total++;
                    }
                    Pool.FreeList(ref entities);
                }

                SendReply(player, string.Format(GetMsg("Cupboards: Authorized", player), target.displayName, total));
            }
        }

        void massCupboardDeauthorize(BasePlayer player, BasePlayer target)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                SendReply(player, GetMsg("Cupboards: Deauthorizing", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BuildingPrivlidge>(checkFrom[current - 1], CupboardDistanceThreshold);

                    foreach (var priv in entities)
                    {
                        if (!entityList.Add(priv)) continue;
                        checkFrom.Add(priv.transform.position);

                        if (!HasCupboardAccess(priv, target)) continue;
                        foreach (var p in priv.authorizedPlayers.ToArray())
                        {
                            if (p.userid == target.userID)
                            {
                                priv.authorizedPlayers.Remove(p);
                                priv.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            }
                        }

                        total++;
                    }
                    Pool.FreeList(ref entities);
                }

                SendReply(player, string.Format(GetMsg("Cupboard: Deauthorized", player), target.displayName, total));
            }
        }

        void massTurretAuthorize(BasePlayer player, BasePlayer target)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                SendReply(player, GetMsg("Turrets: Authorizing", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BaseEntity>(checkFrom[current - 1], DistanceThreshold);

                    foreach (var e in entities)
                    {
                        if (!entityList.Add(e)) continue;
                        checkFrom.Add(e.transform.position);

                        var turret = e as AutoTurret;
                        if (turret == null || HasTurretAccess(turret, target)) continue;
                        turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID()
                        {
                            userid = target.userID,
                            username = target.displayName
                        });

                        turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        turret.SetTarget(null);
                        total++;
                    }
                    Pool.FreeList(ref entities);
                }

                SendReply(player, string.Format(GetMsg("Turrets: Authorized", player), target.displayName, total));
            }
        }

        void massTurretDeauthorize(BasePlayer player, BasePlayer target)
        {
            object entityObject = false;

            entityObject = FindEntity(player.transform.position, DistanceThreshold);

            if (entityObject is bool)
            {
                SendReply(player, GetMsg("Entities: None", player));
            }
            else
            {
                var total = 0;
                SendReply(player, GetMsg("Turrets: Deauthorizing", player));
                var entity = entityObject as BaseEntity;
                var entityList = new HashSet<BaseEntity>();
                var checkFrom = new List<Vector3>();

                checkFrom.Add(entity.transform.position);

                var current = 0;
                while (true)
                {
                    current++;
                    if (current > EntityLimit)
                    {
                        if (debug)
                            SendReply(player, GetMsg("Target: Limit", player) + " " + EntityLimit);

                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }
                    if (current > checkFrom.Count)
                    {
                        SendReply(player, string.Format(GetMsg("Ownership: Count", player), total));
                        break;
                    }

                    var entities = FindEntities<BaseEntity>(checkFrom[current - 1], DistanceThreshold);

                    foreach (var e in entities)
                    {
                        if (!entityList.Add(e)) continue;
                        checkFrom.Add(e.transform.position);

                        var turret = e as AutoTurret;
                        if (turret == null || !HasTurretAccess(turret, target)) continue;
                        foreach (var p in turret.authorizedPlayers.ToArray())
                        {
                            if (p.userid == target.userID)
                            {
                                turret.authorizedPlayers.Remove(p);
                                turret.SetTarget(null);
                                total++;
                            }
                        }

                        turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                    Pool.FreeList(ref entities);
                }

                SendReply(player, string.Format(GetMsg("Turrets: Deauthorized", player), target.displayName, total));
            }
        }

        bool TryGetCupboardUserNames(BuildingPrivlidge cupboard, out List<string> names)
        {
            names = new List<string>();
            if (cupboard.authorizedPlayers == null)
                return false;
            if (cupboard.authorizedPlayers.Count == 0)
                return false;

            foreach (var pnid in cupboard.authorizedPlayers)
                names.Add($"{FindPlayerName(pnid.userid)} - {pnid.userid}");

            return true;
        }

        bool TryGetTurretUserNames(AutoTurret turret, out List<string> names)
        {
            names = new List<string>();
            if (turret.authorizedPlayers == null)
                return false;
            if (turret.authorizedPlayers.Count == 0)
                return false;

            foreach (var pnid in turret.authorizedPlayers)
                names.Add($"{FindPlayerName(pnid.userid)} - {pnid.userid}");

            return true;
        }

        bool HasCupboardAccess(BuildingPrivlidge cupboard, BasePlayer player)
        {
            return cupboard.IsAuthed(player);
        }

        bool HasTurretAccess(AutoTurret turret, BasePlayer player)
        {
            return turret.IsAuthed(player);
        }

        string GetOwnerName(BaseEntity entity)
        {
            return FindPlayerName(entity.OwnerID);
        }

        BasePlayer GetOwnerPlayer(BaseEntity entity)
        {
            if (entity.OwnerID.IsSteamId())
            {
                return BasePlayer.FindByID(entity.OwnerID);
            }

            return null;
        }

        IPlayer GetOwnerIPlayer(BaseEntity entity)
        {
            if (entity.OwnerID.IsSteamId())
            {
                return covalence.Players.FindPlayerById(entity.OwnerID.ToString());
            }

            return null;
        }

        void RemoveOwner(BaseEntity entity)
        {
            entity.OwnerID = 0;
        }

        void ChangeOwner(BaseEntity entity, object player)
        {
            //get the current owner for debug log
            var old_owner = GetOwnerDisplayName(entity);
            if (string.IsNullOrEmpty(old_owner))
            {
                old_owner = "N/A";
            }
            
            if (player is BasePlayer)
                entity.OwnerID = ((BasePlayer)player).userID;
            else if (player is IPlayer)
                entity.OwnerID = Convert.ToUInt64(((IPlayer)player).Id);
            else if (player is ulong && ((ulong)player).IsSteamId())
                entity.OwnerID = (ulong)player;
            else if (player is string)
            {
                ulong id;
                var basePlayer = BasePlayer.Find((string)player);

                if (ulong.TryParse((string)player, out id) && id.IsSteamId())
                    entity.OwnerID = id;
                else if (basePlayer is BasePlayer)
                    entity.OwnerID = basePlayer.userID;
            }

            //get the current owner for the debug log
            var new_owner = GetOwnerDisplayName(entity);
            if (string.IsNullOrEmpty(new_owner))
            {
                new_owner = "N/A";
            }

            //Debug
            if(debug)
                Puts("Changed owner of [" + entity.ShortPrefabName + "] from [" + old_owner + "] to [" + new_owner + "]");
        }

        object FindEntityData(BaseEntity entity)
        {
            if (!entity.OwnerID.IsSteamId())
            {
                return false;
            }

            return entity.OwnerID.ToString();
        }

        #endregion

        #region Utility Methods

        object RaycastAll<T>(Vector3 position, Vector3 aim) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(position, aim);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }

            return target;
        }

        object RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T && hit.distance < distance)
                {
                    target = ent;
                    break;
                }
            }

            return target;
        }

        object FindBuilding(Vector3 position, float distance = 3f)
        {
            var hit = FindEntity<BuildingBlock>(position, distance);

            if (hit != null)
            {
                return hit;
            }

            return false;
        }

        object FindEntity(Vector3 position, float distance = 3f, params string[] filter)
        {
            var hit = FindEntity<BaseEntity>(position, distance, filter);

            if (hit != null)
            {
                return hit;
            }

            return false;
        }

        T FindEntity<T>(Vector3 position, float distance = 3f, params string[] filter) where T : BaseEntity
        {
            var list = Pool.GetList<T>();
            Vis.Entities(position, distance, list, layerMasks);

            if (list.Count > 0)
            {
                foreach (var e in list)
                {
                    if (filter.Length > 0)
                    {
                        foreach (var f in filter)
                        {
                            if (e.name.Contains(f))
                            {
                                return e;
                            }
                        }
                    }
                    else
                    {
                        return e;
                    }
                }
                Pool.FreeList(ref list);
            }

            return null;
        }

        List<T> FindEntities<T>(Vector3 position, float distance = 3f) where T : BaseEntity
        {
            var list = Pool.GetList<T>();
            Vis.Entities(position, distance, list, layerMasks);
            return list;
        }

        List<BuildingBlock> GetProfileConstructions(BasePlayer player)
        {
            var result = new List<BuildingBlock>();
            var blocks = UnityEngine.Object.FindObjectsOfType<BuildingBlock>();
            foreach (var block in blocks)
            {
                if (block.OwnerID == player.userID)
                {
                    result.Add(block);
                }
            }

            return result;
        }

        List<BaseEntity> GetProfileDeployables(BasePlayer player)
        {
            var result = new List<BaseEntity>();
            var entities = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
            foreach (var entity in entities)
            {
                if (entity.OwnerID == player.userID && !(entity is BuildingBlock))
                {
                    result.Add(entity);
                }
            }

            return result;
        }

        void ClearProfile(BasePlayer player)
        {
            var entities = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
            foreach (var entity in entities)
            {
                if (entity.OwnerID == player.userID && !(entity is BuildingBlock))
                {
                    RemoveOwner(entity);
                }
            }
        }
        
        string FindPlayerName(ulong playerID)
        {
            if (playerID.IsSteamId())
            {
                var player = FindPlayerByPartialName(playerID.ToString());
                if (player)
                {
                    if (player.IsSleeping())
                    {
                        return $"{player.displayName} [<color=#ADD8E6>Sleeping</color>]";
                    }

                    return $"{player.displayName} [<color=#32CD32>Online</color>]";
                }

                var p = covalence.Players.FindPlayerById(playerID.ToString());
                if (p != null)
                {
                    return $"{p.Name} [<color=#FF0000>Offline</color>]";
                }
            }

            return $"Unknown: {playerID}";
        }

        //only purpose of this function is to provide the same informatoin as GetOwnerName()
        //but without the color-tag for a debug line added in ChangeOwner()
        string GetOwnerDisplayName(BaseEntity entity)
        {
            
            var playerID = entity.OwnerID;
            
            if (playerID.IsSteamId())
            {
                var player = FindPlayerByPartialName(playerID.ToString());
                if (player)
                    return player.displayName;

                var p = covalence.Players.FindPlayerById(playerID.ToString());
                if (p != null)
                    return p.Name;
            }

            return $"Unknown: {playerID}";
        }

        ulong FindUserIDByPartialName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return 0;

            ulong userID;
            if (ulong.TryParse(name, out userID))
            {
                return userID;
            }

            IPlayer player = covalence.Players.FindPlayer(name);

            if (player != null)
            {
                return Convert.ToUInt64(player.Id);
            }

            return 0;
        }

        BasePlayer FindPlayerByPartialName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return null;

            IPlayer player = covalence.Players.FindPlayer(name);

            if (player != null)
            {
                return (BasePlayer)player.Object;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: EntityOwner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosion-tracker ---
// --- Original File Path: E/ExplosionTracker/ExplosionTracker.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Explosion Tracker", "Ryan", "1.0.2")]
    [Description("Tracks and logs every explosion that happens on the server")]
    internal class ExplosionTracker : RustPlugin
    {
        [PluginReference] private Plugin Slack, Discord;

        private enum  Actions
        {
            Throw,
            Drop,
            Launch
        }

        #region Config

        private ConfigFile ConfigData;

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Enable RCON messages")]
            public bool RCON;

            [JsonProperty(PropertyName = "Enable Log messages")]
            public bool Log;

            [JsonProperty(PropertyName = "Send messages to online admins")]
            public bool AdminMsg;

            [JsonProperty(PropertyName = "Enable Discord messages")]
            public bool Discord;

            [JsonProperty(PropertyName = "Slack Settings")]
            public SlackInfo SlackInfo;

            [JsonProperty(PropertyName = "Enable rocket launch notifications")]
            public bool Launch;

            [JsonProperty(PropertyName = "Enable explosive throw notifications")]
            public bool Throw;

            [JsonProperty(PropertyName = "Enable explosive drop notifications")]
            public bool Drop;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    RCON = true,
                    Log = true,
                    AdminMsg = true,
                    Discord = false,
                    SlackInfo = new SlackInfo
                    {
                        Enabled = false,
                        Channel = "mychannelname"
                    },
                    Launch = true,
                    Drop = false,
                    Throw = true
                };
            }
        }

        public class SlackInfo
        {
            [JsonProperty(PropertyName = "Enable Slack messages")]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Channel name")]
            public string Channel { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            ConfigData = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            ConfigData = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(ConfigData);

        #endregion Config

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Dropped Message"] = "{0} ({1}) dropped {2} at (X: {3}, Y: {4}, Z: {5})",
                ["Launched Message"] = "{0} ({1}) launched a rocket at (X: {3}, Y: {4}, Z: {5})",
                ["Thrown Message"] = "{0} ({1}) dropped {2} at (X: {3}, Y: {4}, Z: {5})"
            }, this);
        }

        #endregion Lang

        #region Methods

        private void Log(string message, string action) => LogToFile(action, string.Format($"[{DateTime.Now}] " + message), this);

        private void SendSlack(string message, BasePlayer player) => Slack?.Call("SimpleMessage", message, covalence.Players.FindPlayerById(player.UserIDString), ConfigData.SlackInfo.Channel);

        private void SendDiscord(string message) => Discord?.Call("SendMessage", message);

        private string ThrowMsg(BasePlayer player, BaseEntity entity)
        {
            return string.Format(lang.GetMessage("Thrown Message", this, player.UserIDString), player.displayName, player.UserIDString, entity.ShortPrefabName,
                Math.Round(entity.transform.position.x, 2), Math.Round(entity.transform.position.y, 2), Math.Round(entity.transform.position.z, 2));
        }

        private string LaunchMsg(BasePlayer player, BaseEntity entity)
        {
            return string.Format(lang.GetMessage("Launched Message", this, player.UserIDString), player.displayName, player.UserIDString, entity.ShortPrefabName,
                Math.Round(entity.transform.position.x, 2), Math.Round(entity.transform.position.y, 2), Math.Round(entity.transform.position.z, 2));
        }

        private string DropMsg(BasePlayer player, BaseEntity entity)
        {
            return string.Format(lang.GetMessage("Dropped Message", this, player.UserIDString), player.displayName, player.UserIDString, entity.ShortPrefabName,
                Math.Round(entity.transform.position.x, 2), Math.Round(entity.transform.position.y, 2), Math.Round(entity.transform.position.z, 2));
        }

        private void SendMessages(string message, Actions action, BasePlayer player)
        {
            if (ConfigData.Log) Log(message, action.ToString());
            if (ConfigData.RCON) Puts(message);
            if (ConfigData.AdminMsg)
            {
                foreach (var p in BasePlayer.activePlayerList)
                    if (p.IsAdmin) PrintToChat(player, message);
            }
            if (ConfigData.SlackInfo.Enabled) SendSlack(message, player);
            if (ConfigData.Discord) SendDiscord(message);
        }

        private void ConstructMessage(BasePlayer player, BaseEntity entity, Actions action)
        {
            if (action.Equals(Actions.Throw) && ConfigData.Throw)
                SendMessages(ThrowMsg(player, entity), action, player);
            if (action.Equals(Actions.Launch) && ConfigData.Launch)
                SendMessages(LaunchMsg(player, entity), action, player);
            if (action.Equals(Actions.Drop) && ConfigData.Drop)
                SendMessages(DropMsg(player, entity), action, player);
        }

        #endregion Methods

        #region Hooks

        private void Init() => SaveConfig();

        private void OnServerInitialized()
        {
            if (ConfigData.Discord && !Discord) PrintWarning("You have Discord notifications on, but 'Discord' plugin isn't detected");
            if (ConfigData.SlackInfo.Enabled && !Slack) PrintWarning("You have Slack notifications on, but 'Slack' plugin isn't detected");
        }

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            NextTick(() =>
            {
                try { ConstructMessage(player, entity, Actions.Throw); }
                catch { }
            });
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            NextTick(() =>
            {
                try { ConstructMessage(player, entity, Actions.Launch); }
                catch { }
            });
        }

        private void OnExplosiveDropped(BasePlayer player, BaseEntity entity)
        {
            NextTick(() =>
            {
                try { ConstructMessage(player, entity, Actions.Drop); }
                catch { }
            });
        }

        #endregion Hooks
    }
}


// --- End of file: ExplosionTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/engine-parts-durability ---
// --- Original File Path: E/EnginePartsDurability/EnginePartsDurability.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Rust.Modular;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Engine Parts Durability", "WhiteThunder", "1.2.0")]
    [Description("Alters engine part durability loss when modular cars are damaged.")]
    internal class EnginePartsDurability : CovalencePlugin
    {
        private DurabilityConfig _pluginConfig;

        #region Hooks

        private void Init()
        {
            _pluginConfig = Config.ReadObject<DurabilityConfig>();
        }

        private void OnServerInitialized(bool serverInitialized)
        {
            // The OnEntitySpawned hook already covers server init so this is just for late loading
            if (!serverInitialized)
            {
                foreach (var engineModule in BaseNetworkable.serverEntities.OfType<VehicleModuleEngine>())
                    SetInternalDamageMultiplier(engineModule);
            }
        }

        private void OnEntitySpawned(VehicleModuleEngine engineModule) =>
            SetInternalDamageMultiplier(engineModule);

        #endregion

        #region API

        private void API_RefreshMultiplier(EngineStorage engineStorage)
        {
            engineStorage.internalDamageMultiplier = _pluginConfig.DurabilityLossMultiplier;
        }

        #endregion

        #region Helpers

        private static bool MultiplierChangeWasBlocked(EngineStorage engineStorage, float desiredMultiplier)
        {
            object hookResult = Interface.CallHook("OnEngineDamageMultiplierChange", engineStorage, desiredMultiplier);
            return hookResult is bool && (bool)hookResult == false;
        }

        private void SetInternalDamageMultiplier(VehicleModuleEngine engineModule)
        {
            NextTick(() =>
            {
                if (engineModule == null)
                    return;

                var engineStorage = engineModule.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    return;

                if (!MultiplierChangeWasBlocked(engineStorage, _pluginConfig.DurabilityLossMultiplier))
                    engineStorage.internalDamageMultiplier = _pluginConfig.DurabilityLossMultiplier;
            });
        }

        #endregion

        protected override void LoadDefaultConfig() => Config.WriteObject(new DurabilityConfig(), true);

        internal class DurabilityConfig
        {
            [JsonProperty("DurabilityLossMultiplier")]
            public float DurabilityLossMultiplier = 0;
        }
    }
}


// --- End of file: EnginePartsDurability.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extra-gather-bonuses ---
// --- Original File Path: E/ExtraGatherBonuses/ExtraGatherBonuses.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Extra Gather Bonuses", "Orange", "1.0.5")]
    [Description("Get extra items on gathering resources")]
    public class ExtraGatherBonuses : RustPlugin
    {
        #region Vars

        private Dictionary<string, GatherInfo> bonuses = new Dictionary<string, GatherInfo>();

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.list)
            {
                bonuses.Add(value.resource, value);
                if (!permission.PermissionExists(value.perm,this))
                {
                    permission.RegisterPermission(value.perm, this);
                }
            }
        }

        private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            foreach (ItemAmount item in collectible.itemList)
            {
                OnGather(player, item.itemDef.shortname);
            }
        }

        private void OnCropGather(GrowableEntity  plant, Item item, BasePlayer player)
        {
            OnGather(player, item.info.shortname);
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            OnGather(player, item.info.shortname);
        }

        #endregion

        #region Core

        private void OnGather(BasePlayer player, string name)
        {
            var list = bonuses.Where(x => x.Key == name).ToList();
            if (list.Count == 0)
            {
                return;
            }

            foreach (var value in list)
            {
                CheckBonus(player, value.Value);
            }
        }

        private void CheckBonus(BasePlayer player, GatherInfo info)
        {
            if (permission.UserHasPermission(player.UserIDString, info.perm) == false)
            {
                return;
            }

            var amount = 0;
            var max = info.maxItems;
            foreach (var def in info.extra)
            {
                if (max != 0 && amount >= max)
                {
                    break;
                }

                var random = Core.Random.Range(0, 100);
                if (random > def.chance)
                {
                    continue;
                }

                var item = CreateItem(def);
                if (item != null)
                {
                    player.GiveItem(item);
                    Message(player, "Received", def.displayName);
                }

                amount++;
            }
        }

        private Item CreateItem(BaseItem def)
        {
            var amount = Core.Random.Range(def.amountMin, def.amountMax + 1);
            var item = ItemManager.CreateByName(def.shortname, amount, def.skinId);
            if (item == null)
            {
                PrintWarning($"Can't create item ({def.shortname})");
                return null;
            }

            item.name = def.displayName;
            return item;
        }

        #endregion

        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "A. Bonus list")]
            public List<GatherInfo> list;
        }

        private class GatherInfo
        {
            [JsonProperty(PropertyName = "Item gathered to get bonus")]
            public string resource;

            [JsonProperty(PropertyName = "Permission")]
            public string perm;

            [JsonProperty(PropertyName = "Maximal items that player can get by once")]
            public int maxItems;

            [JsonProperty(PropertyName = "Bonus list")]
            public List<BaseItem> extra;
        }

        private class BaseItem
        {
            [JsonProperty(PropertyName = "Shortname")]
            public string shortname;

            [JsonProperty(PropertyName = "Amount min")]
            public int amountMin = 1;

            [JsonProperty(PropertyName = "Amount max")]
            public int amountMax = 1;

            [JsonProperty(PropertyName = "Skin")]
            public ulong skinId;

            [JsonProperty(PropertyName = "Display name")]
            public string displayName;

            [JsonProperty(PropertyName = "Chance")]
            public int chance;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                list = new List<GatherInfo>
                {
                    new GatherInfo
                    {
                        resource = "cloth",
                        maxItems = 0,
                        perm = "extragatherbonuses.default",
                        extra = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                shortname = "bandage",
                                amountMin = 1,
                                amountMax = 5,
                                skinId = 0,
                                displayName = "Apple",
                                chance = 50
                            }
                        }
                    },
                    new GatherInfo
                    {
                        resource = "wood",
                        maxItems = 0,
                        perm = "extragatherbonuses.default",
                        extra = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                shortname = "apple",
                                amountMin = 1,
                                amountMax = 5,
                                skinId = 0,
                                displayName = "Apple",
                                chance = 50
                            },
                            new BaseItem
                            {
                                shortname = "apple.spoiled",
                                amountMin = 1,
                                amountMax = 5,
                                skinId = 0,
                                displayName = "Spoiled Apple",
                                chance = 50
                            }
                        }
                    },
                    new GatherInfo
                    {
                        resource = "sulfur.ore",
                        maxItems = 1,
                        perm = "extragatherbonuses.vip",
                        extra = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                shortname = "ammo.rifle",
                                amountMin = 10,
                                amountMax = 50,
                                skinId = 0,
                                displayName = "556 Ammo",
                                chance = 10
                            },
                            new BaseItem
                            {
                                shortname = "ammo.pistol",
                                amountMin = 10,
                                amountMax = 50,
                                skinId = 0,
                                displayName = "9mm Ammo",
                                chance = 10
                            }
                        }
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    throw new JsonReaderException();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Loading defaults...");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization 1.1.1

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Received", "You received {0} for gathering!"},
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
    }
}

// --- End of file: ExtraGatherBonuses.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosives-modifier ---
// --- Original File Path: E/ExplosivesModifier/ExplosivesModifier.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("Explosives Modifier", "Mughisi", "1.3.2", ResourceId = 832)]
    [Description("Allows you to modify explosive damage and radius")]
    class ExplosivesModifier : RustPlugin
    {
        #region Configuration Data

        private bool configChanged;

        // Plugin options
        private const string DefaultChatPrefix = "Bomb Squad";
        private const string DefaultChatPrefixColor = "#008000";

        public string ChatPrefix { get; private set; }
        public string ChatPrefixColor { get; private set; }

        // Explosive Charge options
        private const float DefaultExplosiveChargeDamageModifier = 100;
        private const float DefaultExplosiveChargeRadiusModifier = 100;

        public float ExplosiveChargeDamageModifier { get; private set; }
        public float ExplosiveChargeRadiusModifier { get; private set; }

        // F1 Grenade options
        private const float DefaultF1GrenadeDamageModifier = 100;
        private const float DefaultF1GrenadeRadiusModifier = 100;
        private const bool DefaultF1GrenadeSticky = false;

        public float F1GrenadeDamageModifier { get; private set; }
        public float F1GrenadeRadiusModifier { get; private set; }
        public bool F1GrenadeSticky { get; private set; }

        // Beancan Grenade options
        private const float DefaultBeancanGrenadeDamageModifier = 100;
        private const float DefaultBeancanGrenadeRadiusModifier = 100;
        private const bool DefaultBeancanGrenadeSticky = false;

        public float BeancanGrenadeDamageModifier { get; private set; }
        public float BeancanGrenadeRadiusModifier { get; private set; }
        public bool BeancanGrenadeSticky { get; private set; }

        // Rocket options
        private const float DefaultRocketDamageModifier = 100;
        private const float DefaultRocketRadiusModifier = 100;

        public float RocketDamageModifier { get; private set; }
        public float RocketRadiusModifier { get; private set; }

        // Explosive Ammo options
        private const float DefaultExplosiveAmmoDamageModifier = 100;

        public float ExplosiveAmmoDamageModifier { get; private set; }

        // Plugin messages
        private const string DefaultHelpTextPlayersExplosiveCharge =
            "Explosive charges deal {0}% of their normal damage and their radius is set to {1}%";
        private const string DefaultHelpTextPlayersF1Grenade =
            "F1 Grenades deal {0}% of their normal damage and their radius is set to {1}%. Sticky F1 Grenades are {2}";
        private const string DefaultHelpTextPlayersBeancanGrenade =
            "Beancan Grenades deal {0}% of their normal damage and their radius is set to {1}%. Sticky Beancan Grenades are {2}";
        private const string DefaultHelpTextPlayersRocket =
            "Rockets deal {0}% of their normal damage and their radius is set to {1}%.";
        private const string DefaultHelpTextPlayersExplosiveAmmo = "Explosive rounds deals {0}% of their normal damage.";
        private const string DefaultHelpTextAdmins =
            "You can modify the damage of the following types of explosives: \r\n" +
            "  Explosive Charges, F1 Grenades, Beancan Grenades, Rockets and Explosive Ammo. \r\n" +
            "  /explosivedamage <type:timed|f1|beancan|rocket|ammo> <value:percentage> \r\n" +
            "  Example: /explosivedamage timed 50 - For 50% of normal damage. \r\n" +
            "           /explosivedamage ammo 200 - For 200% of normal damage. \r\n \r\n" +
            "You can modify the radius of the following types of explosives: \r\n" +
            "  Explosive Charges, F1 Grenades, Beancan Grenades and Rockets. \r\n" +
            "  /explosiveradius <type:timed|f1|beancan|rocket> <value:percentage> \r\n" +
            "  Example: /explosiveradius timed 50 - For 50% of normal damage. \r\n" +
            "           /explosiveradius rocket 200 - For 200% of normal damage. \r\n \r\n" +
            "You can also toggle sticky grenades for F1 Grenades and Beancan grenades: \r\n" +
            "  /stickygrenades <type:f1|beancan>";
        private const string DefaultModified = "{0} {1} changed to {2}% of the normal {1}.";
        private const string DefaultSticky = "You have {0} sticky {1}s";
        private const string DefaultNotAllowed = "You are not allowed to use this command.";
        private const string DefaultInvalidArguments =
            "Invalid argument(s) supplied! Check /help for more information on the commands.";

        public string HelpTextPlayersExplosiveCharge { get; private set; }
        public string HelpTextPlayersF1Grenade { get; private set; }
        public string HelpTextPlayersBeancanGrenade { get; private set; }
        public string HelpTextPlayersRocket { get; private set; }
        public string HelpTextPlayersExplosiveAmmo { get; private set; }
        public string HelpTextAdmins { get; private set; }
        public string Modified { get; private set; }
        public string Sticky { get; private set; }
        public string NotAllowed { get; private set; }
        public string InvalidArguments { get; private set; }

        #endregion

        private readonly string[] weaponDamageTypes = { "timed", "f1", "beancan", "rocket", "ammo" };

        private readonly string[] weaponRadiusTypes = { "timed", "f1", "beancan", "rocket" };

        protected override void LoadDefaultConfig() => PrintWarning("New configuration file created.");

        private void Init() => LoadConfiguration();

        private void LoadConfiguration()
        {
            // Plugin options
            ChatPrefix = GetConfigValue("Settings", "Chat Prefix", DefaultChatPrefix);
            ChatPrefixColor = GetConfigValue("Settings", "Chat Prefix Color", DefaultChatPrefixColor);

            // Explosive Charge options
            ExplosiveChargeDamageModifier = GetConfigValue("Options - Explosive Charge", "Damage Modifier",
                DefaultExplosiveChargeDamageModifier);
            ExplosiveChargeRadiusModifier = GetConfigValue("Options - Explosive Charge", "Radius Modifier",
                DefaultExplosiveChargeRadiusModifier);

            // F1 Grenade options
            F1GrenadeDamageModifier = GetConfigValue("Options - F1 Grenade", "Damage Modifier",
                DefaultF1GrenadeDamageModifier);
            F1GrenadeRadiusModifier = GetConfigValue("Options - F1 Grenade", "Radius Modifier",
                DefaultF1GrenadeRadiusModifier);
            F1GrenadeSticky = GetConfigValue("Options - F1 Grenade", "Sticky", DefaultF1GrenadeSticky);

            // Beancan Grenade options
            BeancanGrenadeDamageModifier = GetConfigValue("Options - Beancan Grenade", "Damage Modifier",
                DefaultBeancanGrenadeDamageModifier);
            BeancanGrenadeRadiusModifier = GetConfigValue("Options - Beancan Grenade", "Radius Modifier",
                DefaultBeancanGrenadeRadiusModifier);
            BeancanGrenadeSticky = GetConfigValue("Options - Beancan Grenade", "Sticky", DefaultBeancanGrenadeSticky);

            // Rocket options
            RocketDamageModifier = GetConfigValue("Options - Rocket", "Damage Modifier",
                DefaultRocketDamageModifier);
            RocketRadiusModifier = GetConfigValue("Options - Rocket", "Radius Modifier",
                DefaultRocketRadiusModifier);

            // Explosive Ammo options
            ExplosiveAmmoDamageModifier = GetConfigValue("Options - Explosive Ammo", "Damage Modifier",
                DefaultExplosiveAmmoDamageModifier);

            // Plugin messages
            HelpTextPlayersExplosiveCharge = GetConfigValue("HelpText", "Player - Explosive Charge",
                DefaultHelpTextPlayersExplosiveCharge);
            HelpTextPlayersF1Grenade = GetConfigValue("HelpText", "Player - F1 Grenade",
                     DefaultHelpTextPlayersF1Grenade);
            HelpTextPlayersBeancanGrenade = GetConfigValue("HelpText", "Player - Beancan Grenade",
                     DefaultHelpTextPlayersBeancanGrenade);
            HelpTextPlayersRocket = GetConfigValue("HelpText", "Player - Rocket",
                     DefaultHelpTextPlayersRocket);
            HelpTextPlayersExplosiveAmmo = GetConfigValue("HelpText", "Player - Explosive Ammo",
                     DefaultHelpTextPlayersExplosiveAmmo);
            HelpTextAdmins = GetConfigValue("HelpText", "Admin", DefaultHelpTextAdmins);
            Modified = GetConfigValue("Messages", "Modified", DefaultModified);
            Sticky = GetConfigValue("Messages", "Sticky", DefaultSticky);
            NotAllowed = GetConfigValue("Messages", "Not Allowed", DefaultNotAllowed);
            InvalidArguments = GetConfigValue("Messages", "Invalid Argument(s)", DefaultInvalidArguments);

            if (!configChanged) return;
            Puts("Configuration file updated.");
            SaveConfig();
        }

        [ChatCommand("explosivedamage")]
        private void ExplosiveDamage(BasePlayer player, string command, string[] args)
        {
            ChangeExplosive(player, command, args, "Damage Modifier");
        }

        [ChatCommand("explosiveradius")]
        private void ExplosiveRadius(BasePlayer player, string command, string[] args)
        {
            ChangeExplosive(player, command, args, "Radius Modifier");
        }

        [ChatCommand("stickygrenades")]
        private void StickyGrenades(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player)) return;

            switch (args[0].ToLower())
            {
                case "f1":
                    F1GrenadeSticky = !F1GrenadeSticky;
                    SetConfigValue("Options - F1 Grenade", "Sticky", F1GrenadeSticky);
                    SendChatMessage(player, Sticky, (F1GrenadeSticky ? "enabled" : "disabled"), "F1 Grenade");
                    return;
                case "beancan":
                    BeancanGrenadeSticky = !BeancanGrenadeSticky;
                    SetConfigValue("Options - F1 Grenade", "Sticky", BeancanGrenadeSticky);
                    SendChatMessage(player, Sticky, (BeancanGrenadeSticky ? "enabled" : "disabled"), "Beancan Grenade");
                    return;
            }

            SendChatMessage(player, InvalidArguments);
        }

        private void ChangeExplosive(BasePlayer player, string command, string[] args, string type)
        {
            if (!IsAllowed(player)) return;

            if (args.Length != 2)
            {
                SendChatMessage(player, InvalidArguments, command);
                return;
            }

            var invalid = false;
            float newModifier;
            if (!float.TryParse(args[1], out newModifier))
                invalid = true;

            if (!IsValidType(command, args[0]) || invalid)
            {
                SendChatMessage(player, InvalidArguments, command);
                return;
            }

            var configCategory = string.Empty;
            if (args[0].ToLower() == "timed")
            {
                configCategory = "Options - Explosive Charge";
                if (type == "Damage Modifier")
                    ExplosiveChargeDamageModifier = newModifier;
                if (type == "Radius Modifier")
                    ExplosiveChargeRadiusModifier = newModifier;
                SendChatMessage(player, Modified, "Explosive Charge", type.Replace(" Modifier", "").ToLower(), newModifier);
            }
            if (args[0].ToLower() == "f1")
            {
                configCategory = "Options - F1 Grenade";
                if (type == "Damage Modifier")
                    F1GrenadeDamageModifier = newModifier;
                if (type == "Radius Modifier")
                    F1GrenadeRadiusModifier = newModifier;
                SendChatMessage(player, Modified, "F1 Grenade", type.Replace(" Modifier", "").ToLower(), newModifier);
            }
            if (args[0].ToLower() == "beancan")
            {
                configCategory = "Options - Beancan Grenade";
                if (type == "Damage Modifier")
                    BeancanGrenadeDamageModifier = newModifier;
                if (type == "Radius Modifier")
                    BeancanGrenadeRadiusModifier = newModifier;
                SendChatMessage(player, Modified, "Beancan Grenade", type.Replace(" Modifier", "").ToLower(), newModifier);
            }
            if (args[0].ToLower() == "rocket")
            {
                configCategory = "Options - Rocket";
                if (type == "Damage Modifier")
                    RocketDamageModifier = newModifier;
                if (type == "Radius Modifier")
                    RocketRadiusModifier = newModifier;
                SendChatMessage(player, Modified, "Rocket", type.Replace(" Modifier", "").ToLower(), newModifier);
            }
            if (args[0].ToLower() == "ammo")
            {
                configCategory = "Options - Explosive Ammo";
                if (type == "Damage Modifier")
                    ExplosiveAmmoDamageModifier = newModifier;
                SendChatMessage(player, Modified, "Explosive Ammo", type.Replace(" Modifier", "").ToLower(), newModifier);
            }

            SetConfigValue(configCategory, type, newModifier);
        }

        #region Hooks

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            var explosive = entity as TimedExplosive;
            if (!explosive) return;
            var modifier = 100f;
            var radius = 100f;

            if (entity.name == "items/timed.explosive.deployed") { modifier = ExplosiveChargeDamageModifier; radius = ExplosiveChargeRadiusModifier; }
            if (entity.name == "items/grenade.f1.deployed") { modifier = F1GrenadeDamageModifier; radius = F1GrenadeRadiusModifier; }
            if (entity.name == "items/grenade.beancan.deployed") { modifier = BeancanGrenadeDamageModifier; radius = BeancanGrenadeRadiusModifier; }

            foreach (var damage in explosive.damageTypes)
                damage.amount *= modifier / 100;

            explosive.explosionRadius *= radius / 100;
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            var explosive = entity as TimedExplosive;
            if (!explosive) return;

            foreach (var damage in explosive.damageTypes)
                damage.amount *= RocketDamageModifier / 100;

            explosive.explosionRadius *= RocketRadiusModifier / 100;
        }
        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (info.Initiator?.ToPlayer() != null && info.damageTypes.Get(DamageType.Explosion) > 0)
                info.damageTypes.Scale(DamageType.Explosion, ExplosiveAmmoDamageModifier / 100);
        }


        private void SendHelpText(BasePlayer player)
        {
            SendChatMessage(player, HelpTextPlayersExplosiveCharge, ExplosiveAmmoDamageModifier, ExplosiveChargeRadiusModifier);
            SendChatMessage(player, HelpTextPlayersF1Grenade, F1GrenadeDamageModifier, F1GrenadeRadiusModifier, (F1GrenadeSticky ? "enabled" : "disabled"));
            SendChatMessage(player, HelpTextPlayersBeancanGrenade, BeancanGrenadeDamageModifier, BeancanGrenadeRadiusModifier, (BeancanGrenadeSticky ? "enabled" : "disabled"));
            SendChatMessage(player, HelpTextPlayersRocket, RocketDamageModifier, RocketRadiusModifier);
            SendChatMessage(player, HelpTextPlayersExplosiveAmmo, ExplosiveAmmoDamageModifier);

            if (player.net.connection.authLevel == 2)
                SendChatMessage(player, HelpTextAdmins);
        }

        #endregion

        #region Helper Methods

        private bool IsValidType(string command, string type)
        {
            switch (command)
            {
                case "explosivedamage":
                    return weaponDamageTypes.Contains(type.ToLower());
                case "explosiveradius":
                    return weaponRadiusTypes.Contains(type.ToLower());
            }
            return false;
        }

        private void SendChatMessage(BasePlayer player, string message, params object[] arguments) =>
            PrintToChat(player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: {message}", arguments);

        bool IsAllowed(BasePlayer player)
        {
            if (player.net.connection.authLevel == 2) return true;
            SendChatMessage(player, NotAllowed);
            return false;
        }

        T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            configChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        private void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }

            SaveConfig();
        }

        #endregion
    }
}

// --- End of file: ExplosivesModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extended-crafting ---
// --- Original File Path: E/ExtendedCrafting/ExtendedCrafting.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Extended Crafting", "nivex & judess69er", "0.3.6")]
    [Description("Allows players to deploy additional entities.")]
    class ExtendedCrafting : RustPlugin
    {
		#region Engine
        private static Dictionary<NetworkableId, ExtendedController> _controllers = new Dictionary<NetworkableId, ExtendedController>();
        private const int _layerMask = Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction;
        private List<int> _layers = new List<int> { (int)Layer.World, (int)Layer.Terrain };
        private const string permAllow = "extendedcrafting.allow";
        private const string permFree = "extendedcrafting.free";
        private Dictionary<ulong, ExtendedInfo> _skins = new Dictionary<ulong, ExtendedInfo>();
        private static ExtendedCrafting Instance;
        private RaycastHit _hit;

        public class ExtendedController : FacepunchBehaviour
        {
            internal BaseCombatEntity entity;
            internal RaycastHit hit;
            internal ExtendedInfo ei;
            internal NetworkableId uid;

            private void Awake()
            {
                entity = GetComponent<BaseCombatEntity>();
                _controllers[uid = entity.net.ID] = this;
                ei = Instance._skins[entity.skinID];
                if (ei.destroy.ground) InvokeRepeating(CheckGround, 5f, 5f);
            }

            private void CheckGround()
            {
                var position = entity.transform.position;

                if (!Physics.Raycast(position + new Vector3(0f, 0.1f, 0f), Vector3.down, out hit, 4f, _layerMask) || hit.distance > 0.2f)
                {
                    if (ei.destroy.give)
                    {
                        ei.GiveItem(position);
                    }

                    foreach (var effect in ei.destroy.effects)
                    {
                        Effect.server.Run(effect, position);
                    }

                    CancelInvoke(CheckGround);
                    entity.Kill();
                }
            }

            public void TryPickup(BasePlayer player)
            {
                if (!ei.pickup.enabled)
                {
                    Message(player, "Disabled");
                    return;
                }

                if (ei.pickup.privilege && !player.CanBuild())
                {
                    Message(player, "Build");
                    return;
                }

                if (ei.pickup.owner && entity.OwnerID != player.userID)
                {
                    Message(player, "Owner");
                    return;
                }

                if (entity.SecondsSinceDealtDamage < 30f)
                {
                    Message(player, "Damaged");
                    return;
                }

                var ice = entity as IItemContainerEntity;

                if (ice?.inventory != null)
                {
                    DropUtil.DropItems(ice.inventory, entity.transform.position + Vector3.up);
                }

                entity.Invoke(entity.KillMessage, 0.01f);
                ei.GiveItem(player, true);
            }

            private void OnDestroy()
            {
                _controllers?.Remove(uid);
                Destroy(this);
            }
        }

        #region Hooks

        private void Init()
        {
            Instance = this;
            Unsubscribe(nameof(CanBuild));
            permission.RegisterPermission(permAllow, this);
            permission.RegisterPermission(permFree, this);
            _controllers = new Dictionary<NetworkableId, ExtendedController>();
        }

        private void OnServerInitialized(bool isStartup)
        {
            config.entities.Values.ToList().ForEach(ei =>
            {
                _skins[ei.item.skin] = ei;

                var ci = ei.craft.items.FirstOrDefault(x => x.definition == null);

                if (ci != null)
                {
                    ei.craft.enabled = false;

                    Puts("Invalid item {0} configured for '{1}'", ci.shortname, ei.itemname);
                }

                if (ei.land || ei.distance > 0)
                {
                    Subscribe(nameof(CanBuild));
                }
            });

            foreach (var entity in BaseNetworkable.serverEntities.OfType<BaseEntity>())
            {
                if (entity.OwnerID != 0uL && _skins.ContainsKey(entity.skinID))
                {
                    entity.gameObject.AddComponent<ExtendedController>();
                }
            }
        }

        private void Unload()
        {
            foreach (var controller in _controllers.ToList())
            {
                UnityEngine.Object.Destroy(controller.Value);
            }
			
            Instance = null;
            _controllers = null;
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();

            config.entities.Values.FirstOrDefault(x => x.item.skin == entity.skinID)?.Spawn(entity);
        }

        private void OnHammerHit(BasePlayer player, HitInfo hitInfo)
        {
            var entity = hitInfo.HitEntity;

            if (entity == null || entity.IsDestroyed || !_skins.ContainsKey(entity.skinID))
            {
                return;
            }

            ExtendedController controller;
            if (_controllers.TryGetValue(entity.net.ID, out controller) && !controller.IsInvoking("TryPickup"))
            {
                controller.Invoke(() => controller.TryPickup(player), 0.25f);
            }
        }

        private object CanBuild(Planner planner, Construction construction, Construction.Target target)
        {
            Item item = planner.GetItem();
            ExtendedInfo ei;

            if (!_skins.TryGetValue(item.skin, out ei))
            {
                return null;
            }

            var buildPos = target.entity && target.entity.transform && target.socket ? target.GetWorldPosition() : target.position;

            if (ei.land && (!Physics.Raycast(buildPos + Vector3.up, Vector3.down, out _hit, 4f) || !_layers.Contains(_hit.collider.gameObject.layer)))
            {
                return false;
            }
            else if (ei.distance > 0 && Vector3.Distance(buildPos, planner.transform.position) < ei.distance)
            {
                return false;
            }

            return null;
        }

        #endregion Hooks

        #region Helpers

        private void CommandExtended(IPlayer p, string command, string[] args)
        {
            var player = p.Object as BasePlayer;

            if (args.Length == 2 && (p.IsServer || player.IsAdmin))
            {
                ExtendedInfo.GiveItem(p, command, args);
                return;
            }

            if (p.IsServer)
            {
                p.Reply($"{command} <name> <steamid>");
                return;
            }

            var ei = config.entities.Values.FirstOrDefault(m => m.command == command);

            if (ei.CanCraft(player))
            {
                ei.GiveItem(player);
            }
        }

        #endregion Helpers
		
		#endregion Engine	
        #region Configuration

        private static void Message(BasePlayer player, string key, params object[] args)
        {
            Instance.Player.Message(player, _(key, player.UserIDString, args), Instance.config.chatid);
        }

        private static string _(string key, string id = null, params object[] args)
        {
            return string.Format(Instance.lang.GetMessage(key, Instance, id), args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command!",
                ["ItemAmount"] = "You are missing {0}",
                ["Pickup"] = "You picked up {0}!",
                ["Received"] = "You received {0}!",
                ["Disabled"] = "Pickup disabled!",
                ["Build"] = "You cannot do this while building blocked!",
                ["Damaged"] = "You cannot pick this up yet!",
                ["NoCraft"] = "You cannot craft this item.",
                ["Owner"] = "You are not allowed to pick this up!",
            }, this);
        }

        public class CraftItem
        {
            public string shortname;
            public int amount;
            public ulong skin;
            internal ItemDefinition _definition;

            internal int itemid => definition.itemid;
            internal string displayName => definition.displayName.english;

            public CraftItem(string shortname, int amount, ulong skin = 0uL)
            {
                this.shortname = shortname;
                this.amount = amount;
                this.skin = skin;
            }

            internal ItemDefinition definition
            {
                get
                {
                    if (_definition == null)
                    {
                        _definition = ItemManager.FindItemDefinition(shortname);
                    }

                    return _definition;
                }
            }
        }

        public class CraftSettings
        {
            [JsonProperty("items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<CraftItem> items;
            public bool enabled;

            public CraftSettings(bool enabled)
            {
                this.enabled = enabled;
            }
        }

        public class DestroySettings
        {
            [JsonProperty("effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> effects;
            public bool give;
            public bool ground;

            public DestroySettings(bool give, bool ground)
            {
                this.give = give;
                this.ground = ground;
            }
        }

        public class PickupSettings
        {
            public bool enabled;
            public bool owner;
            public bool privilege;

            public PickupSettings(bool enabled, bool owner, bool privilege)
            {
                this.enabled = enabled;
                this.owner = owner;
                this.privilege = privilege;
            }
        }

        public class ExtendedInfo
        {
            public CraftSettings craft;
            public DestroySettings destroy;
            public PickupSettings pickup;
            public CraftItem item;
            public string prefab;
            public string itemname;
            public string command;
            public bool land;
            public float distance;

            public Item CreateItem()
            {
                Item item = ItemManager.CreateByName(this.item.shortname, this.item.amount, this.item.skin);

                if (!string.IsNullOrEmpty(itemname))
                {
                    item.name = itemname;
                }

                return item;
            }

            public static void GiveItem(IPlayer server, string command, string[] args)
            {
                var ei = Instance.config.entities.Values.FirstOrDefault(x => x.item.shortname.Equals(args[0], StringComparison.OrdinalIgnoreCase));

                if (ei == null)
                {
                    server.Reply($"{args[0]} does not exist in config");
                    server.Reply($"{command} <shortname> <steamid>");
                }

                var target = RustCore.FindPlayer(args[1]);

                if (target == null)
                {
                    server.Reply($"{args[1]} player not found");
                }
                else ei.GiveItem(target);
            }

            public void GiveItem(BasePlayer player, bool pickup = false)
            {
                Item item = CreateItem();

                player.inventory.GiveItem(item);

                Message(player, pickup ? "Pickup" : "Received", item.info.displayName.english);
            }

            public void GiveItem(Vector3 position)
            {
                CreateItem().DropAndTossUpwards(position);
            }

            public bool CanCraft(BasePlayer player)
            {
                if (!craft.enabled)
                {
                    return false;
                }

                if (!player.IPlayer.HasPermission(permAllow))
                {
                    Message(player, "NoPermission");
                    return false;
                }

                if (player.IPlayer.HasPermission(permFree))
                {
                    return true;
                }

                bool flag = true;

                foreach (var ci in craft.items)
                {
                    int amount = player.inventory.GetAmount(ci.itemid);

                    if (amount < ci.amount)
                    {
                        Message(player, _("ItemAmount", player.UserIDString, $"{ci.displayName} x{ci.amount - amount}"));
                        flag = false;
                    }
                }

                if (flag)
                {
                    craft.items.ForEach(ci => player.inventory.Take(null, ci.itemid, ci.amount));
                }

                return flag;
            }

            public void Spawn(BaseEntity other)
            {
                var entity = GameManager.server.CreateEntity(prefab, other.transform.position, other.transform.rotation);

                if (entity == null)
                {
                    return;
                }

                entity.skinID = item.skin;
                entity.OwnerID = other.OwnerID;                
                entity.Spawn();
                entity.gameObject.AddComponent<ExtendedController>();

                other.transform.position = new Vector3(0f, -500f, 0f);
                other.TransformChanged();
                other.Invoke(other.KillMessage, 0.1f);
            }
        }
        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Entities", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, ExtendedInfo> entities { get; set; } = new Dictionary<string, ExtendedInfo>();

            [JsonProperty(PropertyName = "Steam ChatID")]
            public ulong chatid { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                LoadDefaultConfig();
            }
            config.entities.Values.ToList().ForEach(ei =>
            {
                AddCovalenceCommand(ei.command, nameof(CommandExtended));
            });
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config, true);
        }
		#endregion Configuration
        #region Item Tables (226)
        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                chatid = 0,
                entities = new Dictionary<string, ExtendedInfo>
                {
                    #region Deployables (20)
					
					#region Large (13)
					
                    #region Recycler
                    ["Recycler Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("metal.fragments", 5000),
                                new CraftItem("metal.refined", 50),
                                new CraftItem("gears", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("box.repair.bench", 1, 1594245394),
                        command = "recycler.craft",
                        land = false,
                        itemname = "Personal Recycler",
                        prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                    },
                    #endregion Recycler
                    #region Indoor Large Furnace
                    ["Indoor Furnace Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("stones", 500),
                                new CraftItem("wood", 600),
                                new CraftItem("lowgradefuel", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("furnace", 1, 1992717673),
                        command = "furnace.craft",
                        land = false,
                        itemname = "Indoor Large Furnace",
                        prefab = "assets/prefabs/deployable/furnace.large/furnace.large.prefab",
                    },
                    #endregion Indoor Large Furnace
                    #region Indoor Oil Refinery
                    ["Indoor Oil Refinery Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("stones", 500),
                                new CraftItem("wood", 600),
                                new CraftItem("lowgradefuel", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("furnace", 1, 1293296287),
                        command = "refinery.craft",
                        land = false,
                        itemname = "Indoor Oil Refinery",
                        prefab = "assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab",
                    },
                    #endregion Indoor Oil Refinery
                    #region Advanced Water Pump
                    ["Advanced Water Pump Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("wood", 250),
                                new CraftItem("metal.fragments", 200),
                                new CraftItem("gears", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, false),
                        item = new CraftItem("electric.fuelgenerator.small", 1, 1284169891),
                        command = "waterpump.craft",
                        land = false,
                        itemname = "Advanced Water Pump",
                        prefab = "assets/prefabs/deployable/playerioents/waterpump/water.pump.deployed.prefab",
                    },
                    #endregion Advanced Water Pump
                    #region Waterwell
                    ["Waterwell Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 5000),
                                new CraftItem("metal.fragments", 1000),
                                new CraftItem("scrap", 500),
                                new CraftItem("metal.refined", 100),
                                new CraftItem("sheetmetal", 50),
                                new CraftItem("bucket.water", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("water.catcher.small", 1, 204391461),
                        command = "waterwell.craft",
                        land = false,
                        itemname = "Waterwell",
                        prefab = "assets/prefabs/deployable/water well/waterwellstatic.prefab",
                    },
                    #endregion Waterwell
                    #region Small Modular Reactor
                    ["Small Modular Reactor Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 7500),
                                new CraftItem("metal.refined", 1000),
                                new CraftItem("techparts", 250),
                                new CraftItem("sheetmetal", 150),
                                new CraftItem("metalpipe", 50),
                                new CraftItem("targeting.computer", 10),
                                new CraftItem("propanetank", 5),
                                new CraftItem("fridge", 5),
                                new CraftItem("waterpump", 3),
                                new CraftItem("computerstation", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("electric.generator.small", 1, 295829489),
                        command = "smr.craft",
                        land = false,
                        itemname = "Small Modular Reactor",
                        prefab = "assets/prefabs/deployable/playerioents/generators/generator.small.prefab",
                    },
                    #endregion Small Modular Reactor
                    #region One Sided Town Sign Post
                    ["One Sided Town Sign Post Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.post.town", 1, 1832422579),
                        command = "townsign1.craft",
                        land = false,
                        itemname = "One Sided Town Sign Post",
                        prefab = "assets/prefabs/deployable/signs/sign.post.town.prefab",
                    },
                    #endregion One Sided Town Sign Post
                    #region Two Sided Town Sign Post
                    ["Two Sided Town Sign Post Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("metal.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.post.town.roof", 1, 826309791),
                        command = "townsign2.craft",
                        land = false,
                        itemname = "Two Sided Town Sign Post",
                        prefab = "assets/prefabs/deployable/signs/sign.post.town.roof.prefab",
                    },
                    #endregion Two Sided Town Sign Post
                    #region Hobobarrel
                    ["Hobobarrel Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 150),
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("sheetmetal", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hobobarrel", 1, 1442559428),
                        command = "hobobarrel.craft",
                        land = false,
                        itemname = "Hobobarrel",
                        prefab = "assets/prefabs/misc/twitch/hobobarrel/hobobarrel.deployed.prefab",
                    },
                    #endregion Hobobarrel
                    #region Car Shredder
                    ["Car Shredder Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50000),
                                new CraftItem("scrap", 10000),
                                new CraftItem("crude.oil", 5000),
                                new CraftItem("metal.refined", 2500),
                                new CraftItem("sheetmetal", 500),
                                new CraftItem("metalblade", 500),
                                new CraftItem("metalspring", 100),
                                new CraftItem("metalpipe", 100),
                                new CraftItem("gears", 100),
                                new CraftItem("sparkplug3", 40),
                                new CraftItem("piston3", 20),
                                new CraftItem("valve3", 20),
                                new CraftItem("crankshaft3", 10),
                                new CraftItem("carburetor3", 5),
                                new CraftItem("vehicle.1mod.engine", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("abovegroundpool", 1, 352130972),
                        command = "shredder.craft",
                        land = false,
                        itemname = "Car Shredder - Rotation is 1 rotation behind",
                        prefab = "assets/content/structures/carshredder/carshredder.entity.prefab",
                    },
                    #endregion Car Shredder
                    #region Pumpjack
                    ["Pumpjack Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 25000),
                                new CraftItem("metal.fragments", 10000),
                                new CraftItem("scrap", 5000),
                                new CraftItem("metal.refined", 1500),
                                new CraftItem("sheetmetal", 100),
                                new CraftItem("gears", 75),
                                new CraftItem("metalpipe", 50),
                                new CraftItem("metalspring", 25),
                                new CraftItem("piston3", 5),
                                new CraftItem("valve3", 5),
                                new CraftItem("carburetor3", 3),
                                new CraftItem("crankshaft3", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("water.catcher.large", 1, 1130709577),
                        command = "pumpjack.craft",
                        land = false,
                        itemname = "Pumpjack",
                        prefab = "assets/bundled/prefabs/static/pumpjack-static.prefab",
                    },
                    #endregion Pumpjack
                    #region Mining Quarry
                    ["Mining Quarry Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25000),
                                new CraftItem("wood", 15000),
                                new CraftItem("scrap", 5000),
                                new CraftItem("metal.refined", 1500),
                                new CraftItem("sheetmetal", 100),
                                new CraftItem("gears", 75),
                                new CraftItem("metalpipe", 50),
                                new CraftItem("metalspring", 25),
                                new CraftItem("piston3", 5),
                                new CraftItem("valve3", 5),
                                new CraftItem("carburetor3", 3),
                                new CraftItem("crankshaft3", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("water.catcher.large", 1, 1052926200),
                        command = "quarry.craft",
                        land = false,
                        itemname = "Mining Quarry",
                        prefab = "assets/bundled/prefabs/static/miningquarry_static.prefab",
                    },
                    #endregion Mining Quarry
                    #region Clan Banner
                    ["Clan Banner Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("metal.fragments", 50),
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.pole.banner.large", 1, 2070189026),
                        command = "clanbanner.craft",
                        land = false,
                        itemname = "Clan Banner",
                        prefab = "assets/prefabs/deployable/signs/sign.pole.banner.large.prefab",
                    },
                    #endregion Clan Banner

					#endregion Large
                    #region Animals (6)
					
                    #region Chicken
                    ["Chicken Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_d", 1, 9999999998),
                        command = "chicken.craft",
                        land = false,
                        itemname = "Chicken",
                        prefab = "assets/rust.ai/agents/chicken/chicken.prefab",
                    },
                    #endregion Chicken
                    #region Boar
                    ["Boar Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 9999999997),
                        command = "boar.craft",
                        land = false,
                        itemname = "Boar",
                        prefab = "assets/rust.ai/agents/boar/boar.prefab",
                    },
                    #endregion Boar
                    #region Bear
                    ["Bear Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 125),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_a", 1, 9999999996),
                        command = "bear.craft",
                        land = false,
                        itemname = "Bear",
                        prefab = "assets/rust.ai/agents/bear/bear.prefab",
                    },
                    #endregion Bear
                    #region PolarBear
                    ["PolarBear Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 150),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_c", 1, 9999999995),
                        command = "polarbear.craft",
                        land = false,
                        itemname = "PolarBear",
                        prefab = "assets/rust.ai/agents/bear/polarbear.prefab",
                    },
                    #endregion PolarBear
                    #region Stag
                    ["Stag Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 9999999994),
                        command = "stag.craft",
                        land = false,
                        itemname = "Stag",
                        prefab = "assets/rust.ai/agents/stag/stag.prefab",
                    },
                    #endregion Stag
                    #region Wolf
                    ["Wolf Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("rustige_egg_b", 1, 9999999993),
                        command = "wolf.craft",
                        land = false,
                        itemname = "Wolf",
                        prefab = "assets/rust.ai/agents/wolf/wolf.prefab",
                    },
                    #endregion Wolf
					
					
                    #endregion Animals
                    #region Vehicles (1)

                    #region M270 Multiple Launch Rocket System
                    ["M270 Multiple Launch Rocket System Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 7500),
                                new CraftItem("scrap", 1250),
                                new CraftItem("metal.refined", 500),
								new CraftItem("techparts", 100),
								new CraftItem("samsite", 2),
								new CraftItem("targeting.computer", 1),
								new CraftItem("computerstation", 1),
								new CraftItem("vehicle.1mod.cockpit.armored", 1),
                                new CraftItem("vehicle.1mod.passengers.armored", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("water.catcher.large", 1, 1449152644),
                        command = "mlrs.craft",
                        land = false,
                        itemname = "M270 Multiple Launch Rocket System",
                        prefab = "assets/content/vehicles/mlrs/mlrs.entity.prefab",
                    },
                    #endregion M270 Multiple Launch Rocket System0
					
                    #endregion Vehicles
					
                    #endregion Deployables
                    #region Items (66)
                    #region Attire (14)
					
                    #region Diving Mask
                    ["Diving Mask Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("diving.mask", 1, 113413047),
                        command = "divingmask.craft",
                        land = false,
                        itemname = "Diving Mask",
                        prefab = null,
                    },
                    #endregion Diving Mask
                    #region Wetsuit
                    ["Wetsuit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("diving.wetsuit", 1, 1101924344),
                        command = "wetsuit.craft",
                        land = false,
                        itemname = "Wetsuit",
                        prefab = null,
                    },
                    #endregion Wetsuit
                    #region Diving Tank
                    ["Diving Tank Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("diving.tank", 1, 2022172587),
                        command = "divingtank.craft",
                        land = false,
                        itemname = "Diving Tank",
                        prefab = null,
                    },
                    #endregion Diving Tank
                    #region Diving Fins
                    ["Diving Fins Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("diving.fins", 1, 296519935),
                        command = "divingfins.craft",
                        land = false,
                        itemname = "Diving Fins",
                        prefab = null,
                    },
                    #endregion Diving Fins
                    #region Space Suit
                    ["Space suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hazmatsuit.spacesuit", 1, 560304835),
                        command = "spacesuit.craft",
                        land = false,
                        itemname = "Space Suit",
                        prefab = null,
                    },
                    #endregion Space Suit
                    #region Scientist Suit
                    ["Scientist Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hazmatsuit_scientist", 1, 253079493),
                        command = "scientistsuit.craft",
                        land = false,
                        itemname = "Scientist Suit",
                        prefab = null,
                    },
                    #endregion Scientist Suit
                    #region Peacekeeper Suit
                    ["Peacekeeper Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hazmatsuit_scientist_peacekeeper", 1, 1958316066),
                        command = "peacekeepersuit.craft",
                        land = false,
                        itemname = "Peacekeeper Suit",
                        prefab = null,
                    },
                    #endregion Peacekeeper Suit
                    #region Heavy Scientist Suit
                    ["Heavy Scientist Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 300),
                                new CraftItem("tarp", 30),
                                new CraftItem("sewingkit", 15),
                                new CraftItem("propanetank", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("scientistsuit_heavy", 1, 1772746857),
                        command = "heavyscientistsuit.craft",
                        land = false,
                        itemname = "Heavy Scientist Suit",
                        prefab = null,
                    },
                    #endregion Heavyhazmat Suit
                    #region Clatter Helmet
                    ["Clatter Helmet Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 35),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("clatter.helmet", 1, 968019378),
                        command = "clatterhelmet.craft",
                        land = false,
                        itemname = "Clatter Helmet",
                        prefab = null,
                    },
                    #endregion Clatter Helmet
                    #region Tactical Gloves
                    ["Tactical Gloves Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 2),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("tactical.gloves", 1, 1108136649),
                        command = "tacgloves.craft",
                        land = false,
                        itemname = "Tactical Gloves",
                        prefab = null,
                    },
                    #endregion Tactical Gloves
                    #region Frog Boots
                    ["Frog Boots Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("boots.frog", 1, 1000573653),
                        command = "frogboots.craft",
                        land = false,
                        itemname = "Frog Boots",
                        prefab = null,
                    },
                    #endregion Frog Boots
                    #region Party Hat
                    ["Party Hat Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("partyhat", 1, 575744869),
                        command = "partyhat.craft",
                        land = false,
                        itemname = "Party Hat",
                        prefab = null,
                    },
                    #endregion Party Hat
                    #region Nomad Suit
                    ["Nomad Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hazmatsuit.nomadsuit", 1, 491263800),
                        command = "nomadsuit.craft",
                        land = false,
                        itemname = "Nomad Suit",
                        prefab = null,
                    },
                    #endregion Nomad Suit
                    #region Arctic Suit
                    ["Arctic Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 10),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hazmatsuit.arcticsuit", 1, 470439097),
                        command = "arcticsuit.craft",
                        land = false,
                        itemname = "Arctic Suit",
                        prefab = "assets/prefabs/clothes/suit.hazmat/arctic/hazmat_suit_arctic.prefab",
                    },
                    #endregion Arctic Suit
					
                    #endregion Attire
                    #region Weapons (5)
					
                    #region L96 Rifle
                    ["L96 Rifle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 100),
                                new CraftItem("metal.refined", 40),
                                new CraftItem("metalspring", 4),
                                new CraftItem("metalpipe", 4),
                                new CraftItem("gears", 2),
								new CraftItem("riflebody", 1),
								new CraftItem("semibody", 1),
								
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rifle.l96", 1, 778367295),
                        command = "l96.craft",
                        land = false,
                        itemname = "L96 Rifle",
                        prefab = null,
                    },
                    #endregion L96 Rifle
                    #region M39 Rifle
                    ["M39 Rifle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 200),
                                new CraftItem("metal.refined", 50),
                                new CraftItem("metalspring", 4),
                                new CraftItem("metalpipe", 4),
                                new CraftItem("gears", 2),
								new CraftItem("riflebody", 1),
								new CraftItem("semibody", 1),
								
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rifle.m39", 1, 28201841),
                        command = "m39.craft",
                        land = false,
                        itemname = "M39 Rifle",
                        prefab = null,
                    },
                    #endregion M39 Rifle
                    #region LR-300 Assault Rifle
                    ["LR-300 Assault Rifle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 250),
                                new CraftItem("metal.refined", 75),
                                new CraftItem("metalspring", 4),
                                new CraftItem("metalpipe", 4),
                                new CraftItem("gears", 3),
								new CraftItem("riflebody", 1),
								new CraftItem("smgbody", 1),
								
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rifle.lr300", 1, 1812555177),
                        command = "lr300.craft",
                        land = false,
                        itemname = "LR-300 Assault Rifle",
                        prefab = null,
                    },
                    #endregion LR-300 Assault Rifle
                    #region M249
                    ["M249 Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("metal.refined", 100),
                                new CraftItem("metalspring", 5),
                                new CraftItem("metalpipe", 5),
                                new CraftItem("gears", 5),
								new CraftItem("riflebody", 1),
								new CraftItem("smgbody", 1),
								new CraftItem("semibody", 1),
								
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("lmg.m249", 1, 2069578888),
                        command = "m249.craft",
                        land = false,
                        itemname = "M249",
                        prefab = null,
                    },
                    #endregion M249
                    #region Multiple Grenade Launcher
                    ["Multiple Grenade Launcher Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
								
                                new CraftItem("scrap", 1000),
                                new CraftItem("metal.refined", 100),
                                new CraftItem("metalspring", 5),
                                new CraftItem("metalpipe", 5),
                                new CraftItem("gears", 5),
								new CraftItem("riflebody", 1),
								new CraftItem("smgbody", 1),
								new CraftItem("semibody", 1),
								
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("multiplegrenadelauncher", 1, 1123473824),
                        command = "launcher.craft",
                        land = false,
                        itemname = "Multiple Grenade Launcher",
                        prefab = null,
                    },
                    #endregion Multiple Grenade Launcher
					
                    #endregion Weapons
                    #region Components/Resources (6)
					
                    #region CCTV Camera
                    ["CCTV Camera Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("techparts", 10),
                                new CraftItem("metal.refined", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cctv.camera", 1, 634478325),
                        command = "cctv.craft",
                        land = false,
                        itemname = "CCTV Camera",
                        prefab = null,
                    },
                    #endregion CCTV Camera
                    #region Diesel Fuel
                    ["Diesel Fuel Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("lowgradefuel", 250),
                                new CraftItem("crude.oil", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("diesel_barrel", 1, 1568388703),
                        command = "diesel.craft",
                        land = false,
                        itemname = "Diesel Fuel",
                        prefab = "assets/prefabs/resource/diesel barrel/diesel_barrel_world.prefab",
                    },
                    #endregion Diesel Fuel
                    #region Rope
                    ["Rope Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 30),
                                new CraftItem("plantfiber", 6),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rope", 1, 1414245522),
                        command = "rope.craft",
                        land = false,
                        itemname = "Rope",
                        prefab = null,
                    },
                    #endregion Rope
                    #region Sheet Metal
                    ["Sheet Metal Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 200),
                                new CraftItem("scrap", 16),
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sheetmetal", 1, 1994909036),
                        command = "sheetmetal.craft",
                        land = false,
                        itemname = "Sheet Metal",
                        prefab = null,
                    },
                    #endregion Sheet Metal
                    #region Targeting Computer
                    ["Targeting Computer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                                new CraftItem("techparts", 20),
                                new CraftItem("metal.refined", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("targeting.computer", 1, 1523195708),
                        command = "targetingcomputer.craft",
                        land = false,
                        itemname = "Targeting Computer",
                        prefab = null,
                    },
                    #endregion Targeting Computer
                    #region Tarp
                    ["Tarp Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("tarp", 1, 2019042823),
                        command = "tarp.craft",
                        land = false,
                        itemname = "Tarp",
                        prefab = null,
                    },
                    #endregion Tarp
					
                    #endregion Components/Resources
					#region Admin Stuff (10)
					
                    #region APC
                    ["APC Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_a", 1, 9999999992),
                        command = "apc.craft",
                        land = false,
                        itemname = "Bradley APC",
                        prefab = "assets/prefabs/npc/m2bradley/bradleyapc.prefab",
                    },
                    #endregion APC
                    #region Plane
                    ["Plane Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 9999999991),
                        command = "plane.craft",
                        land = false,
                        itemname = "Cargo Plane",
                        prefab = "assets/prefabs/npc/cargo plane/cargo_plane.prefab",
                    },
                    #endregion Plane
                    #region CH47
                    ["CH47 Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 9999999990),
                        command = "ch47.craft",
                        land = false,
                        itemname = "CH47",
                        prefab = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab",
                    },
                    #endregion CH47
                    #region Patrol Heli
                    ["Patrol Heli Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 9999999989),
                        command = "patrolheli.craft",
                        land = false,
                        itemname = "Patrol Heli",
                        prefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab",
                    },
                    #endregion Patrol Heli
                    #region Ship
                    ["Ship Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("kayak", 1, 9999999988),
                        command = "ship.craft",
                        land = false,
                        itemname = "Cargo Ship",
                        prefab = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab",
                    },
                    #endregion Ship
                    #region Santa's Sleigh
                    ["Santa's Sleigh Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_d", 1, 9999999987),
                        command = "claus.craft",
                        land = false,
                        itemname = "Santa's Sleigh",
                        prefab = "assets/prefabs/misc/xmas/sleigh/santasleigh.prefab",
                    },
                    #endregion Santa's Sleigh
                    #region Admin Car
                    ["Admin Car Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("electric.generator.small", 1, 1742652663),
                        command = "car.craft",
                        land = false,
                        itemname = "Admin Car",
                        prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                    },
                    #endregion Admin Car
                    #region Admin Heli
                    ["Admin Heli Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("electric.generator.small", 1, 1771792500),
                        command = "heli.craft",
                        land = false,
                        itemname = "Admin Heli",
                        prefab = "assets/prefabs/npc/ch47/ch47.entity.prefab",
                    },
                    #endregion Admin Heli
                    #region Admin Sentry
                    ["Admin Sentry Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("electric.generator.small", 1, 9999999986),
                        command = "sentry.craft",
                        land = false,
                        itemname = "Admin Sentry",
                        prefab = "assets/content/props/sentry_scientists/sentry.scientist.static.prefab",
                    },
                    #endregion Admin Sentry
                    #region Shark
                    ["Shark Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 999999999),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("kayak", 1, 9999999999),
                        command = "shark.craft",
                        land = false,
                        itemname = "Shark",
                        prefab = "assets/rust.ai/agents/fish/simpleshark.prefab",
                    },
                    #endregion Shark
					
					#endregion Admin Stuff
                    #region Jokes/Gags/Misc (13)
					
                    #region Chippy Arcade Game
                    ["Chippy Arcade Game Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 10),
                                new CraftItem("gears", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("arcade.machine.chippy", 1, 359723196),
                        command = "arcade.craft",
                        land = false,
                        itemname = "Chippy Arcade Game",
                        prefab = "assets/prefabs/misc/chippy arcade/chippyarcademachine.prefab",
                    },
                    #endregion Chippy Arcade Game
                    #region FHC
                    ["FHC Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("glue", 1, 1899491405),
                        command = "fhc.craft",
                        land = false,
                        itemname = "Fermented Horse Cum",
                        prefab = null,
                    },
                    #endregion FHC
                    #region AWK
                    ["AWK Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("ducttape", 1, 1401987718),
                        command = "awk.craft",
                        land = false,
                        itemname = "Apocalypse Waxing Kit",
                        prefab = null,
                    },
                    #endregion AWK
                    #region Bleach
                    ["Bleach Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("bleach", 1, 1553078977),
                        command = "bleach.craft",
                        land = false,
                        itemname = "Bleach",
                        prefab = null,
                    },
                    #endregion Bleach
                    #region Industrial Wall Light
                    ["Industrial Wall Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("industrial.wall.light", 1, 1623701499),
                        command = "whitelight.craft",
                        land = false,
                        itemname = "Industrial Wall Light",
                        prefab = "assets/prefabs/misc/permstore/industriallight/industrial.wall.lamp.deployed.prefab",
                    },
                    #endregion Industrial Wall Light
                    #region Red Industrial Wall Light
                    ["Red Industrial Wall Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("industrial.wall.light.red", 1, 1160621614),
                        command = "redlight.craft",
                        land = false,
                        itemname = "Red Industrial Wall Light",
                        prefab = "assets/prefabs/misc/permstore/industriallight/industrial.wall.lamp.red.deployed.prefab",
                    },
                    #endregion Red Industrial Wall Light
                    #region Green Industrial Wall Light
                    ["Green Industrial Wall Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("industrial.wall.light.green", 1, 1268178466),
                        command = "greenlight.craft",
                        land = false,
                        itemname = "Green Industrial Wall Light",
                        prefab = "assets/prefabs/misc/permstore/industriallight/industrial.wall.lamp.green.deployed.prefab",
                    },
                    #endregion Green Industrial Wall Light
                    #region Simple Light
                    ["Simple Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("metal.fragments", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("electric.simplelight", 1, 282113991),
                        command = "simplelight.craft",
                        land = false,
                        itemname = "Simple Light",
                        prefab = "assets/prefabs/deployable/playerioents/lights/simplelight.prefab",
                    },
                    #endregion Simple Light
                    #region Slot Machine
                    ["Slot Machine Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 500),
                                new CraftItem("wood", 250),
                                new CraftItem("wiretool", 10),
                                new CraftItem("gears", 6),
                                new CraftItem("metalspring", 5),
                                new CraftItem("techparts", 4),
                                new CraftItem("electrical.memorycell", 3),
                                new CraftItem("electric.counter", 2),
                                new CraftItem("targetingcomputer", 1),
                                new CraftItem("storage.monitor", 1),
                                new CraftItem("electric.sirenlight", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("arcade.machine.chippy", 1, 9999999985),
                        command = "slots.craft",
                        land = false,
                        itemname = "Slot Machine",
                        prefab = "assets/prefabs/misc/casino/slotmachine/slotmachine.prefab",
                    },
                    #endregion Slot Machine
                    #region Card Table
                    ["Card Table Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 400),
                                new CraftItem("metal.fragments", 400),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cardtable", 1, 1081921512),
                        command = "cardtable.craft",
                        land = false,
                        itemname = "Card Table",
                        prefab = "assets/prefabs/deployable/card table/cardtable.deployed.prefab",
                    },
                    #endregion Card Table
                    #region Sofa
                    ["Sofa Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("cloth", 60),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sofa", 1, 555122905),
                        command = "sofa.craft",
                        land = false,
                        itemname = "Sofa",
                        prefab = "assets/prefabs/deployable/sofa/sofa.deployed.prefab",
                    },
                    #endregion Sofa
                    #region Pattern Sofa
                    ["Pattern Sofa Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("cloth", 60),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sofa.pattern", 1, 782422285),
                        command = "patternsofa.craft",
                        land = false,
                        itemname = "Pattern Sofa",
                        prefab = "assets/prefabs/deployable/sofa/sofa.pattern.deployed.prefab",
                    },
                    #endregion Pattern Sofa
                    #region Secret Lab Chair
                    ["Secret Lab Chair Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("secretlabchair", 1, 567871954),
                        command = "labchair.craft",
                        land = false,
                        itemname = "Secret Lab Chair",
                        prefab = "assets/prefabs/deployable/secretlab chair/secretlabchair.deployed.prefab",
                    },
                    #endregion Secret Lab Chair
					
                    #endregion Jokes/Gags/Misc
					#region Musical Instruments (10)
					
                    #region Canbourine
                    ["Canbourine Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.tambourine", 1, 1379036069),
                        command = "canbourine.craft",
                        land = false,
                        itemname = "Canbourine",
                        prefab = "assets/prefabs/instruments/tambourine/tambourine.weapon.prefab",
                    },
                    #endregion Canbourine
                    #region Cowbell
                    ["Cowbell Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 35),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.cowbell", 1, 1049881973),
                        command = "cowbell.craft",
                        land = false,
                        itemname = "Cowbell",
                        prefab = "assets/prefabs/instruments/cowbell/cowbell.weapon.prefab",
                    },
                    #endregion Cowbell
                    #region Junkyard Drum Kit
                    ["Junkyard Drum Kit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("drumkit", 1, 1330640246),
                        command = "drumkit.craft",
                        land = false,
                        itemname = "Junkyard Drum Kit",
                        prefab = "assets/prefabs/instruments/drumkit/drumkit.deployed.prefab",
                    },
                    #endregion Junkyard Drum Kit
                    #region Jerry Can Guitar
                    ["Jerry Can Guitar Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50),
                                new CraftItem("wood", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.jerrycanguitar", 1, 979951147),
                        command = "jerrycanguitar.craft",
                        land = false,
                        itemname = "Jerry Can Guitar",
                        prefab = "assets/prefabs/instruments/jerrycanguitar/jerrycanguitar.weapon.prefab",
                    },
                    #endregion Jerry Can Guitar
                    #region Pan Flute
                    ["Pan Flute Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                                new CraftItem("cloth", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.flute", 1, 2040817543),
                        command = "flute.craft",
                        land = false,
                        itemname = "Pan Flute",
                        prefab = "assets/prefabs/instruments/flute/flute.weapon.prefab",
                    },
                    #endregion Pan Flute
                    #region Plumber's Trumpet
                    ["Plumber's Trumpet Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.trumpet", 1, 273172220),
                        command = "trumpet.craft",
                        land = false,
                        itemname = "Plumber's Trumpet",
                        prefab = "assets/prefabs/instruments/trumpet/trumpet.weapon.prefab",
                    },
                    #endregion Plumber's Trumpet
                    #region Sousaphone
                    ["Sousaphone Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.tuba", 1, 1784406797),
                        command = "tuba.craft",
                        land = false,
                        itemname = "Sousaphone",
                        prefab = "assets/prefabs/instruments/tuba/tuba.weapon.prefab",
                    },
                    #endregion Sousaphone
                    #region Shovel Bass
                    ["Shovel Bass Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("wood", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.bass", 1, 2107018088),
                        command = "bass.craft",
                        land = false,
                        itemname = "Shovel Bass",
                        prefab = "assets/prefabs/instruments/bass/bass.weapon.prefab",
                    },
                    #endregion Shovel Bass
                    #region Wheelbarrow Piano
                    ["Wheelbarrow Piano Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("piano", 1, 1272430949),
                        command = "piano.craft",
                        land = false,
                        itemname = "Wheelbarrow Piano",
                        prefab = "assets/prefabs/instruments/piano/piano.deployed.prefab",
                    },
                    #endregion Wheelbarrow Piano
                    #region Xylobone
                    ["Xylobone Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("bone.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xylophone", 1, 211235948),
                        command = "xylobone.craft",
                        land = false,
                        itemname = "Xylobone",
                        prefab = "assets/prefabs/instruments/xylophone/xylophone.deployed.prefab",
                    },
                    #endregion Xylobone
					
					#endregion Musical Instruments
					#region VoicePropsPack (15)
					
                    #region Cassette Recorder
                    ["Cassette Recorder Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.casetterecorder", 1, 1530414568),
                        command = "recorder.craft",
                        land = false,
                        itemname = "Cassette Recorder",
                        prefab = "assets/prefabs/voiceaudio/cassetterecorder/cassetterecorder.weapon.prefab",
                    },
                    #endregion Cassette Recorder
                    #region Cassette - Short
                    ["Cassette - Short Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cassette.short", 1, 1523403414),
                        command = "cassette1.craft",
                        land = false,
                        itemname = "Cassette - Short",
                        prefab = "assets/prefabs/voiceaudio/cassette/cassette.short.entity.prefab",
                    },
                    #endregion Cassette - Short
                    #region Cassette - Medium
                    ["Cassette - Medium Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cassette.medium", 1, 912398867),
                        command = "cassette2.craft",
                        land = false,
                        itemname = "Cassette - Medium",
                        prefab = "assets/prefabs/voiceaudio/cassette/cassette.medium.entity.prefab",
                    },
                    #endregion Cassette - Medium
                    #region Cassette - Long
                    ["Cassette - Long Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cassette", 1, 476066818),
                        command = "cassette3.craft",
                        land = false,
                        itemname = "Cassette - Long",
                        prefab = "assets/prefabs/voiceaudio/cassette/cassette.entity.prefab",
                    },
                    #endregion Cassette - Long
                    #region Mobile Phone
                    ["Mobile Phone Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("mobilephone", 1, 20045316),
                        command = "mobilephone.craft",
                        land = false,
                        itemname = "Mobile Phone",
                        prefab = "assets/prefabs/voiceaudio/mobilephone/mobilephone.weapon.prefab",
                    },
                    #endregion Mobile Phone
                    #region Boom Box
                    ["Boom Box Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("boombox", 1, 1113501606),
                        command = "boombox1.craft",
                        land = false,
                        itemname = "Boom Box",
                        prefab = "assets/prefabs/voiceaudio/boombox/boombox.deployed.prefab",
                    },
                    #endregion Boom Box
                    #region Portable Boom Box
                    ["Portable Boom Box Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("fun.boomboxportable", 1, 576509618),
                        command = "boombox2.craft",
                        land = false,
                        itemname = "Portable Boom Box",
                        prefab = "assets/prefabs/voiceaudio/boomboxportable/boomboxportable.weapon.prefab",
                    },
                    #endregion Portable Boom Box
                    #region Connected Speaker
                    ["Connected Speaker Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("connected.speaker", 1, 968421290),
                        command = "connectedspeaker.craft",
                        land = false,
                        itemname = "Connected Speaker",
                        prefab = "assets/prefabs/voiceaudio/hornspeaker/connectedspeaker.deployed.prefab",
                    },
                    #endregion Connected Speaker
                    #region Megaphone
                    ["Megaphone Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("wood", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("megaphone", 1, 583379016),
                        command = "megaphone.craft",
                        land = false,
                        itemname = "Megaphone",
                        prefab = "assets/prefabs/voiceaudio/megaphone/megaphone.weapon.prefab",
                    },
                    #endregion Megaphone
                    #region Microphone Stand
                    ["Microphone Stand Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("microphonestand", 1, 39600618),
                        command = "microphonestand.craft",
                        land = false,
                        itemname = "Microphone Stand",
                        prefab = "assets/prefabs/voiceaudio/microphonestand/microphonestand.deployed.prefab",
                    },
                    #endregion Microphone Stand
                    #region Sound Light
                    ["Sound Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("soundlight", 1, 343857907),
                        command = "soundlight.craft",
                        land = false,
                        itemname = "Sound Light",
                        prefab = "assets/prefabs/voiceaudio/soundlight/soundlight.deployed.prefab",
                    },
                    #endregion Sound Light
                    #region Laser Light
                    ["Laser Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("laserlight", 1, 853471967),
                        command = "laserlight.craft",
                        land = false,
                        itemname = "Laser Light",
                        prefab = "assets/prefabs/voiceaudio/laserlight/laserlight.deployed.prefab",
                    },
                    #endregion Laser Light
                    #region Disco Floor
                    ["Disco Floor Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("discofloor", 1, 286648290),
                        command = "discofloor.craft",
                        land = false,
                        itemname = "Disco Floor",
                        prefab = "assets/prefabs/voiceaudio/discofloor/discofloor.deployed.prefab",
                    },
                    #endregion Disco Floor
                    #region Disco Floor Large Tiles
                    ["Disco Floor Large Tiles Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("discofloor.largetiles", 1, 1735402444),
                        command = "discofloorlarge.craft",
                        land = false,
                        itemname = "Disco Floor Large Tiles",
                        prefab = "assets/prefabs/voiceaudio/discofloor/skins/discofloor.largetiles.deployed.prefab",
                    },
                    #endregion Disco Floor Large Tiles
                    #region Disco Ball
                    ["Disco Ball Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("discoball", 1, 1895235349),
                        command = "discoball.craft",
                        land = false,
                        itemname = "Disco Ball",
                        prefab = "assets/prefabs/voiceaudio/discoball/discoball.deployed.prefab",
                    },
                    #endregion Disco Ball
					
					#endregion VoicePropsPack
					
                    #endregion Items
                    #region Seasonal (136)
					
                    #region Summer (15)
					
                    #region Water Pistol
                    ["Water Pistol Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("pistol.water", 1, 1815301988),
                        command = "waterpistol.craft",
                        land = false,
                        itemname = "Water Pistol",
                        prefab = "assets/prefabs/misc/summer_dlc/waterpistol/waterpistol.entity.prefab",
                    },
                    #endregion Water Pistol
                    #region Water Gun
                    ["Water Gun Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("gun.water", 1, 722955039),
                        command = "watergun.craft",
                        land = false,
                        itemname = "Water Gun",
                        prefab = "assets/prefabs/misc/summer_dlc/watergun/watergun.entity.prefab",
                    },
                    #endregion Water Gun
                    #region Paddling Pool
                    ["Paddling Pool Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("paddlingpool", 1, 733625651),
                        command = "pool1.craft",
                        land = false,
                        itemname = "Paddling Pool",
                        prefab = "assets/prefabs/misc/summer_dlc/paddling_pool/paddlingpool.deployed.prefab",
                    },
                    #endregion Paddling Pool
                    #region Above Ground Pool
                    ["Above Ground Pool Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 500),
                                new CraftItem("metal.fragments", 200),
                                new CraftItem("tarp", 3),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("abovegroundpool", 1, 1840570710),
                        command = "pool2.craft",
                        land = false,
                        itemname = "Above Ground Pool",
                        prefab = "assets/prefabs/misc/summer_dlc/abovegroundpool/abovegroundpool.deployed.prefab",
                    },
                    #endregion Above Ground Pool
                    #region Beach Chair
                    ["Beach Chair Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 50),
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("beachchair", 1, 321431890),
                        command = "beachchair.craft",
                        land = false,
                        itemname = "Beach Chair",
                        prefab = "assets/prefabs/misc/summer_dlc/beach_chair/beachchair.deployed.prefab",
                    },
                    #endregion Beach Chair
                    #region Beach Parasol
                    ["Beach Parasol Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("beachparasol", 1, 1621539785),
                        command = "beachparasol.craft",
                        land = false,
                        itemname = "Beach Parasol",
                        prefab = "assets/prefabs/misc/summer_dlc/beach_chair/beachparasol.deployed.prefab",
                    },
                    #endregion Beach Parasol
                    #region Beach Table
                    ["Beach Table Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("beachtable", 1, 657352755),
                        command = "beachtable.craft",
                        land = false,
                        itemname = "Beach Table",
                        prefab = "assets/prefabs/misc/summer_dlc/beach_chair/beachtable.deployed.prefab",
                    },
                    #endregion Beach Table
                    #region Beach Towel
                    ["Beach Towel Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("beachtowel", 1, 8312704),
                        command = "beachtowel.craft",
                        land = false,
                        itemname = "Beach Towel",
                        prefab = "assets/prefabs/misc/summer_dlc/beach_towel/beachtowel.deployed.prefab",
                    },
                    #endregion Beach Towel
                    #region Boogie Board
                    ["Boogie Board Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("tarp", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("boogieboard", 1, 1478094705),
                        command = "boogieboard.craft",
                        land = false,
                        itemname = "Boogie Board",
                        prefab = "assets/prefabs/misc/summer_dlc/boogie_board/boogieboard.deployed.prefab",
                    },
                    #endregion Boogie Board
                    #region Inner Tube
                    ["Inner Tube Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("tarp", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("innertube", 1, 697981032),
                        command = "innertube.craft",
                        land = false,
                        itemname = "Inner Tube",
                        prefab = "assets/prefabs/misc/summer_dlc/inner_tube/innertube.deployed.prefab",
                    },
                    #endregion Inner Tube
                    #region Sunglasses
                    ["Sunglasses Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 60),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sunglasses", 1, 352321488),
                        command = "sunglasses.craft",
                        land = false,
                        itemname = "Sunglasses",
                        prefab = null,
                    },
                    #endregion Sunglasses
                    #region Instant Camera
                    ["Instant Camera Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 75),
                                new CraftItem("gears", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("tool.instant_camera", 1, 2001260025),
                        command = "instantcamera.craft",
                        land = false,
                        itemname = "Instant Camera",
                        prefab = "assets/prefabs/misc/summer_dlc/instantcamera/instant_camera.entity.prefab",
                    },
                    #endregion Instant Camera
                    #region Portrait Photo Frame
                    ["Portrait Photo Frame Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("photoframe.portrait", 1, 1729712564),
                        command = "photoportrait.craft",
                        land = false,
                        itemname = "Portrait Photo Frame",
                        prefab = "assets/prefabs/misc/summer_dlc/photoframe/photoframe.portrait.prefab",
                    },
                    #endregion Portrait Photo Frame
                    #region Landscape Photo Frame
                    ["Landscape Photo Frame Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("photoframe.landscape", 1, 1697996440),
                        command = "photolandscape.craft",
                        land = false,
                        itemname = "Landscape Photo Frame",
                        prefab = "assets/prefabs/misc/summer_dlc/photoframe/photoframe.landscape.prefab",
                    },
                    #endregion Landscape Photo Frame
                    #region Large Photo Frame
                    ["Large Photo Frame Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("photoframe.large", 1, 1205084994),
                        command = "photolarge.craft",
                        land = false,
                        itemname = "Large Photo Frame",
                        prefab = "assets/prefabs/misc/summer_dlc/photoframe/photoframe.landscape.prefab",
                    },
                    #endregion Large Photo Frame
					
                    #endregion Summer
                    #region Halloween (42)
					
                    #region A Barrel Costume
                    ["A Barrel Costume Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("water.barrel", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("barrelcostume", 1, 1215166612),
                        command = "barrelcostume.craft",
                        land = false,
                        itemname = "A Barrel Costume",
                        prefab = null,
                    },
                    #endregion A Barrel Costume
                    #region Scarecrow Wrap
                    ["Scarecrow Wrap Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 75),
                                new CraftItem("sewingkit", 3),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("scarecrowhead", 1, 809942731),
                        command = "scarecrowhead.craft",
                        land = false,
                        itemname = "Scarecrow Wrap",
                        prefab = null,
                    },
                    #endregion Scarecrow Wrap
                    #region Scarecrow Suit
                    ["Scarecrow Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 125),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("scarecrow.suit", 1, 273951840),
                        command = "scarecrowsuit.craft",
                        land = false,
                        itemname = "Scarecrow Suit",
                        prefab = null,
                    },
                    #endregion Scarecrow Suit
                    #region Coffin
                    ["Coffin Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 500),
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("coffin.storage", 1, 573676040),
                        command = "coffin.craft",
                        land = false,
                        itemname = "Coffin",
                        prefab = "assets/prefabs/misc/halloween/coffin/coffinstorage.prefab",
                    },
                    #endregion Coffin
                    #region Cursed Cauldron
                    ["Cursed Cauldron Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cursedcauldron", 1, 1242522330),
                        command = "cursedcauldron.craft",
                        land = false,
                        itemname = "Cursed Cauldron",
                        prefab = "assets/prefabs/misc/halloween/cursed_cauldron/cursedcauldron.deployed.prefab",
                    },
                    #endregion Cursed Cauldron
                    #region Fogger-3000
                    ["Fogger-3000 Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("lowgradefuel", 30),
                                new CraftItem("metalpipe", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("fogmachine", 1, 1973785141),
                        command = "fogger.craft",
                        land = false,
                        itemname = "Fogger-3000",
                        prefab = "assets/content/props/fog machine/fogmachine.prefab",
                    },
                    #endregion Fogger-3000
                    #region Gravestone
                    ["Gravestone Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("stones", 250),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("gravestone", 1, 809199956),
                        command = "gravestone.craft",
                        land = false,
                        itemname = "Gravestone",
                        prefab = "assets/prefabs/misc/halloween/deployablegravestone/gravestone.stone.deployed.prefab",
                    },
                    #endregion Gravestone
                    #region Graveyard Fence
                    ["Graveyard Fence Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("stones", 250),
                                new CraftItem("metal.fragments", 75),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("wall.graveyard.fence", 1, 1679267738),
                        command = "graveyardfence.craft",
                        land = false,
                        itemname = "Graveyard Fence",
                        prefab = "assets/prefabs/misc/halloween/graveyard_fence/graveyardfence.prefab",
                    },
                    #endregion Graveyard Fence
                    #region Large Candle Set
                    ["Large Candle Set Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("fat.animal", 35),
                                new CraftItem("cloth", 8),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(false, true, true),
                        item = new CraftItem("largecandles", 1, 489848205),
                        command = "largecandles.craft",
                        land = false,
                        itemname = "Large Candle Set",
                        prefab = "assets/prefabs/misc/halloween/candles/largecandleset.prefab",
                    },
                    #endregion Large Candle Set
                    #region Small Candle Set
                    ["Small Candle Set Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("fat.animal", 20),
                                new CraftItem("cloth", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("smallcandles", 1, 2058362263),
                        command = "smallcandles.craft",
                        land = false,
                        itemname = "Small Candle Set",
                        prefab = "assets/prefabs/misc/halloween/candles/smallcandleset.prefab",
                    },
                    #endregion Small Candle Set
                    #region Spider Webs
                    ["Spider Webs Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("spiderweb", 1, 882559853),
                        command = "spiderweb.craft",
                        land = false,
                        itemname = "Spider Webs",
                        prefab = "assets/prefabs/misc/halloween/spiderweb/spiderweba.prefab",
                    },
                    #endregion Spider Webs
                    #region Spooky Speaker
                    ["Spooky Speaker Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 400),
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("spookyspeaker", 1, 1885488976),
                        command = "spookyspeaker.craft",
                        land = false,
                        itemname = "Spooky Speaker",
                        prefab = "assets/prefabs/misc/halloween/spookyspeaker/spookyspeaker.prefab",
                    },
                    #endregion Spooky Speaker
                    #region Strobe Light
                    ["Strobe Light Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("strobelight", 1, 2104517339),
                        command = "strobelight.craft",
                        land = false,
                        itemname = "Strobe Light",
                        prefab = "assets/content/props/strobe light/strobelight.prefab",
                    },
                    #endregion Strobe Light
                    #region Wooden Cross
                    ["Wooden Cross Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 250),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("woodcross", 1, 699075597),
                        command = "woodcross.craft",
                        land = false,
                        itemname = "Wooden Cross",
                        prefab = "assets/prefabs/misc/halloween/deployablegravestone/gravestone.wood.deployed.prefab",
                    },
                    #endregion Wooden Cross
                    #region Butcher Knife
                    ["Butcher Knife Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 150),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("knife.butcher", 1, 194509282),
                        command = "butcherknife.craft",
                        land = false,
                        itemname = "Butcher Knife",
                        prefab = "assets/prefabs/weapons/halloween/butcher knife/butcherknife.entity.prefab",
                    },
                    #endregion Butcher Knife
                    #region Pitchfork
                    ["Pitchfork Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 600),
                                new CraftItem("metal.fragments", 300),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("pitchfork", 1, 1090916276),
                        command = "pitchfork.craft",
                        land = false,
                        itemname = "Pitchfork",
                        prefab = "assets/prefabs/weapons/halloween/pitchfork/pitchfork.entity.prefab",
                    },
                    #endregion Pitchfork
                    #region Sickle
                    ["Sickle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 250),
                                new CraftItem("metal.fragments", 150),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sickle", 1, 1368584029),
                        command = "sickle.craft",
                        land = false,
                        itemname = "Sickle",
                        prefab = "assets/prefabs/weapons/halloween/sickle/sickle.entity.prefab",
                    },
                    #endregion Sickle
                    #region Skull Trophy
                    ["Skull Trophy Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("metal.fragments", 25),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("skull.trophy", 1, 769647921),
                        command = "skulltrophy.craft",
                        land = false,
                        itemname = "Skull Trophy",
                        prefab = "assets/prefabs/misc/halloween/trophy skulls/skulltrophy.deployed.prefab",
                    },
                    #endregion Skull Trophy
                    #region Skull Spikes
                    ["Skull Spikes Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 150),
                                new CraftItem("skull.human", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("skullspikes", 1, 1073015016),
                        command = "skullspikes.craft",
                        land = false,
                        itemname = "Skull Spikes",
                        prefab = "assets/prefabs/misc/halloween/skull spikes/skullspikes.deployed.prefab",
                    },
                    #endregion Skull Spikes
                    #region Mummy Suit
                    ["Mummy Suit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                                new CraftItem("tarp", 5),
                                new CraftItem("sewingkit", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("halloween.mummysuit", 1, 277730763),
                        command = "mummysuit.craft",
                        land = false,
                        itemname = "Mummy Suit",
                        prefab = null,
                    },
                    #endregion Mummy Suit
                    #region Ghost Costume
                    ["Ghost Costume Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 200),
                                new CraftItem("sewingkit", 4),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("ghostsheet", 1, 1043618880),
                        command = "ghostsheet.craft",
                        land = false,
                        itemname = "Ghost Costume",
                        prefab = null,
                    },
                    #endregion Ghost Costume
                    #region Crate Costume
                    ["Crate Costume Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 500),
                                new CraftItem("metal.fragments", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("cratecostume", 1, 1189981699),
                        command = "cratecostume.craft",
                        land = false,
                        itemname = "Crate Costume",
                        prefab = null,
                    },
                    #endregion Crate Costume
                    #region Skull Door Knocker
                    ["Skull Door Knocker Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("skulldoorknocker", 1, 216116642),
                        command = "skullknocker.craft",
                        land = false,
                        itemname = "Skull Door Knocker",
                        prefab = "assets/prefabs/misc/halloween/skull_door_knocker/skull_door_knocker.deployed.prefab",
                    },
                    #endre