gion Skull Door Knocker
                    #region Glowing Eyes
                    ["Glowing Eyes Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("gloweyes", 1, 690276911),
                        command = "gloweyes.craft",
                        land = false,
                        itemname = "Glowing Eyes",
                        prefab = null,
                    },
                    #endregion Glowing Eyes
                    #region Scarecrow
                    ["Scarecrow Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 200),
                                new CraftItem("cloth", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("scarecrow", 1, 177226991),
                        command = "scarecrow.craft",
                        land = false,
                        itemname = "Scarecrow",
                        prefab = "assets/prefabs/misc/halloween/scarecrow/scarecrow.deployed.prefab",
                    },
                    #endregion Scarecrow
                    #region Skull Fire Pit
                    ["Skull Fire Pit Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("skull.human", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("skull_fire_pit", 1, 553887414),
                        command = "skullfirepit.craft",
                        land = false,
                        itemname = "Skull Fire Pit",
                        prefab = "assets/prefabs/misc/halloween/skull_fire_pit/skull_fire_pit.prefab",
                    },
                    #endregion Skull Fire Pit
                    #region Surgeon Scrubs
                    ["Surgeon Scrubs Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 60),
                                new CraftItem("sewingkit", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("halloween.surgeonsuit", 1, 1785231475),
                        command = "surgeonsuit.craft",
                        land = false,
                        itemname = "Surgeon Scrubs",
                        prefab = null,
                    },
                    #endregion Surgeon Scrubs
                    #region Halloween Candy
                    ["Halloween Candy Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("halloween.candy", 1, 888153050),
                        command = "halloweencandy.craft",
                        land = false,
                        itemname = "Halloween Candy",
                        prefab = null,
                    },
                    #endregion Halloween Candy
                    #region Pumpkin Bucket
                    ["Pumpkin Bucket Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("scrap", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("pumpkinbasket", 1, 1346158228),
                        command = "pumpkinbasket.craft",
                        land = false,
                        itemname = "Pumpkin Bucket",
                        prefab = "assets/prefabs/misc/halloween/pumpkin_bucket/pumpkin_basket.entity.prefab",
                    },
                    #endregion Pumpkin Bucket
                    #region Carvable Pumpkin
                    ["Carvable Pumpkin Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("pumpkin", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("carvable.pumpkin", 1, 1524980732),
                        command = "pumpkinlantern.craft",
                        land = false,
                        itemname = "Carvable Pumpkin",
                        prefab = "assets/prefabs/misc/halloween/carvablepumpkin/carvable.pumpkin.prefab",
                    },
                    #endregion Carvable Pumpkin
                    #region Jack O Lantern Angry
                    ["Jack O Lantern Angry Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("pumpkin", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("jackolantern.angry", 1, 1242482355),
                        command = "lanternangry.craft",
                        land = false,
                        itemname = "Jack O Lantern Angry",
                        prefab = "assets/prefabs/deployable/jack o lantern/jackolantern.angry.prefab",
                    },
                    #endregion Jack O Lantern Angry
                    #region Jack O Lantern Happy
                    ["Jack O Lantern Happy Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("pumpkin", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("jackolantern.happy", 1, 1824943010),
                        command = "lanternhappy.craft",
                        land = false,
                        itemname = "Jack O Lantern Happy",
                        prefab = "assets/prefabs/deployable/jack o lantern/jackolantern.happy.prefab",
                    },
                    #endregion Jack O Lantern Happy
                    #region Frankenstein Table
                    ["Frankenstein Table Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 200),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteintable", 1, 1575635062),
                        command = "frankensteintable.craft",
                        land = false,
                        itemname = "Frankenstein Table",
                        prefab = "assets/prefabs/deployable/frankensteintable/frankensteintable.deployed.prefab",
                    },
                    #endregion Frankenstein Table
                    #region Light Frankenstein Head
                    ["Light Frankenstein Head Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 5),
                                new CraftItem("fat.animal", 10),
								new CraftItem("bone.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.01.head", 1, 134959124),
                        command = "lightfrankhead.craft",
                        land = false,
                        itemname = "Light Frankenstein Head",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_01/frankensteins_monster_01_head.prefab",
                    },
                    #endregion Light Frankenstein Head
                    #region Light Frankenstein Torso
                    ["Light Frankenstein Torso Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 5),
                                new CraftItem("fat.animal", 10),
								new CraftItem("bone.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.01.torso", 1, 1624770297),
                        command = "lightfranktorso.craft",
                        land = false,
                        itemname = "Light Frankenstein Torso",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_01/frankensteins_monster_01_torso.prefab",
                    },
                    #endregion Light Frankenstein Torso
                    #region Light Frankenstein Legs
                    ["Light Frankenstein Legs Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 5),
                                new CraftItem("fat.animal", 10),
								new CraftItem("bone.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.01.legs", 1, 106959911),
                        command = "lightfranklegs.craft",
                        land = false,
                        itemname = "Light Frankenstein Legs",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_01/frankensteins_monster_01_legs.prefab",
                    },
                    #endregion Light Frankenstein Legs
                    #region Medium Frankenstein Head
                    ["Medium Frankenstein Head Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 7),
                                new CraftItem("fat.animal", 15),
								new CraftItem("bone.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.02.head", 1, 1732475823),
                        command = "mediumfrankhead.craft",
                        land = false,
                        itemname = "Medium Frankenstein Head",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_02/frankensteins_monster_02_head.prefab",
                    },
                    #endregion Medium Frankenstein Head
                    #region Medium Frankenstein Torso
                    ["Medium Frankenstein Torso Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 7),
                                new CraftItem("fat.animal", 15),
								new CraftItem("bone.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.02.torso", 1, 1491753484),
                        command = "mediumfranktorso.craft",
                        land = false,
                        itemname = "Medium Frankenstein Torso",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_02/frankensteins_monster_02_torso.prefab",
                    },
                    #endregion Medium Frankenstein Torso
                    #region Medium Frankenstein Legs
                    ["Medium Frankenstein Legs Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 7),
                                new CraftItem("fat.animal", 15),
								new CraftItem("bone.fragments", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.02.legs", 1, 835042040),
                        command = "mediumfranklegs.craft",
                        land = false,
                        itemname = "Medium Frankenstein Legs",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_02/frankensteins_monster_02_legs.prefab",
                    },
                    #endregion Medium Frankenstein Legs
                    #region Heavy Frankenstein Head
                    ["Heavy Frankenstein Head Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 10),
                                new CraftItem("fat.animal", 25),
								new CraftItem("bone.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.03.head", 1, 297099594),
                        command = "heavyfrankhead.craft",
                        land = false,
                        itemname = "Heavy Frankenstein Head",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_03/frankensteins_monster_03_head.prefab",
                    },
                    #endregion Heavy Frankenstein Head
                    #region Heavy Frankenstein Torso
                    ["Heavy Frankenstein Torso Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 10),
                                new CraftItem("fat.animal", 25),
								new CraftItem("bone.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.03.torso", 1, 1614528785),
                        command = "heavyfranktorso.craft",
                        land = false,
                        itemname = "Heavy Frankenstein Torso",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_03/frankensteins_monster_03_torso.prefab",
                    },
                    #endregion Heavy Frankenstein Torso
                    #region Heavy Frankenstein Legs
                    ["Heavy Frankenstein Legs Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("humanmeat.raw", 10),
                                new CraftItem("fat.animal", 25),
								new CraftItem("bone.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("frankensteins.monster.03.legs", 1, 2024549027),
                        command = "heavyfranklegs.craft",
                        land = false,
                        itemname = "Heavy Frankenstein Legs",
                        prefab = "assets/prefabs/misc/halloween/frankensteins_monster_03/frankensteins_monster_03_legs.prefab",
                    },
                    #endregion Heavy Frankenstein Legs
					
                    #endregion Halloween
                    #region Easter (12)
					
                    #region Bunny Ears
                    ["Bunny Ears Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("attire.bunnyears", 1, 1004426654),
                        command = "bunnyears.craft",
                        land = false,
                        itemname = "Bunny Ears",
                        prefab = null,
                    },
                    #endregion Bunny Ears
                    #region Bunny Onesie
                    ["Bunny Onesie Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("attire.bunny.onesie", 1, 1266045928),
                        command = "bunnyonesie.craft",
                        land = false,
                        itemname = "Bunny Onesie",
                        prefab = null,
                    },
                    #endregion Bunny Onesie
                    #region Rustigé Egg - Red
                    ["Rustigé Egg - Red Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_a", 1, 173268129),
                        command = "eggred.craft",
                        land = false,
                        itemname = "Rustigé Egg - Red",
                        prefab = "assets/prefabs/misc/easter/faberge_egg_a/rustigeegg_a.deployed.prefab",
                    },
                    #endregion Rustigé Egg - Red
                    #region Rustigé Egg - Blue
                    ["Rustigé Egg - Blue Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_b", 1, 173268132),
                        command = "eggblue.craft",
                        land = false,
                        itemname = "Rustigé Egg - Blue",
                        prefab = "assets/prefabs/misc/easter/faberge_egg_b/rustigeegg_b.deployed.prefab",
                    },
                    #endregion Rustigé Egg - Blue
                    #region Rustigé Egg - Purple
                    ["Rustigé Egg - Purple Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_c", 1, 173268131),
                        command = "eggpurple.craft",
                        land = false,
                        itemname = "Rustigé Egg - Purple",
                        prefab = "assets/prefabs/misc/easter/faberge_egg_c/rustigeegg_c.deployed.prefab",
                    },
                    #endregion Rustigé Egg - Purple
                    #region Rustigé Egg - Ivory
                    ["Rustigé Egg - Ivory Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_d", 1, 173268126),
                        command = "eggivory.craft",
                        land = false,
                        itemname = "Rustigé Egg - Ivory",
                        prefab = "assets/prefabs/misc/easter/faberge_egg_d/rustigeegg_d.deployed.prefab",
                    },
                    #endregion Rustigé Egg - Ivory
                    #region Rustigé Egg - Green
                    ["Rustigé Egg - Green Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("rustige_egg_e", 1, 173268125),
                        command = "egggreen.craft",
                        land = false,
                        itemname = "Rustigé Egg - Green",
                        prefab = "assets/prefabs/misc/easter/faberge_egg_e/rustigeegg_e.deployed.prefab",
                    },
                    #endregion Rustigé Egg - Green
                    #region Easter Door Wreath
                    ["Easter Door Wreath Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("easterdoorwreath", 1, 979302481),
                        command = "easterwreath.craft",
                        land = false,
                        itemname = "Easter Door Wreath",
                        prefab = "assets/prefabs/misc/easter/door_wreath/easter_door_wreath_deployed.prefab",
                    },
                    #endregion Easter Door Wreath
                    #region Nest Hat
                    ["Nest Hat Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("skull.wolf", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("attire.nesthat", 1, 1081315464),
                        command = "nesthat.craft",
                        land = false,
                        itemname = "Nest Hat",
                        prefab = null,
                    },
                    #endregion Nest Hat
                    #region Bunny Hat
                    ["Bunny Hat Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hat.bunnyhat", 1, 23391694),
                        command = "bunnyhat.craft",
                        land = false,
                        itemname = "Bunny Hat",
                        prefab = null,
                    },
                    #endregion Bunny Hat
                    #region Painted Egg
                    ["Painted Egg Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("easter.paintedeggs", 1, 126305173),
                        command = "eastereggs.craft",
                        land = false,
                        itemname = "Painted Egg",
                        prefab = null,
                    },
                    #endregion Painted Egg
                    #region Egg Basket
                    ["Egg Basket Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("scrap", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("easterbasket", 1, 1856217390),
                        command = "easterbasket.craft",
                        land = false,
                        itemname = "Egg Basket",
                        prefab = "assets/prefabs/misc/easter/easter basket/easter_basket.entity.prefab",
                    },
                    #endregion Egg Basket
					
                    #endregion Easter
                    #region Lunar New Year (26)
					
                    #region Blue Boomer
                    ["Blue Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.blue", 1, 1744298439),
                        command = "blueboomer.craft",
                        land = false,
                        itemname = "Blue Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortarblue.prefab",
                    },
                    #endregion Blue Boomer
                    #region Green Boomer
                    ["Green Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.green", 1, 656349006),
                        command = "greenboomer.craft",
                        land = false,
                        itemname = "Green Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortargreen.prefab",
                    },
                    #endregion Green Boomer
                    #region Red Boomer
                    ["Red Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.red", 1, 1553999294),
                        command = "redboomer.craft",
                        land = false,
                        itemname = "Red Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortarred.prefab",
                    },
                    #endregion Red Boomer
                    #region Orange Boomer
                    ["Orange Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.orange", 1, 7270019),
                        command = "orangeboomer.craft",
                        land = false,
                        itemname = "Orange Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortarorange.prefab",
                    },
                    #endregion Orange Boomer
                    #region Violet Boomer
                    ["Violet Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.violet", 1, 280223496),
                        command = "violetboomer.craft",
                        land = false,
                        itemname = "Violet Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortarviolet.prefab",
                    },
                    #endregion Violet Boomer
                    #region Champagne Boomer
                    ["Champagne Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 30),
                                new CraftItem("gunpowder", 75),
                                new CraftItem("lowgradefuel", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.champagne", 1, 1324203999),
                        command = "champagneboomer.craft",
                        land = false,
                        itemname = "Champagne Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/mortarchampagne.prefab",
                    },
                    #endregion Champagne Boomer
                    #region Red Roman Candle
                    ["Red Roman Candle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("lowgradefuel", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.romancandle.red", 1, 1486461488),
                        command = "redromancandle.craft",
                        land = false,
                        itemname = "Red Roman Candle",
                        prefab = "assets/prefabs/deployable/fireworks/romancandle.prefab",
                    },
                    #endregion Red Roman Candle
                    #region Blue Roman Candle
                    ["Blue Roman Candle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("lowgradefuel", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.romancandle.blue", 1, 515830359),
                        command = "blueromancandle.craft",
                        land = false,
                        itemname = "Blue Roman Candle",
                        prefab = "assets/prefabs/deployable/fireworks/romancandle-blue.prefab",
                    },
                    #endregion Blue Roman Candle
                    #region Green Roman Candle
                    ["Green Roman Candle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("lowgradefuel", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.romancandle.green", 1, 1306288356),
                        command = "greenromancandle.craft",
                        land = false,
                        itemname = "Green Roman Candle",
                        prefab = "assets/prefabs/deployable/fireworks/romancandle-green.prefab",
                    },
                    #endregion Green Roman Candle
                    #region Violet Roman Candle
                    ["Violet Roman Candle Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("lowgradefuel", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.romancandle.violet", 1, 99886070),
                        command = "violetromancandle.craft",
                        land = false,
                        itemname = "Violet Roman Candle",
                        prefab = "assets/prefabs/deployable/fireworks/romancandle-violet.prefab",
                    },
                    #endregion Violet Roman Candle
                    #region White Volcano Firework
                    ["White Volcano Firework Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                                new CraftItem("gunpowder", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.volcano", 1, 261913429),
                        command = "whitevolcano.craft",
                        land = false,
                        itemname = "White Volcano Firework",
                        prefab = "assets/prefabs/deployable/fireworks/volcanofirework.prefab",
                    },
                    #endregion White Volcano Firework
                    #region Red Volcano Firework
                    ["Red Volcano Firework Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                                new CraftItem("gunpowder", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.volcano.red", 1, 454370658),
                        command = "redvolcano.craft",
                        land = false,
                        itemname = "Red Volcano Firework",
                        prefab = "assets/prefabs/deployable/fireworks/volcanofirework-red.prefab",
                    },
                    #endregion Red Volcano Firework
                    #region Violet Volcano Firework
                    ["Violet Volcano Firework Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                                new CraftItem("gunpowder", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.volcano.violet", 1, 1538109120),
                        command = "violetvolcano.craft",
                        land = false,
                        itemname = "Violet Volcano Firework",
                        prefab = "assets/prefabs/deployable/fireworks/volcanofirework-violet.prefab",
                    },
                    #endregion Violet Volcano Firework
                    #region Firecracker String
                    ["Firecracker String Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                 new CraftItem("metal.fragments", 10),
                                new CraftItem("gunpowder", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("lunar.firecrackers", 1, 1961560162),
                        command = "firecracker.craft",
                        land = false,
                        itemname = "Firecracker String",
                        prefab = null,
                    },
                    #endregion Firecracker String
                    #region Rat Mask
                    ["Rat Mask Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("skull.wolf", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hat.ratmask", 1, 271048478),
                        command = "ratmask.craft",
                        land = false,
                        itemname = "Rat Mask",
                        prefab = null,
                    },
                    #endregion Rat Mask
                    #region Ox Mask
                    ["Ox Mask Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("skull.wolf", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hat.oxmask", 1, 1315082560),
                        command = "oxmask.craft",
                        land = false,
                        itemname = "Ox Mask",
                        prefab = null,
                    },
                    #endregion Ox Mask
                    #region Dragon Mask
                    ["Dragon Mask Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("skull.wolf", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hat.dragonmask", 1, 1081315464),
                        command = "dragonmask.craft",
                        land = false,
                        itemname = "Dragon Mask",
                        prefab = null,
                    },
                    #endregion Dragon Mask
                    #region New Year Gong
                    ["New Year Gong Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("metal.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("newyeargong", 1, 961457160),
                        command = "gong.craft",
                        land = false,
                        itemname = "New Year Gong",
                        prefab = "assets/prefabs/misc/chinesenewyear/newyeargong/newyeargong.deployed.prefab",
                    },
                    #endregion New Year Gong
                    #region Dragon Door Knocker
                    ["Dragon Door Knocker Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("dragondoorknocker", 1, 854270928),
                        command = "dragonknocker.craft",
                        land = false,
                        itemname = "Dragon Door Knocker",
                        prefab = "assets/prefabs/misc/chinesenewyear/dragondoorknocker/dragondoorknocker.deployed.prefab",
                    },
                    #endregion Dragon Door Knocker
                    #region Chinese Lantern
                    ["Chinese Lantern Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 25),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("chineselantern", 1, 1916473915),
                        command = "chineselantern.craft",
                        land = false,
                        itemname = "Chinese Lantern",
                        prefab = "assets/prefabs/misc/chinesenewyear/chineselantern/chineselantern.deployed.prefab",
                    },
                    #endregion Chinese Lantern
                    #region Sky Lantern
                    ["Sky Lantern Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("skylantern", 1, 1819863051),
                        command = "skylantern.craft",
                        land = false,
                        itemname = "Sky Lantern",
                        prefab = "assets/prefabs/misc/chinesenewyear/sky_lantern/sky_lantern.prefab",
                    },
                    #endregion Sky Lantern
                    #region Sky Lantern - Green
                    ["Sky Lantern - Green Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem(".skylantern.green", 1, 1770889433),
                        command = "skylanterngreen.craft",
                        land = false,
                        itemname = "Sky Lantern - Green",
                        prefab = "assets/prefabs/misc/chinesenewyear/sky_lantern/skylantern.skylantern.green.prefab",
                    },
                    #endregion Sky Lantern - Green
                    #region Sky Lantern - Orange
                    ["Sky Lantern - Orange Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem(".skylantern.orange", 1, 1824770114),
                        command = "skylanternorange.craft",
                        land = false,
                        itemname = "Sky Lantern - Orange",
                        prefab = "assets/prefabs/misc/chinesenewyear/sky_lantern/skylantern.skylantern.orange.prefab",
                    },
                    #endregion Sky Lantern - Orange
                    #region Sky Lantern - Purple
                    ["Sky Lantern - Purple Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem(".skylantern.purple", 1, 831955134),
                        command = "skylanternpurple.craft",
                        land = false,
                        itemname = "Sky Lantern - Purple",
                        prefab = "assets/prefabs/misc/chinesenewyear/sky_lantern/skylantern.skylantern.purple.prefab",
                    },
                    #endregion Sky Lantern - Purple
                    #region Sky Lantern - Red
                    ["Sky Lantern - Red Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("lowgradefuel", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem(".skylantern.red", 1, 1433390281),
                        command = "skylanternred.craft",
                        land = false,
                        itemname = "Sky Lantern - Red",
                        prefab = "assets/prefabs/misc/chinesenewyear/sky_lantern/skylantern.skylantern.red.prefab",
                    },
                    #endregion Sky Lantern - Red
                    #region Tiger Mask
                    ["Tiger Mask Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                                new CraftItem("skull.wolf", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("hat.tigermask", 1, 709206314),
                        command = "tigermask.craft",
                        land = false,
                        itemname = "Tiger Mask",
                        prefab = null,
                    },
                    #endregion Tiger Mask
					
                    #endregion Lunar New Year
                    #region Christmas (41)
					
                    #region Snowball
                    ["Snowball Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("snowball", 1, 363689972),
                        command = "snowball.craft",
                        land = false,
                        itemname = "Snowball",
                        prefab = "assets/prefabs/misc/xmas/snowball/snowball.entity.prefab",
                    },
                    #endregion Snowball
                    #region Snowball Gun
                    ["Snowball Gun Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("snowballgun", 1, 1103488722),
                        command = "snowballgun.craft",
                        land = false,
                        itemname = "Snowball Gun",
                        prefab = "assets/prefabs/misc/xmas/snowballgun/snowballgun.entity.prefab",
                    },
                    #endregion Snowball Gun
                    #region Small Stocking
                    ["Small Stocking Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("stocking.small", 1, 1668858301),
                        command = "smallstocking.craft",
                        land = false,
                        itemname = "Small Stocking",
                        prefab = "assets/prefabs/misc/xmas/stockings/stocking_small_deployed.prefab",
                    },
                    #endregion Small Stocking
                    #region Super Stocking
                    ["Super Stocking Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("stocking.large", 1, 465682601),
                        command = "superstocking.craft",
                        land = false,
                        itemname = "Super Stocking",
                        prefab = "assets/prefabs/misc/xmas/stockings/stocking_large_deployed.prefab",
                    },
                    #endregion Super Stocking
                    #region Xmas Sled
                    ["Sled Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 1500),
                                new CraftItem("metal.refined", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sled.xmas", 1, 135252633),
                        command = "sled.craft",
                        land = false,
                        itemname = "Xmas Sled",
                        prefab = "assets/prefabs/misc/xmas/sled/sled.deployed.prefab",
                    },
                    #endregion Xmas Sled
                    #region Small Neon Sign
                    ["Small Neon Sign Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 150),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.neon.125x125", 1, 1305578813),
                        command = "smallneon.craft",
                        land = false,
                        itemname = "Small Neon Sign",
                        prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.125×125.prefab",
                    },
                    #endregion Small Neon Sign
                    #region Medium Neon Sign
                    ["Medium Neon Sign Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 200),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.neon.125x215", 1, 1423304443),
                        command = "mediumneon1.craft",
                        land = false,
                        itemname = "Medium Neon Sign",
                        prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.125×215.prefab",
                    },
                    #endregion Medium Neon Sign
                    #region Large Neon Sign
                    ["Large Neon Sign Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 250),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.neon.xl", 1, 866332017),
                        command = "largeneon1.craft",
                        land = false,
                        itemname = "Large Neon Sign",
                        prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.xl.prefab",
                    },
                    #endregion Large Neon Sign
                    #region Medium Animated Neon Sign
                    ["Medium Animated Neon Sign Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 300),
                                new CraftItem("metal.refined", 2),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.neon.125x215.animated", 1, 42535890),
                        command = "mediumneon2.craft",
                        land = false,
                        itemname = "Medium Animated Neon Sign",
                        prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.125×215.animated.prefab",
                    },
                    #endregion Medium Animated Neon Sign
                    #region Large Animated Neon Sign
                    ["Large Animated Neon Sign Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 350),
                                new CraftItem("metal.refined", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("sign.neon.xl.animated", 1, 1643667218),
                        command = "largeneon2.craft",
                        land = false,
                        itemname = "Large Animated Neon Sign",
                        prefab = "assets/prefabs/misc/xmas/neon_sign/sign.neon.xl.animated.prefab",
                    },
                    #endregion Large Animated Neon Sign
                    #region Short Ice Wall
                    ["Short Ice Wall Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("stones", 300),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("wall.ice.wall", 1, 1327005675),
                        command = "icewall1.craft",
                        land = false,
                        itemname = "Short Ice Wall",
                        prefab = "assets/prefabs/misc/xmas/icewalls/icewall.prefab",
                    },
                    #endregion Short Ice Wall
                    #region High Ice Wall
                    ["High Ice Wall Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("stones", 1500),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("wall.external.high.ice", 1, 985781766),
                        command = "icewall2.craft",
                        land = false,
                        itemname = "High Ice Wall",
                        prefab = "assets/prefabs/misc/xmas/icewalls/wall.external.high.ice.prefab",
                    },
                    #endregion High Ice Wall
                    #region Snow Machine
                    ["Snow Machine Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 125),
                                new CraftItem("lowgradefuel", 30),
                                new CraftItem("metalpipe", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("snowmachine", 1, 1358643074),
                        command = "snowmachine.craft",
                        land = false,
                        itemname = "Snow Machine",
                        prefab = "assets/prefabs/misc/xmas/snow_machine/models/snowmachine.prefab",
                    },
                    #endregion Snow Machine
                    #region Christmas Door Wreath
                    ["Christmas Door Wreath Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmasdoorwreath", 1, 2009734114),
                        command = "xmaswreath.craft",
                        land = false,
                        itemname = "Christmas Door Wreath",
                        prefab = "assets/prefabs/misc/xmas/wreath/christmas_door_wreath_deployed.prefab",
                    },
                    #endregion Christmas Door Wreath
                    #region Christmas Lights
                    ["Christmas Lights Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 25),
                                new CraftItem("lowgradefuel", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.lightstring", 1, 1058261682),
                        command = "xmaslights1.craft",
                        land = false,
                        itemname = "Christmas Lights",
                        prefab = "assets/prefabs/misc/xmas/christmas_lights/xmas.lightstring.deployed.prefab",
                    },
                    #endregion Christmas Lights
                    #region Deluxe Christmas Lights
                    ["Deluxe Christmas Lights Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.lightstring.advanced", 1, 151387974),
                        command = "xmaslights2.craft",
                        land = false,
                        itemname = "Deluxe Christmas Lights",
                        prefab = "assets/prefabs/misc/xmas/poweredlights/xmas.advanced.lights.deployed.prefab",
                    },
                    #endregion Deluxe Christmas Lights
                    #region Tree Lights
                    ["Tree Lights Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 150),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.lights", 1, 1723747470),
                        command = "treelights.craft",
                        land = false,
                        itemname = "Tree Lights",
                        prefab = null,
                    },
                    #endregion Tree Lights
                    #region Decorative Baubels
                    ["Decorative Baubels Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 100),
                                new CraftItem("scrap", 4),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.baubels", 1, 1667224349),
                        command = "baubels.craft",
                        land = false,
                        itemname = "Decorative Baubels",
                        prefab = null,
                    },
                    #endregion Decorative Baubels
                    #region Decorative Gingerbread Men
                    ["Decorative Gingerbread Men Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.gingerbreadmen", 1, 1686524871),
                        command = "gingerbreadman.craft",
                        land = false,
                        itemname = "Decorative Gingerbread Men",
                        prefab = null,
                    },
                    #endregion Decorative Gingerbread Men
                    #region Decorative Pinecones
                    ["Decorative Pinecones Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.pinecone", 1, 129230242),
                        command = "pinecones.craft",
                        land = false,
                        itemname = "Decorative Pinecones",
                        prefab = null,
                    },
                    #endregion Decorative Pinecones
                    #region Decorative Plastic Candy Canes
                    ["Decorative Plastic Candy Canes Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.candycanes", 1, 209869746),
                        command = "plasticcanes.craft",
                        land = false,
                        itemname = "Decorative Plastic Candy Canes",
                        prefab = null,
                    },
                    #endregion Decorative Plastic Candy Canes
                    #region Decorative Tinsel
                    ["Decorative Tinsel Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("scrap", 6),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.tinsel", 1, 2106561762),
                        command = "tinsel.craft",
                        land = false,
                        itemname = "Decorative Tinsel",
                        prefab = null,
                    },
                    #endregion Decorative Tinsel
                    #region Star Tree Topper
                    ["Star Tree Topper Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 150),
                                new CraftItem("scrap", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.decoration.star", 1, 1331212963),
                        command = "xmasstar.craft",
                        land = false,
                        itemname = "Star Tree Topper",
                        prefab = null,
                    },
                    #endregion Star Tree Topper
                    #region Festive Doorway Garland
                    ["Festive Doorway Garland Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.door.garland", 1, 674734128),
                        command = "garland1.craft",
                        land = false,
                        itemname = "Festive Doorway Garland",
                        prefab = "assets/prefabs/misc/xmas/doorgarland/doorgarland.deployed.prefab",
                    },
                    #endregion Festive Doorway Garland
                    #region Festive Window Garland
                    ["Festive Window Garland Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.window.garland", 1, 1379835144),
                        command = "garland2.craft",
                        land = false,
                        itemname = "Festive Window Garland",
                        prefab = "assets/prefabs/misc/xmas/windowgarland/windowgarland.deployed.prefab",
                    },
                    #endregion Festive Window Garland
                    #region Santa Beard
                    ["Santa Beard Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("santabeard", 1, 2126889441),
                        command = "santabeard.craft",
                        land = false,
                        itemname = "Santa Beard",
                        prefab = null,
                    },
                    #endregion Santa Beard
                    #region Santa Hat
                    ["Santa Hat Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("santahat", 1, 575483084),
                        command = "santahat.craft",
                        land = false,
                        itemname = "Santa Hat",
                        prefab = null,
                    },
                    #endregion Santa Hat
                    #region Reindeer Antlers
                    ["Reindeer Antlers Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("attire.reindeer.headband", 1, 324675402),
                        command = "antlers.craft",
                        land = false,
                        itemname = "Reindeer Antlers",
                        prefab = null,
                    },
                    #endregion Reindeer Antlers
                    #region Candy Cane
                    ["Candy Cane Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 5),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("candycane", 1, 1121925526),
                        command = "candycane.craft",
                        land = false,
                        itemname = "Candy Cane",
                        prefab = null,
                    },
                    #endregion Candy Cane
                    #region Candy Cane Club
                    ["Candy Cane Club Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("candycaneclub", 1, 1789825282),
                        command = "candyclub.craft",
                        land = false,
                        itemname = "Candy Cane Club",
                        prefab = null,
                    },
                    #endregion Candy Cane Club
                    #region Giant Candy Decor
                    ["Giant Candy Decor Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 30),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("giantcandycanedecor", 1, 695124222),
                        command = "giantcandycane.craft",
                        land = false,
                        itemname = "Giant Candy Decor",
                        prefab = "assets/prefabs/misc/xmas/giant_candy_cane/giantcandycane.deployed.prefab",
                    },
                    #endregion Giant Candy Decor
                    #region Giant Lollipop Decor
                    ["Giant Lollipop Decor Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("giantlollipops", 1, 282103175),
                        command = "giantlollipop.craft",
                        land = false,
                        itemname = "Giant Lollipop Decor",
                        prefab = "assets/prefabs/misc/xmas/lollipop_bundle/giantlollipops.deployed.prefab",
                    },
                    #endregion Giant Lollipop Decor
                    #region Snowman
                    ["Snowman Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("charcoal", 50),
                                new CraftItem("cloth", 20),
                                new CraftItem("metal.fragments", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("snowman", 1, 1629293099),
                        command = "snowman.craft",
                        land = false,
                        itemname = "Snowman",
                        prefab = "assets/prefabs/misc/xmas/snowman/snowman.deployed.prefab",
                    },
                    #endregion Snowman
                    #region Moustache
                    ["Moustache Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("movembermoustache", 1, 2047081330),
                        command = "moustache.craft",
                        land = false,
                        itemname = "Moustache",
                        prefab = null,
                    },
                    #endregion Moustache
                    #region Fake Moustache
                    ["Fake Moustache Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 10),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("movembermoustachecard", 1, 3380160),
                        command = "fakemoustache.craft",
                        land = false,
                        itemname = "Fake Moustache",
                        prefab = null,
                    },
                    #endregion Fake Moustache
                    #region Pookie Bear
                    ["Pookie Bear Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 500),
                                new CraftItem("cloth", 250),
                                new CraftItem("sewingkit", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("pookie.bear", 1, 1651220691),
                        command = "pookiebear.craft",
                        land = false,
                        itemname = "Pookie Bear",
                        prefab = "assets/prefabs/misc/xmas/pookie/pookie_deployed.prefab",
                    },
                    #endregion Pookie Bear
                    #region Wrapping Paper
                    ["Wrapping Paper Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("rope", 1),
                                new CraftItem("tarp", 1),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("wrappingpaper", 1, 1094293920),
                        command = "wrappingpaper.craft",
                        land = false,
                        itemname = "Wrapping Paper",
                        prefab = null,
                    },
                    #endregion Wrapping Paper
                    #region Christmas Tree
                    ["Christmas Tree Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("scrap", 50),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.tree", 1, 794443127),
                        command = "xmastree.craft",
                        land = false,
                        itemname = "Christmas Tree",
                        prefab = "assets/prefabs/misc/xmas/xmastree/xmas_tree.deployed.prefab",
                    },
                    #endregion Christmas Tree
                    #region Snowman Helmet
                    ["Snowman Helmet Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("attire.snowman.helmet", 1, 842267147),
                        command = "snowmanhat.craft",
                        land = false,
                        itemname = "Snowman Helmet",
                        prefab = "assets/prefabs/misc/xmas/wearable/snowman_helmet/snowman_helmet.prefab",
                    },
                    #endregion Snowman Helmet
                    #region Pattern Boomer
                    ["Pattern Boomer Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("metal.fragments", 50),
                                new CraftItem("gunpowder", 30),
                                new CraftItem("lowgradefuel", 15),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("firework.boomer.pattern", 1, 379734527),
                        command = "patternboomer.craft",
                        land = false,
                        itemname = "Pattern Boomer",
                        prefab = "assets/prefabs/deployable/fireworks/boomer.pattern.item.prefab",
                    },
                    #endregion Pattern Boomer
                    #region Advent calendar
                    ["Advent calendar Config Settings"] = new ExtendedInfo
                    {
                        craft = new CraftSettings(true)
                        {
                            items = new List<CraftItem>
                            {
                                new CraftItem("wood", 100),
                                new CraftItem("cloth", 20),
                            }
                        },
                        destroy = new DestroySettings(true, false)
                        {
                            effects = new List<string>
                            {
                                "assets/bundled/prefabs/fx/item_break.prefab",
                                "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                            }
                        },
                        pickup = new PickupSettings(true, true, true),
                        item = new CraftItem("xmas.advent", 1, 2027793839),
                        command = "calendar.craft",
                        land = false,
                        itemname = "Advent calendar",
                        prefab = "assets/prefabs/misc/xmas/advent_calendar/advendcalendar.deployed.prefab",
                    }
                    #endregion Advent calendar
                    #endregion Christmas
					
                    #endregion Seasonal
					
                }
            };
        }

        #endregion Item Tables
    }
}

// --- End of file: ExtendedCrafting.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/enchant-tools ---
// --- Original File Path: E/EnchantTools/EnchantTools.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Enchant Tools", "Default", "1.1.2")]
    [Description("Adds enchanted tools for mining melted resources")]
    public class EnchantTools : RustPlugin
    {
        private List<int> EnchantedTools;

        #region Oxide hooks
        private void Init()
        {
            LoadVariables();
            EnchantedTools = Interface.Oxide?.DataFileSystem?.ReadObject<List<int>>("EnchantTools") ?? new List<int>();

            cmd.AddChatCommand(configData.Command, this, "CmdEnchant");
            cmd.AddConsoleCommand(configData.Command, this, "CcmdEnchant");

            permission.RegisterPermission("enchanttools.admin", this);
            permission.RegisterPermission("enchanttools.use", this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PermissionAdmin"] = "You don't have permission to use this command.",
                ["MultiplePlayer"] = "Multiple players found: {0}",
                ["PlayerIsNotFound"] = "The player with the name {0} was not found.",
                ["UsageSyntax"] = "Usage command syntax: \n<color=#FF99CC>{0} <tool_name> <playerName or Id></color>\nAvailable tools names:\n{1}",
                ["ToolGiven"] = "{0} received enchanted tool: {1}.",
                ["CantRepair"] = "You can't repair an enchanted tools.",
                ["ConsoleNotAvailable"] = "This command available only from server console or rcon.",
                ["ConsoleNoPlayerFound"] = "No player with the specified SteamID was found.",
                ["ConsoleNoPlayerAlive"] = "The player with the specified ID was not found among active or sleeping players.",
                ["ConsoleToolGiven"] = "{0} received enchanted tool {1}.",
                ["ConsoleUsageSyntax"] = "Usage command syntax: \n<color=#FF99CC>{0} <tool_name> <steamId></color>\nAvailable tools names:\n{1}"
            }, this);
        }

        private void OnNewSave(string filename)
        {
            EnchantedTools = new List<int>();
            SaveEnchantedTools();
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null)
            {
                return;
            }

            if (!configData.CanUseByAllPlayers && !permission.UserHasPermission(player.UserIDString, "enchanttool.use"))
            {
                return;
            }

            if (EnchantedTools.Contains(player.GetActiveItem().GetHashCode()))
            {
                switch (item.info.shortname)
                {
                    case "sulfur.ore":
                        //PrintWarning(item.info.shortname);
                        ReplaceContents(-1581843485, ref item);
                        break;
                    case "metal.ore":
                        //PrintWarning(item.info.shortname);
                        ReplaceContents(69511070, ref item);
                        break;
                    case "hq.metal.ore":
                        //PrintWarning(item.info.shortname);
                        ReplaceContents(-1982036270, ref item);
                        break;
                    case "wood":
                        ReplaceContents(-1938052175, ref item);
                        break;
                }
            }
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null)
            {
                return;
            }

            if (!configData.CanUseByAllPlayers && !permission.UserHasPermission(player.UserIDString, "enchanttool.use"))
            {
                return;
            }

            if (EnchantedTools.Contains(player.GetActiveItem().GetHashCode()))
            {
                switch (item.info.shortname)
                {
                    case "sulfur.ore":
                        ReplaceContents(-1581843485, ref item);
                        break;
                    case "metal.ore":
                        ReplaceContents(69511070, ref item);
                        break;
                    case "wolfmeat.raw":
                        ReplaceContents(-813023040, ref item);
                        break;
                    case "meat.boar":
                        ReplaceContents(-242084766, ref item);
                        break;
                    case "hq.metal.ore":
                        //PrintWarning(item.info.shortname);
                        ReplaceContents(-1982036270, ref item);
                        break;
                    case "chicken.raw":
                        ReplaceContents(-1848736516, ref item);
                        break;
                    case "bearmeat":
                        ReplaceContents(-1873897110, ref item);
                        break;
                    case "deermeat.raw":
                        ReplaceContents(-1509851560, ref item);
                        break;
                    case "wood":
                        ReplaceContents(-1938052175, ref item);
                        break;
                }
            }
        }

        private object OnItemRepair(BasePlayer player, Item item)
        {
            if (EnchantedTools.Contains(item.GetHashCode()))
            {
                SendReply(player, lang.GetMessage("CantRepair", this, player.UserIDString));
                return false;
            }

            return null;
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (EnchantedTools.Contains(entity.GetHashCode()))
            {
                EnchantedTools.Remove(entity.GetHashCode());
            }
        }
        #endregion

        #region Chat command
        private void CmdEnchant(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, "enchanttools.admin"))
            {
                SendReply(player, lang.GetMessage("PermissionAdmin", this, player.UserIDString));
                return;
            }

            List<string> shortnames = new List<string>();
            foreach (Tool tool in configData.Tools)
            {
                shortnames.Add(tool.shortname);
            }

            if (args.Length == 2)
            {
                if (shortnames.Contains(args.ElementAtOrDefault(0)))
                {
                    List<BasePlayer> foundPlayers = new List<BasePlayer>();

                    string searchNameOrId = args.ElementAtOrDefault(1);

                    foreach (BasePlayer p in BasePlayer.activePlayerList)
                    {
                        if (p.displayName.Contains(searchNameOrId))
                        {
                            foundPlayers.Add(p);
                        }
                        else if (p.UserIDString == searchNameOrId)
                        {
                            foundPlayers.Add(p);
                        }
                    }
                    if (foundPlayers.Count > 1)
                    {
                        List<string> multiple_names = new List<string>();
                        foreach (BasePlayer p in foundPlayers)
                        {
                            multiple_names.Add(p.displayName);
                        }

                        SendReply(player, lang.GetMessage("MultiplePlayer", this, player.UserIDString), string.Join(", ", multiple_names.ToArray()));
                        return;
                    }
                    else if (foundPlayers.Count == 0)
                    {
                        SendReply(player, lang.GetMessage("PlayerIsNotFound", this, player.UserIDString), args.ElementAtOrDefault(1));
                        return;
                    }
                    else
                    {
                        Tool tool = configData.Tools.Find(t => t.shortname == args.ElementAtOrDefault(0));
                        BasePlayer receiver = foundPlayers.First();
                        if (receiver.IsValid())
                        {
                            GiveEnchantTool(receiver, tool);
                            SendReply(player, lang.GetMessage("ToolGiven", this, player.UserIDString), receiver.displayName, args.ElementAtOrDefault(0));
                            return;
                        }
                    }
                }
            }
            SendReply(player, lang.GetMessage("UsageSyntax", this, player.UserIDString), configData.Command, string.Join(", ", shortnames.ToArray()));
        }
        #endregion

        #region Console command
        private void CcmdEnchant(ConsoleSystem.Arg arg)
        {
            if (!arg.IsServerside && !arg.IsRcon)
            {
                BasePlayer player = arg.Player();
                if (player != null)
                {
                    player.ConsoleMessage(lang.GetMessage("ConsoleNotAvailable", this, player.UserIDString));
                }
            }

            List<string> shortnames = new List<string>();
            foreach (Tool tool in configData.Tools)
            {
                shortnames.Add(tool.shortname);
            }

            string[] args = arg.Args;
            if (args.Length == 2)
            {
                if (shortnames.Contains(args.ElementAtOrDefault(0)))
                {
                    List<BasePlayer> foundPlayers = new List<BasePlayer>();
                    string steamId = args.ElementAtOrDefault(1);

                    IPlayer iplayer = covalence.Players.FindPlayerById(steamId);
                    if (iplayer == null)
                    {
                        SendReply(arg, lang.GetMessage("ConsoleNoPlayerFound", this));
                    }

                    BasePlayer receiver = receiver = BasePlayer.FindAwakeOrSleeping(steamId);
                    if (receiver == null)
                    {
                        SendReply(arg, lang.GetMessage("ConsoleNoPlayerAlive", this));
                    }
                    else
                    {
                        Tool tool = configData.Tools.Find(t => t.shortname == args.ElementAtOrDefault(0));
                        GiveEnchantTool(receiver, tool);
                        SendReply(arg, lang.GetMessage("ConsoleToolGiven", this), receiver.displayName, args.ElementAtOrDefault(0));
                    }
                    return;
                }
            }
            SendReply(arg, lang.GetMessage("ConsoleUsageSyntax", this), configData.Command, string.Join(", ", shortnames.ToArray()));
        }
        #endregion

        #region Helpers
        private void ReplaceContents(int ItemId, ref Item item)
        {
            Item _item = ItemManager.CreateByItemID(ItemId, item.amount);
            if (item != null)
            {
                item.info = _item.info;
                item.contents = _item.contents;
            }
        }

        private void GiveEnchantTool(BasePlayer player, Tool tool)
        {
            Item item = ItemManager.CreateByName(tool.shortname, 1, tool.skinId);
            if (item != null)
            {
                player.GiveItem(item);
                EnchantedTools.Add(item.GetHashCode());
                SaveEnchantedTools();
            }
        }

        private void SaveEnchantedTools()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, EnchantedTools);
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            public string Command;
            public bool CanUseByAllPlayers;
            public List<Tool> Tools;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                Command = "et",
                CanUseByAllPlayers = true,

                Tools = new List<Tool>()
                {
                    new Tool()
                    {
                        shortname = "hatchet",
                        skinId = 0,
                        canRepair = true
                    },
                    new Tool()
                    {
                        shortname = "axe.salvaged",
                        skinId = 0,
                        canRepair = true
                    },
                    new Tool()
                    {
                        shortname = "pickaxe",
                        skinId = 0,
                        canRepair = true
                    },
                    new Tool()
                    {
                        shortname = "icepick.salvaged",
                        skinId = 0,
                        canRepair = true
                    },
                }
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }

        private void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Nested Classes
        private class Tool
        {
            public string shortname;
            public uint skinId;
            public bool canRepair;
        }
        #endregion
    }
}

// --- End of file: EnchantTools.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/exclusive-groups ---
// --- Original File Path: E/ExclusiveGroups/ExclusiveGroups.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Exclusive Groups", "WhiteDragon", "0.2.8")]
    [Description("Maintains exclusive group membership within categories.")]
    internal class ExclusiveGroups : CovalencePlugin
    {
        private static ExclusiveGroups _instance;

        #region _category_

        private class Category
        {
            public class Settings : Dictionary<string, Settings.Entry>
            {
                public class Entry
                {
                    public Groups Includes;
                    public Groups Excludes;

                    public class Groups : List<string>
                    {
                        public bool Validate(string category, string type)
                        {
                            bool valid = true;

                            foreach(var group in this)
                            {
                                if(!_instance.permission.GroupExists(group) || group == "default")
                                {
                                    Log.Console(Key.CategoryGroupInvalid, new Dictionary<string, string>
                                    {
                                        { "category", category },
                                        { "group", group },
                                        { "type", type }
                                    });

                                    valid = false;
                                }
                            }

                            return valid;
                        }
                    }

                    public bool Validate(string category)
                    {
                        Configuration.Validate(ref Includes, () => new Groups());
                        Configuration.Validate(ref Excludes, () => new Groups());

                        var valid = true;

                        if(!Includes.Validate(category, nameof(Includes)))
                        {
                            valid = false;
                        }

                        if(!Excludes.Validate(category, nameof(Excludes)))
                        {
                            valid = false;
                        }

                        foreach(var group in Includes)
                        {
                            if(Excludes.Contains(group))
                            {
                                Log.Console(Key.CategoryGroupDuplicate, new Dictionary<string, string>
                                {
                                    { "category", category },
                                    { "group", group }
                                });

                                valid = false;
                            }
                        }

                        return valid;
                    }
                }

                public bool Validate()
                {
                    var included = new HashSet<string>();
                    var validate = new Queue<string>();

                    var valid = true;

                    foreach(var category in this)
                    {
                        if(category.Value == null)
                        {
                            validate.Enqueue(category.Key);

                            continue;
                        }

                        foreach(var group in category.Value.Includes)
                        {
                            if(!included.Add(group))
                            {
                                Log.Console(Key.CategoryGroupMultiple, new Dictionary<string, string>
                                {
                                    { "category", category.Key },
                                    { "group", group },
                                    { "type", nameof(Entry.Includes) }
                                });

                                valid = false;
                            }
                        }
                    }

                    while(validate.Count > 0)
                    {
                        this[validate.Dequeue()] = new Entry();

                        Configuration.SetDirty();
                    }

                    foreach(var category in this)
                    {
                        if(!category.Value.Validate(category.Key))
                        {
                            valid = false;
                        }
                    }

                    return valid;
                }
            }

            private static void Remove(IPlayer user, string category, string type, string group)
            {
                user.RemoveFromGroup(group);

                Log.Console(Key.CategoryRemove, new Dictionary<string, string>
                {
                    { "category", category },
                    { "group", group },
                    { "type", type },
                    { "userid", user.Id },
                    { "username", user.Name },
                });
            }

            public static void Update()
            {
                foreach(var user in _instance.covalence.Players.All)
                {
                    foreach(var category in config.Categories)
                    {
                        var exclude = false;

                        foreach(var group in category.Value.Includes)
                        {
                            if(user.BelongsToGroup(group))
                            {
                                if(exclude)
                                {
                                    Remove(user, category.Key, nameof(Settings.Entry.Includes), group);
                                }
                                else
                                {
                                    exclude = true;
                                }
                            }
                        }

                        if(exclude)
                        {
                            foreach(var group in category.Value.Excludes)
                            {
                                if(user.BelongsToGroup(group))
                                {
                                    Remove(user, category.Key, nameof(Settings.Entry.Excludes), group);
                                }
                            }
                        }
                    }
                }
            }
            public static void Update(string userid, string added)
            {
                var user = _instance.covalence.Players.FindPlayerById(userid);

                foreach(var category in config.Categories)
                {
                    bool exclude = category.Value.Includes.Contains(added);

                    foreach(var group in category.Value.Includes)
                    {
                        if(user.BelongsToGroup(group) && (group != added))
                        {
                            if(exclude)
                            {
                                Remove(user, category.Key, nameof(Settings.Entry.Includes), group);
                            }
                            else
                            {
                                exclude = true;
                            }
                        }
                    }

                    if(exclude)
                    {
                        foreach(var group in category.Value.Excludes)
                        {
                            if(user.BelongsToGroup(group))
                            {
                                Remove(user, category.Key, nameof(Settings.Entry.Excludes), group);
                            }
                        }
                    }
                }
            }

            public static bool Validate() => config.Categories.Validate();
        }

        #endregion _category_

        #region _configuration_

        private static Configuration config;

        private class Configuration
        {
            public Category.Settings Categories;
            public Version.Settings  Version;

            private static bool corrupt  = false;
            private static bool dirty    = false;
            private static bool upgraded = false;

            public static void Load()
            {
                dirty = false;

                try
                {
                    config = _instance.Config.ReadObject<Configuration>();

                    config.Version.Compare(0, 0, 0);
                }
                catch(NullReferenceException)
                {
                    Log.Console(Key.ConfigurationDefault);

                    dirty = true; config = new Configuration();
                }
                catch(JsonException e)
                {
                    Log.Console(Key.ConfigurationError, new Dictionary<string, string>
                    {
                        { "message", e.ToString() }
                    });

                    corrupt = true; config = new Configuration();
                }

                Validate();
            }

            public static void Save()
            {
                if(dirty && !corrupt)
                {
                    dirty = false;

                    _instance.Config.WriteObject(config);
                }
            }

            public static void SetDirty() => dirty = true;

            public static void SetUpgrade(bool upgrade = true) => upgraded = upgrade;

            public static void Unload()
            {
                Save();

                config = null;
            }

            public static bool Upgraded() => upgraded;

            public static void Validate<T>(ref T value, Func<T> initializer, Action validator = null)
            {
                if(value == null)
                {
                    dirty = true; value = initializer();
                }
                else
                {
                    validator?.Invoke();
                }
            }
            private static void Validate()
            {
                Validate(ref config.Categories, () => new Category.Settings());
                Validate(ref config.Version,    () => new Version.Settings());

                config.Version.Validate();
            }
        }

        #endregion _conifguration_

        #region _hooks_

        private void Init()
        {
            Unsubscribe(nameof(OnUserGroupAdded));

            _instance = this;

            Text.Preload();

            Configuration.Load();

            Text.Load();

            if(!Category.Validate())
            {
                throw new Exception("Configuration error.");
            }

            Configuration.Save();
        }

        protected override void LoadDefaultConfig() { }

        protected override void LoadDefaultMessages() { }

        private void Loaded()
        {
            Category.Update();

            Subscribe(nameof(OnUserGroupAdded));
        }

        private void OnUserGroupAdded(string userid, string group)
        {
            if(group != "default")
            {
                Category.Update(userid, group);
            }
        }

        private void Unload()
        {
            Text.Unload();

            Configuration.Unload();

            _instance = null;
        }

        #endregion _hooks_

        #region _log_

        private new class Log
        {
            public static void Console(Key key, Dictionary<string, string> parameters = null)
            {
                _instance.Puts(Text.Get(key, parameters));
            }
        }

        #endregion _log_

        #region _text_

        private enum Key
        {
            CategoryGroupDuplicate,
            CategoryGroupInvalid,
            CategoryGroupMultiple,
            CategoryRemove,
            ConfigurationDefault,
            ConfigurationError,
            TextKeyInvalid,
        }

        private class Text
        {
            private static readonly Dictionary<Key, string> cache = new Dictionary<Key, string>();

            private static Dictionary<string, Dictionary<string, string>> messages;

            public static string Get(Key key, Dictionary<string, string> parameters = null)
            {
                string message;

                if(cache.TryGetValue(key, out message))
                {
                    return Replace(message, parameters);
                }
                else
                {
                    var language = _instance.lang.GetServerLanguage();

                    if(string.IsNullOrEmpty(language) || !messages.ContainsKey(language))
                    {
                        language = "en";
                    }

                    Dictionary<string, string> cache;

                    if(messages.TryGetValue(language, out cache) && cache.TryGetValue(Enum.GetName(typeof(Key), key), out message))
                    {
                        return Replace(message, parameters);
                    }
                }

                return Enum.GetName(typeof(Key), key);
            }

            public static void Load()
            {
                var languages = _instance.lang.GetLanguages(_instance);

                if((languages.Length == 0) || Configuration.Upgraded())
                {
                    RegisterMessages();
                }

                var language = _instance.lang.GetServerLanguage();

                if(string.IsNullOrEmpty(language) || !languages.Contains(language))
                {
                    language = "en";
                }

                var keys = new HashSet<string>(Enum.GetNames(typeof(Key)));

                foreach(var entry in _instance.lang.GetMessages(language, _instance))
                {
                    if(string.IsNullOrEmpty(entry.Key))
                    {
                        continue;
                    }

                    if(keys.Contains(entry.Key))
                    {
                        cache.Add((Key)Enum.Parse(typeof(Key), entry.Key), entry.Value);
                    }
                    else
                    {
                        Log.Console(Key.TextKeyInvalid, new Dictionary<string, string>
                        {
                            { "key", entry.Key },
                            { "language", language }
                        });
                    }
                }
            }

            public static void Preload()
            {
                messages = new Dictionary<string, Dictionary<string, string>>
                {
                    {
                        "en", new Dictionary<string, string>
                        {
                            { nameof(Key.CategoryGroupDuplicate), "Category[\"{category}\"]: Duplicate group \"{group}\"." },
                            { nameof(Key.CategoryGroupInvalid),   "Category[\"{category}\"].{type}: Invalid group \"{group}\"." },
                            { nameof(Key.CategoryGroupMultiple),  "Category[\"{category}\"].{type}: Multiple categories include group \"{group}\"." },
                            { nameof(Key.CategoryRemove),         "Category[\"{category}\"].{type}: Removed {username}[{userid}] from group \"{group}\"." },
                            { nameof(Key.ConfigurationDefault),   "Configuration: Created new configuration with default settings." },
                            { nameof(Key.ConfigurationError),     "Configuration: Using default settings. Delete the configuration file, or fix the following error, and reload; {message}" },
                            { nameof(Key.TextKeyInvalid),         "Language[\"{language}\"]: Invalid key \"{key}\"." },
                        }
                    }
                };
            }

            private static void RegisterMessages()
            {
                foreach(var langauge in messages)
                {
                    _instance.lang.RegisterMessages(langauge.Value, _instance, langauge.Key);
                }
            }

            private static string Replace(string message, Dictionary<string, string> parameters = null)
            {
                if((message != null) && (parameters != null))
                {
                    foreach(var entry in parameters)
                    {
                        message = message.Replace('{' + entry.Key + '}', entry.Value);
                    }
                }

                return message;
            }

            public static void Unload()
            {
                cache.Clear();

                foreach(var language in messages)
                {
                    language.Value.Clear();
                }

                messages.Clear();
                messages = null;
            }
        }

        #endregion _text_

        #region _version_

        private new class Version
        {
            public class Settings
            {
                public int Major;
                public int Minor;
                public int Patch;

                public Settings()
                {
                    Major = Minor = Patch = 0;
                }

                public int Compare(int major, int minor, int patch)
                {
                    return
                        (Major != major) ? (Major - major) :
                        (Minor != minor) ? (Minor - minor) :
                        (Patch != patch) ? (Patch - patch) : 0;
                }

                public void Validate()
                {
                    var current = (_instance as CovalencePlugin).Version;

                    if(Compare(current.Major, current.Minor, current.Patch) < 0)
                    {
                        Configuration.SetDirty();

                        Major = current.Major;
                        Minor = current.Minor;
                        Patch = current.Patch;

                        Configuration.SetUpgrade();
                    }
                    else
                    {
                        Configuration.SetUpgrade(false);
                    }
                }
            }
        }

        #endregion _version_
    }
}

// --- End of file: ExclusiveGroups.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ember ---
// --- Original File Path: E/Ember/Ember.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;

namespace Oxide.Plugins {
	[Info ("Ember", "Mkekala", "1.4.0")]
	[Description ("Integrates Ember store & ban management with Rust")]
	public class Ember : RustPlugin {
		#region Configuration
		private class PluginConfig {
			public string Host = "http://127.0.0.1";
			public string Token;
		}

		private PluginConfig config;
		private bool banLog;
		private Dictionary<string, bool> roleSync;

		private Dictionary<string, string> headers;

		protected override void LoadDefaultConfig () {
			Config.WriteObject (new PluginConfig (), true);
		}
		#endregion

		#region Variables
		private bool connected;
		private Dictionary<string, JToken> userData;
		private Dictionary<string, string> usersToPost;
		private List<string> usersProcessed;
		#endregion

		#region Methods
		void QueueUserToPost (string steamid, string name = "") {
			if (!usersToPost.ContainsKey (steamid))
				usersToPost.Add (steamid, name);
		}

		void PostUsers (Dictionary<string, string> users) {
			if (users.Count == 0)
				return;

			Puts (string.Format (lang.GetMessage ("ConsolePostingUsers", this), users.Count));

			List<string> names = new List<string> ();
			foreach (string name in users.Values)
				names.Add (name.Replace (",", ""));

			webrequest.Enqueue (config.Host + "/api/server/users", "steamids=" + string.Join (",", users.Keys) + "&names=" + string.Join (",", names), (code, response) => {
				if ((code != 200 && code != 204) || response == null) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailed", this), code, response));
					return;
				}

				JObject json = JObject.Parse (response);

				foreach (var userobj in (JObject) json["users"]) {
					userData[userobj.Key] = userobj.Value;
					BasePlayer player = GetPlayerBySteamID (userobj.Key);
					if (player != null)
						ProcessUser (player);
				}

			}, this, RequestMethod.POST, headers);
		}

		void ProcessUser (BasePlayer player) {
			string steamid = player.UserIDString;
			if (!userData.ContainsKey (steamid)) return;
			JToken userjson = userData[steamid];
			string name = player.displayName;

			Puts (string.Format (lang.GetMessage ("ConsoleProcessingUserData", this), name, steamid));
			bool banned = (bool) userjson["banned"];

			if (banned) {
				player.Kick (lang.GetMessage ("Banned", this, player.UserIDString));
				userData.Remove (steamid);
				return;
			}

			foreach (JObject purchase in userjson["store_package_purchases"]["expiring"]) {
				SendReply (player, string.Format (lang.GetMessage ("PackageExpired", this, player.UserIDString), purchase["store_package"]["name"]));
				if (purchase["store_package"]["role"].HasValues) {
					string groupToRevoke = (string) purchase["store_package"]["role"]["ingame_equivalent"];
					Puts (string.Format (lang.GetMessage ("ConsoleRevokingGroup", this), groupToRevoke, name, steamid));
					permission.RemoveUserGroup (steamid, groupToRevoke);
					SendReply (player, string.Format (lang.GetMessage ("GroupRevoked", this, player.UserIDString), groupToRevoke));
				}
				foreach (string command in purchase["store_package"]["expiry_commands"])
					rust.RunServerCommand (command);
			}

			foreach (JObject purchase in userjson["store_package_purchases"]["unredeemed"]) {
				SendReply (player, string.Format (lang.GetMessage ("RedeemingPackage", this, player.UserIDString), purchase["store_package"]["name"]));
				if (purchase["store_package"]["role"].HasValues) {
					string group = (string) purchase["store_package"]["role"]["ingame_equivalent"];
					if (!permission.GroupExists (group)) {
						Puts (string.Format (lang.GetMessage ("ConsoleCreatingGroup", this), group));
						permission.CreateGroup (group, group, 0);
					}
					Puts (string.Format (lang.GetMessage ("ConsoleGrantingGroup", this), group, name, steamid));
					permission.AddUserGroup (steamid, group);
					SendReply (player, string.Format (lang.GetMessage ("GroupGranted", this, player.UserIDString), group));
				}
				foreach (string command in purchase["store_package"]["commands"])
					rust.RunServerCommand (command);
			}

			if (roleSync["Receive"] == true || roleSync["Send"] == true) {
				Puts (string.Format (lang.GetMessage ("ConsoleSyncingRoles", this), name, steamid));

				if (roleSync["Receive"] == true) {
					foreach (string role in userjson["roles"]) {
						if (!permission.UserHasGroup (steamid, role)) {
							if (!permission.GroupExists (role)) {
								if (roleSync["Create"]) {
									Puts (string.Format (lang.GetMessage ("ConsoleCreatingGroup", this), role));
									permission.CreateGroup (role, role, 0);
								} else {
									continue;
								}
							}
							Puts (string.Format (lang.GetMessage ("ConsoleGrantingGroup", this), role, name, steamid));
							permission.AddUserGroup (steamid, role);
							SendReply (player, string.Format (lang.GetMessage ("GroupGranted", this, player.UserIDString), role));
						}
					}
					foreach (string role in userjson["revoked_roles"]) {
						if (permission.UserHasGroup (steamid, role)) {
							Puts (string.Format (lang.GetMessage ("ConsoleRevokingGroup", this), role, name, steamid));
							permission.RemoveUserGroup (steamid, role);
							SendReply (player, string.Format (lang.GetMessage ("GroupRevoked", this, player.UserIDString), role));
						}
					}
				}

				if (roleSync["Send"] == true) {
					string[] roles = userjson["roles"].ToObject<string[]> ();
					foreach (string group in permission.GetGroups ()) {
						if (permission.UserHasGroup (steamid, group)) {
							if (Array.IndexOf (roles, group) == -1) {
								PostRole (steamid, group);
							}
						}
					}
				}
			}

			usersProcessed.Add (steamid);
			userData.Remove (steamid);
		}

		void PostUsersProcessed (List<String> users) {
			if (users.Count == 0)
				return;

			webrequest.Enqueue (config.Host + "/api/server/usersprocessed", "steamids=" + string.Join (",", users), (code, response) => {
				if (code != 200 && code != 204)
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailed", this), code, response));
			}, this, RequestMethod.POST, headers);
		}

		private void PollUsers () {
			string steamids = "";

			foreach (BasePlayer ply in BasePlayer.activePlayerList) {
				if (!usersToPost.ContainsKey (ply.UserIDString) &&
					!usersProcessed.Contains (ply.UserIDString) &&
					!userData.ContainsKey (ply.UserIDString)
				)
					steamids += ply.UserIDString + ",";
			}

			if (!string.IsNullOrEmpty (steamids)) {
				webrequest.Enqueue (config.Host + "/api/server/users/poll?steamids=" + steamids, null, (code, response) => {
					if ((code != 200 && code != 204) || response == null) {
						Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailed", this), code, response));
						return;
					}

					JObject json = JObject.Parse (response);

					foreach (string steamid in json["users"])
						QueueUserToPost (steamid);
				}, this, RequestMethod.GET, headers);
			}
		}

		void Ban (string offenderSteamid, string expiryMinutes, string reason, bool global, string adminSteamid, BasePlayer caller) {
			string globalStr = global ? "global=true&" : "";
			string adminStr = (adminSteamid != null) ? "&admin_steamid=" + adminSteamid : "";

			webrequest.Enqueue (config.Host + "/api/server/users/" + offenderSteamid + "/bans", globalStr + "expiry_minutes=" + expiryMinutes + "&reason=" + reason + adminStr, (code, response) => {
				if (code != 200 && code != 204) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailedBan", this), code, response));
					return;
				}

				Puts (lang.GetMessage ("PlayerBanned", this));

				if (caller != null)
					SendReply (caller, lang.GetMessage ("PlayerBanned", this, caller.UserIDString));
			}, this, RequestMethod.POST, headers);
		}

		void Unban (string offenderSteamid, BasePlayer caller) {
			webrequest.Enqueue (config.Host + "/api/server/users/" + offenderSteamid + "/bans", null, (code, response) => {
				if (code != 200 && code != 204) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailedUnban", this), code, response));
					return;
				}

				Puts (lang.GetMessage ("PlayerUnbanned", this));

				if (caller != null)
					SendReply (caller, lang.GetMessage ("PlayerUnbanned", this, caller.UserIDString));
			}, this, RequestMethod.DELETE, headers);
		}

		void PostRole (string steamid, string role) {
			if (role == "default")
				return;

			webrequest.Enqueue (config.Host + "/api/server/users/" + steamid + "/roles", "role=" + role, (code, response) => {
				if (code != 200 && code != 204) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailedRoleAdd", this), role, code, response));
					return;
				}

				Puts (string.Format (lang.GetMessage ("ConsoleRoleAdded", this), role, steamid));
			}, this, RequestMethod.POST, headers);

		}

		void DeleteRole (string steamid, string role) {
			webrequest.Enqueue (config.Host + "/api/server/users/" + steamid + "/roles/" + role, null, (code, response) => {
				if (code != 200 && code != 204) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailedRoleRevoke", this), role, code, response));
					return;
				}

				Puts (string.Format (lang.GetMessage ("ConsoleRoleRevoked", this), role, steamid));
			}, this, RequestMethod.DELETE, headers);
		}

		static List<BasePlayer> GetPlayersByName (string name) {
			List<BasePlayer> matches = new List<BasePlayer> ();

			foreach (BasePlayer ply in BasePlayer.activePlayerList)
				if (ply.displayName.ToLower ().Contains (name.ToLower ()))
					matches.Add (ply);

			if (matches.Count () > 0)
				return matches;

			return null;
		}

		static BasePlayer GetPlayerBySteamID (string steamid) {
			foreach (BasePlayer ply in BasePlayer.activePlayerList)
				if (ply.UserIDString == steamid)
					return ply;

			return null;
		}

		protected void SendApiConnectionWarning (BasePlayer player) {
			SendReply (player, lang.GetMessage ("DebugChatPrefix", this) + "<color=orange>" + lang.GetMessage ("NoApiConnection", this, player.UserIDString) + "</color>");
		}
		#endregion

		#region Hooks
		private void Init () {
			config = Config.ReadObject<PluginConfig> ();
			config.Host = config.Host.TrimEnd (new Char[] { '/' });
			Config.WriteObject (config);
			headers = new Dictionary<string, string> { { "Authorization", "Bearer " + config.Token }, { "Accept", "application/json" } };

			permission.RegisterPermission (this.Title.ToLower () + ".ban", this);
			permission.RegisterPermission (this.Title.ToLower () + ".unban", this);

			Puts (lang.GetMessage ("ConsoleApiConnectionChecking", this));

			webrequest.Enqueue (config.Host + "/api/server/connectioncheck", null, (code, response) => {
				if ((code != 200 && code != 204) || response == null) {
					Puts (string.Format (lang.GetMessage ("ConsoleApiRequestFailed", this), code, response));
					Unsubscribe ("OnUserBanned");
					Unsubscribe ("OnUserUnbanned");
					Unsubscribe ("OnUserGroupAdded");
					Unsubscribe ("OnUserGroupRemoved");
					Unsubscribe ("OnUserApproved");
					return;
				}

				JObject json = JObject.Parse (response);
				banLog = (bool) json["settings"]["ban_log"];
				roleSync = new Dictionary<string, bool> () {
					{ "Receive", (bool) json["settings"]["role_sync"]["receive"] },
					{ "Send", (bool) json["settings"]["role_sync"]["send"] },
					{ "Create", (bool) json["settings"]["role_sync"]["create"] }
				};

				int pollInterval = (int) json["settings"]["poll_interval"];
				if (pollInterval > 0) {
					timer.Every (pollInterval, () => {
						PollUsers ();
					});
				}

				usersToPost = new Dictionary<string, string> ();
				usersProcessed = new List<string> ();
				userData = new Dictionary<string, JToken> ();
				timer.Every (5, () => {
					PostUsers (usersToPost);
					usersToPost = new Dictionary<string, string> ();
					PostUsersProcessed (usersProcessed);
					usersProcessed = new List<string> ();
				});

				connected = true;
				Puts (lang.GetMessage ("ConsoleApiConnectionSuccess", this));
			}, this, RequestMethod.GET, headers);
		}

		void OnUserBanned (string name, string id, string ipAddress, string reason) {
			if (banLog)
				Ban (id, "0", reason, false, null, null);
		}

		void OnUserUnbanned (string name, string id, string ipAddress) {
			if (banLog)
				Unban (id, null);
		}

		void OnUserGroupAdded (string id, string groupName) {
			if (roleSync["Send"])
				PostRole (id, groupName);
		}

		void OnUserGroupRemoved (string id, string groupName) {
			if (roleSync["Send"])
				DeleteRole (id, groupName);
		}

		void OnUserApproved (string name, string id, string ipAddress) {
			QueueUserToPost (id, name);
		}

		void OnPlayerConnected (BasePlayer player) {
			if (!connected) {
				if (player.net.connection.authLevel >= 1)
					SendApiConnectionWarning (player);
				return;
			}

			ProcessUser (player);
		}
		#endregion

		#region Chat commands
		[ChatCommand ("ban")]
		void cmdBan (BasePlayer player, string command, string[] args) {
			string steamid = player.UserIDString;

			if (player.net.connection.authLevel != 2 && !permission.UserHasPermission (player.UserIDString, this.Title.ToLower () + ".ban")) {
				SendReply (player, lang.GetMessage ("NoPermission", this, player.UserIDString));
				return;
			} else if (args == null || args.Length < 3) {
				SendReply (player, lang.GetMessage ("BanCommandUsage", this, player.UserIDString));
				return;
			}

			string offenderSteamid = "";
			if (args[0].IsSteamId ()) {
				offenderSteamid = args[0];
			} else {
				List<BasePlayer> offenderMatches = GetPlayersByName (args[0]);
				if (offenderMatches != null) {
					if (offenderMatches.Count () == 1) {
						offenderSteamid = offenderMatches.First ().UserIDString;
					} else {
						SendReply (player, lang.GetMessage ("MultiplePlayersFound", this, player.UserIDString));
						return;
					}
				} else {
					SendReply (player, string.Format (lang.GetMessage ("NoPlayersFoundByName", this, player.UserIDString), args[0]));
					return;
				}
			}

			int n;
			if (!int.TryParse (args[1], out n)) {
				SendReply (player, lang.GetMessage ("InvalidTime", this, player.UserIDString));
				return;
			}

			BasePlayer offender = GetPlayerBySteamID (offenderSteamid);

			if (offender != null)
				offender.Kick (lang.GetMessage ("Banned", this, offender.UserIDString));

			bool global = args.Length == 4 && args[3] == "true";
			Ban (offenderSteamid, args[1], args[2], global, steamid, player);
		}

		[ChatCommand ("unban")]
		void cmdUnban (BasePlayer player, string command, string[] args) {
			if (player.net.connection.authLevel != 2 && !permission.UserHasPermission (player.UserIDString, this.Title.ToLower () + ".unban")) {
				SendReply (player, lang.GetMessage ("NoPermission", this, player.UserIDString));
				return;
			} else if (args == null || args.Length < 1) {
				SendReply (player, lang.GetMessage ("UnbanCommandUsage", this, player.UserIDString));
				return;
			} else if (!args[0].IsSteamId ()) {
				SendReply (player, string.Format (lang.GetMessage ("InvalidSteamid", this, player.UserIDString), args[0]));
				return;
			}

			Unban (args[0].ToString (), player);
		}

		[ChatCommand ("sync")]
		void cmdSync (BasePlayer player, string command, string[] args) {
			if (!connected) {
				if (player.net.connection.authLevel >= 1)
					SendApiConnectionWarning (player);
				return;
			}

			QueueUserToPost (player.UserIDString);
			SendReply (player, lang.GetMessage ("Syncing", this, player.UserIDString));
		}
		#endregion

		#region Localization
		protected override void LoadDefaultMessages () {
			lang.RegisterMessages (new Dictionary<string, string> {
				{ "BanCommandUsage", "Usage: /ban <(partial) name/SteamID64> <time in minutes (0 for permanent)> \"<reason>\" <global?>" },
				{ "Banned", "You've been banned from the server" },
				{ "ConsoleApiConnectionChecking", "Checking connection to web API" },
				{ "ConsoleApiConnectionSuccess", "Connection established and token validated successfully" },
				{ "ConsoleApiRequestFailed", "Web API request failed. Code: {0}. Response: {1}" },
				{ "ConsoleApiRequestFailedBan", "Failed to ban user. Code: {0}. Response: {1}" },
				{ "ConsoleApiRequestFailedRoleAdd", "Failed to add role \"{0}\". Code: {1}. Response: {2}" },
				{ "ConsoleApiRequestFailedRoleRevoke", "Failed to revoke role \"{0}\". Code: {1}. Response: {2}" },
				{ "ConsoleApiRequestFailedUnban", "Failed to unban user. Code: {0}. Response: {1}" },
				{ "ConsoleCreatingGroup", "Creating group \"{0}\"" },
				{ "ConsoleGrantingGroup", "Granting the \"{0}\" group to {1} ({2})" },
				{ "ConsolePostingUsers", "Posting {0} user(s)" },
				{ "ConsoleProcessingUserData", "Processing user data for {0} ({1})" },
				{ "ConsoleRevokingGroup", "Revoking the \"{0}\" group from {1} ({2})" },
				{ "ConsoleRoleAdded", "Role \"{0}\" added for {1}" },
				{ "ConsoleRoleRevoked", "Role \"{0}\" revoked from {1}" },
				{ "ConsoleSyncingRoles", "Syncing roles for {0} ({1})" },
				{ "DebugChatPrefix", "[Ember] " },
				{ "GroupGranted", "You've been granted the {0} group" },
				{ "GroupRevoked", "Your {0} group has been revoked" },
				{ "InvalidSteamid", "Invalid SteamID" },
				{ "InvalidTime", "Time must be a number, 0 for permanent" },
				{ "MultiplePlayersFound", "Multiple players found, please be more specific" },
				{ "NoApiConnection", "The plugin is not connected to the web API. Check the server console for details" },
				{ "NoPermission", "You don't have the required permissions to do that" },
				{ "NoPlayersFoundByName", "Player not found by name \"{0}\"" },
				{ "PackageExpired", "Your {0} package has expired" },
				{ "PlayerBanned", "Player banned" },
				{ "PlayerUnbanned", "Player unbanned" },
				{ "RedeemingPackage", "Redeeming the {0} package" },
				{ "Syncing", "Synchronizing groups & purchases" },
				{ "UnbanCommandUsage", "Usage: /unban <SteamID64>" },
			}, this, "en");
			Puts ("Default messages created");
		}
		#endregion
	}
}

// --- End of file: Ember.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/enhanced-ban-system ---
// --- Original File Path: E/EnhancedBanSystem/EnhancedBanSystem.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.SQLite.Libraries;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    
    [Info("Enhanced Ban System", "Reneb/Slut", "5.2.6")]
    class EnhancedBanSystem : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlayerDatabase, DiscordMessages;

        ////////////////////////////////////////////////////////////
        // Static fields
        ////////////////////////////////////////////////////////////
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        char[] ipChrArray = new char[] { '.' };

        private static BanSystem banSystem;

        static Hash<int, BanData> cachedBans = new Hash<int, BanData>();

        static List<int> wasBanned = new List<int>();

        ////////////////////////////////////////////////////////////
        // Config fields
        ////////////////////////////////////////////////////////////
        private static string Platform = "Steam";
        private static string Server = "1.1.1.1:28015";
        private static string Game = "Rust";

        string PermissionBan = "enhancedbansystem.ban";
        string PermissionUnban = "enhancedbansystem.unban";
        string PermissionBanlist = "enhancedbansystem.banlist";
        string PermissionKick = "enhancedbansystem.kick";

        private bool SQLite_use = false;
        private string SQLite_DB = "banlist.db";

        private bool MySQL_use = false;
        private string MySQL_Host = "localhost";
        private int MySQL_Port = 3306;
        private string MySQL_DB = "banlist";
        private string MySQL_User = "root";
        private string MySQL_Pass = "toor";

        private bool PlayerDatabase_use = false;
        private string PlayerDatabase_IPFile = "EnhancedBanSystem_IPs.json";

        private bool Files_use = false;

        private bool WebAPI_use = false;
        private string WebAPI_Ban_Request = "http://webpage.com/api.php?action=ban&pass=mypassword&id={id}&steamid={steamid}&name={name}&ip={ip}&reason={reason}&source={source}&game={game}&platform={platform}&server={server}&tempban={expiration}";
        private string WebAPI_Unban_Request = "http://webpage.com/api.php?action=unban&pass=mypassword&steamid={steamid}&name={name}&ip={ip}&name={name}&source={source}";
        private string WebAPI_IsBanned_Request = "http://webpage.com/api.php?action=isbanned&pass=mypassword&id={id}&update={update}&steamid={steamid}&ip={ip}&time={time}&name={name}&game=Rust&server=rust.kortal.org:28015";
        private string WebAPI_Banlist_Request = "http://webpage.com/banlist.php?startid={startid}";

        private bool Native_use = false;

        private string BanDefaultReason = "Banned";
        private string BanEvadeReason = "Ban Evade";

        private bool Kick_Broadcast = true;
        private bool Kick_Log = true;
        private bool Kick_OnBan = true;

        private bool Ban_Broadcast = true;
        private bool Ban_Log = true;
        private bool Discord_use = false;
        private string Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private bool Ban_Escape = true;

        private bool Log_Denied = true;

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Server Info - Platform", ref Platform);
            CheckCfg<string>("Server Info - Game", ref Game);
            CheckCfg<string>("Server Info - IP:PORT", ref Server);

            CheckCfg<string>("Permissions - Ban", ref PermissionBan);
            CheckCfg<string>("Permissions - Unban", ref PermissionUnban);
            CheckCfg<string>("Permissions - Banlist", ref PermissionBanlist);
            CheckCfg<string>("Permissions - Kick", ref PermissionKick);

            CheckCfg<bool>("DataType - SQLite - use", ref SQLite_use);
            CheckCfg<string>("DataType - SQLite - Database Filename", ref SQLite_DB);

            CheckCfg<bool>("DataType - MySQL - use", ref MySQL_use);
            CheckCfg<string>("DataType - MySQL - Host", ref MySQL_Host);
            CheckCfg<int>("DataType - MySQL - Port", ref MySQL_Port);
            CheckCfg<string>("DataType - MySQL - Database", ref MySQL_DB);
            CheckCfg<string>("DataType - MySQL - User", ref MySQL_User);
            CheckCfg<string>("DataType - MySQL - Pass", ref MySQL_Pass);

            CheckCfg<bool>("DataType - Files - use", ref Files_use);

            CheckCfg<bool>("DataType - PlayerDatabase - use", ref PlayerDatabase_use);
            CheckCfg<string>("DataType - PlayerDatabase - IP Filename", ref PlayerDatabase_IPFile);

            CheckCfg<bool>("DataType - WebAPI - use", ref WebAPI_use);
            CheckCfg<string>("DataType - WebAPI - Host", ref WebAPI_Ban_Request);
            CheckCfg<string>("DataType - WebAPI - Unban", ref WebAPI_Unban_Request);
            CheckCfg<string>("DataType - WebAPI - IsBanned", ref WebAPI_IsBanned_Request);
            CheckCfg<string>("DataType - WebAPI - Banlist", ref WebAPI_Banlist_Request);

            CheckCfg<bool>("DataType - Native - use", ref Native_use);

            CheckCfg<bool>("Ban - Evade", ref Ban_Escape);
            CheckCfg<string>("Ban - Default Reason", ref BanDefaultReason);
            CheckCfg<string>("Ban - Evade Reason", ref BanEvadeReason);
            CheckCfg<bool>("Ban - Broadcast", ref Ban_Broadcast);
            CheckCfg<bool>("Ban - Log", ref Ban_Log);
            CheckCfg<bool>("DiscordMessages - Use Discord", ref Discord_use);
            CheckCfg<string>("DiscordMessages - Discord Webhook", ref Discord_Webhook);

            CheckCfg<bool>("Kick - Broadcast", ref Kick_Broadcast);
            CheckCfg<bool>("Kick - Log", ref Kick_Log);
            CheckCfg<bool>("Kick - On Ban", ref Kick_OnBan);

            CheckCfg<bool>("Denied Connection - Log", ref Log_Denied);

            SaveConfig();

            if (SQLite_use) banSystem |= BanSystem.SQLite;
            if (MySQL_use) banSystem |= BanSystem.MySQL;
            if (Native_use) banSystem |= BanSystem.Native;
            if (PlayerDatabase_use) banSystem |= BanSystem.PlayerDatabase;
            if (Files_use) banSystem |= BanSystem.Files;
            if (WebAPI_use) banSystem |= BanSystem.WebAPI;

            InitializeLang();
        }

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "No matching player was found.\n" },
                { "PlayerTempBanned", "You are temporarily banned from this server ({0}). {1} left" },
                { "PlayerPermBanned", "You are permanently banned from this server ({0})." },
                {"LoadedBans","Loaded {0} bans" },
                {"BanExists","This ban already exists ({0})." },
                {"BanAdded","Successfully added {0} to the banlist." },
                {"MultipleBans","Multiple Bans Found:\n\r" },
                {"BansRemoved","{0} matching bans were removed" },
                {"PlayerNotBanned","{0} - {1} isn't banned.\n" },
                {"Loaded","Loaded" },
                {"NoPermission","You don't have the permission to use this command." },
                {"KickSyntax","Syntax: kick < Name | SteamID | IP | IP Range > < reason(optional) >" },
                {"UnbanSyntax","Syntax: unban < Name | SteamID | IP | IP Range >" },
                {"BanSyntax","Syntax: ban < Name | SteamID | IP | IP Range > < reason(optional) > < time in secondes(optional) > " },
                {"BanlistSyntax","Syntax: banlist <BanSystem> <startid>" },
                {"BanSystems","Avaible BanSystems:\n" },
                {"BanlistSyntax1","Wrong usage of /banlist" },
                {"OutOfRange","Index is out of range. Current bans recorded: {0}" },
                {"Banlist","Banlist - {0}-{1}/{2}\n" },
                {"PlayerPermBan", "{0} was permanently banned from the server for {1}" },
                {"PlayerTempBan", "{0} was temporarily banned for {1} for {2}" },
                {"PlayerKick", "<color=red>{0}</color> <color=silver>was kicked from the server for</color> <color=red>{1}</color>" },
                {"IPPermBan", "An IP was banned from the server for {0}" },
                {"IPTempBan", "An IP was temporarily banned for {0} for {1}" },
                {"BanUpdated", "Succesfully updated {0} in the banlist." }
            }, this);
        }

        ////////////////////////////////////////////////////////////
        // ID Save
        ////////////////////////////////////////////////////////////

        private static DynamicConfigFile Ban_ID_File;
        private static int Ban_ID = 0;

        void Load_ID()
        {
            try
            {
                Ban_ID_File = Interface.Oxide.DataFileSystem.GetDatafile(Name + "_ID");
                Ban_ID = (int)Ban_ID_File["id"];
            }
            catch
            {
                Ban_ID = 0;
                Ban_ID_File["id"] = Ban_ID;
                Save_ID();
            }
        }

        void Save_ID()
        {
            Interface.Oxide.DataFileSystem.SaveDatafile(Name + "_ID");
        }

        static int GetNewID()
        {
            Ban_ID++;
            Ban_ID_File["id"] = Ban_ID;
            return Ban_ID;
        }

        ////////////////////////////////////////////////////////////
        // Enum & Class
        ////////////////////////////////////////////////////////////

        enum BanSystem
        {
            Native = 1,
            MySQL = 2,
            SQLite = 4,
            WebAPI = 8,
            PlayerDatabase = 16,
            Files = 32,
        }

        class BanData
        {
            public int id;
            public string steamid;
            public string ip;
            public string name;
            public string game;
            public string server;
            public string source;
            public double date;
            public double expire;
            public string reason;
            public string platform;

            public BanData() { }

            public BanData(object source, string userID, string name, string ip, string reason, double duration)
            {
                this.id = GetNewID();
                this.source = source is IPlayer ? ((IPlayer)source).Name : source is string ? (string)source : "Console";
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = duration != 0.0 ? LogTime() + duration : 0.0;
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public BanData(int id, string source, string userID, string name, string ip, string reason, string duration)
            {
                this.id = id;
                this.source = source;
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = double.Parse(duration);
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public override string ToString()
            {
                return string.Format("{0} - {1} - {2} - {3} - {4}", steamid, name, ip, reason, expire == 0.0 ? "Permanent" : expire < LogTime() ? "Expired" : string.Format("Temporary: {0}s", (expire - LogTime()).ToString()));
            }
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////


        private bool IsPluginLoaded(Plugin plugin)
        {
            if (plugin != null)
            {
                return plugins.GetAll().Where(x => x.Equals(plugin) && x.IsLoaded) != null;
            }
            else
            {
                return false;
            }
        }
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }


        static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        string GetMsg(string key, object steamid = null, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString()), args);
            }
            else
            {
                return lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString());
            }
        }

        bool hasPermission(IPlayer player, string permissionName)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.Id.ToString(), permissionName);
        }

        bool isIPAddress(string arg)
        {
            int subIP;
            string[] strArray = arg.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }
            foreach (string str in strArray)
            {
                if (str.Length == 0)
                {
                    return false;
                }
                if (!int.TryParse(str, out subIP) && str != "*")
                {
                    return false;
                }
                if (!(str == "*" || (subIP >= 0 && subIP <= 255)))
                {
                    return false;
                }
            }
            return true;
        }

        bool IPRange(string sourceIP, string targetIP)
        {
            string[] srcArray = sourceIP.Split(ipChrArray);
            string[] trgArray = targetIP.Split(ipChrArray);
            for (int i = 0; i < 4; i++)
            {
                if (srcArray[i] != trgArray[i] && srcArray[i] != "*")
                {
                    return false;
                }
            }
            return true;
        }

        bool RangeFromIP(string sourceIP, out string range1, out string range2, out string range3)
        {
            range1 = string.Empty;
            range2 = string.Empty;
            range3 = string.Empty;
            if (sourceIP == string.Empty) return false;

            string[] strArray = sourceIP.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }

            range1 = string.Format("{0}.*.*.*", strArray[0]);
            range2 = string.Format("{0}.{1}.*.*", strArray[0], strArray[1]);
            range3 = string.Format("{0}.{1}.{2}.*", strArray[0], strArray[1], strArray[2]);

            return true;
        }

        List<IPlayer> FindPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            var FoundPlayers = players.FindPlayers(userIDorNameorIP).ToList();
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source) + "xd ";
            }
            if (FoundPlayers.Count > 1)
            {
                foreach (var iplayer in FoundPlayers)
                {
                    reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                }
            }
            return FoundPlayers;
        }

        List<IPlayer> FindConnectedPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            ulong steamid = 0L;
            var FoundPlayers = new List<IPlayer>();
            ulong.TryParse(userIDorNameorIP, out steamid);
            if (isIPAddress(userIDorNameorIP))
            {
                FoundPlayers = players.All.Where(x => x.IsConnected).Where(w => IPRange(userIDorNameorIP, w.Address)).ToList();
            }
            else if (steamid != 0L)
            {
                var p = players.FindPlayer(userIDorNameorIP);
                if (p != null && p.IsConnected)
                {
                    FoundPlayers.Add(p);
                }
            }
            else
            {
                FoundPlayers = players.FindPlayers(userIDorNameorIP).Where(x => x.IsConnected).ToList();
                if (FoundPlayers.Count > 1)
                {
                    foreach (var iplayer in FoundPlayers)
                    {
                        reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                    }
                }
            }
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source);
            }
            return FoundPlayers;
        }

        string GetPlayerIP(IPlayer iplayer)
        {
            try
            {
                if (iplayer.IsConnected) return iplayer.Address;
                return GetPlayerIP(iplayer.Id);
            }
            catch
            {
                return GetPlayerIP(iplayer.Id);
            }
        }
        string GetPlayerIP(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "ip") ?? string.Empty;
            }
            return string.Empty;
        }

        string GetPlayerName(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "name") ?? string.Empty;
            }
            return string.Empty;
        }
        bool HasDelayedAnswer() => BanSystemHasFlag(banSystem, BanSystem.MySQL) || BanSystemHasFlag(banSystem, BanSystem.SQLite) || (BanSystemHasFlag(banSystem, BanSystem.WebAPI));

        bool BanSystemHasFlag(BanSystem b, BanSystem t) => (b & t) == t;

        string FormatReturn(BanSystem system, string msg, params object[] args) => string.Format("{0}: {1}", system.ToString(), string.Format(msg, args));

        void SendReply(object source, string msg)
        {
            if (source is IPlayer) ((IPlayer)source).Reply(msg);
            else if (source is string) return;
            else Interface.Oxide.LogInfo(msg);
        }

        public static string ToShortString(TimeSpan timeSpan)
        {
            return string.Format("{0:00}:{1:00}:{2:00}", (int)timeSpan.TotalHours, timeSpan.Minutes, timeSpan.Seconds);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////


        void OnServerInitialized()
        {
            Load_ID();
            List<string> returnString = new List<string>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                 returnString.Add(PlayerDatabase_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnString.Add(Files_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnString.Add(MySQL_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnString.Add(SQLite_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnString.Add(WebAPI_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnString.Add(Native_Load());
            }

            if (returnString.Count == 0)
            {
                this.LogWarning("You must enable at least one Ban System to use this plugin!");
                Interface.Oxide.UnloadPlugin(Name);
            }

            permission.RegisterPermission(PermissionBan, this);
            permission.RegisterPermission(PermissionBanlist, this);
            permission.RegisterPermission(PermissionKick, this);
            permission.RegisterPermission(PermissionUnban, this);

            Interface.Oxide.LogInfo(string.Join("\n", returnString.ToArray()));

            if (Discord_use && (!IsPluginLoaded(DiscordMessages) || Discord_Webhook.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")))
            {
                LogError("DiscordMessages enabled but it isn't setup correctly.");
                Discord_use = false;
            }
        }

        void Unload() => OnServerSave();

        void OnServerSave()
        {
            Save_ID();
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                Save_PlayerDatabaseIP();
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                Save_Files();
            }
        }
        private void OnUserBanned(string name, string id, string address, string reason)
        {
            timer.Once(5f, () =>
            {
                if (!isBanned_Check(name, id, address))
                {
                    Puts("Adding banned player to EnhancedBanSystem");
                    BanData bd = new BanData("Auto Ban", id, name, address, reason, 0.0);
                    ExecuteBan("Auto Ban", bd, false);
                }
            });
        }
        object CanUserLogin(string name, string id, string ip)
        {
            BanData bd = null;
            if (isBanned_NonDelayed(name, id, ip, Ban_Escape, out bd))
            {
                if (bd != null && bd.expire != 0.0)
                {
                    return GetMsg("PlayerTempBanned", id, bd.reason, FormatTime(TimeSpan.FromSeconds(bd.expire - LogTime())));
                }
                return GetMsg("PlayerPermBanned", id, bd == null ? string.Empty : bd.reason);
            }
            return null;
        }

        void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            string ip = player.Address;
            string name = player.Name;
            string steamid = player.Id;

            isBanned_Delayed(name, steamid, ip, Ban_Escape);
        }

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string Files_Load()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var b in storedData.Banlist)
            {
                var bd = JsonConvert.DeserializeObject<BanData>(b);
                if (!cachedBans.ContainsKey(bd.id))
                    cachedBans.Add(bd.id, bd);
            }
            return FormatReturn(BanSystem.Files, GetMsg("LoadedBans", null), storedData.Banlist.Count.ToString());
        }

        void Save_Files()
        {
            if (storedData.Banlist == null)
            {
                return;
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        string Files_UpdateBan(BanData bandata)
        {
            if (!cachedBans.ContainsKey(bandata.id)) return FormatReturn(BanSystem.Files, "No such ban id {0}", bandata.id);

            storedData.Banlist.Remove(cachedBans[bandata.id].ToJson());
            cachedBans.Remove(bandata.id);

            storedData.Banlist.Add(bandata.ToJson());

            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
        }

        string Files_ExecuteBan(BanData bandata)
        {

            var f = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == bandata.steamid).ToList();
            if (f.Count > 0)
            {
                var i = f.ToList();
                foreach (var id in i)
                {
                    if (id.expire == 0.0 || id.expire < LogTime()) continue;
                    storedData.Banlist.Remove(id.ToJson());
                    f.Remove(id);
                }
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.Files, GetMsg("BanExists"), f[0].ToString());
                }
            }
            storedData.Banlist.Add(bandata.ToJson());
            Save_Files();
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanAdded"), bandata.ToString());
        }

        string Files_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                var json = u.ToJson();
                if (storedData.Banlist.Contains(json))
                {
                    i++;
                    storedData.Banlist.Remove(json);
                }
            }
            return FormatReturn(BanSystem.Files, GetMsg("BansRemoved"), i.ToString());
        }

        string Files_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                var list = cachedBans.Values.Where(x => x.name.ToLower().Equals(name.ToLower())).ToList();
                if (list.Count > 1)
                {
                    var ret = FormatReturn(BanSystem.Files, GetMsg("MultipleBans"));
                    foreach (var b in list)
                    {
                        ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                    }
                    return ret;
                }
                else
                {
                    unbanList = list;
                }
            }
            return Files_RawUnban(unbanList);
        }

        bool Files_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            var b_steamid_ip = ip != null ? b_steamid.Where(w => w.ip == ip).ToList() : new List<BanData>();

            foreach (var b in b_steamid_ip)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid_ip.Remove(u);
                }
                unbanList.Clear();
            }
            foreach (var b in b_steamid)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid.Remove(u);
                }
                unbanList.Clear();
            }
            if (bandata == null)
            {
                if (b_steamid_ip.Count > 0)
                {
                    bandata = b_steamid_ip[0];
                }
                else if (b_steamid.Count > 0)
                {
                    bandata = b_steamid[0];
                }
            }
            if (bandata == null && !permanent)
            {
                // check by IP & IP Range
                list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
                foreach (var b in list)
                {
                    if (b.expire != 0.0 && cTime >= b.expire)
                    {
                        unbanList.Add(b);
                    }
                    else
                    {
                        if (b.expire == 0.0)
                        {
                            permanent = true;
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    Files_RawUnban(unbanList);
                    foreach (var u in unbanList)
                    {
                        list.Remove(u);
                    }
                    unbanList.Clear();
                }
                if (list.Count > 0)
                {
                    bandata = list[0];
                }
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                bandata.expire = 0.0;
                Files_UpdateBan(bandata);
            }
            return bandata != null;
        }

        string Files_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.Files, "Index is out of range. Current bans recorded: {0}", cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.Files, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // PlayerDatabase
        ////////////////////////////////////////////////////////////

        static StoredIPData storedIPData;

        class StoredIPData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string PlayerDatabase_Load()
        {
            if (!IsPluginLoaded(PlayerDatabase)) return FormatReturn(BanSystem.PlayerDatabase, "Missing plugin: oxidemod.org/threads/playerdatabase.18409/");

            try
            {
                storedIPData = Interface.Oxide.DataFileSystem.ReadObject<StoredIPData>(PlayerDatabase_IPFile);
            }
            catch
            {
                storedIPData = new StoredIPData();
            }

            if (storedIPData.Banlist.Count > 0)
            {
                foreach (var b in storedIPData.Banlist)
                {
                    var bd = JsonConvert.DeserializeObject<BanData>(b);
                    if (!cachedBans.ContainsKey(bd.id))
                        cachedBans.Add(bd.id, bd);
                }
            }
            var getKnownPlayers = (List<string>)PlayerDatabase.Call("GetAllKnownPlayers");
            if (getKnownPlayers == null) return FormatReturn(BanSystem.PlayerDatabase, "Error P01");

            int i = 0;
            List<BanData> list = new List<BanData>();
            foreach (var steamid in getKnownPlayers)
            {
                var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (!(success is string)) continue;

                
                if (((string)success).Equals("System.Collections.Generic.List`1[Oxide.Plugins.EnhancedBanSystem+BanData]", StringComparison.Ordinal))
                {
                    list = new List<BanData>();
                }
                else
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                foreach (var b in list)
                {
                    i++;
                    if (!cachedBans.ContainsKey(b.id))
                        cachedBans.Add(b.id, b);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("LoadedBans"), i.ToString());
        }

        void Save_PlayerDatabaseIP()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PlayerDatabase_IPFile, storedIPData);
        }


        string PlayerDatabase_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid != string.Empty)
            {
                List<BanData> list = new List<BanData>();
                var success = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (success is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                var f = list.Where(x => x.ip == bandata.ip).ToList();
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f[0].ToString());
                }
                f.Add(bandata);
                PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", f, true);
            }
            else
            {
                var f2 = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == string.Empty).ToList();
                if (f2.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f2[0].ToString());
                }
                storedIPData.Banlist.Add(bandata.ToJson());
            }
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanAdded"), bandata.ToString());
        }

        string PlayerDatabase_UpdateBan(BanData bandata, double expire)
        {
            if (bandata.steamid == string.Empty)
            {
                if (cachedBans.ContainsKey(bandata.id))
                {
                    var json = bandata.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        cachedBans.Remove(bandata.id);
                        storedIPData.Banlist.Remove(json);
                        bandata.expire = expire;
                        storedIPData.Banlist.Add(bandata.ToJson());
                        cachedBans.Add(bandata.id, bandata);
                        return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                    }
                }
            }
            else
            {
                List<BanData> list = new List<BanData>();
                bandata.expire = expire;
                var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (b_steamid is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
                }
                if (list.Count > 0)
                {
                    foreach (var b in list)
                    {
                        b.expire = expire;
                    }
                    PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", list, true);
                    return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                }
            }
            return string.Empty;
        }

        string PlayerDatabase_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                if (u.steamid == string.Empty)
                {
                    var json = u.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        i++;
                        storedIPData.Banlist.Remove(json);
                    }
                }
                else
                {
                    i++;
                    PlayerDatabase.Call("SetPlayerData", u.steamid, "Banned", new List<BanData>(), true);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BansRemoved"), i.ToString());
        }

        string PlayerDatabase_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                unbanList = cachedBans.Values.Where(x => x.name == name).ToList();
                if (unbanList.Count == 0)
                {
                    var lname = name.ToLower();
                    unbanList = cachedBans.Values.Where(x => x.name.ToLower().Contains(lname)).ToList();
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.PlayerDatabase, GetMsg("MultipleBans"));
                        foreach (var b in unbanList)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                        }
                        return ret;
                    }
                }
            }
            return PlayerDatabase_RawUnban(unbanList);
        }

        bool PlayerDatabase_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            BanData possibleData = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
            if (b_steamid is string)
            {
                list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
            }
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }

            if (list.Count > 0 && bandata == null)
            {
                possibleData = list[0];
            }
            // check by IP & IP Range
            list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }
            if (list.Count > 0 && bandata == null && possibleData == null)
            {
                possibleData = list[0];
            }
            if (bandata == null && possibleData != null)
            {
                bandata = possibleData;
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                PlayerDatabase_UpdateBan(bandata, 0.0);
            }
            return bandata != null;
        }

        string PlayerDatabase_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.PlayerDatabase, GetMsg("OutOfRange"), cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.PlayerDatabase, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // WebAPI
        ////////////////////////////////////////////////////////////

        string FormatOnlineBansystem(string line, Dictionary<string, string> args)
        {
            foreach (KeyValuePair<string, string> pair in args)
            {
                line = line.Replace(pair.Key, pair.Value);
            }
            return line;
        }

        string WebAPI_ExecuteBan(object source, BanData bandata)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Ban_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{reason}", bandata.reason }, { "{source}", bandata.source }, { "{expiration}", bandata.expire.ToString() }, { "{game}", bandata.game }, { "{platform}", bandata.platform }, { "{server}", bandata.server } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);


            return string.Empty;
        }

        string WebAPI_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Unban_Request, new Dictionary<string, string> { { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);

            return string.Empty;
        }

        string WebAPI_IsBanned(BanData bandata, bool update)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{source}", "Auto Ban" }, { "{update}", update.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    if (response == "false" || response == "0")
                        return;
                    timer.Once(0.01f, () => Kick(null, bandata.steamid, response == "true" || response == "1" ? "Banned" : response, false));
                }
                else
                {
                    Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Banlist(object source, int startid)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Banlist_Request, new Dictionary<string, string> { { "{startid}", startid.ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    SendReply(source, response);
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Load()
        {
            return FormatReturn(BanSystem.WebAPI, GetMsg("Loaded"));
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        SQLite Sqlite = Interface.Oxide.GetLibrary<SQLite>();
        Connection Sqlite_conn;

        string SQLite_Load()
        {
            var returnstring = string.Empty;
            try
            {
                Sqlite_conn = Sqlite.OpenDb(SQLite_DB, this);
                if (Sqlite_conn == null)
                {
                    returnstring = FormatReturn(BanSystem.SQLite, "Couldn't open the SQLite.");
                }
                else
                {
                    Sqlite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS EnhancedBanSystem ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, steamid TEXT, name TEXT, ip TEXT, reason TEXT, source TEXT, game TEXT, platform TEXT, server TEXT, expire INTEGER );"), Sqlite_conn);
                    returnstring = FormatReturn(BanSystem.SQLite, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                returnstring = e.Message;
            }
            return FormatReturn(BanSystem.SQLite, returnstring);
        }


        string SQLite_RawBan(BanData bandata)
        {
            try
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("INSERT OR REPLACE INTO EnhancedBanSystem ( id, steamid, name, ip, reason, source, game, platform, server, expire ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.SQLite, GetMsg("BanAdded"), bandata.ToString());
        }

        string SQLite_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0 AND `ip` == @1 ", bandata.steamid, bandata.ip);

            Sqlite.Query(sqlString, Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.SQLite, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                var reponse2 = SQLite_RawBan(bandata);
                if (source is IPlayer) ((IPlayer)source).Reply(reponse2);
                else Interface.Oxide.LogInfo(reponse2);
            });

            return string.Empty;
        }

        void SQLite_RawUnban(object source, List<long> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("DELETE from EnhancedBanSystem WHERE `id` = @0", id), Sqlite_conn);
            }
            var returnstring = FormatReturn(BanSystem.SQLite, GetMsg("BansRemoved"), unbanList.Count.ToString());
            SendReply(source, returnstring);
        }

        string SQLite_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<long> unbanList = new List<long>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid);
                Sqlite.Query(sqlString, Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `name` LIKE @0", "%" + name + "%"), Sqlite_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.SQLite, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            return string.Empty;
        }

        void SQLite_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void SQLite_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            double cTime = LogTime();
            List<long> unbanList = new List<long>();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", bandata.steamid), Sqlite_conn, list =>
            {

                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (long)entry["expire"];
                        if (expire != 0.0 && cTime >= expire)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    SQLite_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 OR `ip` == @1 OR `ip` == @2 OR `ip` == @3", bandata.ip, range1, range2, range3), Sqlite_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (long)entry["expire"];
                                    if (expire != 0.0 && cTime >= expire)
                                    {
                                        unbanList.Add((long)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if ((long)(match["expire"]) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        bd.expire = bandata.expire;
                                        SQLite_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                    if (match.ContainsKey("expire"))
                    {
                        if ((long)(match["expire"]) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            SQLite_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string SQLite_Banlist(object source, int startid)
        {
            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem ORDER BY id DESC"), Sqlite_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.SQLite, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";
                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        string MySQL_Load()
        {
            try
            {
                Sql_conn = Sql.OpenDb(MySQL_Host, MySQL_Port, MySQL_DB, MySQL_User, MySQL_Pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    return FormatReturn(BanSystem.MySQL, "Couldn't open the MySQL PlayerDatabase: {0} ", Sql_conn.Con.State.ToString());
                }
                else
                {
                    Sql.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS enhancedbansystem ( `id` int(11) NOT NULL, `steamid` VARCHAR(17),`name` VARCHAR(25),`ip` VARCHAR(15),`reason` VARCHAR(25),`source` VARCHAR(25), `game` VARCHAR(25) , `platform` VARCHAR(25), `server` VARCHAR(25), `expire` int(11) );"), Sql_conn);
                    return FormatReturn(BanSystem.MySQL, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                return FormatReturn(BanSystem.MySQL, e.Message);
            }
        }

        string MySQL_RawBan(BanData bandata)
        {
            try
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("INSERT IGNORE INTO enhancedbansystem ( `id`, `steamid`,`name`,`ip`,`reason`,`source`,`game`,`platform`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sql_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.MySQL, GetMsg("BanAdded"), bandata.ToString());
        }

        void MySQL_UpdateBan(BanData bandata)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void MySQL_RawUnban(object source, List<int> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("DELETE from enhancedbansystem WHERE `id` = @0", id), Sql_conn);
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    Native_ExecuteUnban(id.ToString(), null);
                }
            }
            SendReply(source, FormatReturn(BanSystem.MySQL, GetMsg("BansRemoved"), unbanList.Count.ToString()));
        }
        string MySQL_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0 AND `ip` = @1 ", bandata.steamid, bandata.ip);
            Sql.Query(sqlString, Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.MySQL, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                SendReply(source, MySQL_RawBan(bandata));
            });
            return string.Empty;
        }

        string MySQL_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<int> unbanList = new List<int>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid);
                Sql.Query(sqlString, Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    MySQL_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `name` LIKE @0", "%" + name + "%"), Sql_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        string ret = FormatReturn(BanSystem.MySQL, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    else
                    {
                        MySQL_RawUnban(source, unbanList);
                    }
                });
            }
            return string.Empty;
        }

        void MySQL_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            List<int> unbanList = new List<int>();
            double cTime = LogTime();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", bandata.steamid), Sql_conn, list =>
            {
                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (int)entry["expire"];
                        if (expire != 0 && cTime >= expire)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    MySQL_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (int)x["expire"] == 0).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 OR `ip` = @1 OR `ip` = @2 OR `ip` = @3", bandata.ip, range1, range2, range3), Sql_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (int)entry["expire"];
                                    if (expire != 0 && cTime >= double.Parse(expire.ToString()))
                                    {
                                        unbanList.Add((int)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (int)(match["expire"]) : (int)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if (double.Parse(match["expire"].ToString()) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        MySQL_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"]));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? double.Parse(match["expire"].ToString()) : double.Parse(l[0]["expire"].ToString());
                    if (match.ContainsKey("expire"))
                    {
                        if (double.Parse(match["expire"].ToString()) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            MySQL_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string MySQL_Banlist(object source, int startid)
        {
            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem ORDER BY id DESC"), Sql_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.MySQL, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";

                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // Native
        ////////////////////////////////////////////////////////////

        string Native_Load()
        {
            return FormatReturn(BanSystem.Native, GetMsg("Loaded"));
        }
        string Native_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid.Length == 0) return FormatReturn(BanSystem.Native, "Can't ban by IP.");

            var player = players.FindPlayer(bandata.steamid);
            if (player == null) return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            if (player.IsBanned) return FormatReturn(BanSystem.Native, GetMsg("BanExists"), bandata.steamid.ToString());

            TimeSpan duration = bandata.expire == 0.0 ? default(TimeSpan) : TimeSpan.FromSeconds(bandata.expire);
            player.Ban(bandata.reason, duration);
#if RUST
            if (bandata.expire != 0.0)
            {
              return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString()) + "\nWARNING: NATIVE temporary bans are not supported in RUST! Temporary bans will stay permanent";
            }
#endif
            return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString());
        }

        string Native_ExecuteUnban(string steamid, string name)
        {
            if (steamid == string.Empty)
            {
                if (name == string.Empty) return string.Empty;
                var f = players.FindPlayers(name).Where(x => x.IsBanned).ToList();
                if (f.Count == 0)
                {
                    return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
                }
                if (f.Count > 1)
                {
                    var ret = string.Empty;
                    foreach (var p in f)
                    {
                        ret += string.Format("{0} - {1}\n", p.Id, p.Name);
                    }
                    return ret;
                }
                steamid = f[0].Id;
            }
            var b = players.FindPlayer(steamid);
            if (b == null)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            }
            if (!b.IsBanned)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotBanned"), b.Id, b.Name);
            }
            b.Unban();
            return FormatReturn(BanSystem.Native, "1 matching bans were removed");
        }

        bool Native_IsBanned(string steamid)
        {
            var b = players.FindPlayer(steamid);
            if (b != null)
            {
                return b.IsBanned;
            }
            return false;
        }

        string Native_Banlist(object source, int startid)
        {
            int i = -1;
            int max = startid + 9;

            var banlist = players.All.Where(x => x.IsBanned).ToList();

            string returnstring = FormatReturn(BanSystem.Native, GetMsg("Banlist"), startid.ToString(), max.ToString(), banlist.Count.ToString());

            foreach (IPlayer b in banlist)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += string.Format("{0} - {1} - {2}", b.Id, b.Name, ToShortString(b.BanTimeRemaining));
            }

            return returnstring;
        }


        ////////////////////////////////////////////////////////////
        // Kick
        ////////////////////////////////////////////////////////////

        string Kick(object source, string target, string reason, bool shouldBroadcast = true)
        {
            string r = string.Empty;
            var foundplayers = FindConnectedPlayers(target, source, out r);
            if (r != string.Empty)
            {
                return r;
            }

            var returnkick = string.Empty;
            foreach (var iplayer in foundplayers)
            {
                returnkick += ExecuteKick(source, iplayer, reason, shouldBroadcast) + "\r\n";
            }

            return returnkick;
        }
        string TryKick(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : "Kicked";
            return Kick(source, target, reason);
        }

        string ExecuteKick(object source, IPlayer player, string reason, bool shouldBroadcast = true)
        {
            if (shouldBroadcast && Kick_Broadcast)
            {
                server.Broadcast(GetMsg("PlayerKick", null, player.Name.ToString(), reason));
                if (Discord_use)
                {
                    object payload = new[]
                    {
                        new{name="Player", value=$"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", inline=true},
                        new{name="Kicked By", value=source is IPlayer ? ((IPlayer)source).Name : source.ToString(),inline=true },
                        new{name="Reason", value=reason, inline=false}
                    };
                    string json = JsonConvert.SerializeObject(payload);
                    DiscordMessages.Call("API_SendFancyMessage", Discord_Webhook, "Player Kick", 3329330, json);
                }
            }

            if (Kick_Log)
                Interface.Oxide.LogWarning(GetMsg("{0} was kicked from the server ({1})", null, player.Name.ToString(), reason));

            player.Kick(reason);


            return GetMsg("{0} was kicked from the server ({1})", source, player.Name.ToString(), reason);
        }


        ////////////////////////////////////////////////////////////
        // IsBanned
        ////////////////////////////////////////////////////////////
        bool isBanned_Check(string name, string steamid, string ip)
        {
            int count = 0;
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                count++;
                var files = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
                if (files.Count > 0)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                count++;
                var playerdatabase = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (playerdatabase is string && playerdatabase != null)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                count++;
                bool foundMySQL = false;
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid), Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foundMySQL = true;
                    }
                });
                if (foundMySQL)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                count++;
                bool sqlite = false;
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid), Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        sqlite = true;
                    }
                });
                if (sqlite)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                count++;
                bool banned = false;
                webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", null }, { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip }, { "{source}", "Auto Ban" }, { "{update}", false.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
                {
                    if (response != null || code != 200)
                    {
                        if (response == "true")
                        {
                            banned = true;
                        }
                    }
                    else
                    {
                        Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                    }
                }, this);
                if (banned == true)
                {
                    return banned;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native) && count > 0)
            {
                return false;
            }
            else if (BanSystemHasFlag(banSystem, BanSystem.Native) && count == 0)
            {
                var player = players.FindPlayer(steamid);
                return player != null && player.IsBanned;
            }
            return false;
        }
        bool isBanned_NonDelayed(string name, string steamid, string ip, bool update, out BanData bandata)
        {
            bool denied = false;
            bandata = null;
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                if (Native_IsBanned(steamid))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Native: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                if (PlayerDatabase_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("PlayerDatabase: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                if (Files_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Files: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (update && denied)
            {
                if (bandata != null && (bandata.ip != ip || bandata.steamid != steamid))
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, bandata.expire == 0.0 ? 0.0 : bandata.expire - LogTime(), false);
                else if (bandata == null)
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, 0.0, false);
            }
            return bandata != null;
        }

        void isBanned_Delayed(string name, string steamid, string ip, bool update)
        {
            var partialBan = new BanData("Auto Ban", steamid, name, ip, string.Empty, 0.0);
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                SQLite_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                MySQL_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                WebAPI_IsBanned(partialBan, update);
            }
        }

        ////////////////////////////////////////////////////////////
        // Banlist
        ////////////////////////////////////////////////////////////

        string TryBanlist(object source, string[] args)
        {
            int startID = 0;
            BanSystem bs;
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out startID);
            }
            switch (args[0].ToLower())
            {
                case "files":
                    bs = BanSystem.Files;
                    break;
                case "mysql":
                    bs = BanSystem.MySQL;
                    break;
                case "native":
                    bs = BanSystem.Native;
                    break;
                case "playerdatabase":
                    bs = BanSystem.PlayerDatabase;
                    break;
                case "sqlite":
                    bs = BanSystem.SQLite;
                    break;
                case "webapi":
                    bs = BanSystem.WebAPI;
                    break;
                default:
                    return GetMsg("BanlistSyntax1", source);
            }

            return Banlist(source, bs, startID);
        }

        string Banlist(object source, BanSystem bs, int startID)
        {
            switch (bs)
            {
                case BanSystem.Files:
                    return Files_Banlist(source, startID);
                case BanSystem.MySQL:
                    return MySQL_Banlist(source, startID);
                case BanSystem.Native:
                    return Native_Banlist(source, startID);
                case BanSystem.PlayerDatabase:
                    return PlayerDatabase_Banlist(source, startID);
                case BanSystem.SQLite:
                    return SQLite_Banlist(source, startID);
                case BanSystem.WebAPI:
                    return WebAPI_Banlist(source, startID);
                default:
                    return string.Empty;
            }
        }

        ////////////////////////////////////////////////////////////
        // Ban
        ////////////////////////////////////////////////////////////


        string TryBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            string name = string.Empty;
            string errorreason = string.Empty;
            ulong userID;
            double duration = 0.0;
            string reason = BanDefaultReason;
            TimeSpan duration1;
            if (args.Length > 2 && TryParseTimeSpan(args[1], out duration1))
            {
                duration = duration1.TotalSeconds;
                reason = string.Join(" ", args.Skip(2).ToArray());
            }
            else if (args.Length > 1)
            {
                reason = string.Join(" ", args.Skip(1).ToArray());
            }
            if (ipaddress.Length != 0)
            {
                return BanIP(source, ipaddress, reason, duration);
            }
            else
            {
                var foundplayers = FindPlayers(args[0], source, out errorreason);
                if (errorreason != string.Empty | errorreason.Length != 0)
                {
                    if (ulong.TryParse(args[0], out userID) && userID.IsSteamId())
                    {
                        return BanID(source, args[0], reason, duration);
                    }
                    return errorreason;
                }
                return BanPlayer(source, foundplayers[0], reason, duration);
            }
        }

        string BanIP(object source, string ip, string reason, double duration)
        {
            return PrepareBan(source, string.Empty, string.Empty, ip, reason, duration, Kick_OnBan);
        }

        string BanID(object source, string steamid, string reason, double duration)
        {
            string name = GetPlayerName(steamid);
            string ipaddress = GetPlayerIP(steamid);

            return PrepareBan(source, steamid, name, ipaddress, reason, duration, Kick_OnBan);
        }

        string BanPlayer(object source, IPlayer player, string reason, double duration)
        {
            var address = GetPlayerIP(player);

            return PrepareBan(source, player.Id, player.Name, address, reason, duration, Kick_OnBan);
        }

        string PrepareBan(object source, string userID, string name, string ip, string reason, double duration, bool kick)
        {
            var bandata = new BanData(source, userID, name, ip, reason, duration);


            return ExecuteBan(source, bandata, kick);
        }
        string ExecuteBan(object source, BanData bandata, bool kick)
        {
            Unsubscribe(nameof(OnUserBanned));
            if (wasBanned.Contains(bandata.id)) return string.Empty;

            string returnstring = null;
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteBan(bandata);
            }

            if (Ban_Broadcast)
                if (bandata.name != string.Empty | bandata.steamid != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("PlayerPermBan", null, bandata.name, bandata.reason) : GetMsg("PlayerTempBan", null, bandata.name, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));
                else if (bandata.ip != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("IPPermBan", null, bandata.reason) : GetMsg("IPTempBan", null, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));

            if (Ban_Log && (source is IPlayer) && ((IPlayer)source).Id != "server_console")
                Interface.Oxide.LogWarning(returnstring);

            if (kick)
                Kick(source, bandata.steamid != string.Empty ? bandata.steamid : bandata.ip, bandata.reason ?? "Banned", true);

            wasBanned.Add(bandata.id);
            if (Discord_use)
            {
                object payload = new[]
                {
                    new {name="Player",value=bandata.name.Length != 0 ? $"[{bandata.name}](https://steamcommunity.com/profiles/{bandata.steamid})" : bandata.steamid.Length != 0 ? $"[{bandata.steamid}](https://steamcommunity.com/profiles/{bandata.steamid})" : "An IP", inline=true},
                    new {name="Type",value=bandata.expire != 0.0 ? $"Temporarily ({FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime()))})" : "Permanently", inline=true},
                    new {name="Banned By", value=bandata.source, inline=true },
                    new {name="Reason",value=bandata.reason, inline=false}
                };
                string json = JsonConvert.SerializeObject(payload);
                DiscordMessages?.Call("API_SendFancyMessage", Discord_Webhook, "Player Ban", 3329330, json);
            }
            timer.Once(5f, () => { Subscribe(nameof(OnUserBanned)); });
            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // Unban
        ////////////////////////////////////////////////////////////

        string ExecuteUnban(object source, string steamid, string name, string ip)
        {
            string returnstring = string.Empty;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> unbanList2 = new List<BanData>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteUnban(steamid, name, ip, out unbanList);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteUnban(steamid, name, ip, out unbanList2);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteUnban(steamid, name);
            }

            foreach (var b in unbanList)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            foreach (var b in unbanList2)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            OnServerSave();
            return returnstring;
        }

        string TryUnBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            ulong userID = 0L;
            string name = string.Empty;
            string errorreason = string.Empty;

            if (ipaddress != string.Empty)
            {
                return ExecuteUnban(source, string.Empty, string.Empty, ipaddress);
            }
            else
            {
                ulong.TryParse(args[0], out userID);
                return ExecuteUnban(source, userID != 0L ? args[0] : string.Empty, userID == 0L ? args[0] : string.Empty, string.Empty);
            }
        }


        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////
        [Command("ban", "player.ban")]
        void cmdBan(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("BanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
                Puts(e.StackTrace);
            }
        }

        [Command("banlist", "player.banlist")]
        void cmdBanlist(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanlist))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || args.Length == 0)
            {
                string replystring = GetMsg("BanlistSyntax", player.Id.ToString()) + "\n";
                replystring += GetMsg("BanSystems", player.Id.ToString());
                if (BanSystemHasFlag(banSystem, BanSystem.Files))
                {
                    replystring += "Files\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
                {
                    replystring += "MySQL\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    replystring += "Native\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
                {
                    replystring += "PlayerDatabase\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
                {
                    replystring += "SQLite\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
                {
                    replystring += "WebAPI\n";
                }
                player.Reply(replystring);
                return;
            }
            try
            {
                player.Reply(TryBanlist(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("kick", "player.kick")]
        void cmdKick(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("KickSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryKick(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("unban", "player.unban")]
        void cmdUnban(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionUnban))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryUnBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }
    }
}

// --- End of file: EnhancedBanSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/external-wall-stacker ---
// --- Original File Path: E/ExternalWallStacker/ExternalWallStacker.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("External Wall Stacker", "Dana", "1.0.3")]
    [Description("Build skyscraper-like walls.")]

    public class ExternalWallStacker : RustPlugin
    {
        #region Custom Functions

        /*
         * Name: HasRunPermission
         * Parameters: BasePlayer player, string cmdPermission
         * Return: Boolean
         * Description: Checks if the user has the permission of the value of the cmdPermission variable or is an owner of the server.
         */
        private bool HasRunPermission(BasePlayer player, string cmdPermission)
        {
            // If the player is equal to null then return false.
            if (player == null)
                return false;

            // return true or false (return true if the user has the permission or is an owner of the server) (return false if the user doesn't have the permission or isn't an owner of the server).
            return permission.UserHasPermission(player.userID.ToString(), cmdPermission) || player.net?.connection?.authLevel == 2;
        }

        /*
         * Name: CreateStackWall
         * Parameters: int amount, BaseEntity entity, BasePlayer player
         * Return: HashSet<ExternalWallLink>
         * Description: Creates the high external walls that stack on top of the first high external wall.
         */
        private HashSet<ExternalWallLink> CreateStackWall(int amount, BaseEntity entity, BasePlayer player)
        {
            // If the value of amount is less than 1 then set the value of amount to 1 else set the value of amount to the value of amount.
            amount = (amount < 1) ? 1 : amount;

            // Create an emply "list" that will contain ExternalWallLink(s).
            HashSet<ExternalWallLink> links = new HashSet<ExternalWallLink>();

            // If the configuration key "RequireMaterials" is set to true.
            if (this.configRequireMaterials == true)
            {
                // Find the item's definition for the type of high external wall that is being placed.
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(entity.ShortPrefabName);

                // Count how much high external walls the user has in their inventory.
                int canPlaceAmount = player.inventory.GetAmount(itemDefinition.itemid);

                // Subtract how much high external walls the user has in their inventory by one.
                canPlaceAmount = canPlaceAmount - 1;

                // If the amount of high external walls the user has in their inventory is less than one then return an empty list of ExternalWallLink(s).
                if (canPlaceAmount < 1)
                    return links;

                // If the amount of high external walls the users has in their inventory is greater than the amount allowed to be placed then set the value of amount to the value of amount...
                // ...else set the value of amount to the value of how much high external walls the user has in their inventory.
                amount = (canPlaceAmount > amount) ? amount : canPlaceAmount;

                // Take # (based now the value of amount) of high external walls from the player.
                player.inventory.Take(new List<Item>(), itemDefinition.itemid, amount);
                // Notify the player of how much high external walls are being taken out of their inventory.
                player.Command("note.inv", itemDefinition.itemid, -amount);
            }

            // Create an emply ExternalWallLink.
            ExternalWallLink entityLink;

            BaseEntity previousWall = entity;

            // Loop until the value of index is greater than the value of amount plus one.
            for (int index = 1; index < amount + 1; index++)
            {
                // Create a high external wall.
                BaseEntity wall = GameManager.server.CreateEntity(entity.PrefabName, entity.transform.position + new Vector3(0f, 5.5f * (float)index, 0f), entity.transform.rotation, true);
                // Set the parent of the newly created wall to the previous wall
                wall.SetParent(previousWall, true, false);

                // Activate the high external wall game object.
                wall.gameObject.SetActive(true);
                // Spawn the high external wall game object.
                wall.Spawn();
                // Notify the server of the placement and rotation changes of the high external wall.
                wall.InvalidateNetworkCache();
                wall.UpdateNetworkGroup();
                wall.OnPositionalNetworkUpdate();

                // Get the BaseCombatEntity component of the high external wall.
                BaseCombatEntity combatEntity = wall.GetComponentInParent<BaseCombatEntity>();

                // If the component can be found.
                if (combatEntity != null)
                {
                    // Change the health of the high external wall to max health.
                    combatEntity.SetHealth(combatEntity.MaxHealth());
                }

                // Set the owner of the high external wall to the player.
                wall.OwnerID = player.userID;

                // Tell the server to to send a update to the players for the high external wall.
                wall.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                // Set the ExternalWallLink's game object to the high external wall's game object.
                entityLink = new ExternalWallLink(wall.gameObject);

                // Add the ExternalWallLink to the list of ExternalWallLink(s).
                links.Add(entityLink);

                // Set the newly created wall as the previous wall for the next iteration
                previousWall = wall;
            }

            // Return the list of ExternalWallLink(s).
            return links;
        }

        /*
         * Name: GetConfig
         * Parameters: string name, T value
         * Return: if it can't find the configuration then return the value of value else return the value of the configuration.
         * Description: Obtains a configuration by the name.
         */
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion

        #region MonoBehavior

        class ExternalWallLink
        {
            // Create an empty GameObject.
            GameObject gameObject;

            // Create boolean variable and set it to false.
            public bool isRemoving = false;

            /*
             * Name: ExternalWallLink
             * Parameters: GameObject go
             * Return: Nothing because it is an constructor
             * Description: Constructor for the ExternalWallLink class.
             */
            public ExternalWallLink(GameObject go)
            {
                // Set the class variable gameObject to the value of the argrument.
                this.gameObject = go;
            }

            /*
             * Name: entity
             * Parameters: None
             * Return: NULL if it can't get the BaseEntity component else return the BaseEntity component of the game object
             * Description: Constructor for the ExternalWallLink class.
             */
            public BaseEntity entity()
            {
                return (this.gameObject.GetComponent<BaseEntity>() == null) ? null : this.gameObject.GetComponent<BaseEntity>();
            }
        }

        class ExternalWallController : MonoBehaviour
        {
            // Declare an empty list of ExternalWallLink(s).
            HashSet<ExternalWallLink> links;

            /*
             * Name: Awake
             * Parameters: None
             * Return: None
             * Description: It is called when this component is added to a game object.
             */
            void Awake()
            {
                // Create an empty list of ExternalWallLink(s).
                links = new HashSet<ExternalWallLink>();
            }

            /*
             * Name: entityLinks
             * Parameters: None
             * Return: HashSet<ExternalWallLink>
             * Description: Return the list of ExternalWallLink(s).
             */
            public HashSet<ExternalWallLink> entityLinks()
            {
                // Return the value of the variable links.
                return this.links;
            }

            /*
             * Name: addLink
             * Parameters: ExternalWallLink linkEntity
             * Return: None
             * Description: Add a *new* entry to the list of ExternalWallLink(s).
             */
            public void addLink(ExternalWallLink linkEntity)
            {
                // If the variable links doesn't contain argument.
                if (this.links.Contains(linkEntity) == false)
                    // Add the ExternalWallLink to the list of ExternalWallLink(s).
                    this.links.Add(linkEntity);
            }
        }

        #endregion

        #region Initialization

        // Obtain the plugin RemoverTool.
        [PluginReference]
        Plugin RemoverTool;

        // Declare the variables that will contain the values of their respective configuration values.
        int configStackHeight;
        bool configUsePermission, configRequireMaterials;
        string pluginPermission, pluginName, pluginColor = "#FF6600";

        // Create empty list of BaseEntity(s).
        List<BaseEntity> removingEntity = new List<BaseEntity>();
        // Create empty list of player user id(s).
        HashSet<ulong> playerToggleCommand = new HashSet<ulong>();

        /*
         * Name: LoadDefaultConfig
         * Parameters: None
         * Return: None
         * Description: Called when the config for a plugin should be initialized.
         */
        protected override void LoadDefaultConfig()
        {
            Config["StackHeight"] = configStackHeight = GetConfig("StackHeight", 2);
            Config["UsePermission"] = configUsePermission = GetConfig("UsePermission", true);
            Config["RequireMaterials"] = configRequireMaterials = GetConfig("RequireMaterials", true);
            SaveConfig();
        }

        /*
         * Name: Init
         * Parameters: None
         * Return: None
         * Description: Called when a plugin is being initialized.
         */
        void Init()
        {
            // Call the function LoadDefaultConfig.
            LoadDefaultConfig();

            // Set the variable pluginPermission value to externalwallstack.wstack.
            this.pluginPermission = new StringBuilder(this.GetType().Name.ToLower()).Append(".wstack").ToString();

            // Set the leading plugin name in chat to "<color=#FF6600>[ExternalWallStack]</color> :".
            this.pluginName = new StringBuilder("<color=").Append(this.pluginColor).Append(">[").Append(this.GetType().Name).Append("]</color> : ").ToString();

            // Register messages to the plugin lang file.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NotAuthorized", "You're not the permissions to use this chat command!" },
                { "CommandToggle", "High External Wall stacking is <color={0}>{1}</color>"}

            }, this);

            // If the permission externalwallstack.wstack doesn't exist.
            if (!permission.PermissionExists(pluginPermission))
                // Register the permission externalwallstack.wstack.
                permission.RegisterPermission(pluginPermission, this);
        }

        /*
         * Name: OnServerInitialized
         * Parameters: None
         * Return: None
         * Description: Called after the server startup has been completed and is awaiting connections.
         */
        void OnServerInitialized()
        {
            // If the plugin RemoverToll can't be found.
            if (RemoverTool == null)
                // Print a warning to the server console.
                PrintWarning("RemoverTool by Reneb was not found!");
        }

        /*
         * Name: Unload
         * Parameters: None
         * Return: None
         * Description: Called when a plugin is being unloaded.
         */
        void Unload()
        {
            // Clear the list of player user id(s).
            this.playerToggleCommand.Clear();
            // Clear the list of BaseEntity(s).
            this.removingEntity.Clear();
        }

        /*
         * Name: OnPlayerDisconnected
         * Parameters: BasePlayer player, string reason
         * Return: None
         * Description: Called after the player has disconnected from the server.
         */
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            // If the list of player user id(s) contains the player's user id.
            if (this.playerToggleCommand.Contains(player.userID) == true)
                // Remove the player's user id from the list of player user id(s).
                this.playerToggleCommand.Remove(player.userID);
        }

        #endregion

        #region Hooks
        /*
         * Name: OnEntityBuilt
         * Parameters: Planner planner, GameObject gameObject
         * Return: None
         * Description: Called when any structure is built (walls, ceilings, stairs, etc.).
         */
        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            // If the argument for planner is null or the argument for gameObject is null then don't proceed any further.
            if (planner == null || gameObject == null)
                return;

            // Obtain the BaseEntity component from the game object a store it into the variable baseEntity.
            BaseEntity baseEntity = gameObject.GetComponent<BaseEntity>();

            // If the BaseEntity component was found or the planner doesn't have an owner then don't proceed any further.
            if (baseEntity == null || planner.GetOwnerPlayer() == null)
                return;

            // Obtain the owner of the planner.
            BasePlayer player = planner.GetOwnerPlayer();

            // If the entity is a High External Wall and the player has wall stacking enabled.
            if (baseEntity.ShortPrefabName.Contains("wall.external.high") == true && this.playerToggleCommand.Contains(player.userID))
            {
                // Declare empty variales.
                BaseEntity linkingEntity;
                ExternalWallController linkingExternalController;
                HashSet<ExternalWallLink> externalLinks;

                // Set the value of the variable externalLinks to the return value of the function CreateStackWall.
                externalLinks = this.CreateStackWall(this.configStackHeight, baseEntity, player);

                // If the list of ExternalWallLink(s) is not empty.
                if (externalLinks.Count > 0)
                {
                    // Create a new ExternalWallLink for the game object and store it in the variable initialExternalLink.
                    ExternalWallLink initialExternalLink = new ExternalWallLink(gameObject);
                    // Add the value of the variable initialExternalLink to the list of ExternalWallLink(s).
                    externalLinks.Add(initialExternalLink);

                    // Go through the list of ExternalWallLink(s).
                    foreach (ExternalWallLink externalLink in externalLinks)
                    {
                        // Set the value of the variable linkingEntity to the current ExternalWallLink('s) BaseEntity.
                        linkingEntity = (BaseEntity)externalLink.entity();

                        // If the BaseEntity component was found.
                        if (linkingEntity != null)
                        {
                            // Add the ExternalWallController to the current game object.
                            linkingExternalController = linkingEntity.gameObject.AddComponent<ExternalWallController>();

                            // Go through the list of ExternalWallLink(s).
                            foreach (ExternalWallLink externalAddLinkage in externalLinks)
                            {
                                // If the current link is the parent current link then continue (skip it).
                                if (externalAddLinkage == externalLink) continue;

                                // Link the other ExternalWallLink(s) to the ExternalWallController.
                                linkingExternalController.addLink(externalAddLinkage);
                            }
                        }
                    }
                }

            }

            // Set the value of the variable baseEntity to null.
            baseEntity = null;
        }

        /*
         * Name: OnRemovedEntity
         * Parameters: BaseEntity entity
         * Return: None
         * Description: Called when any structure is removed by the removal tool.
         */
        void OnRemovedEntity(BaseEntity entity)
        {
            // If the BaseEntity is null then don't proceed any further.
            if (entity == null) return;

            // If the BaseEntity is an High External Wall.
            if (entity.ShortPrefabName.Contains("wall.external.high") == true)
            {
                // If the entity is being removed.
                if (this.removingEntity.Contains(entity) == true)
                {
                    // Remove the entity from the list of BaseEntity(s).
                    this.removingEntity.Remove(entity);
                    // Don't proceed any further.
                    return;
                }
                else
                    // If the entity isn't being removed then add it to the list of BaseEntity(s).
                    this.removingEntity.Add(entity);

                // Obtain the ExternalWallController component from the BaseEntity('s) game object.
                ExternalWallController controller = entity.gameObject.GetComponent<ExternalWallController>();

                // If the ExternalWallController component wasn't found then don't proceed any further.
                if (controller == null) return;

                // Declare empty variable.
                BaseEntity linkEntity;

                // Get the owner of the BaseEntity.
                BasePlayer player = BasePlayer.Find(entity.OwnerID.ToString());

                // Go through the list of ExternalWallLink(s) in the ExternalWallController component.
                foreach (ExternalWallLink externalLink in controller.entityLinks())
                {
                    // If the ExternalWallLink isn't being removed.
                    if (externalLink.isRemoving == false)
                    {
                        // Remove the ExternalWallLink.
                        externalLink.isRemoving = true;

                        // Get the BaseEntity that owns the ExternalWallLink component.
                        linkEntity = externalLink.entity();

                        // If the BaseEntity is null then move to the next ExternalWallLink.
                        if (linkEntity == null) continue;

                        // If the player is required to use materials.
                        if (this.configRequireMaterials == true)
                        {
                            // Create the High External Wall and give it to the player.
                            Item item = ItemManager.CreateByName(entity.ShortPrefabName, 1);
                            player.inventory.GiveItem(item, null);
                            player.Command("note.inv", item.info.itemid, item.amount);
                        }

                        // Kill the BaseEntity.
                        linkEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                    }

                }
            }
        }

        /*
         * Name: OnEntityDeath
         * Parameters: BaseCombatEntity entity, HitInfo info
         * Return: None
         * Description: Called when any thing is killed.
         */
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            // If the BaseCombatEntity is null then don't proceed any further.
            if (entity == null) return;

            // If BaseCombatEntity is an High External Wall.
            if (entity.ShortPrefabName.Contains("wall.external.high") == true)
            {
                // Obtain the ExternalWallController component from the BaseCombatEntity.
                ExternalWallController controller = entity.gameObject.GetComponent<ExternalWallController>();

                // Declare an empty variable.
                ExternalWallController controllerLink;

                // If the ExternalWallController component can't be found in the BaseCombatEntity then don't proceed any further.
                if (controller == null) return;

                // Declare an empty variable.
                BaseEntity linkEntity;

                // Go through the list of ExternalWallLink(s) in the ExternalWallController component.
                foreach (ExternalWallLink externalLink in controller.entityLinks())
                {
                    // Get the BaseEntity that owns the ExternalWallLink component.
                    linkEntity = externalLink.entity();

                    // If the BaseEntity is null then move to the next ExternalWallLink.
                    if (linkEntity == null) continue;

                    // Obtain the ExternalWallController component from the current BaseEntity
                    controllerLink = linkEntity.gameObject.GetComponent<ExternalWallController>();

                    // If the ExternalWallController component couldn't be found then move to the next ExternalWallLink.
                    if (controllerLink == null) continue;

                    // Sever link between the BaseCombatEntity and the current BaseEntity.
                    controllerLink.entityLinks().RemoveWhere(link => link.entity() == null || link.entity().gameObject == entity.gameObject);
                }
            }

        }

        #endregion

        #region Chat Commands

        /*
         * Name: cmdWStack
         * Parameters: BasePlayer player, string command, string[] args
         * Return: None
         * Description: Called when a player type /wstack in chat.
         */
        [ChatCommand("wstack"), Permission("externalwallstack.wstack")]
        private void cmdWStack(BasePlayer player, string command, string[] args)
        {
            // If the player can't be found then don't proceed any further.
            if (player == null)
                return;

            // If the user doesn't have the permission externalwallstack.wstack and the configuration requires the user to have the permission externalwallstack.wstack.
            if (this.HasRunPermission(player, this.pluginPermission) == false && this.configUsePermission == true)
            {
                // Notify the player that they don't have the permission to run this chat command.
                PrintToChat(player, lang.GetMessage("NotAuthorized", this, null));

                // Don't proceed any further.
                return;
            }

            // If the list of player user id(s) contains the player's user id that is running this command.
            if (this.playerToggleCommand.Contains(player.userID) == true)
            {
                //  Notify the player that they have High External Wall stacking OFF.
                PrintToChat(player, new StringBuilder(this.pluginName).AppendFormat(lang.GetMessage("CommandToggle", this, null), "#CC0000", "OFF").ToString());

                // Remove the player's user id from the list of player user id(s).
                this.playerToggleCommand.Remove(player.userID);

                // Don't proceed any further.
                return;
            }

            // Add the player's user id to the list of player user id(s).
            this.playerToggleCommand.Add(player.userID);

            //  Notify the player that they have High External Wall stacking ON.
            PrintToChat(player, new StringBuilder(this.pluginName).AppendFormat(lang.GetMessage("CommandToggle", this, null), "#2C6700", "ON").ToString());
        }

        #endregion
    }
}

// --- End of file: ExternalWallStacker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-data ---
// --- Original File Path: E/EntityData/EntityData.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Entity Data", "Orange", "1.0.3")]
    [Description("Saving specified information about player-owned entities")]
    public class EntityData : RustPlugin
    {
        #region Vars

        private class OEntity
        {
            public ulong ownerID;
            public double spawnTime;
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            LoadData();
        }

        private void Unload()
        {
            SaveData();
        }
        
        private void OnNewSave()
        {
            SaveData();
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
           CheckEntity(entity);
        }

        private void OnEntityKill(BaseEntity entity)
        {
            CheckEntity(entity);
        }

        #endregion

        #region Helpers
        
        private void CheckEntity(BaseEntity entity)
        {
            var owner = entity.OwnerID;
            
            if (!owner.IsSteamId())
            {
                return;
            }
            
            var id = entity.net.ID;

            if (entities.ContainsKey(id))
            {
                entities.Remove(id);
            }
            else
            {
                entities.Add(id, new OEntity{ownerID = entity.OwnerID, spawnTime = Now()});
            }
        }
        
        private double Now()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }

        private int Passed(double a)
        {
            return Convert.ToInt32(Now() - a);
        }

        #endregion
        
        #region Data
        
        private Dictionary<uint, OEntity> entities = new Dictionary<uint, OEntity>();

        private const string filename = "EntityData";

        private void LoadData()
        {
            try
            {
                entities = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, OEntity>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(150f, SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, entities);
        }

        #endregion

        #region API

        private int API_GetLifeDuration(uint netID)
        {
            if (!entities.ContainsKey(netID))
            {
                return 0;
            }

            var spawnTime = entities[netID].spawnTime;

            return Passed(spawnTime);
        }

        private double API_GetSpawnTime(uint netID)
        {
            if (!entities.ContainsKey(netID))
            {
                return 0;
            }

            return entities[netID].spawnTime;
        }

        private ulong API_GetOwner(uint netID)
        {
            if (!entities.ContainsKey(netID))
            {
                return 0;
            }

            return entities[netID].ownerID;
        }

        #endregion
    }
}

// --- End of file: EntityData.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/endless-cargo ---
// --- Original File Path: E/EndlessCargo/EndlessCargo.cs ---

﻿
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Endless Cargo", "OG61", "1.1.1")]
    [Description("Calls new cargo ship into game as soon as one departs.")]
    public class EndlessCargo : CovalencePlugin
    {
      
        #region Config
        const string cargoPrefab = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        const int MaxShips = 1;
        private const string perm = "endlesscargo.admin";
        readonly System.Random random = new System.Random();

        private class PluginConfig
        { 
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate = 5f;

            [JsonProperty(PropertyName = "How far off shore to spawn ship in grid blocks 1-10 (Default 5)")]
            public int GridBlocksOffShore = 5;

            [JsonProperty(PropertyName = "NPC spawn on ship (Default true)")]
            public bool NpcSpawn = true;
            
            [JsonProperty(PropertyName = "Egress duration in minutes (Default 10)")]
            public int EgressMin = 10;

            [JsonProperty(PropertyName = "Event duration in minutes (Default 50)")]
            public int DurationMin = 50;

            [JsonProperty(PropertyName = "Loot round spacing in minutes (Default 10)")]
            public int LootSpacing = 10;

            [JsonProperty(PropertyName = "Loot rounds 1-3 (Default 3)")]
            public int LootRounds = 3;

            [JsonProperty(PropertyName = "Enable Log file (true/false)")]
            public bool LogToFile = true;

            [JsonProperty(PropertyName = "Log output to console (true/false)")]
            public bool LogToConsole = true;
        }

        private PluginConfig _config;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch (Exception e)
            {
                LoadDefaultConfig();
                LogError(e.Message);
            }
            /* Check for more than 3 loot rounds. Setting loot rounds to more than 3 will work but the ships horn
             * will sound everytime the loot round timer triggers and an index out of bounds error will 
             * print to console. This appears to be a bug in the game. 
             */
            if (_config.LootRounds > 3) _config.LootRounds = 3;

            if (_config.GridBlocksOffShore > 10 || _config.GridBlocksOffShore < 1) _config.GridBlocksOffShore = 5;  // set to default if outside reasonible range
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new PluginConfig();

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion //Config

        #region Data
        private List<CargoShip> _activeCargoShips = new List<CargoShip>();
        #endregion //Data

        #region uMod Hooks

        private void OnServerInitialized()
        {
            NextTick(() =>
            {
                _activeCargoShips = UnityEngine.Object.FindObjectsOfType<CargoShip>().ToList();
                CheckCargoShip();
            });

            timer.Every(_config.UpdateRate, CheckCargoShip);

            //ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "cargoship.event_enabled false");
            //Setting cargoship.event_enabled to false does not disable the event. For now just kill the new ship
            server.Command($"cargoship.egress_duration_minutes {_config.EgressMin}");
            server.Command($"ai.npc_spawn_on_cargo_ship {_config.NpcSpawn}");
            server.Command($"cargoship.event_duration_minutes {_config.DurationMin}");
            server.Command($"cargoship.loot_round_spacing_minutes {_config.LootSpacing}");
            server.Command($"cargoship.loot_rounds {_config.LootRounds}");
        }
       
        private void OnEntitySpawned(CargoShip ship)
        {  
            if (_activeCargoShips.Count >= MaxShips) 
            {   // This should never execute if the default event is turned off but it does.
                ship.Kill();
                 Logger("NormalGameCall") ;
                return;
            }
            NextTick(() =>
            {
                 _activeCargoShips.Add(ship);
                CheckCargoShip();
            });
        }




        #endregion //Oxide Hooks  

        #region Helpers

        private string GetLang(string key, string id = "", params object[] args)
        {
           return string.Format(lang.GetMessage(key, this, id), args);
        }


        private void Logger(string key, IPlayer player = null, params object[] args)
        {
            string s = GetLang(key, player != null ? player.Id : "",args);
            string ps = "";
            if (player !=null) ps = $"{player.Name} ({player.Id}) ";
            s =  $"[{DateTime.Now}] {ps} {s}";
            if (_config.LogToFile) LogToFile("CargoControl", s, this);
            if (_config.LogToConsole) Log(s);
        }
      
        private void Message(string key, IPlayer player, params object[] args)
        { 
           player.Reply(GetLang(key, player.Id, args));
        }

        private void CheckCargoShip()
        {
            _activeCargoShips.RemoveAll(p => !p.IsValid() || !p.gameObject.activeInHierarchy || p.HasFlag(BaseEntity.Flags.Reserved8));
            if (_activeCargoShips.Count < MaxShips) SpawnCargo(); 
        }

        private void SpawnCargo()
        {

            var worldSize = (ConVar.Server.worldsize);
            var gridWidth = (worldSize * 0.0066666666666667f);
            float step = worldSize / gridWidth;
            int steps = (int)(((worldSize / step) / 2) + _config.GridBlocksOffShore);

            float posX;
            float posZ;
            float rotation;
            var ranXZ = random.Next(-100, 100); //Randomly choose if we are randomizing x or Z 
            var ranPN = random.Next(-100, 100); //Randomly choose if we are positive x or z or negative x or z
            ranPN = ranPN > 0 ? 1 : -1;
            if (ranXZ > 0)
            {
                posX = random.Next(-steps, steps) * step;
                posZ = steps * step * ranPN; //Z will be on the edge of map randomly north or south
                rotation = posZ > 0 ? 180 : 0; //Rotate ship to point toward land
            }
            else
            {
                posX = steps * step * ranPN; //X will be on the edge of map randomly east or west
                posZ = random.Next(-steps, steps) * step;
                rotation = posX > 0 ? 270 : 90; //Rotate ship to point toward land
            }
            Vector3 position = new Vector3(posX, 0f, posZ);
            Quaternion myTransform = new Quaternion();
            Vector3 rot = myTransform.eulerAngles;
            rot = new Vector3(rot.x, rot.y + rotation, rot.z);
            myTransform = Quaternion.Euler(rot);
            CargoShip cargo = (CargoShip)GameManager.server.CreateEntity(cargoPrefab, position, myTransform);
            if (cargo != null)
            {
                cargo.Spawn();
                Logger("ShipSpawned", null, position.x, position.z);
            }
            else
            {
                Logger("ShipSpawnError");
            }

        }     
        
        
        #endregion //Helpers

        #region Commands
    [Command("KillCargo"), Permission(perm)]
        private void KillCargo(IPlayer player)
        {
            if (_activeCargoShips.Count > 0)
            {


                foreach (var c in _activeCargoShips)
                {
                    c.Kill();
                }
                Logger("KillCargo", player);
            }
            else Logger("NoActiveShips");
        }
        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NormalGameCall"] = "Normal cargo event triggered. Ship killed.",
                ["KillcargoRcon"] = "Killcargo issued from RCon",
                ["NoActiveShips"] = "Killcargo command issued but no active ships",
                ["KillCargo"] = "Killcargo command executed",
                ["ShipSpawned"] = "Cargo ship spawned at X={0}  Z={1}",
                ["ConfigError"] = "Error reading config file. Defaut configuration used.",
                ["ShipSpawnError"] = "Cargo ship spawn error. Spawn failed."
            }, this) ;
        }
        #endregion
    }
}


// --- End of file: EndlessCargo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosive-rounds ---
// --- Original File Path: E/ExplosiveRounds/ExplosiveRounds.cs ---

﻿using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ExplosiveRounds", "redBDGR", "1.0.1")]
    [Description("Give explosive bullets impact explosions")]
    internal class ExplosiveRounds : RustPlugin
    {
        private const string permissionName = "explosiverounds.use";
        private List<object> ammotypes;
        private bool Changed;

        /*
         *   [ BEANCAN ]                 assets/prefabs/weapons/beancan grenade/effects/beancan_grenade_explosion.prefab
         *   [ GRENADE EXPLOSION ]       assets/prefabs/weapons/f1 grenade/effects/f1grenade_explosion.prefab
         *   [ SATCHEL CHARGE ]          assets/prefabs/weapons/satchelcharge/effects/satchel-charge-explosion.prefab
         *   [ C4 EXPLOSION ]            assets/prefabs/tools/c4/effects/c4_explosion.prefab
         *   [ HELI EXPLOSION ]          assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab
         *   [ WATER ]                   assets/prefabs/weapons/waterbucket/effects/waterimpact_explosion.prefab
         *   [ SURVEY CHARGE ]           assets/bundled/prefabs/fx/survey_explosion.prefab
         */

        public string explosioneffectuse = "assets/prefabs/weapons/beancan grenade/effects/beancan_grenade_explosion.prefab";

        private static List<object> AmmoTypes()
        {
            var at = new List<object> {"ammo.rifle.explosive"};
            return at;
        }

        private void Init()
        {
            permission.RegisterPermission(permissionName, this);
            LoadVariables();
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            explosioneffectuse = Convert.ToString(GetConfig("Settings", "Explosion Effect", "assets/prefabs/weapons/beancan grenade/effects/beancan_grenade_explosion.prefab"));
            ammotypes = (List<object>) GetConfig("Settings", "Ammo Types", AmmoTypes());

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private void OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
                return;
            if (ammotypes.Contains(info.Weapon.GetEntity().GetComponent<BaseProjectile>()?.primaryMagazine.ammoType.shortname))
                Effect.server.Run(explosioneffectuse, info.HitPositionWorld);
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
    }
}

// --- End of file: ExplosiveRounds.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-reducer ---
// --- Original File Path: E/EntityReducer/EntityReducer.cs ---

using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Reducer", "Arainrr", "2.1.4")]
    [Description("Controls all spawn populations on the server")]
    public class EntityReducer : RustPlugin
    {
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            if (SpawnHandler.Instance == null || SpawnHandler.Instance.AllSpawnPopulations == null)
            {
                PrintError("The SpawnHandler is missing on your server, the plugin cannot be used");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            UpdateConfig();
            if (configData.pluginEnabled)
            {
                ApplySpawnHandler();
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private void UpdateConfig()
        {
            var newPopulationSettings = new Dictionary<string, PopulationSetting>();
            for (int i = 0; i < SpawnHandler.Instance.AllSpawnPopulations.Length; i++)
            {
                var spawnPopulation = SpawnHandler.Instance.AllSpawnPopulations[i];
                if (spawnPopulation == null) continue;
                var spawnDistribution = SpawnHandler.Instance.SpawnDistributions[i];
                if (spawnDistribution == null) continue;
                int targetCount = spawnPopulation.GetTargetCount(spawnDistribution);
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting))
                {
                    if (!populationSetting.enabled)
                    {
                        populationSetting.targetCount = targetCount;
                    }
                    newPopulationSettings.Add(spawnPopulation.name, populationSetting);
                }
                else
                {
                    newPopulationSettings.Add(spawnPopulation.name, new PopulationSetting { targetCount = targetCount });
                }
            }
            configData.populationSettings = newPopulationSettings;
            SaveConfig();
        }

        private void ApplySpawnHandler()
        {
            foreach (var spawnPopulationBase in SpawnHandler.Instance.AllSpawnPopulations)
            {
                var spawnPopulation = spawnPopulationBase as DensitySpawnPopulation;
                if (spawnPopulation == null) continue;
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting) && populationSetting.enabled)
                {
                    float num = TerrainMeta.Size.x * TerrainMeta.Size.z;
                    if (!spawnPopulation.ScaleWithLargeMaps)
                    {
                        num = Mathf.Min(num, 1.6E+07f);
                    }
                    var densityToMaxPopulation = num * 1E-06f * Spawn.max_density;
                    spawnPopulation.ScaleWithSpawnFilter = false;
                    spawnPopulation.ScaleWithServerPopulation = false;
                    spawnPopulation.EnforcePopulationLimits = true;
                    spawnPopulation.ScaleWithLargeMaps = true;
                    var targetDensity = populationSetting.targetCount / densityToMaxPopulation;
                    var convarControlledSpawnPopulation = spawnPopulation as ConvarControlledSpawnPopulation;
                    if (convarControlledSpawnPopulation != null)
                    {
                        ConsoleSystem.Command command = ConsoleSystem.Index.Server.Find(convarControlledSpawnPopulation.PopulationConvar);
                        command?.Set(targetDensity);
                    }
                    else spawnPopulation._targetDensity = targetDensity;
                }
            }
            SpawnHandler.Instance.EnforceLimits(true);
        }

        public string GetReport()
        {
            SpawnPopulationBase[] allSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnDistribution[] spawnDistributions = SpawnHandler.Instance.SpawnDistributions;
            StringBuilder stringBuilder = new StringBuilder();
            if (allSpawnPopulations == null) stringBuilder.AppendLine("Spawn population array is null.");
            if (spawnDistributions == null) stringBuilder.AppendLine("Spawn distribution array is null.");
            if (allSpawnPopulations != null && spawnDistributions != null)
            {
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("SpawnPopulationName".PadRight(40) + "CurrentPopulation".PadRight(25) + "MaximumPopulation");
                for (int i = 0; i < allSpawnPopulations.Length; i++)
                {
                    var spawnPopulation = allSpawnPopulations[i];
                    if (spawnPopulation == null) continue;
                    var spawnDistribution = spawnDistributions[i];
                    if (spawnDistribution == null) continue;
                    int currentCount = spawnDistribution.Count;
                    int targetCount = spawnPopulation.GetTargetCount(spawnDistribution);
                    stringBuilder.AppendLine(spawnPopulation.name.PadRight(40) + currentCount.ToString().PadRight(25) + targetCount);
                }
            }
            return stringBuilder.ToString();
        }

        #endregion Methods

        #region Commands

        [ConsoleCommand("er.fillpopulations")]
        private void CmdFillPopulations(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.FillPopulations();
            SendReply(arg, "Successfully filled all populations");
        }

        [ConsoleCommand("er.getreport")]
        private void CmdGetReport(ConsoleSystem.Arg arg) => SendReply(arg, GetReport());

        [ConsoleCommand("er.enforcelimits")]
        private void CmdEnforceLimits(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.EnforceLimits(true);
            SendReply(arg, "Successfully enforced all population limits");
        }

        #endregion Commands

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enabled Plugin")]
            public bool pluginEnabled = false;

            [JsonProperty(PropertyName = "Population Settings")]
            public Dictionary<string, PopulationSetting> populationSettings = new Dictionary<string, PopulationSetting>();
        }

        private class PopulationSetting
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = true;

            [JsonProperty(PropertyName = "Target Count")]
            public int targetCount;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion Configuration
    }
}


// --- End of file: EntityReducer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extended-disconnect-info ---
// --- Original File Path: E/ExtendedDisconnectInfo/ExtendedDisconnectInfo.cs ---

using Rust;
using System;
using Network;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Extended Disconnect Info", "Strrobez", "2.0.2")]
    [Description("Extends the disconnect reasons with more information upon reconnecting.")]
    public class ExtendedDisconnectInfo : RustPlugin
    {
        #region Declaration
        private readonly Dictionary<ulong, string> CachedPlayers = new Dictionary<ulong, string>();
        private int CachedServerProtocol;
        #endregion

        #region Config
        private static Configuration _config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Log All Disconnect Messages")]
            public bool LogAllDisconnects;
            [JsonProperty(PropertyName = "Show Ban Reason on Reconnect? (if false, shows message in language file)")]
            public bool ShowBanReason;
            [JsonProperty(PropertyName = "Cache Removal Interval")]
            public float CacheRemovalInterval;
            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    LogAllDisconnects = true,
                    ShowBanReason = false,
                    CacheRemovalInterval = 30f
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();

                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Hooks
        private void Init()
        {
            CachedServerProtocol = Protocol.network;
            CachedPlayers.Clear();
        }

        private object CanClientLogin(Connection connection)
        {
            if (connection.protocol > CachedServerProtocol)
                return lang.GetMessage("Server Wrong Version", this);

            if (connection.protocol < CachedServerProtocol)
                return lang.GetMessage("Client Wrong Version", this);

            timer.Once(_config.CacheRemovalInterval, () => CachedPlayers.Remove(connection.userid));

            return CachedPlayers.ContainsKey(connection.userid)
                ? CachedPlayers[connection.userid]
                : null;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_config.LogAllDisconnects)
                Puts($"{1} {0} was disconnected from the server. Reason: {2}", player.displayName,
                    player.UserIDString, reason);

            if (reason.Contains("World File Mismatch"))
                CachedPlayers.Add(player.userID, lang.GetMessage("World File Mismatch", this));
        }

        private void OnPlayerBanned(ulong userID, string reason)
        {
            if (!_config.ShowBanReason)
                CachedPlayers.Add(userID, lang.GetMessage("Banned", this));
        }

        #endregion

        #region Language
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["World Map Mismatch"] = "Delete all files in C:\\Program Files (x86)\\Steam\\steamapps\\common\\Rust\\maps and reconnect.",
                ["Server Wrong Version"] = "Server has not yet been updated to the latest Rust server update. Contact the Admins.",
                ["Client Wrong Version"] = "Please update your Rust client to the latest version.",
                ["Banned"] = "Banned: Appeal @ noobgaming.com"
            }, this);
        }
        #endregion
    }
}

// --- End of file: ExtendedDisconnectInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-spawn ---
// --- Original File Path: E/EntitySpawn/EntitySpawn.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Entity Spawn", "Wolfleader101", "1.0.0")]
	[Description("Throw a projectile and find a surprise!")]
	class EntitySpawn : RustPlugin
	{
		#region Variables
		private struct spawnItemConfig
		{
			public List<string> prefabs { get; set; }
			public bool enabled { get; set; }
			public bool random { get; set; }
			public string permission { get; set; }
		}

		private PluginConfig config;

		#endregion

		#region Hooks
		private void Init()
		{
			config = Config.ReadObject<PluginConfig>();

			permission.RegisterPermission("entityspawn.use", this);

			foreach (var item in config.NewItem.Values)
			{
				if (!string.IsNullOrEmpty(item.permission))
				{
					permission.RegisterPermission(item.permission, this);
				}
			}
		}

		void OnPlayerAttack(BasePlayer attacker, HitInfo info)
		{
			if (info.IsProjectile())
			{
				string EntName = info.ProjectilePrefab.name;
				foreach (var item in config.NewItem)
				{
					string projectileName = item.Key + ".projectile";

					if (!string.IsNullOrEmpty(item.Value.permission))
					{
						SpawnChecks(item.Value.permission, projectileName, EntName, item, attacker, info);
					}
					else
					{
						SpawnChecks("entityspawn.use", projectileName, EntName, item, attacker, info);
					}
				}
			}
		}
		#endregion

		#region Custom Methods

		void SpawnChecks(string perm, string projectileName, string EntName, KeyValuePair<string, spawnItemConfig> item, BasePlayer attacker, HitInfo info)
		{
			if (permission.UserHasPermission(attacker.UserIDString, perm))
			{
				if (EntName == projectileName && item.Value.enabled)
				{
					string PrefabAsset;

					if (item.Value.random)
					{
						System.Random random = new System.Random();
						int i = random.Next(0, item.Value.prefabs.Count);
						PrefabAsset = item.Value.prefabs[i];
					}
					else
					{
						PrefabAsset = item.Value.prefabs[0];
					}
					SpawnIn(attacker, info, PrefabAsset);
				}
			}
		}
		void SpawnIn(BasePlayer attacker, HitInfo info, string PrefName)
		{
			Vector3 EntLoc = info.HitPositionWorld;
			Quaternion playerRotQuat = attacker.GetNetworkRotation();
			float playerRotY = playerRotQuat.eulerAngles.y;


			BaseEntity NewEntity = GameManager.server.CreateEntity(PrefName, EntLoc, new Quaternion());
			NewEntity.ServerRotation = Quaternion.Euler(0, playerRotY, 0);
			NewEntity.Spawn();
			info.ProjectilePrefab.remainInWorld = false;
		}

		#endregion

		#region Config

		private class PluginConfig
		{
			[JsonProperty("Spawns")]
			public Dictionary<string, spawnItemConfig> NewItem { get; set; }
		}

		private PluginConfig GetDefaultConfig()
		{
			return new PluginConfig
			{
				NewItem = new Dictionary<string, spawnItemConfig>()
				{
					{
						"snowball",
						new spawnItemConfig {
							prefabs = new List<string>() {"assets/prefabs/npc/scientist/htn/scientist_full_any.prefab"},
							enabled = false,
							random = false,
							permission = "snowball.spawn"
						}
					}
				}
			};
		}

		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}
		#endregion
	}
}

// --- End of file: EntitySpawn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/event-tips-remover ---
// --- Original File Path: E/EventTipsRemover/EventTipsRemover.cs ---

using System.Collections.Generic;
using System.Collections;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Event Tips Remover", "Razor", "1.0.4")]
    [Description("Remove new GameTip messages.")]
    public class EventTipsRemover : RustPlugin
    {
        List<PuzzleReset> puzzleReset = new List<PuzzleReset>();
        List<TriggeredEventPrefab> _triggeredEventPrefab = new List<TriggeredEventPrefab>();

        #region Init
        private void OnServerInitialized()
        {
            //This Was The Only Way To Find PuzzleReset as no hooks available currenty in DoReset()
            foreach (var GateToRemove in GameObject.FindObjectsOfType<PuzzleReset>())
            {
                if (GateToRemove.broadcastResetMessage)
                {
                    GateToRemove.broadcastResetMessage = false;
                    puzzleReset.Add(GateToRemove);
                }
            }
        }

        private void Unload()
        {
            foreach (var GateToRemove in puzzleReset)
            {
                if (GateToRemove != null)
                    GateToRemove.broadcastResetMessage = true;
            }

            foreach (var GateToRemove in _triggeredEventPrefab)
            {
                if (GateToRemove != null)
                    GateToRemove.shouldBroadcastSpawn = true;
            }
        }
        #endregion

        #region Hooks
        private void OnEventTrigger(TriggeredEventPrefab eventTrig)
        {
            if (eventTrig.shouldBroadcastSpawn)
            {
                if (!_triggeredEventPrefab.Contains(eventTrig))
                    _triggeredEventPrefab.Add(eventTrig);
                eventTrig.shouldBroadcastSpawn = false;
            }
        }

        private object OnExcavatorResourceSet(ExcavatorArm arm, string str, BasePlayer player)
        {
            if (str == "HQM")
                arm.resourceMiningIndex = 0;
            else if (str == "Sulfur")
                arm.resourceMiningIndex = 1;
            else if (str == "Stone")
                arm.resourceMiningIndex = 2;
            else if (str == "Metal")
                arm.resourceMiningIndex = 3;
            if (arm.IsOn())
                return null;
            BeginMining(arm);

            return false;
        }

        public void BeginMining(ExcavatorArm arm)
        {
            if (!arm.IsPowered())
                return;
            arm.SetFlag(BaseEntity.Flags.On, true);
            arm.InvokeRepeating(new Action(arm.ProduceResources), arm.resourceProductionTickRate, arm.resourceProductionTickRate);

            ExcavatorServerEffects.SetMining(true);
            Interface.CallHook("OnExcavatorMiningToggled", (object)arm);
        }
        #endregion

    }
}
    


// --- End of file: EventTipsRemover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/electric-taser ---
// --- Original File Path: E/ElectricTaser/ElectricTaser.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Electric Taser", "ZockiRR", "2.0.5")]
    [Description("Gives players the ability to spawn a taser")]
    class ElectricTaser : CovalencePlugin
    {

        #region Variables
        private const string PERMISSION_GIVETASER = "electrictaser.givetaser";
        private const string PERMISSION_REMOVEALLTASERS = "electrictaser.removealltasers";
        private const string PERMISSION_TASENPC = "electrictaser.tasenpc";
        private const string PERMISSION_USETASER = "electrictaser.usetaser";

        private const string I18N_NO_PLAYER_FOR_NAME = "NoPlayerForName";
        private const string I18N_MULTIPLE_PLAYERS_FOR_NAME = "MultiplePlayersForName";
        private const string I18N_GAVE_TASER_TO = "GaveTaserTo";
        private const string I18N_GAVE_TASER_TO_YOU = "GaveTaserToYou";
        private const string I18N_COULD_NOT_SPAWN = "CouldNotSpawn";
        private const string I18N_TASER = "Taser";
        private const string I18N_PLAYERS_ONLY = "PlayersOnly";
        private const string I18N_CANNOT_MOVE_ITEM = "CannotMoveItem";
        private const string I18N_NOT_ALLOWED_TO_USE = "NotAllowedToUse";
        private const string I18N_REMOVED_ALL_TASERS = "RemovedAllTasers";

        #endregion Variables

        #region Data
        private class DataContainer
        {
            // Set Nailgun.net.ID
            public HashSet<ulong> NailgunIDs = new HashSet<ulong>();
        }
        #endregion Data

        #region Configuration
        private Configuration config;

        private class Configuration
        {
            [JsonProperty("TaserCooldown")]
            public float TaserCooldown = 5f;

            [JsonProperty("TaserDistance")]
            public float TaserDistance = 8f;

            [JsonProperty("TaserShockDuration")]
            public float TaserShockDuration = 20f;

            [JsonProperty("TaserDamage")]
            public float TaserDamage = 0f;

            [JsonProperty("NoUsePermissionDamage")]
            public float NoUsePermissionDamage = 20f;

            [JsonProperty("InstantKillsNPCs")]
            public bool InstantKillsNPCs = false;

            [JsonProperty("NPCBeltLocked")]
            public bool NPCBeltLocked = true;

            [JsonProperty("NPCWearLocked")]
            public bool NPCWearLocked = true;

            [JsonProperty("ItemNailgun")]
            public string ItemNailgun = "pistol.nailgun";

            [JsonProperty("PrefabScream")]
            public string PrefabScream = "assets/bundled/prefabs/fx/player/gutshot_scream.prefab";

            [JsonProperty("PrefabShock")]
            public string PrefabShock = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [I18N_NO_PLAYER_FOR_NAME] = "No players found with name or ID '{0}'",
                [I18N_MULTIPLE_PLAYERS_FOR_NAME] = "Multiple players were found, please specify: {0}",
                [I18N_GAVE_TASER_TO] = "Gave taser to {0}",
                [I18N_GAVE_TASER_TO_YOU] = "Gave taser to you",
                [I18N_COULD_NOT_SPAWN] = "Could not spawn a taser",
                [I18N_TASER] = "Taser",
                [I18N_PLAYERS_ONLY] = "Command '{0}' can only be used by a player",
                [I18N_CANNOT_MOVE_ITEM] = "Cannot move item!",
                [I18N_NOT_ALLOWED_TO_USE] = "You can't use the taser!",
                [I18N_REMOVED_ALL_TASERS] = "Removed all tasers from the server"
            }, this);
        }
        #endregion localization

        #region commands
        [Command("givetaser", "givetazer"), Permission(PERMISSION_GIVETASER)]
        private void GiveTaser(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            IPlayer thePlayer = someArgs.Length > 0 ? FindPlayer(someArgs[0], aPlayer) : aPlayer;
            if (thePlayer == null)
            {
                return;
            }
            if (thePlayer.IsServer)
            {
                Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
                return;
            }
            BasePlayer thePlayerEntity = thePlayer.Object as BasePlayer;
            if (!thePlayerEntity)
            {
                return;
            }
            Item theItem = GiveItemToPlayer(thePlayerEntity, config.ItemNailgun);
            if (theItem == null)
            {
                Message(aPlayer, I18N_COULD_NOT_SPAWN);
                return;
            }
            EnableTaserBehaviour(theItem.GetHeldEntity().GetComponent<BaseProjectile>());
            if (thePlayer == aPlayer)
            {
                Message(aPlayer, I18N_GAVE_TASER_TO_YOU);
            }
            else
            {
                Message(aPlayer, I18N_GAVE_TASER_TO, thePlayer.Name);
            }
        }

        [Command("removealltasers", "removealltazers"), Permission(PERMISSION_REMOVEALLTASERS)]
        private void RemoveAllTasers(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            foreach (DroppedItem eachItem in BaseNetworkable.serverEntities.OfType<DroppedItem>())
            {
                Item theItem = eachItem.GetItem();
                if (theItem.GetHeldEntity()?.GetComponent<TaserController>())
                {
                    theItem.Remove();
                }
            }

            foreach (BaseProjectile eachProjectile in BaseNetworkable.serverEntities.OfType<BaseProjectile>())
            {
                if (eachProjectile.GetComponent<TaserController>())
                {
                    eachProjectile.GetItem()?.Remove();
                    if (!eachProjectile.IsDestroyed)
                    {
                        eachProjectile.Kill();
                    }
                }
            }

            Message(aPlayer, I18N_REMOVED_ALL_TASERS);
        }
        #endregion commands

        #region hooks
        private void Unload()
        {
            OnServerSave();

            foreach (BaseProjectile eachProjectile in BaseNetworkable.serverEntities.OfType<BaseProjectile>())
            {
                if (eachProjectile.GetComponent<TaserController>())
                {
                    DisableTaserBehaviour(eachProjectile);
                }
            }

            foreach (BasePlayer eachPlayer in BaseNetworkable.serverEntities.OfType<BasePlayer>())
            {
                ShockedController theController = eachPlayer.GetComponent<ShockedController>();
                if (theController)
                {
                    UnityEngine.Object.Destroy(theController);
                }
            }
        }

        private void OnServerSave()
        {
            DataContainer thePersistentData = new DataContainer();
            foreach (BaseProjectile eachTaser in BaseNetworkable.serverEntities.OfType<BaseProjectile>())
            {
                TaserController theController = eachTaser.GetComponent<TaserController>();
                if (theController)
                {
                    thePersistentData.NailgunIDs.Add(eachTaser.net.ID.Value);
                }
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, thePersistentData);
        }

        private void OnServerInitialized(bool anInitialFlag)
        {
            permission.RegisterPermission(PERMISSION_TASENPC, this);
            permission.RegisterPermission(PERMISSION_USETASER, this);

            // Readd Behaviour
            DataContainer thePersistentData = Interface.Oxide.DataFileSystem.ReadObject<DataContainer>(Name);
            foreach (ulong eachNailgunID in thePersistentData.NailgunIDs)
            {
                BaseProjectile theTaser = BaseNetworkable.serverEntities.Find(new NetworkableId(eachNailgunID))?.GetComponent<BaseProjectile>();
                if (theTaser)
                {
                    EnableTaserBehaviour(theTaser);
                }
            }
        }

        private void OnWeaponFired(BaseProjectile aProjectile, BasePlayer aPlayer, ItemModProjectile aMod, ProtoBuf.ProjectileShoot aProjectileProtoBuf)
        {
            TaserController theController = aProjectile.GetComponent<TaserController>();
            if (theController)
            {
                theController.ResetTaser();
                if (!permission.UserHasPermission(aPlayer.UserIDString, PERMISSION_USETASER))
                {
                    Effect.server.Run(config.PrefabShock, aProjectile, StringPool.Get(aProjectile.MuzzleTransform.name), aProjectile.MuzzleTransform.localPosition, Vector3.zero);
                    aPlayer.OnAttacked(new HitInfo(aPlayer, aPlayer, DamageType.ElectricShock, config.NoUsePermissionDamage, aPlayer.transform.position + aPlayer.transform.forward * 1f));
                    Message(aPlayer, I18N_NOT_ALLOWED_TO_USE);
                }
            }
        }

        private object CanCreateWorldProjectile(HitInfo anInfo, ItemDefinition anItemDefinition)
        {
            if (anInfo.Weapon.GetComponent<TaserController>())
            {
                return false;
            }
            return null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity anEntity, HitInfo aHitInfo)
        {
            if (!aHitInfo?.Weapon?.GetComponent<TaserController>())
            {
                return null;
            }

            aHitInfo.damageTypes.Clear();
            aHitInfo.DoHitEffects = false;
            aHitInfo.DoDecals = false;

            if (aHitInfo.InitiatorPlayer && !permission.UserHasPermission(aHitInfo.InitiatorPlayer.UserIDString, PERMISSION_USETASER))
            {
                return true;
            }

            float theDistance = !aHitInfo.IsProjectile() ? Vector3.Distance(aHitInfo.PointStart, aHitInfo.HitPositionWorld) : aHitInfo.ProjectileDistance;
            if (config.TaserDistance > 0f && theDistance > config.TaserDistance)
            {
                aHitInfo.DidHit = false;
                return true;
            }
            Effect.server.Run(config.PrefabShock, anEntity, aHitInfo.HitBone, aHitInfo.HitPositionLocal, aHitInfo.HitNormalLocal);
            aHitInfo.damageTypes.Add(DamageType.ElectricShock, config.TaserDamage);
            BasePlayer thePlayer = anEntity?.GetComponent<BasePlayer>();
            if (thePlayer)
            {
                if (thePlayer.IsNpc)
                {
                    if (aHitInfo.InitiatorPlayer && !permission.UserHasPermission(aHitInfo.InitiatorPlayer.UserIDString, PERMISSION_TASENPC))
                    {
                        return null;
                    }

                    if (config.InstantKillsNPCs)
                    {
                        thePlayer.Die(aHitInfo);
                        return null;
                    }

                    if (config.NPCBeltLocked)
                    {
                        thePlayer.inventory.containerBelt.SetLocked(true);
                    }
                    if (config.NPCWearLocked)
                    {
                        thePlayer.inventory.containerWear.SetLocked(true);
                    }
                }

                ShockedController theController = thePlayer.GetComponent<ShockedController>();
                if (!theController)
                {
                    theController = thePlayer.gameObject.AddComponent<ShockedController>();
                    theController.Config = config;
                }
                NextFrame(() => theController.Shock(aHitInfo));
            }
            return null;
        }

        private object CanMoveItem(Item anItem, PlayerInventory aPlayerLoot, uint aTargetContainer, int aTargetSlot, int anAmount)
        {
            if (anItem.GetRootContainer()?.IsLocked() ?? false && (anItem.GetOwnerPlayer()?.GetComponent<ShockedController>()?.IsShocked ?? false))
            {
                Message(aPlayerLoot.GetComponentInParent<BasePlayer>(), I18N_CANNOT_MOVE_ITEM);
                return ItemContainer.CanAcceptResult.CannotAccept;
            }
            return null;
        }

        private object OnPlayerRecover(BasePlayer aPlayer)
        {
            ShockedController theController = aPlayer.GetComponent<ShockedController>();
            if (theController)
            {
                if (aPlayer.IsNpc)
                {
                    if (aPlayer.inventory.containerBelt.IsLocked())
                    {
                        aPlayer.inventory.containerBelt.SetLocked(false);
                    }
                    if (aPlayer.inventory.containerWear.IsLocked())
                    {
                        aPlayer.inventory.containerWear.SetLocked(false);
                    }
                }
                theController.IsShocked = false;
            }
            return null;
        }

        private void OnItemDropped(Item anItem, BaseEntity aWorldEntity)
        {
            if (anItem.GetHeldEntity()?.GetComponent<TaserController>())
            {
                anItem.name = null;
            }
        }

        private object OnItemPickup(Item anItem, BasePlayer aPlayer)
        {
            if (anItem.GetHeldEntity()?.GetComponent<TaserController>())
            {
                anItem.name = GetText(I18N_TASER, aPlayer.UserIDString);
            }
            return null;
        }
        #endregion hooks

        #region methods
        private Item GiveItemToPlayer(BasePlayer aPlayer, string anItemName)
        {
            Item theItem = ItemManager.Create(ItemManager.FindItemDefinition(anItemName.ToLower()));
            if (theItem == null)
            {
                return null;
            }
            if (!aPlayer.inventory.GiveItem(theItem))
            {
                theItem.Remove();
                return null;
            }
            return theItem;
        }

        private void EnableTaserBehaviour(BaseProjectile aBaseProjectile)
        {
            Item theItem = aBaseProjectile.GetItem();
            if (theItem != null)
            {
                theItem.name = GetText(I18N_TASER, theItem.GetOwnerPlayer()?.UserIDString);
            }
            aBaseProjectile.canUnloadAmmo = false;
            aBaseProjectile.primaryMagazine.contents = 1;
            aBaseProjectile.primaryMagazine.capacity = 0;
            TaserController theController = aBaseProjectile.GetComponent<TaserController>();
            if (theController)
            {
                UnityEngine.Object.Destroy(theController);
            }
            aBaseProjectile.gameObject.AddComponent<TaserController>().Config = config;
            aBaseProjectile.SendNetworkUpdateImmediate();
        }

        private void DisableTaserBehaviour(BaseProjectile aBaseProjectile)
        {
            Item theItem = aBaseProjectile.GetItem();
            if (theItem != null)
            {
                theItem.name = null;
            }
            aBaseProjectile.canUnloadAmmo = true;
            aBaseProjectile.primaryMagazine.contents = 0;
            aBaseProjectile.primaryMagazine.capacity = 16;
            TaserController theController = aBaseProjectile.GetComponent<TaserController>();
            if (theController)
            {
                UnityEngine.Object.Destroy(theController);
            }
            aBaseProjectile.SendNetworkUpdateImmediate();
        }
        #endregion methods

        #region helpers
        private IPlayer FindPlayer(string aPlayerNameOrId, IPlayer aPlayer)
        {
            IPlayer[] theFoundPlayers = players.FindPlayers(aPlayerNameOrId).ToArray();
            if (theFoundPlayers.Length > 1)
            {
                Message(aPlayer, I18N_MULTIPLE_PLAYERS_FOR_NAME, string.Join(", ", theFoundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer theFoundPlayer = theFoundPlayers.Length == 1 ? theFoundPlayers[0] : null;
            if (theFoundPlayer == null)
            {
                Message(aPlayer, I18N_NO_PLAYER_FOR_NAME, aPlayerNameOrId);
                return null;
            }

            return theFoundPlayer;
        }

        private string GetText(string aKey, string aPlayerId = null, params object[] someArgs) => string.Format(lang.GetMessage(aKey, this, aPlayerId), someArgs);

        private void Message(IPlayer aPlayer, string anI18nKey, params object[] someArgs)
        {
            if (aPlayer.IsConnected)
            {
                string theText = GetText(anI18nKey, aPlayer.Id, someArgs);
                aPlayer.Reply(theText != anI18nKey ? theText : anI18nKey);
            }
        }

        private void Message(BasePlayer aPlayer, string anI18nKey, params object[] someArgs)
        {
            if (aPlayer.IsConnected)
            {
                string theText = GetText(anI18nKey, aPlayer.UserIDString, someArgs);
                aPlayer.ChatMessage(theText != anI18nKey ? theText : anI18nKey);
            }
        }
        #endregion helpers

        #region controllers
        private class TaserController : FacepunchBehaviour
        {
            public Configuration Config { get; set; }
            private BaseProjectile Taser
            {
                get
                {
                    if (taser == null)
                    {
                        taser = GetComponent<BaseProjectile>();
                    }
                    return taser;
                }
            }

            private BaseProjectile taser;

            public void ResetTaser()
            {
                Invoke(() =>
                {
                    Taser.primaryMagazine.contents = 1;
                    Taser.SendNetworkUpdateImmediate();
                }, Config.TaserCooldown);
            }
        }

        private class ShockedController : FacepunchBehaviour
        {
            public Configuration Config { get; set; }
            public bool IsShocked { get; set; }
            private BasePlayer Player
            {
                get
                {
                    if (player == null)
                    {
                        player = GetComponent<BasePlayer>();
                    }
                    return player;
                }
            }

            private BasePlayer player;

            public void Shock(HitInfo aHitInfo)
            {
                Effect.server.Run(Config.PrefabScream, Player.transform.position);
                if (!Player.IsSleeping())
                {
                    IsShocked = true;
                    float theHealth = Player.health;
                    Player.GoToIncapacitated(aHitInfo);
                    Player.health = theHealth;
                    Player.woundedDuration = Config.TaserShockDuration + 5f;
                    CancelInvoke(StopWounded);
                    Invoke(StopWounded, Config.TaserShockDuration);
                }
            }

            private void StopWounded()
            {
                if (Player.IsWounded())
                {
                    Player.StopWounded();
                }
            }
        }
        #endregion controllers
    }
}


// --- End of file: ElectricTaser.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/easy-broadcast ---
// --- Original File Path: E/EasyBroadcast/EasyBroadcast.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Easy Broadcast", "LaserHydra", "2.1.0", ResourceId = 863)]
    [Description("Broadcast a message to the server")]
    class EasyBroadcast : RustPlugin
    {
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("broadcast.use", this);

            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Display", "<color=blue>{title}</color>: {message}");
            SetConfig("Title", "Server");

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ChatCommand("bcast")]
        void cmdBroadcast(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "broadcast.use"))
            {
                SendChatMessage(player, "Broadcast", "You have no permission to use this command!");
                return;
            }
            if (args.Length < 1)
            {
                SendChatMessage(player, "Broadcast", "Syntax: /bcast <message>");
            }

            string message = Config["Display"] as string;
            message = message.Replace("{title}", Config["Title"] as string).Replace("{message}", ListToString(args.ToList(), 0, " "));

            BroadcastChat(message);
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: EasyBroadcast.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/exclusive-looter ---
// --- Original File Path: E/ExclusiveLooter/ExclusiveLooter.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ExclusiveLooter", "redBDGR", "1.0.0")]
    [Description("Allow only one player to loot an entity at a time")]

    class ExclusiveLooter : RustPlugin
    {
        private bool Changed;
        private const string permissionNameEXEMPT = "exclusivelooter.exempt";

        private Dictionary<BaseEntity, string> containerDic = new Dictionary<BaseEntity, string>();

        private List<object> entityBlacklist = new List<object>();
        static List<object> entityBlacklistGet()
        {
            var eb = new List<object>();
            eb.Add("woodbox_deployed");
            eb.Add("refinery_small_deployed");
            return eb;
        }

        #region Config

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            entityBlacklist = (List<object>)GetConfig("Settings", "Entity Blacklist", entityBlacklistGet());

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permissionNameEXEMPT, this);
            LoadVariables();

            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["Not Allowed"] = "You are not allowed to loot this object because someone else is already looting it!",
            }, this);
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionNameEXEMPT))
                return;
            if (entityBlacklist.Contains(entity.ShortPrefabName))
                return;
            StorageContainer container = entity.GetComponent<StorageContainer>();
            if (container)
                if (!container.IsLocked())
                    NextTick(() => container.SetFlag(BaseEntity.Flags.Locked, true));
        }

        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (permission.UserHasPermission(player.UserIDString, permissionNameEXEMPT))
                return;
            if (entityBlacklist.Contains(entity.ShortPrefabName))
                return;
            StorageContainer container = entity.GetComponent<StorageContainer>();
            if (container)
                if (container.IsLocked())
                    NextTick(() => container.SetFlag(BaseEntity.Flags.Locked, false));
        }

        #endregion

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: ExclusiveLooter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/economics ---
// --- Original File Path: E/Economics/Economics.cs ---

﻿//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

// TODO: Add SQLite and MySQL database support

namespace Oxide.Plugins
{
    [Info("Economics", "Wulf", "3.9.2")]
    [Description("Basic economics system and economy API")]
    public class Economics : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Allow negative balance for accounts")]
            public bool AllowNegativeBalance = false;

            [JsonProperty("Balance limit for accounts (0 to disable)")]
            public int BalanceLimit = 0;

            [JsonProperty("Maximum balance for accounts (0 to disable)")] // TODO: From version 3.8.6; remove eventually
            private int BalanceLimitOld { set { BalanceLimit = value; } }

            [JsonProperty("Negative balance limit for accounts (0 to disable)")]
            public int NegativeBalanceLimit = 0;

            [JsonProperty("Remove unused accounts")]
            public bool RemoveUnused = true;

            [JsonProperty("Log transactions to file")]
            public bool LogTransactions = false;

            [JsonProperty("Starting account balance (0 or higher)")]
            public int StartingBalance = 1000;

            [JsonProperty("Starting money amount (0 or higher)")] // TODO: From version 3.8.6; remove eventually
            private int StartingBalanceOld { set { StartingBalance = value; } }

            [JsonProperty("Wipe balances on new save file")]
            public bool WipeOnNewSave = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Stored Data

        private DynamicConfigFile data;
        private StoredData storedData;
        private bool changed;

        private class StoredData
        {
            public readonly Dictionary<string, double> Balances = new Dictionary<string, double>();
        }

        private void SaveData()
        {
            if (changed)
            {
                Puts("Saving balances for players...");
                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            }
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion Stored Data

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandBalance"] = "balance",
                ["CommandDeposit"] = "deposit",
                ["CommandSetBalance"] = "SetBalance",
                ["CommandTransfer"] = "transfer",
                ["CommandWithdraw"] = "withdraw",
                ["CommandWipe"] = "ecowipe",
                ["DataSaved"] = "Economics data saved!",
                ["DataWiped"] = "Economics data wiped!",
                ["DepositedToAll"] = "Deposited {0:C} total ({1:C} each) to {2} player(s)",
                ["LogDeposit"] = "{0:C} deposited to {1}",
                ["LogSetBalance"] = "{0:C} set as balance for {1}",
                ["LogTransfer"] = "{0:C} transferred to {1} from {2}",
                ["LogWithdrawl"] = "{0:C} withdrawn from {1}",
                ["NegativeBalance"] = "Balance can not be negative!",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["PlayerBalance"] = "Balance for {0}: {1:C}",
                ["PlayerLacksMoney"] = "'{0}' does not have enough money!",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["ReceivedFrom"] = "You have received {0} from {1}",
                ["SetBalanceForAll"] = "Balance set to {0:C} for {1} player(s)",
                ["TransactionFailed"] = "Transaction failed! Make sure amount is above 0",
                ["TransferredTo"] = "{0} transferred to {1}",
                ["TransferredToAll"] = "Transferred {0:C} total ({1:C} each) to {2} player(s)",
                ["TransferToSelf"] = "You can not transfer money yourself!",
                ["UsageBalance"] = "{0} - check your balance",
                ["UsageBalanceOthers"] = "{0} <player name or id> - check balance of a player",
                ["UsageDeposit"] = "{0} <player name or id> <amount> - deposit amount to player",
                ["UsageSetBalance"] = "Usage: {0} <player name or id> <amount> - set balance for player",
                ["UsageTransfer"] = "Usage: {0} <player name or id> <amount> - transfer money to player",
                ["UsageWithdraw"] = "Usage: {0} <player name or id> <amount> - withdraw money from player",
                ["UsageWipe"] = "Usage: {0} - wipe all economics data",
                ["YouLackMoney"] = "You do not have enough money!",
                ["YouLostMoney"] = "You lost: {0:C}",
                ["YouReceivedMoney"] = "You received: {0:C}",
                ["YourBalance"] = "Your balance is: {0:C}",
                ["WithdrawnForAll"] = "Withdrew {0:C} total ({1:C} each) from {2} player(s)",
                ["ZeroAmount"] = "Amount cannot be zero"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permissionBalance = "economics.balance";
        private const string permissionDeposit = "economics.deposit";
        private const string permissionDepositAll = "economics.depositall";
        private const string permissionSetBalance = "economics.setbalance";
        private const string permissionSetBalanceAll = "economics.setbalanceall";
        private const string permissionTransfer = "economics.transfer";
        private const string permissionTransferAll = "economics.transferall";
        private const string permissionWithdraw = "economics.withdraw";
        private const string permissionWithdrawAll = "economics.withdrawall";
        private const string permissionWipe = "economics.wipe";

        private void Init()
        {
            // Register universal chat/console commands
            AddLocalizedCommand(nameof(CommandBalance));
            AddLocalizedCommand(nameof(CommandDeposit));
            AddLocalizedCommand(nameof(CommandSetBalance));
            AddLocalizedCommand(nameof(CommandTransfer));
            AddLocalizedCommand(nameof(CommandWithdraw));
            AddLocalizedCommand(nameof(CommandWipe));

            // Register permissions for commands
            permission.RegisterPermission(permissionBalance, this);
            permission.RegisterPermission(permissionDeposit, this);
            permission.RegisterPermission(permissionDepositAll, this);
            permission.RegisterPermission(permissionSetBalance, this);
            permission.RegisterPermission(permissionSetBalanceAll, this);
            permission.RegisterPermission(permissionTransfer, this);
            permission.RegisterPermission(permissionTransferAll, this);
            permission.RegisterPermission(permissionWithdraw, this);
            permission.RegisterPermission(permissionWithdrawAll, this);
            permission.RegisterPermission(permissionWipe, this);

            // Load existing data and migrate old data format
            data = Interface.Oxide.DataFileSystem.GetFile(Name);
            try
            {
                Dictionary<ulong, double> temp = data.ReadObject<Dictionary<ulong, double>>();
                try
                {
                    storedData = new StoredData();
                    foreach (KeyValuePair<ulong, double> old in temp)
                    {
                        if (!storedData.Balances.ContainsKey(old.Key.ToString()))
                        {
                            storedData.Balances.Add(old.Key.ToString(), old.Value);
                        }
                    }
                    changed = true;
                }
                catch
                {
                    // Ignored
                }
            }
            catch
            {
                storedData = data.ReadObject<StoredData>();
                changed = true;
            }

            List<string> playerData = new List<string>(storedData.Balances.Keys);

            // Check for and set any balances over maximum allowed
            if (config.BalanceLimit > 0)
            {
                foreach (string p in playerData)
                {
                    if (storedData.Balances[p] > config.BalanceLimit)
                    {
                        storedData.Balances[p] = config.BalanceLimit;
                        changed = true;
                    }
                }
            }

            // Check for and remove any inactive player balance data
            if (config.RemoveUnused)
            {
                foreach (string p in playerData)
                {
                    if (storedData.Balances[p].Equals(config.StartingBalance))
                    {
                        storedData.Balances.Remove(p);
                        changed = true;
                    }
                }
            }
        }

        private void OnNewSave()
        {
            if (config.WipeOnNewSave)
            {
                storedData.Balances.Clear();
                changed = true;
                Interface.Call("OnEconomicsDataWiped");
            }
        }

        #endregion Initialization

        #region API Methods

        private double Balance(string playerId)
        {
            if (string.IsNullOrEmpty(playerId))
            {
                LogWarning("Balance method called without a valid player ID");
                return 0.0;
            }

            double playerData;
            return storedData.Balances.TryGetValue(playerId, out playerData) ? playerData : config.StartingBalance;
        }
        
        private double Balance(object playerId) => Balance(GetUserId(playerId));
        
        private string GetUserId(object playerId)
        {
            if (playerId is ulong)
            {
                return playerId.ToString();
            }
            
            // Support Rusts BasePlayer.userID type
            string userId = playerId.ToString();
            if (string.IsNullOrEmpty(userId) || !userId.IsSteamId())
            {
                throw new ArgumentException( "Invalid player ID, playerId must be a valid SteamID of type ulong or string" );
            }

            return userId;
        }
        
        private bool Deposit(string playerId, double amount)
        {
            if (string.IsNullOrEmpty(playerId))
            {
                LogWarning("Deposit method called without a valid player ID");
                return false;
            }

            if (amount > 0 && SetBalance(playerId, amount + Balance(playerId)))
            {
                Interface.Call("OnEconomicsDeposit", playerId, amount);

                if (config.LogTransactions)
                {
                    LogToFile("transactions", $"[{DateTime.Now}] {GetLang("LogDeposit", null, amount, playerId)}", this);
                }

                return true;
            }

            return false;
        }

        private bool Deposit(object playerId, double amount) => Deposit(GetUserId(playerId), amount);

        private bool SetBalance(string playerId, double amount)
        {
            if (string.IsNullOrEmpty(playerId))
            {
                LogWarning("SetBalance method called without a valid player ID");
                return false;
            }

            if (amount >= 0 || config.AllowNegativeBalance)
            {
                amount = Math.Round(amount, 2);
                if (config.BalanceLimit > 0 && amount > config.BalanceLimit)
                {
                    amount = config.BalanceLimit;
                }
                else if (config.AllowNegativeBalance && config.NegativeBalanceLimit < 0 && amount < config.NegativeBalanceLimit)
                {
                    amount = config.NegativeBalanceLimit;
                }

                storedData.Balances[playerId] = amount;
                changed = true;

                Interface.Call("OnEconomicsBalanceUpdated", playerId, amount);
                Interface.CallDeprecatedHook("OnBalanceChanged", "OnEconomicsBalanceUpdated", new System.DateTime(2022, 7, 1), playerId, amount);

                if (config.LogTransactions)
                {
                    LogToFile("transactions", $"[{DateTime.Now}] {GetLang("LogSetBalance", null, amount, playerId)}", this);
                }

                return true;
            }

            return false;
        }

        private bool SetBalance(object playerId, double amount) => SetBalance(GetUserId(playerId), amount);

        private bool Transfer(string playerId, string targetId, double amount)
        {
            if (string.IsNullOrEmpty(playerId))
            {
                LogWarning("Transfer method called without a valid player ID");
                return false;
            }

            if (Withdraw(playerId, amount) && Deposit(targetId, amount))
            {
                Interface.Call("OnEconomicsTransfer", playerId, targetId, amount);

                if (config.LogTransactions)
                {
                    LogToFile("transactions", $"[{DateTime.Now}] {GetLang("LogTransfer", null, amount, targetId, playerId)}", this);
                }

                return true;
            }

            return false;
        }

        private bool Transfer(object playerId, ulong targetId, double amount)
        {
            return Transfer(GetUserId(playerId), targetId.ToString(), amount);
        }

        private bool Withdraw(string playerId, double amount)
        {
            if (string.IsNullOrEmpty(playerId))
            {
                LogWarning("Withdraw method called without a valid player ID");
                return false;
            }

            if (amount >= 0 || config.AllowNegativeBalance)
            {
                double balance = Balance(playerId);
                if ((balance >= amount || (config.AllowNegativeBalance && balance + amount > config.NegativeBalanceLimit)) && SetBalance(playerId, balance - amount))
                {
                    Interface.Call("OnEconomicsWithdrawl", playerId, amount);

                    if (config.LogTransactions)
                    {
                        LogToFile("transactions", $"[{DateTime.Now}] {GetLang("LogWithdrawl", null, amount, playerId)}", this);
                    }

                    return true;
                }
            }

            return false;
        }

        private bool Withdraw(object playerId, double amount) => Withdraw(GetUserId(playerId), amount);

        #endregion API Methods

        #region Commands

        #region Balance Command

        private void CommandBalance(IPlayer player, string command, string[] args)
        {
            if (args != null && args.Length > 0)
            {
                if (!player.HasPermission(permissionBalance))
                {
                    Message(player, "NotAllowed", command);
                    return;
                }

                IPlayer target = FindPlayer(args[0], player);
                if (target == null)
                {
                    Message(player, "UsageBalance", command);
                    return;
                }

                Message(player, "PlayerBalance", target.Name, Balance(target.Id));
                return;
            }

            if (player.IsServer)
            {
                Message(player, "UsageBalanceOthers", command);
            }
            else
            {
                Message(player, "YourBalance", Balance(player.Id));
            }
        }

        #endregion Balance Command

        #region Deposit Command

        private void CommandDeposit(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionDeposit))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 1)
            {
                Message(player, "UsageDeposit", command);
                return;
            }

            double amount;
            double.TryParse(args[1], out amount);
            if (amount <= 0)
            {
                Message(player, "ZeroAmount");
                return;
            }

            if (args[0] == "*")
            {
                if (!player.HasPermission(permissionDepositAll))
                {
                    Message(player, "NotAllowed", command);
                    return;
                }

                int receivers = 0;
                foreach (string targetId in storedData.Balances.Keys.ToList())
                {
                    if (Deposit(targetId, amount))
                    {
                        receivers++;
                    }
                }
                Message(player, "DepositedToAll", amount * receivers, amount, receivers);
            }
            else
            {
                IPlayer target = FindPlayer(args[0], player);
                if (target == null)
                {
                    return;
                }

                if (Deposit(target.Id, amount))
                {
                    Message(player, "PlayerBalance", target.Name, Balance(target.Id));
                }
                else
                {
                    Message(player, "TransactionFailed", target.Name);
                }
            }
        }

        #endregion Deposit Command

        #region Set Balance Command

        private void CommandSetBalance(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionSetBalance))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 1)
            {
                Message(player, "UsageSetBalance", command);
                return;
            }

            double amount;
            double.TryParse(args[1], out amount);

            if (amount < 0)
            {
                Message(player, "NegativeBalance");
                return;
            }

            if (args[0] == "*")
            {
                if (!player.HasPermission(permissionSetBalanceAll))
                {
                    Message(player, "NotAllowed", command);
                    return;
                }

                int receivers = 0;
                foreach (string targetId in storedData.Balances.Keys.ToList())
                {
                    if (SetBalance(targetId, amount))
                    {
                        receivers++;
                    }
                }
                Message(player, "SetBalanceForAll", amount, receivers);
            }
            else
            {
                IPlayer target = FindPlayer(args[0], player);
                if (target == null)
                {
                    return;
                }

                if (SetBalance(target.Id, amount))
                {
                    Message(player, "PlayerBalance", target.Name, Balance(target.Id));
                }
                else
                {
                    Message(player, "TransactionFailed", target.Name);
                }
            }
        }

        #endregion Set Balance Command

        #region Transfer Command

        private void CommandTransfer(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionTransfer))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 1)
            {
                Message(player, "UsageTransfer", command);
                return;
            }

            double amount;
            double.TryParse(args[1], out amount);

            if (amount <= 0)
            {
                Message(player, "ZeroAmount");
                return;
            }

            if (args[0] == "*")
            {
                if (!player.HasPermission(permissionTransferAll))
                {
                    Message(player, "NotAllowed", command);
                    return;
                }

                if (!Withdraw(player.Id, amount))
                {
                    Message(player, "YouLackMoney");
                    return;
                }

                int receivers = players.Connected.Count();
                double splitAmount = amount /= receivers;

                foreach (IPlayer target in players.Connected)
                {
                    if (Deposit(target.Id, splitAmount))
                    {
                        if (target.IsConnected)
                        {
                            Message(target, "ReceivedFrom", splitAmount, player.Name);
                        }
                    }
                }
                Message(player, "TransferedToAll", amount, splitAmount, receivers);
            }
            else
            {
                IPlayer target = FindPlayer(args[0], player);
                if (target == null)
                {
                    return;
                }

                if (target.Equals(player))
                {
                    Message(player, "TransferToSelf");
                    return;
                }

                if (!Withdraw(player.Id, amount))
                {
                    Message(player, "YouLackMoney");
                    return;
                }

                if (Deposit(target.Id, amount))
                {
                    Message(player, "TransferredTo", amount, target.Name);
                    Message(target, "ReceivedFrom", amount, player.Name);
                }
                else
                {
                    Message(player, "TransactionFailed", target.Name);
                }
            }
        }

        #endregion Transfer Command

        #region Withdraw Command

        private void CommandWithdraw(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionWithdraw))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (args == null || args.Length <= 1)
            {
                Message(player, "UsageWithdraw", command);
                return;
            }

            double amount;
            double.TryParse(args[1], out amount);

            if (amount <= 0)
            {
                Message(player, "ZeroAmount");
                return;
            }

            if (args[0] == "*")
            {
                if (!player.HasPermission(permissionWithdrawAll))
                {
                    Message(player, "NotAllowed", command);
                    return;
                }

                int receivers = 0;
                foreach (string targetId in storedData.Balances.Keys.ToList())
                {
                    if (Withdraw(targetId, amount))
                    {
                        receivers++;
                    }
                }
                Message(player, "WithdrawnForAll", amount * receivers, amount, receivers);
            }
            else
            {
                IPlayer target = FindPlayer(args[0], player);
                if (target == null)
                {
                    return;
                }

                if (Withdraw(target.Id, amount))
                {
                    Message(player, "PlayerBalance", target.Name, Balance(target.Id));
                }
                else
                {
                    Message(player, "YouLackMoney", target.Name);
                }
            }
        }

        #endregion Withdraw Command

        #region Wipe Command

        private void CommandWipe(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permissionWipe))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            storedData = new StoredData();
            changed = true;
            SaveData();

            Message(player, "DataWiped");
            Interface.Call("OnEconomicsDataWiped", player);
        }

        #endregion Wipe Command

        #endregion Commands

        #region Helpers

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        #endregion Helpers
    }
}

#region Extension Methods

namespace Oxide.Plugins.EconomicsExtensionMethods
{
    public static class ExtensionMethods
    {
        public static T Clamp<T>(this T val, T min, T max) where T : IComparable<T>
        {
            if (val.CompareTo(min) < 0)
            {
                return min;
            }
            else if (val.CompareTo(max) > 0)
            {
                return max;
            }
            else
            {
                return val;
            }
        }
    }
}

#endregion Extension Methods


// --- End of file: Economics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-limit ---
// --- Original File Path: E/EntityLimit/EntityLimit.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Limit", "Orange/The Friendly Chap", "2.1.5")]
    [Description("Limit entities per player or building")]
    public class EntityLimit : RustPlugin
    {
        #region Vars
        
        private Coroutine lookup;

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            foreach (var value in config.permissions)
            {
                if (string.IsNullOrEmpty(value.permission) == false && permission.PermissionExists(value.permission) == false)
                {
                    permission.RegisterPermission(value.permission, this);
                }
            }

            foreach (var command in config.commands)
            {
                cmd.AddChatCommand(command, this, nameof(cmdControlChat));
            }

            cmd.AddConsoleCommand("elimit.debug", this, nameof(cmdControlConsole));
            timer.Every(Core.Random.Range(config.cacheTime, config.cacheTime + 60), () => { cachePermission.Clear(); });
        }
        
        private void OnServerInitialized()
        {
            timer.Once(3f, () =>
            {
                PrintWarning("Organizing data for plugin, it can take a while, expect small lag");
                CheckAllEntities();
            });
        }

        private void Unload()
        {
            if (lookup != null)
            {
                ServerMgr.Instance.StopCoroutine(lookup);
            }
        }

        private object CanBuild(Planner planner, Construction entity, Construction.Target target)
        {
            return CheckBuild(planner.GetOwnerPlayer(), entity.fullName);
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            CheckLifeState(entity, false);
        }

        private void OnEntityKill(BaseEntity entity)
        {
            CheckLifeState(entity, true);
        }

        #endregion

        #region Commands

        private void cmdControlConsole(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                Interface.Oxide.DataFileSystem.WriteObject("entitylimit_debug", Data);
                SendReply(arg, "Done, check data");
            }
        }

        [ChatCommand("testmessage")]
        private void TestMessage(BasePlayer player)
        {
            SendMessage(player, MessageType.LimitsList, "{global}" + "{building}");
        }

        private void cmdControlChat(BasePlayer player)
        {
            var perm = GetPermissionFromPlayerID(player.UserIDString, config.permissions);
            if (perm == null)
            {
                return;
            }

            var limitsBuilding = perm.limitsBuilding.Clone();
            var limitsGlobal = perm.limitsGlobal.Clone();
            
            var buildingEntities = player.GetBuildingPrivilege()?.GetBuilding()?.decayEntities;
            if (buildingEntities != null)
            {
                foreach (var entity in buildingEntities)
                {
                    if (entity.IsValid() == false)
                    {
                        continue;
                    }
                    
                    if (limitsBuilding.ContainsKey(entity.ShortPrefabName) == true)
                    {
                        limitsBuilding[entity.ShortPrefabName]--;
                    }
                }
            }

            var globalEntities = Data.Get(player, false)?.entities?.SelectMany(x => x.list);
            if (globalEntities != null)
            {
                foreach (var entity in globalEntities)
                {
                    if (entity.IsValid() == false)
                    {
                        continue;
                    }
                
                    if (limitsGlobal.ContainsKey(entity.ShortPrefabName) == true)
                    {
                        limitsGlobal[entity.ShortPrefabName]--;
                    }
                }
            }

            var text1 = string.Empty;
            var text2 = string.Empty;

            foreach (var pair in limitsGlobal)
            {
                text1 += pair.Key + " x" + pair.Value + "\n";
            }
            
            foreach (var pair in limitsBuilding)
            {
                text2 += pair.Key + " x" + pair.Value + "\n";
            }
            
            SendMessage(player, MessageType.LimitsList, "{global}", text1, "{building}", text2);
        }

        #endregion

        #region Core

        private object CheckBuild(BasePlayer player, string fullName)
        {
            var perm = GetPermissionFromPlayerID(player.UserIDString, config.permissions);
            if (perm == null)
            {
                return null;
            }

            var shortname = GetShortname(fullName);
            var cupboard = player.GetBuildingPrivilege();
            var limit = 0;
            var exists = 0;
            var left = 0;
            
            if (cupboard != null) // Check for building limits
            {
                var pair = perm.limitsBuilding.FirstOrDefault(x => SameName(x.Key, shortname, fullName));
                limit = pair.Value;
                if (limit > 0)
                {
                    var entities = player.GetBuildingPrivilege()?.GetBuilding()?.decayEntities;
                    if (entities != null)
                    {
                        exists = pair.Key == "*" ? entities.Count : entities.Count(x => x.IsValid() && x.PrefabName == fullName);
                       
                        left = limit - exists;
                        if (left < 1)
                        {
                            SendMessage(player, MessageType.LimitBuilding, 
                                "{name}", shortname, 
                                "{used}", exists, 
                                "{left}", left, 
                                "{limit}", limit);
                            return true;
                        }
                        else
                        {
                            if (exists % config.warnCount == 0 || left < config.warnCount)
                            {
                                SendMessage(player, MessageType.LimitBuildingWarning, 
                                    "{name}", shortname, 
                                    "{used}", exists + 1, 
                                    "{left}", left - 1, 
                                    "{limit}", limit);
                            }
                        }
                    }
                }
            }
            
            // Check for global limits
            var pairGlobal = perm.limitsGlobal.FirstOrDefault(x => SameName(x.Key, shortname, fullName));
            limit = pairGlobal.Value;
            if (limit > 0)
            {
                var data = Data.Get(player.UserIDString, false);
                if (data == null)
                {
                    return null;
                }

                if (pairGlobal.Key == "*")
                {
                    exists = data.entities.Sum(x => x.count);
                }
                else
                {
                    var entitiesGlobal = data.entities.FirstOrDefault(x => x.prefab == fullName);
                    if (entitiesGlobal == null)
                    {
                        return null;
                    }

                    exists = entitiesGlobal.count;
                }
                
                left = limit - exists;
                if (left < 1)
                {
                    SendMessage(player, MessageType.LimitGlobal, 
                        "{name}", shortname, 
                        "{used}", exists, 
                        "{left}", left, 
                        "{limit}", limit);
                    return true;
                }
                else
                {
                    if (exists % config.warnCount == 0 || left < config.warnCount)
                    {
                        SendMessage(player, MessageType.LimitGlobalWarning, 
                            "{name}", shortname, 
                            "{used}", exists + 1, 
                            "{left}", left - 1, 
                            "{limit}", limit);
                    }
                }
            }
            
            return null;
        }

        private void CheckLifeState(BaseEntity entity, bool dying)
        {
            if (entity.OwnerID.IsSteamId() == false)
            {
                return;
            }

            var owner = entity.OwnerID;
            var prefab = entity.PrefabName;
            
            NextTick(() =>
            {
                if (dying == false && entity.IsValid() == false)
                {
                    return;
                }

                var data = Data.Get(owner, dying == false);
                if (data == null)
                {
                    if (dying == true)
                    {
                        return;
                    }
                        
                    data = new DataEntry();
                    Data.Set(owner, data);
                }

                var eData = data.entities.FirstOrDefault(x => x.prefab == prefab);
                if (eData == null)
                {
                    if (dying == true)
                    {
                        return;
                    }
                        
                    eData = new EntityData();
                    eData.prefab = prefab;
                    data.entities.Add(eData);
                }
                
                if (dying == true)
                {
                    eData.list.Remove(entity);
                }
                else
                {
                    eData.list.Add(entity);
                }
            });
        }

        private static string GetShortname(string original)
        {
            var index = original.LastIndexOf("/", StringComparison.Ordinal) + 1;
            var name = original.Substring(index);
            return name.Replace(".prefab", string.Empty);
        }

        private static bool SameName(string original, string name1, string name2)
        {
            return 
                original == "*" ||
                string.Equals(original, name1, StringComparison.OrdinalIgnoreCase) ||
                   string.Equals(original, name2, StringComparison.OrdinalIgnoreCase);
        }

        private void CheckAllEntities()
        {
            if (lookup == null)
            {
                lookup = ServerMgr.Instance.StartCoroutine(LookupEntities());
            }
        }

        private IEnumerator LookupEntities()
        {
            yield return new WaitForEndOfFrame();
            var entities = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
            yield return new WaitForSecondsRealtime(1);
            var total = entities.Length;
            
            for (var i = 0; i < entities.Length; i++)
            {
                var entity = entities[i];
                if (entity.IsValid() == false || entity.OwnerID.IsSteamId() == false)
                {
                    continue;
                }

                var pData = Data.Get(entity.OwnerID, true);
                var eData = pData.entities.FirstOrDefault(x => x.prefab == entity.PrefabName);
                if (eData == null)
                {
                    eData = new EntityData();
                    eData.prefab = entity.PrefabName;
                    pData.entities.Add(eData);
                }

                eData.list.Add(entity);

                if (i > 0 && i % 1000 == 0)
                {
                    Puts($"Organizing data: {i}/{total}");
                    yield return new WaitForEndOfFrame();
                }
            }

            yield return new WaitForSecondsRealtime(1);
            Puts("Entity data was organized!");
        }

        #endregion
        
        #region Permissions Support

        private Dictionary<string, PermissionEntry> cachePermission = new Dictionary<string, PermissionEntry>();
        
        private class PermissionEntry
        {
            public PermissionEntry GetClone()
            {
                return (PermissionEntry) this.MemberwiseClone();
            }
            
            [JsonProperty(PropertyName = "Permission")]
            public string permission;

            [JsonProperty(PropertyName = "Priority")]
            public int priority;

            [JsonProperty(PropertyName = "Limits Global")]
            public Dictionary<string, int> limitsGlobal = new Dictionary<string, int>();

            [JsonProperty(PropertyName = "Limits Building")]
            public Dictionary<string, int> limitsBuilding = new Dictionary<string, int>();
        }
        
        private PermissionEntry GetPermissionFromPlayerID(string playerID, PermissionEntry[] permissions)
        {
            var lastPermission = (PermissionEntry) null;
            if (cachePermission.TryGetValue(playerID, out lastPermission) == true)
            {
                return lastPermission;
            }

            var lastPriority = -1;

            foreach (var value in permissions)
            {
                if (value.priority > lastPriority && permission.UserHasPermission(playerID, value.permission))
                {
                    lastPriority = value.priority;
                    lastPermission = value;
                }
            }

            if (lastPermission != null)
            {
                cachePermission.Add(playerID, lastPermission);
            }
            
            return lastPermission;
        }

        #endregion

        #region Configuration | 2.0.1

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Commands")]
            public string[] commands =
            {
                "buildinglimits", "limits", "limit", "blimit"
            };
            
            [JsonProperty(PropertyName = "Permission cache time (seconds)")]
            public int cacheTime = 700;

            [JsonProperty(PropertyName = "Warn about limits every X entities")]
            public int warnCount = 50;

            [JsonProperty(PropertyName = "Permissions")]
            public PermissionEntry[] permissions =
            {
                new PermissionEntry
                {
                    permission = nameof(EntityLimit) + ".default",
                    priority = 0,
                    limitsGlobal = new Dictionary<string, int>
                    {
                        {"foundation", 50},
                        {"assets/prefabs/building core/roof/roof.prefab", 50},
                        {"assets/prefabs/deployable/furnace/furnace.prefab", 5},
                        {"*", 1000},
                    },
                    limitsBuilding = new Dictionary<string, int>
                    {
                        {"foundation", 25},
                        {"foundation.triangle", 25},
                        {"assets/prefabs/npc/autoturret/autoturret_deployed.prefab", 10}
                    }
                }, 
                new PermissionEntry
                {
                    permission = nameof(EntityLimit) + ".vip",
                    priority = 1,
                    limitsGlobal = new Dictionary<string, int>
                    {
                        {"foundation", 200},
                        {"assets/prefabs/building core/roof/roof.prefab", 200},
                        {"*", 2000},
                    },
                    limitsBuilding = new Dictionary<string, int>
                    {
                        {"foundation", 200},
                        {"foundation.triangle", 200},
                        {"assets/prefabs/npc/autoturret/autoturret_deployed.prefab", 200}
                    }
                }, 
                new PermissionEntry
                {
                    permission = nameof(EntityLimit) + ".nolimit",
                    priority = 999,
                    limitsGlobal = new Dictionary<string, int>
                    {
                        
                    },
                    limitsBuilding = new Dictionary<string, int>
                    {
                        
                    }
                }, 
                new PermissionEntry
                {
                    permission = nameof(EntityLimit) + ".debug",
                    priority = 9999,
                    limitsGlobal = new Dictionary<string, int>
                    {
                        {"foundation", 3},
                        {"*", 15},
                    },
                    limitsBuilding = new Dictionary<string, int>
                    {
                        {"foundation", 2},
                        {"*", 5},
                    }
                }, 
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private static void ValidateConfig()
        {
            
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Language | 2.0.1
        
        private Dictionary<object, string> langMessages = new Dictionary<object, string>
        {
            {MessageType.LimitBuilding, "You reached limit at that building! Used: {used}, Limit: {limit}"},
            {MessageType.LimitGlobal, "You reached global limit! Used: {used}, Limit: {limit}"},
            {MessageType.LimitBuildingWarning, "You used {used} that type of building parts in that building, {left} available..."},
            {MessageType.LimitGlobalWarning, "You used {used} that type of building parts in whole world, {left} available..."},
            {MessageType.LimitsList, "Your global limits:\n{global}\nYour building limits:\n{building}"},
        };
        
        private enum MessageType
        {
            LimitsList,
            LimitBuilding,
            LimitBuildingWarning,
            LimitGlobal,
            LimitGlobalWarning,
        }
        
        protected override void LoadDefaultMessages()
        {
            var dictionary = new Dictionary<string, string>();
            foreach (var pair in langMessages)
            {
                var key = pair.Key.ToString();
                var value = pair.Value;
                dictionary.TryAdd(key, value);
            }
            lang.RegisterMessages(dictionary, this, "en");
        }

        private string GetMessage(MessageType key, string playerID = null, params object[] args)
        {
            var message = lang.GetMessage(key.ToString(), this, playerID);
            var organized = OrganizeArgs(args);
            message = ReplaceArgs(message, organized);
            return message;
        }
        
        private static Dictionary<string, object> OrganizeArgs(object[] args)
        {
            var dic = new Dictionary<string, object>();
            for (var i = 0; i < args.Length; i += 2)
            {
                var value = args[i].ToString();
                var nextValue = i + 1 < args.Length ? args[i + 1] : null;
                dic.Add(value, nextValue);
            }

            return dic;
        }

		private static string ReplaceArgs(string message, Dictionary<string, object> args)
		{
			if (args == null || args.Count < 1){return message;}
			
			foreach (var pair in args)
			{
				var s0 = "{" + pair.Key + "}";
				var s1 = pair.Key;
				var s2 = pair.Value != null ? pair.Value.ToString() : "null";
				
				// Case-insensitive replacement
				message = message.Replace(s0, s2, StringComparison.OrdinalIgnoreCase);
				message = message.Replace(s1, s2, StringComparison.OrdinalIgnoreCase);
			}
			return message;
		}


        private void SendMessage(object receiver, MessageType key, params object[] args)
        {
            var userID = (receiver as BasePlayer)?.UserIDString;
            var message = GetMessage(key, userID, args);
            SendMessage(receiver, message);
        }
        
        private void SendMessage(object receiver, string message)
        {
            if (receiver == null)
            {
                Puts(message);
                return;
            }
            
            var console = receiver as ConsoleSystem.Arg;
            if (console != null)
            {
                SendReply(console, message);
                return;
            }
            
            var player = receiver as BasePlayer;
            if (player != null)
            {
                player.ChatMessage(message);
                return;
            }
        }

        #endregion
        
        #region Data | 2.2.0
        
        private static PluginData Data = new PluginData();

        private class DataEntry
        {
            public HashSet<EntityData> entities = new HashSet<EntityData>();
        }
        
        private class EntityData
        {
            public string prefab;
            public int count => list.Count;
            [JsonIgnore] public HashSet<BaseEntity> list = new HashSet<BaseEntity>();
        }
        
        private class PluginData
        {
            /* ### Values ### */
            // ReSharper disable once MemberCanBePrivate.Local
            [JsonProperty] private Dictionary<string, DataEntry> values = new Dictionary<string, DataEntry>();
            [JsonIgnore] private Dictionary<string, DataEntry> cache = new Dictionary<string, DataEntry>();
            
            public DataEntry Get(object param, bool createNewOnMissing)
            {
                var key = GetKeyFrom(param);
                if (string.IsNullOrEmpty(key) == true)
                {
                    return null;
                }
                
                var value = (DataEntry) null;
                if (cache.TryGetValue(key, out value) == true)
                {
                    return value;
                }

                if (values.TryGetValue(key, out value) == false && createNewOnMissing == true)
                {
                    value = new DataEntry();
                    values.Add(key, value);
                }

                if (value != null)
                {
                    cache.TryAdd(key, value);
                }
                
                return value;
            }
            
            public void Set(object param, DataEntry value)
            {
                var key = GetKeyFrom(param);
                if (string.IsNullOrEmpty(key) == true)
                {
                    return;
                }

                if (value == null)
                {
                    if (values.ContainsKey(key) == true)
                    {
                        values.Remove(key);
                    }
                    
                    if (cache.ContainsKey(key) == true)
                    {
                        cache.Remove(key);
                    }
                }
                else
                {
                    if (values.TryAdd(key, value) == false)
                    {
                        values[key] = value;
                    
                        if (cache.ContainsKey(key) == true)
                        {
                            cache[key] = value;
                        }
                    }
                }
            }

            private static string GetKeyFrom(object obj)
            {
                if (obj == null)
                {
                    return null;
                }

                if (obj is string)
                {
                    return obj as string;
                }

                if (obj is BasePlayer)
                {
                    return (obj as BasePlayer).UserIDString;
                }

                if (obj is BaseNetworkable)
                {
                    return (obj as BaseNetworkable).net?.ID.ToString();
                }

                return obj.ToString();
            }
        }

        #endregion
    }
}

// --- End of file: EntityLimit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-item-picker ---
// --- Original File Path: E/EntityItemPicker/EntityItemPicker.cs ---

﻿using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Entity Item Picker", "0x89A", "1.0.1")]
    [Description("Get the item of any deployable with a single button press")]
    class EntityItemPicker : RustPlugin
    {
        private Configuration _config;
        
        private const string use = "entityitempicker.use";
        private const string bypassCooldown = "entityitempicker.bypass";

        private Regex _removeRegex = new Regex(".prefab|.deployed|.entity|_deployed|_leather|electrical.|electric.");

        private Dictionary<string, string> _prefabToItemShortname = new Dictionary<string, string>
        {
            ["sign.huge.wood.prefab"] = "sign.wooden.huge",
            ["sign.large.wood.prefab"] = "sign.wooden.large",
            ["sign.medium.wood.prefab"] = "sign.wooden.medium",
            ["sign.small.wood.prefab"] = "sign.wooden.small",
            ["wall.external.high.wood.prefab"] = "wall.external.high",
            ["survivalfishtrap.deployed.prefab"] = "fishtrap.small",
            ["waterpurifier.deployed.prefab"] = "water.purifier",
            ["refinery_small_deployed.prefab"] = "small.oil.refinery",
            ["barricade.cover.wood.prefab"] = "barricade.wood.cover"
        };

        private Dictionary<ulong, float> _lastUseTime = new Dictionary<ulong, float>();

        void Init()
        {
            permission.RegisterPermission(use, this);
            permission.RegisterPermission(bypassCooldown, this);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["InvalidObject"] = "Please look at a valid object",
                ["OnCooldown"] = "Please wait {0} more seconds",
            }, this);
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.FIRE_THIRD))
            {
                float useTime = 9999f;
                if (!_lastUseTime.TryGetValue(player.userID, out useTime))
                    _lastUseTime.Add(player.userID, Time.time);

                float time = Time.time - useTime;

                if (permission.UserHasPermission(player.UserIDString, use) && (!_config.useCooldown || permission.UserHasPermission(player.UserIDString, bypassCooldown) || time >= _config.cooldownTime))
                {
                    RaycastHit hit;
                    if (Physics.Raycast(player.eyes.HeadRay(), out hit, _config.maxDist))
                    {
                        BaseCombatEntity entity = null;
                        try
                        {
                            entity = hit.GetEntity() as BaseCombatEntity;
                        }
                        catch
                        {
                            return;
                        }

                        string compareString = _removeRegex.Replace(entity.ShortPrefabName, string.Empty);

                        ItemDefinition itemDef = entity.pickup.itemTarget ?? GetDefinition(compareString, compareString.Replace('_', '.'), compareString.Replace("_", string.Empty), $"electric.{compareString}", GetStringFromDict(entity.ShortPrefabName));

                        if (itemDef != null)
                        {
                            player.GiveItem(ItemManager.Create(itemDef, 1, entity.skinID));

                            if (_config.killWhenShifting && input.IsDown(BUTTON.SPRINT))
                                entity.AdminKill();
                        }
                        else player.ChatMessage(lang.GetMessage("InvalidObject", this, player.UserIDString));

                        _lastUseTime[player.userID] = Time.time;
                    }
                }
                else if (time < _config.cooldownTime)
                {
                    player.ChatMessage(lang.GetMessage("OnCooldown", this, player.UserIDString).Replace("{0}", (_config.cooldownTime - Math.Round(time, 1)).ToString()));
                }
            }
        }

        private ItemDefinition GetDefinition(params string[] comparisons)
        {
            ItemDefinition itemDef = null;

            foreach (string comparison in comparisons)
            {
                if (ItemManager.itemDictionaryByName.TryGetValue(comparison, out itemDef))
                    break;
            }

            return itemDef;
        }

        private string GetStringFromDict(string key)
        {
            string value;
            _prefabToItemShortname.TryGetValue(key, out value);

            return value ?? string.Empty;
        }

        #region -Configuration-

        private class Configuration
        {
            [JsonProperty("Use cooldown")]
            public bool useCooldown = true;

            [JsonProperty("Cooldown duration")]
            public float cooldownTime = 3f;

            [JsonProperty("Maximum distance")]
            public float maxDist = 20f;

            [JsonProperty("Kill on pickup when holding sprint")]
            public bool killWhenShifting = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load _config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}


// --- End of file: EntityItemPicker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/enforce-single-resource-extractor ---
// --- Original File Path: E/EnforceSingleResourceExtractor/EnforceSingleResourceExtractor.cs ---

/* --- Contributor information ---
 * Please follow the following set of guidelines when working on this plugin,
 * this to help others understand this file more easily.
 * 
 * NOTE: On Authors, new entries go BELOW the existing entries. As with any other software header comment.
 *
 * -- Authors --
 * Thimo (ThibmoRozier) <thibmorozier@live.nl> 2021-03-15 +
 *
 * -- Naming --
 * Avoid using non-alphabetic characters, eg: _
 * Avoid using numbers in method and class names (Upgrade methods are allowed to have these, for readability)
 * Private constants -------------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private readonly fields -------------- SHOULD start with a uppercase "C" (PascalCase)
 * Private fields ----------------------- SHOULD start with a uppercase "F" (PascalCase)
 * Arguments/Parameters ----------------- SHOULD start with a lowercase "a" (camelCase)
 * Classes ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Methods ------------------------------ SHOULD start with a uppercase character (PascalCase)
 * Public properties (constants/fields) - SHOULD start with a uppercase character (PascalCase)
 * Variables ---------------------------- SHOULD start with a lowercase character (camelCase)
 *
 * -- Style --
 * Max-line-width ------- 160
 * Single-line comments - // Single-line comment
 * Multi-line comments -- Just like this comment block!
 */
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Enforce Single Resource Extractor", "ThibmoRozier", "1.0.5")]
    [Description("Enforce players only being able to use a single quarry and/or pump jack.")]
    public class EnforceSingleResourceExtractor : RustPlugin
    {
        #region Types
        private enum ExtractorType
        {
            PumpJack,
            Quarry
        }

        private struct QuarryState
        {
            public ulong PlayerId;
            public uint ExtractorId;
            public ExtractorType Type;
        }
        #endregion Types

        #region Constants
        // Not sure what the placable prefab is called, just playing safe
        private static readonly string[] CPumpJackPrefabs = { "pumpjack", "pump_jack", "pump-jack", "pumpjack-static" };
        private static readonly string[] CQuarryPrefabs = { "mining_quarry", "miningquarry_static" };
        private static readonly IEnumerable<string> CCombinedPrefabs = CPumpJackPrefabs.Concat(CQuarryPrefabs);

        // Permissions
        private const String CPermWhitelist = "enforcesingleresourceextractor.whitelist";
        #endregion Constants

        #region Variables
        private ConfigData FConfigData;
        private Timer FCleanupTimer;
        private readonly List<QuarryState> FPlayerExtractorList = new List<QuarryState>();
        #endregion Variables

        #region Config
        /// <summary>
        /// The config type class
        /// </summary>
        private class ConfigData
        {
            [DefaultValue(true)]
            [JsonProperty("Ignore Extractor Type", DefaultValueHandling = DefaultValueHandling.Populate)]
            public bool IgnoreExtractorType { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try {
                FConfigData = Config.ReadObject<ConfigData>();

                if (FConfigData == null)
                    LoadDefaultConfig();
            } catch (Exception) {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            FConfigData = new ConfigData {
                IgnoreExtractorType = true
            };
        }

        protected override void SaveConfig() => Config.WriteObject(FConfigData);
        #endregion Config

        #region Script Methods
        private void CheckExtractorIsOff()
        {
            List<uint> removeIds = new List<uint>();
            BaseNetworkable extractor;

            foreach (var item in FPlayerExtractorList) {
                // Check whitelist permission, just remove entry when whitelisted
                if (permission.UserHasPermission(item.PlayerId.ToString(), CPermWhitelist)) {
                    removeIds.Add(item.ExtractorId);
                    continue;
                }

                try {
                    // Check the prefab name, just to be sure, since we use the net.ID which could be reused after the entity is killed.
                    extractor = BaseNetworkable.serverEntities.First(x => x.net.ID == item.ExtractorId && CCombinedPrefabs.Contains(x.ShortPrefabName));

                    if ((extractor as MiningQuarry).IsEngineOn())
                        continue;
                } catch(ArgumentNullException) { }

                removeIds.Add(item.ExtractorId);
            }

            if (removeIds.Count > 0)
                FPlayerExtractorList.RemoveAll(x => removeIds.Contains(x.ExtractorId));
        }
        #endregion Script Methods

        #region Hooks
        void OnServerInitialized()
        { 
            LoadConfig();
            permission.RegisterPermission(CPermWhitelist, this);
            FCleanupTimer = timer.Every(1f, CheckExtractorIsOff);
        }

        void Unload()
        {
            if (FCleanupTimer != null && !FCleanupTimer.Destroyed)
                FCleanupTimer.Destroy();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    { "Warning Message Text", "<color=#FF7900>You can only run a single resource extractor at any given time.</color>" }
                }, this, "en"
            );
        }

        void OnQuarryToggled(MiningQuarry aExtractor, BasePlayer aPlayer)
        {
            /* This check takes care of 2 simple cases:
             *   1> The player is whitelisted, just remove
             *   2> Extractor was turned off, don't care about player ID, just remove
             */
            if (permission.UserHasPermission(aPlayer.UserIDString, CPermWhitelist) || !aExtractor.IsEngineOn()) {
                FPlayerExtractorList.RemoveAll(x => aExtractor.net.ID == x.ExtractorId);
                return;
            }

            ExtractorType type;

            if (CPumpJackPrefabs.Contains(aExtractor.ShortPrefabName)) {
                type = ExtractorType.PumpJack;
            } else if (CQuarryPrefabs.Contains(aExtractor.ShortPrefabName)) {
                type = ExtractorType.Quarry;
            } else {
                // Skip anything we don't care about
                return;
            }

            if (FPlayerExtractorList.Count(x => aPlayer.userID == x.PlayerId && (FConfigData.IgnoreExtractorType || type == x.Type)) > 0) {
                // Turn engine OFF
                aExtractor.EngineSwitch(false);
                // Warn the player
                aPlayer.ChatMessage(lang.GetMessage("Warning Message Text", this, aPlayer.UserIDString));
                return;
            }

            FPlayerExtractorList.Add(new QuarryState { PlayerId = aPlayer.userID, ExtractorId = aExtractor.net.ID, Type = type });
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (CCombinedPrefabs.Contains(entity.ShortPrefabName))
                FPlayerExtractorList.RemoveAll(x => entity.net.ID == x.ExtractorId);
        }
        #endregion Hooks
    }
}


// --- End of file: EnforceSingleResourceExtractor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosive-barrels ---
// --- Original File Path: E/ExplosiveBarrels/ExplosiveBarrels.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Explosive Barrels", "Orange", "1.0.1")]
    [Description("Allows barrels to blow up on damage or death")]
    public class ExplosiveBarrels : RustPlugin
    {
        #region Vars
        
        private List<string> barrels = new List<string>
        {
            "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-1.prefab",
            "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-2.prefab",
            "assets/bundled/prefabs/radtown/loot_barrel_1.prefab",
            "assets/bundled/prefabs/radtown/loot_barrel_2.prefab",
            "assets/bundled/prefabs/radtown/oil_barrel.prefab",
        };
        
        #endregion

        #region Oxide Hooks

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            CheckBarrel(entity, false);
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            CheckBarrel(entity, true);
        }

        #endregion

        #region Core

        private void CheckBarrel(BaseCombatEntity entity, bool death)
        {
            if (entity == null) {return;}
            if (!IsBarrel(entity)) {return;}
            var cfg = IsOilBarrel(entity) ? config.oil : config.normal;
            var random = Core.Random.Range(0, 99);
            var chance = death ? cfg.death : cfg.damage;
            if (chance == 0 || random >  chance) {return;}
            Explode(entity, cfg);
        }

        private void Explode(BaseCombatEntity barrel, ConfigData.OBarrel config)
        {
            var position = barrel.transform.position;
            var radius = config.eRadius;
            var damage = config.eDamage;
            var effects = config.effects;

            if (barrel.health > 0)
            {
                try
                {
                    barrel.Hurt(100f);
                }
                catch
                {
                    // ignored
                }
            }

            foreach (var effect in effects)
            {
                var x = Core.Random.Range(-radius, radius);
                var y = Core.Random.Range(0, radius);
                var z = Core.Random.Range(-radius, radius);
                Effect.server.Run(effect, position + new Vector3(x,y,z));
            }
            
            Effect.server.Run("assets/content/weapons/_gestures/effects/eat_1hand_celery.prefab", position);

            var entities = new List<BaseCombatEntity>();
            Vis.Entities(position, radius, entities);
            
            foreach (var entity in entities.ToList())
            {
                try
                {
                    if (entity.health > 0)
                    {
                        entity.Hurt(damage, DamageType.Explosion);
                    }
                }
                catch
                {
                    // ignored
                }
            }
        }

        #endregion

        #region Helpers

        private bool IsBarrel(BaseEntity entity)
        {
            return entity.OwnerID == 0 && barrels.Contains(entity.PrefabName);
        }

        private bool IsOilBarrel(BaseEntity entity)
        {
            return entity.PrefabName.Contains("oil");
        }

        #endregion

        #region Config

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "1. NORMAL barrels settings:")]
            public OBarrel normal;
            
            [JsonProperty(PropertyName = "2. OIL barrels settings:")]
            public OBarrel oil;

            public class OBarrel
            {
                [JsonProperty(PropertyName = "1. Chance to explode on taking damage (set to 0 to disable)")]
                public int damage;
                
                [JsonProperty(PropertyName = "2. Chance to explode on death (set to 0 to disable)")]
                public int death;
                
                [JsonProperty(PropertyName = "3. Damage on explosion (set to 0 to disable)")]
                public int eDamage;
                
                [JsonProperty(PropertyName = "4. Radius of damage on explosion")]
                public int eRadius;
                
                [JsonProperty(PropertyName = "5. List of effects on explosion")]
                public List<string> effects;
            }
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                normal = new ConfigData.OBarrel
                {
                    damage = 0,
                    death = 10,
                    eDamage = 0,
                    eRadius = 5,
                    effects = new List<string>
                    {
                        "assets/bundled/prefabs/fx/gas_explosion_small.prefab",
                        "assets/bundled/prefabs/fx/explosions/explosion_03.prefab"
                    }
                },
                oil = new ConfigData.OBarrel
                {
                    damage = 10,
                    death = 75,
                    eDamage = 50,
                    eRadius = 3,
                    effects = new List<string>
                    {
                        "assets/bundled/prefabs/fx/gas_explosion_small.prefab",
                        "assets/bundled/prefabs/fx/explosions/explosion_03.prefab"
                    }
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: ExplosiveBarrels.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/empty-ovens ---
// --- Original File Path: E/EmptyOvens/EmptyOvens.cs ---

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Empty Ovens", "Orange", "1.0.0")]
    [Description("Remove wood from campfires and same on placing")]
    public class EmptyOvens : RustPlugin
    {
        #region Oxide Hooks
        
        private void OnEntitySpawned(BaseOven entity)
        {
            var name = entity.ShortPrefabName;
            if (config.whitelist.Contains(name))
            {
                return;
            }

            foreach (var item in entity.inventory.itemList.ToList())
            {
                item.GetHeldEntity()?.Kill();
                item.DoRemove();
            }
        }
        
        #endregion
        
        #region Configuration 1.0.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Whitelist")]
            public List<string> whitelist;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                whitelist = new List<string>
                {
                    "shortname here",
                    "that shortnames will be excluded"
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: EmptyOvens.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-scale-manager ---
// --- Original File Path: E/EntityScaleManager/EntityScaleManager.cs ---

﻿using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Entity Scale Manager", "WhiteThunder", "2.1.5")]
[Description("Utilities for resizing entities.")]
internal class EntityScaleManager : CovalencePlugin
{
    #region Fields

    [PluginReference]
    private readonly Plugin ParentedEntityRenderFix;

    private Configuration _config;
    private StoredData _data;

    private const string PermissionScaleUnrestricted = "entityscalemanager.unrestricted";
    private const string SpherePrefab = "assets/prefabs/visualization/sphere.prefab";

    private readonly object True = true;

    // This could be improved by calculating the time needed for the resize,
    // since the amount of time required seems to depend on the scale.
    private const float ExpectedResizeDuration = 7f;

    private EntitySubscriptionManager _entitySubscriptionManager = new();
    private NetworkSnapshotManager _networkSnapshotManager = new();

    #endregion

    #region Hooks

    private void Init()
    {
        _data = StoredData.Load();

        permission.RegisterPermission(PermissionScaleUnrestricted, this);

        if (!_config.HideSpheresAfterResize)
        {
            Unsubscribe(nameof(OnEntitySnapshot));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnNetworkGroupLeft));
            Unsubscribe(nameof(CanStartTelekinesis));
        }
    }

    private void Unload()
    {
        _data.Save();

        _entitySubscriptionManager.Clear();
        _networkSnapshotManager.Clear();

        _data = null;
        _config = null;
    }

    private void OnServerInitialized()
    {
        foreach (var networkable in BaseNetworkable.serverEntities)
        {
            var entity = networkable as BaseEntity;
            if (entity == null)
                continue;

            var parentSphere = GetParentSphere(entity);
            if (parentSphere != null && _data.ScaledEntities.Contains(entity.net.ID.Value))
            {
                RefreshScaledEntity(entity, parentSphere);
            }
        }
    }

    private void OnServerSave()
    {
        _data.Save();
    }

    private void OnNewSave()
    {
        _data = StoredData.Clear();
    }

    private void OnEntityKill(BaseEntity entity)
    {
        if (entity == null || entity.net == null)
            return;

        if (!_data.ScaledEntities.Remove(entity.net.ID.Value))
            return;

        _entitySubscriptionManager.RemoveEntity(entity.net.ID);

        var parentSphere = GetParentSphere(entity);
        if (parentSphere == null)
            return;

        if (_config.HideSpheresAfterResize)
        {
            _networkSnapshotManager.InvalidateForEntity(entity.net.ID);
        }

        var parentSphereForClosure = parentSphere;

        // Destroy the sphere that was used to scale the entity.
        // This assumes that only one entity was scaled using this sphere.
        // We could instead check if the sphere still has children, but keeping the sphere
        // might cause it to never be killed after the remaining children are killed.
        // Plugins should generally parent other entities using a separate sphere, or
        // parent to the scaled entity itself.
        parentSphereForClosure.Invoke(() =>
        {
            if (parentSphereForClosure != null && !parentSphereForClosure.IsDestroyed)
            {
                parentSphereForClosure.Kill();
            }
        }, 0);
    }

    private void OnPlayerDisconnected(BasePlayer player)
    {
        _entitySubscriptionManager.RemoveSubscriber(player.userID);
    }

    private object OnEntitySnapshot(BaseEntity entity, Connection connection)
    {
        if (entity == null || entity.net == null)
            return null;

        if (!_data.ScaledEntities.Contains(entity.net.ID.Value))
            return null;

        var parentSphere = GetParentSphere(entity);
        if (parentSphere == null)
            return null;

        // Detect when the vanilla network cache has been cleared in order to invalidate the custom cache.
        if (entity._NetworkCache == null)
        {
            _networkSnapshotManager.InvalidateForEntity(entity.net.ID);
        }

        var resizeState = _entitySubscriptionManager.GetResizeState(entity.net.ID, connection.ownerid);
        if (resizeState == ResizeState.Resized)
        {
            // Don't track CPU time of this since it's almost identical to the vanilla behavior being cancelled.
            // Tracking it would give server operators false information that this plugin is spending more CPU time than it is.
            TrackEnd();
            _networkSnapshotManager.SendModifiedSnapshot(entity, connection);
            TrackStart();
            return True;
        }

        if (resizeState == ResizeState.NeedsResize)
        {
            // The entity is now starting to resize for this client.
            // Start a timer to cause this client to start using the custom snapshots after resize.
            timer.Once(ExpectedResizeDuration, () =>
            {
                if (entity != null
                    && parentSphere != null
                    && _entitySubscriptionManager.DoneResizing(entity.net.ID, connection.ownerid))
                {
                    // Send a snapshot to the client indicating that the entity is not parented to the sphere.
                    _networkSnapshotManager.SendModifiedSnapshot(entity, connection);

                    // Terminate the sphere on the client.
                    // Subsequent snapshots to this client will use different logic.
                    NetworkUtils.TerminateOnClient(parentSphere, connection);
                }
            });
        }

        // Send normal snapshot which indicates the entity has a sphere parent.
        return null;
    }

    // Clients destroy entities from a network group when they leave it.
    // This helps determine later on whether the client is creating the entity or simply receiving an update.
    private void OnNetworkGroupLeft(BasePlayer player, Network.Visibility.Group group)
    {
        for (var i = 0; i < group.networkables.Count; i++)
        {
            var networkable = group.networkables.Values.Buffer[i];
            if (networkable == null)
                continue;

            var entity = networkable.handler as BaseNetworkable;
            if (entity == null || entity.net == null)
                continue;

            _entitySubscriptionManager.RemoveEntitySubscription(entity.net.ID, player.userID);
        }
    }

    // This hook is exposed by plugin: Telekinesis.
    private Tuple<BaseEntity, BaseEntity> OnTelekinesisStart(BasePlayer player, BaseEntity entity)
    {
        if (!_data.ScaledEntities.Contains(entity.net.ID.Value))
            return null;

        var parentSphere = GetParentSphere(entity);
        if (parentSphere == null)
            return null;

        // Move the sphere, but rotate the child.
        // This is done because spheres have default rotation to avoid client-side interpolation issues.
        return new Tuple<BaseEntity, BaseEntity>(parentSphere, entity);
    }

    // This hook is exposed by plugin: Telekinesis.
    private string CanStartTelekinesis(BasePlayer player, SphereEntity moveEntity, BaseEntity rotateEntity)
    {
        if (!_data.ScaledEntities.Contains(rotateEntity.net.ID.Value))
            return null;

        return GetMessage(player, "Error.CannotMoveWithHiddenSpheres");
    }

    #endregion

    #region API

    [HookMethod(nameof(API_GetScale))]
    public float API_GetScale(BaseEntity entity)
    {
        if (entity == null || entity.net == null)
            return 1;

        if (!_data.ScaledEntities.Contains(entity.net.ID.Value))
            return 1;

        var parentSphere = GetParentSphere(entity);
        if (parentSphere == null)
            return 1;

        return parentSphere.currentRadius;
    }

    [HookMethod(nameof(API_ScaleEntity))]
    public bool API_ScaleEntity(BaseEntity entity, float scale)
    {
        if (entity == null || entity.net == null)
            return false;

        return TryScaleEntity(entity, scale);
    }

    [HookMethod(nameof(API_ScaleEntity))]
    public bool API_ScaleEntity(BaseEntity entity, int scale)
    {
        return API_ScaleEntity(entity, (float)scale);
    }

    [HookMethod(nameof(API_RegisterScaledEntity))]
    public void API_RegisterScaledEntity(BaseEntity entity)
    {
        if (entity == null || entity.net == null)
            return;

        _data.ScaledEntities.Add(entity.net.ID.Value);
    }

    #endregion

    #region Commands

    [Command("scale")]
    private void CommandScale(IPlayer player, string cmd, string[] args)
    {
        if (player.IsServer)
            return;

        if (!player.HasPermission(PermissionScaleUnrestricted))
        {
            ReplyToPlayer(player, "Error.NoPermission");
            return;
        }

        if (args.Length == 0 || !float.TryParse(args[0], out var scale))
        {
            ReplyToPlayer(player, "Error.Syntax", cmd);
            return;
        }

        var basePlayer = player.Object as BasePlayer;
        var entity = GetLookEntity(basePlayer);
        if (entity == null)
        {
            ReplyToPlayer(player, "Error.NoEntityFound");
            return;
        }

        if (entity is BasePlayer)
        {
            ReplyToPlayer(player, "Error.EntityNotSafeToScale");
            return;
        }

        ReplyToPlayer(player, TryScaleEntity(entity, scale) ? "Scale.Success" : "Error.ScaleBlocked", scale);
    }

    [Command("getscale")]
    private void CommandGetScale(IPlayer player)
    {
        if (player.IsServer)
            return;

        if (!player.HasPermission(PermissionScaleUnrestricted))
        {
            ReplyToPlayer(player, "Error.NoPermission");
            return;
        }

        var basePlayer = player.Object as BasePlayer;
        var entity = GetLookEntity(basePlayer);
        if (entity == null)
        {
            ReplyToPlayer(player, "Error.NoEntityFound");
            return;
        }

        if (!_data.ScaledEntities.Contains(entity.net.ID.Value))
        {
            ReplyToPlayer(player, "Error.NotTracked");
            return;
        }

        var parentSphere = GetParentSphere(entity);
        if (parentSphere == null)
        {
            ReplyToPlayer(player, "Error.NotScaled");
            return;
        }

        ReplyToPlayer(player, "GetScale.Success", parentSphere.currentRadius);
    }

    #endregion

    #region Helper Methods

    private static bool EntityScaleWasBlocked(BaseEntity entity, float scale)
    {
        return Interface.CallHook("OnEntityScale", entity, scale) is false;
    }

    private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 20)
    {
        return Physics.Raycast(basePlayer.eyes.HeadRay(), out var hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
            ? hit.GetEntity()
            : null;
    }

    private static void EnableGlobalBroadcastFixed(BaseEntity entity, bool wants)
    {
        entity.globalBroadcast = wants;

        if (wants)
        {
            entity.UpdateNetworkGroup();
        }
        else if (entity.net?.group?.ID == 0)
        {
            // Fix vanilla bug that prevents leaving the global network group.
            var group = entity.net.sv.visibility.GetGroup(entity.transform.position);
            entity.net.SwitchGroup(group);
        }
    }

    private static void SetupSphereEntity(SphereEntity sphereEntity, BaseEntity scaledEntity)
    {
        // SphereEntity has enableSaving off by default, so enable it if the child has saving enabled.
        // This fixes an issue where the resized child gets orphaned on restart and spams console errors every 2 seconds.
        sphereEntity.EnableSaving(scaledEntity.enableSaving);

        // SphereEntity has globalBroadcast on by default, but it should generally be off for scaled entities.
        // This fixes an issue where clients who resubscribe do not recreate the sphere or its children.
        EnableGlobalBroadcastFixed(sphereEntity, scaledEntity.globalBroadcast);
    }

    private static void SetSphereSize(SphereEntity sphereEntity, float scale)
    {
        sphereEntity.currentRadius = scale;
        sphereEntity.lerpRadius = scale;
        sphereEntity.transform.localScale = new Vector3(scale, scale, scale);
    }

    private static SphereEntity CreateSphere(Vector3 position, Quaternion rotation, float scale, BaseEntity scaledEntity)
    {
        var sphereEntity = GameManager.server.CreateEntity(SpherePrefab, position, rotation) as SphereEntity;
        if (sphereEntity == null)
            return null;

        SetupSphereEntity(sphereEntity, scaledEntity);
        SetSphereSize(sphereEntity, scale);
        sphereEntity.SetParent(scaledEntity.GetParentEntity());
        sphereEntity.Spawn();

        return sphereEntity;
    }

    private static SphereEntity GetParentSphere(BaseEntity entity)
    {
        return entity.GetParentEntity() as SphereEntity;
    }

    private void RefreshScaledEntity(BaseEntity scaledEntity, SphereEntity parentSphere)
    {
        SetupSphereEntity(parentSphere, scaledEntity);

        if (_config.HideSpheresAfterResize)
        {
            foreach (var subscriber in scaledEntity.net.group.subscribers)
            {
                _entitySubscriptionManager.InitResized(scaledEntity.net.ID, subscriber.ownerid);
            }
        }
    }

    private void UnparentFromSphere(BaseEntity scaledEntity)
    {
        var sphereEntity = GetParentSphere(scaledEntity);
        if (sphereEntity == null)
            return;

        // Un-parenting an entity automatically transfers the local scale of the parent to the child.
        // So we have to invert the local scale of the child to compensate.
        scaledEntity.transform.localScale /= sphereEntity.currentRadius;

        // If the sphere already has a parent, simply move the entity to it.
        // Parent is possibly null but that's ok since that will simply unparent.
        scaledEntity.SetParent(sphereEntity.GetParentEntity(), worldPositionStays: true, sendImmediate: true);

        sphereEntity.Kill();

        _entitySubscriptionManager.RemoveEntity(scaledEntity.net.ID);
        _data.ScaledEntities.Remove(scaledEntity.net.ID.Value);
    }

    private bool TryScaleEntity(BaseEntity entity, float scale)
    {
        if (EntityScaleWasBlocked(entity, scale))
            return false;

        var parentSphere = GetParentSphere(entity);

        // Only resize an existing sphere if it's registered.
        // This allows spheres fully managed by other plugins to remain untouched.
        if (parentSphere != null && _data.ScaledEntities.Contains(entity.net.ID.Value))
        {
            if (scale == parentSphere.currentRadius)
                return true;

            NetworkUtils.TerminateOnClient(entity);
            NetworkUtils.TerminateOnClient(parentSphere);

            // Clear the cache in ParentedEntityRenderFix.
            ParentedEntityRenderFix?.Call("OnEntityKill", entity);

            // Remove the entity from the subscriber manager to allow clients to resize it.
            // This could result in a client who is already resizing it to not resize it fully,
            // but that's not worth the trouble to fix.
            _entitySubscriptionManager.RemoveEntity(entity.net.ID);

            if (scale == 1)
            {
                UnparentFromSphere(entity);
            }
            else
            {
                SetSphereSize(parentSphere, scale);

                // Resend the child as well since it was previously terminated on clients.
                NetworkUtils.SendUpdateImmediateRecursive(parentSphere);
            }

            Interface.CallHook("OnEntityScaled", entity, scale);
            return true;
        }

        if (scale == 1)
            return true;

        _data.ScaledEntities.Add(entity.net.ID.Value);

        var entityTransform = entity.transform;
        parentSphere = CreateSphere(entityTransform.localPosition, Quaternion.identity, scale, entity);
        entityTransform.localPosition = Vector3.zero;
        entity.SetParent(parentSphere, worldPositionStays: false, sendImmediate: true);

        Interface.CallHook("OnEntityScaled", entity, scale);
        return true;
    }

    #endregion

    #region Network Utils

    private static class NetworkUtils
    {
        public static void TerminateOnClient(BaseNetworkable entity, Connection connection = null)
        {
            var write = Net.sv.StartWrite();
            write.PacketID(Message.Type.EntityDestroy);
            write.EntityID(entity.net.ID);
            write.UInt8((byte)BaseNetworkable.DestroyMode.None);
            write.Send(connection != null ? new SendInfo(connection) : new SendInfo(entity.net.group.subscribers));
        }

        public static void SendUpdateImmediateRecursive(BaseEntity entity)
        {
            entity.SendNetworkUpdateImmediate();

            foreach (var child in entity.children)
            {
                SendUpdateImmediateRecursive(child);
            }
        }
    }

    #endregion

    #region Pooling

    private class SimplePool<T> where T : class, new()
    {
        private List<T> _pool = new();

        public virtual T Get()
        {
            var item = _pool.LastOrDefault();
            if (item != null)
            {
                _pool.RemoveAt(_pool.Count - 1);
                return item;
            }

            return new T();
        }

        public virtual void Free(ref T item)
        {
            _pool.Add(item);
            item = null;
        }

        public void Clear()
        {
            _pool.Clear();
        }
    }

    private class SimpleDictionaryPool<TKey, TValue> : SimplePool<Dictionary<TKey, TValue>>
    {
        public override void Free(ref Dictionary<TKey, TValue> dict)
        {
            dict.Clear();
            base.Free(ref dict);
        }
    }

    #endregion

    #region Network Snapshot Manager

    private abstract class BaseNetworkSnapshotManager
    {
        private readonly Dictionary<NetworkableId, MemoryStream> _networkCache = new();

        public void Clear()
        {
            _networkCache.Clear();
        }

        public void InvalidateForEntity(NetworkableId entityId)
        {
            _networkCache.Remove(entityId);
        }

        // Mostly copied from:
        // - `BaseNetworkable.SendAsSnapshot(Connection)`
        // - `BasePlayer.SendEntitySnapshot(BaseNetworkable)`
        public void SendModifiedSnapshot(BaseEntity entity, Connection connection)
        {
            var write = Net.sv.StartWrite();
            connection.validate.entityUpdates++;
            var saveInfo = new BaseNetworkable.SaveInfo
            {
                forConnection = connection,
                forDisk = false,
            };
            write.PacketID(Message.Type.Entities);
            write.UInt32(connection.validate.entityUpdates);
            ToStreamForNetwork(entity, write, saveInfo);
            write.Send(new SendInfo(connection));
        }

        // Mostly copied from `BaseNetworkable.ToStream(Stream, SaveInfo)`.
        private void ToStream(BaseEntity entity, Stream stream, BaseNetworkable.SaveInfo saveInfo)
        {
            using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
            {
                entity.Save(saveInfo);
                Interface.CallHook("OnEntitySaved", entity, saveInfo);
                HandleOnEntitySaved(entity, saveInfo);
                saveInfo.msg.ToProto(stream);
                entity.PostSave(saveInfo);
            }
        }

        // Mostly copied from `BaseNetworkable.ToStreamForNetwork(Stream, SaveInfo)`.
        private Stream ToStreamForNetwork(BaseEntity entity, Stream stream, BaseNetworkable.SaveInfo saveInfo)
        {
            if (!_networkCache.TryGetValue(entity.net.ID, out var cachedStream))
            {
                cachedStream = BaseNetworkable.EntityMemoryStreamPool.Count > 0
                    ? BaseNetworkable.EntityMemoryStreamPool.Dequeue()
                    : new MemoryStream(8);

                ToStream(entity, cachedStream, saveInfo);
                _networkCache[entity.net.ID] = cachedStream;
            }

            cachedStream.WriteTo(stream);
            return cachedStream;
        }

        // Handler for modifying save info when building a snapshot.
        protected abstract void HandleOnEntitySaved(BaseEntity entity, BaseNetworkable.SaveInfo saveInfo);
    }

    private class NetworkSnapshotManager : BaseNetworkSnapshotManager
    {
        protected override void HandleOnEntitySaved(BaseEntity entity, BaseNetworkable.SaveInfo saveInfo)
        {
            var parentSphere = GetParentSphere(entity);
            if (parentSphere == null)
                return;

            var transform = entity.transform;

            var grandparent = parentSphere.GetParentEntity();
            if (grandparent == null)
            {
                saveInfo.msg.parent = null;
                saveInfo.msg.baseEntity.pos = transform.position;
                saveInfo.msg.baseEntity.rot = transform.rotation.eulerAngles;
            }
            else
            {
                saveInfo.msg.parent.uid = grandparent.net.ID;
                saveInfo.msg.baseEntity.pos = parentSphere.transform.localPosition;
            }
        }
    }

    #endregion

    #region Entity Subscription Manager

    private enum ResizeState { NeedsResize, Resizing, Resized }

    private class EntitySubscriptionManager
    {
        private SimpleDictionaryPool<ulong, ResizeState> _dictPool = new();

        // This is used to keep track of which clients are aware of each entity
        // When we expect the client to destroy an entity, we update this state
        private readonly Dictionary<NetworkableId, Dictionary<ulong, ResizeState>> _networkResizeState = new();

        public void Clear()
        {
            foreach (var dict in _networkResizeState.Values)
            {
                var d = dict;
                _dictPool.Free(ref d);
            }

            _dictPool.Clear();
            _networkResizeState.Clear();
        }

        public void InitResized(NetworkableId entityId, ulong userId)
        {
            EnsureEntity(entityId).Add(userId, ResizeState.Resized);
        }

        public ResizeState GetResizeState(NetworkableId entityId, ulong userId)
        {
            var clientToResizeState = EnsureEntity(entityId);
            if (clientToResizeState.TryGetValue(userId, out var resizeState))
                return resizeState;

            clientToResizeState[userId] = ResizeState.Resizing;
            return ResizeState.NeedsResize;
        }

        // Returns true if it was still resizing.
        // Absence in the data structure indicates the client deleted it.
        public bool DoneResizing(NetworkableId entityId, ulong userId)
        {
            if (!_networkResizeState.TryGetValue(entityId, out var clientToResizeState))
                return false;

            if (!clientToResizeState.ContainsKey(userId))
                return false;

            clientToResizeState[userId] = ResizeState.Resized;
            return true;
        }

        public void RemoveEntitySubscription(NetworkableId entityId, ulong userId)
        {
            if (!_networkResizeState.TryGetValue(entityId, out var clientToResizeState))
                return;

            clientToResizeState.Remove(userId);
        }

        public void RemoveEntity(NetworkableId entityId)
        {
            if (!_networkResizeState.TryGetValue(entityId, out var clientToResizeState))
                return;

            _networkResizeState.Remove(entityId);
            _dictPool.Free(ref clientToResizeState);
        }

        public void RemoveSubscriber(ulong userId)
        {
            foreach (var entry in _networkResizeState)
            {
                entry.Value.Remove(userId);
            }
        }

        private Dictionary<ulong, ResizeState> EnsureEntity(NetworkableId entityId)
        {
            if (!_networkResizeState.TryGetValue(entityId, out var clientToResizeState))
            {
                clientToResizeState = _dictPool.Get();
                _networkResizeState[entityId] = clientToResizeState;
            }

            return clientToResizeState;
        }
    }

    #endregion

    #region Data

    private class StoredData
    {
        [JsonProperty("ScaledEntities")]
        public HashSet<ulong> ScaledEntities = new();

        public static StoredData Load()
        {
            return Interface.Oxide.DataFileSystem.ReadObject<StoredData>(nameof(EntityScaleManager)) ?? new StoredData();
        }

        public static StoredData Clear()
        {
            return new StoredData().Save();
        }

        public StoredData Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject(nameof(EntityScaleManager), this);
            return this;
        }
    }

    #endregion

    #region Configuration

    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("Hide spheres after resize (performance intensive)")]
        public bool HideSpheresAfterResize = false;
    }

    private Configuration GetDefaultConfig() => new();

    #region Configuration Helpers

    private class SerializableConfiguration
    {
        public string ToJson() => JsonConvert.SerializeObject(this);

        public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json) => ToObject(JToken.Parse(json));

        private static object ToObject(JToken token)
        {
            switch (token.Type)
            {
                case JTokenType.Object:
                    return token.Children<JProperty>()
                        .ToDictionary(prop => prop.Name,
                            prop => ToObject(prop.Value));

                case JTokenType.Array:
                    return token.Select(ToObject).ToList();

                default:
                    return ((JValue)token).Value;
            }
        }
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config)
    {
        var currentWithDefaults = config.ToDictionary();
        var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
        return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
    }

    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
    {
        var changed = false;

        foreach (var key in currentWithDefaults.Keys)
        {
            if (currentRaw.TryGetValue(key, out var currentRawValue))
            {
                var currentDictValue = currentRawValue as Dictionary<string, object>;
                if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                {
                    if (currentDictValue == null)
                    {
                        currentRaw[key] = currentWithDefaults[key];
                        changed = true;
                    }
                    else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                    {
                        changed = true;
                    }
                }
            }
            else
            {
                currentRaw[key] = currentWithDefaults[key];
                changed = true;
            }
        }

        return changed;
    }

    protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null)
            {
                throw new JsonException();
            }

            if (MaybeUpdateConfig(_config))
            {
                LogWarning("Configuration appears to be outdated; updating and saving");
                SaveConfig();
            }
        }
        catch (Exception e)
        {
            LogError(e.Message);
            LogWarning($"Configuration file {Name}.json is invalid; using defaults");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig()
    {
        Log($"Configuration changes saved to {Name}.json");
        Config.WriteObject(_config, true);
    }

    #endregion

    #endregion

    #region Localization

    private string GetMessage(string playerId, string messageName, params object[] args)
    {
        var message = lang.GetMessage(messageName, this, playerId);
        return args.Length > 0 ? string.Format(message, args) : message;
    }

    private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
        player.ChatMessage(GetMessage(player.IPlayer, messageName, args));

    private string GetMessage(IPlayer player, string messageName, params object[] args) =>
        GetMessage(player.Id, messageName, args);

    private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
        GetMessage(player.UserIDString, messageName, args);

    private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
        player.Reply(GetMessage(player, messageName, args));

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            ["Error.NoPermission"] = "You don't have permission to do that.",
            ["Error.Syntax"] = "Syntax: {0} <size>",
            ["Error.NoEntityFound"] = "Error: No entity found.",
            ["Error.EntityNotSafeToScale"] = "Error: That entity cannot be safely scaled.",
            ["Error.NotTracked"] = "Error: That entity is not tracked by Entity Scale Manager.",
            ["Error.NotScaled"] = "Error: That entity is not scaled.",
            ["Error.ScaleBlocked"] = "Error: Another plugin prevented you from scaling that entity to size {0}.",
            ["Error.CannotMoveWithHiddenSpheres"] = "You may not move resized entities while spheres are configured to be hidden.",
            ["GetScale.Success"] = "Entity scale is: {0}",
            ["Scale.Success"] = "Entity was scaled to: {0}",
        }, this, "en");
    }

    #endregion
}

// --- End of file: EntityScaleManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/edit-tool ---
// --- Original File Path: E/EditTool/EditTool.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Text;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Edit Tool", "JakeRich", "1.0.5")]
    [Description("Modify entities in a map")]
    public class EditTool : RustPlugin
    {
        public static ulong ToolSkinID = 1175592586;
        public static string ToolItemShortname = "coal";
        public static string ToolName = "Edit Tool";
        public static EditTool _plugin;
        public static float EditToolDistance = 50f;
        public static UIManager UI;
        public static PlayerDataController<ToolPlayerData> PlayerData;

        private const string permUse = "edittool.use";

        private void Init()
        {
            _plugin = this;
            UI = new UIManager();
            PlayerData = new PlayerDataController<ToolPlayerData>();
            permission.RegisterPermission(permUse, this);
            for (ToolMode mode = ToolMode.Transform; mode < ToolMode.Last; mode++)
            {
                permission.RegisterPermission($"edittool.{mode.ToString().ToLower()}", this);
            }
        }

        private void Unload()
        {
            UI.Unload();
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!player.IsAdmin)
            {
                if (!permission.UserHasPermission(player.UserIDString, permUse))
                {
                    return;
                }
            }

            if (!HasEditTool(player))
            {
                UI.ToolUI.Hide(player);
                UI.EntityInfoLabel.Text = "";
                UI.EntityInfoLabel.Refresh(player);
                return;
            }

            UI.ToolUI.Show(player);

            ToolPlayerData data = PlayerData.Get(player);
            if (input.WasJustPressed(BUTTON.FIRE_THIRD))
            {
                data.SwitchMode();
            }

            BaseEntity entity;
            Vector3 hitPoint;
            if (!GetEntityLookingAt(player, out entity, out hitPoint, EditToolDistance))
            {
                NotLookingAtEntity(player);
            }
            if (entity == null)
            {
                NotLookingAtEntity(player);
            }
            else
            {
                LookingAtEntity(player, entity);
                UI.EntityInfoLabel.Refresh(player);
            }

            if (input.WasJustPressed(BUTTON.FIRE_PRIMARY))
            {
                if (input.IsDown(BUTTON.SPRINT))
                {
                    data.OnShiftLeftClick(entity, hitPoint);
                }
                else if (input.IsDown(BUTTON.RELOAD))
                {
                    data.OnReloadClick(entity, hitPoint);
                }
                else
                {
                    data.OnLeftClick(entity, hitPoint);
                }
            }
            if (input.WasJustPressed(BUTTON.FIRE_SECONDARY))
            {
                if (input.IsDown(BUTTON.SPRINT))
                {
                    data.OnShiftRightClick(entity, hitPoint);
                }
                else
                {
                    data.OnRightClick(entity, hitPoint);
                }
            }
            if (input.WasJustReleased(BUTTON.FIRE_PRIMARY))
            {
                data.OnLeftRelease();
            }
            if (input.WasJustReleased(BUTTON.FIRE_SECONDARY))
            {
                data.OnRightRelease();
            }
            data.OnPlayerInput(entity, input);
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            OreResourceEntity node = entity as OreResourceEntity;
            if (node == null)
            {
                return;
            }

            node._hotSpot?.Kill();
        }

        private void NotLookingAtEntity(BasePlayer player)
        {
            UI.EntityInfoLabel.Text = "";
            UI.EntityInfoLabel.Refresh(player);
        }

        private void LookingAtEntity(BasePlayer player, BaseEntity entity)
        {
            UI.EntityInfoLabel.Text = $"{entity.ShortPrefabName}";
        }

        public static bool IsEditTool(Item item)
        {
            if (item == null)
            {
                return false;
            }

            return item.skin == ToolSkinID;
        }

        public static bool HasEditTool(BasePlayer player)
        {
            Item item = player.GetActiveItem();
            if (item == null)
            {
                return false;
            }

            return IsEditTool(item);
        }

        #region Entity Raycast

        //public static int EditToolLayer = LayerMask.GetMask("AI", "Construction", "Deployed", "Default", "Debris", "Ragdoll", "Tree", "Terrain", "World", "Vehicle Movement");
        public static int EditToolLayer = int.MaxValue;

        public static bool GetEntityLookingAt(BasePlayer player, out BaseEntity entity, out Vector3 hitPoint, float distance = 5f, bool announceOnNotFound = false)
        {
            entity = null;
            RaycastHit raycastHit;
            Ray ray = player.eyes.BodyRay();

            if (!Physics.Raycast(ray, out raycastHit, distance, EditToolLayer))
            {
                hitPoint = Vector3.zero;
                return false;
            }
            else
            {
                hitPoint = raycastHit.point;
                entity = raycastHit.GetEntity();
                if (entity != null)
                {
                    return true;
                }
            }

            if (announceOnNotFound)
            {
                player.IPlayer.Message(GetLangMessage("NotLookingAtEntity", player));
            }
            return true;
        }

        #endregion Entity Raycast

        [ChatCommand("edittool")]
        private void GiveEditTool_Command(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                return;
            }

            GiveEditTool(player);
        }

        [ConsoleCommand("edittool.switchmode")]
        private void SwitchEditToolMode_ConsoleCommand(ConsoleSystem.Arg args)
        {
            ToolPlayerData data = PlayerData.Get(args.Player());
            if (data == null)
            {
                return;
            }

            data.SwitchMode();
        }

        public void GiveEditTool(BasePlayer player)
        {
            Item item = ItemManager.CreateByPartialName(ToolItemShortname, 1);
            if (item == null)
            {
                PrintError("WARNING! Failed to create edit tool!");
                return;
            }

            item.skin = ToolSkinID;
            item.name = ToolName;
            player.GiveItem(item);
        }

        public enum ToolMode
        {
            None = 0,
            Transform = 1,
            Clone = 2,
            EditData = 3,
            Spawn = 4,
            Diguise = 5,
            Last
        }

        public class ToolPlayerData : PlayerDataBase
        {
            public ToolMode Mode = ToolMode.None;

            //public string SavedPrefabName = "";
            //private Vector3 SavedPrefabPosition;
            //private Quaternion SavedPrefabRotation;
            //private byte[] savedBytes;
            //private BuildingGrade grade;
            private BaseEntity selectedEntity;

            private Vector3 lastTransformPosition;
            private Vector3 transformOffset;
            private float TranslateDistance;
            private EntitySaver _entitySaver = new EntitySaver();
            private Quaternion _lastRotation;

            public void SwitchMode()
            {
                if (!Player.IsAdmin)
                {
                    if (!_plugin.permission.UserHasPermission(Player.UserIDString, permUse))
                    {
                        Mode = ToolMode.None;
                        return;
                    }
                }

                OnLeaveMode(Mode);
                int loops = 0;
                while (loops < (int)ToolMode.Last * 2)
                {
                    Mode++;
                    loops++;
                    if (Mode >= ToolMode.Last)
                    {
                        Mode = ToolMode.Transform;
                    }
                    if (Mode == ToolMode.EditData)
                    {
                        if (EntityPropertiesLoaded() == false)
                        {
                            continue;
                        }
                    }

                    if (Mode == ToolMode.Spawn)
                    {
                        continue;
                    }

                    if (Mode == ToolMode.Diguise)
                    {
                        if (DisguiseLoaded() == false)
                        {
                            continue;
                        }
                    }

                    //Permission check
                    if (!Player.IsAdmin)
                    {
                        if (!_plugin.permission.UserHasPermission(Player.UserIDString, $"edittool.{Mode.ToString().ToLower()}"))
                        {
                            continue;
                        }
                    }

                    OnEnterMode(Mode);
                    break;
                }
            }

            public void OnLeaveMode(ToolMode mode)
            {
                DeselectEntity();
            }

            public void OnEnterMode(ToolMode mode)
            {
                UI.SwitchToolMode(Player, Mode);
            }

            public void OnShiftRightClick(BaseEntity entity, Vector3 hitPoint)
            {
                switch (Mode)
                {
                    case ToolMode.Clone:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            SavePrefabName(entity, true);
                            break;
                        }
                    case ToolMode.EditData:
                        {
                            selectedEntity = entity;
                            break;
                        }
                }
            }

            public void OnShiftLeftClick(BaseEntity entity, Vector3 hitPoint)
            {
                switch (Mode)
                {
                    case ToolMode.Clone:
                        {
                            SpawnPrefab(hitPoint, true);
                            break;
                        }
                    case ToolMode.EditData:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            CloneEntityData(selectedEntity, entity);
                            break;
                        }
                }
            }

            public void OnLeftClick(BaseEntity entity, Vector3 hitPoint)
            {
                switch (Mode)
                {
                    case ToolMode.Clone:
                        {
                            SpawnPrefab(hitPoint, false);
                            break;
                        }
                    case ToolMode.Transform:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            SelectEntity(entity);
                            TranslateDistance = Vector3.Distance(hitPoint, Player.eyes.position);
                            transformOffset = hitPoint - selectedEntity.transform.position;
                            break;
                        }
                    case ToolMode.EditData:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            GameObject obj = new GameObject();
                            //obj.Identity();
                            //obj.SetActive(true);
                            //collider.bounds.SetMinMax(-bounds, bounds);
                            obj.layer = (int)Rust.Layer.Construction;
                            obj.transform.position = Player.transform.position;
                            //var rigid = obj.AddComponent<Rigidbody>();
                            //rigid.isKinematic = true;
                            //rigid.useGravity = false;
                            //rigid.detectCollisions = true;
                            BoxCollider collider = obj.AddComponent<BoxCollider>();
                            collider.size = new Vector3(3f, 3f, 3f);
                            //collider.isTrigger = false;
                            //collider.enabled = true;
                            obj.SetActive(false);
                            Debug(string.Join(",", obj.GetComponents<Component>().Select(x => x.GetType().ToString()).ToArray()));
                            //Vector3 bounds = new Vector3(3f,3f,3f);
                            //_plugin.Puts($"Added collider! {obj.transform.position} {Player.transform.position} {obj.transform.localScale}");
                            break;
                        }
                }
            }

            public void OnLeftRelease()
            {
                switch (Mode)
                {
                    case ToolMode.Transform:
                        {
                            if (selectedEntity == null)
                            {
                                return;
                            }

                            if (selectedEntity.GetComponent<Rigidbody>() != null)
                            {
                                Vector3 velocity = (selectedEntity.transform.position - lastTransformPosition);
                                Debug($"Setting release velocity {velocity}");
                                selectedEntity.SetVelocity(velocity * 20);
                                selectedEntity.GetComponent<Rigidbody>().useGravity = true;
                            }
                            Debug(string.Join(",", selectedEntity.GetComponents<Component>().Select(x => x.GetType().ToString()).ToArray()));
                            DeselectEntity();
                            break;
                        }
                }
            }

            public void OnRightRelease()
            {
            }

            public void OnRightClick(BaseEntity entity, Vector3 hitPoint)
            {
                switch (Mode)
                {
                    case ToolMode.Clone:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            SavePrefabName(entity, false);
                            break;
                        }
                    case ToolMode.EditData:
                        {
                            if (entity == null)
                            {
                                return;
                            }

                            StartEditingEntityData(Player, entity);
                            break;
                        }
                }
            }

            public void OnReloadClick(BaseEntity entity, Vector3 hitPoint)
            {
            }

            public void OnPlayerInput(BaseEntity entity, InputState input)
            {
                switch (Mode)
                {
                    case ToolMode.Transform:
                        {
                            if (input.WasJustPressed(BUTTON.FIRE_SECONDARY))
                            {
                                _lastRotation = entity.transform.rotation;
                                SelectEntity(entity);
                            }
                            if (input.WasJustReleased(BUTTON.FIRE_SECONDARY))
                            {
                                DeselectEntity();
                            }
                            float translateSpeed = 0.4f;
                            if (input.IsDown(BUTTON.SPRINT))
                            {
                                translateSpeed = 1.2f;
                            }
                            if (input.IsDown(BUTTON.USE))
                            {
                                TranslateDistance = Mathf.MoveTowards(TranslateDistance, 0, translateSpeed);
                            }
                            if (input.IsDown(BUTTON.RELOAD))
                            {
                                TranslateDistance = Mathf.MoveTowards(TranslateDistance, EditToolDistance, translateSpeed);
                            }
                            if (input.IsDown(BUTTON.FIRE_SECONDARY))
                            {
                                RotationTick(input);
                            }
                            else
                            {
                                TransformTick();
                            }
                            break;
                        }
                }
            }

            private void SelectEntity(BaseEntity entity)
            {
                selectedEntity = entity;
            }

            private void DeselectEntity()
            {
                //Handling in TransformTick and RotationTick as performance impact isn't too bad
                //TryUpdateBuildingBlock(selectedEntity);
                selectedEntity = null;
                lastTransformPosition = default(Vector3);
            }

            private void TryUpdateBuildingBlock(BaseEntity entity)
            {
                BuildingBlock block = entity as BuildingBlock;
                if (block == null)
                {
                    return;
                }

                block.UpdateSkin(true);
            }

            private void TransformTick()
            {
                if (selectedEntity == null)
                {
                    return;
                }

                //_plugin.Puts($"SyncPosition: {selectedEntity.syncPosition}");
                Rigidbody rigid = selectedEntity.GetComponent<Rigidbody>();
                //Disable rigid body's gravity, as they keep trying to fall when moved around
                if (rigid != null)
                {
                    rigid.useGravity = false;
                }
                lastTransformPosition = selectedEntity.transform.position;
                selectedEntity.transform.position = Player.eyes.BodyRay().origin + Player.eyes.BodyRay().direction * TranslateDistance - transformOffset;
                //Have to manually trigger building blocks to update their collider serverside
                TryUpdateBuildingBlock(selectedEntity);
                if (selectedEntity is AnimatedBuildingBlock)
                {
                    //Have to change entity flags for doors to update their position on client
                    //So just change a useless flag
                    //selectedEntity.SetFlag(BaseEntity.Flags.Open, !selectedEntity.HasFlag(BaseEntity.Flags.Open));
                }

                //Manually kill and respawn entities to make them update their position
                using (NetWrite write = Net.sv.StartWrite())
                {
                    write.PacketID(Message.Type.EntityDestroy);
                    write.UInt64(selectedEntity.net.ID.Value);
                    write.UInt8(0);
                    write.Send(new SendInfo(selectedEntity.net.group.subscribers));
                }
                
                selectedEntity.SendNetworkUpdateImmediate();
                if (selectedEntity is BuildingBlock)
                {
                    //Have to tell the client to update building block's position on client
                    //selectedEntity.ClientRPC(null, "RefreshSkin");
                }
            }

            private void RotationTick(InputState input)
            {
                float multiplier = 8f;
                if (selectedEntity == null)
                {
                    return;
                }

                Vector3 center = selectedEntity.CenterPoint();

                //This will be used to fix the entity rotating on the players look angle
                Vector3 eyeLeveled = Player.eyes.position;
                Vector3 centerLeveled = center;
                eyeLeveled.y = 0;
                centerLeveled.y = 0;
                Ray ray = new Ray(eyeLeveled, eyeLeveled - centerLeveled);

                Vector3 difference = (new Vector3((input.previous.aimAngles.x - input.current.aimAngles.x) * -1f,
                                                  (input.previous.aimAngles.y - input.current.aimAngles.y),
                                                   0)) * multiplier;
                selectedEntity.transform.RotateAround(center, Player.eyes.BodyRight(), (input.previous.aimAngles.x - input.current.aimAngles.x) * multiplier);
                selectedEntity.transform.RotateAround(center, Player.eyes.BodyUp(), (input.previous.aimAngles.y - input.current.aimAngles.y) * multiplier);
                float rollRotate = 0f;
                if (input.IsDown(BUTTON.USE))
                {
                    rollRotate = 2f;
                }
                if (input.IsDown(BUTTON.RELOAD))
                {
                    rollRotate = -2f;
                }
                if (input.IsDown(BUTTON.SPRINT))
                {
                    rollRotate *= 4f;
                }
                selectedEntity.transform.RotateAround(center, Player.eyes.BodyForward(), rollRotate);
                if (input.IsDown(BUTTON.DUCK))
                {
                    float rotMuli = 9f;
                    selectedEntity.transform.rotation = Quaternion.Euler(Mathf.Round(selectedEntity.transform.rotation.x * rotMuli) / rotMuli,
                                                                         Mathf.Round(selectedEntity.transform.rotation.y * rotMuli) / rotMuli,
                                                                         Mathf.Round(selectedEntity.transform.rotation.z * rotMuli) / rotMuli);
                }

                TryUpdateBuildingBlock(selectedEntity);
                //Manually kill and respawn entities to make them update their position
                using (NetWrite write = Net.sv.StartWrite())
                {
                    write.PacketID(Message.Type.EntityDestroy);
                    write.UInt64(selectedEntity.net.ID.Value);
                    write.UInt8(0);
                    write.Send(new SendInfo(selectedEntity.net.group.subscribers));
                }
                
                selectedEntity.SendNetworkUpdateImmediate();
            }

            private void SavePrefabName(BaseEntity entity, bool fullClone)
            {
                _entitySaver.SaveEntity(entity, fullClone);
            }

            private void SpawnPrefab(Vector3 position, bool fullClone)
            {
                _entitySaver.SpawnEntity(position, fullClone);
            }
        }

        public class EntitySaver
        {
            //public bool FullClone = false;
            private ulong _ownerID = 0;

            private string _prefabName = "";
            private Vector3 lastPos;
            private Quaternion _rotation;
            private byte[] savedBytes = null;
            private BuildingGrade.Enum _grade = BuildingGrade.Enum.None;
            private Vector3 velocity;

            public void SaveEntity(BaseEntity entity, bool fullClone)
            {
                _prefabName = entity.PrefabName;
                _rotation = entity.transform.rotation;
                lastPos = entity.transform.position;
                if (entity is BuildingBlock)
                {
                    _grade = (entity as BuildingBlock).grade;
                }
                if (!fullClone)
                {
                    savedBytes = null;
                    return;
                }

                savedBytes = entity.GetSaveCache().ToArray();
                if (entity.GetComponent<ServerProjectile>() != null)
                {
                    velocity = (Vector3)typeof(ServerProjectile).GetField("_currentVelocity", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public).GetValue(entity.GetComponent<ServerProjectile>());
                }
            }

            public void SpawnEntity(Vector3 position, bool fullClone)
            {
                if (_prefabName == "")
                {
                    return;
                }

                BaseEntity entity = GameManager.server.CreateEntity(_prefabName, position, _rotation);
                if (entity == null)
                {
                    _plugin.PrintError("SpawnPrefab Failed!");
                }
                if (fullClone)
                {
                    entity.PreServerLoad();
                }
                GameObject.Destroy(entity.GetComponent<Spawnable>());
                if (entity is BuildingBlock && _grade > BuildingGrade.Enum.None)
                {
                    (entity as BuildingBlock).grade = _grade;
                }
                entity.Spawn();
                if (entity is BuildingBlock && _grade > BuildingGrade.Enum.None)
                {
                    (entity as BuildingBlock).SetGrade(_grade);
                    (entity as BuildingBlock).Heal(entity.MaxHealth());
                }
                if (!fullClone)
                {
                    return;
                }

                if (savedBytes == null)
                {
                    return;
                }

                Entity entityData = Entity.Deserialize(savedBytes);
                BaseNetworkable.LoadInfo loadInfo = new BaseNetworkable.LoadInfo() { fromDisk = true };
                loadInfo.msg = entityData;
                entity.Load(loadInfo);
                entity.PostServerLoad();
                entity.transform.position = position;
                SetupEntityIDs(entity);
                if (entity.GetComponent<ServerProjectile>() != null)
                {
                    entity.GetComponent<ServerProjectile>().InitializeVelocity(velocity);
                }
                if (entity is Signage)
                {
                    entity.SendNetworkUpdate();
                }
            }

            private void SetupEntityIDs(BaseEntity entity)
            {
                if (entity is StorageContainer)
                {
                    SetupItemContainerIDs((entity as StorageContainer).inventory);
                }
                else if (entity is BasePlayer)
                {
                    BasePlayer player = entity as BasePlayer;
                    SetupItemContainerIDs(player.inventory.containerBelt);
                    SetupItemContainerIDs(player.inventory.containerMain);
                    SetupItemContainerIDs(player.inventory.containerWear);
                }
                else if (entity is DroppedItemContainer)
                {
                    SetupItemContainerIDs((entity as DroppedItemContainer).inventory);
                }
            }

            private void SetupItemContainerIDs(ItemContainer container)
            {
                container.uid = new ItemContainerId(Net.sv.TakeUID());
                foreach (Item item in container.itemList)
                {
                    SetupItem(item);
                }
            }

            private void SetupItem(Item item)
            {
                item.uid = new ItemId(Net.sv.TakeUID());
                if (item.contents != null)
                {
                    SetupItemContainerIDs(item.contents);
                }
                foreach (ItemMod mod in item.info.itemMods)
                {
                    mod.OnItemCreated(item);
                }
            }
        }

        public class UIManager
        {
            private UIImage Crosshair;
            public UILabel EntityInfoLabel;
            public UIBaseElement ToolUI;
            private UILabel ToolMode;

            public UIManager()
            {
                SetupUI_ToolUI();
                SetupUI_Crosshair();
            }

            public void Unload()
            {
                Crosshair?.HideAll();
                EntityInfoLabel?.HideAll();
                ToolMode?.HideAll();
            }

            private void SetupUI_Crosshair()
            {
                float dotSize = 0.007f * 0.20f;
                Crosshair = new UIImage(new Vector2(0.5f - dotSize, 0.5f - dotSize * 2), new Vector2(0.5f + dotSize, 0.5f + dotSize * 2), ToolUI);
                Crosshair.Image.Sprite = "assets/icons/circle_closed.png";
                EntityInfoLabel = new UILabel(new Vector2(0.4f, 0.50f), new Vector2(0.6f, 0.60f), "Entity", 12, "1 1 1 1", ToolUI, TextAnchor.MiddleCenter);
                EntityInfoLabel.AddOutline();
            }

            private void SetupUI_ToolUI()
            {
                ToolUI = new UIBaseElement(new Vector2(0, 0), new Vector2(1, 1));
                ToolUI.conditionalShow = delegate (BasePlayer player)
                {
                    Item item = player.GetActiveItem();
                    if (item == null)
                    {
                        return false;
                    }

                    return item.skin == ToolSkinID;
                };
                ToolMode = new UILabel(new Vector2(0.29f, 0.02f), new Vector2(0.39f, 0.12f), "Inactive", 16, "1 1 1 1", ToolUI, TextAnchor.MiddleRight);
                ToolMode.variableText = delegate (BasePlayer player)
                {
                    return $"{PlayerData.Get(player).Mode}";
                };
                ToolMode.AddOutline();
            }

            public void SwitchToolMode(BasePlayer player, ToolMode mode)
            {
                ToolMode.Refresh(player);
            }
        }

        #region Lang API

        public Dictionary<string, string> lang_en = new Dictionary<string, string>()
        {
            {"NotLookingAtEntity", "You aren't looking at an entity!" },
        };

        public static string GetLangMessage(string key, BasePlayer player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player.UserIDString);
        }

        public static string GetLangMessage(string key, ulong player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player.ToString());
        }

        public static string GetLangMessage(string key, string player)
        {
            return _plugin.lang.GetMessage(key, _plugin, player);
        }

        #endregion Lang API

        #region Entity Properties Integration

        [PluginReference]
        private RustPlugin EntityProperties;

        public static bool EntityPropertiesLoaded()
        {
            if (_plugin.EntityProperties == null)
            {
                return false;
            }

            return _plugin.EntityProperties.IsLoaded;
        }

        public static void StartEditingEntityData(BasePlayer player, BaseEntity entity)
        {
            if (!EntityPropertiesLoaded())
            {
                return;
            }

            _plugin.EntityProperties.CallHook("StartEditingEntity", player, entity);
        }

        public static void StopEditingEntityData(BasePlayer player)
        {
            if (!EntityPropertiesLoaded())
            {
                return;
            }

            _plugin.EntityProperties.CallHook("StopEditingEntity", player);
        }

        public static void CloneEntityData(BaseEntity source, BaseEntity target)
        {
            if (!EntityPropertiesLoaded())
            {
                return;
            }

            _plugin.EntityProperties.CallHook("CloneEntitySettings", source, target);
        }

        #endregion Entity Properties Integration

        #region Disguise Integration

        [PluginReference]
        private RustPlugin Disguise;

        public static bool DisguiseLoaded()
        {
            if (_plugin.Disguise == null)
            {
                return false;
            }

            return _plugin.Disguise.IsLoaded;
        }

        #endregion Disguise Integration

        #region Error Printing

        public static bool Debugging = true;

        public static void Debug(string format, params object[] args)
        {
            if (!Debugging)
            {
                return;
            }

            _plugin.Puts(format, args);
        }

        public static void Debug(object obj)
        {
            if (!Debugging)
            {
                return;
            }

            _plugin.Puts(obj.ToString());
        }

        public static void Error(string format, params object[] args)
        {
            _plugin.PrintError(format, args);
        }

        #endregion Error Printing

        #region PlayerData

        public class PlayerDataBase
        {
            [JsonIgnore]
            public BasePlayer Player { get; set; }

            public string UserID { get; set; } = "";

            public PlayerDataBase()
            {
            }

            public PlayerDataBase(BasePlayer player)
            {
                UserID = player.UserIDString;
                Player = player;
            }
        }

        public class PlayerDataController<T> where T : PlayerDataBase
        {
            [JsonProperty(Required = Required.Always)]
            private Dictionary<string, T> playerData { get; set; } = new Dictionary<string, T>();

            public T Get(string identifer)
            {
                T data;
                if (!playerData.TryGetValue(identifer, out data))
                {
                    data = Activator.CreateInstance<T>();
                    playerData[identifer] = data;
                }
                return data;
            }

            public T Get(ulong userID)
            {
                return Get(userID.ToString());
            }

            public T Get(BasePlayer player)
            {
                T data = Get(player.UserIDString);
                data.Player = player;
                return data;
            }
        }

        #endregion PlayerData

        #region Rust Classes In JSON

        public class JSONSpawnPoint
        {
            public float xPos { get; set; }
            public float yPos { get; set; }
            public float zPos { get; set; }
            public float xRot { get; set; }
            public float yRot { get; set; }
            public float zRot { get; set; }
            public float wRot { get; set; }

            public BasePlayer.SpawnPoint ToSpawnPoint()
            {
                BasePlayer.SpawnPoint newSpawn = new BasePlayer.SpawnPoint();

                newSpawn.pos.x = xPos;
                newSpawn.pos.y = yPos;
                newSpawn.pos.z = zPos;
                newSpawn.rot.x = xRot;
                newSpawn.rot.y = yRot;
                newSpawn.rot.z = zRot;
                newSpawn.rot.w = wRot;

                return newSpawn;
            }

            [JsonIgnore]
            public Vector3 Position
            {
                get { return new Vector3(xPos, yPos, zPos); }
                set { xPos = value.x; yPos = value.y; zPos = value.z; }
            }

            [JsonIgnore]
            public Quaternion Rotation
            {
                get { return new Quaternion(xRot, yRot, zRot, wRot); }
                set { xRot = value.x; yRot = value.y; zRot = value.z; wRot = value.w; }
            }

            public JSONSpawnPoint()
            {
            }

            public JSONSpawnPoint(Vector3 position, Quaternion rot)
            {
                Position = position;
                Rotation = rot;
            }
        }

        public class JSONEntity
        {
            public float xPos { get; set; }
            public float yPos { get; set; }
            public float zPos { get; set; }

            public float xRot { get; set; }
            public float yRot { get; set; }
            public float zRot { get; set; }
            public float wRot { get; set; }

            public string prefabName { get; set; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BuildingGrade.Enum grade { get; set; }

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int AssignedBaseID;

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong OwnerID = 0;

            [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
            public JSONStorageContainer Inventory;

            [JsonIgnore]
            public Vector3 Position
            {
                get { return new Vector3(xPos, yPos, zPos); }
            }

            [JsonIgnore]
            public Quaternion Rotation
            {
                get { return new Quaternion(xRot, yRot, zRot, wRot); }
            }

            [JsonIgnore]
            public BaseEntity Entity;

            public JSONEntity(BaseEntity entity) : this(entity, entity.transform.position, entity.transform.rotation)
            {
            }

            public JSONEntity(BaseEntity entity, Vector3 position, Quaternion rotation)
            {
                this.xPos = position.x;
                this.yPos = position.y;
                this.zPos = position.z;
                this.xRot = rotation.x;
                this.yRot = rotation.y;
                this.zRot = rotation.z;
                this.wRot = rotation.w;
                this.prefabName = entity.PrefabName;
                OwnerID = entity.OwnerID;
                if (entity.GetType() == typeof(BuildingBlock))
                {
                    grade = ((BuildingBlock)entity).grade;
                }
            }

            public JSONEntity()
            {
            }

            private BaseEntity CreateEntity(bool floating = true)
            {
                GameObject obj = GameManager.server.CreatePrefab(prefabName, Position, Rotation, false);
                if (obj == null)
                {
                    return null;
                }

                BaseEntity entity = obj.GetComponent<BaseEntity>();

                GameObject.Destroy(obj.GetComponent<Spawnable>());

                obj.AwakeFromInstantiate();

                entity.OwnerID = OwnerID;

                Entity = entity;

                PreSpawn(entity);

                return entity;
            }

            public void PreSpawn(BaseEntity entity)
            {
                if (entity is BuildingBlock)
                {
                    (entity as BuildingBlock).grade = grade;
                }
            }

            public void PostSpawn(BaseEntity entity)
            {
                BaseCombatEntity combat = entity as BaseCombatEntity;
                if (combat != null)
                {
                    if (combat.healthFraction < 1f)
                    {
                        combat.SetHealth(entity.MaxHealth());
                    }
                }
            }

            public BaseEntity Spawn()
            {
                BaseEntity ent = CreateEntity(false);
                ent.Spawn();
                PostSpawn(ent);
                return ent;
            }

            public bool IsEntity(BaseEntity entity)
            {
                if (entity.transform.position != Position)
                {
                    return false;
                }

                if (entity.transform.rotation != Rotation)
                {
                    return false;
                }

                if (entity.PrefabName != prefabName)
                {
                    return false;
                }

                if (entity.OwnerID != OwnerID)
                {
                    return false;
                }

                return true;
            }
        }

        public class JSONStorageContainer
        {
            public int MaxRefills = -1; //-1 For unlimited
            public bool Locked = true;
            public bool PerPlayer = false;

            public JSONItemContainer SavedInventory = new JSONItemContainer();
        }

        public class JSONItemAmount
        {
            public string shortname = "";
            public int amount = 0;

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong skinID = 0;

            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int slot = 0;

            public JSONItemAmount()
            {
            }

            public JSONItemAmount(string shortname, int amount = 1, ulong skinID = 0)
            {
                this.shortname = shortname;
                this.amount = amount;
                this.skinID = skinID;
            }

            public JSONItemAmount(ItemAmount itemAmount) : this(itemAmount.itemDef.shortname, (int)itemAmount.amount)
            {
            }

            public JSONItemAmount(Item item, int slot = 0) : this(item.info.shortname, item.amount, item.skin)
            {
                this.slot = slot + 1;
            }

            public int ItemID()
            {
                ItemDefinition item = ItemManager.itemList.FirstOrDefault(x => x.shortname == shortname);
                if (item == null)
                {
                    return -1;
                }

                return item.itemid;
            }

            public Item CreateItem()
            {
                Item item = ItemManager.CreateByPartialName(shortname, amount);
                if (item == null)
                {
                    return null;
                }

                item.skin = skinID;
                return item;
            }

            public void GiveToPlayer(BasePlayer player)
            {
                Item item = CreateItem();
                if (item != null)
                {
                    player.GiveItem(item);
                }
            }

            public void AddToContainer(ItemContainer container)
            {
                Item item = CreateItem();
                item.MoveToContainer(container, slot - 1, false);
            }
        }

        public class JSONItemContainer
        {
            public List<JSONItemAmount> Items = new List<JSONItemAmount>();

            public JSONItemContainer()
            {
            }

            public JSONItemContainer(ItemContainer container)
            {
                List<JSONItemAmount> items = new List<JSONItemAmount>();
                for (int i = 0; i < container.capacity; i++)
                {
                    Item item = container.GetSlot(i);
                    items.Add(new JSONItemAmount(item, i));
                }
                Items = items;
            }

            public void Load(ItemContainer container)
            {
                container.Clear();
                foreach (JSONItemAmount item in Items)
                {
                    item.AddToContainer(container);
                }
            }
        }

        #endregion Rust Classes In JSON

        #region Configuration Files

        public enum ConfigLocation
        {
            Data = 0,
            Config = 1,
            Logs = 2,
            Plugins = 3,
            Lang = 4,
            Custom = 5,
        }

        public class JSONFile<Type> where Type : class
        {
            private DynamicConfigFile _file;
            public string _name { get; set; }
            public Type Instance { get; set; }
            private ConfigLocation _location { get; set; }
            private string _path { get; set; }
            public bool SaveOnUnload = false;
            public bool Compressed = false;

            public JSONFile(string name, ConfigLocation location = ConfigLocation.Data, string path = null, string extension = ".json", bool saveOnUnload = false)
            {
                SaveOnUnload = saveOnUnload;
                _name = name.Replace(".json", "");
                _location = location;
                switch (location)
                {
                    case ConfigLocation.Data:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.DataDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Config:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.ConfigDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Logs:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LogDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Lang:
                        {
                            _path = $"{Oxide.Core.Interface.Oxide.LangDirectory}/{name}{extension}";
                            break;
                        }
                    case ConfigLocation.Custom:
                        {
                            _path = $"{path}/{name}{extension}";
                            break;
                        }
                }
                _file = new DynamicConfigFile(_path);
                Init();
            }

            public virtual void Init()
            {
                _plugin.OnRemovedFromManager.Add(new Action<Plugin, PluginManager>(Unload));
                Load();
            }

            public virtual void Load()
            {
                if (Compressed)
                {
                    LoadCompressed();
                    return;
                }

                if (!_file.Exists())
                {
                    Save();
                }
                Instance = _file.ReadObject<Type>();
                if (Instance == null)
                {
                    Instance = Activator.CreateInstance<Type>();
                    Save();
                }
                return;
            }

            private void LoadCompressed()
            {
                string str = _file.ReadObject<string>();
                if (str == null || str == "")
                {
                    Instance = Activator.CreateInstance<Type>();
                    return;
                }

                using (MemoryStream compressedStream = new MemoryStream(Convert.FromBase64String(str)))
                using (GZipStream zipStream = new GZipStream(compressedStream, CompressionMode.Decompress))
                using (MemoryStream resultStream = new MemoryStream())
                {
                    byte[] buffer = new byte[4096];
                    int read;

                    while ((read = zipStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        resultStream.Write(buffer, 0, read);
                    }

                    Instance = JsonConvert.DeserializeObject<Type>(Encoding.UTF8.GetString(resultStream.ToArray()));
                }
            }

            public virtual void Save()
            {
                if (Compressed)
                {
                    SaveCompressed();
                    return;
                }

                _file.WriteObject(Instance);
                return;
            }

            private void SaveCompressed()
            {
                using (MemoryStream stream = new MemoryStream())
                {
                    using (GZipStream zipStream = new GZipStream(stream, CompressionMode.Compress))
                    {
                        byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(Instance));
                        zipStream.Write(bytes, 0, bytes.Length);
                        zipStream.Close();
                        _file.WriteObject(Convert.ToBase64String(stream.ToArray()));
                    }
                }
            }

            public virtual void Reload()
            {
                Load();
            }

            private void Unload(Plugin sender, PluginManager manager)
            {
                if (SaveOnUnload)
                {
                    Save();
                }
            }
        }

        #endregion Configuration Files

        #region Jake's UI Framework

        private Dictionary<string, UICallbackComponent> UIButtonCallBacks { get; set; } = new Dictionary<string, UICallbackComponent>();

        private void OnButtonClick(ConsoleSystem.Arg arg)
        {
            UICallbackComponent button;
            if (UIButtonCallBacks.TryGetValue(arg.cmd.Name, out button))
            {
                button.InvokeCallback(arg);
                return;
            }

            Puts("Unknown button command: {0}", arg.cmd.Name);
        }

        public class UIElement : UIBaseElement
        {
            public CuiElement Element { get; protected set; }
            public UIOutline Outline { get; set; }
            public CuiRectTransformComponent transform { get; protected set; }

            public float FadeOut
            {
                get
                {
                    return Element == null ? _fadeOut : Element.FadeOut;
                }
                set
                {
                    if (Element != null)
                    {
                        Element.FadeOut = value;
                    }
                    _fadeOut = value;
                }
            }

            private float _fadeOut = 0f;

            public string Name { get { return Element.Name; } }

            public UIElement(UIBaseElement parent = null) : base(parent)
            {
            }

            public UIElement(Vector2 position, float width, float height, UIBaseElement parent = null) : this(position, new Vector2(position.x + width, position.y + height), parent)
            {
            }

            public UIElement(Vector2 min, Vector2 max, UIBaseElement parent = null) : base(min, max, parent)
            {
                transform = new CuiRectTransformComponent();
                Element = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = this._parent == null ? this.Parent : this._parent.Parent,
                    Components =
                        {
                            transform,
                        },
                    FadeOut = _fadeOut,
                };
                UpdatePlacement();

                Init();
            }

            public void AddOutline(string color = "0 0 0 1", string distance = "1 -1")
            {
                Outline = new UIOutline(color, distance);
                Element.Components.Add(Outline.component);
            }

            public virtual void Init()
            {
            }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (this is UIElement)
                {
                    if (!CanShow(player))
                    {
                        _shouldShow = false;
                        return;
                    }
                    _shouldShow = true;

                    if (conditionalSize != null)
                    {
                        Vector2 returnSize = conditionalSize.Invoke(player);
                        if (returnSize != null)
                        {
                            SetSize(returnSize.x, returnSize.y);
                        }
                    }

                    if (conditionalPosition != null)
                    {
                        Vector2 returnPos = conditionalPosition.Invoke(player);
                        if (returnPos != null)
                        {
                            SetPosition(returnPos.x, returnPos.y);
                        }
                    }
                }
                if (AddPlayer(player))
                {
                    SafeAddUi(player, Element);
                }
                base.Show(player, children);
            }

            public override void Hide(BasePlayer player, bool children = true)
            {
                base.Hide(player, children);
                if (RemovePlayer(player))
                {
                    SafeDestroyUi(player, Element);
                }
            }

            public override void UpdatePlacement()
            {
                base.UpdatePlacement();
                if (transform != null)
                {
                    transform.AnchorMin = $"{globalPosition.x} {globalPosition.y}";
                    transform.AnchorMax = $"{globalPosition.x + globalSize.x} {globalPosition.y + globalSize.y}";
                }
                //RefreshAll();
            }

            public void SetPositionAndSize(CuiRectTransformComponent trans)
            {
                transform.AnchorMin = trans.AnchorMin;
                transform.AnchorMax = trans.AnchorMax;

                //_plugin.Puts($"POSITION [{transform.AnchorMin},{transform.AnchorMax}]");

                RefreshAll();
            }

            public void SetParent(UIElement element)
            {
                Element.Parent = element.Element.Name;
                UpdatePlacement();
            }

            public void SetParent(string parent)
            {
                Element.Parent = parent;
                Parent = parent;
            }
        }

        public class UIButton : UIElement, UICallbackComponent
        {
            public CuiButtonComponent buttonComponent { get; private set; }
            public CuiTextComponent textComponent { get; private set; }
            public UILabel Label { get; set; }
            private string _textColor { get; set; }
            private string _buttonText { get; set; }
            public string Text { set { textComponent.Text = value; } }
            public Func<BasePlayer, string> variableText { get; set; }

            public Action<ConsoleSystem.Arg> onCallback;

            private int _fontSize;

            public UIButton(Vector2 min = default(Vector2), Vector2 max = default(Vector2), string buttonText = "", string buttonColor = "0 0 0 0.85", string textColor = "1 1 1 1", int fontSize = 15, UIBaseElement parent = null) : base(min, max, parent)
            {
                buttonComponent = new CuiButtonComponent();

                _fontSize = fontSize;
                _textColor = textColor;
                _buttonText = buttonText;

                buttonComponent.Command = CuiHelper.GetGuid();
                buttonComponent.Color = buttonColor;

                Element.Components.Insert(0, buttonComponent);

                _plugin.cmd.AddConsoleCommand(buttonComponent.Command, _plugin, "OnButtonClick");

                _plugin.UIButtonCallBacks[buttonComponent.Command] = this;

                Label = new UILabel(new Vector2(0, 0), new Vector2(1, 1), fontSize: _fontSize, parent: this);

                textComponent = Label.text;

                Label.text.Align = TextAnchor.MiddleCenter;
                Label.text.Color = _textColor;
                Label.Text = _buttonText;
                Label.text.FontSize = _fontSize;
            }

            public UIButton(Vector2 position, float width, float height, string buttonText = "", string buttonColor = "0 0 0 0.85", string textColor = "1 1 1 1", int fontSize = 15, UIBaseElement parent = null) : this(position, new Vector2(position.x + width, position.y + height), buttonText, buttonColor, textColor, fontSize, parent)
            {
            }

            public override void Init()
            {
                base.Init();
            }

            public void AddChatCommand(string fullCommand)
            {
                if (fullCommand == null)
                {
                    return;
                }
                onCallback += (arg) =>
                {
                    arg.Player().IPlayer.Command($"chat.say \"/{fullCommand}\"");
                };
            }

            public void AddCallback(Action<BasePlayer> callback)
            {
                if (callback == null)
                {
                    return;
                }
                onCallback += (args) => { callback(args.Player()); };
            }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (variableText != null)
                {
                    try
                    {
                        Text = variableText.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UIButton.variableText failed!\n{ex}");
                    }
                }
                base.Show(player, children);
            }

            public void InvokeCallback(ConsoleSystem.Arg args)
            {
                if (onCallback == null)
                {
                    return;
                }

                onCallback.Invoke(args);
            }
        }

        public class UIBackgroundText : UIPanel
        {
            public UILabel Label;

            public UIBackgroundText(Vector2 min = default(Vector2), Vector2 max = default(Vector2), UIBaseElement parent = null, string backgroundColor = "0 0 0 0.85", string labelText = "", int fontSize = 12, string fontColor = "1 1 1 1", TextAnchor alignment = TextAnchor.MiddleCenter) : base(min, max, parent)
            {
                Label = new UILabel(new Vector2(0, 0), new Vector2(1, 1), labelText, fontSize, fontColor, parent, alignment);
            }
        }

        public class UILabel : UIElement
        {
            public CuiTextComponent text { get; private set; }

            public UILabel(Vector2 min = default(Vector2), Vector2 max = default(Vector2), string labelText = "", int fontSize = 12, string fontColor = "1 1 1 1", UIBaseElement parent = null, TextAnchor alignment = TextAnchor.MiddleCenter) : base(min, max, parent)
            {
                if (min == Vector2.zero && max == Vector2.zero)
                {
                    max = Vector2.one;
                }

                text = new CuiTextComponent();

                text.Text = labelText;
                ColorString = fontColor;
                text.Align = alignment;
                text.FontSize = fontSize;

                Element.Components.Insert(0, text);
            }

            public UILabel(Vector2 min, float width, float height, string labelText = "", int fontSize = 12, string fontColor = "1 1 1 1", UIBaseElement parent = null, TextAnchor alignment = TextAnchor.MiddleCenter) : this(min, new Vector2(min.x + width, min.y + height), labelText, fontSize, fontColor, parent, alignment)
            {
            }

            public string Text { set { if (value == null) { text.Text = ""; } else { text.Text = value; } text.Text = value; } } //I love single line statments
            public TextAnchor Allign { set { text.Align = value; } }
            public Color Color { set { text.Color = value.ToString(); } }
            public string ColorString { set { text.Color = value.Replace("f", ""); } } //Prevent me from breaking UI with 0.1f instead of 0.1

            public Func<BasePlayer, string> variableText { get; set; }
            public Func<BasePlayer, string> variableFontColor { get; set; }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (variableText != null)
                {
                    try
                    {
                        Text = variableText.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UILabel.variableText failed!\n{ex}");
                    }
                }
                if (variableFontColor != null)
                {
                    try
                    {
                        ColorString = variableFontColor.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UILabel.variableFontColor failed!\n{ex}");
                    }
                }
                base.Show(player, children);
            }

            public override void Init()
            {
                base.Init();

                if (_parent != null)
                {
                    if (_parent is UIButton)
                    {
                        Element.Parent = (_parent as UIButton).Name;
                        transform.AnchorMin = $"{localPosition.x} {localPosition.y}";
                        transform.AnchorMax = $"{localPosition.x + localSize.x} {localPosition.y + localSize.y}";
                    }
                }
            }
        }

        public class UIImageBase : UIElement
        {
            public UIImageBase(Vector2 min, Vector2 max, UIBaseElement parent) : base(min, max, parent)
            {
            }

            private CuiNeedsCursorComponent needsCursor { get; set; }

            private bool requiresFocus { get; set; }

            public bool CursorEnabled
            {
                get
                {
                    return requiresFocus;
                }
                set
                {
                    if (value)
                    {
                        needsCursor = new CuiNeedsCursorComponent();
                        Element.Components.Add(needsCursor);
                    }
                    else
                    {
                        Element.Components.Remove(needsCursor);
                    }

                    requiresFocus = value;
                }
            }
        }

        public class UIPanel : UIImageBase
        {
            private CuiImageComponent panel;

            public string Color { get { return panel.Color; } set { panel.Color = value; } }
            public string Material { get { return panel.Material; } set { panel.Material = value; } }

            public Func<BasePlayer, string> variableColor { get; set; }

            public UIPanel(Vector2 min, Vector2 max, UIBaseElement parent = null, string color = "0 0 0 0.85") : base(min, max, parent)
            {
                panel = new CuiImageComponent
                {
                    Color = color,
                };

                Element.Components.Insert(0, panel);
            }

            public UIPanel(Vector2 position, float width, float height, UIBaseElement parent = null, string color = "0 0 0 .85") : this(position, new Vector2(position.x + width, position.y + height), parent, color)
            {
            }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (variableColor != null)
                {
                    try
                    {
                        panel.Color = variableColor.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UIPanel.variableColor failed!\n{ex}");
                    }
                }
                base.Show(player, children);
            }
        }

        public class UIButtonContainer : UIPanel
        {
            private float _padding;
            private float _buttonHeight;
            private string _buttonColor;

            private List<UIButton> buttons = new List<UIButton>();

            public UIButtonContainer(Vector2 min, Vector2 max, UIBaseElement parent, string bgColor, float buttonHeight, float padding, string buttonColor = "0 0 0 0.85") : base(min, max, parent, bgColor)
            {
                _padding = padding;
                _buttonHeight = buttonHeight;
                _buttonColor = buttonColor;
            }

            public UIButton AddButton(string text, int fontSize, string textColor = "1 1 1 1", string buttonColor = "", Action<BasePlayer> callback = null)
            {
                if (buttonColor == "")
                {
                    buttonColor = _buttonColor;
                }
                float max = 1f - buttons.Count * _padding - buttons.Count * _buttonHeight;
                UIButton button = new UIButton(new Vector2(0f, max - _buttonHeight), new Vector2(1f, max), text, buttonColor, textColor, fontSize, this);
                if (callback != null)
                {
                    button.AddCallback(callback);
                }
                buttons.Add(button);
                return button;
            }
        }

        public class UIPagedElements : UIBaseElement
        {
            private UIButton nextPage { get; set; }
            private UIButton prevPage { get; set; }
            private float _elementHeight { get; set; }
            private float _elementSpacing { get; set; }
            private int _elementWidth { get; set; }
            private Dictionary<BasePlayer, int> ElementIndex = new Dictionary<BasePlayer, int>();

            private List<UIBaseElement> Elements = new List<UIBaseElement>();

            public UIPagedElements(Vector2 min, Vector2 max, float elementHeight, float elementSpacing, UIBaseElement parent = null, int elementWidth = 1) : base(min, max, parent)
            {
                _elementHeight = elementHeight;
                _elementSpacing = elementSpacing;
                _elementWidth = elementWidth;
            }

            public void NewElement(UIBaseElement element)
            {
                SetParent(this);
                Elements.Add(element);
            }

            public void NewElements(IEnumerable<UIBaseElement> elements)
            {
                foreach (UIBaseElement element in elements)
                {
                    SetParent(this);
                }
                Elements.AddRange(elements);
            }

            public override void Show(BasePlayer player, bool showChildren = true)
            {
                foreach (UIBaseElement element in Elements)
                {
                    element.Hide(player);
                }
                int elements = Mathf.FloorToInt((1f - (_elementSpacing * 2)) / (_elementHeight + _elementSpacing));
                int index = 0;
                ElementIndex.TryGetValue(player, out index);
                for (int i = index; i < elements; i++)
                {
                    //_plugin.Puts($"Index is {index}");
                    if (i >= Elements.Count)
                    {
                        break;
                    }
                    UIBaseElement element = Elements[i];
                    element.SetPosition(0f, 1f - (_elementHeight * (i + 1)) - (_elementWidth * (i + 1)));
                    element.SetSize(1f, _elementHeight);
                    element.Show(player);
                    //_plugin.Puts($"Element at {element.localPosition} {element.localSize}");
                }
                base.Show(player, showChildren);
            }

            public override void Hide(BasePlayer player, bool hideChildren = true)
            {
                base.Hide(player, hideChildren);
                foreach (UIBaseElement element in Elements)
                {
                    element.Hide(player);
                }
            }
        }

        public class UIButtonConfiguration
        {
            public string ButtonName { get; set; }
            public string ButtonCommand { get; set; }
            public string ButtonColor { get; set; }
            public Action<BasePlayer> callback { get; set; }
        }

        public class UIImage : UIImageBase
        {
            public CuiImageComponent Image { get; private set; }
            public string Sprite { get { return Image.Sprite; } set { Image.Sprite = value; } }
            public string Material { get { return Image.Material; } set { Image.Material = value; } }
            public string PNG { get { return Image.Png; } set { Image.Png = value; } }

            public UIImage(Vector2 min, Vector2 max, UIBaseElement parent = null) : base(min, max, parent)
            {
                Image = new CuiImageComponent();
                Element.Components.Insert(0, Image);
            }

            public UIImage(Vector2 position, float width, float height, UIBaseElement parent = null) : this(position, new Vector2(position.x + width, position.y + height), parent)
            {
            }

            public Func<BasePlayer, string> variableSprite { get; set; }
            public Func<BasePlayer, string> variablePNG { get; set; }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (variableSprite != null)
                {
                    try
                    {
                        Image.Sprite = variableSprite.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UIImage.variableSprite failed!\n{ex}");
                    }
                }
                if (variablePNG != null)
                {
                    try
                    {
                        Image.Png = variablePNG.Invoke(player);
                    }
                    catch (Exception ex)
                    {
                        _plugin.Puts($"UIImage.variablePNG failed!\n{ex}");
                    }
                }
                base.Show(player, children);
            }
        }

        public class UIRawImage : UIImageBase
        {
            public CuiRawImageComponent Image { get; private set; }

            public string Material { get { return Image.Material; } set { Image.Material = value; } }
            public string Sprite { get { return Image.Sprite; } set { Image.Sprite = value; } }
            public string PNG { get { return Image.Png; } set { Image.Png = value; } }
            public string Color { get { return Image.Color; } set { Image.Color = value; } }

            public UIRawImage(Vector2 position, float width, float height, UIBaseElement parent = null, string url = null) : this(position, new Vector2(position.x + width, position.y + height), parent, url)
            {
            }

            public UIRawImage(Vector2 min, Vector2 max, UIBaseElement parent = null, string url = null) : base(min, max, parent)
            {
                Image = new CuiRawImageComponent()
                {
                    Url = url,
                    Sprite = "assets/content/textures/generic/fulltransparent.tga"
                };

                Element.Components.Insert(0, Image);
            }

            public Func<BasePlayer, string> variablePNG { get; set; }

            public Func<BasePlayer, string> variableURL { get; set; }

            public Func<BasePlayer, string> variablePNGURL { get; set; }

            public override void Show(BasePlayer player, bool children = true)
            {
                if (variablePNGURL != null)
                {
                    string url = variablePNGURL.Invoke(player);
                    if (string.IsNullOrEmpty(url))
                    {
                        Image.Png = null;
                        Image.Url = null;
                    }
                    ulong num;
                    if (ulong.TryParse(url, out num))
                    {
                        Image.Png = url;
                        Image.Url = null;
                    }
                    else
                    {
                        Image.Png = null;
                        Image.Url = url;
                    }
                }
                else
                {
                    if (variablePNG != null)
                    {
                        Image.Png = variablePNG.Invoke(player);
                        if (string.IsNullOrEmpty(Image.Png))
                        {
                            Image.Png = null;
                        }
                    }
                    if (variableURL != null)
                    {
                        Image.Url = variableURL.Invoke(player);
                        if (string.IsNullOrEmpty(Image.Url))
                        {
                            Image.Url = null;
                        }
                    }
                }

                base.Show(player, children);
            }
        }

        public class UIBaseElement
        {
            public Vector2 localPosition { get; set; } = new Vector2();
            public Vector2 localSize { get; set; } = new Vector2();
            public Vector2 globalSize { get; set; } = new Vector2();
            public Vector2 globalPosition { get; set; } = new Vector2();
            public HashSet<BasePlayer> players { get; set; } = new HashSet<BasePlayer>();
            public UIBaseElement _parent { get; set; }
            public HashSet<UIBaseElement> children { get; set; } = new HashSet<UIBaseElement>();
            public Vector2 min { get { return localPosition; } }
            public Vector2 max { get { return localPosition + localSize; } }
            public string Parent { get; set; } = "Hud.Menu";
            public bool _shouldShow = true;

            public Func<BasePlayer, bool> conditionalShow { get; set; }
            public Func<BasePlayer, Vector2> conditionalSize { get; set; }
            public Func<BasePlayer, Vector2> conditionalPosition { get; set; }

            public UIBaseElement(UIBaseElement parent = null)
            {
                this._parent = parent;
            }

            public UIBaseElement(Vector2 min, Vector2 max, UIBaseElement parent = null) : this(parent)
            {
                localPosition = min;
                localSize = max - min;
                SetParent(parent);
                UpdatePlacement();
            }

            public UIBaseElement(Vector2 min, float width, float height, UIBaseElement parent = null) : this(min, new Vector2(min.x + width, min.y + height), parent)
            {
            }

            public void AddElement(UIBaseElement element)
            {
                if (element == this)
                {
                    _plugin.Puts("[UI FRAMEWORK] WARNING: AddElement() trying to add self as parent!");
                    return;
                }

                if (!children.Contains(element))
                {
                    children.Add(element);
                }
            }

            public void RemoveElement(UIBaseElement element)
            {
                children.Remove(element);
            }

            public void Refresh(BasePlayer player)
            {
                Hide(player);
                Show(player);
            }

            public bool AddPlayer(BasePlayer player)
            {
                if (!players.Contains(player))
                {
                    players.Add(player);
                    return true;
                }

                foreach (UIBaseElement child in children)
                {
                    child.AddPlayer(player);
                }

                return false;
            }

            public bool RemovePlayer(BasePlayer player)
            {
                return players.Remove(player);
            }

            public void Show(IEnumerable<BasePlayer> players)
            {
                foreach (BasePlayer player in players.ToList())
                {
                    Show(player);
                }
            }

            public virtual void SetParent(UIBaseElement parent)
            {
                if (parent != null && this != parent)
                {
                    parent.AddElement(this);
                }
                _parent = parent;
            }

            public virtual void Hide(BasePlayer player, bool hideChildren = true)
            {
                foreach (UIBaseElement child in children)
                {
                    child.Hide(player, hideChildren);
                }

                if (GetType() == typeof(UIBaseElement))
                {
                    RemovePlayer(player);
                }
            }

            public void Hide(IEnumerable<BasePlayer> players)
            {
                foreach (BasePlayer player in players.ToList())
                {
                    Hide(player);
                }
            }

            public virtual bool Toggle(BasePlayer player)
            {
                if (players.Contains(player))
                {
                    Hide(player);
                    return false;
                }

                Show(player);
                return true;
            }

            public virtual void Show(BasePlayer player, bool showChildren = true)
            {
                if (player == null || player.gameObject == null)
                {
                    players.Remove(player);
                    return;
                }

                if (GetType() == typeof(UIBaseElement))
                {
                    if (!CanShow(player))
                    {
                        _shouldShow = false;
                        return;
                    }
                    _shouldShow = true;

                    if (conditionalSize != null)
                    {
                        Vector2 returnSize = conditionalSize.Invoke(player);
                        if (returnSize != null)
                        {
                            SetSize(returnSize.x, returnSize.y);
                        }
                    }

                    if (conditionalPosition != null)
                    {
                        Vector2 returnPos = conditionalPosition.Invoke(player);
                        if (returnPos != null)
                        {
                            SetPosition(returnPos.x, returnPos.y);
                        }
                    }

                    AddPlayer(player);
                }

                foreach (UIBaseElement child in children)
                {
                    child.Show(player, showChildren);
                }
            }

            public bool CanShow(BasePlayer player)
            {
                if (_parent != null)
                {
                    if (!_parent.CanShow(player))
                    {
                        return false;
                    }
                }

                if (conditionalShow == null)
                {
                    return true;
                }

                if (player == null)
                {
                    return false;
                }

                if (player.gameObject == null)
                {
                    return false;
                }

                if (!player.IsConnected)
                {
                    return false;
                }

                try
                {
                    if (conditionalShow.Invoke(player))
                    {
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    _plugin.Puts($"UIBaseElement.conditionShow failed!\n{ex}");
                }
                return false;
            }

            public void HideAll()
            {
                foreach (BasePlayer player in players.ToList())
                {
                    if (player == null || player.gameObject == null)
                    {
                        players.Remove(player);
                        continue;
                    }

                    Hide(player);
                }
            }

            public void RefreshAll()
            {
                foreach (BasePlayer player in players.ToList())
                {
                    if (player == null || player.gameObject == null)
                    {
                        players.Remove(player);
                        continue;
                    }

                    Refresh(player);
                }
            }

            public void SafeAddUi(BasePlayer player, CuiElement element)
            {
                try
                {
                    //_plugin.Puts(JsonConvert.SerializeObject(element));
                    List<CuiElement> elements = new List<CuiElement>();
                    elements.Add(element);
                    CuiHelper.AddUi(player, elements);
                }
                catch (Exception)
                {
                }
            }

            public void SafeDestroyUi(BasePlayer player, CuiElement element)
            {
                try
                {
                    //_plugin.Puts($"Deleting {element.Name} to {player.userID}");
                    CuiHelper.DestroyUi(player, element.Name);
                }
                catch (Exception)
                {
                }
            }

            public void SetSize(float x, float y)
            {
                localSize = new Vector2(x, y);
                UpdatePlacement();
            }

            public void SetPosition(float x, float y)
            {
                localPosition = new Vector2(x, y);
                UpdatePlacement();
            }

            public virtual void UpdatePlacement()
            {
                if (_parent == null)
                {
                    globalSize = localSize;
                    globalPosition = localPosition;
                }
                else
                {
                    globalSize = Vector2.Scale(_parent.globalSize, localSize);
                    globalPosition = _parent.globalPosition + Vector2.Scale(_parent.globalSize, localPosition);
                }

                foreach (UIBaseElement child in children)
                {
                    child.UpdatePlacement();
                }
            }
        }

        public class UIReflectionElement : UIPanel
        {
            private object config { get; set; }
            private object _target { get { return Field.GetValue(config); } set { Field.SetValue(config, value); } }
            private FieldInfo Field { get; set; }

            private UILabel Text { get; set; }
            private UIInputField InputField { get; set; }
            private UIButton editButton { get; set; }

            private bool EditBox { get; set; } = false;

            public UIReflectionElement(Vector2 min, Vector2 max, FieldInfo field, object configuration, UIBaseElement parent = null) : base(min, max, parent)
            {
                config = configuration;
                Field = field;

                Text = new UILabel(new Vector2(0.05f, 0f), new Vector2(0.4f, 1f), "Amount", parent: this, alignment: TextAnchor.MiddleLeft);
                Text.variableText = delegate (BasePlayer player)
                {
                    return GetVisualText();
                };

                Text.AddOutline("0 0 0 1");

                //editButton = new UIButton(new Vector2(0.0125f, 0.15f), new Vector2(0.0375f, 0.85f), "","1 1 1 1", "1 1 1 1", 12, this);
                editButton = new UIButton(new Vector2(0.80f, 0.15f), new Vector2(0.90f, 0.85f), "Edit", "0 0 0 1", "1 1 1 1", 12, this);
                editButton.AddCallback((player) =>
                {
                    EditBox = true;
                    InputField.Refresh(player);
                });
                editButton.AddOutline("1 1 1 1", "0.75 -0.75");

                InputField = new UIInputField(new Vector2(0.45f, 0f), new Vector2(0.60f, 1f), this, "", TextAnchor.MiddleCenter);
                InputField.AddCallback((player, text) =>
                {
                    //TODO: Check if player has permissions to edit config values
                    if (String.IsNullOrEmpty(text))
                    {
                        return;
                    }

                    EditBox = false;
                    AssignValue(text);
                    InputField.InputField.Text = _target.ToString();
                    Text.Refresh(player);
                    InputField.Refresh(player);
                });
                InputField.AddOutline("1 1 1 1", "0.75 -0.75");
                InputField.conditionalShow = delegate (BasePlayer player)
                {
                    return EditBox;
                };
            }

            public override void Show(BasePlayer player, bool children = true)
            {
                base.Show(player, children);
            }

            public string GetVisualText()
            {
                if (_target == null)
                {
                    return $"{Field.FieldType.Name} = <color=#3B8AD6FF>NULL</color>";
                }

                string elementText = ((_target is IEnumerable && !(_target is string)) ? $" Count : {0}" : "");
                string valueText = (IsValueType(_target) ? $" = <color=#3B8AD6FF>{_target.ToString()}</color>" : "");
                if (_target is string)
                {
                    if (string.IsNullOrEmpty(_target as string))
                    {
                        valueText = $" = <color=#D69D85FF>\'\' \'\'</color>";
                    }
                    else
                    {
                        valueText = $" = <color=#D69D85FF>\'\'{_target}\'\'</color>";
                    }
                }
                return $"{Field.Name.Replace("<", "").Replace(">", "").Replace("k__BackingField", "")}{elementText}{valueText}";
                //return $"<color=#4EC8B0FF>{Field.FieldType.Name}</color> {Field.Name.Replace("<","").Replace(">","").Replace("k__BackingField","")}{elementText}{valueText}";
            }

            public void AssignValue(string text)
            {
                if (_target is string)
                {
                    _target = text;
                }
                else if (_target is int)
                {
                    int val = 0;
                    if (int.TryParse(text, out val))
                    {
                        _target = val;
                    }
                }
                else if (_target is uint)
                {
                    uint val = 0;
                    if (uint.TryParse(text, out val))
                    {
                        _target = val;
                    }
                }
                else if (_target is float)
                {
                    float val = 0;
                    if (float.TryParse(text, out val))
                    {
                        _target = val;
                    }
                }
            }
        }

        public class UIGridDisplay
        {
            public UIGridDisplay(Vector2 min, Vector2 max, int width, int height, float paddingX, float paddingY)
            {
            }
        }

        public static bool IsValueType(object obj)
        {
            return obj.GetType().IsValueType || obj is string;
        }

        public class ObjectMemoryInfo
        {
            public string name { get; set; }
            public int memoryUsed { get; set; }
            public int elements { get; set; }
            public object _target { get; set; }
            private int currentLayer { get; set; } = 0;
            public ObjectMemoryInfo _parent { get; set; }
            private bool _autoExpand { get; set; }

            public List<ObjectMemoryInfo> children { get; set; } = new List<ObjectMemoryInfo>();
            public List<MethodInfo> methods { get; set; } = new List<MethodInfo>();

            public ObjectMemoryInfo(object targetObject, int layers, string variableName = "", ObjectMemoryInfo parent = null, bool autoExpand = false)
            {
                _autoExpand = autoExpand;
                _parent = parent;
                name = variableName;
                name = name.Replace("<", "");
                name = name.Replace(">", "");
                name = name.Replace("k__BackingField", "");
                currentLayer = layers - 1;
                _target = targetObject;
                SetupObject();
                if (autoExpand)
                {
                    Expand();
                }
            }

            public void Expand()
            {
                CalculateSubObjects();
            }

            public void SetupObject()
            {
                #region Elements

                if (_target is IEnumerable)
                {
                    elements = GetCount();
                }
                if (_target is HashSet<object>)
                {
                    elements = (_target as HashSet<object>).Count;
                }

                #endregion Elements

                #region Memory Usage

                Type Type = _target?.GetType();
                if (Type == null)
                {
                    return;
                }
                if (Type == typeof(int))
                {
                    memoryUsed = 4;
                }
                else if (Type == typeof(string))
                {
                    memoryUsed = (_target as string).Length;
                }
                else if (Type == typeof(BaseNetworkable))
                {
                    memoryUsed = 8;
                }
                else if (_target is IDictionary)
                {
                    memoryUsed = elements * 16;
                }
                else if (_target is IList)
                {
                    memoryUsed = elements * 8;
                }
                else if (Type == typeof(int))
                {
                    memoryUsed = 4;
                }
                foreach (ObjectMemoryInfo child in children)
                {
                    memoryUsed += child.memoryUsed;
                }

                #endregion Memory Usage

                #region Methods

                foreach (MethodInfo method in Type.GetMethods())
                {
                    if (method?.GetParameters().Length != 0)
                    {
                        continue;
                    }

                    methods.Add(method);
                }

                #endregion Methods
            }

            private int GetCount()
            {
                int? c = (_target as IEnumerable).Cast<object>()?.Count();
                if (c != null)
                {
                    return (int)c;
                }

                return 0;
            }

            public string GetInfo()
            {
                return (_target is IEnumerable) ? $"Count : {elements}" : GetMemoryUsage();
            }

            public string GetVisualText()
            {
                if (_target == null)
                {
                    return $"{name} = <color=#3B8AD6FF>NULL</color>";
                }

                string elementText = ((_target is IEnumerable && !(_target is string)) ? $" Count : {elements}" : "");
                string valueText = (IsValueType(_target) ? $" = <color=#3B8AD6FF>{_target.ToString()}</color>" : "");
                return $"<color=#4EC8B0FF>{GetTypeName(_target.GetType())}</color> {name}{elementText}{valueText}";
            }

            public static string GetMethodText(MethodInfo info)
            {
                return $"{(info.IsPublic ? "<color=#3B8AD6FF>public " : "<color=#3B8AD6FF>private ")}{(info.IsVirtual ? "virtual</color> " : "</color>")}{$"<color=#4EC8B0FF>{GetTypeName(info.ReturnType)}</color> "}{info.Name}()";
            }

            private static string GetTypeName(Type type)
            {
                if (type == null)
                {
                    return "";
                }

                string generic = type.IsGenericType ? $"<{string.Join(",", type.GetGenericArguments().Select(x => GetTypeName(x)).ToArray())}>" : "";
                string name = type.Name;
                if (name.Contains("`"))
                {
                    name = name.Remove(name.IndexOf('`', 2));
                }
                return $"{name}{generic}";
            }

            private string GetMemoryUsage()
            {
                if (memoryUsed > 1000000000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000000000, 2)}GB";
                }

                if (memoryUsed > 1000000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000000, 2)}MB";
                }

                if (memoryUsed > 1000)
                {
                    return $"{Math.Round((double)memoryUsed / 1000, 2)}KB";
                }

                return $"{memoryUsed}B";
            }

            public void CalculateSubObjects()
            {
                children.Clear();
                try
                {
                    if (currentLayer < 0)
                    {
                        return;
                    }

                    if (_target == null)
                    {
                        return;
                    }

                    Type Type = _target.GetType();
                    if (Type == null)
                    {
                        return;
                    }

                    if (_target is string) //No need to expand these
                    {
                        return;
                    }

                    if (_target is IEnumerable)
                    {
                        int index = 0;
                        IEnumerable<object> objects = (_target as IEnumerable).Cast<object>();
                        if (objects == null)
                        {
                            return;
                        }

                        foreach (object item in objects)
                        {
                            children.Add(new ObjectMemoryInfo(item, currentLayer, index.ToString(), this, _autoExpand));
                            index++;
                        }
                    }
                    else
                    {
                        foreach (FieldInfo field in Type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static))
                        {
                            object target = field.GetValue(_target);
                            if (!CheckParents())
                            {
                                continue;
                            }

                            children.Add(new ObjectMemoryInfo(target, currentLayer, field.Name, this));
                        }
                    }
                }
                catch (Exception ex)
                {
                    _plugin.Puts(ex.ToString());
                }
            }

            public bool CheckParents()
            {
                ObjectMemoryInfo parent = _parent;
                while (parent != null)
                {
                    if (parent._target == _target)
                    {
                        return false;
                    }
                    parent = parent._parent;
                }
                return true;
            }

            public List<string> GetOutput(int layer = 0, bool justLists = false)
            {
                List<string> returnValue = new List<string>();
                string padding = new string('\t', layer);
                if (_target != null)
                {
                    if (_target is IEnumerable || !justLists || children.Count != 0)
                    {
                        returnValue.Add(padding + $"{_target.GetType().Name} {name} {GetMemoryUsage()}");
                    }
                }
                if (children.Count > 0)
                {
                    returnValue.Add(padding + "{");
                    foreach (ObjectMemoryInfo child in children)
                    {
                        returnValue.AddRange(child.GetOutput(layer + 1, justLists));
                    }
                    returnValue.Add(padding + "}");
                }
                return returnValue;
            }

            public string PrintOutput(bool justLists = false)
            {
                return string.Join(System.Environment.NewLine, GetOutput(0, justLists).ToArray());
            }
        }

        public class UICheckbox : UIButton
        {
            public UICheckbox(Vector2 min, Vector2 max, UIBaseElement parent = null) : base(min, max, parent: parent)
            {
            }
        }

        public class UIOutline
        {
            public CuiOutlineComponent component;

            public string Color { get { return _color; } set { _color = value; UpdateComponent(); } }
            public string Distance { get { return _distance; } set { _distance = value; UpdateComponent(); } }

            private string _color = "0 0 0 1";
            private string _distance = "0.25 0.25";

            public UIOutline()
            {
            }

            public UIOutline(string color, string distance)
            {
                _color = color;
                _distance = distance;
                UpdateComponent();
            }

            private void UpdateComponent()
            {
                if (component == null)
                {
                    component = new CuiOutlineComponent();
                }
                component.Color = _color;
                component.Distance = _distance;
            }
        }

        public interface UICallbackComponent
        {
            void InvokeCallback(ConsoleSystem.Arg args);
        }

        public class UIInputField : UIPanel, UICallbackComponent
        {
            public CuiInputFieldComponent InputField { get; set; }

            public Action<ConsoleSystem.Arg> onCallback;

            public UIInputField(Vector2 min, Vector2 max, UIBaseElement parent, string defaultText = "Enter Text Here", TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 12, string panelColor = "0 0 0 0.85", string textColor = "1 1 1 1", bool password = false, int charLimit = 100) : base(min, max, parent, panelColor)
            {
                UIInput_Raw input = new UIInput_Raw(Vector2.zero, Vector2.one, this, defaultText, align, fontSize, textColor, password, charLimit);

                InputField = input.InputField;

                _plugin.cmd.AddConsoleCommand(InputField.Command, _plugin, "OnButtonClick");

                _plugin.UIButtonCallBacks[InputField.Command] = this;
            }

            public void AddCallback(Action<BasePlayer, string> callback)
            {
                if (callback == null)
                {
                    return;
                }
                onCallback += (args) => { callback(args.Player(), string.Join(" ", args.Args)); };
            }

            public void InvokeCallback(ConsoleSystem.Arg args)
            {
                if (onCallback == null)
                {
                    return;
                }
                onCallback.Invoke(args);
            }
        }

        public class UIInput_Raw : UIElement
        {
            public CuiInputFieldComponent InputField { get; set; }

            public UIInput_Raw(Vector2 min, Vector2 max, UIBaseElement parent, string defaultText = "Enter Text Here", TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 12, string textColor = "1 1 1 1", bool password = false, int charLimit = 100) : base(min, max, parent)
            {
                InputField = new CuiInputFieldComponent()
                {
                    Align = align,
                    CharsLimit = charLimit,
                    Color = textColor,
                    FontSize = fontSize,
                    IsPassword = password,
                    Text = defaultText,
                    Command = CuiHelper.GetGuid(),
                };

                Element.Components.Insert(0, InputField);
            }
        }

        #endregion Jake's UI Framework
    }
}

// --- End of file: EditTool.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/elevator-control ---
// --- Original File Path: E/ElevatorControl/ElevatorControl.cs ---

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using UnityEngine;
/* 
Thanks to Magma Networks for sponsoring this plugin!
magmanetworks.cc
*/
namespace Oxide.Plugins {
    [Info ("Elevator Control", "ghostr", "1.0.2")]
    [Description ("Change elevator settings")]

    public class ElevatorControl : RustPlugin {
        private Configuration config;

        public class Configuration {
            [JsonProperty (PropertyName = "ElevatorSpeed")]
            public float ElevatorSpeed { get; set; } = 1f;
            [JsonProperty (PropertyName = "DoesNeedPower")]
            public bool DoesNeedPower { get; set; } = true;
        }

        protected override void LoadConfig () {
            base.LoadConfig ();
            try {
                config = Config.ReadObject<Configuration> ();
                if (config == null) {
                    throw new JsonException ();
                }
            } catch {
                string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}";
                Puts ($"Could not load a valid configuration file, creating a new configuration file at {configPath}.json");
                Config.WriteObject (config, false, $"{configPath}_invalid.json");
                LoadDefaultConfig ();
            }
            SaveConfig ();
        }

        protected override void LoadDefaultConfig () => config = new Configuration ();

        protected override void SaveConfig () => Config.WriteObject (config);

        private void OnServerInitialized () {
            List<Elevator> elevators = Resources.FindObjectsOfTypeAll<Elevator> ().Where (b => b.PrefabName == "assets/prefabs/deployable/elevator/elevator.prefab").ToList ();
            foreach (Elevator elevator in elevators)
                elevator.LiftSpeedPerMetre = config.ElevatorSpeed;
        }

        void OnEntitySpawned (BaseNetworkable entity) {
            var Entity = entity as BaseEntity;
            if (Entity == null) return;
            if (Entity.name == "assets/prefabs/deployable/elevator/elevator.prefab") {
                timer.Once (.1f, () => { //This is to allow elevator to exist
                    Elevator elevator = Entity as Elevator;
                    if (!config.DoesNeedPower) {
                        IOEntity IOChild = null;
                        foreach (BaseEntity child in elevator.children) {
                            IOEntity oEntity = child as IOEntity;
                            IOEntity oEntity1 = oEntity;
                            if (oEntity == null) { continue; }
                            IOChild = oEntity1; //Same code the game uses to find the proper child 
                        }

                        IOChild.SetFlag (BaseEntity.Flags.Reserved8, true); //Sets flag 8(IsPowered) to true
                    }
                    elevator.LiftSpeedPerMetre = config.ElevatorSpeed;
                });
            }
        }

    }
}

// --- End of file: ElevatorControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/effects-panel ---
// --- Original File Path: E/EffectsPanel/EffectsPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Effects Panel", "Mevent", "1.1.0")]
    [Description("Displaying effects in the interface with the ability to play it and output it to the console")]
    public class EffectsPanel : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin Notify;

        private const string Layer = "UI.Effects";

        private readonly List<string> _effects = new List<string>();

        private const string PermUse = "effects.use";

        #endregion

        #region Config

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "effects", "efui" };

            [JsonProperty(PropertyName = "Work with Notify?")]
            public bool UseNotify = true;

            [JsonProperty(PropertyName = "Interface Settings")]
            public InterfaceConf UI = new InterfaceConf
            {
                AmountOnPage = 8,
                ItemHeight = 50f,
                ItemsMargin = 5f
            };
        }

        private class InterfaceConf
        {
            [JsonProperty(PropertyName = "Amount on page")]
            public int AmountOnPage;

            [JsonProperty(PropertyName = "Item Height")]
            public float ItemHeight;

            [JsonProperty(PropertyName = "Items Margin")]
            public float ItemsMargin;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermUse, this);
            
            foreach (var asset in GameManifest.Current.pooledStrings.Where(asset =>
                (asset.str.StartsWith("assets/content/") || asset.str.StartsWith("assets/bundled/") ||
                 asset.str.StartsWith("assets/prefabs/")) && asset.str.EndsWith(".prefab") &&
                asset.str.Contains("/fx/")))
                _effects.Add(asset.str);

            AddCovalenceCommand(_config.Commands, nameof(CmdOpenEffects));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }

        #endregion

        #region Commands

        private void CmdOpenEffects(IPlayer cov, string command, string[] args)
        {
            var player = cov?.Object as BasePlayer;
            if (player == null) return;

            if (!cov.HasPermission(PermUse))
            {
                SendNotify(player, NoPermission, 1);
                return;
            }

            MainUi(player, first: true);
        }

        [ConsoleCommand("UI_Effects")]
        private void CmdConsoleEffects(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "page":
                {
                    int page;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out page)) return;

                    var search = string.Empty;
                    if (arg.HasArgs(3))
                        search = string.Join(" ", arg.Args.Skip(2));

                    MainUi(player, page, search);
                    break;
                }

                case "play":
                {
                    var effect = string.Join(" ", arg.Args.Skip(1));
                    if (string.IsNullOrEmpty(effect)) return;

                    SendEffect(player, effect);
                    break;
                }

                case "debug":
                {
                    var effect = string.Join(" ", arg.Args.Skip(1));
                    if (string.IsNullOrEmpty(effect)) return;

                    PrintWarning(Msg(player, ShowEffect, effect));
                    break;
                }
            }
        }

        #endregion

        #region Interface

        private void MainUi(BasePlayer player, int page = 0, string search = "", bool first = false)
        {
            var container = new CuiElementContainer();

            #region Background

            if (first)
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer
                    }
                }, Layer);
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-310 -250",
                    OffsetMax = "310 250"
                },
                Image =
                {
                    Color = HexToCuiColor("#0E0E10")
                }
            }, Layer, Layer + ".Main");

            #region Header

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = { Color = HexToCuiColor("#161617") }
            }, Layer + ".Main", Layer + ".Header");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "30 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, TitleMenu),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 14,
                    Color = HexToCuiColor("#FFFFFF")
                }
            }, Layer + ".Header");

            float xSwitch = -25;
            float width = 25;
            float margin = 5;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, CloseButton),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Close = Layer,
                    Color = HexToCuiColor("#4B68FF")
                }
            }, Layer + ".Header");

            xSwitch = xSwitch - margin - width;
            width = 25;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, BtnNext),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF"),
                    Command = _effects.Count > (page + 1) * _config.UI.AmountOnPage
                        ? $"UI_Effects page {page + 1} {search}"
                        : ""
                }
            }, Layer + ".Header");

            xSwitch = xSwitch - margin - width;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, BtnBack),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF", 33),
                    Command = page != 0 ? $"UI_Effects page {page - 1} {search}" : ""
                }
            }, Layer + ".Header");

            #region Search

            xSwitch = xSwitch - margin - width;
            width = 140;

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Image =
                {
                    Color = HexToCuiColor("#000000")
                }
            }, Layer + ".Header", Layer + ".Header.Search");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "10 0", OffsetMax = "-10 0"
                },
                Text =
                {
                    Text = string.IsNullOrEmpty(search) ? Msg(player, SearchTitle) : $"{search}",
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.65"
                }
            }, Layer + ".Header.Search");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Header.Search",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        Command = $"UI_Effects page {page} ",
                        Color = "1 1 1 0.95",
                        CharsLimit = 32
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            #endregion

            #endregion

            #region List

            var ySwitch = -60f;

            foreach (var effect in _effects.Skip(page * _config.UI.AmountOnPage).Take(_config.UI.AmountOnPage))
            {
                container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                        OffsetMin = $"-300 {ySwitch - _config.UI.ItemHeight}",
                        OffsetMax = $"300 {ySwitch}"
                    },
                    Image =
                    {
                        Color = HexToCuiColor("#161617")
                    }
                }, Layer + ".Main", Layer + $".Effect.{ySwitch}");

                #region Name

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                        OffsetMin = "10 0", OffsetMax = "0 0"
                    },
                    Text =
                    {
                        Text = $"{effect}",
                        Align = TextAnchor.MiddleLeft,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = "1 1 1 1"
                    }
                }, Layer + $".Effect.{ySwitch}");

                #endregion

                #region Buttons

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                        OffsetMin = "-110 -15", OffsetMax = "-10 15"
                    },
                    Text =
                    {
                        Text = Msg(player, DebugTitle),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Color = HexToCuiColor("#B43D3D"),
                        Command = $"UI_Effects debug {effect}"
                    }
                }, Layer + $".Effect.{ySwitch}");

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                        OffsetMin = "-220 -15", OffsetMax = "-120 15"
                    },
                    Text =
                    {
                        Text = Msg(player, PlayTitle),
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = "1 1 1 1"
                    },
                    Button =
                    {
                        Color = HexToCuiColor("#4B68FF"),
                        Command = $"UI_Effects play {effect}"
                    }
                }, Layer + $".Effect.{ySwitch}");

                #endregion

                ySwitch = ySwitch - _config.UI.ItemHeight - _config.UI.ItemsMargin;
            }

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private static string HexToCuiColor(string hex, float alpha = 100)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6) throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100f}";
        }

        private static void SendEffect(BasePlayer player, string effect)
        {
            EffectNetwork.Send(new Effect(effect, player, 0, new Vector3(), new Vector3()), player.Connection);
        }

        #endregion

        #region Lang

        private const string
            ShowEffect = "ShowEffect",
            NoPermission = "NoPermission",
            PlayTitle = "PlayTitle",
            DebugTitle = "DebugTitle",
            SearchTitle = "SearchTitle",
            BtnBack = "BtnBack",
            BtnNext = "BtnNext",
            CloseButton = "CloseButton",
            TitleMenu = "TitleMenu";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "You don't have the required permission",
                [TitleMenu] = "Effects",
                [CloseButton] = "✕",
                [BtnBack] = "◀",
                [BtnNext] = "▶",
                [SearchTitle] = "Search...",
                [DebugTitle] = "DEBUG",
                [PlayTitle] = "PLAY",
                [ShowEffect] = "Effect: {0}"
            }, this);
        }

        private string Msg(BasePlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, Msg(player, key, obj));
        }

        private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
        {
            if (Notify.IsLoaded && _config.UseNotify)
                Notify?.Call("SendNotify", player, type, Msg(player, key, obj));
            else
                Reply(player, key, obj);
        }

        #endregion
    }
}

// --- End of file: EffectsPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/eminterface ---
// --- Original File Path: E/EMInterface/EMInterface.cs ---

﻿//Requires: EventStatistics
using System;
using System.Text;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("EMInterface", "k1lly0u", "2.0.2")]
    [Description("Manages and provides user interface for event games")]
    public class EMInterface : RustPlugin
    {
        #region Fields    
        [PluginReference] private Plugin ImageLibrary;

        public static EMInterface Instance { get; private set; }

        public static ConfigData Configuration { get; set; }
        #endregion

        #region Oxide Hooks        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(Messages, this);
        }

        private void OnServerInitialized()
        {
            Instance = this;

            RegisterDeathScreenImages();
        }

        private void Unload()
        {            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                DestroyAllUI(player);

            Instance = null;
            Configuration = null;
        }
        #endregion

        #region UI Menus        
        public enum MenuTab { Event, Statistics, Admin }
        public enum AdminTab { None, OpenEvent, EditEvent, CreateEvent, DeleteEvent, KickPlayer, Selector }
        public enum StatisticTab { Personal, Global, Leaders }
        public enum SelectionType { Field, Event, Player }

        private const float ELEMENT_HEIGHT = 0.035f;

        public void OpenMenu(BasePlayer player, MenuArgs args)
        {
            CuiElementContainer container = UI.Container(UI_MENU, Configuration.Menu.Background.Get, new UI4(0.1f, 0.1f, 0.9f, 0.9f), true);

            UI.Label(container, UI_MENU, Message("UI.Title", player.userID), 20, new UI4(0.005f, 0.94f, 0.995f, 1f), TextAnchor.MiddleLeft);

            AddMenuButtons(player, container, UI_MENU, args.Menu);

            switch (args.Menu)
            {
                case MenuTab.Event:
                    CreateEventDetails(player, container, UI_MENU, args.Page);
                    break;
                case MenuTab.Admin:
                    if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
                        CreateAdminOptions(player, container, UI_MENU, args);
                    break;
                case MenuTab.Statistics:
                    CreateStatisticsMenu(player, container, args);
                    break;
            }

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        private void CreateMenuPopup(BasePlayer player, string text, float duration = 5f)
        {
            CuiElementContainer container = UI.Container(UI_POPUP, Configuration.Menu.Highlight.Get, new UI4(0.1f, 0.072f, 0.9f, 0.1f));
            UI.Label(container, UI_POPUP, text, 12, UI4.Full);

            CuiHelper.DestroyUi(player, UI_POPUP);
            CuiHelper.AddUi(player, container);

            player.Invoke(() => CuiHelper.DestroyUi(player, UI_POPUP), duration);
        }

        private void AddMenuButtons(BasePlayer player, CuiElementContainer container, string panel, MenuTab menuTab)
        {
            int i = 0;
            float xMin = GetHorizontalPos(i);

            UI.Button(container, panel, menuTab == MenuTab.Event ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Menu.Event", player.userID), 13, new UI4(xMin, 0.9f, xMin + 0.14f, 0.94f), menuTab == MenuTab.Event ? "" : $"emui.event 0 {(int)MenuTab.Event}");
            xMin = GetHorizontalPos(i += 1) + (0.002f * i);

            UI.Button(container, panel, menuTab == MenuTab.Statistics ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Menu.Statistics", player.userID), 13, new UI4(xMin, 0.9f, xMin + 0.14f, 0.94f), menuTab == MenuTab.Statistics ? "" : $"emui.statistics {(int)StatisticTab.Personal} {(int)EventStatistics.Statistic.Rank}");
            xMin = GetHorizontalPos(i += 1) + (0.002f * i);

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                UI.Button(container, panel, menuTab == MenuTab.Admin ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Menu.Admin", player.userID), 13, new UI4(xMin, 0.9f, xMin + 0.14f, 0.94f), menuTab == MenuTab.Admin ? "" : $"emui.event 0 {(int)MenuTab.Admin}");
                xMin = GetHorizontalPos(i += 1) + (0.002f * i);
            }

            UI.Button(container, panel, Configuration.Menu.Highlight.Get, "X", 16, new UI4(0.975f, 0.96f, 0.995f, 0.9925f), "emui.close");

            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.005f, 0.897f, 0.995f, 0.9f));
        }

        #region Event Tab
        private void CreateEventDetails(BasePlayer player, CuiElementContainer container, string panel, int page = 0)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.005f, 0.0075f, 0.499f, 0.836f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.501f, 0.0075f, 0.995f, 0.836f));

            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.005f, 0.845f, 0.499f, 0.885f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.501f, 0.845f, 0.995f, 0.885f));

            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.005f, 0.841f, 0.499f, 0.844f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.501f, 0.841f, 0.995f, 0.844f));

            UI.Label(container, UI_MENU, Message("UI.Event.Current", player.userID), 13, new UI4(0.01f, 0.845f, 0.499f, 0.885f), TextAnchor.MiddleLeft);

            if (EventManager.BaseManager != null) // Show current event details on the left and current scores on the right
            {
                #region Current Event Info
                EventManager.BaseEventGame eventGame = EventManager.BaseManager;

                int i = 0;
                CreateListEntryLeft(container, Message("UI.Event.Name", player.userID), eventGame.Config.EventName, GetVerticalPos(i += 1, 0.841f));

                CreateListEntryLeft(container, Message("UI.Event.Type", player.userID), eventGame.Config.EventType, GetVerticalPos(i += 1, 0.841f));
                CreateListEntryLeft(container, Message("UI.Event.Status", player.userID), eventGame.Status.ToString(), GetVerticalPos(i += 1, 0.841f));

                CreateListEntryLeft(container, Message("UI.Event.Players", player.userID),
                    string.Format(Message("UI.Players.Format", player.userID), eventGame.eventPlayers.Count, eventGame.Config.MaximumPlayers, eventGame.joiningPlayers.Count),
                    GetVerticalPos(i += 1, 0.841f));

                if (eventGame.Config.TimeLimit > 0)
                    CreateListEntryLeft(container, Message("UI.Event.TimeLimit", player.userID), $"{eventGame.Config.TimeLimit} seconds", GetVerticalPos(i += 1, 0.841f));

                if (eventGame.Config.ScoreLimit > 0)
                    CreateListEntryLeft(container, Message("UI.Event.ScoreLimit", player.userID), eventGame.Config.ScoreLimit.ToString(), GetVerticalPos(i += 1, 0.841f));

                List<KeyValuePair<string, object>> additionalEventDetails = Facepunch.Pool.Get<List<KeyValuePair<string, object>>>();

                eventGame.GetAdditionalEventDetails(ref additionalEventDetails, player.userID);

                for (int y = 0; y < additionalEventDetails.Count; y++)
                {
                    KeyValuePair<string, object> kvp = additionalEventDetails[y];

                    CreateListEntryLeft(container, kvp.Key, kvp.Value.ToString(), GetVerticalPos(i += 1, 0.841f));
                }

                Facepunch.Pool.FreeUnmanaged(ref additionalEventDetails);

                if (EventManager.Configuration.Reward.WinAmount > 0)
                {
                    CreateListEntryLeft(container, Message("UI.Event.WinReward", player.userID),
                        string.Format(Message("UI.Reward.Format", player.userID), EventManager.Configuration.Reward.WinAmount, Message($"UI.Reward.{EventManager.Configuration.Reward.Type}", player.userID)),
                        GetVerticalPos(i += 1, 0.841f));
                }

                if (EventManager.Configuration.Reward.KillAmount > 0)
                {
                    CreateListEntryLeft(container, Message("UI.Event.KillReward", player.userID),
                        string.Format(Message("UI.Reward.Format", player.userID), EventManager.Configuration.Reward.KillAmount, Message($"UI.Reward.{EventManager.Configuration.Reward.Type}", player.userID)),
                        GetVerticalPos(i += 1, 0.841f));
                }

                if (EventManager.Configuration.Reward.HeadshotAmount > 0)
                {
                    CreateListEntryLeft(container, Message("UI.Event.HeadshotReward", player.userID),
                        string.Format(Message("UI.Reward.Format", player.userID), EventManager.Configuration.Reward.HeadshotAmount, Message($"UI.Reward.{EventManager.Configuration.Reward.Type}", player.userID)),
                        GetVerticalPos(i += 1, 0.841f));
                }

                if (EventManager.GetUser(player) || eventGame.joiningPlayers.Contains(player))
                {
                    float yMin = GetVerticalPos(i += 1, 0.841f);
                    UI.Button(container, UI_MENU, Configuration.Menu.Button.Get, Message("UI.Event.Leave", player.userID), 13, new UI4(0.3805f, yMin, 0.499f, yMin + ELEMENT_HEIGHT), "emui.leaveevent");
                }
                else
                {
                    if (eventGame.IsOpen())
                    {
                        float yMin = GetVerticalPos(i += 1, 0.841f);
                        UI.Button(container, UI_MENU, Configuration.Menu.Button.Get, Message("UI.Event.Enter", player.userID), 13, new UI4(0.3805f, yMin, 0.499f, yMin + ELEMENT_HEIGHT), "emui.joinevent");
                    }
                }
                #endregion

                #region Current Event Scores
                UI.Label(container, UI_MENU, Message("UI.Event.CurrentScores", player.userID), 13, new UI4(0.506f, 0.845f, 0.995f, 0.885f), TextAnchor.MiddleLeft);

                if (eventGame.scoreData.Count > 0)
                {
                    int j = 0;
                    const int ELEMENTS_PER_PAGE = 20;

                    if (eventGame.scoreData.Count > (ELEMENTS_PER_PAGE * page) + ELEMENTS_PER_PAGE)
                        UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "> > >", 10, new UI4(0.911f, 0.0075f, 0.995f, 0.0375f), $"emui.event {page + 1} {(int)MenuTab.Event}");
                    if (page > 0)
                        UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "< < <", 10, new UI4(0.005f, 0.0075f, 0.089f, 0.0375f), $"emui.event {page - 1} {(int)MenuTab.Event}");

                    if (eventGame.Plugin.IsTeamEvent)
                    {
                        CreateScoreEntryRight(container, Message("UI.Event.TeamScore", player.userID),
                            string.Format(Message("UI.Score.TeamA", player.userID), eventGame.GetTeamScore(EventManager.Team.A)),
                            string.Format(Message("UI.Score.TeamB", player.userID), eventGame.GetTeamScore(EventManager.Team.B)), GetVerticalPos(j += 1, 0.841f));
                    }

                    for (int k = page * ELEMENTS_PER_PAGE; k < (page * ELEMENTS_PER_PAGE) + ELEMENTS_PER_PAGE; k++)
                    {
                        if (k >= eventGame.scoreData.Count)
                            break;

                        EventManager.ScoreEntry scoreEntry = eventGame.scoreData[k];

                        eventGame.Plugin.FormatScoreEntry(scoreEntry, player.userID, out string score1, out string score2);

                        CreateScoreEntryRight(container, scoreEntry.displayName, score1, score2, GetVerticalPos(j += 1, 0.841f));
                    }
                }
                else UI.Label(container, UI_MENU, Message("UI.Event.NoScoresRecorded", player.userID), 13, new UI4(0.506f, 0.806f, 0.88f, 0.841f), TextAnchor.MiddleLeft);
                #endregion
            }
            else 
            {
                UI.Label(container, UI_MENU, Message("UI.Event.Previous", player.userID), 13, new UI4(0.506f, 0.845f, 0.995f, 0.885f), TextAnchor.MiddleLeft);

                UI.Label(container, UI_MENU, Message("UI.Event.NoEvent", player.userID), 12, new UI4(0.01f, 0.801f, 0.495f, 0.845f), TextAnchor.MiddleLeft);

                #region Last Event Scores
                if (EventManager.LastEventResult?.IsValid ?? false)
                {
                    int ELEMENTS_PER_PAGE = EventManager.LastEventResult.Plugin.IsTeamEvent ? 17 : 18;

                    if (EventManager.LastEventResult.Scores.Count > (ELEMENTS_PER_PAGE * page) + ELEMENTS_PER_PAGE)
                        UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "> > >", 10, new UI4(0.911f, 0.0075f, 0.995f, 0.0375f), $"emui.event {page + 1} {(int)MenuTab.Event}");
                    if (page > 0)
                        UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "< < <", 10, new UI4(0.005f, 0.0075f, 0.089f, 0.0375f), $"emui.event {page - 1} {(int)MenuTab.Event}");

                    int i = 0;

                    CreateSplitEntryRight(container, Message("UI.Event.Name", player.userID), EventManager.LastEventResult.EventName, GetVerticalPos(i += 1, 0.841f));
                    CreateSplitEntryRight(container, Message("UI.Event.Type", player.userID), EventManager.LastEventResult.EventType, GetVerticalPos(i += 1, 0.841f));

                    if (EventManager.LastEventResult.Plugin.IsTeamEvent)
                    {                        
                        CreateScoreEntryRight(container, Message("UI.Event.TeamScore", player.userID), 
                            string.Format(Message("UI.Score.TeamA", player.userID), EventManager.LastEventResult.TeamScore.value1), 
                            string.Format(Message("UI.Score.TeamB", player.userID), EventManager.LastEventResult.TeamScore.value2), GetVerticalPos(i += 1, 0.841f));
                    }

                    for (int k = page * ELEMENTS_PER_PAGE; k < (page * ELEMENTS_PER_PAGE) + ELEMENTS_PER_PAGE; k++)
                    {
                        if (k >= EventManager.LastEventResult.Scores.Count)
                            break;

                        EventManager.ScoreEntry scoreEntry = EventManager.LastEventResult.Scores[k];

                        EventManager.LastEventResult.Plugin.FormatScoreEntry(scoreEntry, player.userID, out string score1, out string score2);

                        CreateScoreEntryRight(container, scoreEntry.displayName, score1, score2, GetVerticalPos(i += 1, 0.841f));
                    }
                }
                else
                {
                    UI.Label(container, UI_MENU, Message("UI.Event.NoPrevious", player.userID), 12, new UI4(0.506f, 0.801f, 0.995f, 0.845f), TextAnchor.MiddleLeft);
                }
                #endregion
            }
        }

        #region Helpers
        private void CreateListEntryLeft(CuiElementContainer container, string key, string value, float yMin)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.005f, yMin, 0.38f, yMin + ELEMENT_HEIGHT));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.3805f, yMin, 0.499f, yMin + ELEMENT_HEIGHT));
            UI.Label(container, UI_MENU, key, 12, new UI4(0.01f, yMin, 0.38f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
            UI.Label(container, UI_MENU, value, 12, new UI4(0.3805f, yMin, 0.494f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleRight);
        }

        private void CreateListEntryRight(CuiElementContainer container, string key, string value, float yMin)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.501f, yMin, 0.88f, yMin + ELEMENT_HEIGHT));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.8805f, yMin, 0.995f, yMin + ELEMENT_HEIGHT));
            UI.Label(container, UI_MENU, key, 12, new UI4(0.506f, yMin, 0.88f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
            UI.Label(container, UI_MENU, value, 12, new UI4(0.8805f, yMin, 0.99f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleRight);
        }

        private void CreateScoreEntryRight(CuiElementContainer container, string displayName, string score1, string score2, float yMin)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.501f, yMin, 0.748f, yMin + ELEMENT_HEIGHT));
            UI.Label(container, UI_MENU, displayName, 12, new UI4(0.506f, yMin, 0.748f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);

            if (!string.IsNullOrEmpty(score1))
            {
                UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.7485f, yMin, 0.8725f, yMin + ELEMENT_HEIGHT));
                UI.Label(container, UI_MENU, score1, 12, new UI4(0.7535f, yMin, 0.8675f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleRight);
            }
            else UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.7485f, yMin, 0.8725f, yMin + ELEMENT_HEIGHT));

            if (!string.IsNullOrEmpty(score2))
            {
                UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.875f, yMin, 0.995f, yMin + ELEMENT_HEIGHT));
                UI.Label(container, UI_MENU, score2, 12, new UI4(0.88f, yMin, 0.99f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleRight);
            }
            else UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.875f, yMin, 0.995f, yMin + ELEMENT_HEIGHT));
        }

        private void CreateSplitEntryRight(CuiElementContainer container, string key, string value, float yMin)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.501f, yMin, 0.748f, yMin + ELEMENT_HEIGHT));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.7485f, yMin, 0.995f, yMin + ELEMENT_HEIGHT));
            UI.Label(container, UI_MENU, key, 12, new UI4(0.506f, yMin, 0.748f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
            UI.Label(container, UI_MENU, value, 12, new UI4(0.7485f, yMin, 0.99f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleRight);
        }
        #endregion
        #endregion

        #region Admin Tab
        private void CreateAdminOptions(BasePlayer player, CuiElementContainer container, string panel, MenuArgs args)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.005f, 0.845f, 0.175f, 0.885f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.005f, 0.841f, 0.175f, 0.844f));

            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.177f, 0.845f, 0.995f, 0.885f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.177f, 0.841f, 0.995f, 0.844f));

            UI.Label(container, UI_MENU, Message("UI.Admin.Title", player.userID), 13, new UI4(0.01f, 0.845f, 0.175f, 0.885f), TextAnchor.MiddleLeft);

            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.005f, 0.0075f, 0.175f, 0.836f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.177f, 0.0075f, 0.995f, 0.836f));

            int i = 1;
            float yMin = GetVerticalPos(i, 0.836f);

            if (EventManager.BaseManager != null)
            {
                if ((int)EventManager.BaseManager.Status < 2)
                {
                    UI.Button(container, UI_MENU, Configuration.Menu.Button.Get, Message("UI.Admin.Start", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), "emui.startevent");
                    yMin = GetVerticalPos(i += 1, 0.836f);
                }

                if (EventManager.BaseManager.IsOpen())
                {
                    UI.Button(container, UI_MENU, Configuration.Menu.Button.Get, Message("UI.Admin.Close", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), "emui.closeevent");
                    yMin = GetVerticalPos(i += 1, 0.836f);
                }

                UI.Button(container, UI_MENU, Configuration.Menu.Button.Get, Message("UI.Admin.End", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), "emui.endevent");
                yMin = GetVerticalPos(i += 1, 0.836f);

                //UI.Button(container, UI_MENU, args.Admin == AdminTab.KickPlayer ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Admin.Kick", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), "emui.kickplayer");
                //yMin = GetVerticalPos(i += 1, 0.836f);
            }
            else
            {
                UI.Button(container, UI_MENU, args.Admin == AdminTab.OpenEvent ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Admin.Open", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), $"emui.eventselector {(int)AdminTab.OpenEvent}");
                yMin = GetVerticalPos(i += 1, 0.836f);

                UI.Button(container, UI_MENU, args.Admin == AdminTab.EditEvent ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Admin.Edit", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), $"emui.eventselector {(int)AdminTab.EditEvent}");
                yMin = GetVerticalPos(i += 1, 0.836f);

                UI.Button(container, UI_MENU, args.Admin == AdminTab.CreateEvent ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Admin.Create", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), "emui.create");
                yMin = GetVerticalPos(i += 1, 0.836f);

                UI.Button(container, UI_MENU, args.Admin == AdminTab.DeleteEvent ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Admin.Delete", player.userID), 12, new UI4(0.01f, yMin, 0.17f, yMin + ELEMENT_HEIGHT), $"emui.eventselector {(int)AdminTab.DeleteEvent}");
                yMin = GetVerticalPos(i += 1, 0.836f);
            }

            switch (args.Admin)
            {                
                case AdminTab.OpenEvent:
                case AdminTab.EditEvent:
                case AdminTab.DeleteEvent:
                    OpenEventSelector(player, container, UI_MENU, args.Selector, args.Page);                   
                    break;
                case AdminTab.CreateEvent:
                    EventCreatorMenu(player, container, UI_MENU);
                    break;                
                case AdminTab.KickPlayer:
                    break;
                case AdminTab.Selector:
                    OpenSelector(player, container, UI_MENU, args.Selector, args.Page);
                    break;
                default:
                    break;
            }
        }
        #endregion

        #region Event Creation
        private Hash<ulong, EventManager.EventConfig> _eventCreators = new Hash<ulong, EventManager.EventConfig>();

        private void EventCreatorMenu(BasePlayer player, CuiElementContainer container, string panel)
        {
            _eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig);

            int i = 0;

            if (eventConfig == null || string.IsNullOrEmpty(eventConfig.EventType))
            {
                UI.Label(container, UI_MENU, "Select an event type", 13, new UI4(0.182f, 0.845f, 0.99f, 0.885f), TextAnchor.MiddleLeft);

                foreach (string eventName in EventManager.Instance.EventModes.Keys)
                {
                    float yMin = GetVerticalPos(i += 1, 0.836f);
                    UI.Button(container, panel, Configuration.Menu.Button.Get, eventName, 12, new UI4(0.182f, yMin, 0.3f, yMin + ELEMENT_HEIGHT), $"emui.create {CommandSafe(eventName)}");
                }
            }
            else
            {
                UI.Label(container, UI_MENU, $"Creating Event ({eventConfig.EventType})", 13, new UI4(0.182f, 0.845f, 0.99f, 0.885f), TextAnchor.MiddleLeft);

                UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "Save", 12, new UI4(0.925f, 0.845f, 0.995f, 0.885f), "emui.saveevent");
                UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "Dispose", 12, new UI4(0.85f, 0.845f, 0.92f, 0.885f), "emui.disposeevent");

                AddInputField(container, panel, i += 1, "Event Name", "eventName", eventConfig.EventName);

                AddSelectorField(container, panel, i += 1, "Zone ID", "zoneID", eventConfig.ZoneID, "GetZoneIDs");

                if (eventConfig.Plugin.IsTeamEvent)
                {
                    AddSelectorField(container, panel, i += 1, "Team A Spawnfile", "teamASpawnfile", eventConfig.TeamConfigA.Spawnfile, "GetSpawnfileNames");

                    AddSelectorField(container, panel, i += 1, "Team A Kit(s)", "teamAKits", GetSelectorLabel(eventConfig.TeamConfigA.Kits), "GetAllKits", eventConfig.AllowClassSelection);

                    AddInputField(container, panel, i += 1, "Team A Color (Hex)", "teamAColor", eventConfig.TeamConfigA.Color);

                    AddSelectorField(container, panel, i += 1, "Team A Clothing", "teamAClothing", eventConfig.TeamConfigA.Clothing, "GetAllKits", false);

                    AddSelectorField(container, panel, i += 1, "Team B Spawnfile", "teamBSpawnfile", eventConfig.TeamConfigB.Spawnfile, "GetSpawnfileNames");

                    AddSelectorField(container, panel, i += 1, "Team B Kit(s)", "teamBKits", GetSelectorLabel(eventConfig.TeamConfigB.Kits), "GetAllKits", eventConfig.AllowClassSelection);

                    AddInputField(container, panel, i += 1, "Team B Color (Hex)", "teamBColor", eventConfig.TeamConfigB.Color);

                    AddSelectorField(container, panel, i += 1, "Team B Clothing", "teamBClothing", eventConfig.TeamConfigB.Clothing, "GetAllKits", false);
                }
                else
                {
                    AddSelectorField(container, panel, i += 1, "Spawnfile", "teamASpawnfile", eventConfig.TeamConfigA.Spawnfile, "GetSpawnfileNames");

                    AddSelectorField(container, panel, i += 1, "Kit(s)", "teamAKits", GetSelectorLabel(eventConfig.TeamConfigA.Kits), "GetAllKits", eventConfig.AllowClassSelection);
                }

                if (eventConfig.Plugin.CanUseClassSelector)
                    AddToggleField(container, panel, i += 1, "Use Class Selector", "useClassSelector", eventConfig.AllowClassSelection);

                if (eventConfig.Plugin.UseTimeLimit)
                    AddInputField(container, panel, i += 1, "Time Limit (seconds)", "timeLimit", eventConfig.TimeLimit);

                if (eventConfig.Plugin.UseScoreLimit)
                    AddInputField(container, panel, i += 1, "Score Limit", "scoreLimit", eventConfig.ScoreLimit);

                AddInputField(container, panel, i += 1, "Minimum Players", "minimumPlayers", eventConfig.MinimumPlayers);
                AddInputField(container, panel, i += 1, "Maximum Players", "maximumPlayers", eventConfig.MaximumPlayers);

                List<EventManager.EventParameter> eventParameters = eventConfig.Plugin.AdditionalParameters;

                for (int y = 0; y < eventParameters?.Count; y++)
                {
                    EventManager.EventParameter eventParameter = eventParameters[y];

                    switch (eventParameter.Input)
                    {
                        case EventManager.EventParameter.InputType.InputField:
                            {
                                string parameter = eventConfig.GetParameter<string>(eventParameter.Field);
                                AddInputField(container, panel, i += 1, eventParameter.Name, eventParameter.Field, string.IsNullOrEmpty(parameter) ? null : parameter);
                                break;
                            }
                        case EventManager.EventParameter.InputType.Toggle:
                            {
                                bool parameter = eventConfig.GetParameter<bool>(eventParameter.Field);
                                AddToggleField(container, panel, i += 1, eventParameter.Name, eventParameter.Field, parameter);
                                break;
                            }
                        case EventManager.EventParameter.InputType.Selector:
                            {
                                string parameter = eventConfig.GetParameter<string>(eventParameter.Field);
                                AddSelectorField(container, panel, i += 1, eventParameter.Name, eventParameter.Field, parameter, eventParameter.SelectorHook);
                            }
                            break;
                    }
                }
            }
        }

        private void AddInputField(CuiElementContainer container, string panel, int index, string title, string fieldName, object currentValue)
        {
            float yMin = GetVerticalPos(index >= 21 ? index - 20 : index, 0.836f);
            float hMin = index >= 21 ? 0.59f : 0.182f;

            UI.Label(container, panel, title, 12, new UI4(hMin, yMin, hMin + 0.118f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);

            UI.Panel(container, panel, Configuration.Menu.Button.Get, new UI4(hMin + 0.118f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT));

            string label = GetInputLabel(currentValue);
            if (!string.IsNullOrEmpty(label))
            {
                UI.Label(container, panel, label, 12, new UI4(hMin + 0.123f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
                UI.Button(container, panel, Configuration.Menu.Highlight.Get, "X", 12, new UI4(hMin + 0.38f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT), $"emui.clear {fieldName}");
            }
            else UI.Input(container, panel, string.Empty, 12, $"emui.creator {fieldName}", new UI4(hMin + 0.123f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT));
        }

        private void AddLabelField(CuiElementContainer container, string panel, int index, string title, string value)
        {
            float yMin = GetVerticalPos(index >= 21 ? index - 20 : index, 0.836f);
            float hMin = index >= 21 ? 0.59f : 0.182f;

            UI.Label(container, panel, title, 12, new UI4(hMin, yMin, hMin + 0.118f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);

            UI.Panel(container, panel, Configuration.Menu.Button.Get, new UI4(hMin + 0.118f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT));
            UI.Label(container, panel, value, 12, new UI4(hMin + 0.123f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
        }

        private void AddToggleField(CuiElementContainer container, string panel, int index, string title, string fieldName, bool currentValue)
        {
            float yMin = GetVerticalPos(index >= 21 ? index - 20 : index, 0.836f);
            float hMin = index >= 21 ? 0.59f : 0.182f;

            UI.Label(container, panel, title, 12, new UI4(hMin, yMin, hMin + 0.118f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
            UI.Toggle(container, panel, Configuration.Menu.Button.Get, 12, new UI4(hMin + 0.118f, yMin, hMin + 0.138f, yMin + ELEMENT_HEIGHT), $"emui.creator {fieldName} {!currentValue}", currentValue);
        }

        private void AddSelectorField(CuiElementContainer container, string panel, int index, string title, string fieldName, string currentValue, string hook, bool allowMultiple = false)
        {
            float yMin = GetVerticalPos(index >= 21 ? index - 20 : index, 0.836f);
            float hMin = index >= 21 ? 0.59f : 0.182f;

            UI.Label(container, panel, title, 12, new UI4(hMin, yMin, hMin + 0.118f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);

            UI.Panel(container, panel, Configuration.Menu.Button.Get, new UI4(hMin + 0.118f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT));

            if (!string.IsNullOrEmpty(currentValue))
                UI.Label(container, panel, currentValue.ToString(), 12, new UI4(hMin + 0.123f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);

            UI.Button(container, panel, Configuration.Menu.Highlight.Get, "Select", 12, new UI4(hMin + 0.35f, yMin, hMin + 0.4f, yMin + ELEMENT_HEIGHT), $"emui.fieldselector {CommandSafe(title)} {fieldName} {hook} {allowMultiple}");
        }

        private string GetSelectorLabel(IEnumerable<object> list) => list.Count() == 0 ? "Nothing Selected" : list.Count() > 1 ? "Multiple Selected" : list.ElementAt(0).ToString();

        private string GetInputLabel(object obj)
        {
            if (obj is string)
                return string.IsNullOrEmpty(obj as string) ? null : obj.ToString();
            else if (obj is int)
                return (int)obj <= 0 ? null : obj.ToString();
            else if (obj is float)
                return (float)obj <= 0 ? null : obj.ToString();
            return null;
        }

        #region Selector
        private void OpenEventSelector(BasePlayer player, CuiElementContainer container, string panel, SelectorArgs args, int page)
        {
            UI.Label(container, UI_MENU, args.Title, 13, new UI4(0.182f, 0.845f, 0.99f, 0.885f), TextAnchor.MiddleLeft);

            int i = 0;
            foreach (KeyValuePair<string, EventManager.EventConfig> kvp in EventManager.Instance.Events.events)
            {
                UI.Button(container, panel, Configuration.Menu.Button.Get, $"{kvp.Key} <size=8>({kvp.Value.EventType})</size>", 11, GetGridLayout(i, 0.182f, 0.796f, 0.1578f, 0.035f, 5, 20), $"{args.Callback} {CommandSafe(kvp.Key)}");
                i++;
            }            
        }

        private void OpenSelector(BasePlayer player, CuiElementContainer container, string panel, SelectorArgs args, int page)
        {
            UI.Label(container, UI_MENU, args.Title, 13, new UI4(0.182f, 0.845f, 0.99f, 0.885f), TextAnchor.MiddleLeft);

            UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "Back", 12, new UI4(0.925f, 0.845f, 0.995f, 0.885f), "emui.closeselector");

            string[] array = Interface.CallHook(args.Hook) as string[];
            if (array != null)
            {
                _eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig);

                string stringValue = eventConfig.GetString(args.FieldName);
                List<string> listValue = eventConfig?.GetList(args.FieldName);

                int count = 0;
                for (int i = page * 200; i < Mathf.Min((page + 1) * 200, array.Length); i++)
                {
                    string option = array[i];

                    string color = ((stringValue?.Equals(option, StringComparison.OrdinalIgnoreCase) ?? false) || (listValue?.Contains(option)?? false)) ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get;

                    UI.Button(container, panel, color, array[i], 11, GetGridLayout(count), $"emui.select {CommandSafe(args.Title)} {args.FieldName} {args.Hook} {args.AllowMultiple} {CommandSafe(option)}");
                    count += 1;
                }
            }
            else
            {
                UI.Label(container, UI_MENU, "No options available for selection", 13, new UI4(0.182f, 0.796f, 0.99f, 0.836f), TextAnchor.MiddleLeft);
            }
        }

        private UI4 GetGridLayout(int index, float xMin = 0.182f, float yMin = 0.796f, float width = 0.0764f, float height = 0.035f, int columns = 10, int rows = 20)
        {
            int columnNumber = index == 0 ? 0 : Mathf.FloorToInt(index / (float)columns);
            int rowNumber = index - (columnNumber * columns);

            float x = xMin + ((width + 0.005f) * rowNumber);
            float y = yMin - ((height + 0.0075f) * columnNumber);

            return new UI4(x, y, x + width, y + height);
        }

        private UI4 GetGridLayout(int columnNumber, int rowNumber, float xMin = 0.182f, float yMin = 0.796f, float width = 0.0764f, float height = 0.035f, int columns = 10, int rows = 20)
        {            
            float x = xMin + ((width + 0.005f) * rowNumber);
            float y = yMin - ((height + 0.0075f) * columnNumber);

            return new UI4(x, y, x + width, y + height);
        }
        #endregion        
        #endregion        
        #endregion

        #region Statistics      
        private void CreateStatisticsMenu(BasePlayer player, CuiElementContainer container, MenuArgs args)
        {
            AddStatisticHeader(container, player.userID, args.Statistic);            

            switch (args.Statistic)
            {
                case StatisticTab.Personal:
                    AddStatistics(container, false, player.userID, args.Page);
                    break;
                case StatisticTab.Global:
                    AddStatistics(container, true, player.userID, args.Page);
                    break;
                case StatisticTab.Leaders:
                    AddLeaderBoard(container, player.userID, args.Page, args.StatisticSort);
                    break;  
            }
        }

        private void AddStatisticHeader(CuiElementContainer container, ulong playerId, StatisticTab openTab)
        {
            int i = 0;
            float xMin = GetHorizontalPos(i);

            UI.Button(container, UI_MENU, openTab == StatisticTab.Personal ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Statistics.Personal", playerId), 13, new UI4(xMin, 0.85f, xMin + 0.14f, 0.885f), openTab == StatisticTab.Personal ? "" : $"emui.statistics {(int)StatisticTab.Personal} {EventStatistics.Statistic.Rank}");
            xMin = GetHorizontalPos(i += 1) + (0.002f * i);

            UI.Button(container, UI_MENU, openTab == StatisticTab.Global ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Statistics.Global", playerId), 13, new UI4(xMin, 0.85f, xMin + 0.14f, 0.885f), openTab == StatisticTab.Global ? "" : $"emui.statistics {(int)StatisticTab.Global} {EventStatistics.Statistic.Rank}");
            xMin = GetHorizontalPos(i += 1) + (0.002f * i);

            UI.Button(container, UI_MENU, openTab == StatisticTab.Leaders ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Statistics.Leaders", playerId), 13, new UI4(xMin, 0.85f, xMin + 0.14f, 0.885f), openTab == StatisticTab.Leaders ? "" : $"emui.statistics {(int)StatisticTab.Leaders} {EventStatistics.Statistic.Rank}");
            xMin = GetHorizontalPos(i += 1) + (0.002f * i);
        }

        private void AddStatistics(CuiElementContainer container, bool isGlobal, ulong playerId, int page = 0)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.005f, 0.805f, 0.499f, 0.845f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Button.Get, new UI4(0.501f, 0.805f, 0.995f, 0.845f));
            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.005f, 0.801f, 0.995f, 0.804f));

            UI.Label(container, UI_MENU, isGlobal ? Message("UI.Statistics.Global", playerId) : Message("UI.Statistics.Personal", playerId), 13, new UI4(0.01f, 0.805f, 0.499f, 0.845f), TextAnchor.MiddleLeft);
            UI.Label(container, UI_MENU, Message("UI.GamesPlayed", playerId), 13, new UI4(0.506f, 0.805f, 0.995f, 0.845f), TextAnchor.MiddleLeft);

            EventStatistics.Statistics.Data data = isGlobal ? EventStatistics.Data.global : EventStatistics.Data.Find(playerId);
            if (data != null)
            {
                const int ELEMENTS_PER_PAGE = 19;
                                
                if (data.events.Count > (ELEMENTS_PER_PAGE * page) + ELEMENTS_PER_PAGE)
                    UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "> > >", 10, new UI4(0.911f, 0.0075f, 0.995f, 0.0375f), 
                        $"emui.statistics {(isGlobal ? (int)StatisticTab.Global : (int)StatisticTab.Personal)} {page + 1}");
                if (page > 0)
                    UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "< < <", 10, new UI4(0.005f, 0.0075f, 0.089f, 0.0375f), 
                        $"emui.statistics {(isGlobal ? (int)StatisticTab.Global : (int)StatisticTab.Personal)} {page - 1}");

                int i = 0;
                if (!isGlobal)
                {
                    CreateListEntryLeft(container, Message("UI.Rank", playerId), data.Rank == -1 ? "-" : data.Rank.ToString(), GetVerticalPos(i+=1, 0.801f));
                    CreateListEntryLeft(container, Message("UI.Score", playerId), data.Score.ToString(), GetVerticalPos(i+=1, 0.801f));
                }

                foreach (KeyValuePair<string, int> score in data.statistics)                
                    CreateListEntryLeft(container, isGlobal ? string.Format(Message("UI.Totals", playerId), score.Key) : Message(score.Key, playerId), score.Value.ToString(), GetVerticalPos(i+=1, 0.801f));

                int j = 1;
                for (int k = page * ELEMENTS_PER_PAGE; k < (page * ELEMENTS_PER_PAGE) + ELEMENTS_PER_PAGE; k++)
                {
                    if (k >= data.events.Count)
                        break;

                    KeyValuePair<string, int> eventGame = data.events.ElementAt(k);

                    CreateListEntryRight(container, eventGame.Key, eventGame.Value.ToString(), GetVerticalPos(j++, 0.801f));
                }
            }
            else
            {
                float yMin = GetVerticalPos(1, 0.801f);
                UI.Label(container, UI_MENU, Message("UI.NoStatisticsSaved", playerId), 13, new UI4(0.01f, yMin, 0.38f, yMin + ELEMENT_HEIGHT), TextAnchor.MiddleLeft);
            }
        }        
        
        private void AddLeaderBoard(CuiElementContainer container, ulong playerId, int page = 0, EventStatistics.Statistic sortBy = EventStatistics.Statistic.Rank)
        {
            const int ELEMENTS_PER_PAGE = 19;

            List<EventStatistics.Statistics.Data> list = EventStatistics.Data.SortStatisticsBy(sortBy);

            if (list.Count > (ELEMENTS_PER_PAGE * page) + ELEMENTS_PER_PAGE)
                UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "> > >", 10, new UI4(0.911f, 0.0075f, 0.995f, 0.0375f), 
                    $"emui.statistics {(int)StatisticTab.Leaders} {(int)sortBy} {page + 1}");
            if (page > 0)
                UI.Button(container, UI_MENU, Configuration.Menu.Highlight.Get, "< < <", 10, new UI4(0.005f, 0.0075f, 0.089f, 0.0375f), 
                    $"emui.statistics {(int)StatisticTab.Leaders} {(int)sortBy} {page - 1}");

            float yMin = 0.81f;

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Rank ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, string.Empty, page, EventStatistics.Statistic.Rank, 0.005f, 0.033f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Name ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Player", playerId), page, EventStatistics.Statistic.Name, 0.035f, 0.225f, yMin, TextAnchor.MiddleLeft);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Rank ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Score", playerId), page, EventStatistics.Statistic.Rank, 0.227f, 0.309f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Kills ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Kills", playerId), page, EventStatistics.Statistic.Kills, 0.311f, 0.393f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Deaths ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Deaths", playerId), page, EventStatistics.Statistic.Deaths, 0.395f, 0.479f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Assists ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Assists", playerId), page, EventStatistics.Statistic.Assists, 0.481f, 0.565f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Headshots ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Headshots", playerId), page, EventStatistics.Statistic.Headshots, 0.567f, 0.651f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Melee ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Melee", playerId), page, EventStatistics.Statistic.Melee, 0.653f, 0.737f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Wins ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Won", playerId), page, EventStatistics.Statistic.Wins, 0.739f, 0.823f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Losses ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Lost", playerId), page, EventStatistics.Statistic.Losses, 0.825f, 0.909f, yMin);

            AddLeaderSortButton(container, UI_MENU, sortBy == EventStatistics.Statistic.Played ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Played", playerId), page, EventStatistics.Statistic.Played, 0.911f, 0.995f, yMin);

            UI.Panel(container, UI_MENU, Configuration.Menu.Highlight.Get, new UI4(0.005f, 0.807f, 0.995f, 0.81f));

            int j = 1;
            for (int i = page * ELEMENTS_PER_PAGE; i < (page * ELEMENTS_PER_PAGE) + ELEMENTS_PER_PAGE; i++)
            {
                if (i >= list.Count)
                    break;

                EventStatistics.Statistics.Data userData = list[i];

                yMin = GetVerticalPos(j, 0.81f);
                
                if (userData != null)
                {
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.Rank.ToString(), 0.005f, 0.033f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.DisplayName ?? "Unknown", 0.035f, 0.225f, yMin, TextAnchor.MiddleLeft);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.Score.ToString(), 0.227f, 0.309f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Kills").ToString(), 0.311f, 0.393f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Deaths").ToString(), 0.395f, 0.479f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Assists").ToString(), 0.481f, 0.565f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Headshots").ToString(), 0.567f, 0.651f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Melee").ToString(), 0.653f, 0.737f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Wins").ToString(), 0.739f, 0.823f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Losses").ToString(), 0.825f, 0.909f, yMin);
                    AddStatistic(container, UI_MENU, Configuration.Menu.Button.Get, userData.GetStatistic("Played").ToString(), 0.9111f, 0.995f, yMin);
                    j++;
                }
            }
        }

        #region Helpers
        private void AddStatistic(CuiElementContainer container, string panel, string color, string message, float xMin, float xMax, float verticalPos, TextAnchor anchor = TextAnchor.MiddleCenter)
        {            
            UI.Panel(container, panel, color, new UI4(xMin, verticalPos, xMax, verticalPos + ELEMENT_HEIGHT));
            UI.Label(container, panel, message, 12, new UI4(xMin + (anchor != TextAnchor.MiddleCenter ? 0.005f : 0f), verticalPos, xMax - (anchor != TextAnchor.MiddleCenter ? 0.005f : 0f), verticalPos + ELEMENT_HEIGHT), anchor);
        }

        private void AddLeaderSortButton(CuiElementContainer container, string panel, string color, string message, int page, EventStatistics.Statistic statistic, float xMin, float xMax, float verticalPos, TextAnchor anchor = TextAnchor.MiddleCenter)
        {
            UI4 ui4 = new UI4(xMin, verticalPos, xMax, verticalPos + ELEMENT_HEIGHT);

            UI.Panel(container, panel, color, ui4);
            UI.Label(container, panel, message, 12, new UI4(xMin + (anchor != TextAnchor.MiddleCenter ? 0.005f : 0f), verticalPos, xMax - (anchor != TextAnchor.MiddleCenter ? 0.005f : 0f), verticalPos + ELEMENT_HEIGHT), anchor);
            UI.Button(container, panel, "0 0 0 0", string.Empty, 0, ui4, $"emui.statistics {(int)StatisticTab.Leaders} {(int)statistic} {page}");
        }

        private float GetHorizontalPos(int i, float start = 0.005f, float size = 0.1405f) => start + (size * i);

        private float GetVerticalPos(int i, float start = 0.9f) => start - (i * (ELEMENT_HEIGHT + 0.005f));
        #endregion
        #endregion

        #region Scoreboards        
        public static CuiElementContainer CreateScoreboardBase(EventManager.BaseEventGame baseEventGame)
        {
            CuiElementContainer container = UI.Container(UI_SCORES, Configuration.Scoreboard.Background.Get, Configuration.Scoreboard.Position.UI4, false, "Hud.Menu");

            UI.Panel(container, UI_SCORES, Configuration.Scoreboard.Highlight.Get, UI4.Full);
            UI.Label(container, UI_SCORES, $"{baseEventGame.Config.EventName} ({baseEventGame.Config.EventType})", 11, UI4.Full);

            return container;            
        }

        public static void CreateScoreEntry(CuiElementContainer container, string text, string value1, string value2, int index)
        {
            float yMax = -(1f * index);
            float yMin = -(1f * (index + 1));

            UI.Panel(container, UI_SCORES, Configuration.Scoreboard.Panel.Get, new UI4(0f, yMin + 0.02f, 1f, yMax - 0.02f));

            UI.Label(container, UI_SCORES, text, 11, new UI4(0.05f, yMin, 1f, yMax), TextAnchor.MiddleLeft);

            if (!string.IsNullOrEmpty(value1))
            {
                UI.Panel(container, UI_SCORES, Configuration.Scoreboard.Highlight.Get, new UI4(0.75f, yMin + 0.02f, 0.875f, yMax - 0.02f));
                UI.Label(container, UI_SCORES, value1, 11, new UI4(0.75f, yMin, 0.875f, yMax), TextAnchor.MiddleCenter);
            }

            if (!string.IsNullOrEmpty(value2))
            {
                UI.Panel(container, UI_SCORES, Configuration.Scoreboard.Highlight.Get, new UI4(0.875f, yMin + 0.02f, 1f, yMax - 0.02f));
                UI.Label(container, UI_SCORES, value2, 11, new UI4(0.875f, yMin, 1f, yMax), TextAnchor.MiddleCenter);
            }
        }

        public static void CreatePanelEntry(CuiElementContainer container, string text, int index)
        {
            float yMax = -(1f * index);
            float yMin = -(1f * (index + 1));

            UI.Panel(container, UI_SCORES, Configuration.Scoreboard.Foreground.Get, new UI4(0f, yMin + 0.02f, 1f, yMax - 0.02f));

            UI.Label(container, UI_SCORES, text, 11, new UI4(0.05f, yMin, 1f, yMax), TextAnchor.MiddleCenter);
        }
        #endregion

        #region DeathScreen
        private const string DEATH_SKULL_ICON = "emui.death_skullicon";
        private const string DEATH_BACKGROUND = "emui.death_background";

        private void RegisterDeathScreenImages()
        {
            if (!ImageLibrary)
                return;

            if (!string.IsNullOrEmpty(Configuration.DeathBackground))
                AddImage(DEATH_BACKGROUND, Configuration.DeathBackground);

            if (!string.IsNullOrEmpty(Configuration.DeathIcon))
                AddImage(DEATH_SKULL_ICON, Configuration.DeathIcon);
        }
        
        public static void DisplayDeathScreen(EventManager.BaseEventPlayer victim, string message, bool canRespawn)
        {
            CuiElementContainer container = UI.Container(UI_DEATH, Configuration.Menu.Background.Get, UI4.Full, true);

            if (!string.IsNullOrEmpty(Configuration.DeathBackground))
            {
                string background = Instance.GetImage(DEATH_BACKGROUND);
                if (!string.IsNullOrEmpty(background))
                    UI.Image(container, UI_DEATH, background, UI4.Full);
            }

            if (!string.IsNullOrEmpty(Configuration.DeathIcon))
            {
                string icon = Instance.GetImage(DEATH_SKULL_ICON);
                if (!string.IsNullOrEmpty(icon))
                    UI.Image(container, UI_DEATH, icon, new UI4(0.45f, 0.405f, 0.55f, 0.595f));
            }
            
            UI.Label(container, UI_DEATH, message, 22, new UI4(0.2f, 0.7f, 0.8f, 0.85f));

            victim.DestroyUI(UI_DEATH);
            victim.AddUI(UI_DEATH, container);

            if (canRespawn)
                UpdateRespawnButton(victim);
            else CreateLeaveButton(victim);
        }
        
        public static void UpdateRespawnButton(EventManager.BaseEventPlayer eventPlayer)
        {
            CuiElementContainer container = UI.Container(UI_RESPAWN, Configuration.Menu.Panel.Get, new UI4(0f, 0f, 1f, 0.04f), true);

            UI.Panel(container, UI_RESPAWN, Configuration.Menu.Highlight.Get, new UI4(0f, 1f, 1f, 1.005f));

            UI.Button(container, UI_RESPAWN, eventPlayer.CanRespawn ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, eventPlayer.CanRespawn ? Message("UI.Death.Respawn", eventPlayer.Player.userID) : string.Format(Message("UI.Death.Respawn.Time", eventPlayer.Player.userID), eventPlayer.RespawnRemaining), 13, new UI4(0.005f, 0.125f, 0.1f, 0.875f), "emui.respawn");

            UI.Label(container, UI_RESPAWN, Message("UI.Death.AutoRespawn", eventPlayer.Player.userID), 13, new UI4(0.1f, 0.125f, 0.17f, 0.875f), TextAnchor.MiddleRight);
            UI.Toggle(container, UI_RESPAWN, Configuration.Menu.Button.Get, 14, new UI4(0.18f, 0.125f, 0.2f, 0.875f), "emui.toggleautospawn", eventPlayer.AutoRespawn);

            List<string> kits = EventManager.BaseManager.GetAvailableKits(eventPlayer.Team);

            if (EventManager.BaseManager.Config.AllowClassSelection && kits.Count > 1)
            {
                UI.Button(container, UI_RESPAWN, eventPlayer.IsSelectingClass ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Death.Class", eventPlayer.Player.userID), 13, new UI4(0.895f, 0.125f, 0.995f, 0.875f), $"emui.selectkit {CommandSafe(eventPlayer.Kit)} {!eventPlayer.IsSelectingClass}");

                if (eventPlayer.IsSelectingClass)
                {
                    UI.Panel(container, UI_RESPAWN, Configuration.Menu.Panel.Get, new UI4(0.89f, 1f, 1f, 1f + kits.Count));

                    UI.Panel(container, UI_RESPAWN, Configuration.Menu.Highlight.Get, new UI4(0.88975f, 1f, 0.89f, 1f + kits.Count + 0.005f)); // Side highlight

                    UI.Panel(container, UI_RESPAWN, Configuration.Menu.Highlight.Get, new UI4(0.89f, 1f + kits.Count, 1f, 1f + kits.Count + 0.005f)); // Top highlight

                    for (int i = 0; i < kits.Count; i++)
                    {
                        string kit = kits[i];                        

                        UI.Button(container, UI_RESPAWN, eventPlayer.Kit.Equals(kit, StringComparison.OrdinalIgnoreCase) ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, kit, 12, new UI4(0.895f, (1f + i) + 0.125f, 0.995f, (1f + (i + 1f)) - 0.125f), $"emui.selectkit {CommandSafe(kit)} true");
                    }
                }
            }

            eventPlayer.DestroyUI(UI_RESPAWN);
            eventPlayer.AddUI(UI_RESPAWN, container);
        }

        public static void CreateLeaveButton(EventManager.BaseEventPlayer eventPlayer)
        {
            CuiElementContainer container = UI.Container(UI_RESPAWN, Configuration.Menu.Panel.Get, new UI4(0f, 0f, 1f, 0.04f), true);

            UI.Panel(container, UI_RESPAWN, Configuration.Menu.Highlight.Get, new UI4(0f, 1f, 1f, 1.005f));

            UI.Button(container, UI_RESPAWN, eventPlayer.CanRespawn ? Configuration.Menu.Highlight.Get : Configuration.Menu.Button.Get, Message("UI.Death.Leave", eventPlayer.Player.userID), 13, new UI4(0.005f, 0.125f, 0.1f, 0.875f), "emui.leaveevent");
                        
            eventPlayer.DestroyUI(UI_RESPAWN);
            eventPlayer.AddUI(UI_RESPAWN, container);
        }
        #endregion

        #region ImageLibrary
        internal void AddImage(string imageName, string url) => ImageLibrary.Call("AddImage", url, imageName);

        internal string GetImage(string name) => (string)ImageLibrary.Call("GetImage", name);
        #endregion

        #region UI Args
        public struct MenuArgs
        {
            public int Page;
            public MenuTab Menu;
            public AdminTab Admin;
            public StatisticTab Statistic;
            public EventStatistics.Statistic StatisticSort;
            public SelectorArgs Selector;

            public MenuArgs(MenuTab menu)
            {
                Page = 0;
                Menu = menu;
                Statistic = StatisticTab.Global;
                Admin = AdminTab.None;
                StatisticSort = EventStatistics.Statistic.Rank;
                Selector = default(SelectorArgs);
            }

            public MenuArgs(int page, MenuTab menu)
            {
                Page = page;
                Menu = menu;
                Statistic = StatisticTab.Personal;
                Admin = AdminTab.None;
                StatisticSort = EventStatistics.Statistic.Rank;
                Selector = default(SelectorArgs);
            }

            public MenuArgs(AdminTab admin)
            {
                Page = 0;
                Menu = MenuTab.Admin;
                Statistic = StatisticTab.Personal;
                Admin = admin;
                StatisticSort = EventStatistics.Statistic.Rank;
                Selector = default(SelectorArgs);
            }

            public MenuArgs(StatisticTab statistic, EventStatistics.Statistic sort, int page)
            {
                Page = page;
                Menu = MenuTab.Statistics;
                Statistic = statistic;
                Admin = AdminTab.None;
                StatisticSort = sort;
                Selector = default(SelectorArgs);
            }

            public MenuArgs(SelectorArgs selectorArgs, int page)
            {
                Page = page;
                Selector = selectorArgs;
                Menu = MenuTab.Admin;
                Admin = AdminTab.Selector;
                Statistic = StatisticTab.Personal;
                StatisticSort = EventStatistics.Statistic.Rank;
            }

            public MenuArgs(SelectorArgs selectorArgs, AdminTab admin, int page)
            {
                Page = page;
                Selector = selectorArgs;
                Menu = MenuTab.Admin;
                Admin = admin;
                Statistic = StatisticTab.Personal;
                StatisticSort = EventStatistics.Statistic.Rank;
            }
        }

        public struct SelectorArgs
        {
            public string Title;
            public string FieldName;
            public string Hook;
            public bool AllowMultiple;

            public SelectionType Type;
            public string Callback;

            public SelectorArgs(string title, string fieldName, string hook, bool allowMultiple, SelectionType type = SelectionType.Field)
            {
                Title = title;
                FieldName = fieldName;
                Hook = hook;
                AllowMultiple = allowMultiple;
                Type = SelectionType.Field;
                Callback = string.Empty;
            }

            public SelectorArgs(string title, SelectionType type, string callback)
            {
                Title = title;
                FieldName = string.Empty;
                Hook = string.Empty;
                AllowMultiple = false;
                Type = type;
                Callback = callback;
            }
        }

        #endregion

        #region UI Commands
        #region Creator Commands
        [ConsoleCommand("emui.create")]
        private void ccmdCreateEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                if (arg.HasArgs(1))
                {
                    EventManager.EventConfig eventConfig;
                    if (!_eventCreators.TryGetValue(player.userID, out eventConfig))
                    {
                        string eventName = CommandSafe(arg.GetString(0), true);

                        EventManagerEx.IEventPlugin eventPlugin = EventManager.Instance.GetPlugin(eventName);

                        if (eventPlugin == null)
                            return;

                        _eventCreators[player.userID] = eventConfig = new EventManager.EventConfig(eventName, eventPlugin);
                    }
                }

                OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
            }
        }

        [ConsoleCommand("emui.saveevent")]
        private void ccmdSaveEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                if (!_eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig))
                    return;

                object success = EventManager.Instance.ValidateEventConfig(eventConfig);
                if (success == null)
                {
                    EventManager.SaveEventConfig(eventConfig);
                    _eventCreators.Remove(player.userID);

                    OpenMenu(player, new MenuArgs(AdminTab.None));

                    CreateMenuPopup(player, $"Successfully saved event {eventConfig.EventName}");
                }
                else CreateMenuPopup(player, (string)success);
            }
        }

        [ConsoleCommand("emui.disposeevent")]
        private void ccmdDisposeEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            _eventCreators.Remove(player.userID);

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                OpenMenu(player, new MenuArgs(AdminTab.None));
                CreateMenuPopup(player, "Cancelled event creation");
            }
        }

        [ConsoleCommand("emui.clear")]
        private void ccmdClearField(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (!_eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig))
                return;

            string fieldName = arg.GetString(0);

            switch (fieldName)
            {
                case "eventName":
                    eventConfig.EventName = string.Empty;
                    break;
                case "zoneID":
                    eventConfig.ZoneID = string.Empty;
                    break;
                case "timeLimit":
                    eventConfig.TimeLimit = 0;
                    break;
                case "scoreLimit":
                    eventConfig.ScoreLimit = 0;
                    break;
                case "minimumPlayers":
                    eventConfig.MinimumPlayers = 0;
                    break;
                case "maximumPlayers":
                    eventConfig.MaximumPlayers = 0;
                    break;
                case "teamASpawnfile":
                    eventConfig.TeamConfigA.Spawnfile = string.Empty;
                    break;
                case "teamBSpawnfile":
                    eventConfig.TeamConfigB.Spawnfile = string.Empty;
                    break;
                case "teamAColor":
                    eventConfig.TeamConfigA.Color = string.Empty;
                    break;
                case "teamBColor":
                    eventConfig.TeamConfigB.Color = string.Empty;
                    break;
                default:
                    foreach (KeyValuePair<string, object> kvp in eventConfig.AdditionalParams)
                    {
                        if (kvp.Key.Equals(fieldName, StringComparison.OrdinalIgnoreCase))
                        {
                            eventConfig.AdditionalParams[fieldName] = null;
                            break;
                        }
                    }
                    break;
            }

            OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
        }

        [ConsoleCommand("emui.creator")]
        private void ccmdSetField(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (!_eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig))
                return;

            if (arg.HasArgs(2))
            {
                SetParameter(player, eventConfig, arg.GetString(0), string.Join(" ", arg.Args.Skip(1)));

                OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
            }
        }

        #region Creator Helpers
        private void SetParameter(BasePlayer player, EventManager.EventConfig eventConfig, string fieldName, object value)
        {
            if (value == null)
                return;

            switch (fieldName)
            {
                case "eventName":
                    eventConfig.EventName = (string)value;
                    break;
                case "zoneID":
                    eventConfig.ZoneID = (string)value;
                    break;
                case "timeLimit":
                    {
                        if (!TryConvertValue<int>(value, out int intValue))
                            CreateMenuPopup(player, "You must enter a number");
                        else eventConfig.TimeLimit = intValue;
                    }                   
                    break;
                case "scoreLimit":
                    {
                        if (!TryConvertValue<int>(value, out int intValue))
                            CreateMenuPopup(player, "You must enter a number");
                        else eventConfig.ScoreLimit = intValue;
                    }                    
                    break;
                case "minimumPlayers":
                    {
                        if (!TryConvertValue<int>(value, out int intValue))
                            CreateMenuPopup(player, "You must enter a number");
                        else eventConfig.MinimumPlayers = intValue;
                    }                    
                    break;
                case "maximumPlayers":
                    {
                        if (!TryConvertValue<int>(value, out int intValue))
                            CreateMenuPopup(player, "You must enter a number");
                        else eventConfig.MaximumPlayers = intValue;
                    }                    
                    break;
                case "teamASpawnfile":
                    eventConfig.TeamConfigA.Spawnfile = (string)value;
                    break;
                case "teamBSpawnfile":
                    eventConfig.TeamConfigB.Spawnfile = (string)value;
                    break;
                case "useClassSelector":
                    {
                        if (!TryConvertValue<bool>(value, out bool boolValue))
                            CreateMenuPopup(player, "You must enter 'True' or 'False'");
                        else eventConfig.AllowClassSelection = boolValue;
                    }
                    break;
                case "teamAKits":
                    AddToRemoveFromList(eventConfig.TeamConfigA.Kits, (string)value);
                    break;
                case "teamBKits":
                    AddToRemoveFromList(eventConfig.TeamConfigB.Kits, (string)value);
                    break;
                case "teamAClothing":
                    eventConfig.TeamConfigA.Clothing = (string)value;
                    break;
                case "teamBClothing":
                    eventConfig.TeamConfigB.Clothing = (string)value;
                    break;
                case "teamAColor":
                    {
                        string color = (string)value;
                        if (string.IsNullOrEmpty(color) || color.Length < 6 || color.Length > 6 || !EventManager.IsValidHex(color))
                            CreateMenuPopup(player, "The color must be a 6 digit hex color, without the # prefix");
                        else eventConfig.TeamConfigA.Color = color;
                        break;
                    }
                case "teamBColor":
                    {
                        string color = (string)value;
                        if (string.IsNullOrEmpty(color) || color.Length < 6 || color.Length > 6 || !EventManager.IsValidHex(color))
                            CreateMenuPopup(player, "The color must be a 6 digit hex color, without the # prefix");
                        else eventConfig.TeamConfigB.Color = color;
                        break;
                    }
                default:
                    List<EventManager.EventParameter> additionalParameters = eventConfig.Plugin?.AdditionalParameters;
                    if (additionalParameters != null)
                    {
                        for (int i = 0; i < additionalParameters.Count; i++)
                        {
                            EventManager.EventParameter eventParameter = additionalParameters[i];

                            if (!eventConfig.AdditionalParams.ContainsKey(eventParameter.Field))
                            {
                                if (eventParameter.IsList)
                                    eventConfig.AdditionalParams[eventParameter.Field] = new List<string>();
                                else eventConfig.AdditionalParams[eventParameter.Field] = eventParameter.DefaultValue == null ? null : eventParameter.DefaultValue;
                            }

                            if (fieldName.Equals(eventParameter.Field, StringComparison.OrdinalIgnoreCase))
                            {
                                object success = eventConfig.Plugin.ParameterIsValid(fieldName, value);
                                if (success != null)
                                {
                                    CreateMenuPopup(player, (string)success);
                                    return;
                                }

                                switch (eventParameter.DataType)
                                {
                                    case "string":
                                        eventConfig.AdditionalParams[eventParameter.Field] = (string)value;
                                        break;
                                    case "int":
                                        if (!TryConvertValue<int>(value, out int intValue))
                                            CreateMenuPopup(player, "You must enter a number");
                                        else eventConfig.AdditionalParams[eventParameter.Field] = intValue;
                                        break;
                                    case "float":
                                        if (!TryConvertValue<float>(value, out float floatValue))
                                            CreateMenuPopup(player, "You must enter a number");
                                        else eventConfig.AdditionalParams[eventParameter.Field] = floatValue;                                        
                                        break;
                                    case "bool":
                                        if (!TryConvertValue<bool>(value, out bool boolValue))
                                            CreateMenuPopup(player, "You must enter 'True' or 'False'");
                                        else eventConfig.AdditionalParams[eventParameter.Field] = boolValue;                                        
                                        break;
                                    case "List<string>":
                                        AddToRemoveFromList(eventConfig.AdditionalParams[eventParameter.Field] as List<string>, (string)value);
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                    return;
            }
        }

        private bool TryConvertValue<T>(object value, out T result)
        {
            try
            {
                result = (T)Convert.ChangeType(value, typeof(T));
                return true;
            }
            catch
            {
                result = default(T);
                return false;
            }            
        }

        private void AddToRemoveFromList(List<string> list, string value)
        {
            if (list.Contains(value))
                list.Remove(value);
            else list.Add(value);
        }
        #endregion
        #endregion

        #region Death Screen Commands
        [ConsoleCommand("emui.toggleautospawn")]
        private void ccmdToggleAutoSpawn(ConsoleSystem.Arg arg)
        {
            EventManager.BaseEventPlayer eventPlayer = arg.Player()?.GetComponent<EventManager.BaseEventPlayer>();
            if (eventPlayer == null || !eventPlayer.IsDead)
                return;

            eventPlayer.AutoRespawn = !eventPlayer.AutoRespawn;
            UpdateRespawnButton(eventPlayer);
        }

        [ConsoleCommand("emui.respawn")]
        private void ccmdRespawn(ConsoleSystem.Arg arg)
        {
            EventManager.BaseEventPlayer eventPlayer = arg.Player()?.GetComponent<EventManager.BaseEventPlayer>();
            if (eventPlayer == null || !eventPlayer.IsDead || !eventPlayer.CanRespawn)
                return;

            if (string.IsNullOrEmpty(eventPlayer.Kit))
                return;

            eventPlayer.IsSelectingClass = false;

            EventManager.RespawnPlayer(eventPlayer);            
        }

        [ConsoleCommand("emui.selectkit")]
        private void ccmdSelectKit(ConsoleSystem.Arg arg)
        {
            EventManager.BaseEventPlayer eventPlayer = arg.Player()?.GetComponent<EventManager.BaseEventPlayer>();
            if (eventPlayer == null || !eventPlayer.IsDead)
                return;

            eventPlayer.Kit = CommandSafe(arg.GetString(0), true);
            eventPlayer.IsSelectingClass = arg.GetBool(1);

            UpdateRespawnButton(eventPlayer);
        }
        #endregion

        #region General Commands
        [ConsoleCommand("emui.close")]
        private void ccmdCloseUI(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.DestroyUi(player, UI_POPUP);
        }

        [ConsoleCommand("emui.joinevent")]
        private void ccmdJoinEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (EventManager.BaseManager.CanJoinEvent(player))
            {
                EventManager.BaseManager.JoinEvent(player);

                if (EventManager.BaseManager.Status < EventManager.EventStatus.Prestarting)
                {
                    OpenMenu(player, new MenuArgs(MenuTab.Event));
                    CreateMenuPopup(player, Message("UI.Popup.EnterEvent", player.userID));
                }
            }
        }

        [ConsoleCommand("emui.leaveevent")]
        private void ccmdLeaveEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            DestroyAllUI(player);

            EventManager.BaseManager.LeaveEvent(player);

            if (EventManager.BaseManager.Status < EventManager.EventStatus.Prestarting)
            {
                OpenMenu(player, new MenuArgs(MenuTab.Event));
                CreateMenuPopup(player, Message("UI.Popup.LeaveEvent", player.userID));
            }
        }
        #endregion

        #region Menu Selection
        [ConsoleCommand("emui.statistics")]
        private void ccmdStatistics(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            OpenMenu(player, new MenuArgs((StatisticTab)arg.GetInt(0), (EventStatistics.Statistic)arg.GetInt(1), arg.GetInt(2)));
        }

        [ConsoleCommand("emui.event")]
        private void ccmdEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            _eventCreators.Remove(player.userID);

            OpenMenu(player, new MenuArgs(arg.GetInt(0), (MenuTab)arg.GetInt(1)));
        }
        #endregion

        #region Event Management
        [ConsoleCommand("emui.eventselector")]
        private void ccmdOpenEventSelector(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                AdminTab adminTab = (AdminTab)arg.GetInt(0);

                switch (adminTab)
                {
                    case AdminTab.OpenEvent:
                        OpenMenu(player, new MenuArgs(new SelectorArgs("Select an event to open", SelectionType.Event, "emui.openevent"), adminTab, 0));
                        break;
                    case AdminTab.EditEvent:
                        OpenMenu(player, new MenuArgs(new SelectorArgs("Select an event to edit", SelectionType.Event, "emui.editevent"), adminTab, 0));
                        break;
                    case AdminTab.DeleteEvent:
                        OpenMenu(player, new MenuArgs(new SelectorArgs("Select an event to delete", SelectionType.Event, "emui.deleteevent"), adminTab, 0));
                        break;
                    default:
                        break;
                }
            }
        }

        [ConsoleCommand("emui.openevent")]
        private void ccmdOpenEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                string eventName = CommandSafe(arg.GetString(0), true);

                object success = EventManager.Instance.OpenEvent(eventName);

                if (success == null)
                {
                    CreateMenuPopup(player, $"Opened event {eventName}");
                    OpenMenu(player, new MenuArgs(0, MenuTab.Event));
                }
                else CreateMenuPopup(player, (string)success);
            }
        }

        [ConsoleCommand("emui.endevent")]
        private void ccmdEndEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                CreateMenuPopup(player, $"Cancelled event {EventManager.BaseManager.Config.EventName}");
                EventManager.BaseManager.EndEvent();

                OpenMenu(player, new MenuArgs(0, MenuTab.Admin));
            }
        }

        [ConsoleCommand("emui.startevent")]
        private void ccmdStartEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                if (EventManager.BaseManager.joiningPlayers.Contains(player))
                    DestroyAllUI(player);
                else
                {
                    OpenMenu(player, new MenuArgs(0, MenuTab.Admin));
                    CreateMenuPopup(player, "Event pre-start initiated");
                }

                EventManager.BaseManager.PrestartEvent();                
            }
        }

        [ConsoleCommand("emui.closeevent")]
        private void ccmdCloseEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                CreateMenuPopup(player, $"Closed event {EventManager.BaseManager.Config.EventName} to new players");
                EventManager.BaseManager.CloseEvent();
                OpenMenu(player, new MenuArgs(0, MenuTab.Admin));
            }
        }
        #endregion

        [ConsoleCommand("emui.editevent")]
        private void ccmdEditEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                string eventName = CommandSafe(arg.GetString(0), true);

                EventManager.EventConfig eventConfig = EventManager.Instance.Events.events[eventName];
                eventConfig.Plugin = EventManager.Instance.GetPlugin(eventConfig.EventType);

                if (eventConfig.Plugin != null)
                {
                    CreateMenuPopup(player, $"Editing event {eventName} ({eventConfig.EventType})");
                    _eventCreators[player.userID] = eventConfig;
                    OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
                }
                else CreateMenuPopup(player, $"The event plugin {eventConfig.EventType} is not loaded");
            }
        }

        [ConsoleCommand("emui.deleteevent")]
        private void ccmdDeleteEvent(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                string eventName = CommandSafe(arg.GetString(0), true);

                CreateMenuPopup(player, $"Deleted event {eventName}");

                EventManager.Instance.Events.events.Remove(eventName);

                EventManager.Instance.SaveEventData();

                OpenMenu(player, new MenuArgs(AdminTab.None));
            }
        }

        [ConsoleCommand("emui.closeselector")]
        private void ccmdCloseSelector(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
            }
        }

        [ConsoleCommand("emui.fieldselector")]
        private void ccmdOpenSelector(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                OpenMenu(player, new MenuArgs(new SelectorArgs(CommandSafe(arg.GetString(0), true), arg.GetString(1), arg.GetString(2), arg.GetBool(3)), 0));
            }
        }

        [ConsoleCommand("emui.select")]
        private void ccmdSelect(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null)
                return;

            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, EventManager.ADMIN_PERMISSION))
            {
                if (!_eventCreators.TryGetValue(player.userID, out EventManager.EventConfig eventConfig))
                    return;

                SetParameter(player, eventConfig, arg.GetString(1), CommandSafe(arg.GetString(4), true));

                if (arg.GetBool(3))
                    OpenMenu(player, new MenuArgs(new SelectorArgs(CommandSafe(arg.GetString(0), true), arg.GetString(1), arg.GetString(2), true), 0));

                else OpenMenu(player, new MenuArgs(AdminTab.CreateEvent));
            }
        }

        #region Command Helpers
        private static string CommandSafe(string text, bool unpack = false) => unpack ? text.Replace("▊▊", " ") : text.Replace(" ", "▊▊");
        #endregion
        #endregion

        #region UI
        internal const string UI_MENU = "emui.menu";
        internal const string UI_TIMER = "emui.timer";
        internal const string UI_SCORES = "emui.scores";
        internal const string UI_POPUP = "emui.popup";
        internal const string UI_DEATH = "emui.death";
        internal const string UI_RESPAWN = "emui.respawn";

        internal static void DestroyAllUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.DestroyUi(player, UI_DEATH);
            CuiHelper.DestroyUi(player, UI_POPUP);
            CuiHelper.DestroyUi(player, UI_RESPAWN);
            CuiHelper.DestroyUi(player, UI_SCORES);
            CuiHelper.DestroyUi(player, UI_TIMER);
        }

        public static class UI
        {
            public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = color },
                            RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return container;
            }


            public static CuiElementContainer Popup(string panelName, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter, string parent = "Overlay")
            {
                CuiElementContainer container = UI.Container(panelName, "0 0 0 0", dimensions, false);

                UI.Label(container, panelName, text, size, UI4.Full, align);

                return container;
            }

            public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Button(CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            public static void Input(CuiElementContainer container, string panel, string text, int size, string command, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = TextAnchor.MiddleLeft,
                            CharsLimit = 300,
                            Command = command + text,
                            FontSize = size,
                            IsPassword = false,
                            Text = text
                        },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Image(CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Toggle(CuiElementContainer container, string panel, string boxColor, int fontSize, UI4 dimensions, string command, bool isOn)
            {
                UI.Panel(container, panel, boxColor, dimensions);

                if (isOn)
                    UI.Label(container, panel, "✔", fontSize, dimensions);

                UI.Button(container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');

                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        public class UI4
        {
            public float xMin, yMin, xMax, yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {yMin}";

            public string GetMax() => $"{xMax} {yMax}";

            private static UI4 _full;

            public static UI4 Full
            {
                get
                {
                    if (_full == null)
                        _full = new UI4(0, 0, 1, 1);
                    return _full;
                }
            }
        }
        #endregion

        #region Config        
        public class ConfigData
        {
            [JsonProperty(PropertyName = "Death screen skull image")]
            public string DeathIcon { get; set; }

            [JsonProperty(PropertyName = "Death screen background image")]
            public string DeathBackground { get; set; }

            [JsonProperty(PropertyName = "Menu Colors")]
            public MenuColors Menu { get; set; }

            [JsonProperty(PropertyName = "Scoreboard Colors")]
            public ScoreboardColors Scoreboard { get; set; }

            public class MenuColors
            {
                [JsonProperty(PropertyName = "Background Color")]
                public UIColor Background { get; set; }

                [JsonProperty(PropertyName = "Foreground Color")]
                public UIColor Foreground { get; set; }

                [JsonProperty(PropertyName = "Panel Color")]
                public UIColor Panel { get; set; }                

                [JsonProperty(PropertyName = "Button Color")]
                public UIColor Button { get; set; }

                [JsonProperty(PropertyName = "Highlight Color")]
                public UIColor Highlight { get; set; }                
            }

            public class ScoreboardColors
            {
                [JsonProperty(PropertyName = "Background Color")]
                public UIColor Background { get; set; }

                [JsonProperty(PropertyName = "Foreground Color")]
                public UIColor Foreground { get; set; }

                [JsonProperty(PropertyName = "Panel Color")]
                public UIColor Panel { get; set; }

                [JsonProperty(PropertyName = "Highlight Color")]
                public UIColor Highlight { get; set; }

                [JsonProperty(PropertyName = "Screen Position")]
                public UIPosition Position { get; set; }
            }

            public class UIColor
            {
                public string Hex { get; set; }
                public float Alpha { get; set; }

                [JsonIgnore]
                private string _color;

                [JsonIgnore]
                public string Get
                {
                    get
                    {
                        if (string.IsNullOrEmpty(_color))
                            _color = EMInterface.UI.Color(Hex, Alpha);
                        return _color;
                    }
                }
            }

            public class UIPosition
            {                
                [JsonProperty(PropertyName = "Center Position X (0.0 - 1.0)")]
                public float CenterX { get; set; }

                [JsonProperty(PropertyName = "Center Position Y (0.0 - 1.0)")]
                public float CenterY { get; set; }

                [JsonProperty(PropertyName = "Panel Width")]
                public float Width { get; set; }

                [JsonProperty(PropertyName = "Panel Height")]
                public float Height { get; set; }

                private UI4 _ui4;

                public UI4 UI4
                {
                    get
                    {
                        if (_ui4 == null)
                            _ui4 = new UI4(CenterX - (Width * 0.5f), CenterY - (Height * 0.5f), CenterX + (Width * 0.5f), CenterY + (Height * 0.5f));
                        return _ui4;
                    }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                DeathBackground = "",
                DeathIcon = "https://www.rustedit.io/images/skullicon.png",
                Menu = new ConfigData.MenuColors
                {                    
                    Background = new ConfigData.UIColor { Hex = "#232323", Alpha = 1f },
                    Foreground = new ConfigData.UIColor { Hex = "#252526", Alpha = 1f },
                    Panel = new ConfigData.UIColor { Hex = "#2d2d30", Alpha = 1f },
                    Button = new ConfigData.UIColor { Hex = "#3e3e42", Alpha = 1f },
                    Highlight = new ConfigData.UIColor { Hex = "#007acc", Alpha = 1f },
                },     
                Scoreboard = new ConfigData.ScoreboardColors
                {
                    Background = new ConfigData.UIColor { Hex = "#232323", Alpha = 0.8f },
                    Foreground = new ConfigData.UIColor { Hex = "#252526", Alpha = 0.8f },
                    Panel = new ConfigData.UIColor { Hex = "#2d2d30", Alpha = 0.8f },
                    Highlight = new ConfigData.UIColor { Hex = "#007acc", Alpha = 0.8f },
                    Position = new ConfigData.UIPosition { CenterX = 0.9325f, CenterY = 0.98f, Width = 0.125f, Height = 0.02f }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private static string Message(string key, ulong playerId = 0UL) => Instance.lang.GetMessage(key, Instance, playerId != 0UL ? playerId.ToString() : null);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["UI.Title"] = "Event Manager",
            ["UI.Statistics.Title"] = "Event Statistics",

            ["UI.Event.Current"] = "Current Event",
            ["UI.Event.NoEvent"] = "No event in progress",
            ["UI.Event.CurrentScores"] = "Scoreboard",
            ["UI.Event.NoScoresRecorded"] = "No scores have been recorded yet",
            ["UI.Event.TeamScore"] = "Team Scores",
            ["UI.Event.Previous"] = "Previous Event Scores",
            ["UI.Event.NoPrevious"] = "No event has been played yet",

            ["UI.Event.Name"] = "Name",
            ["UI.Event.Type"] = "Type",
            ["UI.Event.Status"] = "Status",
            ["UI.Event.Players"] = "Players",
            ["UI.Players.Format"] = "{0} / {1} ({2} joining)",
            ["UI.Event.TimeLimit"] = "Time Limit",
            ["UI.Event.ScoreLimit"] = "Score Limit",
            ["UI.Event.WinReward"] = "Win Reward",
            ["UI.Event.KillReward"] = "Kill Reward",
            ["UI.Event.HeadshotReward"] = "Headshot Reward",

            ["UI.Event.Leave"] = "Leave Event",
            ["UI.Event.Enter"] = "Enter Event",
            ["UI.Popup.EnterEvent"] = "You have entered the event",
            ["UI.Popup.LeaveEvent"] = "You have left the event",

            ["UI.Reward.Format"] = "{0} {1}",
            ["UI.Reward.Scrap"] = "Scrap",
            ["UI.Reward.Economics"] = "Coins",
            ["UI.Reward.ServerRewards"] = "RP",

            ["UI.Admin.Title"] = "Admin Options",
            ["UI.Admin.Start"] = "Start Event",
            ["UI.Admin.Close"] = "Close Event",
            ["UI.Admin.End"] = "End Event",
            ["UI.Admin.Kick"] = "Kick Player",
            ["UI.Admin.Open"] = "Open Event",
            ["UI.Admin.Edit"] = "Edit Event",
            ["UI.Admin.Create"] = "Create Event",
            ["UI.Admin.Delete"] = "Delete Event",

            ["UI.Menu.Admin"] = "Admin",
            ["UI.Menu.Statistics"] = "Statistics",
            ["UI.Menu.Event"] = "Event",

            ["UI.LeaveEvent"] = "Leave Event",
            ["UI.JoinEvent"] = "Join Event",

            ["UI.Statistics.Personal"] = "Personal Statistics",
            ["UI.Statistics.Global"] = "Global Statistics",
            ["UI.Statistics.Leaders"] = "Leader Boards",
            ["UI.NoStatisticsSaved"] = "No statistics have been recorded yet",

            ["UI.Rank"] = "Rank",
            ["UI.GamesPlayed"] = "Games Played",

            ["UI.Next"] = "Next",
            ["UI.Back"] = "Back",

            ["UI.Player"] = "Player",
            ["UI.Score"] = "Score",
            ["UI.Kills"] = "Kills",
            ["UI.Deaths"] = "Deaths",
            ["UI.Assists"] = "Kill Assists",
            ["UI.Headshots"] = "Headshots",
            ["UI.Melee"] = "Melee Kills",
            ["UI.Won"] = "Games Won",
            ["UI.Lost"] = "Games Lost",
            ["UI.Played"] = "Games Played",

            ["UI.Totals"] = "Total {0}",

            ["UI.Return"] = "Return",

            ["UI.Death.Leave"] = "Leave",
            ["UI.Death.Respawn"] = "Respawn",
            ["UI.Death.Respawn.Time"] = "Respawn ({0})",
            ["UI.Death.AutoRespawn"] = "Auto-Respawn",
            ["UI.Death.Class"] = "Change Class",

            ["UI.Score.TeamA"] = "Team A : {0}",
            ["UI.Score.TeamB"] = "Team B : {0}",
        };
        #endregion
    }
}


// --- End of file: EMInterface.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/empty-low-fps ---
// --- Original File Path: E/EmptyLowFPS/EmptyLowFPS.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System.IO;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Empty Low FPS", "Wulf/lukespragg", "1.0.2")]
    [Description("Sets the server frame rate limit to lower when empty to save CPU usage")]
    class EmptyLowFPS : CovalencePlugin
    {
        #region Configuration

        // DEFAULT FRAME RATE LIMITS
        // #########################
        // 7 Days to Die:  20?
        // Hurtworld:      -1 (no limit)
        // Reign of Kings: 60
        // Rust:           256
        // Unturned:       50

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Frame rate limit when empty")]
            public int FpsLimitEmpty { get; set; } = 10;

            [JsonProperty(PropertyName = "Frame rate limit when not empty")]
            public int FpsLimitNotEmpty { get; set; } = 60;

            [JsonProperty(PropertyName = "Log frame rate limit changes")]
            public bool LogChanges { get; set; } = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}";
                LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}.json");
                Config.WriteObject(config, false, $"{configPath}_invalid.json");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        private void OnServerInitialized()
        {
            if (players.Connected.Any())
            {
                NotEmptyFpsLimit();
            }
            else
            {
                EmptyFpsLimit();
            }
        }

        private void OnUserConnected()
        {
            if (players.Connected.Count() <= 1)
            {
                NotEmptyFpsLimit();
            }
        }

        private void OnUserDisconnected()
        {
            if (players.Connected.Count() <= 1)
            {
                EmptyFpsLimit();
            }
        }

        private void Unload()
        {
            NotEmptyFpsLimit();
        }

        private void EmptyFpsLimit()
        {
            if (config.LogChanges)
            {
                LogWarning("Server is empty, setting FPS limit to " + config.FpsLimitEmpty);
            }

#if HURTWORLD || REIGNOFKINGS || RUST || UNTURNED
            UnityEngine.Application.targetFrameRate = config.FpsLimitEmpty;
#elif SEVENDAYSTODIE
            GameManager.Instance.waitForTargetFPS.TargetFPS = config.FpsLimitEmpty;
#else
            LogWarning("Setting the frame rate is currently not supported for " + covalence.Game.Humanize());
#endif
        }

        private void NotEmptyFpsLimit()
        {
            if (config.LogChanges)
            {
                LogWarning("Server is no longer empty, setting FPS limit to " + config.FpsLimitNotEmpty);
            }

#if HURTWORLD || REIGNOFKINGS || RUST || UNTURNED
            UnityEngine.Application.targetFrameRate = config.FpsLimitNotEmpty;
#elif SEVENDAYSTODIE
            GameManager.Instance.waitForTargetFPS.TargetFPS = config.FpsLimitNotEmpty;
#else
            LogWarning("Setting the frame rate is currently not supported for " + covalence.Game.Humanize());
#endif
        }
    }
}


// --- End of file: EmptyLowFPS.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/external-wall-decay-protection ---
// --- Original File Path: E/ExternalWallDecayProtection/ExternalWallDecayProtection.cs ---

using System;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("External Wall Decay Protection", "Orange", "1.0.0")]
    [Description("Adding protection from decay to walls")]
    public class ExternalWallDecayProtection : RustPlugin
    {
        #region Config
        
        private float protection1;
        private float protection2;

        protected override void LoadDefaultConfig()
        {
            Config["Walls protection from decay out of TC"] = protection1 = GetConfig("Walls protection from decay out of TC", 100);
            Config["Walls protection from decay in TC"] = protection2 = GetConfig("Walls protection from decay in TC", 100);
            SaveConfig();
        }
        
        T GetConfig<T>(string name, T value)
        {
            return Config[name] == null ? value : (T) Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            LoadDefaultConfig();
            CheckEntities();
        }
        
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity.PrefabName.Contains("external.high"))
            {
                AddProtection(entity);
            }
        }

        #endregion

        #region Helpers

        private void CheckEntities()
        {
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseEntity>().Where(x => x.PrefabName.Contains("external.high")))
            {
                AddProtection(entity);   
            }
        }
        
        private void AddProtection(BaseNetworkable entity)
        {
            var ent = entity.GetComponent<BaseCombatEntity>();
            if(ent == null) {return;}
            var value = ent.GetBuildingPrivilege() == null ? protection1 : protection2;
            if (ent.baseProtection.Get(DamageType.Decay) != value) {ent.baseProtection.Add(DamageType.Decay, value);}
        }

        #endregion
    }
}

// --- End of file: ExternalWallDecayProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extra-loot ---
// --- Original File Path: E/ExtraLoot/ExtraLoot.cs ---

#define DEBUG
using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using UnityEngine;


//ExtraLoot created with PluginMerge v(1.0.4.0) by MJSU @ https://github.com/dassjosh/Plugin.Merge
namespace Oxide.Plugins
{
    [Info("Extra Loot", "Shady14u", "1.0.8")]
    [Description("Add extra items (including custom) to any loot container in the game")]
    public partial class ExtraLoot : RustPlugin
    {
        #region 0.ExtraLoot.cs
        private void SpawnLoot(LootContainer container)
        {
            if (container == null) return;
            
            List<BaseItem> items;
            if (!_config.Containers.TryGetValue(container.ShortPrefabName, out items))
            {
                return;
            }
            
            var maxItems = _config.MaxItemsPerContainer;
            var cnt = 0;
            foreach (var value in items)
            {
                if (!(value.Chance >= UnityEngine.Random.Range(0f, 100f))) continue;
                
                var height = container.transform.position.y;
                
                if (value.MinHeight != 0 && height < value.MinHeight) continue;
                if (value.MaxHeight != 0 && height > value.MaxHeight) continue;
                
                var amount = UnityEngine.Random.Range(value.AmountMin, value.AmountMax + 1);
                var shortName = value.IsBlueprint ? "blueprintbase" : value.ShortName;
                var item = ItemManager.CreateByName(shortName, amount, value.SkinId);
                
                if (item == null) continue;
                
                item.name = value.DisplayName;
                item.blueprintTarget = value.IsBlueprint ? ItemManager.FindItemDefinition(value.ShortName).itemid : 0;
                
                item.MoveToContainer(container.inventory);
                container.inventory.MarkDirty();
                cnt++;
                if (maxItems > 0 && cnt >= maxItems) return;
            }
        }
        #endregion

        #region 1.ExtraLoot.Config.cs
        private static Configuration _config;
        
        public class Configuration
        {
            [JsonProperty(PropertyName = "ShortName -> Items")]
            public Dictionary<string, List<BaseItem>> Containers;
            
            [JsonProperty(PropertyName = "Max Extra Items Per Container")]
            public int MaxItemsPerContainer;
            
            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    
                    Containers = new Dictionary<string, List<BaseItem>>
                    {
                        ["crate_normal"] = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                ShortName = "pistol.revolver",
                                Chance = 50,
                                AmountMin = 1,
                                AmountMax = 1,
                                SkinId = 0,
                                DisplayName = "Recipe",
                                IsBlueprint = true
                            },
                            new BaseItem
                            {
                                ShortName = "box.repair.bench",
                                Chance = 30,
                                AmountMin = 1,
                                AmountMax = 2,
                                SkinId = 1594245394,
                                DisplayName = "Recycler",
                                IsBlueprint = false
                            },
                            new BaseItem
                            {
                                ShortName = "autoturret",
                                Chance = 30,
                                AmountMin = 1,
                                AmountMax = 2,
                                SkinId = 1587601905,
                                DisplayName = "Sentry Turret",
                                IsBlueprint = false
                            },
                            new BaseItem
                            {
                                ShortName = "paper",
                                Chance = 30,
                                AmountMin = 1,
                                AmountMax = 1,
                                SkinId = 1602864474,
                                DisplayName = "Recipe",
                                IsBlueprint = false
                            },
                            new BaseItem
                            {
                                ShortName = "paper",
                                Chance = 30,
                                AmountMin = 1,
                                AmountMax = 1,
                                SkinId = 1602955228,
                                DisplayName = "Recipe",
                                IsBlueprint = false
                            },
                        },
                        ["crate_elite"] = new List<BaseItem>
                        {
                            new BaseItem
                            {
                                ShortName = "paper",
                                Chance = 15,
                                AmountMin = 1,
                                AmountMax = 1,
                                SkinId = 1602864474,
                                DisplayName = "Recipe"
                            },
                            new BaseItem
                            {
                                ShortName = "paper",
                                Chance = 15,
                                AmountMin = 1,
                                AmountMax = 1,
                                SkinId = 1602955228,
                                DisplayName = "Recipe"
                            },
                        },
                    }
                    
                };
            }
        }
        
        
        #region BoilerPlate
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        
        #endregion
        #endregion

        #region 5.ExtraLoot.Hooks.cs
        private void OnLootSpawn(LootContainer container)
        {
            NextTick(() => { SpawnLoot(container); });
        }
        #endregion

        #region 7.ExtraLoot.Classes.cs
        public class BaseItem
        {
            [JsonProperty(PropertyName = "1. ShortName")]
            public string ShortName;
            
            [JsonProperty(PropertyName = "2. Chance")]
            public float Chance;
            
            [JsonProperty(PropertyName = "3. Minimal amount")]
            public int AmountMin;
            
            [JsonProperty(PropertyName = "4. Maximal Amount")]
            public int AmountMax;
            
            [JsonProperty(PropertyName = "5. Skin Id")]
            public ulong SkinId;
            
            [JsonProperty(PropertyName = "6. Display Name")]
            public string DisplayName;
            
            [JsonProperty(PropertyName = "7. Blueprint")]
            public bool IsBlueprint;
            
            [JsonProperty(PropertyName = "8. Min Spawn Height")]
            public float MinHeight;
            
            [JsonProperty(PropertyName = "9. Max Spawn Height")]
            public float MaxHeight;
        }
        #endregion

    }

}


// --- End of file: ExtraLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/excavator-lock ---
// --- Original File Path: E/ExcavatorLock/ExcavatorLock.cs ---

﻿#define _DEBUG
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Text;
using UnityEngine.Networking;
using Facepunch;
 
// rev 0.4.25
//    some correction to the lang file

namespace Oxide.Plugins
{
    [Info("Excavator Lock", "Lorenzo", "0.4.37")]
    [Description("Lock excavator to a player/team/clan when it run")]
    class ExcavatorLock : CovalencePlugin
    {
        [PluginReference] private Plugin Clans;
        [PluginReference] private Plugin Notify;

        #region Variables

        private static ExcavatorLock _instance;
        private static DiscordComponent _discord = null;

        private const string PermissionAdmin = "excavatorlock.admin";
        private const ulong supplyDropSkinID = 234501;

        private const string PREFAB_ITEM_DROP = "assets/prefabs/misc/item drop/item_drop.prefab";

        string TraceFile = "Trace";     // file name in log directory

#if CARBON
        const char Platform = 'C';
#else
        const char Platform = 'O';
#endif

        #endregion

        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Use permission")]
            public bool UsePermission = false;      // use permission or grant access to players

            [JsonProperty(PropertyName = "Permission")]
            public string Permission = "excavatorlock.use";   // name of permission

            [JsonProperty(PropertyName = "Allow access to excavator without permission (will not lock)")]
            public bool UseExcavatorWithoutPermission = false;

            [JsonProperty(PropertyName = "Multiplier permission")]
            public bool MultiplierPermission = false;      // use permission or grant access to every players

            [JsonProperty(PropertyName = "Permission For Multiplier")]
            public string PermissionMult = "excavatorlock.multiplier";   // name of permission for multiplier

            [JsonProperty(PropertyName = "CoolDown before releasing excavator")]
            public float CoolDown = 5;      // 5 minute cooldown after excavator finish and anybody can loot

            [JsonProperty(PropertyName = "Send Excavator available Message to All")]
            public bool MessageAll = true;

            [JsonProperty(PropertyName = "Enable engine loot after it is started to add diesel")]
            public bool engineloot = true;

            // In case clans pluginis installed but you dont want to use it with this plugin
            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams = true;

            // In case clans pluginis installed but you dont want to use it with this plugin
            [JsonProperty(PropertyName = "Use Clans plugin")]
            public bool UseClans = false;

            [JsonProperty(PropertyName = "Use clan table")]
            public bool UseClanTable = false;

            [JsonProperty(PropertyName = "CoolDown before a player or team can restart the excavator (0 is disabled)")]
            public float PlayerCoolDown = 30;      // 60 minute cooldown after excavator finish and anybody can loot

            [JsonIgnore]
            public float _PlayerCoolDown = 30;      // internal value

            [JsonProperty(PropertyName = "Apply cooldown to all excavators")]
            public bool CoolDownGlobal = true;      // 60 minute cooldown after excavator finish and anybody can loot

            [JsonProperty(PropertyName = "Enable fuel modifier")]
            public bool enablefuelModifier = true;

            [JsonProperty(PropertyName = "Maximum stack size for diesel engine (-1 to disable function)")]
            public int DieselFuelMaxStackSize = -1;

            [JsonProperty(PropertyName = "Enable signal Computer lock")]
            public bool enableComputeLock = true;

            [JsonProperty(PropertyName = "Enable signal Computer message")]
            public bool enableComputeMesssage = true;

            [JsonProperty(PropertyName = "Running time per fuel units (time in seconds)")]
            public float runningTimePerFuelUnit = 120f;

            [JsonProperty(PropertyName = "Sulfur production multiplier ")]
            public float SulfurMult = 1f;

            [JsonProperty(PropertyName = "HQM production multiplier")]
            public float HQMMult = 1f;

            [JsonProperty(PropertyName = "Metal production multiplier")]
            public float MetalMult = 1f;

            [JsonProperty(PropertyName = "Stone production multiplier")]
            public float StoneMult = 1f;

            [JsonProperty(PropertyName = "Excavator chat command")]
            public string excavatorquerry = "excavator";

            [JsonProperty(PropertyName = "Excavator clear status")]
            public string excavatorclearstatus = "excavatorclear";

            [JsonProperty(PropertyName = "Excavator stop command")]
            public string excavatorStop = "excavatorstop";

            [JsonProperty(PropertyName = "Empty the output piles when excavator start")]
            public bool FlushOutputPiles = false;

            [JsonProperty(PropertyName = "Charge needed for supply drop (0 to use default of 600sec)")]
            public long  chargeNeededForSupplies = 0;

            [JsonProperty(PropertyName = "Clear excavator lock after all player from team/clan disconnect ")]
            public bool ClearExcavatorLockOnAllTeamDisconnect = false;

            [JsonProperty(PropertyName = "Clear excavator lock after player owner disconnect")]
            public bool ClearExcavatorLockOnPlayerOwnerDisconnect = false;

            [JsonProperty(PropertyName = "Time after all player disconnect before excavator clear (minutes)")]
            public long CooldownExcavatorLockOnDisconnect = 10;    // default 10 minutes

            [JsonProperty(PropertyName = "Items in report list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] ReportItems = { "stones", "metal.ore", "metal.fragments", "hq.metal.ore", "metal.refined", "sulfur.ore", "sulfur", "lowgradefuel", "crude.oil" };

            [JsonProperty("Use Discord hook")]
            public bool Discordena = false;

            [JsonProperty("Use Discord timestamp")]
            public bool UseDiscordTimestamp = true;
			
            [JsonProperty("Discord hook url")]
            public string DiscordHookUrl = "";

            [JsonProperty(PropertyName = "Use Notify plugin")]
            public bool useNotify = false;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;

            [JsonProperty(PropertyName = "Log to file")]
            public bool LogToFile = false;			
        };

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            _config.SulfurMult = Mathf.Clamp(_config.SulfurMult, 0f, 100000f);
            _config.HQMMult    = Mathf.Clamp(_config.HQMMult,   0f, 100000f);
            _config.MetalMult  = Mathf.Clamp(_config.MetalMult, 0f, 100000f);
            _config.StoneMult  = Mathf.Clamp(_config.StoneMult, 0f, 100000f);

            _config._PlayerCoolDown = Math.Max(_config.PlayerCoolDown, _config.CoolDown);

            if (_config.ClearExcavatorLockOnAllTeamDisconnect == true && _config.ClearExcavatorLockOnPlayerOwnerDisconnect == true)
            {
                PrintError("Both ClearExcavatorLockOnAllTeamDisconnect and ClearExcavatorLockOnPlayerOwnerDisconnect are true. Using team mode by default");
                _config.ClearExcavatorLockOnPlayerOwnerDisconnect = false;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

#endregion Configuration

        // ############################################################################################

#region UserInfo

        private Dictionary<ulong, ExcavatorInfo> Excavators = new Dictionary<ulong, ExcavatorInfo>();

        // dict to link all the diff component entity to the right excavator
        private Dictionary<ulong, ulong> Associate = new Dictionary<ulong, ulong>();

        private class ExcavatorInfo
        {
            public ulong playerid;
            public string displayName;
            [JsonIgnore]
            public double FuelTimeRemaining;
            [JsonIgnore]
            public bool state;      // is the excavator running

            public DateTime fueltime;
            public DateTime stoptime;
            public string Name;

            public Dictionary<ulong, CooldownTime> PlayerCooldown;

            [JsonIgnore]
            public DateTime PlayerDisconnectTime;
            [JsonIgnore]
            public int CountTick;

            [JsonIgnore]
            public ExcavatorArm Arm;

            [JsonIgnore]
            public Timer timerStopped = null;

            [JsonIgnore]
            public float[] extraMineralProduced = { 0f, 0f, 0f, 0f };
            [JsonIgnore]
            public int pileIndex = 0;

            public ExcavatorInfo()
            {
                playerid = 0;
                displayName = string.Empty;
                FuelTimeRemaining = 0f;
                state = false;
                PlayerDisconnectTime = DateTime.MaxValue;

                fueltime  = DateTime.MinValue;
                stoptime  = DateTime.MinValue;
                Name = "nobody";
                PlayerCooldown = new Dictionary<ulong, CooldownTime>();
                CountTick = 10;
                Arm = null;
            }
        }

        public class CooldownTime
        {
            public bool IsOnline;
            public bool IgnoreOnline;
            public DateTime Time;
            public CooldownTime() { IsOnline = true; Time = DateTime.MinValue; IgnoreOnline = false; }
        }

        private void LoadData()
        {
            try {
                Excavators = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ExcavatorInfo>>(Name);
                if (Excavators == null) throw new Exception();
            }
            catch {
                Excavators = new Dictionary<ulong, ExcavatorInfo>();
                PrintWarning($"Data file corrupted or incompatible. Reinitialising data file ");
                SaveData();
            }
        }

        private void SaveData() { Interface.Oxide.DataFileSystem.WriteObject(Name, Excavators); }

#endregion UserInfo

        // ############################################################################################

#region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ExcavatorOff"]      = "<color=#FF1500>- Excavator just turn off !</color>",
                ["ExcavatorCoolDown"] = "<color=#FF1500>- You have {0} minutes to get the ore, before it unlock to all</color>",
                ["ExcavatorInUse"]    = "<color=#FFA500>Excavator currently in use by {0}</color>",
                ["ExcavatorStartEngine"] = "Excavator started for {0,2:F0} minutes",
                ["ExcavatorStartEngineHM"] = "Excavator started for {0,2:F0} hour, {1,2:F0} minutes",
                ["ExcavatorStarted_"]  = "Excavator {0}, started by {1}. loot is protected",
                ["ExcavatorStoped_"]   = "Excavator {0}, stopped and is available to all",
                ["ExcavatorFuel"]     = "<color=#FFA500>Excavator currently running with {0} fuel in storage</color>",
                ["ExcavatorPlCooldown"] = "Excavator Player cooldown will expire in {0} minutes",
                ["ExcavatorAvailableIn1"] = "Excavator {0}, used by {2}, will be available in {1,2:F0} minutes",
                ["ExcavatorClearStatus"] = "Clearing the excavator status",
                ["ExcavatorPermission"] = "Player does not have permission to use excavator",
                ["ExcavatorSupplySignal"] = "Airdrop was activated at excavator {0} by player {1}, please do not steal",
                ["ExcavatorClearOffline"] = "Excavator {0}, cleared because team/clan player are offline",
                ["NoExcavatorFoundNear"] = "No excavator found near to apply command",
                ["MoveFuelToOutput"] = "Stop excavator, moving fuel to output pile",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ExcavatorOff"]      = "<color=#FF1500>- l'excavateur viens de s'arrêter !</color>",
                ["ExcavatorCoolDown"] = "<color=#FF1500>- Vous avez {0} minutes pour récuperer le butin avant qu'il ne soit accessible pour tous !</color>",
                ["ExcavatorInUse"]    = "<color=#FFA500>l'excavateur est utilisé par {0}.</color>",
                ["ExcavatorStartEngine"] = "L'excavateur est démarré pour {0,2:F0} minutes.",
                ["ExcavatorStartEngineHM"] = "L'excavateur est démarré pour {0,2:F0} heure(s), {1,2:F0} minutes.",
                ["ExcavatorStarted_"]  = "L'excavateur {0} a été démarré par {1}. Le butin est protégé !",
                ["ExcavatorStoped_"]   = "Arret de l'excavateur {0}. Le butin est disponible pour tous !",
                ["ExcavatorFuel"]     = "<color=#FFA500>L'excavateur a été démarré avec {0} diesel(s) dans le reservoir.</color>",
                ["ExcavatorPlCooldown"] = "Le délai d'utilisation de l'Excavateur expire dans {0} minutes.",
                ["ExcavatorAvailableIn1"] = "L'excavateur {0}, utilisé par {2}, sera disponible dans {1,2:F0} minutes.",
                ["ExcavatorClearStatus"] = "Efface le status de l'excavateur.",
                ["ExcavatorPermission"] = "Le joueur n'a pas la permission d'utiliser l'excavateur.",
                ["ExcavatorSupplySignal"] = "Largage aérien activé a l'excavator {0} par le joueur {1}, s.v.p. ne pas voler.",
                ["ExcavatorClearOffline"] = "L'excavateur {0}, est libre, le l'equipe/clan s'est deconnecté !",
                ["NoExcavatorFoundNear"] = "Aucun excavateur trouvé, deplacez vous plus pres dèun excavateur",
                ["MoveFuelToOutput"] = "Arret de l'excavateur, transfert du diesel vers pile de sortie",
            }, this, "fr");
        }

        #endregion Localization

        #region Hooks Targets
        private void Unload()
        {
            SaveData();

            if (_config.chargeNeededForSupplies > 2) ExcavatorSignalComputer.chargeNeededForSupplies = 600f; // reset to default

            foreach (var KVP in Excavators)
            { 
                if (KVP.Value.timerStopped != null)
                {
                    timer.Destroy(ref KVP.Value.timerStopped);
                }
            }

            _instance = null;
           _discord = null;
		   _config = null;
        }

        private void Init()
        {
            _instance = this;

            permission.RegisterPermission(_config.Permission, this);
            permission.RegisterPermission(_config.PermissionMult, this);
            permission.RegisterPermission(PermissionAdmin, this);

            LoadData();

            if (!_config.ClearExcavatorLockOnAllTeamDisconnect &&
                !_config.ClearExcavatorLockOnPlayerOwnerDisconnect)
            {
                Unsubscribe(nameof(OnPlayerConnected));
                Unsubscribe(nameof(OnPlayerDisconnected));
            }

            AddCovalenceCommand(_config.excavatorquerry, nameof(Excavator_info));
            AddCovalenceCommand(_config.excavatorclearstatus, nameof(Excavator_clearstatus));
            AddCovalenceCommand(_config.excavatorStop, nameof(Excavator_stopcommand));
        }

        private void OnServerInitialized(bool initial)
        {
            if (_config.Discordena && !string.IsNullOrEmpty(_config.DiscordHookUrl))
            {
                var loader = new GameObject("WebObject");
                _discord = loader.AddComponent<DiscordComponent>().Configure(_config.DiscordHookUrl);
                PrintToLog($"Plugin Excavator Lock restarted");
            }

            // limit the range between 10 sec and 10 minutes per barrel 
            if (_config.runningTimePerFuelUnit < 10f)
            {
                PrintWarning("Warning, config.runningTimePerFuelUnit modifier is disabled. (runningTimePerFuelUnit < 10)");
                _config.runningTimePerFuelUnit = 10f;
            }

            if (_config.runningTimePerFuelUnit > 6000f)
            {
                PrintWarning("Warning, config.runningTimePerFuelUnit set to maximum at 6000 sec. (runningTimePerFuelUnit > 6000)");
                _config.runningTimePerFuelUnit = 6000f;
            }
            
            // this is just in case user think its in second and put a large value 
            if (_config.PlayerCoolDown > 120)
            {
                PrintWarning($"Configuration cooldown period {_config.PlayerCoolDown} minutes");
            }

            List<DieselEngine> engines = Pool.Get<List<DieselEngine>>();
            List<ExcavatorSignalComputer> Computes = Pool.Get<List<ExcavatorSignalComputer>>();
            engines.Clear();
            Computes.Clear();
            // count the excavator engine on the map
            foreach (var entarm in BaseNetworkable.serverEntities)
            {
                var arm = entarm as ExcavatorArm;
                if (arm != null)
                {
                    Vis.Entities<DieselEngine>(arm.transform.position, 20f, engines, -1);
                    Vis.Entities<ExcavatorSignalComputer>(arm.transform.position, 20f, Computes, -1);

                    ExcavatorInfo excavatorinfo;
                    if (!Excavators.TryGetValue(arm.net.ID.Value, out excavatorinfo))
                    {
                        excavatorinfo = new ExcavatorInfo();                        
                        Excavators.Add(arm.net.ID.Value, excavatorinfo);
                    }
                    excavatorinfo.Name = PositionToString(arm.transform.position);
                    excavatorinfo.Arm = arm;

                    // Associate engines to excavator in dictionary
                    foreach (var engine in engines)
                    {
                        // experiemntal max stack size
                        if (_config.DieselFuelMaxStackSize >= 0) engine.inventory.maxStackSize = _config.DieselFuelMaxStackSize;

                        excavatorinfo.state = engine.IsOn();

                        Associate.Add(engine.net.ID.Value, arm.net.ID.Value);
                        if (_config.enablefuelModifier) engine.runningTimePerFuelUnit = _config.runningTimePerFuelUnit;

                        if (excavatorinfo.state) excavatorinfo.FuelTimeRemaining = CalcFuelTime(engine);
                        else excavatorinfo.FuelTimeRemaining = 0;
                        excavatorinfo.fueltime = DateTime.Now.AddMinutes(excavatorinfo.FuelTimeRemaining);

                        break; // only one engine per excavator, ignore duplicates
                    }

                    // Associate outputpiles to excavator in dictionary
                    foreach (var outputpile in arm.outputPiles)
                    {
                        Associate.Add(outputpile.net.ID.Value, arm.net.ID.Value);
                    }


                    if (_config.chargeNeededForSupplies > 2) ExcavatorSignalComputer.chargeNeededForSupplies = (float)_config.chargeNeededForSupplies;

                    // Associate engines to excavator in dictionary
                    foreach (var compute in Computes)
                    {
                        Associate.Add(compute.net.ID.Value, arm.net.ID.Value);
                        break; // only one compute, ignore duplicates
                    }
                }
                engines.Clear();
                Computes.Clear();
            }
            Pool.FreeUnmanaged(ref engines);
            Pool.FreeUnmanaged(ref Computes);

            NextTick(() =>
            {
                // Check if the excavator entry exist 
                // If not remove it. This append when server wipe
                List<ulong> removals = new List<ulong>();
                foreach (KeyValuePair<ulong, ExcavatorInfo> kvp in  Excavators)
                {
                    if (kvp.Value.Arm == null)
                    {
                        PrintWarning($"Removing excavator info for {kvp.Key} ");
                        removals.Add(kvp.Key);
                    }
                }

                // cleanup dict entry of unused info
                foreach (ulong removeid in removals)
                {
                    Excavators.Remove(removeid);
                }

                if (_config.UseClans && !IspluginLoaded(Clans))
                {
                    PrintWarning("Optional Clans plugin not found. Clans disabled");
                }

                if (_config.useNotify && !IspluginLoaded(Notify))
                {
                    PrintWarning("Optional Notify plugin not found. Notify disabled");
                }
            });
        }

        object OnDieselEngineToggle(DieselEngine engine, BasePlayer player)
        {
            if (engine.skinID != 0UL)
                return null;
				
            ulong armID;
            ExcavatorInfo excavatorinfo = null;

            if (!Associate.TryGetValue(engine.net.ID.Value, out armID)) return null;  // allow if engine not associated with excavator
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return true;  // 

            bool perm = CanPlayerUse((ulong)player.userID);
            if (!perm && !_config.UseExcavatorWithoutPermission)
            {
                SendChatMessage(player, "ExcavatorPermission");
                return true;
            }

            // check if engine is off. 
            if (!engine.IsOn())
            {
                var checkcooldown = CheckPlayerCooldown((ulong)player.userID, excavatorinfo);

                // if Player cooldown is active, dont allow excavator restart
                if (checkcooldown)
                {
                    SendChatMessage(player, "ExcavatorPlCooldown", PlayerCooldownTime((ulong)player.userID, excavatorinfo));
                    return true;
                }

                // If excavator is captured, dont allow it to restart
                if (!IsExcavatorAvailable(excavatorinfo))
                {
                    SendChatMessage(player, "ExcavatorInUse", excavatorinfo.displayName);
                    return true;    // do not start excavator
                }

                if (perm)
                {
                    excavatorinfo.playerid = (ulong)player.userID;
                    excavatorinfo.displayName = player.displayName;
                    excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;
                }
                else
                {
                    excavatorinfo.playerid = 0;
                    excavatorinfo.displayName = "nobody";
                    excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;
                }

                PrintToLog($"Excavator engine {excavatorinfo.Name} started at : {DateTime.Now.ToString("hh:mm tt")}");
                return null;
            }

            return null;
        }

        double CalcFuelTime(DieselEngine engine) => (engine.cachedFuelTime + engine.runningTimePerFuelUnit * (float)engine.GetFuelAmount()) / 60f;

        // The engine was toggled. 
        void OnDieselEngineToggled(DieselEngine engine)
        {
            if (engine.skinID != 0UL)
                return;

            ulong armID;
            ExcavatorInfo excavatorinfo = null;

            if (!Associate.TryGetValue(engine.net.ID.Value, out armID)) return;  // 
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return;  // 

            excavatorinfo.state = engine.IsOn();
            if (excavatorinfo.state)
            {
                if (excavatorinfo.playerid != 0)
                {
                    // Excavator state is On
                    excavatorinfo.FuelTimeRemaining = CalcFuelTime(engine);
                    excavatorinfo.fueltime = DateTime.Now.AddMinutes(excavatorinfo.FuelTimeRemaining);
                    excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;

                    BasePlayer player = BasePlayer.FindByID(excavatorinfo.playerid);
                    if (player != null)
                    {
                        if (excavatorinfo.FuelTimeRemaining < 60) SendChatMessage(player, "ExcavatorStartEngine", Math.Ceiling(excavatorinfo.FuelTimeRemaining));
                        else SendChatMessage(player, "ExcavatorStartEngineHM", excavatorinfo.FuelTimeRemaining / 60, excavatorinfo.FuelTimeRemaining % 60);

                        if (_config.MessageAll)
                        {
                            BroadcastMessage("ExcavatorStarted_", excavatorinfo.Name, player.displayName);
                        }

                    }

                    // Start 
                    AddPlayerCooldown(excavatorinfo.playerid, excavatorinfo.FuelTimeRemaining, excavatorinfo);

                    if (_config.FlushOutputPiles)
                    {
                        var arm = excavatorinfo.Arm;
                        if (arm != null)
                        {
                            int cnt = 1;
                            foreach (var piles in arm.outputPiles)
                            {
                                var storage = piles.GetComponent<StorageContainer>();
                                PrintToLog($"Flush {cnt}/2 {ReportInventory(storage)} items from loot pile");
                                DropItemContainer(storage.inventory, piles.transform.position, Quaternion.identity);
                                cnt++;
                            }
                        }
                    }
                    if (excavatorinfo.timerStopped != null)
                    {
                        timer.Destroy(ref excavatorinfo.timerStopped);
                    }
                }
            }
            else
            {
                // Excavator state is Off
                if (excavatorinfo.playerid != 0)
                {
                    excavatorinfo.stoptime = DateTime.Now;
                    // Update cooldown info when the excavator stop
                    AddPlayerCooldown(excavatorinfo.playerid, 0f, excavatorinfo);

                    // player will be null when disconnected and wont receive message
                    var player = BasePlayer.FindByID(excavatorinfo.playerid);
                    if (player != null)
                    {
                        SendChatMessage(player, "ExcavatorOff");
                        SendChatMessage(player, "ExcavatorCoolDown", _config.CoolDown);
                    }

                    PrintToLog($"Excavator {excavatorinfo.Name} stopped at : {DateTime.Now.ToString("hh:mm tt")}");

                    if (excavatorinfo.timerStopped != null)
                    {
                        timer.Destroy(ref excavatorinfo.timerStopped);
                    }
                    excavatorinfo.timerStopped = timer.Once(_config.CoolDown * 60f, () =>
                    {
                        // In case excavator is resarted after cooldown
                        if (excavatorinfo!=null && !excavatorinfo.state)
                        {
                            if (_config.MessageAll) BroadcastMessage("ExcavatorStoped_", excavatorinfo.Name);
                            excavatorinfo.playerid = 0;
                            excavatorinfo.displayName = "nobody";
                            excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;
                            excavatorinfo.timerStopped = null;
                        }                            
                    });
                }
            }

            SaveData();
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container.skinID != 0UL)
                return null;

            // ID excavator_output_pile
            // ID engine
            if (container.prefabID == 673116596) return LootExcavatorOutputPile(player, container);    // "excavator_output_pile"
            else if (container.prefabID == 2982299738) return LootDieselEngine(player, container);     // "engine"
            else if (container.prefabID == 3632568684) return LootAirdrop(player, container);     // Airdrop
            return null;
        }

        void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            if (container.skinID != 0UL)
                return;

            if (container.prefabID == 2982299738) LootDieselEngineEnd(player, container);   // "engine"
        }

        void LootDieselEngineEnd(BasePlayer player, StorageContainer container)
        {
            if (container.skinID != 0UL)
                return;

            ulong armID;
            ExcavatorInfo excavatorinfo = null;

            var engine = container as DieselEngine;
            if (engine == null) return;

            if (!Associate.TryGetValue(engine.net.ID.Value, out armID)) return;
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return;

            if (excavatorinfo.state == true)
            {
                excavatorinfo.FuelTimeRemaining = CalcFuelTime(engine);
                excavatorinfo.fueltime = DateTime.Now.AddMinutes(excavatorinfo.FuelTimeRemaining);
                AddPlayerCooldown(excavatorinfo.playerid, excavatorinfo.FuelTimeRemaining, excavatorinfo);
            }

        }



        object LootExcavatorOutputPile(BasePlayer player, StorageContainer container)
        {
            ulong armID;
            ExcavatorInfo excavatorinfo = null;

            if (!Associate.TryGetValue(container.net.ID.Value, out armID)) return true;  // 
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return true;  // 

            if (IsAdmin((ulong)player.userID) || 
                excavatorinfo.playerid == 0 || 
                IsExcavatorAvailable(excavatorinfo))
            {
                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting pile not locked    loc:{excavatorinfo.Name}, {ReportInventory(container)} items in pile");
                return null;
            }

            if (((ulong)player.userID == excavatorinfo.playerid) ||
                (SameTeam((ulong)player.userID, excavatorinfo.playerid)) ||
                (SameClan((ulong)player.userID, excavatorinfo.playerid)))
            {
                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} looting pile owned by:{excavatorinfo.displayName}/{excavatorinfo.playerid}  loc:{excavatorinfo.Name}, {ReportInventory(container)} item in pile");
                return null;
            }

            SendChatMessage(player, "ExcavatorInUse", excavatorinfo.displayName);
            return true;
        }

        object LootDieselEngine(BasePlayer player, StorageContainer container)
        {
            if (container.skinID != 0UL)
                return null;

            ulong armID;
            ExcavatorInfo excavatorinfo = null;

            if (!Associate.TryGetValue(container.net.ID.Value, out armID)) return null;  // ignore engine not associated
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return true;  // 

            if (IsAdmin((ulong)player.userID) ||
                excavatorinfo.playerid == 0 ||
                (IsExcavatorAvailable(excavatorinfo) && !CheckPlayerCooldown((ulong)player.userID, excavatorinfo)))
            {
                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} Looting engine, not locked  pos:{excavatorinfo.Name}");
                return null;
            }
             
            if (((ulong)player.userID == excavatorinfo.playerid) ||
                (SameTeam((ulong)player.userID, excavatorinfo.playerid)) ||
                (SameClan((ulong)player.userID, excavatorinfo.playerid)))
            {
                if (!_config.engineloot) // cannot loot diesel engine if current user
                {
                    var amount = (container.inventory.itemList.Count != 0) ? container.inventory.itemList[0].amount + 1 : 1;
                    if (excavatorinfo.state) SendChatMessage(player, "ExcavatorFuel", amount.ToString());
                    else
                    {
                        SendChatMessage(player, "ExcavatorAvailableIn1", excavatorinfo.Name, PlayerCooldownTime((ulong)player.userID, excavatorinfo), excavatorinfo.displayName);
                    }
                    return true;   // disable engine loot
                }

                PrintToLog($"Player {player.displayName}/{(ulong)player.userID} Looting engine, locked to {excavatorinfo.displayName}/{excavatorinfo.playerid}  pos:{excavatorinfo.Name}");
                return null;
            }

            SendChatMessage(player, "ExcavatorInUse", excavatorinfo.displayName);
            return true;
        }

        object LootAirdrop(BasePlayer player, StorageContainer container)
        {
            ulong armID;
            ExcavatorInfo excavatorinfo;

            List<ExcavatorSignalComputer> Computes = Pool.Get<List<ExcavatorSignalComputer>>();
            Computes.Clear();
            Vis.Entities<ExcavatorSignalComputer>(container.transform.position, 90f, Computes, -1);

            if (Computes.Count != 0)
            {
                if (Associate.TryGetValue(Computes[0].net.ID.Value, out armID))
                {
                    if (Excavators.TryGetValue(armID, out excavatorinfo))
                    {
                        PrintToLog($"Player {player.displayName}/{(ulong)player.userID} Looting supply drop near excavator, locked to {excavatorinfo.displayName}/{excavatorinfo.playerid}  pos:{excavatorinfo.Name}  dist:{Vector3.Distance(Computes[0].transform.position, container.transform.position).ToString("F1")}");
                    }
                }
            }
            Pool.FreeUnmanaged(ref Computes);
            return null;
        }


        object OnExcavatorResourceSet(ExcavatorArm arm, string resourceName, BasePlayer player)
        {
            ExcavatorInfo excavatorinfo;
            if (!Excavators.TryGetValue(arm.net.ID.Value, out excavatorinfo)) return true;

            if (IsAdmin((ulong)player.userID) ||
                excavatorinfo.playerid == 0 ||
                IsExcavatorAvailable(excavatorinfo))
            {
                PrintToLog($"Excavator {excavatorinfo.Name} started at : {DateTime.Now.ToString("hh:mm tt")} for {excavatorinfo.FuelTimeRemaining} minutes, not locked to player {excavatorinfo.displayName}/{excavatorinfo.playerid}. Mining {resourceName}");
                return null;
            }

            // check if a different player/team/clan is trying to use excavator
            if (!(((ulong)player.userID == excavatorinfo.playerid) ||
                 (SameTeam((ulong)player.userID, excavatorinfo.playerid)) ||
                 (SameClan((ulong)player.userID, excavatorinfo.playerid))))
            {
                SendChatMessage(player, "ExcavatorInUse", excavatorinfo.displayName);
                return true;
            }

            PrintToLog($"Excavator {excavatorinfo.Name} started at : {DateTime.Now.ToString("hh:mm tt")} for {excavatorinfo.FuelTimeRemaining} minutes, by player {excavatorinfo.displayName}/{excavatorinfo.playerid}. Mining {resourceName}");

            return null;
        }

        object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            float multiplier = 1f;
            ExcavatorInfo excavatorinfo;
            if (!Excavators.TryGetValue(arm.net.ID.Value, out excavatorinfo)) return null;
            if (excavatorinfo.pileIndex == 0) excavatorinfo.pileIndex = excavatorinfo.Arm.outputPiles.Count - 1;
            else excavatorinfo.pileIndex--;

            if (excavatorinfo.playerid!=0 && IsMultiplierActive(excavatorinfo.playerid))
            {
                if (item.info.shortname == "sulfur.ore" && _config.SulfurMult != 0f) multiplier = _config.SulfurMult;
                else if (item.info.shortname == "hq.metal.ore" && _config.HQMMult != 0f) multiplier = _config.HQMMult;
                else if (item.info.shortname == "metal.fragments" && _config.MetalMult != 0f) multiplier = _config.MetalMult;
                else if (item.info.shortname == "stones" && _config.StoneMult != 0f) multiplier = _config.StoneMult;
            }

            float tmp = excavatorinfo.extraMineralProduced[excavatorinfo.pileIndex] + ((float)item.amount * (multiplier -1f));
            float tmp2 = Mathf.Floor(tmp);
            item.amount = Math.Max(0, item.amount + (int)tmp2);
            excavatorinfo.extraMineralProduced[excavatorinfo.pileIndex] = tmp - tmp2;

            // Evaluate every ~10 sec.
            if ((_config.ClearExcavatorLockOnAllTeamDisconnect || _config.ClearExcavatorLockOnPlayerOwnerDisconnect) && --excavatorinfo.CountTick == 0)
            {
                excavatorinfo.CountTick = 10;

                if (excavatorinfo.PlayerDisconnectTime != DateTime.MaxValue)
                {
                    if (excavatorinfo.PlayerDisconnectTime.AddMinutes(_config.CooldownExcavatorLockOnDisconnect) <= DateTime.Now)
                    {
                        // Clear quarry lock
                        if (_config.ClearExcavatorLockOnPlayerOwnerDisconnect)
                        {
                            PrintToLog($"Excavator unlocked because player owner disconnected for {_config.CooldownExcavatorLockOnDisconnect} minutes {excavatorinfo.displayName}/{excavatorinfo.playerid} ");
                        }
                        if (_config.ClearExcavatorLockOnAllTeamDisconnect)
                        {
                            PrintToLog($"Excavator unlocked because all team/clan disconnected for {_config.CooldownExcavatorLockOnDisconnect} minutes {excavatorinfo.displayName}/{excavatorinfo.playerid} ");
                        }

                        if (_config.MessageAll) BroadcastMessage("ExcavatorClearOffline", excavatorinfo.Name);
                        excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;
                        ClearExcavator(excavatorinfo, false);
                    }
                }
            }
            return null;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            foreach (KeyValuePair<ulong, ExcavatorInfo> excav in Excavators)
            {
                foreach (var kvp in excav.Value.PlayerCooldown)
                {
                    if (_config.ClearExcavatorLockOnPlayerOwnerDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key && (ulong)player.userID == excav.Value.playerid)
                        {
                            kvp.Value.IsOnline = true;
                            excav.Value.PlayerDisconnectTime = DateTime.MaxValue;
                            PrintToLog($"Player connected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");

                        }
                    }

                    if (_config.ClearExcavatorLockOnAllTeamDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key)
                        {
                            kvp.Value.IsOnline = true;
                            excav.Value.PlayerDisconnectTime = DateTime.MaxValue;
                            PrintToLog($"Player connected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");
                        }
                    }
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string strReason)
        {
            int PlayerCount;
            if (player == null) return;

            foreach (KeyValuePair<ulong, ExcavatorInfo> excav in Excavators)
            {
                if (_config.ClearExcavatorLockOnPlayerOwnerDisconnect) PlayerCount = 1;
                else PlayerCount = excav.Value.PlayerCooldown.Count;

                foreach (var kvp in excav.Value.PlayerCooldown)
                {
                    if (_config.ClearExcavatorLockOnPlayerOwnerDisconnect)
                    {
                        if ((ulong)player.userID == kvp.Key && (ulong)player.userID == excav.Value.playerid)
                        {
                            kvp.Value.IsOnline = false;
                            PlayerCount--;
                            PrintToLog($"Player disconnected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");
                        }
                    }

                    if (_config.ClearExcavatorLockOnAllTeamDisconnect)
                    {
                        if (kvp.Key == (ulong)player.userID)
                        {
                            kvp.Value.IsOnline = false;
                            PrintToLog($"Player disconnected {player.displayName}/{(ulong)player.userID} at {DateTime.Now}   isconnected:{BasePlayer.FindAwakeOrSleeping(player.UserIDString)?.IsConnected ?? false}");
                        }
                        if (!kvp.Value.IsOnline || kvp.Value.IgnoreOnline) PlayerCount--;
                    }
                }

                if (PlayerCount == 0)
                {
                    excav.Value.PlayerDisconnectTime = DateTime.Now;
                    PrintToLog($"Activate disconnect countdown {player.displayName}/{(ulong)player.userID} at {DateTime.Now}  {excav.Value.Name} by {excav.Value.displayName}/{excav.Value.playerid} ");
                }
            }
        }


        bool CheckPlayerCooldown(ulong playerID, ExcavatorInfo excavatorinfo)
        {
            List<ulong> removals = new List<ulong>();
            DateTime now = DateTime.Now;
            bool result = false;

            if (_config.CoolDownGlobal)
            {
                foreach (KeyValuePair<ulong, ExcavatorInfo> excav in Excavators)
                {
                    foreach (KeyValuePair<ulong, CooldownTime> kvp in excav.Value.PlayerCooldown)
                    {
                        if (now >= kvp.Value.Time) removals.Add(kvp.Key);
                        if (kvp.Key == playerID && now < kvp.Value.Time) result=true;
                    }

                    // cleanup dict entry of older time info
                    foreach (ulong removeid in removals)
                    {
                        excav.Value.PlayerCooldown.Remove(removeid);
                    }
                    removals.Clear();
                }
            }
            else
            {
                foreach (KeyValuePair<ulong, CooldownTime> kvp in excavatorinfo.PlayerCooldown)
                {
                    if (now >= kvp.Value.Time) removals.Add(kvp.Key);
                    if (kvp.Key == playerID && now < kvp.Value.Time) result=true;
                }

                // cleanup dict entry of older time info
                foreach (ulong removeid in removals)
                {
                    excavatorinfo.PlayerCooldown.Remove(removeid);
                }
            }

            return result;
        }

        int PlayerCooldownTime(ulong playerID, ExcavatorInfo excavatorinfo)
        {
            DateTime now = DateTime.Now;
            CooldownTime cooldown;

            if (_config.CoolDownGlobal)
            {
                foreach (KeyValuePair<ulong, ExcavatorInfo> excav in Excavators)
                {
                    if (excav.Value.PlayerCooldown.TryGetValue(playerID, out cooldown) && now < cooldown.Time)
                    {
                        var diff = cooldown.Time.Subtract(now);
                        return (int)Math.Ceiling(diff.TotalMinutes);
                    }
                }
            }
            else
            {
                if (excavatorinfo.PlayerCooldown.TryGetValue(playerID, out cooldown) && now < cooldown.Time)
                {
                    var diff = cooldown.Time.Subtract(now);
                    return (int)Math.Ceiling(diff.TotalMinutes);
                }
            }
            return 0;
        }

        void AddPlayerCooldown(ulong playerID, double extra, ExcavatorInfo excavatorinfo)
        {
            var teammanager = RelationshipManager.ServerInstance;
            foreach (KeyValuePair<ulong, CooldownTime> kvp in excavatorinfo.PlayerCooldown)
            {
                kvp.Value.IgnoreOnline = true;
            }

            //player.IsConnected
            CooldownTime CoolDown = new CooldownTime();
            CoolDown.IsOnline = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.IsConnected ?? false;
            CoolDown.Time =  DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
            AddSinglePlayerCooldown(playerID, excavatorinfo, CoolDown);

            if (CoolDown.IsOnline == false)
            {
                PrintWarning($"Player {playerID} just activated quarry, but is flagged Offline. Something is wrong ");
                PrintToLog($"Player {playerID} just activated quarry, but is flagged Offline. Something is wrong ");
            }

            // If enable, Process all team members
            if (_config.UseTeams && teammanager != null)
            {
                var team = teammanager.FindPlayersTeam(playerID);
                if (team != null)
                {
                    foreach (var ent in team.members)
                    {
                        CoolDown = new CooldownTime();
                        CoolDown.IsOnline = BasePlayer.FindAwakeOrSleeping(ent.ToString())?.IsConnected ?? false;
                        CoolDown.IgnoreOnline = false;
                        CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                        AddSinglePlayerCooldown(ent, excavatorinfo, CoolDown);
                    }
                }
            }

            // if enable, process the clan member
            if (_config.UseClans && IspluginLoaded(Clans))
            {
                BasePlayer friend;
                var member = Clans.Call("GetClanMembers", playerID.ToString());
                if (member!=null)
                {
                    List<string> memberlist = member as List<string>;

                    foreach (var ent in memberlist)
                    {
                        friend = BasePlayer.FindAwakeOrSleeping(ent);
                        if (friend != null)
                        {
                            CoolDown = new CooldownTime();
                            CoolDown.IsOnline = friend.IsConnected;
                            CoolDown.IgnoreOnline = false;
                            CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                            AddSinglePlayerCooldown(ulong.Parse(ent), excavatorinfo, CoolDown);
                        }
                    }
                }
            }

            // if enable, process the clan member from clantable
            if (_config.UseClanTable)
            {
                BasePlayer friend;
                long clanId = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.clanId ?? 0;
                if (clanId != 0)
                {
                    IClan clan = null;
                    if (ClanManager.ServerInstance.Backend?.TryGet(clanId, out clan) ?? false)
                    {
                        foreach (ClanMember member in clan.Members)
                        {
                            friend = BasePlayer.FindAwakeOrSleeping(member.SteamId.ToString());
                            if (friend != null)
                            {
                                CoolDown = new CooldownTime();
                                CoolDown.IsOnline = friend.IsConnected;
                                CoolDown.IgnoreOnline = false;
                                CoolDown.Time = DateTime.Now.AddMinutes(_config._PlayerCoolDown + extra);
                                AddSinglePlayerCooldown(member.SteamId, excavatorinfo, CoolDown);
                            }
                        }
                    }
                }
            }
        }

        void AddSinglePlayerCooldown(ulong playerID, ExcavatorInfo excavatorinfo, CooldownTime Cooldown)
        {
			// filter some bogus 0 entry comming from Team and Clan plugin
            if (playerID == 0) return;
            if (excavatorinfo.PlayerCooldown.ContainsKey(playerID))
            {
                excavatorinfo.PlayerCooldown[playerID] = Cooldown;
            }
            else
            {
                excavatorinfo.PlayerCooldown.Add(playerID, Cooldown);
            }
        }

        object OnExcavatorSuppliesRequest(ExcavatorSignalComputer computer, BasePlayer player)
        {		
            if (player == null || computer == null || !_config.enableComputeLock) return null;

            if (IsAdmin((ulong)player.userID) == true) return null;

            ulong armID;
            ExcavatorInfo excavatorinfo = null;
			if (!Associate.TryGetValue(computer.net.ID.Value, out armID)) return true;  //
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return null;  // 

            if (excavatorinfo.playerid != 0 && !IsExcavatorAvailable(excavatorinfo))
            {

                if ((ulong)player.userID == excavatorinfo.playerid) return null;
                if ((SameTeam((ulong)player.userID, excavatorinfo.playerid)) ||
                   (SameClan((ulong)player.userID, excavatorinfo.playerid))) return null;

                SendChatMessage(player, "ExcavatorInUse", excavatorinfo.displayName);

                return true;
            }

            return null;
        }

        void OnExcavatorSuppliesRequested(ExcavatorSignalComputer computer, BasePlayer player, CargoPlane plane)
        {
            if (player == null || computer == null || plane==null) return;

            ulong armID;
            ExcavatorInfo excavatorinfo = null;
            if (!Associate.TryGetValue(computer.net.ID.Value, out armID)) return;
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return;

            if (_config.enableComputeMesssage && excavatorinfo.playerid!=0) BroadcastMessage("ExcavatorSupplySignal", excavatorinfo.Name, excavatorinfo.displayName);
            // tag plane like loot defender 
            PrintToLog($"Supply signal activated at excavator {excavatorinfo.Name} by {player.displayName}/{(ulong)player.userID}");

            plane.OwnerID = (ulong)player.userID;
            plane.skinID = supplyDropSkinID;
        }

#endregion Hooks

#region Commands

        private void Excavator_info(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            foreach (var excator in Excavators)
            {
                var remaining = Math.Max(0, ((excator.Value.fueltime - DateTime.Now).TotalMinutes) + _config.CoolDown );
                if (!IsExcavatorAvailable(excator.Value))
                {
                    PrintToLog($" {excator.Value.Name} remaining time {remaining}");
                    SendChatMessage(player, "ExcavatorAvailableIn1", excator.Value.Name, Math.Ceiling(remaining), excator.Value.displayName);
                }
                else
                {
                    PrintToLog($" {excator.Value.Name} not running");
                    SendChatMessage(player, "ExcavatorStoped_", excator.Value.Name);
                }

                var checkcooldown = CheckPlayerCooldown((ulong)player.userID, excator.Value);
                if (checkcooldown)
                {
                    SendChatMessage(player, "ExcavatorPlCooldown", PlayerCooldownTime((ulong)player.userID, excator.Value));
                }
            }

            return;
        }

        private void Excavator_clearstatus(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (iplayer.Id == "server_console" ||
                (player != null && IsAdmin((ulong)player.userID)))
            {
                foreach (var excator in Excavators)
                {
                    ClearExcavator(excator.Value);
                }

                if (player != null)
                {
                    SendChatMessage(player, "ExcavatorClearStatus");
                    Puts(Lang("ExcavatorClearStatus"));
                }
                else
                {
                    Puts(Lang("ExcavatorClearStatus", "0"));
                }

                SaveData();

                PrintToLog($"Excavator clear status {iplayer.Id} ");
            }

            return;
        }

        private void Excavator_stopcommand(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            DieselEngine dieselEngine = null;
            List<DieselEngine> engines = Pool.Get<List<DieselEngine>>();
            Vis.Entities<DieselEngine>(player.transform.position, 120f, engines, -1);
            if (engines.Count > 0)
            {
                dieselEngine = engines[0];
                var distance = Vector3Ex.Distance2D(player.transform.position, dieselEngine.transform.position);
            }
            Pool.FreeUnmanaged(ref engines);

            ulong armID;
            ExcavatorInfo excavatorinfo = null;
            if (!Associate.TryGetValue(dieselEngine.net.ID.Value, out armID)) return;  // allow if engine not associated with excavator
            if (!Excavators.TryGetValue(armID, out excavatorinfo)) return;  // 

            if (dieselEngine.skinID != 0UL ||
                excavatorinfo == null)
            {
                SendChatMessage(player, "NoExcavatorFoundNear");
                return;
            }

            int fuelmoved = 0;
            if (((ulong)player.userID == excavatorinfo.playerid) ||
                (SameTeam((ulong)player.userID, excavatorinfo.playerid)) ||
                (SameClan((ulong)player.userID, excavatorinfo.playerid)))
            {
                List<Item> items = dieselEngine.inventory.FindItemsByItemID(1568388703);    // lowgradefuel == -946369541, Diesel == 1568388703
                foreach (Item item in items)
                {
                    if (!item.MoveToContainer(excavatorinfo.Arm.outputPiles[0].inventory, -1, true, false, null, true))
                    {
                        item.Drop(excavatorinfo.Arm.outputPiles[0].GetDropPosition(), excavatorinfo.Arm.outputPiles[0].GetDropVelocity(), default(Quaternion));
                    }
                    fuelmoved += item.amount;
                }
                SendChatMessage(player, "MoveFuelToOutput");
                PrintToLog($"Excavator stop command by {player.displayName}/{(ulong)player.userID}  at {excavatorinfo.Name}. moving {fuelmoved} fuel ");
            }
            else SendChatMessage(player, "NoExcavatorFoundNear");

            return;
        }


        #endregion Commands

        #region Helpers


        void ClearExcavator(ExcavatorInfo excavator, bool clearcooldownlist = true)
        {
            excavator.playerid = 0;
            excavator.displayName = string.Empty;
            excavator.FuelTimeRemaining = 0f;
            excavator.state = false;
            excavator.PlayerDisconnectTime = DateTime.MaxValue;
            excavator.fueltime = DateTime.MinValue;
            excavator.stoptime = DateTime.MinValue;
            if (clearcooldownlist) excavator.PlayerCooldown = new Dictionary<ulong, CooldownTime>();
        }

        bool IsExcavatorAvailable(ExcavatorInfo excavatorinfo)
        {
            // check if excavator is off longer then cooldown
            if ((excavatorinfo.state == false) && ((DateTime.Now - excavatorinfo.stoptime).TotalMinutes > _config.CoolDown))
            {
                // enough time elapse, allow loot
                excavatorinfo.playerid = 0;
                excavatorinfo.displayName = "nobody";
                excavatorinfo.PlayerDisconnectTime = DateTime.MaxValue;
                return true;
            }
            return false;
        }

        private static void DropItemContainer(ItemContainer itemContainer, Vector3 dropPosition, Quaternion rotation) => itemContainer?.Drop(PREFAB_ITEM_DROP, dropPosition, rotation, 0);

        string ReportInventory(StorageContainer storage)
        {
            StringBuilder Report = new StringBuilder(" [");
            int itemcount;
            int count = 0;
            foreach (var itemstr in _config.ReportItems)
            {
                Item item = storage.inventory.FindItemByItemName(itemstr);
                if (item == null) continue;
                itemcount = storage.inventory.GetTotalItemAmount(item, 0, storage.inventory.capacity - 1);
                if (count != 0) Report.Append(", ");
                Report.Append(string.Format("{1} {0}", item.info.displayName.english, itemcount.ToString()));
                count++;
            }
            if (count == 0) Report.Append("Empty");
            Report.Append("]");
            return Report.ToString();
        }

        private void PrintToLog(string message)
        {
            if (_config.Debug)
                UnityEngine.Debug.Log($"[{_instance.Name}] [{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}");

            if (_config.LogToFile)
                LogToFile(TraceFile, $"[{DateTime.Now.ToString("h:mm tt")}]{Platform} {message}", this);

            if (_config.Discordena)
                PrintToDiscord(message);
        }

        private bool IsAdmin(ulong id) =>
            (permission.UserHasPermission(id.ToString(), PermissionAdmin));
        private bool IsAdmin(string id) =>
            (permission.UserHasPermission(id, PermissionAdmin));


        private bool CanPlayerUse(ulong id) =>
            (!_config.UsePermission || permission.UserHasPermission(id.ToString(), _config.Permission) || permission.UserHasPermission(id.ToString(), PermissionAdmin));
        private bool CanPlayerUse(string id) =>
            (!_config.UsePermission || permission.UserHasPermission(id, _config.Permission) || permission.UserHasPermission(id, PermissionAdmin));

        private bool IsMultiplierActive(ulong id) =>
            (!_config.MultiplierPermission || permission.UserHasPermission(id.ToString(), _config.PermissionMult));
        private bool IsMultiplierActive(string id) =>
            (!_config.MultiplierPermission || permission.UserHasPermission(id, _config.PermissionMult));

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (_config.UseClans == true && IspluginLoaded(Clans))
            {
                //Clans
                var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
                if (isMember != null && (bool)isMember) return true;
            }

            if (_config.UseClanTable == true)
            {
                long playerclan = BasePlayer.FindAwakeOrSleeping(playerID.ToString())?.clanId ?? 0;
                IClan clan = null;
                if (playerclan != 0 && (ClanManager.ServerInstance.Backend?.TryGet(playerclan, out clan) ?? false))
                {
                    foreach (ClanMember member in clan.Members)
                    {
                        if (member.SteamId == friendID) return true;
                    }
                }
            }

            return false;
        }

        // Check if in same team
        private bool SameTeam(ulong playerID, ulong friendID)
        {
            if (playerID==0 || friendID==0 || _config.UseTeams == false) return false;

            var teammanager = RelationshipManager.ServerInstance;
            if (teammanager == null) return false;

            var team = teammanager.FindPlayersTeam(playerID);
            if (team == null) return false;

            if (team.members.Contains(friendID)) return true;
            return false;
        }

        private void BroadcastMessage(string msg, params object[] args)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                SendChatMessage(player, msg, args);
            }
        }

        public void SendChatMessage(BasePlayer player, string msg, params object[] args)
        {
            if (_config.useNotify && IspluginLoaded(Notify))
            {
                Notify.Call("SendNotify", player, 0, Lang(msg, player.UserIDString, args));
            }
            else
            {
                player.ChatMessage(Lang(msg, player.UserIDString, args));
            }
        }

        private void PrintToDiscord(string message, double seconds = 0)
        {
            if (_discord == null) return;
            if (_discord.MsgCooldown <= DateTime.Now.ToBinary())
            {
                _discord.MsgCooldown = DateTime.Now.AddSeconds(seconds).ToBinary();
				
				DateTime currentTime = DateTime.UtcNow;
				long unixTime = ((DateTimeOffset)currentTime).ToUnixTimeSeconds();
				if (_config.UseDiscordTimestamp)
					_discord.SendTextMessage($"[<t:{unixTime}:t>]{Platform} " + message);
				else
			        _discord.SendTextMessage($"[{DateTime.Now.ToString("h:mm tt")}]{Platform} " + message);
            }
        }

        private string PositionToString(Vector3 position) => MapHelper.PositionToString(position);
        // correction for grid offset vs FP code


        bool IspluginLoaded(Plugin a) => (a?.IsLoaded ?? false);

#endregion helpers

        //######################################################

#region Shared.Components

        private class DiscordComponent : MonoBehaviour
        {
            private const float PostDelay = 2.0f; // set 2 sec min delay between two discord post
            public long MsgCooldown = DateTime.Now.ToBinary();

            private readonly Queue<object> _queue = new Queue<object>();
            private string _url;
            private bool _busy = false;

            public DiscordComponent Configure(string url)
            {
                if (url == null) throw new ArgumentNullException(nameof(url));
                _url = url;

                return this;
            }

            public DiscordComponent SendTextMessage(string message, params object[] args)
            {                
                message = args.Length > 0 ? string.Format(message, args) : message;
                return AddQueue(new MessageRequest(message));
            }

#region Send requests to server

            private DiscordComponent AddQueue(object request)
            {
                _queue.Enqueue(request);

                if (!_busy)
                    StartCoroutine(ProcessQueue());

                return this;
            }

            private IEnumerator ProcessQueue()
            {
                if (_busy) yield break;
                _busy = true;

                while (_queue.Count!=0)
                {
                    var request = _queue.Dequeue();
                    yield return ProcessRequest(request);
                }

                _busy = false;
            }
            
            private IEnumerator ProcessRequest(object request)
            {
                if (string.IsNullOrEmpty(_url))
                {
                    print("[ERROR] Discord webhook URL wasn't specified");
                    yield break;
                }

                byte[]  data = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(request));
                UploadHandlerRaw uh = new UploadHandlerRaw(data) { contentType = "application/json" };
                UnityWebRequest www = UnityWebRequest.PostWwwForm(_url, UnityWebRequest.kHttpVerbPOST);
                www.uploadHandler = uh;

                yield return www.SendWebRequest();

                if  (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
                    print($"ERROR: {www.error} | {www.downloadHandler?.text}");

                www.Dispose();

                // to avoid spam requests to Discord
                yield return new WaitForSeconds(PostDelay);
            }            

#endregion

#region Requests

            private class MessageRequest
            {
                [JsonProperty("content")]
                public string Content { get; set; }

                public MessageRequest(string content)
                {
                    if (content == null) throw new ArgumentNullException(nameof(content));
                    Content = content;
                }
            }

#endregion
        }

#endregion
    }
}


// --- End of file: ExcavatorLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/event-randomizer ---
// --- Original File Path: E/EventRandomizer/EventRandomizer.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Event Randomizer", "mvrb", "0.3.4")]
    [Description("Set random timers for server events")]
    class EventRandomizer : RustPlugin
    {
        private float heliInterval;
        private float chinookInterval;
        private float cargoInterval;
        private float airdropInterval;

        private int lastHeli;
        private int lastChinook;
        private int lastCargo;
        private int lastAirdrop;

        private string permSpawnChinook = "eventrandomizer.spawn.ch47";
        private string permSpawnHeli = "eventrandomizer.spawn.heli";
        private string permSpawnCargo = "eventrandomizer.spawn.cargo";
        private string permSpawnAirdrop = "eventrandomizer.spawn.airdrop";
		
        private string permCheckTimer = "eventrandomizer.check";
		
		private bool initialized = false;

        private class EventTimer
        {
            public float Min;
            public float Max;
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NextHeliIn"] = "Next Patrol Helicopter spawns in {0}",
                ["NextChinookIn"] = "Next Chinook Helicopter spawns in {0}",
                ["NextCargoIn"] = "Next Cargo Ship spawns in {0}",
                ["NextAirdropIn"] = "Next Airdrop spawns in {0}",

                ["CargoSpawned"] = "A Cargo Ship has been spawned.",
                ["PatrolHelicopterSpawned"] = "A Patrol Helicopter has been spawned.",
                ["ChinookSpawned"] = "A Chinook Helicopter has been spawned.",
                ["AirdropSpawned"] = "An Airdrop has been spawned.",

                ["FormatTime"] = "{0} Hours {1} Minutes",

                ["EventNotEnabled"] = "The Min and Max timer for {0} is less than or equal to 0 so this event has been disabled.",

                ["Warning: MinGreaterThanMax"] = "The minimum value ({0}) for {1} is greater than the maximum value ({2})!",

                ["Error: NoPermission"] = "You do not have permission to use this command.",
            }, this);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permSpawnChinook, this);
            permission.RegisterPermission(permSpawnHeli, this);
            permission.RegisterPermission(permSpawnCargo, this);
            permission.RegisterPermission(permSpawnAirdrop, this);
            permission.RegisterPermission(permCheckTimer, this);

            LoadVariables();

            foreach (var entry in configData.EventTimers)
            {
                if (entry.Value.Min > entry.Value.Max)
                {
                    PrintWarning(Lang("Warning: MinGreaterThanMax", null, entry.Value.Min, entry.Key, entry.Value.Max));
                }
            }

            if (configData.EventTimers["Helicopter"].Min > 0 && configData.EventTimers["Helicopter"].Max > 0)
            {
                heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
                timer.Once(heliInterval, SpawnHeliRandom);
                PrintWarning(Lang("NextHeliIn", null, FormatTime(heliInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Helicopter"));
            }

            if (configData.EventTimers["Chinook"].Min > 0 && configData.EventTimers["Chinook"].Max > 0)
            {
                chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
                timer.Once(chinookInterval, SpawnChinookRandom);
                PrintWarning(Lang("NextChinookIn", null, FormatTime(chinookInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Chinook"));
            }

            if (configData.EventTimers["Cargo"].Min > 0 && configData.EventTimers["Cargo"].Max > 0)
            {
                cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
                timer.Once(cargoInterval, SpawnCargoRandom);
                PrintWarning(Lang("NextCargoIn", null, FormatTime(cargoInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Cargo"));
            }

            if (configData.EventTimers["Airdrop"].Min > 0 && configData.EventTimers["Airdrop"].Max > 0)
            {
                airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
                timer.Once(airdropInterval, SpawnAirdropRandom);
                PrintWarning(Lang("NextAirdropIn", null, FormatTime(airdropInterval)));
            }
            else
            {
                PrintWarning(Lang("EventNotEnabled", null, "Airdrop"));
            }

            var currentTime = GetUnix();

            lastHeli = currentTime;
            lastChinook = currentTime;
            lastCargo = currentTime;
            lastAirdrop = currentTime;
			
			initialized = true;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
			if (!initialized) return;			
            
            /*if (configData.blockServerAirdrops && entity is CargoPlane)
            {
                entity.KillMessage();
            }
            else*/ if (configData.blockServerCargoShips && entity is CargoShip)
            {
                entity.KillMessage();
            }
            else if (configData.blockServerChinooks && (entity is CH47Helicopter || entity is CH47HelicopterAIController))
            {
                //entity.KillMessage();
            }
            else if (configData.blockServerPatrolHelicopters && entity is PatrolHelicopterAI)
            {
                entity.KillMessage();
            }
        }

        [ChatCommand("heli")]
        private void CmdHeli(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextHeliIn", player.UserIDString, FormatTime(heliInterval + lastHeli - GetUnix())));
        }

        [ChatCommand("chinook")]
        private void CmdChinook(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextChinookIn", player.UserIDString, FormatTime(chinookInterval + lastChinook - GetUnix())));
        }

        [ChatCommand("cargo")]
        private void CmdCargo(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permCheckTimer))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            player.ChatMessage(Lang("NextCargoIn", player.UserIDString, FormatTime(cargoInterval + lastCargo - GetUnix())));
        }

        [ConsoleCommand("ch47.spawn")]
        private void ConsoleCmdSpawnCh47(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnChinook))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnChinook();
        }

        [ConsoleCommand("heli.spawn")]
        private void ConsoleCmdSpawnHeli(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnHeli))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnHeli();
        }

        [ConsoleCommand("cargo.spawn")]
        private void ConsoleCmdSpawnCargo(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnCargo))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnCargo();
        }

        [ConsoleCommand("airdrop.spawn")]
        private void ConsoleCmdSpawnAirdrop(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();

            if (arg?.Connection != null && player && !permission.UserHasPermission(player.UserIDString, permSpawnAirdrop))
            {
                player.ChatMessage(Lang("Error: NoPermission", player.UserIDString));
                return;
            }

            SpawnAirdrop();
        }

        private void SpawnCargoRandom()
        {
            SpawnCargo();
            lastCargo = GetUnix();

            cargoInterval = UnityEngine.Random.Range(configData.EventTimers["Cargo"].Min, configData.EventTimers["Cargo"].Max);
            timer.Once(cargoInterval, SpawnCargoRandom);
        }

        private void SpawnHeliRandom()
        {
            SpawnHeli();
            lastHeli = GetUnix();

            heliInterval = UnityEngine.Random.Range(configData.EventTimers["Helicopter"].Min, configData.EventTimers["Helicopter"].Max);
            timer.Once(heliInterval, SpawnHeliRandom);
        }

        private void SpawnChinookRandom()
        {
            SpawnChinook();
            lastChinook = GetUnix();

            chinookInterval = UnityEngine.Random.Range(configData.EventTimers["Chinook"].Min, configData.EventTimers["Chinook"].Max);
            timer.Once(chinookInterval, SpawnChinookRandom);
        }

        private void SpawnAirdropRandom()
        {
            SpawnAirdrop();
            lastAirdrop = GetUnix();

            airdropInterval = UnityEngine.Random.Range(configData.EventTimers["Airdrop"].Min, configData.EventTimers["Airdrop"].Max);
            timer.Once(airdropInterval, SpawnAirdropRandom);
        }

        private string FormatTime(float seconds)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);

            return Lang("FormatTime", null, time.Hours, time.Minutes);
        }

        private void SpawnAirdrop()
        {
            var entity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3());
            entity?.Spawn();

            PrintWarning(Lang("AirdropSpawned"));
        }

        private void SpawnCargo()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var cargoShip = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab") as CargoShip;
            if (cargoShip == null) return;
            cargoShip.TriggeredEventSpawn();
            cargoShip.Spawn();

            PrintWarning(Lang("CargoSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnHeli()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var heli = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
            if (heli == null) return;
            heli.Spawn();

            PrintWarning(Lang("PatrolHelicopterSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private void SpawnChinook()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            var ch47 = (CH47HelicopterAIController)GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47scientists.entity.prefab", new Vector3(0, 200, 0));
            if (ch47 == null) return;
            ch47.Spawn();

            PrintWarning(Lang("ChinookSpawned"));
            Subscribe(nameof(OnEntitySpawned));
        }

        private int GetUnix() => (int)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Timers in seconds")]
            public Dictionary<string, EventTimer> EventTimers { get; set; }

            [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
            public bool blockServerAirdrops;

            [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
            public bool blockServerCargoShips;

            [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
            public bool blockServerChinooks;

            [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
            public bool blockServerPatrolHelicopters;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                EventTimers = new Dictionary<string, EventTimer>()
                {
                    { "Helicopter", new EventTimer(){ Min = 3600, Max = 7200 } },
                    { "Chinook", new EventTimer(){ Min = 7200, Max = 14400 } },
                    { "Cargo", new EventTimer(){ Min = 7200, Max = 10800 } },
                    { "Airdrop", new EventTimer(){ Min = 3600, Max = 3600 } }
                },
                blockServerPatrolHelicopters = true,
                blockServerChinooks =  true,
                blockServerAirdrops = true,
                blockServerCargoShips = true
            };

            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: EventRandomizer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/extended-recycler ---
// --- Original File Path: E/ExtendedRecycler/ExtendedRecycler.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("Extended Recycler", "beee/The Friendly Chap", "1.2.6")]
    [Description("Extend recyclers for personal use with per player limits")]

/* Version History : 
    1.2.4 : Added logic to create a VIP starting balance system.
	1.2.5 : Added Logo and MIT Licence
	1.2.6 : Removed Logo.
*/
/*	MIT License

	©2024 The Friendly Chap

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/
    public class ExtendedRecycler : RustPlugin
    {
        #region Vars

        private const ulong skinID = 1594245394;
        private const string prefab = "assets/bundled/prefabs/static/recycler_static.prefab";
        private static ExtendedRecycler plugin;
        private const string permUse = "extendedrecycler.use";
        private const string permUnlimited = "extendedrecycler.unlimited";
        private const string permVIP = "extendedrecycler.vip";

        RecyclersData recData;
        private DynamicConfigFile data;

        ProtectionProperties recyclerProtection;
        ProtectionProperties originalRecyclerProtection;

        #endregion

        #region Config

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "1. Pickup settings:")]
            public OPickup pickup;

            [JsonProperty(PropertyName = "2. Craft settings:")]
            public OCraft craft;

            [JsonProperty(PropertyName = "3. Destroy settings:")]
            public ODestroy destroy;

            [JsonProperty(PropertyName = "4. Damage settings:")]
            public ODamage damage;

            public class OPickup
            {
                [JsonProperty(PropertyName = "1. Enabled for personal recyclers (placed by player)")]
                public bool personal;

                [JsonProperty(PropertyName = "2. Check ability to build for pickup")]
                public bool privilege;

                [JsonProperty(PropertyName = "3. Only owner can pickup")]
                public bool onlyOwner;
            }

            public class OCraft
            {
                [JsonProperty(PropertyName = "1. Enabled")]
                public bool enabled;

                [JsonProperty(PropertyName = "2. Cost (shortname - amount):")]
                public Dictionary<string, int> cost;

                
                [JsonProperty(PropertyName = "3. Default Balance per Player:")]
                public int defaultBalance = 2;

                [JsonProperty(PropertyName = "3. VIP Balance per Player:")]
                public int VIPBalance = 10;
            }

            public class ODestroy
            {
                [JsonProperty(PropertyName = "1. Check ground for recyclers (destroy on missing)")]
                public bool checkGround;

                [JsonProperty(PropertyName = "2. Give item on destroy recycler")]
                public bool destroyItem;

                [JsonProperty(PropertyName = "3. Effects on destroy recycler")]
                public List<string> effects;
            }

            public class ODamage
            {
                [JsonProperty(PropertyName = "1. Allow damage to recycler")]
                public bool allowDamage;

                [JsonProperty(PropertyName = "2. Reduce damage to recycler by %")]
                public float reduceDamagePercent;
            }
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                pickup = new ConfigData.OPickup
                {
                    personal = false,
                    privilege = true,
                    onlyOwner = false
                },
                craft = new ConfigData.OCraft
                {
                    enabled = true,
                    cost = new Dictionary<string, int>
                    {
                        {"scrap", 500},
                        {"metal.fragments", 5000},
                        {"metal.refined", 50},
                        {"gears", 10}
                    },
                    defaultBalance = 2,
                    VIPBalance = 10
                },
                destroy = new ConfigData.ODestroy
                {
                    checkGround = true,
                    destroyItem = true,
                    effects = new List<string>
                    {
                        "assets/bundled/prefabs/fx/item_break.prefab",
                        "assets/bundled/prefabs/fx/impacts/stab/rock/stab_rock_01.prefab"
                    }
                },
                damage = new ConfigData.ODamage
                {
                    allowDamage = true,
                    reduceDamagePercent = 50f
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            if(config.damage == null)
            {
                config.damage = new ConfigData.ODamage()
                {
                    allowDamage = true,
                    reduceDamagePercent = 50f
                };
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language

        private Dictionary<string, string> EN = new Dictionary<string, string>
        {
            {"Name", "Recycler"},
            {"Pickup", "You picked up recycler!"},
            {"Receive", "You received recycler!"},
            {"Disabled", "Pickup disabled!"},
            {"Build", "You must have ability to build to do that!"},
            {"Damaged", "Recycler was recently damaged, you can pick it up in next 30s!"},
            {"NoCraft", "Craft disabled!"},
            {"Owner", "Only owner can pickup recycler!"},
            {"Craft", "For craft you need more resources:\n{0}"},
            {"Permission", "You need permission to do that!"},
            {"Claimed", "You claimed a recycler! your current balance is {0}."},
            {"LimitExceeded", "You reached your crafting limit!"},
            {"Balance", "Your current balance is {0}."}
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            if (player == null)
            {
                return;
            }
            
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }

        #endregion

        #region Oxide Hooks

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            CheckDeploy(go.ToBaseEntity());
        }

        private void OnServerInitialized()
        {
            plugin = this;
            lang.RegisterMessages(EN, this);
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permUnlimited, this);
            permission.RegisterPermission(permVIP, this);
            CheckRecyclers();            
            LoadData();
			// ShowLogo();
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            CheckHit(player, info?.HitEntity);
        }

        private void Unload()
        {
            if(config.damage.allowDamage)
            {
                // In case unloaded before OnServerInitialized was called
                if (originalRecyclerProtection == null)
                    return;

                foreach (var recycler in UnityEngine.Object.FindObjectsOfType<Recycler>())
                {
                    recycler.baseProtection = originalRecyclerProtection;
                }

                UnityEngine.Object.Destroy(recyclerProtection);
            }
            SaveData();
        }

        private void OnServerSave() => SaveData();

        #endregion

        #region Core

        private BaseEntity SpawnRecycler(Vector3 position, Quaternion rotation = default(Quaternion), ulong ownerID = 0)
        {
            var recycler = GameManager.server.CreateEntity(prefab, position, rotation);
            if (recycler == null)
            {
                return null;
            }

            recycler.skinID = skinID;
            recycler.OwnerID = ownerID;
            recycler.gameObject.AddComponent<ExtendedRecyclerComponent>();
            recycler.Spawn();

            return recycler;
        }

        private void CheckRecyclers()
        {
            if(config.damage.allowDamage)
            {
                recyclerProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
                recyclerProtection.name = "ExtendedRecyclerProtection";
                recyclerProtection.Add(config.damage.reduceDamagePercent/100f); // Reduce damage from all types
            }

            foreach (var recycler in UnityEngine.Object.FindObjectsOfType<Recycler>())
            {
                if (IsRecycler(recycler.skinID) && recycler.GetComponent<ExtendedRecyclerComponent>() == null)
                {
                    if (config.damage.allowDamage && originalRecyclerProtection == null)
                        originalRecyclerProtection = recycler.baseProtection;

                    recycler.gameObject.AddComponent<ExtendedRecyclerComponent>();
                }
            }
        }

        private void GiveRecycler(BasePlayer player, bool pickup = false, bool free = false)
        {
            var item = CreateItem();
            if (item != null && player != null)
            {
                player.GiveItem(item);
                
                if(pickup)
                {
                    message(player, "Pickup");
                }
                else
                {
                    if(permission.UserHasPermission(player.UserIDString, permUnlimited) || free)
                    {
                        message(player, "Receive");
                    }
                    else
                    {
                        int remainingBalance = SpendFromBalance(player);
                        message(player, "Claimed", remainingBalance);
                    }
                }
            }
        }

        private void GiveRecycler(Vector3 position)
        {
            var item = CreateItem();
            item?.Drop(position, Vector3.down);
        }

        private Item CreateItem()
        {
            var item = ItemManager.CreateByName("box.repair.bench", 1, skinID);
            if (item != null)
            {
                item.name = plugin?.GetRecyclerName();
            }
           
            return item;
        }

        private void CheckDeploy(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsRecycler(entity.skinID))
            {
                return;
            }

            var transform = entity.transform;
            BaseEntity recycler = SpawnRecycler(transform.position, transform.rotation, entity.OwnerID);
            entity.transform.position -= new Vector3(0, 3, 0);
            entity.SendNetworkUpdate();
            NextFrame(() =>
            {
                if (entity.IsValid() == true && entity.IsDestroyed == false)
                {
                    if(recycler.IsValid() && entity.HasParent() && entity.GetParentEntity() is Tugboat)
                    {
                        recycler.SetParent(entity.GetParentEntity(), true, true);
                    }
                    
                    entity.Kill();
                }
            });
        }

        private void CheckHit(BasePlayer player, BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }

            if (!IsRecycler(entity.skinID))
            {
                return;
            }

            NextFrame(() =>
            {
                if (entity.IsValid() == true)
                {
                    entity.GetComponent<ExtendedRecyclerComponent>()?.TryPickup(player);
                }
            });
        }

        [ChatCommand("recycler.craft")]
        private void Craft(BasePlayer player)
        {
            if (CanCraft(player))
            {
                GiveRecycler(player);
            }
        }
        
        [ChatCommand("recycler.balance")]
        private void Balance(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                message(player, "Permission");
                return;
            }

            string balance = GetBalance(player).ToString();

            if (permission.UserHasPermission(player.UserIDString, permUnlimited))
            {
                balance = "Unlimited";
            }

            message(player, "Balance", balance);
        }

        private bool CanCraft(BasePlayer player)
        {
            if (!config.craft.enabled)
            {
                message(player, "NoCraft");
                return false;
            }

            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                message(player, "Permission");
                return false;
            }

            CheckEntry(player);

            if(!permission.UserHasPermission(player.UserIDString, permUnlimited) 
            && recData.Players[player.userID].Balance <= 0)
            {
                message(player, "LimitExceeded");
                return false;
            }

            var recipe = config.craft.cost;
            var more = new Dictionary<string, int>();

            foreach (var component in recipe)
            {
                var name = component.Key;
                var has = player.inventory.GetAmount(ItemManager.FindItemDefinition(component.Key).itemid);
                var need = component.Value;
                if (has < component.Value)
                {
                    if (!more.ContainsKey(name))
                    {
                        more.Add(name, 0);
                    }

                    more[name] += need;
                }
            }

            if (more.Count == 0)
            {
                foreach (var item in recipe)
                {
                    player.inventory.Take(null, ItemManager.FindItemDefinition(item.Key).itemid, item.Value);
                }

                return true;
            }
            else
            {
                var text = "";

                foreach (var item in more)
                {
                    text += $" * {item.Key} x{item.Value}\n";
                }

                player.ChatMessage(string.Format(lang.GetMessage("Craft", this), text));
                return false;
            }
        }

        #endregion

        #region Helpers

        private string GetRecyclerName()
        {
            return lang.GetMessage("Name", this);
        }

        private bool IsRecycler(ulong skin)
        {
            return skin != 0 && skin == skinID;
        }

        private void CheckEntry(BasePlayer player)
        {
            if (!recData.Players.ContainsKey(player.userID))
            {
                recData.Players.Add(player.userID, new PlayerData
                {
                    DisplayName = player.displayName,
                    Balance = config.craft.defaultBalance
                });
                if (permission.UserHasPermission(player.UserIDString, permVIP)) 
                {
                    recData.Players[player.userID].Balance = config.craft.VIPBalance;
                }
            }
        }

        private void CheckEntry(ulong playerId)
        {
            if (!recData.Players.ContainsKey(playerId))
            {
                recData.Players.Add(playerId, new PlayerData
                {
                    DisplayName = covalence.Players.FindPlayerById(playerId.ToString())?.Name ?? "NoName",
                    Balance = config.craft.defaultBalance
                });
                if (permission.UserHasPermission(playerId.ToString(), permVIP))
                {
                    recData.Players[playerId].Balance = config.craft.VIPBalance;
                }
            }
        }

        public int SpendFromBalance(BasePlayer player){
            CheckEntry(player);
            if(permission.UserHasPermission(player.UserIDString, permUnlimited)){ return 999; }

            recData.Players[player.userID].Balance -= 1;
            if(recData.Players[player.userID].Balance < 0){
                recData.Players[player.userID].Balance = 0;
            }

            return recData.Players[player.userID].Balance;
        }

        private void SetBalance(BasePlayer player, int newBalance)
        {
            CheckEntry(player);
            
            recData.Players[player.userID].Balance = newBalance;
        }

        private int AddBalance(BasePlayer player, int deposit)
        {
            CheckEntry(player);
            
            recData.Players[player.userID].Balance += deposit;

            return recData.Players[player.userID].Balance;
        }

        private int GetBalance(BasePlayer player)
        {
            CheckEntry(player);
            
            return recData.Players[player.userID].Balance;
        }
		
		private void ShowLogo()
        {
			Puts(" _______ __               _______        __                 __ __             ______ __           ©2024");
			Puts("|_     _|  |--.-----.    |    ___|.----.|__|.-----.-----.--|  |  |.--.--.    |      |  |--.---.-.-----.");
			Puts("  |   | |     |  -__|    |    ___||   _||  ||  -__|     |  _  |  ||  |  |    |   ---|     |  _  |  _  |");
			Puts("  |___| |__|__|_____|    |___|    |__|  |__||_____|__|__|_____|__||___  |    |______|__|__|___._|   __|");
			Puts("                         Extended Recycler v1.2.5                 |_____| thefriendlychap.co.za |__|");      
        }
        #endregion

        #region Command

        [ConsoleCommand("recycler.give")]
        private void Cmd(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin && arg.Args?.Length > 0)
            {
                var player = BasePlayer.Find(arg.Args[0]) ?? BasePlayer.FindSleeping(arg.Args[0]);
                if (player == null)
                {
                    PrintWarning($"We can't find player with that name/ID! {arg.Args[0]}");
                    return;
                }

                GiveRecycler(player, false, true);
            }
        }

        [ConsoleCommand("recycler.setbalance")]
        private void SetBalanceCMD(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin && arg.Args?.Length > 1)
            {
                var player = BasePlayer.Find(arg.Args[0]) ?? BasePlayer.FindSleeping(arg.Args[0]);
                if (player == null)
                {
                    PrintWarning($"We can't find player with that name/ID! {arg.Args[0]}");
                    return;
                }

                int newBalance = 0;

                if (!int.TryParse(arg.Args[1], out newBalance))
                {
                    PrintWarning($"{arg.Args[1]} is not a valid number!");
                    return;
                }

                SetBalance(player, newBalance);
                Puts($"{arg.Args[0]} current balance is " + newBalance + ".");
                //player.ChatMessage($"Your current recycler craft balance is " + newBalance + ".");
            }
        }

        [ConsoleCommand("rec_wipe")]
        private void ccmdPCWipe(ConsoleSystem.Arg arg)
        {if (arg.IsAdmin)
            {
                recData = new RecyclersData();
                Puts("Extended Recycler wiped successfully.");
                SaveData();
            }
        }

        #endregion

        #region Data
        private void SaveData()
        {
            if(recData == null) return;
            
            data.WriteObject(recData);
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("ExtendedRecycler");
            try
            {
                recData = data.ReadObject<RecyclersData>();
                if(recData == null) recData = new RecyclersData();
            }
            catch
            {
                recData = new RecyclersData();
            }
        }

        private class RecyclersData
        {
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            public string DisplayName = string.Empty;
            public int Balance = config.craft.defaultBalance;
        }

        #endregion

        #region Scripts

        private class ExtendedRecyclerComponent : MonoBehaviour
        {
            private Recycler recycler;

            private void Awake()
            {
                recycler = GetComponent<Recycler>();
                
                if(config.damage.allowDamage)
                {
                    recycler.baseProtection = plugin.recyclerProtection;
                }

                if (config.destroy.checkGround)
                {
                    InvokeRepeating("CheckGround", 5f, 5f);
                }
            }

            private void CheckGround()
            {
                if(recycler.HasParent() && recycler.GetParentEntity() is Tugboat) 
                {
                    CancelInvoke("CheckGround");
                    return;
                }
                
                RaycastHit rhit;
                var cast = Physics.Raycast(recycler.transform.position + new Vector3(0, 0.1f, 0), Vector3.down,
                    out rhit, 4f, LayerMask.GetMask("Terrain", "Construction"));
                var distance = cast ? rhit.distance : 3f;

                if (distance > 0.2f)
                {
                    GroundMissing();
                }
            }

            private void GroundMissing()
            {
                recycler.Kill();

                if (config.destroy.destroyItem)
                {
                    plugin.GiveRecycler(recycler.transform.position);
                }

                foreach (var effect in config.destroy.effects)
                {
                    Effect.server.Run(effect, recycler.transform.position);
                }
            }

            public void TryPickup(BasePlayer player)
            {
                if (config.pickup.personal == false)
                {
                    plugin.message(player, "Disabled");
                    return;
                }

                if (config.pickup.privilege && !player.CanBuild())
                {
                    plugin.message(player, "Build");
                    return;
                }

                if (config.pickup.onlyOwner && recycler.OwnerID != player.userID)
                {
                    plugin.message(player, "Owner");
                    return;
                }

                if (recycler.SecondsSinceDealtDamage < 30f)
                {
                    plugin.message(player, "Damaged");
                    return;
                }
                
                recycler.DropItems();
                recycler.Kill();
                plugin.GiveRecycler(player, true);
            }

            public void DoDestroy()
            {
                Destroy(this);
            }
        }

        #endregion
    }
}

// --- End of file: ExtendedRecycler.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/entity-cleanup ---
// --- Original File Path: E/EntityCleanup/EntityCleanup.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using Facepunch;

using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Cleanup", "2CHEVSKII", "4.0.0")]
    [Description("Easy way to cleanup your server from unnecessary entities.")]
    public class EntityCleanup : CovalencePlugin
    {
        const string PERMISSION_USE = "entitycleanup.use";

        const string M_PREFIX           = "Chat prefix",
                     M_NO_PERMISSION    = "No permission",
                     M_INVALID_USAGE    = "Invalid usage",
                     M_CLEANUP_STARTED  = "Cleanup started",
                     M_CLEANUP_FINISHED = "Cleanup finished",
                     M_CLEANUP_RUNNING  = "Cleanup running";

        PluginSettings settings;
        CleanupHandler handler;

        #region Command handler

        void CommandHandler(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PERMISSION_USE))
            {
                Message(player, M_NO_PERMISSION);
                return;
            }

            switch (args.Length)
            {
                case 0:
                    if (!handler.TryStartCleanup())
                    {
                        Message(player, M_CLEANUP_RUNNING);
                    }

                    return;
                default:
                    Message(player, M_INVALID_USAGE);
                    break;
            }
        }

        #endregion
        
        #region Oxide hooks

        void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            AddCovalenceCommand("entitycleanup", "CommandHandler");
        }

        void OnServerInitialized()
        {
            handler = ServerMgr.Instance.gameObject.AddComponent<CleanupHandler>();
            handler.Init(this);
        }

        void Unload()
        {
            handler.Shutdown();
        }

        #endregion

        #region LangAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string> {
                    [M_PREFIX] = "[Entity Cleanup] ",
                    [M_NO_PERMISSION] = "<color=red>You have no access to this command</color>",
                    [M_INVALID_USAGE] = "Invalid command usage",
                    [M_CLEANUP_STARTED] = "Cleaning up old server entities...",
                    [M_CLEANUP_FINISHED] = "Cleanup completed, purged <color=#34ebba>{0}</color> old entities",
                    [M_CLEANUP_RUNNING] = "Cleanup is already running, wait until it completes"
                },
                this
            );
        }

        string GetMessage(IPlayer player, string langKey)
        {
            return lang.GetMessage(langKey, this, player.Id);
        }

        void Message(IPlayer player, string langKey, params object[] args)
        {
            var prefix = GetMessage(player, M_PREFIX);
            var format = GetMessage(player, langKey);
            var message = string.Format(format, args);

            player.Message(prefix + message);
        }

        void Announce(string langKey, params object[] args)
        {
            foreach (IPlayer player in players.Connected)
            {
                Message(player, langKey, args);
            }
        }

        #endregion

        #region Configuration load

        protected override void LoadDefaultConfig()
        {
            settings = PluginSettings.Default;
            SaveConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                settings = Config.ReadObject<PluginSettings>();

                if (settings == null)
                {
                    throw new Exception("Configuration is null");
                }
            }
            catch (Exception e)
            {
                LogError("Could not read configuration file:\n{0}", e.Message);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(settings);
        }

        #endregion

        #region Nested types

        #region CleanupHandler

        class CleanupHandler : MonoBehaviour
        {
            PluginSettings        settings;
            List<BaseNetworkable> entityList;
            Coroutine             cleanupRoutine;
            HashSet<string>       deployables;

            bool IsCleanupRunning => cleanupRoutine != null;

            event Action      OnCleanupStarted;
            event Action<int> OnCleanupComplete;

            public void Init(EntityCleanup plugin)
            {
                settings = plugin.settings;

                OnCleanupStarted = () =>
                {
                    plugin.Announce(M_CLEANUP_STARTED);
                };

                OnCleanupComplete = purgedEntityCount =>
                {
                    plugin.Announce(M_CLEANUP_FINISHED, purgedEntityCount);
                };

                entityList = Pool.GetList<BaseNetworkable>();
                deployables = Pool.Get<HashSet<string>>();

                var modDeployables = from itemDef in ItemManager.GetItemDefinitions()
                                     group itemDef by itemDef.GetComponent<ItemModDeployable>()
                                     into deps where deps.Key != null select deps.Key;

                foreach (var prefab in from depl in modDeployables select depl.entityPrefab.resourcePath)
                {
                    deployables.Add(prefab);
                }
            }

            public void Shutdown()
            {
                CancelInvoke();

                if (IsCleanupRunning)
                {
                    StopCoroutine(cleanupRoutine);
                    cleanupRoutine = null;
                }

                Pool.FreeList(ref entityList);
                deployables.Clear();
                Pool.Free(ref deployables);
                Destroy(this);
            }

            public bool TryStartCleanup()
            {
                if (IsCleanupRunning)
                {
                    return false;
                }

                StartCleanup();
                InitializeTimedCleanup();

                return true;
            }

            #region Unity messages

            void Start()
            {
                InitializeTimedCleanup();
            }

            #endregion

            void InitializeTimedCleanup()
            {
                CancelInvoke(nameof(StartCleanup));

                if (settings.Interval > 0)
                {
                    InvokeRepeating(nameof(StartCleanup), settings.Interval, settings.Interval);
                }
            }

            void StartCleanup()
            {
                if (IsCleanupRunning)
                {
                    return;
                }

                cleanupRoutine = StartCoroutine(Cleanup());
            }

            IEnumerator Cleanup()
            {
                entityList.AddRange(BaseNetworkable.serverEntities);
                int cleanedCount = 0;

                OnCleanupStarted();

                for (int i = 0; i < entityList.Count; i++)
                {
                    var entity = entityList[i] as BaseEntity;

                    if (entity && IsCleanupCandidate(entity))
                    {
                        entity.Kill(BaseNetworkable.DestroyMode.Gib);
                        cleanedCount++;
                    }

                    yield return new WaitForEndOfFrame();
                }

                OnCleanupComplete(cleanedCount);

                cleanupRoutine = null;
            }

            bool IsCleanupCandidate(BaseEntity entity)
            {
                if (entity.parentEntity.IsSet())
                {
                    return false;
                }

                if (entity.OwnerID == 0ul)
                {
                    return false;
                }

                if (
                    settings.Whitelist.Contains(entity.ShortPrefabName) ||
                    settings.Whitelist.Contains(entity.PrefabName)
                )
                {
                    return false;
                }

                if (entity is StabilityEntity && settings.CleanupBuildings ||
                    deployables.Contains(entity.gameObject.name) && settings.CleanupDeployables)
                {
                    BuildingPrivlidge buildingPrivilege = entity.GetBuildingPrivilege();
                    bool hasBuildingPrivilege = buildingPrivilege != null;

                    if (hasBuildingPrivilege)
                    {
                        if (!settings.RemoveInsidePrivilege)
                        {
                            return false;
                        }

                        if (settings.CheckOwnerIdPrivilegeAuthorized && buildingPrivilege.IsAuthed(entity.OwnerID))
                        {
                            return false;
                        }

                        return settings.InsideHealthFractionTheshold == 0f || entity.Health() / entity.MaxHealth() < settings.InsideHealthFractionTheshold;
                    }

                    if (!settings.RemoveOutsidePrivilege)
                    {
                        return false;
                    }
                    
                    return settings.OutsideHealthFractionTheshold == 0f || entity.Health() / entity.MaxHealth() < settings.OutsideHealthFractionTheshold;;
                }

                return false;
            }
        }

        #endregion

        #region PluginSettings

        class PluginSettings
        {
            public static PluginSettings Default => new PluginSettings {
                Interval = 3600,
                CleanupBuildings = true,
                CleanupDeployables = true,
                RemoveOutsidePrivilege = true,
                OutsideHealthFractionTheshold = 0.2f,
                RemoveInsidePrivilege = false,
                InsideHealthFractionTheshold = 0f,
                Whitelist = Array.Empty<string>(),
                CheckOwnerIdPrivilegeAuthorized = true
            };

            public int      Interval                        { get; set; }
            public bool     CleanupBuildings                { get; set; }
            public bool     CleanupDeployables              { get; set; }
            public bool     RemoveOutsidePrivilege          { get; set; }
            public float    OutsideHealthFractionTheshold   { get; set; }
            public bool     RemoveInsidePrivilege           { get; set; }
            public float    InsideHealthFractionTheshold    { get; set; }
            public string[] Whitelist                       { get; set; }
            public bool     CheckOwnerIdPrivilegeAuthorized { get; set; }
        }

        #endregion

        #endregion
    }
}


// --- End of file: EntityCleanup.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/easy-vote ---
// --- Original File Path: E/EasyVote/EasyVote.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    //Colour change, added rust-servers.info API, removed Beancan API by MikeHawke
    //Removed Resource ID by MikeHawke
    //Added BestServers.com by MikeHawke
    [Info("EasyVote", "Exel80", "2.0.43")]
    [Description("Simple and smooth voting start by activating one scirpt.")]
    class EasyVote : RustPlugin
    {
        [PluginReference] private Plugin DiscordMessages;

        #region Initializing
        // Permissions
        private const bool DEBUG = false;
        private const string permUse = "EasyVote.Use";

        // Vote status arrays
        // 0 = Havent voted yet OR already claimed.
        // 1 = Voted and waiting claiming.
        // 2 = Already claimed reward (Far us i know, RustServers is only who use this response number)
        protected string[] voteStatus = { "No reward(s)", "Claim reward(s)", "Claim reward(s) / Already claimed?" };
        protected string[] voteStatusColor = { "#ff0000", "#44ff00", "#ffff00" };

        // Spam protect list
        Dictionary<ulong, StringBuilder> claimCooldown = new Dictionary<ulong, StringBuilder>();
        Dictionary<ulong, bool> checkCooldown = new Dictionary<ulong, bool>();

        // List received reward(s) one big list.
        StringBuilder rewardsString = new StringBuilder();

        // List all vote sites.
        List<string> availableAPISites = new List<string>();
        StringBuilder _voteList = new StringBuilder();
        StringBuilder helpYou = new StringBuilder();
        private List<int> numberMax = new List<int>();

        void Loaded()
        {
            // Load configs
            LoadConfigValues();
            LoadMessages();

            // Regitering permissions
            permission.RegisterPermission(permUse, this);

            // Load storedata
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("EasyVote");

            // Check rewards and add them one big list
            BuildNumberMax();

            // Build helptext
            HelpText();

            // Check available vote sites
            checkVoteSites();

            // Build StringBuilders
            voteList();
        }
        #endregion

        #region Localization
        string _lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command!",
                ["ClaimStatus"] = "<color=#00fff7>[{0}]</color> Checked {1}, Status: {2}",
                ["ClaimError"] = "Something went wrong! Player <color=#ff0000>{0} got an error</color> from <color=#fffb00>{1}</color>. Please try again later!",
                ["ClaimReward"] = "You just received your vote reward(s). Enjoy!",
                ["ClaimPleaseWait"] = "Checking the voting websites. Please wait...",
                ["VoteList"] = "You have voted <color=#fffb00>{1}</color> time(s)!\n Leave another vote on these websites:\n{0}",
                ["EarnReward"] = "When you have voted, type <color=#fffb00>/claim</color> to claim your reward(s)!",
                ["RewardListFirstTime"] = "<color=#00fff7>Reward for voting for the first time.</color>",
                ["RewardListEverytime"] = "<color=#00fff7>Reward, which player will receive everytime they vote.</color>",
                ["RewardList"] = "<color=#00fff7>Reward for voting</color> <color=#FFA500>{0}</color> <color=#00fff7>time(s).</color>",
                ["Received"] = "You have received {0}x {1}",
                ["ThankYou"] = "Thank you for voting! You have voted <color=#fffb00>{0}</color> time(s) Here is your reward for..\n{1}",
                ["NoRewards"] = "You do not have any new rewards available\n Please type <color=#fffb00>/vote</color> and go to one of the websites to vote and receive your reward",
                ["RemeberClaim"] = "You haven't claimed your reward from voting for the server yet! Use <color=#fffb00>/claim</color> to claim your reward!\n You have to claim your reward within <color=#fffb00>24h</color>! Otherwise it will be gone!",
                ["GlobalChatAnnouncments"] = "<color=#fffb00>{0}</color><color=#00fff7> has voted </color><color=#fffb00>{1}</color><color=#00fff7> time(s) and just received their rewards. Find out where you can vote by typing</color><color=#fffb00> /vote</color>\n<color=#00fff7>To see a list of avaliable rewards type</color><color=#fffb00> /rewardlist</color>",
                ["money"] = "<color=#fffb00>{0}$</color> has been desposited into your account",
                ["rp"] = "You have gained <color=#fffb00>{0}</color> reward points",
                ["tempaddgroup"] = "You have been temporality added to <color=#fffb00>{0}</color> group (Expire in {1})",
                ["tempgrantperm"] = "You have temporality granted <color=#fffb00>{0}</color> permission (Expire in {1})",
                ["zlvl-wc"] = "You have gained <color=#fffb00>{0}</color> woodcrafting level(s)",
                ["zlvl-m"] = "You have gained <color=#fffb00>{0}</color> mining level(s)",
                ["zlvl-s"] = "You have gained <color=#fffb00>{0}</color> skinning level(s)",
                ["zlvl-c"] = "You have gained <color=#fffb00>{0}</color> crafting level(s)",
                ["zlvl-*"] = "You have gained <color=#fffb00>{0}</color> in all level(s)",
                ["oxidegrantperm"] = "You have been granted <color=#fffb00>{0}</color> permission",
                ["oxiderevokeperm"] = "Your permission <color=#fffb00>{0}</color> has been revoked",
                ["oxidegrantgroup"] = "You have been added to <color=#fffb00>{0}</color> group",
                ["oxiderevokegroup"] = "You have been removed from <color=#fffb00>{0}</color> group"
            }, this);
        }
        #endregion

        #region Hooks
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            // If (for some reason) player is stuck in claimCooldown list.
            if (claimCooldown.ContainsKey(player.userID))
                claimCooldown.Remove(player.userID);
        }

        private void SendHelpText(BasePlayer player)
        {
            if (hasPermission(player, permUse))
                player.ChatMessage(helpYou.ToString());
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!hasPermission(player, permUse))
                return;

            // Check if player exist in cooldown list or not
            if (!checkCooldown.ContainsKey(player.userID))
                checkCooldown.Add(player.userID, false);
            else if (checkCooldown.ContainsKey(player.userID))
                return;

            var timeout = 5500f; // Timeout (in milliseconds)

            foreach (var site in availableAPISites.ToList())
            {
                foreach (KeyValuePair<string, Dictionary<string, string>> kvp in _config.Servers)
                {
                    foreach (KeyValuePair<string, string> vp in kvp.Value)
                    {
                        if (vp.Key != site)
                            continue;

                        string[] idKeySplit = vp.Value.Split(':');
                        foreach (KeyValuePair<string, string> SitesApi in _config.VoteSitesAPI[site])
                        {
                            if (SitesApi.Key == PluginSettings.apiStatus)
                            {
                                // Formating api claim =>
                                // {0} = Key
                                // {1} PlayerID
                                string _format = String.Format(SitesApi.Value, idKeySplit[1], player.userID);

                                // Send GET request to voteAPI site.
                                webrequest.Enqueue(_format, null, (code, response) => CheckStatus(code, response, player), this, RequestMethod.GET, null, timeout);

                                _Debug($"GET: {_format} =>\n Site: {site} Server: {kvp.Key} Id: {idKeySplit[0]}");
                            }
                        }
                    }
                }
            }
            // Wait 3.69 sec before execute this command.
            // Because need make sure that plugin webrequest all api sites.
            timer.Once(3.69f, () =>
            {
                if (checkCooldown[player.userID])
                {
                    Chat(player, $"{_lang("RemeberClaim", player.UserIDString)}");
                }

                // Remove player from cooldown list
                checkCooldown.Remove(player.userID);
            });
        }
        #endregion

        #region Commands
        [ChatCommand("vote")]
        void cmdVote(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, permUse))
            {
                Chat(player, _lang("NoPermission", player.UserIDString));
                return;
            }

            // Check how many time player has voted.
            int voted = 0;
            if (_storedData.Players.ContainsKey(player.UserIDString))
                voted = _storedData.Players[player.UserIDString].voted;

            Chat(player, _lang("VoteList", player.UserIDString, _voteList.ToString(), voted));
            Chat(player, _lang("EarnReward", player.UserIDString));
        }

        [ChatCommand("claim")]
        void cmdClaim(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, permUse))
            {
                Chat(player, _lang("NoPermission", player.UserIDString));
                return;
            }

            // Check if player exist in cooldown list or not
            if (!claimCooldown.ContainsKey(player.userID))
                claimCooldown.Add(player.userID, new StringBuilder());
            else if (claimCooldown.ContainsKey(player.userID))
                return;

            var timeout = 5500f; // Timeout (in milliseconds)
            Chat(player, _lang("ClaimPleaseWait", player.UserIDString));

            foreach (var site in availableAPISites.ToList())
            {
                foreach (KeyValuePair<string, Dictionary<string, string>> kvp in _config.Servers)
                {
                    foreach (KeyValuePair<string, string> vp in kvp.Value)
                    {
                        // Make sure that key is site
                        if (vp.Key != site)
                            continue;

                        // Null check for ID & KEY
                        if (!vp.Value.Contains(":"))
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains ID or Key !!!");
                            continue;
                        }
                        else if (vp.Value.Split(':')[0] == "ID")
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains ID !!!");
                            continue;
                        }
                        else if (vp.Value.Split(':')[1] == "KEY")
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains KEY !!!");
                            continue;
                        }

                        // Split ID & Key
                        string[] idKeySplit = vp.Value.Split(':');

                        // Loop API pages
                        foreach (KeyValuePair<string, string> SitesApi in _config.VoteSitesAPI[site])
                        {
                            // Got apiClaim url
                            if (SitesApi.Key == PluginSettings.apiClaim)
                            {
                                // Formating api claim =>
                                // {0} APIKey
                                // {1} SteamID
                                // Example: "http://rust-servers.net/api/?action=custom&object=plugin&element=reward&key= {0} &steamid= {1} ",
                                string _format = String.Format(SitesApi.Value, idKeySplit[1], player.userID);

                                // Send GET request to voteAPI site.
                                webrequest.Enqueue(_format, null, (code, response) => ClaimReward(code, response, player, site, kvp.Key), this, RequestMethod.GET, null, timeout);

                                _Debug($"Player: {player.displayName} - Check claim URL: {_format}\nSite: {site} Server: {kvp.Key} VoteAPI-ID: {idKeySplit[0]} VoteAPI-KEY: {idKeySplit[1]}");
                            }
                        }
                    }
                }
            }

            // Wait 5.55 sec before remove player from cooldown list.
            timer.Once(5.55f, () =>
            {
                try
                {
                    // Print builded stringbuilder
                    Chat(player, claimCooldown[player.userID].ToString(), false);

                    // Remove player from cooldown list
                    claimCooldown.Remove(player.userID);
                }
                catch (Exception ex) { _Debug($"Error happen when try print \\claim status to \"{player.displayName}\"\n{ex.ToString()}"); PrintError("[ClaimStatus] Error printed to oxide/logs/EasyVote"); }
            });
        }

        [ChatCommand("rewardlist")]
        void cmdReward(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, permUse))
            {
                Chat(player, _lang("NoPermission", player.UserIDString));
                return;
            }

            rewardList(player);
        }
        #endregion

        #region Reward Handler
        private void RewardHandler(BasePlayer player, string serverName = null)
        {
            // Check that player is in "database".
            var playerData = new PlayerData();
            if (!_storedData.Players.ContainsKey(player.UserIDString))
            {
                _storedData.Players.Add(player.UserIDString, playerData);
                _storedData.Players[player.UserIDString].lastTime_Voted = DateTime.UtcNow;
                Interface.GetMod().DataFileSystem.WriteObject("EasyVote", _storedData);
            }

            // Add +1 vote to player.
            _storedData.Players[player.UserIDString].voted++;
            _storedData.Players[player.UserIDString].lastTime_Voted = DateTime.UtcNow;
            Interface.GetMod().DataFileSystem.WriteObject("EasyVote", _storedData);

            // Get how many time player has voted.
            int voted = _storedData.Players[player.UserIDString].voted;

            // Take closest number from rewardNumbers
            int? closest = null;
            if (numberMax.Count != 0)
            {
                try
                {
                    closest = (int?)numberMax.Aggregate((x, y) => Math.Abs(x - voted) < Math.Abs(y - voted)
                            ? (x > voted ? y : x)
                            : (y > voted ? x : y));
                }
                catch (InvalidOperationException error) { _Debug($"Player {player.displayName} tried to claim a reward but this happened ...\n{error.ToString()}"); PrintError("[ClaimReward] Error printed to oxide/logs/EasyVote"); return; }

                if (closest > voted)
                {
                    _Debug($"Closest ({closest}) number was bigger then voted number ({voted}). Changed closest from ({closest}) to 0");
                    closest = 0;
                }

                _Debug($"Reward Number: {closest} Voted: {voted}");
            }

            // and here the magic happens. Loop for all rewards.
            foreach (KeyValuePair<string, List<string>> kvp in _config.Rewards)
            {
                // If first time voted
                if (kvp.Key.ToLower() == "first")
                {
                    // Make sure that this is player first time voting
                    if (voted > 1)
                        continue;

                    GaveRewards(player, kvp.Value);
                    continue;
                }

                // Gave this reward everytime
                if (kvp.Key == "@")
                {
                    GaveRewards(player, kvp.Value);
                    continue;
                }

                // Cumlative reward
                if (_config.Settings[PluginSettings.RewardIsCumulative].ToLower() == "true")
                {
                    if (kvp.Key.ToString().Contains("vote"))
                    {
                        // Tryparse vote number
                        int voteNumber;
                        if (!int.TryParse(kvp.Key.Replace("vote", ""), out voteNumber))
                            continue;

                        // All reward has now claimed
                        if (voteNumber > closest)
                            continue;

                        _Debug($" -> About to gave {kvp.Key} rewards");
                        GaveRewards(player, kvp.Value);
                    }
                    continue;
                }

                // Got closest vote
                if (closest != null)
                {
                    if (kvp.Key.ToString() == $"vote{closest}")
                    {
                        GaveRewards(player, kvp.Value);
                    }
                }

            }
            if (_config.Settings[PluginSettings.GlobalChatAnnouncments]?.ToLower() == "true")
                PrintToChat($"{_lang("GlobalChatAnnouncments", player.UserIDString, player.displayName, voted)}");

            // Send message to discord text channel.
            if (_config.Discord[PluginSettings.DiscordEnabled].ToLower() == "true")
            {
                List<Fields> fields = new List<Fields>();
                string json;

                fields.Add(new Fields("Voter", $"[{player.displayName}](https://steamcommunity.com/profiles/{player.userID})", true));
                fields.Add(new Fields("Voted", voted.ToString(), true));
                fields.Add(new Fields("Server", (serverName != null ? serverName : "[ UNKNOWN ]"), true));
                fields.Add(new Fields("Reward(s)", CleanHTML(rewardsString.ToString()), false));

                json = JsonConvert.SerializeObject(fields);
                DiscordMessages?.Call("API_SendFancyMessage", _config.Discord[PluginSettings.WebhookURL], _config.Discord[PluginSettings.Title], 3329330, json, bool.Parse(_config.Discord[PluginSettings.Alert]) ? "@here" : null);
            }

            // Make sure that player has voted etc.
            if (rewardsString.Length > 1)
            {
                // Hookmethod: void onUserReceiveReward(BasePlayer player, int voted)
                Interface.CallHook("onUserReceiveReward", player, voted);

                // Send ThankYou to player
                if (_config.Settings[PluginSettings.LocalChatAnnouncments].ToLower() == "true")
                    Chat(player, $"{_lang("ThankYou", player.UserIDString, voted, rewardsString.ToString())}");

                // Clear rewardString
                rewardsString.Clear();
            }
        }

        /// <summary>
        /// Gave all rewards from List<string>
        /// </summary>
        /// <param name="player"></param>
        /// <param name="rewardValue"></param>
        private void GaveRewards(BasePlayer player, List<string> rewardValue)
        {
            foreach (string reward in rewardValue)
            {
                // Split reward to variable and value.
                string[] valueSplit = reward.Split(':');
                string commmand = valueSplit[0];
                string value = valueSplit[1].Replace(" ", "");

                // Checking variables and run console command.
                // If variable not found, then try give item.
                if (_config.Commands.ContainsKey(commmand))
                {
                    _Debug($"{getCmdLine(player, commmand, value)}");
                    rust.RunServerCommand(getCmdLine(player, commmand, value));

                    if (!value.Contains("-"))
                        rewardsString.AppendLine($"- {_lang(commmand, player.UserIDString, value)}");
                    else
                    {
                        string[] _value = value.Split('-');
                        rewardsString.AppendLine($"- {_lang(commmand, player.UserIDString, _value[0], _value[1])}");
                    }

                    _Debug($"Ran command {String.Format(commmand, value)}");
                    continue;
                }
                else
                {
                    try
                    {
                        Item itemToReceive = ItemManager.CreateByName(commmand, Convert.ToInt32(value));
                        _Debug($"Received item {itemToReceive.info.displayName.translated} x{value}");
                        //If the item does not end up in the inventory
                        //Drop it on the ground for them
                        if (!player.inventory.GiveItem(itemToReceive, player.inventory.containerMain))
                            itemToReceive.Drop(player.GetDropPosition(), player.GetDropVelocity());

                        rewardsString.AppendLine($"- {_lang("Received", player.UserIDString, value, itemToReceive.info.displayName.translated)}");
                    }
                    catch (Exception e) { PrintWarning($"{e}"); }
                }
            }
        }

        private string getCmdLine(BasePlayer player, string str, string value)
        {
            var output = String.Empty;
            string playerid = player.UserIDString;
            string playername = player.displayName;

            // Checking if value contains => -
            if (!value.Contains('-'))
                output = _config.Commands[str].ToString()
                    .Replace("{playerid}", playerid)
                    .Replace("{playername}", '"' + playername + '"')
                    .Replace("{value}", value);
            else
            {
                string[] splitValue = value.Split('-');
                output = _config.Commands[str].ToString()
                    .Replace("{playerid}", playerid)
                    .Replace("{playername}", '"' + playername + '"')
                    .Replace("{value}", splitValue[0])
                    .Replace("{value2}", splitValue[1]);
            }
            return $"{output}";
        }
        #endregion

        #region Storing
        class StoredData
        {
            public Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
            public StoredData() { }
        }
        class PlayerData
        {
            public int voted;
            public DateTime lastTime_Voted;

            public PlayerData()
            {
                voted = 0;
                lastTime_Voted = DateTime.UtcNow;
            }
        }
        StoredData _storedData;
        #endregion

        #region Webrequests
        void ClaimReward(int code, string response, BasePlayer player, string url, string serverName = null)
        {
            _Debug($"URL: {url} - Code: {code}, Response: {response}");

            // Change response to number
            int responseNum = 0;
            if (!int.TryParse(response, out responseNum))
                _Debug($"Cant understand vote site {url} response \"{response}\"");

            // If vote site is down
            if (code != 200)
            {
                PrintError("Error: {0} - Couldn't get an answer for {1} ({2})", code, player.displayName, url);
                Chat(player, $"{_lang("ClaimError", player.UserIDString, code, url)}");
                return;
            }

            // Add response to StringBuilder
            if (claimCooldown.ContainsKey(player.userID))
            {
                claimCooldown[player.userID].AppendLine(_lang("ClaimStatus", player.UserIDString,
                    (!string.IsNullOrEmpty(serverName) ? serverName : string.Empty), url, $"<color={voteStatusColor[responseNum]}>{voteStatus[responseNum]}</color>"));
            }

            // If response is 1 = Voted & not yet claimed
            if (responseNum == 1)
                RewardHandler(player, serverName);
        }

        void CheckStatus(int code, string response, BasePlayer player)
        {
            _Debug($"Player: {player.displayName} - Code: {code}, Response: {response}");

            if (response?.ToString() == "1" && code == 200)
            {
                if (!checkCooldown.ContainsKey(player.userID))
                {
                    checkCooldown.Add(player.userID, true);
                }
                checkCooldown[player.userID] = true;
            }
        }
        #endregion

        #region Configuration

        #region Configuration Defaults
        PluginConfig DefaultConfig()
        {
            var defaultConfig = new PluginConfig
            {
                Settings = new Dictionary<string, string>
                {
                    { PluginSettings.Prefix, "<color=#00fff7>[EasyVote]</color>" },
                    { PluginSettings.RewardIsCumulative, "false" },
                    { PluginSettings.LogEnabled, "true" },
                    { PluginSettings.GlobalChatAnnouncments, "true" },
                    { PluginSettings.LocalChatAnnouncments, "true" }
                },
                Discord = new Dictionary<string, string>
                {
                    { PluginSettings.DiscordEnabled, "false" },
                    { PluginSettings.Alert, "false" },
                    { PluginSettings.Title, "Vote" },
                    { PluginSettings.WebhookURL, "" }
                },
                Servers = new Dictionary<string, Dictionary<string, string>>
                {
                    { "ServerName1", new Dictionary<string, string>() {{ "Rust-Servers.net", "ID:KEY" } } },
                    { "ServerName2", new Dictionary<string, string>() { { "Rust-Servers.info", "ID:KEY" } } },
                    { "ServerName3", new Dictionary<string, string>() { { "BestServers.com", "ID:KEY" } } }
                },
                VoteSitesAPI = new Dictionary<string, Dictionary<string, string>>
                {
                    { "Rust-Servers.net",
                       new Dictionary<string, string>() {
                           { PluginSettings.apiClaim, "http://rust-servers.net/api/?action=custom&object=plugin&element=reward&key={0}&steamid={1}" },
                           { PluginSettings.apiStatus, "http://rust-servers.net/api/?object=votes&element=claim&key={0}&steamid={1}" },
                           { PluginSettings.apiLink, "http://rust-servers.net/server/{0}" }
                       }
                    },
                    { "Rust-Servers.info",
                       new Dictionary<string, string>() {
                           { PluginSettings.apiClaim, "https://api.rust-servers.info/votesclime/?key={0}&steamid={1}" },
                           { PluginSettings.apiStatus, "https://api.rust-servers.info/votescheckclime/?key={0}&steamid={1}" },
                           { PluginSettings.apiLink, "http://rust-servers.info/server/id-{0}.html" }
                       }
                    },
                    { "BestServers.com",
                       new Dictionary<string, string>() {
                           { PluginSettings.apiClaim, "https://bestservers.com/api/vote.php?action=claim&key={0}&steamid={1}" },
                           { PluginSettings.apiStatus, "https://bestservers.com/api/vote.php?action=status&key={0}&steamid={1}" },
                           { PluginSettings.apiLink, "https://bestservers.com/server/{0}" }
                       }
                    },
                },
                Rewards = new Dictionary<string, List<string>>
                {
                    { "first", new List<string>() { "oxidegrantperm: kits.starterkit" } },
                    { "@", new List<string>() { "supply.signal: 1", "zlvl-*: 1" } },
                    { "vote3", new List<string>() { "oxidegrantgroup: member" } },
                    { "vote6", new List<string>() { "money: 500", "tempaddgroup: vip-1d1h1m" } },
                    { "vote10", new List<string>() { "money: 1000", "rp: 50", "tempgrantperm: fauxadmin.allowed-5m" } }
                },
                Commands = new Dictionary<string, string>
                {
                    ["money"] = "deposit {playerid} {value}",
                    ["rp"] = "sr add {playerid} {value}",
                    ["oxidegrantperm"] = "oxide.grant user {playerid} {value}",
                    ["oxiderevokeperm"] = "oxide.revoke user {playerid} {value}",
                    ["oxidegrantgroup"] = "oxide.usergroup add {playerid} {value}",
                    ["oxiderevokegroup"] = "oxide.usergroup remove {playerid} {value}",
                    ["tempaddgroup"] = "addgroup {playerid} {value} {value2}",
                    ["tempgrantperm"] = "grantperm {playerid} {value} {value2}",
                    ["zlvl-c"] = "zl.lvl {playerid} C +{value}",
                    ["zlvl-wc"] = "zl.lvl {playerid} WC +{value}",
                    ["zlvl-m"] = "zl.lvl {playerid} M +{value}",
                    ["zlvl-s"] = "zl.lvl {playerid} S +{value}",
                    ["zlvl-*"] = "zl.lvl {playerid} * +{value}",
                }
            };
            return defaultConfig;
        }
        #endregion

        private bool configChanged;
        private PluginConfig _config;

        protected override void LoadDefaultConfig() => Config.WriteObject(DefaultConfig(), true);

        class PluginSettings
        {
            public const string apiClaim = "API Claim Reward (GET URL)";
            public const string apiStatus = "API Vote status (GET URL)";
            public const string apiLink = "Vote link (URL)";
            public const string Title = "Title";
            public const string WebhookURL = "Discord webhook (URL)";
            public const string DiscordEnabled = "DiscordMessage Enabled (true / false)";
            public const string Alert = "Enable @here alert (true / false)";
            public const string Prefix = "Prefix";
            public const string LogEnabled = "Enable logging => oxide/logs/EasyVote (true / false)";
            public const string RewardIsCumulative = "Vote rewards cumulative (true / false)";
            public const string GlobalChatAnnouncments = "Globally announcment in chat when player voted (true / false)";
            public const string LocalChatAnnouncments = "Send thank you message to player who voted (true / false)";
        }
        class PluginConfig
        {
            public Dictionary<string, string> Settings { get; set; }
            public Dictionary<string, string> Discord { get; set; }
            public Dictionary<string, Dictionary<string, string>> Servers { get; set; }
            public Dictionary<string, Dictionary<string, string>> VoteSitesAPI { get; set; }
            public Dictionary<string, List<string>> Rewards { get; set; }
            public Dictionary<string, string> Commands { get; set; }
        }
        void LoadConfigValues()
        {
            // Load config file
            _config = Config.ReadObject<PluginConfig>();
            var defaultConfig = DefaultConfig();

            try
            {
                // Try merge config
                Merge(_config.Settings, defaultConfig.Settings);
                Merge(_config.Discord, defaultConfig.Discord);
                Merge(_config.Servers, defaultConfig.Servers, true);
                Merge(_config.VoteSitesAPI, defaultConfig.VoteSitesAPI, true);
                Merge(_config.Rewards, defaultConfig.Rewards, true);
                Merge(_config.Commands, defaultConfig.Commands, true);
            }
            catch
            {
                // Print warning
                PrintWarning($"Could not read oxide/config/{Name}.json, creating new config file");

                // Load default config
                LoadDefaultConfig();
                _config = Config.ReadObject<PluginConfig>();

                // Merge config again
                Merge(_config.Settings, defaultConfig.Settings);
                Merge(_config.Discord, defaultConfig.Discord);
                Merge(_config.Servers, defaultConfig.Servers, true);
                Merge(_config.VoteSitesAPI, defaultConfig.VoteSitesAPI, true);
                Merge(_config.Rewards, defaultConfig.Rewards, true);
                Merge(_config.Commands, defaultConfig.Commands, true);
            }

            // If config changed, run this
            if (!configChanged) return;
            PrintWarning("Configuration file(s) updated!");
            Config.WriteObject(_config);
        }
        void Merge<T1, T2>(IDictionary<T1, T2> current, IDictionary<T1, T2> defaultDict, bool bypass = false)
        {
            foreach (var pair in defaultDict)
            {
                if (bypass) continue;
                if (current.ContainsKey(pair.Key)) continue;
                current[pair.Key] = pair.Value;
                configChanged = true;
            }
            var oldPairs = defaultDict.Keys.Except(current.Keys).ToList();
            foreach (var oldPair in oldPairs)
            {
                if (bypass) continue;
                current.Remove(oldPair);
                configChanged = true;
            }
        }
        #endregion

        #region Helper 
        public void Chat(BasePlayer player, string str, bool prefix = true) => SendReply(player, (prefix != false ? $"{_config.Settings["Prefix"]} " : string.Empty) + str);
        public void _Debug(string msg)
        {
            if (Convert.ToBoolean(_config.Settings[PluginSettings.LogEnabled]))
                LogToFile("EasyVote", $"[{DateTime.UtcNow.ToString()}] {msg}", this);

            if (DEBUG)
                Puts($"[Debug] {msg}");
        }

        private void HelpText()
        {
            helpYou.Append("<color=#00fff7>EasyVote Commands ::</color>").AppendLine();
            helpYou.Append("<color=#fffb00>/vote</color> - Show the voting website(s)").AppendLine();
            helpYou.Append("<color=#fffb00>/claim</color> - Claim vote reward(s)").AppendLine();
            helpYou.Append("<color=#fffb00>/rewardlist</color> - Display all reward(s) what you can get from voting.");
        }

        private string CleanHTML(string input)
        {
            return Regex.Replace(input, @"<(.|\n)*?>", string.Empty);
        }

        private bool hasPermission(BasePlayer player, string perm)
        {
            if (player.IsAdmin) return true;
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;
            return false;
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void rewardList(BasePlayer player)
        {
            StringBuilder rewardList = new StringBuilder();

            int lineCounter = 0; // Count lines
            int lineSplit = 2; // Value when split reward list.

            foreach (KeyValuePair<string, List<string>> kvp in _config.Rewards)
            {
                if (kvp.Key.ToLower() == "first")
                {
                    rewardList.Append(_lang("RewardListFirstTime", null)).AppendLine();

                    var valueList = String.Join(Environment.NewLine, kvp.Value.ToArray());
                    rewardList.Append(valueList).AppendLine();
                    lineCounter++;
                }

                if (kvp.Key == "@")
                {
                    rewardList.Append(_lang("RewardListEverytime", null)).AppendLine();

                    var valueList = String.Join(Environment.NewLine, kvp.Value.ToArray());
                    rewardList.Append(valueList).AppendLine();
                    lineCounter++;
                }

                // If lineCounter is less then lineSplit.
                if (lineCounter <= lineSplit)
                {
                    int voteNumber;
                    if (!int.TryParse(kvp.Key.Replace("vote", ""), out voteNumber))
                    {
                        if (!(kvp.Key.ToLower() != "first" || kvp.Key.ToLower() != "@"))
                            PrintWarning($"[RewardHandler] Invalid vote config format \"{kvp.Key}\"");

                        continue;
                    }
                    rewardList.Append(_lang("RewardList", null, voteNumber)).AppendLine();

                    var valueList = String.Join(Environment.NewLine, kvp.Value.ToArray());
                    rewardList.Append(valueList).AppendLine();
                    lineCounter++;
                }
                // If higher, then send rewardList to player and empty it.
                else
                {
                    SendReply(player, rewardList.ToString());
                    rewardList.Clear();
                    lineCounter = 0;

                    int voteNumber;
                    if (!int.TryParse(kvp.Key.Replace("vote", ""), out voteNumber))
                    {
                        if (!(kvp.Key.ToLower() != "first" || kvp.Key.ToLower() != "@"))
                            PrintWarning($"[RewardHandler] Invalid vote config format \"{kvp.Key}\"");

                        continue;
                    }

                    rewardList.Append(_lang("RewardList", null, voteNumber)).AppendLine();
                    var valueList = String.Join(Environment.NewLine, kvp.Value.ToArray());
                    rewardList.Append(valueList).AppendLine();
                }
            }

            // This section is for making sure all rewards will be displayed.
            SendReply(player, rewardList.ToString());
        }

        private void BuildNumberMax()
        {
            foreach (KeyValuePair<string, List<string>> kvp in _config.Rewards)
            {
                // Ignore @ and first
                if (kvp.Key == "@")
                    continue;
                if (kvp.Key.ToLower() == "first")
                    continue;

                // If key contains "vote"
                if (kvp.Key.ToLower().Contains("vote"))
                {
                    int rewardNumber;

                    // Remove alphabetic and leave only number.
                    if (!int.TryParse(kvp.Key.Replace("vote", ""), out rewardNumber))
                    {
                        Puts($"Invalid vote config format \"{kvp.Key}\"");
                        continue;
                    }
                    numberMax.Add(rewardNumber);
                }
            }
        }

        private void voteList()
        {
            List<string> temp = new List<string>();

            foreach (var site in availableAPISites.ToList())
            {
                foreach (KeyValuePair<string, Dictionary<string, string>> kvp in _config.Servers)
                {
                    foreach (KeyValuePair<string, string> vp in kvp.Value)
                    {
                        // Null checking
                        if (!vp.Value.Contains(":"))
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains ID or Key !!!");
                            continue;
                        }
                        else if (vp.Value.Split(':')[0] == "ID")
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains ID !!!");
                            continue;
                        }
                        else if (vp.Value.Split(':')[1] == "KEY")
                        {
                            _Debug($"{kvp.Key} {vp.Key} does NOT contains KEY !!!");
                            continue;
                        }

                        if (vp.Key == site)
                        {
                            string[] idKeySplit = vp.Value.Split(':');
                            foreach (KeyValuePair<string, string> SitesApi in _config.VoteSitesAPI[site])
                            {
                                if (SitesApi.Key == PluginSettings.apiLink)
                                {
                                    _Debug($"Added {String.Format(SitesApi.Value, idKeySplit[0])} to the stringbuilder list.");
                                    temp.Add($"<color=#C0C0C0>{String.Format(SitesApi.Value, idKeySplit[0])}</color>");
                                }
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < temp.Count; i++)
            {
                _voteList.Append(temp[i]);
                if (i != (temp.Count - 1))
                    _voteList.AppendLine();
            }
        }

        private void checkVoteSites()
        {
            // Double check that VoteSitesAPI isnt null
            if (_config.VoteSitesAPI.Count == 0)
            {
                PrintWarning("VoteSitesAPI is null in oxide/config/EasyVote.json !!!");
                return;
            }

            // Add key names to List<String> availableSites
            foreach (KeyValuePair<string, Dictionary<string, string>> kvp in _config.VoteSitesAPI)
            {
                bool pass = true;
                foreach (KeyValuePair<string, string> vp in kvp.Value)
                {
                    if (string.IsNullOrEmpty(vp.Value))
                    {
                        pass = false;
                        PrintWarning($"In '{kvp.Key}' value '{vp.Key}' is null (oxide/config/EasyVote.json). Disabled: {kvp.Key}");
                        continue;
                    }
                }

                if (pass)
                {
                    _Debug($"Added {kvp.Key} to the \"availableSites\" list");
                    availableAPISites.Add(kvp.Key);
                }
            }
        }
        #endregion

        #region API
        // Output : string() UserID;
        // If there multiple player has same vote value, include them all in one string.
        // Multiple player output format: userid,userid,userid .. etc
        private string getHighestvoter()
        {
            // Helppers
            string output = string.Empty;
            int tempValue = 0;
            Dictionary<string, int> tempList = new Dictionary<string, int>();

            // Receive EasyVote StoreData and save it to tempList.
            foreach (KeyValuePair<string, PlayerData> item in _storedData.Players)
                tempList.Add(item.Key, item.Value.voted);

            // Loop tempList
            foreach (var item in tempList.OrderByDescending(key => key.Value))
            {
                // Run once
                if (tempValue == 0)
                {
                    output = item.Key;
                    tempValue = item.Value;
                    continue;
                }

                if (tempValue != 0)
                {
                    // If tempValue match.
                    if (item.Value == tempValue)
                    {
                        output += $",{item.Key}";
                    }
                    continue;
                }
            }
            return output;
        }

        // Output : string() UserID;
        private string getLastvoter()
        {
            string output = string.Empty;
            Dictionary<string, DateTime> tempList = new Dictionary<string, DateTime>();

            foreach (KeyValuePair<string, PlayerData> item in _storedData.Players)
                tempList.Add(item.Key, item.Value.lastTime_Voted);

            foreach (var item in tempList.OrderBy(x => x.Value).Take(1))
                output = item.Key;

            return output;
        }

        // Output : Only console message.
        private void resetPlayerVotedData(string steamID, bool displayMessage = true)
        {
            // Null checks
            if (string.IsNullOrEmpty(steamID))
                return;

            if (!_storedData.Players.ContainsKey(steamID))
                return;

            // Reset voted data
            int old = _storedData.Players[steamID].voted;
            _storedData.Players[steamID].voted = 0;
            Interface.GetMod().DataFileSystem.WriteObject("EasyVote", _storedData);

            // Print console message
            if (displayMessage)
                Puts($"Player '{steamID}' vote(s) data has been reseted from {old} to 0.");
        }

        // Output : Only console message.
        private void resetData(bool backup = true)
        {
            string currentTime = DateTime.UtcNow.ToString("dd-MM-yyyy");

            // Backup
            if (backup)
                Interface.GetMod().DataFileSystem.WriteObject($"EasyVote-{currentTime}.bac", _storedData);

            // Set new storedata
            _storedData = new StoredData();

            // Write wiped data
            Interface.GetMod().DataFileSystem.WriteObject("EasyVote", _storedData);

            Puts($"Storedata reseted, backup made in oxide/data/EasyVote-{currentTime}.bac");
        }
        #endregion
    }
}

// --- End of file: EasyVote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/elevator-counters ---
// --- Original File Path: E/ElevatorCounters/ElevatorCounters.cs ---

﻿using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Elevator Counters", "WhiteThunder", "1.0.2")]
    [Description("Allows wiring counters into elevators to display the current floor and function as a call button.")]
    internal class ElevatorCounters : CovalencePlugin
    {
        #region Fields

        private static readonly PropertyInfo ElevatorLiftOwnerProperty = typeof(ElevatorLift).GetProperty("owner", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

        private const float MaxCounterUpdateFrequency = 0.4f;

        private readonly Dictionary<NetworkableId, Action> liftTimerActions = new();

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var counter = entity as PowerCounter;
                if (counter != null)
                {
                    HandleCounterInit(counter);
                }
            }
        }

        private void HandleCounterInit(PowerCounter counter)
        {
            // Ignore counters that have connected inputs since those should function normally
            if (HasConnectedInput(counter))
                return;

            // Ignore counters not connected to elevators
            var elevator = GetConnectedElevator(counter);
            if (elevator == null)
                return;

            var topElevator = GetTopElevator(elevator);
            if (IsPowered(topElevator))
            {
                InitializeCounter(counter, GetDisplayFloor(topElevator));
            }
        }

        // When an elevator is removed without adding a new one
        // Possibly toggle all previously attached counters based on new power state
        private void OnEntityKill(Elevator elevator)
        {
            var bottomElevator = GetBottomElevator(elevator);
            var counters = GetAllConnectedCounters(GetTopElevator(elevator));
            if (counters == null)
                return;

            NextTick(() =>
            {
                if (bottomElevator == null)
                {
                    foreach (var counter in counters)
                    {
                        if (counter != null)
                            ResetCounter(counter);
                    }
                    return;
                }

                var topElevator = GetTopElevator(bottomElevator);
                var isPowered = IsPowered(topElevator);
                var currentFloor = GetDisplayFloor(topElevator);

                foreach (var counter in counters)
                {
                    if (counter == null)
                        continue;

                    if (isPowered)
                        InitializeCounter(counter, currentFloor);
                    else
                        ResetCounter(counter);
                }
            });
        }

        private void OnEntityKill(ElevatorLift lift)
        {
            liftTimerActions.Remove(lift.net.ID);
        }

        private void OnElevatorMove(Elevator topElevator, int targetFloor)
        {
            if (!topElevator.liftEntity.TryGet(true, out var lift)
                || lift == null)
                return;

            var liftFloor = topElevator.LiftPositionToFloor();
            if (targetFloor == liftFloor)
                return;

            // Using NextTick to wait for the movement to begin so we can get the travel time
            NextTick(() =>
            {
                if (topElevator == null || lift == null)
                    return;

                var travelTime = GetTravelTime(lift);
                if (travelTime == 0)
                    return;

                var counters = GetAllConnectedCounters(topElevator);
                if (counters != null)
                {
                    StartUpdatingLiftCounters(lift, counters, travelTime);
                }
            });
        }

        private object OnCounterModeToggle(PowerCounter counter, BasePlayer player, bool doShowPassthrough)
        {
            // Make "show counter" action call the elevator
            var elevator = GetConnectedElevator(counter);
            if (!doShowPassthrough && elevator != null && IsEligibleToBeElevatorCounter(counter))
            {
                elevator.CallElevator();
                return false;
            }

            return null;
        }

        private void OnInputUpdate(PowerCounter counter, int inputAmount)
        {
            // Ignore counters not connected to elevators
            Elevator elevator = GetConnectedElevator(counter);
            if (elevator == null)
                return;

            // This has to be delayed since clearing a wire causes this to be called before the connection is actually removed
            NextTick(() =>
            {
                if (elevator == null || counter == null || HasConnectedInput(counter))
                    return;

                MaybeToggleCounter(elevator, counter);
            });
        }

        private void OnInputUpdate(Elevator elevator, int inputAmount, int inputSlot)
        {
            var counter = elevator.inputs[inputSlot].connectedTo.Get() as PowerCounter;
            if (counter == null)
                return;

            NextTick(() =>
            {
                if (elevator == null || counter == null || HasConnectedInput(counter))
                    return;

                if (GetConnectedElevator(counter) == null)
                {
                    ResetCounter(counter);
                    return;
                }

                MaybeToggleCounter(elevator, counter);
            });
        }

        // Covers the case when power state changes, and when a new elevator is added
        private void OnInputUpdate(ElevatorIOEntity elevatorIOEntity, int inputAmount)
        {
            if (elevatorIOEntity == null)
                return;

            var topElevator = elevatorIOEntity.GetParentEntity() as Elevator;

            // This shouldn't happen normally, but it's possible if elevators were pasted incorrectly
            if (topElevator == null)
                return;

            var counters = GetAllConnectedCounters(topElevator);
            if (counters == null)
                return;

            var bottomElevator = GetBottomElevator(topElevator);

            // BetterElevators uses NextTick to restore power after disconnecting a powerless elevator
            // So this uses a timer (slower) so we can properly determine if the elevator has power
            timer.Once(0, () =>
            {
                if (bottomElevator == null)
                {
                    foreach (var counter in counters)
                    {
                        if (counter != null)
                            ResetCounter(counter);
                    }

                    return;
                }

                topElevator = GetTopElevator(bottomElevator);
                var isPowered = IsPowered(topElevator);
                var currentFloor = GetDisplayFloor(topElevator);

                foreach (var counter in counters)
                {
                    if (isPowered)
                        InitializeCounter(counter, currentFloor);
                    else
                        ResetCounter(counter);
                }
            });
        }

        #endregion

        #region Helper Methods

        private static Elevator GetOwnerElevator(ElevatorLift lift)
        {
            return ElevatorLiftOwnerProperty?.GetValue(lift) as Elevator;
        }

        private float GetTravelTime(ElevatorLift lift)
        {
            var tweens = LeanTween.descriptions(lift.gameObject);
            if (tweens.Length == 0)
                return 0;

            return tweens[0].time;
        }

        private void StartUpdatingLiftCounters(ElevatorLift lift, PowerCounter[] counters, float timeToTravel)
        {
            Action existingTimerAction;
            if (liftTimerActions.TryGetValue(lift.net.ID, out existingTimerAction))
            {
                lift.CancelInvoke(existingTimerAction);
            }

            var lastCounterUpdateTime = Time.time;
            Action timerAction = null;
            var stepsRemaining = timeToTravel / MaxCounterUpdateFrequency;
            timerAction = () =>
            {
                stepsRemaining--;

                var reachedEnd = stepsRemaining <= 0;
                if (reachedEnd || Time.time >= lastCounterUpdateTime + MaxCounterUpdateFrequency)
                {
                    UpdateCounters(lift, counters);
                    lastCounterUpdateTime = Time.time;
                }

                if (reachedEnd)
                {
                    lift.CancelInvoke(timerAction);
                    liftTimerActions.Remove(lift.net.ID);
                }
            };
            lift.InvokeRepeating(timerAction, MaxCounterUpdateFrequency, MaxCounterUpdateFrequency);
            liftTimerActions[lift.net.ID] = timerAction;
        }

        private void UpdateCounters(ElevatorLift lift, PowerCounter[] counters)
        {
            // Get the elevator on every update, since the lift can be re-parented
            var elevator = GetOwnerElevator(lift);
            if (elevator == null || counters == null)
                return;

            var floor = elevator.LiftPositionToFloor() + 1;

            foreach (var counter in counters)
            {
                if (counter.counterNumber == floor)
                    continue;

                counter.counterNumber = floor;
                counter.targetCounterNumber = floor;
                counter.currentEnergy = floor;
                counter.SendNetworkUpdate();
            }
        }

        private int GetDisplayFloor(Elevator topElevator)
        {
            if (!topElevator.liftEntity.TryGet(true, out var liftEntity)
                || liftEntity == null)
                return 1;

            return topElevator.LiftPositionToFloor() + 1;
        }

        private bool IsPowered(Elevator topElevator)
        {
            return topElevator.ioEntity != null && topElevator.ioEntity.IsPowered();
        }

        private Elevator GetTopElevator(Elevator elevator)
        {
            return GetFarthestElevatorInDirection(elevator, Elevator.Direction.Up);
        }

        private Elevator GetBottomElevator(Elevator elevator)
        {
            return GetFarthestElevatorInDirection(elevator, Elevator.Direction.Down);
        }

        private Elevator GetFarthestElevatorInDirection(Elevator elevator, Elevator.Direction direction)
        {
            var currentElevator = elevator;

            Elevator nextElevator;
            while ((nextElevator = currentElevator.GetElevatorInDirection(direction)) != null)
                currentElevator = nextElevator;

            return currentElevator;
        }

        private void MaybeToggleCounter(Elevator elevator, PowerCounter counter)
        {
            var topElevator = GetTopElevator(elevator);
            if (IsPowered(topElevator))
            {
                InitializeCounter(counter, GetDisplayFloor(topElevator));
            }
            else
            {
                ResetCounter(counter);
            }
        }

        private void InitializeCounter(PowerCounter counter, int floor)
        {
            counter.SetFlag(IOEntity.Flag_HasPower, true);
            counter.SetFlag(BaseEntity.Flags.Reserved2, true);
            counter.currentEnergy = floor;
            counter.SendNetworkUpdate();
        }

        private void ResetCounter(PowerCounter counter)
        {
            counter.SetFlag(IOEntity.Flag_HasPower, false);
            counter.counterNumber = 0;
            counter.currentEnergy = 0;
            counter.SendNetworkUpdate();
        }

        private Elevator GetConnectedElevator(PowerCounter counter)
        {
            return counter.outputs[0].connectedTo.Get() as Elevator;
        }

        private bool IsEligibleToBeElevatorCounter(PowerCounter counter)
        {
            // Ignore parented counters such as the lift counter
            if (counter.HasParent())
                return false;

            if (HasConnectedInput(counter))
                return false;

            return true;
        }

        private bool HasConnectedInput(PowerCounter counter)
        {
            return counter.inputs[0].connectedTo.Get() != null;
        }

        private PowerCounter[] GetAllConnectedCounters(Elevator topElevator)
        {
            var counters = new List<PowerCounter>();
            var currentElevator = topElevator;

            do
            {
                GetConnectedCounters(currentElevator, out var counter1, out var counter2);
                if (counter1 != null)
                    counters.Add(counter1);

                if (counter2 != null)
                    counters.Add(counter2);
            }
            while ((currentElevator = currentElevator.GetElevatorInDirection(Elevator.Direction.Down)) != null);

            return counters.Count > 0 ? counters.ToArray() : null;
        }

        private void GetConnectedCounters(Elevator elevator, out PowerCounter counter1, out PowerCounter counter2)
        {
            counter1 = GetEligibleElevatorCounter(elevator.inputs[0].connectedTo.Get() as PowerCounter);
            counter2 = GetEligibleElevatorCounter(elevator.inputs[1].connectedTo.Get() as PowerCounter);
        }

        private PowerCounter GetEligibleElevatorCounter(PowerCounter counter)
        {
            if (counter == null)
                return null;

            // Ignore parented counters such as the lift counter
            if (counter.HasParent())
                return null;

            // Ignore counters that have a connected input
            if (counter.inputs[0].connectedTo.Get() != null)
                return null;

            return counter;
        }

        #endregion
    }
}


// --- End of file: ElevatorCounters.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosion-damage-reducer ---
// --- Original File Path: E/ExplosionDamageReducer/ExplosionDamageReducer.cs ---

﻿/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
                                                                     
 ########### CHANGES ###################################################

 1.0.0
    - Plugin release

 #######################################################################
*/

using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Explosion Damage Reducer", "paulsimik", "1.0.0")]
    [Description("Set damage value for Rockets, High Velocity Rockets and HE Grenades only to players")]
    class ExplosionDamageReducer : RustPlugin
    {
        #region [Oxide Hooks]

        private void OnEntityTakeDamage(BasePlayer victim, HitInfo info)
        {
            if (victim == null || victim.IsNpc || info.damageTypes == null || info.InitiatorPlayer == null)
                return;

            var shortName = info.WeaponPrefab?.ShortPrefabName;
            if (string.IsNullOrEmpty(shortName))
                return;

            if (victim == info.InitiatorPlayer && !config.attackerReduceDamage)
                return;

            float damage = 100;
            switch (shortName)
            {
                case "rocket_basic":
                    {
                        damage = config.rocket;
                        break;
                    }
                case "rocket_hv":
                    {
                        damage = config.hvRocket;
                        break;
                    }
                case "40mm_grenade_he":
                    {
                        damage = config.heGrenade;
                        break;
                    }
            }

            info.damageTypes.ScaleAll(0.01f * damage);
        }

        #endregion

        #region [Classes]

        private Configuration config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Apply reduced damage to the attacker")]
            public bool attackerReduceDamage;

            [JsonProperty(PropertyName = "Rocket")]
            public int rocket;

            [JsonProperty(PropertyName = "High Velocity Rocket")]
            public int hvRocket;

            [JsonProperty(PropertyName = "HE Grenade")]
            public int heGrenade;

            public VersionNumber version;
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                attackerReduceDamage = false,
                rocket = 100,
                hvRocket = 100,
                heGrenade = 100,
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config, true);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("######### Configuration file is not valid! #########");
                return;
            }

            SaveConfig();
        }

        #endregion
    }
}

// --- End of file: ExplosionDamageReducer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/exploding-oil-barrels ---
// --- Original File Path: E/ExplodingOilBarrels/ExplodingOilBarrels.cs ---

﻿using System.Collections.Generic;
using Rust;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Exploding Oil Barrel", "Bazz3l", "1.1.0")]
    [Description("Exploding oil barrels with explosion force, player damage and ground shake effect")]
    public class ExplodingOilBarrels : RustPlugin
    {
        #region Fields

        private const string EXPLOSION_EFFECT = "assets/bundled/prefabs/fx/explosions/explosion_03.prefab";
        private const string FIRE_EFFECT = "assets/bundled/prefabs/fx/gas_explosion_small.prefab";
        private const string SHAKE_EFFECT = "assets/content/weapons/_gestures/effects/eat_2hand_chewymeat.prefab";

        private readonly int _playerMask = LayerMask.GetMask("Player (Server)");

        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                PrintWarning("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Screen shake effect for explosion")]
            public bool EnableShakeScreen;

            [JsonProperty(PropertyName = "Moves items in range of explosion")]
            public bool EnableExplosionForce;

            [JsonProperty(PropertyName = "Deal damage to players in distance of explosion")]
            public bool EnablePlayerDamage;

            [JsonProperty(PropertyName = "ditance to deal damage to players")]
            public float PlayerDamageDistance;

            [JsonProperty(PropertyName = "amount of damage delt to players in range")]
            public float PlayerDamage;

            [JsonProperty(PropertyName = "distance shake will effect players from explosion")]
            public float ShakeDistance;

            [JsonProperty(PropertyName = "amount of force delt to object in range")]
            public float ExplosionForce;

            [JsonProperty(PropertyName = "distance to find object near explosion")]
            public float ExplosionItemDistance;

            [JsonProperty(PropertyName = "distance to find targets near explosion")]
            public float ExplosionRange;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    EnableShakeScreen = true,
                    EnableExplosionForce = true,
                    EnablePlayerDamage = true,
                    PlayerDamageDistance = 2f,
                    PlayerDamage = 10f,
                    ShakeDistance = 20f,
                    ExplosionItemDistance = 20f,
                    ExplosionRange = 50f,
                    ExplosionForce = 50f
                };
            }
        }

        #endregion

        #region Oxide

        private void OnEntityDeath(LootContainer entity, HitInfo info)
        {
            if (entity == null || info == null)
            {
                return;
            }
            
            if (!(entity.ShortPrefabName == "oil_barrel" && info.damageTypes.GetMajorityDamageType() == DamageType.Bullet))
            {
                return;
            }

            DoExplosion(entity.ServerPosition);
        }

        #endregion

        #region Core
        
        private void DoExplosion(Vector3 position)
        {
            PlayExplosion(position);
            PlayerInRange(position);
            
            if (!_config.EnableExplosionForce)
            {
                return;
            }
            
            MoveItems(position);
        }

        private void MoveItems(Vector3 position)
        {
            List<DroppedItem> items = Facepunch.Pool.GetList<DroppedItem>();

            Vis.Entities(position, _config.ExplosionItemDistance, items);

            foreach (DroppedItem item in items)
            {
                if (item == null || item.IsDestroyed || !item.IsVisible(position)) continue;

                item.GetComponent<Rigidbody>()
                    ?.AddExplosionForce(_config.ExplosionForce, position, _config.ExplosionItemDistance);
            }

            Facepunch.Pool.FreeList(ref items);
        }

        private void PlayerInRange(Vector3 position)
        {
            List<BasePlayer> targets = Facepunch.Pool.GetList<BasePlayer>();

            Vis.Entities(position, _config.ExplosionRange, targets, _playerMask, QueryTriggerInteraction.Ignore);

            foreach (BasePlayer player in targets)
            {
                if (_config.EnablePlayerDamage &&
                    InDistance(player.ServerPosition, position, _config.PlayerDamageDistance))
                {
                    DamagePlayer(player);
                }

                if (_config.EnableShakeScreen && 
                    InDistance(player.ServerPosition, position, _config.ShakeDistance))
                {
                    PlayerShake(player);
                }
            }

            Facepunch.Pool.FreeList(ref targets);
        }

        private void DamagePlayer(BasePlayer player)
            => player.Hurt(_config.PlayerDamage, DamageType.Explosion);

        private static bool InDistance(Vector3 target, Vector3 position, float distance)
            => Vector3Ex.Distance2D(target, position) <= distance;

        private static void PlayerShake(BasePlayer player)
            => Effect.server.Run(SHAKE_EFFECT, player.transform.position);

        private static void PlayExplosion(Vector3 position)
        {
            Effect.server.Run(EXPLOSION_EFFECT, position);
            Effect.server.Run(FIRE_EFFECT, position);
        }

        #endregion
    }
}

// --- End of file: ExplodingOilBarrels.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/external-wall-protect ---
// --- Original File Path: E/ExternalWallProtect/ExternalWallProtect.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Physics = UnityEngine.Physics;

namespace Oxide.Plugins
{
    [Info("External Wall Protect", "redBDGR", "1.0.3")]
    [Description("Prevents ladders from being able to be placed on external walls")]

    class ExternalWallProtect : RustPlugin
    {
        private const string permissionName = "externalwallprotect.exempt";
        private static LayerMask collLayers = LayerMask.GetMask("Construction", "Clutter", "Deployed", "Tree", "Terrain", "World", "Water", "Default");

        private void Init()
        {
            permission.RegisterPermission(permissionName, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["Deny Crusher"] = "You are not allowed to place a ladder there",
            }, this);
        }

        private object CanBuild(Planner plan, Construction prefab)
        {
            if (prefab.prefabID != 2150203378)
                return null;
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null)
                return null;
            if (permission.UserHasPermission(player.UserIDString, permissionName))
                return null;
            RaycastHit[] hits = Physics.RaycastAll(player.eyes.HeadRay(), 5f, collLayers);
            if (!hits.Where(hit => hit.GetEntity() != null).Any(hit => hit.GetEntity().ShortPrefabName.Contains("external")))
                return null;
            player.ChatMessage(msg("Deny Crusher", player.UserIDString));
            return false;
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: ExternalWallProtect.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/event-manager ---
// --- Original File Path: E/EventManager/EventManager.cs ---

﻿// Requires: EMInterface

using System;
using System.Collections.Generic;
using System.Collections;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Network;
using Facepunch;
using UI = Oxide.Plugins.EMInterface.UI;
using UI4 = Oxide.Plugins.EMInterface.UI4;

namespace Oxide.Plugins
{
    using EventManagerEx;    

    [Info("EventManager", "k1lly0u", "4.0.7")]
    [Description("The core mechanics for arena combat games")]
    public class EventManager : RustPlugin
    {
        #region Fields        
        private DynamicConfigFile restorationData, eventData;

        [PluginReference]
        private Plugin Economics, Kits, NoEscape, ServerRewards, Spawns, ZoneManager;


        private Timer _autoEventTimer;

        private RewardType rewardType;

        private int scrapItemId;

        private static Regex hexFilter;


        public Hash<string, IEventPlugin> EventModes { get; set; } = new Hash<string, IEventPlugin>();

        public EventData Events { get; private set; }

        private RestoreData Restore { get; set; }

        public static EventManager Instance { get; private set; }

        public static BaseEventGame BaseManager { get; internal set; }

        public static ConfigData Configuration { get; set; }

        public static EventResults LastEventResult { get; private set; }

        public static bool IsUnloading { get; private set; }


        internal const string ADMIN_PERMISSION = "eventmanager.admin";
        #endregion
        
        #region Oxide Hooks
        private void Loaded()
        {
            restorationData = Interface.Oxide.DataFileSystem.GetFile("EventManager/restoration_data");

            eventData = Interface.Oxide.DataFileSystem.GetFile("EventManager/event_data");

            permission.RegisterPermission(ADMIN_PERMISSION, this);

            Instance = this;
            IsUnloading = false;
            LastEventResult = new EventResults();

            LoadData();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {
            if (!CheckDependencies())
                return;            

            rewardType = ParseType<RewardType>(Configuration.Reward.Type);

            scrapItemId = ItemManager.FindItemDefinition("scrap")?.itemid ?? 0;

            hexFilter = new Regex("^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

            UnsubscribeAll();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            QueueAutoEvent();
        }

        private void Unload()
        {
            IsUnloading = true;

            SaveRestoreData();
            
            BaseEventPlayer[] eventPlayers = UnityEngine.Object.FindObjectsOfType<BaseEventPlayer>();
            for (int i = 0; i < eventPlayers?.Length; i++)            
                UnityEngine.Object.DestroyImmediate(eventPlayers[i]);
            
            if (BaseManager != null)
                UnityEngine.Object.DestroyImmediate(BaseManager.gameObject);

            hexFilter = null;

            LastEventResult = null;
            BaseManager = null;
            Configuration = null;
            Instance = null;            
        }

        private void OnServerSave() => SaveRestoreData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            UnlockInventory(player);
            
            if (Restore.HasRestoreData(player.userID))
                Restore.RestorePlayer(player);
        }
       
        private void OnPlayerDisconnected(BasePlayer player)
        {
            BaseEventPlayer eventPlayer = GetUser(player);
            if (eventPlayer != null)
            {
                if (BaseManager != null)
                    BaseManager.LeaveEvent(player);
                else UnityEngine.Object.DestroyImmediate(eventPlayer);

                if (player.IsAlive())
                    player.DieInstantly();
            }
        }

        private void OnEntityTakeDamage(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            BasePlayer player = entity.ToPlayer();

            if (player != null)
            {
                BaseEventPlayer eventPlayer = GetUser(player);
                if (eventPlayer != null)
                {
                    if (BaseManager == null)
                        return;
                    
                    BaseManager.OnPlayerTakeDamage(eventPlayer, hitInfo);
                }
            }
            else
            {
                BaseEventPlayer attacker = GetUser(hitInfo.InitiatorPlayer);
                if (attacker != null)
                {
                    if (BaseManager != null)
                    {
                        if (BaseManager.CanDealEntityDamage(attacker, entity, hitInfo))
                            return;
                    }
                    ClearDamage(hitInfo);
                }
            }
        }

        private object CanBeWounded(BasePlayer player, HitInfo hitInfo)
        {
            BaseEventPlayer eventPlayer = GetUser(player);
            if (eventPlayer != null && BaseManager != null)
                return false;
            return null;
        }

        private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player != null)
            {
                BaseEventPlayer eventPlayer = GetUser(player);
                if (eventPlayer != null && BaseManager != null)
                { 
                    if (!eventPlayer.IsDead)
                        BaseManager.PrePlayerDeath(eventPlayer, hitInfo);
                    return false;                    
                }
            }
            return null;
        }


        private object CanSpectateTarget(BasePlayer player, string name)
        {
            BaseEventPlayer eventPlayer = player.GetComponent<BaseEventPlayer>();
            if (eventPlayer != null && eventPlayer.Player.IsSpectating())
            {
                eventPlayer.UpdateSpectateTarget();
                return false;
            }
            return null;
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BasePlayer player = planner?.GetOwnerPlayer();
            if (player == null)
                return;

            BaseCombatEntity baseCombatEntity = gameObject?.ToBaseEntity() as BaseCombatEntity;
            if (baseCombatEntity == null)
                return;

            BaseEventPlayer eventPlayer = GetUser(player);
            if (eventPlayer != null && BaseManager != null)
                BaseManager.OnEntityDeployed(baseCombatEntity);
        }

        private void OnItemDeployed(Deployer deployer, BaseCombatEntity baseCombatEntity)
        {
            BasePlayer player = deployer.GetOwnerPlayer();
            if (player == null)
                return;

            BaseEventPlayer eventPlayer = GetUser(player);
            if (eventPlayer != null && BaseManager != null)
                BaseManager.OnEntityDeployed(baseCombatEntity);
        }

        private object OnCreateWorldProjectile(HitInfo hitInfo, Item item)
        {
            if (hitInfo == null)
                return null;

            if (hitInfo.InitiatorPlayer != null)
            {
                BaseEventPlayer eventPlayer = GetUser(hitInfo.InitiatorPlayer);
                if (eventPlayer != null)
                    return false;
            }

            if (hitInfo.HitEntity?.ToPlayer() != null)
            {
                BaseEventPlayer eventPlayer = GetUser(hitInfo.HitEntity.ToPlayer());
                if (eventPlayer != null)
                    return false;
            }

            return null;
        }

        private object CanDropActiveItem(BasePlayer player)
        {
            BaseEventPlayer eventPlayer = GetUser(player);
            if (eventPlayer != null)                           
                return false;            
            return null;
        }

        private object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            BaseEventPlayer eventPlayer = GetUser(player);

            if (player == null || player.IsAdmin || eventPlayer == null)
                return null;

            if (Configuration.Event.CommandBlacklist.Any(x => x.StartsWith("/") ? x.Substring(1).ToLower() == command : x.ToLower() == command))
            {
                SendReply(player, Message("Error.CommandBlacklisted", player.userID));
                return false;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            BaseEventPlayer eventPlayer = GetUser(player);

            if (player == null || player.IsAdmin || eventPlayer == null || arg.Args == null)
                return null;

            if (Configuration.Event.CommandBlacklist.Any(x => arg.cmd.FullName.Equals(x, StringComparison.OrdinalIgnoreCase)))
            {
                SendReply(player, Message("Error.CommandBlacklisted", player.userID));
                return false;
            }
            return null;
        }
        #endregion

        #region AutoEvents
        private int _nextEventIndex = -1;

        private void QueueAutoEvent()
        {
            if (!Configuration.AutoEvents.Enabled || Configuration.AutoEvents.Events.Length == 0)
                return;

            _autoEventTimer?.Destroy();

            _autoEventTimer = timer.In(Configuration.AutoEvents.Interval, InitializeAutoEvent);
        }

        private void InitializeAutoEvent()
        {            
            string eventName;
            if (Configuration.AutoEvents.Randomize)
                eventName = Configuration.AutoEvents.Events.GetRandom();
            else
            {
                _nextEventIndex += 1;

                if (_nextEventIndex >= Configuration.AutoEvents.Events.Length)
                    _nextEventIndex = 0;

                eventName = Configuration.AutoEvents.Events[_nextEventIndex];
            }

            object success = OpenEvent(eventName);
            if (success != null)
                QueueAutoEvent();
        }
        #endregion

        #region Event Construction
        public static void RegisterEvent(string eventName, IEventPlugin plugin) => Instance.EventModes[eventName] = plugin;

        public static void UnregisterEvent(string eventName) => Instance.EventModes.Remove(eventName);

        public object OpenEvent(string eventName)
        {
            if (Events.events.TryGetValue(eventName, out EventConfig eventConfig))
            {
                if (!EventModes.TryGetValue(eventConfig.EventType, out IEventPlugin plugin))                
                    return $"Unable to find event plugin for game mode: {eventConfig.EventType}";
                
                if (plugin == null)                
                    return $"Unable to initialize event plugin: {eventConfig.EventType}. Plugin is either unloaded or the class does not derive from IEventGame";

                object success = ValidateEventConfig(eventConfig);
                if (success is string)
                    return $"Failed to open event : {(string)success}";

                if (!plugin.InitializeEvent(eventConfig))
                    return $"There was a error initializing the event : {eventConfig.EventType}";

                _autoEventTimer?.Destroy();

                return null;
            }
            else return "Failed to find a event with the specified name";
        }

        public static bool InitializeEvent<T>(IEventPlugin plugin, EventConfig config) where T : BaseEventGame
        {
            if (BaseManager != null)
                return false;

            BaseManager = new GameObject(config.EventName).AddComponent<T>();
            BaseManager.InitializeEvent(plugin, config);           

            return true;
        }
        #endregion

        #region Functions
        public IEventPlugin GetPlugin(string name)
        {
            if (EventModes.TryGetValue(name, out IEventPlugin eventPlugin))
                return eventPlugin;

            return null;
        }

        private bool CheckDependencies()
        {
            if (!Spawns)
            {
                PrintError("Unable to load EventManager - Spawns database not found. Please download Spawns database to continue");
                rust.RunServerCommand("oxide.unload", "EventManager");
                return false;
            }

            if (!ZoneManager)            
                PrintError("ZoneManager is not installed! Unable to restrict event players to zones");
               
            if (!Kits)
                PrintError("Kits is not installed! Unable to issue any weapon kits");

            return true;
        }

        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(CanBeWounded));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(OnEntityBuilt));
            Unsubscribe(nameof(OnItemDeployed));
            Unsubscribe(nameof(OnCreateWorldProjectile));
            Unsubscribe(nameof(CanDropActiveItem));
            Unsubscribe(nameof(OnPlayerCommand));
            Unsubscribe(nameof(OnServerCommand));
        }

        private void SubscribeAll()
        {
            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(CanBeWounded));
            Subscribe(nameof(OnPlayerDeath));
            Subscribe(nameof(OnEntityBuilt));
            Subscribe(nameof(OnItemDeployed));
            Subscribe(nameof(OnCreateWorldProjectile));
            Subscribe(nameof(CanDropActiveItem));
            Subscribe(nameof(OnPlayerCommand));
            Subscribe(nameof(OnServerCommand));
        }

        private static void Broadcast(string key, params object[] args)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player != null && player.IsConnected)
                    player.SendConsoleCommand("chat.add", 0, Configuration.Message.ChatIcon, string.Format(Message(key, player.userID), args));
            }
        }

        internal static bool IsValidHex(string s) => hexFilter.IsMatch(s);
        #endregion

        #region Classes and Components  
        public class BaseEventGame : MonoBehaviour
        {
            internal IEventPlugin Plugin { get; private set; }

            internal EventConfig Config { get; private set; }

            public EventStatus Status { get; protected set; }

            protected GameTimer Timer { get; set; }


            internal SpawnSelector _spawnSelectorA;

            internal SpawnSelector _spawnSelectorB;

            protected CuiElementContainer scoreContainer = null;

            internal List<BasePlayer> joiningPlayers = Pool.Get<List<BasePlayer>>();

            internal List<BaseEventPlayer> eventPlayers = Pool.Get<List<BaseEventPlayer>>();

            internal List<ScoreEntry> scoreData = Pool.Get<List<ScoreEntry>>();

            private List<BaseCombatEntity> _deployedObjects = Pool.Get<List<BaseCombatEntity>>();
                        
            private bool _isClosed = false;

            private double _startsAtTime;


            internal string TeamAColor { get; set; }

            internal string TeamBColor { get; set; }

            internal string TeamAClothing { get; set; }

            internal string TeamBClothing { get; set; }

            public bool GodmodeEnabled { get; protected set; } = true;

            internal string EventInformation
            {
                get
                {
                    string str = string.Format(Message("Info.Event.Current"), Config.EventName, Config.EventType);
                    str += string.Format(Message("Info.Event.Player"), eventPlayers.Count, Config.MaximumPlayers);
                    return str;
                }
            }

            internal string EventStatus => string.Format(Message("Info.Event.Status"), Status);
            
            #region Initialization and Destruction 
            /// <summary>
            /// Called when the event GameObject is destroyed
            /// </summary>
            protected virtual void OnDestroy()
            {
                CleanupEntities();

                for (int i = eventPlayers.Count - 1; i >= 0; i--)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];

                    if (eventPlayer.IsDead)
                        ResetPlayer(eventPlayer.Player);

                    LeaveEvent(eventPlayer);
                }
                
                Pool.FreeUnmanaged(ref scoreData);
                Pool.FreeUnmanaged(ref joiningPlayers);
                Pool.FreeUnmanaged(ref _deployedObjects);
                Pool.FreeUnmanaged(ref eventPlayers);

                _spawnSelectorA?.Destroy();
                _spawnSelectorB?.Destroy();

                Timer?.StopTimer();

                Instance?.UnsubscribeAll();

                Instance?.QueueAutoEvent();

                Destroy(gameObject);
            }

            /// <summary>
            /// The first function called when an event is being opened
            /// </summary>
            /// <param name="plugin">The plugin the event game belongs to</param>
            /// <param name="config">The event config</param>
            internal virtual void InitializeEvent(IEventPlugin plugin, EventConfig config)
            {
                this.Plugin = plugin;
                this.Config = config;

                _spawnSelectorA = new SpawnSelector(config.EventName, config.TeamConfigA.Spawnfile);

                if (plugin.IsTeamEvent)
                {                    
                    TeamAColor = config.TeamConfigA.Color;
                    TeamBColor = config.TeamConfigB.Color;

                    if (string.IsNullOrEmpty(TeamAColor) || TeamAColor.Length < 6 || TeamAColor.Length > 6 || !hexFilter.IsMatch(TeamAColor))
                        TeamAColor = "#EA3232";
                    else TeamAColor = "#" + TeamAColor;

                    if (string.IsNullOrEmpty(TeamBColor) || TeamBColor.Length < 6 || TeamBColor.Length > 6 || !hexFilter.IsMatch(TeamBColor))
                        TeamBColor = "#3232EA";
                    else TeamBColor = "#" + TeamBColor;

                    _spawnSelectorB = new SpawnSelector(config.EventName, config.TeamConfigB.Spawnfile);
                }

                Timer = new GameTimer(this);

                GodmodeEnabled = true;

                OpenEvent();
            }
            #endregion

            #region Event Management 
            /// <summary>
            /// Opens the event for players to join
            /// </summary>
            internal virtual void OpenEvent()
            {
                _isClosed = false;
                Status = EventManager.EventStatus.Open;

                if (Configuration.Message.Announce)
                {
                    _startsAtTime = Time.time + Configuration.Timer.Start;

                    InvokeHandler.InvokeRepeating(this, BroadcastOpenEvent, 0f, Configuration.Message.AnnounceInterval);
                }

                InvokeHandler.Invoke(this, PrestartEvent, Configuration.Timer.Start);
            }

            /// <summary>
            /// Closes the event and prevent's more players from joining
            /// </summary>
            internal virtual void CloseEvent()
            {
                _isClosed = true;
                Broadcast("Notification.EventClosed");

                InvokeHandler.CancelInvoke(this, BroadcastOpenEvent);
            }

            /// <summary>
            /// The event prestart where players are created and sent to the arena
            /// </summary>
            internal virtual void PrestartEvent()
            {
                if (!HasMinimumRequiredPlayers())
                {
                    Broadcast("Notification.NotEnoughToStart");
                    EndEvent();
                    return;
                }

                InvokeHandler.CancelInvoke(this, BroadcastOpenEvent);

                Instance.SubscribeAll();

                Status = EventManager.EventStatus.Prestarting;

                StartCoroutine(CreateEventPlayers());                
            }
            
            /// <summary>
            /// Start's the event
            /// </summary>
            protected virtual void StartEvent()
            {
                InvokeHandler.CancelInvoke(this, PrestartEvent);

                if (!HasMinimumRequiredPlayers())
                {
                    Broadcast("Notification.NotEnoughToStart");
                    EndEvent();
                    return;
                }

                Timer.StopTimer();

                Status = EventManager.EventStatus.Started;

                if (Config.TimeLimit > 0)
                    Timer.StartTimer(Config.TimeLimit, string.Empty, EndEvent);

                GodmodeEnabled = false;

                eventPlayers.ForEach((BaseEventPlayer eventPlayer) =>
                {
                    if (eventPlayer?.Player == null)
                        return;

                    if (eventPlayer.IsDead)
                        RespawnPlayer(eventPlayer);
                    else
                    {
                        ResetPlayer(eventPlayer.Player);
                        OnPlayerRespawn(eventPlayer);
                    }
                });
            }

            /// <summary>
            /// End's the event and restore's all player's back to the state they were in prior to the event starting
            /// </summary>
            internal virtual void EndEvent()
            {
                InvokeHandler.CancelInvoke(this, BroadcastOpenEvent);

                InvokeHandler.CancelInvoke(this, PrestartEvent);

                Timer.StopTimer();

                Status = EventManager.EventStatus.Finished;

                GodmodeEnabled = true;

                LastEventResult.UpdateFromEvent(this);

                ProcessWinners();

                eventPlayers.ForEach((BaseEventPlayer eventPlayer) =>
                {
                    if (eventPlayer?.Player == null)
                        return;

                    if (eventPlayer.IsDead)  
                        ResetPlayer(eventPlayer.Player);
                    
                    EventStatistics.Data.OnGamePlayed(eventPlayer.Player, Config.EventType);
                });

                EventStatistics.Data.OnGamePlayed(Config.EventType);

                EjectAllPlayers();

                DestroyImmediate(this);
            }
            #endregion

            #region Player Management
            internal bool IsOpen()
            {
                if (_isClosed || Status == EventManager.EventStatus.Finished)
                    return false;

                if (((int)Status < 2 && joiningPlayers.Count >= Config.MaximumPlayers) || eventPlayers.Count >= Config.MaximumPlayers)
                    return false;

                if (!string.IsNullOrEmpty(CanJoinEvent()))
                    return false;

                return true;
            }

            internal bool CanJoinEvent(BasePlayer player)
            {
                if (_isClosed)
                {
                    player.ChatMessage(Message("Notification.EventClosed", player.userID));
                    return false;
                }

                if (Status == EventManager.EventStatus.Finished)
                {
                    player.ChatMessage(Message("Notification.EventFinished", player.userID));
                    return false;
                }

                if (((int)Status < 2 && joiningPlayers.Count >= Config.MaximumPlayers) || eventPlayers.Count >= Config.MaximumPlayers)
                {
                    player.ChatMessage(Message("Notification.MaximumPlayers", player.userID));
                    return false;
                }

                string str = CanJoinEvent();

                if (!string.IsNullOrEmpty(str))
                {
                    player.ChatMessage(str);
                    return false;
                }

                return true;
            }

            /// <summary>
            /// Allow or disallow players to join the event
            /// </summary>
            /// <returns>Supply a (string) reason to disallow, or a empty string to allow</returns>
            protected virtual string CanJoinEvent()
            {
                return string.Empty;
            }

            /// <summary>
            /// Override to perform additional logic when a player joins an event
            /// </summary>
            /// <param name="player">The BasePlayer object of the player joining the event</param>
            /// <param name="team">The team the player should be placed in</param>
            internal virtual void JoinEvent(BasePlayer player, Team team = Team.None)
            {
                if (Status == EventManager.EventStatus.Started)
                    CreateEventPlayer(player, team);
                else joiningPlayers.Add(player);

                if (Configuration.Message.BroadcastJoiners)
                    Broadcast("Notification.PlayerJoined", player.displayName, Config.EventName);                
            }

            /// <summary>
            /// Override to perform additional logic when a player leaves an event. This is called when the player uses the leave chat command prior to destroying the BaseEventPlayer
            /// </summary>
            /// <param name="player">The BasePlayer object of the player leaving the event</param>
            internal virtual void LeaveEvent(BasePlayer player)
            {
                if (joiningPlayers.Contains(player))
                {
                    joiningPlayers.Remove(player);

                    if (Configuration.Message.BroadcastLeavers)
                        Broadcast("Notification.PlayerLeft", player.displayName, Config.EventName);

                    return;
                }

                BaseEventPlayer eventPlayer = GetUser(player);
                if (eventPlayer == null)
                    return;

                LeaveEvent(eventPlayer);
            }

            /// <summary>
            /// Override to perform additional logic when a event player leaves an event
            /// </summary>
            /// <param name="eventPlayer">The BaseEventPlayer object of the player leaving the event</param>
            internal virtual void LeaveEvent(BaseEventPlayer eventPlayer)
            {
                BasePlayer player = eventPlayer.Player;

                if (!string.IsNullOrEmpty(Config.ZoneID))
                    Instance.ZoneManager?.Call("RemovePlayerFromZoneWhitelist", Config.ZoneID, player);

                eventPlayers.Remove(eventPlayer);

                DestroyImmediate(eventPlayer);

                if (!player.IsConnected || player.IsSleeping() || IsUnloading)
                    player.Die();
                else Instance.Restore.RestorePlayer(player);                

                if (Status != EventManager.EventStatus.Finished && !HasMinimumRequiredPlayers())
                {
                    BroadcastToPlayers("Notification.NotEnoughToContinue");
                    EndEvent();
                }
            }

            private IEnumerator CreateEventPlayers()
            {
                for (int i = joiningPlayers.Count - 1; i >= 0; i--)
                {
                    BasePlayer joiner = joiningPlayers[i];

                    EMInterface.DestroyAllUI(joiner);

                    CreateEventPlayer(joiner, GetPlayerTeam(joiner));

                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;
                }

                UpdateScoreboard();

                Timer.StartTimer(Configuration.Timer.Prestart, Message("Notification.RoundStartsIn"), StartEvent);
            }

            /// <summary>
            /// Override to perform additional logic when initializing the BaseEventPlayer component
            /// </summary>
            /// <param name="player">The BasePlayer object of the player joining the event</param>
            /// <param name="team">The team this player is on</param>
            protected virtual void CreateEventPlayer(BasePlayer player, Team team = Team.None)
            {
                if (player == null)
                    return;

                joiningPlayers.Remove(player);

                BaseEventPlayer eventPlayer = AddPlayerComponent(player);

                eventPlayer.ResetPlayer();

                eventPlayer.Event = this;

                eventPlayer.Team = team;

                eventPlayers.Add(eventPlayer);

                if (!Config.AllowClassSelection || GetAvailableKits(eventPlayer.Team).Count <= 1)
                    eventPlayer.Kit = GetAvailableKits(team).First();

                SpawnPlayer(eventPlayer, Status == EventManager.EventStatus.Started, true);

                if (!string.IsNullOrEmpty(Config.ZoneID))                
                    Instance.ZoneManager?.Call("AddPlayerToZoneWhitelist", Config.ZoneID, player);                
            }

            /// <summary>
            /// Override to assign players to teams
            /// </summary>
            /// <param name="player"></param>
            /// <returns>The team the player will be assigned to</returns>
            protected virtual Team GetPlayerTeam(BasePlayer player) => Team.None;

            /// <summary>
            /// Add's the BaseEventPlayer component to the player. Override with your own component if you want to extend the BaseEventPlayer class
            /// </summary>
            /// <param name="player"></param>
            /// <param name="team"></param>
            /// <returns>The BaseEventPlayer component</returns>
            protected virtual BaseEventPlayer AddPlayerComponent(BasePlayer player) => player.gameObject.GetComponent<BaseEventPlayer>() ?? player.gameObject.AddComponent<BaseEventPlayer>();                
            
            /// <summary>
            /// Called prior to a event player respawning
            /// </summary>
            /// <param name="baseEventPlayer"></param>
            internal virtual void OnPlayerRespawn(BaseEventPlayer baseEventPlayer)
            {
                SpawnPlayer(baseEventPlayer, Status == EventManager.EventStatus.Started);
            }

            /// <summary>
            /// Spawn's the specified player
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <param name="giveKit">Should this player recieve a kit?</param>
            /// <param name="sleep">Should this player be put to sleep before teleporting?</param>
            internal void SpawnPlayer(BaseEventPlayer eventPlayer, bool giveKit = true, bool sleep = false)
            {
                BasePlayer player = eventPlayer?.Player;
                if (player == null)
                    return;

                eventPlayer.Player.GetMounted()?.AttemptDismount(eventPlayer.Player);

                if (eventPlayer.Player.HasParent())
                    eventPlayer.Player.SetParent(null, true);

                StripInventory(player);

                ResetMetabolism(player);

                MovePosition(player, eventPlayer.Team == Team.B ? _spawnSelectorB.GetSpawnPoint() : _spawnSelectorA.GetSpawnPoint(), sleep);

                if (string.IsNullOrEmpty(eventPlayer.Kit))
                {
                    eventPlayer.ForceSelectClass();
                    EMInterface.DisplayDeathScreen(eventPlayer, Message("UI.SelectClass", eventPlayer.Player.userID), true);
                    return;
                }
                
                UpdateScoreboard(eventPlayer);

                if (giveKit)
                {
                    Instance.NextTick(() =>
                    {
                        if (!CanGiveKit(eventPlayer))
                            return;

                        GiveKit(player, eventPlayer.Kit);

                        OnKitGiven(eventPlayer);                        
                    });
                }

                eventPlayer.ApplyInvincibility();

                OnPlayerSpawned(eventPlayer);
            }

            /// <summary>
            /// Called after a player has spawned/respawned
            /// </summary>
            /// <param name="eventPlayer">The player that has spawned</param>
            protected virtual void OnPlayerSpawned(BaseEventPlayer eventPlayer) { }

            /// <summary>
            /// Kicks all players out of the event
            /// </summary>
            protected void EjectAllPlayers()
            {
                for (int i = eventPlayers.Count - 1; i >= 0; i--)
                    LeaveEvent(eventPlayers[i].Player);
                eventPlayers.Clear();
            }

            /// <summary>
            /// Reset's all players that are currently dead and respawn's them
            /// </summary>
            protected void RespawnAllPlayers()
            {
                for (int i = eventPlayers.Count - 1; i >= 0; i--)
                    RespawnPlayer(eventPlayers[i]);                
            }

            private bool HasMinimumRequiredPlayers()
            {
                if (Status == EventManager.EventStatus.Open)
                    return joiningPlayers.Count >= Config.MinimumPlayers;
                else return eventPlayers.Count >= Config.MinimumPlayers;
            }
            #endregion

            #region Damage and Death
            /// <summary>
            /// Called when a player deals damage to a entity that is not another event player
            /// </summary>
            /// <param name="attacker">The player dealing the damage</param>
            /// <param name="entity">The entity that was hit</param>
            /// <param name="hitInfo">The HitInfo</param>
            /// <returns>True allows damage, false prevents damage</returns>
            internal virtual bool CanDealEntityDamage(BaseEventPlayer attacker, BaseEntity entity, HitInfo hitInfo)
            {
                return false;
            }

            /// <summary>
            /// Scale's player-to-player damage
            /// </summary>
            /// <param name="eventPlayer">The player that is attacking</param>
            /// <returns>1.0f is normal damage</returns>
            protected virtual float GetDamageModifier(BaseEventPlayer eventPlayer) => 1f;

            /// <summary>
            /// Calculates and applies damage to the player
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <param name="hitInfo"></param>
            internal virtual void OnPlayerTakeDamage(BaseEventPlayer eventPlayer, HitInfo hitInfo)
            {
                BaseEventPlayer attacker = GetUser(hitInfo.InitiatorPlayer);

                if (GodmodeEnabled || eventPlayer.IsDead || eventPlayer.IsInvincible)
                {
                    ClearDamage(hitInfo);
                    return;
                }
                
                float damageModifier = GetDamageModifier(attacker);
                if (damageModifier != 1f)
                    hitInfo.damageTypes.ScaleAll(damageModifier);

                eventPlayer.OnTakeDamage(attacker?.Player.userID ?? 0U);
            }

            /// <summary>
            /// Called prior to event player death logic. Prepares the player for the death cycle by hiding them from other players
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <param name="hitInfo"></param>
            internal virtual void PrePlayerDeath(BaseEventPlayer eventPlayer, HitInfo hitInfo)
            {
                if (CanDropBackpack())
                    eventPlayer.DropInventory();

                if (eventPlayer.Player.isMounted)
                {
                    BaseMountable baseMountable = eventPlayer.Player.GetMounted();
                    if (baseMountable != null)
                    {
                        baseMountable.DismountPlayer(eventPlayer.Player);
                        eventPlayer.Player.EnsureDismounted();
                    }
                }

                eventPlayer.IsDead = true;

                UpdateDeadSpectateTargets(eventPlayer);

                eventPlayer.Player.limitNetworking = true;

                eventPlayer.Player.DisablePlayerCollider();

                eventPlayer.Player.RemoveFromTriggers();

                eventPlayer.RemoveFromNetwork();                

                OnEventPlayerDeath(eventPlayer, GetUser(hitInfo?.InitiatorPlayer), hitInfo);

                ClearDamage(hitInfo);
            }

            internal virtual void OnEventPlayerDeath(BaseEventPlayer victim, BaseEventPlayer attacker = null, HitInfo hitInfo = null)
            {
                if (victim == null || victim.Player == null)
                    return;

                StripInventory(victim.Player);

                if (Configuration.Message.BroadcastKills)
                    DisplayKillToChat(victim, attacker?.Player != null ? attacker.Player.displayName : string.Empty);
            }

            /// <summary>
            /// Display's the death message in chat
            /// </summary>
            /// <param name="victim"></param>
            /// <param name="attackerName"></param>
            protected virtual void DisplayKillToChat(BaseEventPlayer victim, string attackerName)
            {
                if (string.IsNullOrEmpty(attackerName))
                {
                    if (victim.IsOutOfBounds)
                        BroadcastToPlayers("Notification.Death.OOB", victim.Player.displayName);
                    else BroadcastToPlayers("Notification.Death.Suicide", victim.Player.displayName);
                }
                else BroadcastToPlayers("Notification.Death.Killed", victim.Player.displayName, attackerName);                
            }
            #endregion

            #region Winners
            /// <summary>
            /// Applies winner statistics, give's rewards and print's winner information to chat
            /// </summary>
            protected void ProcessWinners()
            {
                List<BaseEventPlayer> winners = Pool.Get<List<BaseEventPlayer>>();
                GetWinningPlayers(ref winners);

                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (eventPlayer == null)
                        continue;

                    if (winners.Contains(eventPlayer))
                    {
                        EventStatistics.Data.AddStatistic(eventPlayer.Player, "Wins");
                        Instance.GiveReward(eventPlayer, Configuration.Reward.WinAmount);
                    }
                    else EventStatistics.Data.AddStatistic(eventPlayer.Player, "Losses");

                    EventStatistics.Data.AddStatistic(eventPlayer.Player, "Played");
                }

                if (Configuration.Message.BroadcastWinners && winners.Count > 0)
                {
                    if (Plugin.IsTeamEvent)
                    {
                        Team team = winners[0].Team;
                        Broadcast("Notification.EventWin.Multiple.Team", team == Team.B ? TeamBColor : TeamAColor, team, winners.Select(x => x.Player.displayName).ToSentence());
                    }
                    else
                    {
                        if (winners.Count > 1)
                            Broadcast("Notification.EventWin.Multiple", winners.Select(x => x.Player.displayName).ToSentence());
                        else Broadcast("Notification.EventWin", winners[0].Player.displayName);
                    }
                }

                Pool.FreeUnmanaged(ref winners);
            }

            /// <summary>
            /// Override to calculate the winning player(s). This should done done on a per event basis
            /// </summary>
            /// <param name="list"></param>
            protected virtual void GetWinningPlayers(ref List<BaseEventPlayer> list) { }
            #endregion

            #region Kits and Items
            /// <summary>
            /// Drop's the players belt and main containers in to a bag on death
            /// </summary>
            /// <returns>Return false to disable this feature</returns>
            protected virtual bool CanDropBackpack() => true;

            /// <summary>
            /// Override to prevent players being given kits
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <returns></returns>
            protected virtual bool CanGiveKit(BaseEventPlayer eventPlayer) => true;

            /// <summary>
            /// Called after a player has been given a kit. If the event is team based and team attire kits have been set team attire will be given
            /// </summary>
            /// <param name="eventPlayer"></param>
            protected virtual void OnKitGiven(BaseEventPlayer eventPlayer)
            {
                if (Plugin.IsTeamEvent)
                {
                    string kit = eventPlayer.Team == Team.B ? Config.TeamConfigB.Clothing : Config.TeamConfigA.Clothing;
                    if (!string.IsNullOrEmpty(kit))
                    {
                        List<Item> items = eventPlayer.Player.inventory.containerWear.itemList;
                        for (int i = 0; i < items.Count; i++)
                        {
                            Item item = items[i];
                            item.RemoveFromContainer();
                            item.Remove();
                        }

                        GiveKit(eventPlayer.Player, kit);
                    }
                }
            }

            /// <summary>
            /// Get's the list of Kits available for the specified team
            /// </summary>
            /// <param name="team"></param>
            /// <returns></returns>
            internal List<string> GetAvailableKits(Team team) => team == Team.B ? Config.TeamConfigB.Kits : Config.TeamConfigA.Kits;
            #endregion

            #region Overrides
            /// <summary>
            /// Allows you to display additional event details in the event menu. The key should be a localized message for the target player
            /// </summary>
            /// <param name="list"></param>
            /// <param name="playerId">The user's ID for localization purposes</param>
            internal virtual void GetAdditionalEventDetails(ref List<KeyValuePair<string, object>> list, ulong playerId) { }
            #endregion

            #region Spectating
            /// <summary>
            /// Fill's a list with valid spectate targets
            /// </summary>
            /// <param name="list"></param>
            internal virtual void GetSpectateTargets(ref List<BaseEventPlayer> list)
            {
                list.Clear();
                list.AddRange(eventPlayers);
            }

            /// <summary>
            /// Checks all spectating event players and updates their spectate target if the target has just died
            /// </summary>
            /// <param name="victim"></param>
            private void UpdateDeadSpectateTargets(BaseEventPlayer victim)
            {
                List<BaseEventPlayer> list = Pool.Get<List<BaseEventPlayer>>();
                GetSpectateTargets(ref list);

                bool hasValidSpectateTargets = list.Count > 0;

                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];

                    if (eventPlayer.Player.IsSpectating() && eventPlayer.SpectateTarget == victim)
                    {
                        if (hasValidSpectateTargets)
                            eventPlayer.UpdateSpectateTarget();
                        else eventPlayer.FinishSpectating();
                    }
                }
            }
            #endregion

            #region Player Counts
            /// <summ