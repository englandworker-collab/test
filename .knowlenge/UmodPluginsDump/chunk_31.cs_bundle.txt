ary>
            /// Count the amount of player's that are alive
            /// </summary>
            /// <returns></returns>
            internal int GetAlivePlayerCount()
            {
                int count = 0;
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    if (!eventPlayers[i]?.IsDead ?? false)
                        count++;
                }
                return count;
            }

            /// <summary>
            /// Count the amount of player's on the specified team
            /// </summary>
            /// <param name="team"></param>
            /// <returns></returns>
            internal int GetTeamCount(Team team)
            {
                int count = 0;
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    if (eventPlayers[i]?.Team == team)
                        count++;
                }
                return count;
            }

            /// <summary>
            /// Count the amount of player's that are alive on the specified team
            /// </summary>
            /// <param name="team"></param>
            /// <returns></returns>
            internal int GetTeamAliveCount(Team team)
            {
                int count = 0;
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (eventPlayer != null && eventPlayer.Team == team && !eventPlayer.IsDead)
                        count++;
                }
                return count;               
            }
            #endregion

            #region Teams
            /// <summary>
            /// Get the score for the specified team
            /// </summary>
            /// <param name="team"></param>
            /// <returns></returns>
            internal virtual int GetTeamScore(Team team) => 0;

            /// <summary>
            /// Balance the team's if one team has > 2 more player's on it
            /// </summary>
            protected void BalanceTeams()
            {
                int aCount = GetTeamCount(Team.A);
                int bCount = GetTeamCount(Team.B);

                int difference = aCount > bCount + 1 ? aCount - bCount : bCount > aCount + 1 ? bCount - aCount : 0;
                Team moveFrom = aCount > bCount + 1 ? Team.A : bCount > aCount + 1 ? Team.B : Team.None;

                if (difference > 1 && moveFrom != Team.None)
                {
                    BroadcastToPlayers("Notification.Teams.Unbalanced");

                    List<BaseEventPlayer> teamPlayers = Pool.Get<List<BaseEventPlayer>>();

                    eventPlayers.ForEach(x =>
                    {
                        if (x.Team == moveFrom)
                            teamPlayers.Add(x);
                    });

                    for (int i = 0; i < (int)Math.Floor((float)difference / 2); i++)
                    {
                        BaseEventPlayer eventPlayer = teamPlayers.GetRandom();
                        teamPlayers.Remove(eventPlayer);

                        eventPlayer.Team = moveFrom == Team.A ? Team.B : Team.A;
                        BroadcastToPlayer(eventPlayer, string.Format(Message("Notification.Teams.TeamChanged", eventPlayer.Player.userID), eventPlayer.Team));
                    }

                    Pool.FreeUnmanaged(ref teamPlayers);
                }
            }
            #endregion

            #region Entity Management
            /// <summary>
            /// Keep's track of entities deployed by event players
            /// </summary>
            /// <param name="entity"></param>
            internal void OnEntityDeployed(BaseCombatEntity entity) => _deployedObjects.Add(entity);
            
            /// <summary>
            /// Destroy's any entities deployed by event players
            /// </summary>
            private void CleanupEntities()
            {
                for (int i = _deployedObjects.Count - 1; i >= 0; i--)
                {
                    BaseCombatEntity entity = _deployedObjects[i];
                    if (entity != null && !entity.IsDestroyed)
                        entity.DieInstantly();
                }

                _deployedObjects.Clear();
            }
            #endregion

            #region Scoreboard    
            /// <summary>
            /// Rebuild and send the scoreboard to players
            /// </summary>
            internal void UpdateScoreboard()
            {
                UpdateScores();
                BuildScoreboard();

                if (scoreContainer != null)
                {
                    eventPlayers.ForEach((BaseEventPlayer eventPlayer) =>
                    {
                        if (!eventPlayer.IsDead)
                            eventPlayer.AddUI(EMInterface.UI_SCORES, scoreContainer);
                    });
                }
            }

            /// <summary>
            /// Send the last generated scoreboard to the specified player
            /// </summary>
            /// <param name="eventPlayer"></param>
            protected void UpdateScoreboard(BaseEventPlayer eventPlayer)
            {
                if (scoreContainer != null && !eventPlayer.IsDead)
                    eventPlayer.AddUI(EMInterface.UI_SCORES, scoreContainer);
            }

            /// <summary>
            /// Update the score list and sort it
            /// </summary>
            protected void UpdateScores()
            {
                scoreData.Clear();

                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];

                    scoreData.Add(new ScoreEntry(eventPlayer, GetFirstScoreValue(eventPlayer), GetSecondScoreValue(eventPlayer)));
                }

                SortScores(ref scoreData);
            }

            /// <summary>
            /// Called when building the scoreboard. This should be done on a per event basis
            /// </summary>
            protected virtual void BuildScoreboard() { }

            /// <summary>
            /// The first score value to be displayed on scoreboards
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <returns></returns>
            protected virtual float GetFirstScoreValue(BaseEventPlayer eventPlayer) => 0f;

            /// <summary>
            /// The second score value to be displayed on scoreboards
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <returns></returns>
            protected virtual float GetSecondScoreValue(BaseEventPlayer eventPlayer) => 0f;

            /// <summary>
            /// Sort's the score list. This should be done on a per event basis
            /// </summary>
            /// <param name="list"></param>
            protected virtual void SortScores(ref List<ScoreEntry> list) { }
            #endregion

            #region Event Messaging
            /// <summary>
            /// Broadcasts a localized message to all event players
            /// </summary>
            /// <param name="key">Localizaiton key</param>
            /// <param name="args">Message arguments</param>
            internal void BroadcastToPlayers(string key, params object[] args)
            {
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (eventPlayer?.Player != null)
                        BroadcastToPlayer(eventPlayer, args != null ? string.Format(Message(key, eventPlayer.Player.userID), args) : Message(key, eventPlayer.Player.userID));
                }
            }

            /// <summary>
            /// Broadcasts a localized message to all event players, using the calling plugins localized messages
            /// </summary>
            /// <param name="key">Localizaiton key</param>
            /// <param name="args">Message arguments</param>
            internal void BroadcastToPlayers(Func<string, ulong, string> GetMessage, string key, params object[] args)
            {
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (eventPlayer?.Player != null)
                        BroadcastToPlayer(eventPlayer, args != null ? string.Format(GetMessage(key, eventPlayer.Player.userID), args) : GetMessage(key, eventPlayer.Player.userID));
                }
            }

            /// <summary>
            /// Broadcasts a localized message to all event players on the specified team
            /// </summary>
            /// <param name="team">Target team</param>
            /// <param name="key">Localizaiton key</param>
            /// <param name="args">Message arguments</param>
            internal void BroadcastToTeam(Team team, string key, string[] args = null)
            {
                for (int i = 0; i < eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = eventPlayers[i];
                    if (eventPlayer?.Player != null && eventPlayer.Team == team)
                        BroadcastToPlayer(eventPlayer, args != null ? string.Format(Message(key, eventPlayer.Player.userID), args) : Message(key, eventPlayer.Player.userID));
                }
            }

            /// <summary>
            /// Sends a message directly to the specified player
            /// </summary>
            /// <param name="eventPlayer"></param>
            /// <param name="message"></param>
            internal void BroadcastToPlayer(BaseEventPlayer eventPlayer, string message) => eventPlayer?.Player?.SendConsoleCommand("chat.add", 0, Configuration.Message.ChatIcon, message);

            private void BroadcastOpenEvent()
            {
                int timeRemaining = (int)(_startsAtTime - Time.time);
                if (timeRemaining > 0)
                    Broadcast("Notification.EventOpen", Config.EventName, Config.EventType, timeRemaining);
            }
            #endregion
        }

        public class BaseEventPlayer : MonoBehaviour
        {      
            protected float _respawnDurationRemaining;

            protected float _invincibilityEndsAt;

            private double _resetDamageTime;

            private List<ulong> _damageContributors = Pool.Get<List<ulong>>();

            private bool _isOOB;

            private int _oobTime;

            private int _spectateIndex = 0;


            internal BasePlayer Player { get; private set; }

            internal BaseEventGame Event { get; set; }

            internal Team Team { get; set; } = Team.None;

            internal int Kills { get; set; }

            internal int Deaths { get; set; }
            


            internal bool IsDead { get; set; }

            internal bool AutoRespawn { get; set; }

            internal bool CanRespawn => _respawnDurationRemaining <= 0;

            internal int RespawnRemaining => Mathf.CeilToInt(_respawnDurationRemaining);

            internal bool IsInvincible => Time.time < _invincibilityEndsAt;

            
            internal BaseEventPlayer SpectateTarget { get; private set; } = null;


            internal string Kit { get; set; }

            internal bool IsSelectingClass { get; set; }


            internal bool IsOutOfBounds
            {
                get
                {
                    return _isOOB;
                }
                set
                {
                    if (value)
                    {
                        _oobTime = 10;
                        InvokeHandler.Invoke(this, TickOutOfBounds, 1f);
                    }
                    else InvokeHandler.CancelInvoke(this, TickOutOfBounds);

                    _isOOB = value;
                }
            }
            
            private void Awake()
            {
                Player = GetComponent<BasePlayer>();

                Instance.Restore.AddData(Player);

                Player.metabolism.bleeding.max = 0;
                Player.metabolism.bleeding.value = 0;
                Player.metabolism.radiation_level.max = 0;
                Player.metabolism.radiation_level.value = 0;
                Player.metabolism.radiation_poison.max = 0;
                Player.metabolism.radiation_poison.value = 0;

                Player.metabolism.SendChangesToClient();
            }

            private void OnDestroy()
            {
                if (Player.IsSpectating())
                    FinishSpectating();

                Player.limitNetworking = false;

                Player.EnablePlayerCollider();

                Player.health = Player.MaxHealth();

                Player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                Player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);

                Player.metabolism.bleeding.max = 1;
                Player.metabolism.bleeding.value = 0;
                Player.metabolism.radiation_level.max = 100;
                Player.metabolism.radiation_level.value = 0;
                Player.metabolism.radiation_poison.max = 500;
                Player.metabolism.radiation_poison.value = 0;

                Player.metabolism.SendChangesToClient();

                if (Player.isMounted)
                    Player.GetMounted()?.AttemptDismount(Player);
                
                DestroyUI();

                if (IsUnloading)
                    StripInventory(Player);

                UnlockInventory(Player);
                
                InvokeHandler.CancelInvoke(this, TickOutOfBounds);

                Pool.FreeUnmanaged(ref _damageContributors);
                Pool.FreeUnmanaged(ref _openPanels);
            }

            internal void ResetPlayer()
            {
                Team = Team.None;
                Kills = 0;
                Deaths = 0;
                IsDead = false;
                AutoRespawn = false;
                Kit = string.Empty;
                IsSelectingClass = false;

                _spectateIndex = 0;
                _respawnDurationRemaining = 0;
                _invincibilityEndsAt = 0;
                _resetDamageTime = 0;
                _oobTime = 0;
                _isOOB = false;

                _damageContributors.Clear();
            }

            internal void ForceSelectClass()
            {
                IsDead = true;
                IsSelectingClass = true;
            }

            protected void RespawnTick()
            {
                _respawnDurationRemaining = Mathf.Clamp(_respawnDurationRemaining - 1f, 0f, float.MaxValue);

                EMInterface.UpdateRespawnButton(this);

                if (_respawnDurationRemaining <= 0f)
                {
                    InvokeHandler.CancelInvoke(this, RespawnTick);

                    if (AutoRespawn)
                        RespawnPlayer(this);
                }
            }

            #region Death
            internal void OnKilledPlayer(HitInfo hitInfo)
            {
                Kills++;

                int rewardAmount = Configuration.Reward.KillAmount;

                EventStatistics.Data.AddStatistic(Player, "Kills");

                if (hitInfo != null)
                {
                    if (hitInfo.damageTypes.IsMeleeType())
                        EventStatistics.Data.AddStatistic(Player, "Melee");

                    if (hitInfo.isHeadshot)
                    {
                        EventStatistics.Data.AddStatistic(Player, "Headshots");
                        rewardAmount = Configuration.Reward.HeadshotAmount;
                    }
                }

                if (rewardAmount > 0)
                    Instance.GiveReward(this, rewardAmount);
            }

            internal virtual void OnPlayerDeath(BaseEventPlayer attacker = null, float respawnTime = 5f)
            {
                AddPlayerDeath(attacker);

                _respawnDurationRemaining = respawnTime;

                InvokeHandler.InvokeRepeating(this, RespawnTick, 1f, 1f);

                DestroyUI();

                string message = attacker != null ? string.Format(Message("UI.Death.Killed", Player.userID), attacker.Player.displayName) : 
                                 IsOutOfBounds ? Message("UI.Death.OOB", Player.userID) :
                                 Message("UI.Death.Suicide", Player.userID);

                EMInterface.DisplayDeathScreen(this, message, true);
            }

            internal void AddPlayerDeath(BaseEventPlayer attacker = null)
            {
                Deaths++;
                EventStatistics.Data.AddStatistic(Player, "Deaths");
                ApplyAssistPoints(attacker);
            }

            protected void ApplyAssistPoints(BaseEventPlayer attacker = null)
            {
                if (_damageContributors.Count > 1)
                {
                    for (int i = 0; i < _damageContributors.Count - 1; i++)
                    {
                        ulong contributorId = _damageContributors[i];
                        if (attacker != null && attacker.Player.userID == contributorId)
                            continue;

                        EventStatistics.Data.AddStatistic(contributorId, "Assists");
                    }
                }

                _resetDamageTime = 0;
                _damageContributors.Clear();
            }

            internal void ApplyInvincibility() => _invincibilityEndsAt = Time.time + 3f;
            #endregion
            
            protected void TickOutOfBounds()
            {
                if (Player == null)
                {
                    BaseManager.LeaveEvent(this);
                    return;
                }

                if (IsDead)
                    return;

                if (IsOutOfBounds)
                {
                    if (_oobTime == 10)
                        BaseManager.BroadcastToPlayer(this, Message("Notification.OutOfBounds", Player.userID));
                    else if (_oobTime == 0)
                    {
                        Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", Player.transform.position);

                        if (BaseManager.Status == EventStatus.Started)
                            BaseManager.PrePlayerDeath(this, null);
                        else BaseManager.SpawnPlayer(this, false);
                    }
                    else BaseManager.BroadcastToPlayer(this, string.Format(Message("Notification.OutOfBounds.Time", Player.userID), _oobTime));

                    _oobTime--;

                    InvokeHandler.Invoke(this, TickOutOfBounds, 1f);
                }
            }

            internal void DropInventory()
            {
                const string BACKPACK_PREFAB = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";

                DroppedItemContainer itemContainer = ItemContainer.Drop(BACKPACK_PREFAB, Player.transform.position, Quaternion.identity, new ItemContainer[] { Player.inventory.containerBelt, Player.inventory.containerMain });
                if (itemContainer != null)
                {
                    itemContainer.playerName = Player.displayName;
                    itemContainer.playerSteamID = Player.userID;

                    itemContainer.CancelInvoke(itemContainer.RemoveMe);
                    itemContainer.Invoke(itemContainer.RemoveMe, Configuration.Timer.Bag);
                }
            }

            #region Networking
            internal void RemoveFromNetwork()
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.EntityDestroy);
                netWrite.EntityID(Player.net.ID);
                netWrite.UInt8((byte)BaseNetworkable.DestroyMode.None);
                netWrite.Send(new SendInfo(Player.net.group.subscribers.Where(x => x.userid != Player.userID).ToList()));
            }

            internal void AddToNetwork() => Player.SendFullSnapshot();            
            #endregion

            #region Damage Contributors
            internal void OnTakeDamage(ulong attackerId)
            {
                float time = Time.realtimeSinceStartup;
                if (time > _resetDamageTime)
                {
                    _resetDamageTime = time + 3f;
                    _damageContributors.Clear();
                }

                if (attackerId != 0U && attackerId != Player.userID)
                {
                    if (_damageContributors.Contains(attackerId))
                        _damageContributors.Remove(attackerId);
                    _damageContributors.Add(attackerId);
                }
            }

            internal List<ulong> DamageContributors => _damageContributors;
            #endregion

            #region Spectating  
            public void BeginSpectating()
            {
                if (Player.IsSpectating())
                    return;

                DestroyUI();

                Player.StartSpectating();
                Player.ChatMessage(Message("Notification.SpectateCycle", Player.userID));
                UpdateSpectateTarget();
            }

            public void FinishSpectating()
            {
                if (!Player.IsSpectating())
                    return;

                Player.SetParent(null, false, false);
                Player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                Player.gameObject.SetLayerRecursive(17);
            }

            public void SetSpectateTarget(BaseEventPlayer eventPlayer)
            {
                SpectateTarget = eventPlayer;

                Event.BroadcastToPlayer(this, $"Spectating: {eventPlayer.Player.displayName}");

                Player.SendEntitySnapshot(eventPlayer.Player);
                Player.gameObject.Identity();
                Player.SetParent(eventPlayer.Player, false, false);
            }

            public void UpdateSpectateTarget()
            {
                List<BaseEventPlayer> list = Pool.Get<List<BaseEventPlayer>>();

                Event.GetSpectateTargets(ref list);

                int newIndex = (int)Mathf.Repeat(_spectateIndex += 1, list.Count - 1);

                if (list[newIndex] != SpectateTarget)
                {
                    _spectateIndex = newIndex;
                    SetSpectateTarget(list[_spectateIndex]);
                }

                Pool.FreeUnmanaged(ref list);
            }
            #endregion

            #region UI Management
            private List<string> _openPanels = Pool.Get<List<string>>();

            internal void AddUI(string panel, CuiElementContainer container)
            {
                DestroyUI(panel);

                _openPanels.Add(panel);
                CuiHelper.AddUi(Player, container);
            }

            internal void DestroyUI()
            {
                foreach (string panel in _openPanels)
                    CuiHelper.DestroyUi(Player, panel);
                _openPanels.Clear();
            }

            internal void DestroyUI(string panel)
            {
                if (_openPanels.Contains(panel))
                    _openPanels.Remove(panel);
                CuiHelper.DestroyUi(Player, panel);
            }
            #endregion
        }

        #region Event Timer
        public class GameTimer
        {
            private BaseEventGame _owner = null;

            private string _message;
            private int _timeRemaining;
            private Action _callback;

            internal GameTimer(BaseEventGame owner)
            {
                _owner = owner;
            }
                        
            internal void StartTimer(int time, string message = "", Action callback = null)
            {
                this._timeRemaining = time;
                this._message = message;
                this._callback = callback;

                InvokeHandler.InvokeRepeating(_owner, TimerTick, 1f, 1f);
            }

            internal void StopTimer()
            {
                InvokeHandler.CancelInvoke(_owner, TimerTick);

                for (int i = 0; i < _owner?.eventPlayers?.Count; i++)                
                    _owner.eventPlayers[i].DestroyUI(EMInterface.UI_TIMER);                
            }

            private void TimerTick()
            {
                _timeRemaining--;
                if (_timeRemaining == 0)
                {
                    StopTimer();
                    _callback?.Invoke();
                }
                else UpdateTimer();                
            }

            private void UpdateTimer()
            {
                string clockTime = string.Empty;

                TimeSpan dateDifference = TimeSpan.FromSeconds(_timeRemaining);
                int hours = dateDifference.Hours;
                int mins = dateDifference.Minutes;
                int secs = dateDifference.Seconds;

                if (hours > 0)
                    clockTime = string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
                else clockTime = string.Format("{0:00}:{1:00}", mins, secs);

                CuiElementContainer container = UI.Container(EMInterface.UI_TIMER, "0.1 0.1 0.1 0.7", new UI4(0.46f, 0.92f, 0.54f, 0.95f), false, "Hud");

                UI.Label(container, EMInterface.UI_TIMER, clockTime, 14, UI4.Full);

                if (!string.IsNullOrEmpty(_message))
                    UI.Label(container, EMInterface.UI_TIMER, _message, 14, new UI4(-5f, 0f, -0.1f, 1), TextAnchor.MiddleRight);

                for (int i = 0; i < _owner.eventPlayers.Count; i++)
                {
                    BaseEventPlayer eventPlayer = _owner.eventPlayers[i];
                    if (eventPlayer == null)
                        continue;

                    eventPlayer.DestroyUI(EMInterface.UI_TIMER);
                    eventPlayer.AddUI(EMInterface.UI_TIMER, container);
                }               
            }            
        }
        #endregion

        #region Spawn Management
        internal class SpawnSelector
        {
            private List<Vector3> _defaultSpawns;
            private List<Vector3> _availableSpawns;

            internal SpawnSelector(string eventName, string spawnFile)
            {
                _defaultSpawns = Instance.Spawns.Call("LoadSpawnFile", spawnFile) as List<Vector3> ?? new List<Vector3>();
                _availableSpawns = Pool.Get<List<Vector3>>();
                _availableSpawns.AddRange(_defaultSpawns);
            }

            internal Vector3 GetSpawnPoint()
            {
                Vector3 point = _availableSpawns.GetRandom();
                _availableSpawns.Remove(point);

                if (_availableSpawns.Count == 0)
                    _availableSpawns.AddRange(_defaultSpawns);

                return point;
            }

            internal Vector3 ReserveSpawnPoint(int index)
            {
                Vector3 reserved = _defaultSpawns[index];
                _defaultSpawns.RemoveAt(index);

                _availableSpawns.Clear();
                _availableSpawns.AddRange(_defaultSpawns);

                return reserved;
            }

            internal void Destroy()
            {
                Pool.FreeUnmanaged(ref _availableSpawns);
            }
        }
        #endregion

        #region Event Config
        public class EventConfig
        {            
            public string EventName { get; set; } = string.Empty;
            public string EventType { get; set; } = string.Empty;

            public string ZoneID { get; set; } = string.Empty;

            public int TimeLimit { get; set; }
            public int ScoreLimit { get; set; }
            public int MinimumPlayers { get; set; }
            public int MaximumPlayers { get; set; }

            public bool AllowClassSelection { get; set; }

            public TeamConfig TeamConfigA { get; set; } = new TeamConfig();
            public TeamConfig TeamConfigB { get; set; } = new TeamConfig();

            public Hash<string, object> AdditionalParams { get; set; } = new Hash<string, object>();

            public EventConfig() { }

            public EventConfig(string type, IEventPlugin eventPlugin)
            {
                this.EventType = type;
                this.Plugin = eventPlugin;

                if (eventPlugin.AdditionalParameters != null)
                {
                    for (int i = 0; i < eventPlugin.AdditionalParameters.Count; i++)
                    {
                        EventParameter eventParameter = eventPlugin.AdditionalParameters[i];

                        if (eventParameter.DefaultValue == null && eventParameter.IsList)
                            AdditionalParams[eventParameter.Field] = new List<string>();
                        else AdditionalParams[eventParameter.Field] = eventParameter.DefaultValue;
                    }
                }
            }

            public T GetParameter<T>(string key)
            {
                try
                {
                    if (AdditionalParams.TryGetValue(key, out object obj))
                        return (T)Convert.ChangeType(obj, typeof(T));
                }
                catch { }
                
                return default(T);
            }

            public string GetString(string fieldName)
            {
                switch (fieldName)
                {
                    case "teamASpawnfile":
                        return TeamConfigA.Spawnfile;
                    case "teamBSpawnfile":
                        return TeamConfigB.Spawnfile;
                    case "zoneID":
                        return ZoneID;
                    default:
                        if (AdditionalParams.TryGetValue(fieldName, out object obj) && obj is string)
                            return obj as string;
                        return null;
                }
            }

            public List<string> GetList(string fieldName)
            {
                switch (fieldName)
                {
                    case "teamAKits":
                        return TeamConfigA.Kits;
                    case "teamBKits":
                        return TeamConfigB.Kits;
                    default:
                        if (AdditionalParams.TryGetValue(fieldName, out object obj) && obj is List<string>)
                            return obj as List<string>;
                        return null;
                }
            }

            public class TeamConfig
            {
                public string Color { get; set; } = string.Empty;
                public string Spawnfile { get; set; } = string.Empty;
                public List<string> Kits { get; set; } = new List<string>();
                public string Clothing { get; set; } = string.Empty;
            }

            [JsonIgnore]
            public IEventPlugin Plugin { get; set; }
        }
        #endregion
        #endregion

        #region Rewards
        private void GiveReward(BaseEventPlayer baseEventPlayer, int amount)
        {
            switch (rewardType)
            {
                case RewardType.ServerRewards:
                    ServerRewards?.Call("AddPoints", baseEventPlayer.Player.UserIDString, amount);
                    break;
                case RewardType.Economics:
                    Economics?.Call("Deposit", baseEventPlayer.Player.UserIDString, (double)amount);
                    break;
                case RewardType.Scrap:
                    Restore.AddPrizeToData(baseEventPlayer.Player.userID, scrapItemId, amount);
                    break;                
            }
        }
        #endregion

        #region Enums
        public enum RewardType { ServerRewards, Economics, Scrap }

        public enum EventStatus { Finished, Open, Prestarting, Started }
        
        public enum Team { A, B, None }
        #endregion

        #region Helpers  
        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                return default(T);
            }
        }
        
        // API for direct plugin hook calls ie. EventManager.Call("IsEventPlayer", player);
        private object IsEventPlayer(BasePlayer player) => GetUser(player) != null ? (object)true : null;

        // API for global plugin hook calls ie. Interface.Oxide.CallHook("isEventPlayer", player); Global hook calls can't start with a uppercase I
        private object isEventPlayer(BasePlayer player) => GetUser(player) != null ? (object)true : null;

        /// <summary>
        /// Get the BaseEventPlayer component on the specified BasePlayer
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        internal static BaseEventPlayer GetUser(BasePlayer player) => player?.GetComponent<BaseEventPlayer>();
       
        /// <summary>
        /// Teleport player to the specified position
        /// </summary>
        /// <param name="player"></param>
        /// <param name="destination"></param>
        /// <param name="sleep"></param>
        internal static void MovePosition(BasePlayer player, Vector3 destination, bool sleep)
        {
            if (player.isMounted)
                player.GetMounted().DismountPlayer(player, true);

            if (player.GetParentEntity())
                player.SetParent(null);

            if (sleep)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.MovePosition(destination);
                player.UpdateNetworkGroup();
                player.StartSleeping();
                player.SendNetworkUpdateImmediate(false);
                player.ClearEntityQueue(null);
                player.ClientRPCPlayer(null, player, "StartLoading");
                player.SendFullSnapshot();
            }
            else
            {
                player.MovePosition(destination);
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
                player.SendNetworkUpdateImmediate();
                player.ClearEntityQueue(null);
            }
        }

        /// <summary>
        /// Lock the players inventory so they can't remove items
        /// </summary>
        /// <param name="player"></param>
        internal static void LockInventory(BasePlayer player)
        {
            if (player == null)
                return;

            if (!player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
            {
                player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, true);
                player.inventory.SendSnapshot();
            }
        }

        /// <summary>
        /// Unlock the players inventory
        /// </summary>
        /// <param name="player"></param>
        internal static void UnlockInventory(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.inventory.containerWear.HasFlag(ItemContainer.Flag.IsLocked))
            {
                player.inventory.containerWear.SetFlag(ItemContainer.Flag.IsLocked, false);
                player.inventory.SendSnapshot();
            }
        }

        /// <summary>
        /// Removes all items from the players inventory
        /// </summary>
        /// <param name="player"></param>
        internal static void StripInventory(BasePlayer player)
        {
            List<Item> allItems = Pool.Get<List<Item>>();
            player.inventory.GetAllItems(allItems);

            for (int i = allItems.Count - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                item.RemoveFromContainer();
                item.Remove();
            }
            
            Pool.FreeUnmanaged(ref allItems);
        }

        /// <summary>
        /// Reset the players health and metabolism
        /// </summary>
        /// <param name="player"></param>
        internal static void ResetMetabolism(BasePlayer player)
        {
            player.health = player.MaxHealth();

            player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);

            player.metabolism.calories.value = player.metabolism.calories.max;
            player.metabolism.hydration.value = player.metabolism.hydration.max;
            player.metabolism.heartrate.Reset();

            player.metabolism.bleeding.value = 0;
            player.metabolism.radiation_level.value = 0;
            player.metabolism.radiation_poison.value = 0;
            player.metabolism.SendChangesToClient();            
        }

        /// <summary>
        /// Gives the player the specified kit
        /// </summary>
        /// <param name="player"></param>
        /// <param name="kitname"></param>
        internal static void GiveKit(BasePlayer player, string kitname) => Instance.Kits?.Call("GiveKit", player, kitname);

        /// <summary>
        /// Nullifies damage being dealt
        /// </summary>
        /// <param name="hitInfo"></param>
        internal static void ClearDamage(HitInfo hitInfo)
        {
            if (hitInfo == null)
                return;

            hitInfo.damageTypes.Clear();
            hitInfo.HitEntity = null;
            hitInfo.HitMaterial = 0;
            hitInfo.PointStart = Vector3.zero;
        }

        /// <summary>
        /// Resets the player so they have max health and are visible to other players
        /// </summary>
        /// <param name="player"></param>
        internal static void ResetPlayer(BasePlayer player)
        {
            BaseEventPlayer eventPlayer = GetUser(player);

            if (eventPlayer == null)
                return;

            if (eventPlayer.Player.IsSpectating())
                eventPlayer.FinishSpectating();

            player.limitNetworking = false;

            player.EnablePlayerCollider();

            player.health = player.MaxHealth();

            player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);

            eventPlayer.IsDead = false;

            eventPlayer.AddToNetwork();  
        }

        /// <summary>
        /// Respawn the player if they are dead
        /// </summary>
        /// <param name="eventPlayer"></param>
        internal static void RespawnPlayer(BaseEventPlayer eventPlayer)
        {
            if (!eventPlayer.IsDead)
                return;

            eventPlayer.DestroyUI(EMInterface.UI_DEATH);
            eventPlayer.DestroyUI(EMInterface.UI_RESPAWN);            

            ResetPlayer(eventPlayer.Player);

            BaseManager.OnPlayerRespawn(eventPlayer);
        }

        /// <summary>
        /// Strip's clan tags out of a player display name
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        internal static string StripTags(string str)
        {
            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                str = str.Substring(str.IndexOf("]") + 1).Trim();

            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                StripTags(str);

            return str;
        }

        /// <summary>
        /// Trim's a player's display name to the specified size
        /// </summary>
        /// <param name="str"></param>
        /// <param name="size"></param>
        /// <returns></returns>
        internal static string TrimToSize(string str, int size = 18)
        {
            if (str.Length > size)
                str = str.Substring(0, size);
            return str;
        }
        #endregion

        #region Zone Management
        private void OnExitZone(string zoneId, BasePlayer player)
        {
            if (player == null)
                return;

            BaseEventPlayer eventPlayer = GetUser(player);

            if (eventPlayer == null || eventPlayer.IsDead)
                return;

            if (BaseManager != null && zoneId == BaseManager.Config.ZoneID)            
                eventPlayer.IsOutOfBounds = true;
        }

        private void OnEnterZone(string zoneId, BasePlayer player)
        {           
            BaseEventPlayer eventPlayer = GetUser(player);

            if (eventPlayer == null || eventPlayer.IsDead)
                return;
            
            if (BaseManager != null && zoneId == BaseManager.Config.ZoneID)            
                eventPlayer.IsOutOfBounds = false;   
        }
        #endregion

        #region File Validation
        internal object ValidateEventConfig(EventConfig eventConfig)
        {
            if (string.IsNullOrEmpty(eventConfig.EventType) || !EventModes.TryGetValue(eventConfig.EventType, out IEventPlugin plugin))
                return string.Concat("Event mode ", eventConfig.EventType, " is not currently loaded");

            if (!plugin.CanUseClassSelector && eventConfig.TeamConfigA.Kits.Count == 0)
                return "You must set atleast 1 kit";

            if (eventConfig.MinimumPlayers == 0)
                return "You must set the minimum players";

            if (eventConfig.MaximumPlayers == 0)
                return "You must set the maximum players";

            if (plugin.RequireTimeLimit && eventConfig.TimeLimit == 0)
                return "You must set a time limit";

            if (plugin.RequireScoreLimit && eventConfig.ScoreLimit == 0)
                return "You must set a score limit";

            object success;

            foreach (string kit in eventConfig.TeamConfigA.Kits)
            {
                success = ValidateKit(kit);
                if (success is string)
                    return $"Invalid kit: {kit}";
            }
            
            success = ValidateSpawnFile(eventConfig.TeamConfigA.Spawnfile);
            if (success is string)
                return $"Invalid spawn file: {eventConfig.TeamConfigA.Spawnfile}";

            if (plugin.IsTeamEvent)
            {
                success = ValidateSpawnFile(eventConfig.TeamConfigB.Spawnfile);
                if (success is string)
                    return $"Invalid second spawn file: {eventConfig.TeamConfigB.Spawnfile}";

                if (eventConfig.TeamConfigB.Kits.Count == 0)
                    return "You must set atleast 1 kit for Team B";

                foreach (string kit in eventConfig.TeamConfigB.Kits)
                {
                    success = ValidateKit(kit);
                    if (success is string)
                        return $"Invalid kit: {kit}";
                }
            }

            success = ValidateZoneID(eventConfig.ZoneID);
            if (success is string)
                return $"Invalid zone ID: {eventConfig.ZoneID}";

            for (int i = 0; i < plugin.AdditionalParameters?.Count; i++)
            {
                EventParameter eventParameter = plugin.AdditionalParameters[i];

                if (eventParameter.IsRequired)
                {
                    eventConfig.AdditionalParams.TryGetValue(eventParameter.Field, out object value);

                    if (value == null)
                        return $"Missing event parameter: ({eventParameter.DataType}){eventParameter.Field}";
                    else
                    {
                        success = plugin.ParameterIsValid(eventParameter.Field, value);
                        if (success is string)
                            return (string)success;
                    }
                }
            }

            return null;
        }

        internal object ValidateSpawnFile(string name)
        {
            object success = Spawns?.Call("GetSpawnsCount", name);
            if (success is string)
                return (string)success;
            return null;
        }

        internal object ValidateZoneID(string name)
        {
            object success = ZoneManager?.Call("CheckZoneID", name);
            if (name is string && !string.IsNullOrEmpty((string)name))
                return null;
            return $"Zone \"{name}\" does not exist!";
        }

        internal object ValidateKit(string name)
        {
            object success = Kits?.Call("isKit", name);
            if ((success is bool))
            {
                if (!(bool)success)
                    return $"Kit \"{name}\" does not exist!";
            }
            return null;
        }
        #endregion

        #region Scoring
        public struct ScoreEntry
        {
            internal int position;
            internal string displayName;
            internal float value1;
            internal float value2;
            internal Team team;

            internal ScoreEntry(BaseEventPlayer eventPlayer, int position, float value1, float value2)
            {
                this.position = position;
                this.displayName = StripTags(eventPlayer.Player.displayName);
                this.team = eventPlayer.Team;
                this.value1 = value1;
                this.value2 = value2;
            }

            internal ScoreEntry(BaseEventPlayer eventPlayer, float value1, float value2)
            {
                this.position = 0;
                this.displayName = StripTags(eventPlayer.Player.displayName);
                this.team = eventPlayer.Team;
                this.value1 = value1;
                this.value2 = value2;
            }

            internal ScoreEntry(float value1, float value2)
            {
                this.position = 0;
                this.displayName = string.Empty;
                this.team = Team.None;
                this.value1 = value1;
                this.value2 = value2;
            }
        }

        public class EventResults
        {
            public string EventName { get; private set; }

            public string EventType { get; private set; }

            public ScoreEntry TeamScore { get; private set; }

            public IEventPlugin Plugin { get; private set; }

            public List<ScoreEntry> Scores { get; private set; } = new List<ScoreEntry>();

            public bool IsValid => Plugin != null;

            public void UpdateFromEvent(BaseEventGame baseEventGame)
            {
                EventName = baseEventGame.Config.EventName;
                EventType = baseEventGame.Config.EventType;
                Plugin = baseEventGame.Plugin;

                if (Plugin.IsTeamEvent)
                    TeamScore = new ScoreEntry(baseEventGame.GetTeamScore(Team.A), baseEventGame.GetTeamScore(Team.B));
                else TeamScore = default(ScoreEntry);

                Scores.Clear();

                if (baseEventGame.scoreData.Count > 0)
                    Scores.AddRange(baseEventGame.scoreData);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("event")]
        private void cmdEvent(BasePlayer player, string command, string[] args)
        {
            EMInterface.Instance.OpenMenu(player, new EMInterface.MenuArgs(EMInterface.MenuTab.Event));
        }
        #endregion

        #region Config  
        public class ConfigData
        {
            [JsonProperty(PropertyName = "Auto-Event Options")]
            public AutoEventOptions AutoEvents { get; set; }

            [JsonProperty(PropertyName = "Event Options")]
            public EventOptions Event { get; set; }

            [JsonProperty(PropertyName = "Reward Options")]
            public RewardOptions Reward { get; set; }

            [JsonProperty(PropertyName = "Timer Options")]
            public TimerOptions Timer { get; set; }

            [JsonProperty(PropertyName = "Message Options")]
            public MessageOptions Message { get; set; }

            public class EventOptions
            {      
                [JsonProperty(PropertyName = "Blacklisted commands for event players")]
                public string[] CommandBlacklist { get; set; }
            }

            public class RewardOptions
            {                
                [JsonProperty(PropertyName = "Amount rewarded for kills")]
                public int KillAmount { get; set; }

                [JsonProperty(PropertyName = "Amount rewarded for wins")]
                public int WinAmount { get; set; }

                [JsonProperty(PropertyName = "Amount rewarded for headshots")]
                public int HeadshotAmount { get; set; }

                [JsonProperty(PropertyName = "Reward type (ServerRewards, Economics, Scrap)")]
                public string Type { get; set; }
            }

            public class TimerOptions
            {
                [JsonProperty(PropertyName = "Match start timer (seconds)")]
                public int Start { get; set; }

                [JsonProperty(PropertyName = "Match pre-start timer (seconds)")]
                public int Prestart { get; set; }

                [JsonProperty(PropertyName = "Backpack despawn timer (seconds)")]
                public int Bag { get; set; }
            }

            public class MessageOptions
            {
                [JsonProperty(PropertyName = "Announce events when one opens")]
                public bool Announce { get; set; }

                [JsonProperty(PropertyName = "Event announcement interval (seconds)")]
                public int AnnounceInterval { get; set; }

                [JsonProperty(PropertyName = "Broadcast when a player joins an event to chat")]
                public bool BroadcastJoiners { get; set; }

                [JsonProperty(PropertyName = "Broadcast when a player leaves an event to chat")]
                public bool BroadcastLeavers { get; set; }

                [JsonProperty(PropertyName = "Broadcast the name(s) of the winning player(s) to chat")]
                public bool BroadcastWinners { get; set; }

                [JsonProperty(PropertyName = "Broadcast kills to chat")]
                public bool BroadcastKills { get; set; }  

                [JsonProperty(PropertyName = "Chat icon Steam ID")]
                public ulong ChatIcon { get; set; }
            }

            public class AutoEventOptions
            {
                [JsonProperty(PropertyName = "Enable auto-events")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "List of event configs to run through")]
                public string[] Events { get; set; }

                [JsonProperty(PropertyName = "Randomize auto-event selection")]
                public bool Randomize { get; set; }

                [JsonProperty(PropertyName = "Auto-event interval (seconds)")]
                public int Interval { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AutoEvents = new ConfigData.AutoEventOptions
                {
                    Enabled = false,
                    Events = new string[0],
                    Randomize = false,
                    Interval = 3600
                },
                Event = new ConfigData.EventOptions
                {
                    CommandBlacklist = new string[] { "s", "tp" }
                },
                Message = new ConfigData.MessageOptions
                {
                    Announce = true,
                    AnnounceInterval = 120,
                    BroadcastJoiners = true,
                    BroadcastLeavers = true,
                    BroadcastWinners = true,
                    BroadcastKills = true,
                    ChatIcon = 76561198403299915
                },
                Reward = new ConfigData.RewardOptions
                {
                    KillAmount = 1,
                    WinAmount = 5,
                    HeadshotAmount = 2,
                    Type = "Scrap"
                },
                Timer = new ConfigData.TimerOptions
                {
                    Start = 60,
                    Prestart = 10,
                    Bag = 30
                },                
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(4, 0, 1))
                Configuration.AutoEvents.Interval = baseConfig.AutoEvents.Interval;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        internal void SaveEventData() => eventData.WriteObject(Events);

        private void SaveRestoreData() => restorationData.WriteObject(Restore);

        private void LoadData()
        {
            try
            {
                Restore = restorationData.ReadObject<RestoreData>();
            }
            catch
            {
                Restore = new RestoreData();
            }

            try
            {
                Events = eventData.ReadObject<EventData>();
            }
            catch
            {
                Events = new EventData();
            }
        }

        public static void SaveEventConfig(EventConfig eventConfig)
        {
            Instance.Events.events[eventConfig.EventName] = eventConfig;
            Instance.SaveEventData();
        }

        public class EventData
        {
            public Hash<string, EventConfig> events = new Hash<string, EventConfig>();
        }

        public class EventParameter
        {
            public string Name; // The name shown in the UI
            public InputType Input; // The type of input used to select the value in the UI

            public string Field; // The name of the custom field stored in the event config
            public string DataType; // The type of the field (string, int, float, bool, List<string>)

            public bool IsRequired; // Is this field required to complete event creation?

            public string SelectorHook; // The hook that is called to gather the options that can be selected. This should return a string[] (ex. GetZoneIDs from ZoneManager, GetAllKits from Kits)
            public bool SelectMultiple; // Allows the user to select multiple elements when using the selector

            public object DefaultValue; // Set the default value for this field

            [JsonIgnore]
            public bool IsList => Input == InputType.Selector && DataType.Equals("List<string>", StringComparison.OrdinalIgnoreCase);
            
            public enum InputType { InputField, Toggle, Selector }
        }

        #region Player Restoration
        public class RestoreData
        {
            public Hash<ulong, PlayerData> Restore = new Hash<ulong, PlayerData>();

            internal void AddData(BasePlayer player)
            {
                Restore[player.userID] = new PlayerData(player);
            }

            public void AddPrizeToData(ulong playerId, int itemId, int amount)
            {
                if (Restore.TryGetValue(playerId, out PlayerData playerData))
                {
                    ItemData itemData = FindItem(playerData, itemId);
                    if (itemData != null)
                        itemData.amount += amount;
                    else
                    {
                        Array.Resize<ItemData>(ref playerData.containerMain, playerData.containerMain.Length + 1);
                        playerData.containerMain[playerData.containerMain.Length - 1] = new ItemData() { amount = amount, condition = 100, contents = new ItemData[0], itemid = itemId, position = -1, skin = 0UL };
                    }
                }
            }

            private ItemData FindItem(PlayerData playerData, int itemId)
            {
                for (int i = 0; i < playerData.containerMain.Length; i++)
                {
                    ItemData itemData = playerData.containerMain[i];
                    if (itemData.itemid.Equals(itemId))
                        return itemData;
                }

                for (int i = 0; i < playerData.containerBelt.Length; i++)
                {
                    ItemData itemData = playerData.containerBelt[i];
                    if (itemData.itemid.Equals(itemId))
                        return itemData;
                }

                return null;
            }

            internal void RemoveData(ulong playerId)
            {
                if (HasRestoreData(playerId))
                    Restore.Remove(playerId);
            }

            internal bool HasRestoreData(ulong playerId) => Restore.ContainsKey(playerId);

            internal void RestorePlayer(BasePlayer player)
            {
                if (Restore.TryGetValue(player.userID, out PlayerData playerData))
                {
                    StripInventory(player);

                    player.metabolism.Reset();

                    if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
                    {
                        Instance.timer.Once(1, () => RestorePlayer(player));
                        return;
                    }

                    Instance.NextTick(() =>
                    {
                        playerData.SetStats(player);
                        MovePosition(player, playerData.position, true);
                        RestoreAllItems(player, playerData);
                    });
                }
            }

            private void RestoreAllItems(BasePlayer player, PlayerData playerData)
            {
                if (player == null || !player.IsConnected)
                    return;

                if (RestoreItems(player, playerData.containerBelt, Container.Belt) && 
                    RestoreItems(player, playerData.containerWear, Container.Wear) && 
                    RestoreItems(player, playerData.containerMain, Container.Main))
                    RemoveData(player.userID);
            }

            private bool RestoreItems(BasePlayer player, ItemData[] itemData, Container type)
            {
                ItemContainer container = type == Container.Belt ? player.inventory.containerBelt : type == Container.Wear ? player.inventory.containerWear : player.inventory.containerMain;

                for (int i = 0; i < itemData.Length; i++)
                {
                    ItemData data = itemData[i];
                    if (data.amount < 1)
                        continue;

                    Item item = CreateItem(data);
                    item.position = data.position;
                    item.SetParent(container);
                }
                return true;
            }            

            public class PlayerData
            {
                public float[] stats;
                public Vector3 position;
                public ItemData[] containerMain;
                public ItemData[] containerWear;
                public ItemData[] containerBelt;

                public PlayerData() { }

                public PlayerData(BasePlayer player)
                {
                    stats = GetStats(player);
                    position = player.transform.position;

                    containerBelt = GetItems(player.inventory.containerBelt).ToArray();
                    containerMain = GetItems(player.inventory.containerMain).ToArray();
                    containerWear = GetItems(player.inventory.containerWear).ToArray();
                }

                private IEnumerable<ItemData> GetItems(ItemContainer container)
                {
                    return container.itemList.Select(item => SerializeItem(item));
                }

                private float[] GetStats(BasePlayer player) => new float[] { player.health, player.metabolism.hydration.value, player.metabolism.calories.value };

                internal void SetStats(BasePlayer player)
                {
                    player.health = stats[0];
                    player.metabolism.hydration.value = stats[1];
                    player.metabolism.calories.value = stats[2];
                    player.metabolism.SendChangesToClient();
                }
            }
            private enum Container { Belt, Main, Wear }
        }
        #endregion

        #region Serialized Items
        internal static Item CreateItem(ItemData itemData)
        {
            Item item = ItemManager.CreateByItemID(itemData.itemid, itemData.amount, itemData.skin);
            item.condition = itemData.condition;
            item.maxCondition = itemData.maxCondition;

            if (itemData.frequency > 0)
            {
                ItemModRFListener rfListener = item.info.GetComponentInChildren<ItemModRFListener>();
                if (rfListener != null)
                {
                    PagerEntity pagerEntity = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as PagerEntity;
                    if (pagerEntity != null)
                    {
                        pagerEntity.ChangeFrequency(itemData.frequency);
                        item.MarkDirty();
                    }
                }
            }

            if (itemData.instanceData?.IsValid() ?? false)
                itemData.instanceData.Restore(item);

            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                if (!string.IsNullOrEmpty(itemData.ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.ammotype);
                weapon.primaryMagazine.contents = itemData.ammo;
            }

            FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
            if (flameThrower != null)
                flameThrower.ammo = itemData.ammo;

            if (itemData.contents != null)
            {
                foreach (ItemData contentData in itemData.contents)
                {
                    Item newContent = ItemManager.CreateByItemID(contentData.itemid, contentData.amount);
                    if (newContent != null)
                    {
                        newContent.condition = contentData.condition;
                        newContent.MoveToContainer(item.contents);
                    }
                }
            }
            return item;
        }

        internal static ItemData SerializeItem(Item item)
        {
            return new ItemData
            {
                itemid = item.info.itemid,
                amount = item.amount,
                ammo = item.GetHeldEntity() is BaseProjectile ? (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents :
                               item.GetHeldEntity() is FlameThrower ? (item.GetHeldEntity() as FlameThrower).ammo : 0,
                ammotype = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.ammoType.shortname ?? null,
                position = item.position,
                skin = item.skin,
                condition = item.condition,
                maxCondition = item.maxCondition,
                frequency = ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item)?.GetFrequency() ?? -1,
                instanceData = new ItemData.InstanceData(item),
                contents = item.contents?.itemList.Select(item1 => new ItemData
                {
                    itemid = item1.info.itemid,
                    amount = item1.amount,
                    condition = item1.condition
                }).ToArray()
            };
        }

        public class ItemData
        {
            public int itemid;
            public ulong skin;
            public int amount;
            public float condition;
            public float maxCondition;
            public int ammo;
            public string ammotype;
            public int position;
            public int frequency;
            public InstanceData instanceData;
            public ItemData[] contents;

            public class InstanceData
            {
                public int dataInt;
                public int blueprintTarget;
                public int blueprintAmount;
                public uint subEntity;

                public InstanceData() { }
                public InstanceData(Item item)
                {
                    if (item.instanceData == null)
                        return;

                    dataInt = item.instanceData.dataInt;
                    blueprintAmount = item.instanceData.blueprintAmount;
                    blueprintTarget = item.instanceData.blueprintTarget;
                }

                public void Restore(Item item)
                {
                    if (item.instanceData == null)
                        item.instanceData = new ProtoBuf.Item.InstanceData();

                    item.instanceData.ShouldPool = false;

                    item.instanceData.blueprintAmount = blueprintAmount;
                    item.instanceData.blueprintTarget = blueprintTarget;
                    item.instanceData.dataInt = dataInt;

                    item.MarkDirty();
                }

                public bool IsValid()
                {
                    return dataInt != 0 || blueprintAmount != 0 || blueprintTarget != 0;
                }
            }
        }
        #endregion
        #endregion

        #region Localization
        public static string Message(string key, ulong playerId = 0U) => Instance.lang.GetMessage(key, Instance, playerId != 0U ? playerId.ToString() : null);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Notification.NotEnoughToContinue"] = "There are not enough players to continue the event...",
            ["Notification.NotEnoughToStart"] = "There is not enough players to start the event...",
            ["Notification.EventOpen"] = "The event <color=#007acc>{0}</color> (<color=#007acc>{1}</color>) is open for players\nIt will start in <color=#007acc>{2} seconds</color>\nType <color=#007acc>/event</color> to join",
            ["Notification.EventClosed"] = "The event has been closed to new players",
            ["Notification.EventFinished"] = "The event has finished",
            ["Notification.MaximumPlayers"] = "The event is already at maximum capacity",
            ["Notification.PlayerJoined"] = "<color=#007acc>{0}</color> has joined the <color=#007acc>{1}</color> event!",
            ["Notification.PlayerLeft"] = "<color=#007acc>{0}</color> has left the <color=#007acc>{1}</color> event!",
            ["Notification.RoundStartsIn"] = "Round starts in",
            ["Notification.EventWin"] = "<color=#007acc>{0}</color> won the event!",
            ["Notification.EventWin.Multiple"] = "The following players won the event; <color=#007acc>{0}</color>",
            ["Notification.EventWin.Multiple.Team"] = "<color={0}>Team {1}</color> won the event (<color=#007acc>{2}</color>)",
            ["Notification.Teams.Unbalanced"] = "The teams are unbalanced. Shuffling players...",
            ["Notification.Teams.TeamChanged"] = "You were moved to team <color=#007acc>{0}</color>",
            ["Notification.OutOfBounds"] = "You are out of the playable area. <color=#007acc>Return immediately</color> or you will be killed!",
            ["Notification.OutOfBounds.Time"] = "You have <color=#007acc>{0} seconds</color> to return...",
            ["Notification.Death.Suicide"] = "<color=#007acc>{0}</color> killed themselves...",
            ["Notification.Death.OOB"] = "<color=#007acc>{0}</color> tried to run away...",
            ["Notification.Death.Killed"] = "<color=#007acc>{0}</color> was killed by <color=#007acc>{1}</color>",
            ["Notification.Suvival.Remain"] = "(<color=#007acc>{0}</color> players remain)",
            ["Notification.SpectateCycle"] = "Press <color=#007acc>JUMP</color> to cycle spectate targets",
            ["Info.Event.Current"] = "Current Event: {0} ({1})",
            ["Info.Event.Players"] = "\n{0} / {1} Players",
            ["Info.Event.Status"] = "Status : {0}",
            ["UI.SelectClass"] = "Select a class to continue...",
            ["UI.Death.Killed"] = "You were killed by {0}",
            ["UI.Death.Suicide"] = "You are dead...",
            ["UI.Death.OOB"] = "Don't wander off...",            
            ["Error.CommandBlacklisted"] = "You can not run that command whilst playing an event",
        };
        #endregion
    }

    namespace EventManagerEx
    {
        public interface IEventPlugin
        {            
            bool InitializeEvent(EventManager.EventConfig config);

            void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, out string score1, out string score2);

            List<EventManager.EventParameter> AdditionalParameters { get; }

            string ParameterIsValid(string fieldName, object value);

            bool CanUseClassSelector { get; }

            bool RequireTimeLimit { get; }

            bool RequireScoreLimit { get; }

            bool UseScoreLimit { get; }

            bool UseTimeLimit { get; }

            bool IsTeamEvent { get; }
        }
    }
}



// --- End of file: EventManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/explosive-fuse-changer ---
// --- Original File Path: E/ExplosiveFuseChanger/ExplosiveFuseChanger.cs ---

﻿using System;
using Newtonsoft.Json;


namespace Oxide.Plugins
{
    [Info("Explosive Fuse Changer", "Hockeygel23", "0.0.3")]
    [Description("Changes the fuse time of certain explosives")]
    public class ExplosiveFuseChanger : RustPlugin
    {
        #region Vars
        private const string Permission = "ExplosiveFuseChanger.Use";
        private const string C4PrefabName = "explosive.timed.entity";
        private const string SatchelPrefabName = "explosive.satchel.entity";
        private const string BeanCanPrefabName = "grenade.beancan.entity";
        private const string F1NadePrefabName = "grenade.f1.entity";
        private const string SmokeNadePrefabName = "smoke_grenade.weapon";
        private const string SurveyChargePrefabName = "survey_charge";
        private static ConfigData config;

        #endregion

        #region Init
        private void Init()
        {
            permission.RegisterPermission(Permission, this);
        }

        #endregion

        #region Config

        private class ConfigData
        {
            [JsonProperty("C4 Fuse Time")]
            public float C4FuseTime;

            [JsonProperty("Satchel Fuse Time")]
            public float SatchelFuseTime;

            [JsonProperty( "BeanCan Fuse Time")]
            public float BeancanFuseTime;

            [JsonProperty("Survey Charge Fuse Time")]
            public float SurveyChargeFuseTime;

            [JsonProperty("F1 Explosive Time")]
            public float F1NadeFuseTime;

            [JsonProperty("Smoke Granade Fuse Time")]
            public float SmokeNadeFuseTime;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                C4FuseTime = 5,
                SatchelFuseTime = 5,
                BeancanFuseTime = 5,
                SurveyChargeFuseTime = 4,
                F1NadeFuseTime = 3,
                SmokeNadeFuseTime = 4
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        #endregion

        #region OxideHooks
        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item)
        {
            if(!permission.UserHasPermission(player.UserIDString, Permission))
            {
                return;
            }
            var Explosive = entity as TimedExplosive;

            switch (item.ShortPrefabName)
            {
                case C4PrefabName:
                    Explosive.SetFuse(config.C4FuseTime);
                    break;

                case SatchelPrefabName:
                    Explosive.SetFuse(config.SatchelFuseTime);
                    break;

                case F1NadePrefabName:
                    Explosive.SetFuse(config.F1NadeFuseTime);
                    break;

                case BeanCanPrefabName:
                    Explosive.SetFuse(config.BeancanFuseTime);
                    break;

                case SmokeNadePrefabName:
                    Explosive.SetFuse(config.SmokeNadeFuseTime);
                    break;

                case SurveyChargePrefabName:
                    Explosive.SetFuse(config.SurveyChargeFuseTime);
                    break;
            }
        }
        #endregion

        private void Unload()
        {
            config = null;
        }
    }
}

// --- End of file: ExplosiveFuseChanger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/enhanced-hammer ---
// --- Original File Path: E/EnhancedHammer/EnhancedHammer.cs ---

﻿//#define DEBUG

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Enhanced Hammer", "misticos", "2.1.1")]
    [Description("Upgrade your buildings easily with a hammer")]
    public class EnhancedHammer : CovalencePlugin
    {
        #region Variables

        private static EnhancedHammer _ins;

        private HashSet<BasePlayer> _activePlayers = new HashSet<BasePlayer>();

        private readonly int _maskConstruction = LayerMask.GetMask("Construction");

        private const string PermissionUse = "enhancedhammer.use";
        private const string PermissionFree = "enhancedhammer.free";
        private const string PermissionDowngrade = "enhancedhammer.downgrade";
        private const string PermissionGradeHit = "enhancedhammer.grade.hit";
        private const string PermissionGradeClick = "enhancedhammer.grade.click";
        private const string PermissionGradeBuild = "enhancedhammer.grade.build";

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands =
            {
                "eh",
                "hammer",
                "up",
                "grade",
                "upgrade",
                "bgrade"
            };

            [JsonProperty("Allowed Grades", ItemConverterType = typeof(StringEnumConverter),
                NullValueHandling = NullValueHandling.Ignore)]
            public BuildingGrade.Enum[] OldGradesAllowed = null;

            [JsonProperty("Grades Enabled", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<GradeConfig> GradesEnabled = new List<GradeConfig>
            {
                new GradeConfig { GradeName = BuildingGrade.Enum.Wood.ToString() },
                new GradeConfig { GradeName = BuildingGrade.Enum.Stone.ToString() },
                new GradeConfig { GradeName = BuildingGrade.Enum.Metal.ToString() },
                new GradeConfig { GradeName = BuildingGrade.Enum.TopTier.ToString() }
            };

            [JsonProperty(PropertyName = "Distance From Entity")]
            public float Distance = 3.0f;

            [JsonProperty(PropertyName = "Allow Auto Grade")]
            public bool AutoGrade = true;

            [JsonProperty(PropertyName = "Send Downgrade Disabled Message")]
            public bool DowngradeMessage = true;

            [JsonProperty(PropertyName = "Cancel Default Hammer Hit Behavior")]
            public bool CancelHammerHitDefaultBehavior = true;

            [JsonProperty(PropertyName = "Default Preferences")]
            public PlayerPreferences Preferences = new PlayerPreferences();

            public class GradeConfig
            {
                [JsonProperty("Grade")]
                public string GradeName = BuildingGrade.Enum.Stone.ToString();

                [JsonIgnore]
                public BuildingGrade.Enum Grade = BuildingGrade.Enum.None;

                [JsonProperty("Skin")]
                public ulong? Skin = null;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }

            if (_config == null)
                return;

            if (_config.OldGradesAllowed != null)
            {
                _config.GradesEnabled.Clear();

                foreach (var grade in _config.OldGradesAllowed)
                {
                    _config.GradesEnabled.Add(new Configuration.GradeConfig { Grade = grade });
                }

                _config.OldGradesAllowed = null;
                SaveConfig();
            }

            foreach (var grade in _config.GradesEnabled)
            {
                if (!Enum.TryParse(grade.GradeName, true, out grade.Grade) ||
                    !Enum.IsDefined(typeof(BuildingGrade.Enum), grade.Grade))
                {
                    grade.Grade = BuildingGrade.Enum.None;
                    PrintWarning($"Grade '{grade.GradeName}' was not found");
                }
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Work with Data

        private void DeleteOldData() => Interface.Oxide.DataFileSystem.DeleteDataFile(Name);

        private void ConvertOldData()
        {
            var oldData = LoadOldData();
            if (oldData == null)
                return;

            foreach (var kvp in oldData.Preferences)
            {
                var preference = PlayerPreferences.GetOrCreate(kvp.Key);

                preference.AutoGrade = kvp.Value.AutoGrade;
                preference.DisableIn = kvp.Value.DisableIn;

                PlayerPreferences.Save(kvp.Key);
            }

            PrintWarning($"Converted {oldData.Preferences.Count} player preferences into new format");

            DeleteOldData();
        }

        private PluginData LoadOldData()
        {
            try
            {
                return Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            return null;
        }

        private class PluginData
        {
            [JsonProperty(PropertyName = "Player Preferences")]
            public Dictionary<string, OldPreference> Preferences = new Dictionary<string, OldPreference>();

            [Serializable]
            public class OldPreference
            {
                public float DisableIn = 30f;

                public bool AutoGrade = true;
            }
        }

        private abstract class SplitDatafile<T> where T : SplitDatafile<T>, new()
        {
            public static Dictionary<string, T> LoadedData = new Dictionary<string, T>();

            protected static string[] GetFiles(string baseFolder)
            {
                try
                {
                    var json = ".json".Length;
                    var paths = Interface.Oxide.DataFileSystem.GetFiles(baseFolder);
                    for (var i = 0; i < paths.Length; i++)
                    {
                        var path = paths[i];
                        var separatorIndex = path.LastIndexOf(Path.DirectorySeparatorChar);

                        // We have to do this since GetFiles returns paths instead of filenames
                        // And other methods require filenames
                        paths[i] = path.Substring(separatorIndex + 1, path.Length - separatorIndex - 1 - json);
                    }

                    return paths;
                }
                catch
                {
                    return Array.Empty<string>();
                }
            }

            protected static T Save(string baseFolder, string filename)
            {
                T data;
                if (!LoadedData.TryGetValue(filename, out data))
                    return null;

                Interface.Oxide.DataFileSystem.WriteObject(baseFolder + filename, data);
                return data;
            }

            protected static T Get(string baseFolder, string filename)
            {
                T data;
                if (LoadedData.TryGetValue(filename, out data))
                    return data;

                return null;
            }

            protected static T GetOrLoad(string baseFolder, string filename)
            {
                T data;
                if (LoadedData.TryGetValue(filename, out data))
                    return data;

                try
                {
                    data = Interface.Oxide.DataFileSystem.ReadObject<T>(baseFolder + filename);
                }
                catch (Exception e)
                {
                    Interface.Oxide.LogError(e.ToString());
                }

                return LoadedData[filename] = data;
            }

            protected static T GetOrCreate(string baseFolder, string path)
            {
                return GetOrLoad(baseFolder, path) ?? (LoadedData[path] = new T().SetDefaults());
            }

            protected virtual T SetDefaults()
            {
                throw new NotImplementedException();
            }
        }

        private class PlayerPreferences : SplitDatafile<PlayerPreferences>
        {
            // State

            [JsonIgnore]
            public BuildingGrade.Enum Grade = BuildingGrade.Enum.None;

            [JsonIgnore]
            public ulong Skin = 0ul;

            [JsonIgnore]
            public DateTime? LastUsed = null;

            [JsonIgnore]
            public bool Enabled => LastUsed != null;

            // Preferences

            public float? DisableIn = 30f;

            public bool AutoGrade = true;

            public void ResetState()
            {
                Grade = BuildingGrade.Enum.None;
                Skin = 0ul;

                LastUsed = null;
            }

            public static readonly string BaseFolder =
                nameof(EnhancedHammer) + Path.DirectorySeparatorChar + "Preferences" + Path.DirectorySeparatorChar;

            public static string[] GetFiles() => GetFiles(BaseFolder);
            public static PlayerPreferences Save(string filename) => Save(BaseFolder, filename);
            public static PlayerPreferences Get(string filename) => Get(BaseFolder, filename);
            public static PlayerPreferences GetOrLoad(string filename) => GetOrLoad(BaseFolder, filename);
            public static PlayerPreferences GetOrCreate(string filename) => GetOrCreate(BaseFolder, filename);

            protected override PlayerPreferences SetDefaults()
            {
                var defaults = _ins._config.Preferences;

                DisableIn = defaults.DisableIn;
                AutoGrade = defaults.AutoGrade;

                return this;
            }
        }

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Command: No Permission", $"You do not have enough permissions for that ({PermissionUse})" },
                { "Command: Player Only", "You must be an in-game player to use this command" },
                { "Command: Invalid Grade", "You have entered an invalid grade" },
                { "Command: Timeout", "Current timeout: {timeout}" },
                { "Command: Auto Grade: Enabled", "You have enabled automatic toggle for grading" },
                { "Command: Auto Grade: Disabled", "You have disabled automatic toggle for grading" },
                { "Command: Auto Grade: Force Disabled", "Auto Grade is disabled on this server" },
                {
                    "Command: Syntax", "Grade command syntax:\n" +
                                       "(grade) - Set current grade to a specific value\n" +
                                       "timeout (Time in seconds) - Disable grading in X seconds\n" +
                                       "autograde (True/False) - Toggle automatic grading toggle"
                },
                { "Grade: Changed", "Current grade: {grade}" },
                { "Grade: No Downgrade", "Downgrading is not allowed on this server" },
                { "Grade: Building Blocked", "You cannot build there" },
                { "Grade: Upgrade Blocked", "You cannot upgrade this" },
                { "Grade: Insufficient Resources", "You cannot afford this upgrade" },
                { "Grade: Recently Damaged", "This entity was recently damaged" }
            }, this);
        }

        private void Init()
        {
            _ins = this;

            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionFree, this);
            permission.RegisterPermission(PermissionDowngrade, this);
            permission.RegisterPermission(PermissionGradeHit, this);
            permission.RegisterPermission(PermissionGradeClick, this);
            permission.RegisterPermission(PermissionGradeBuild, this);

            if (!_config.AutoGrade)
                Unsubscribe(nameof(OnStructureUpgrade));

            ConvertOldData();

            AddCovalenceCommand(_config.Commands, nameof(CommandGrade));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerDisconnected(player);

            PlayerPreferences.LoadedData.Clear();

            _ins = null;
        }

        private void OnPlayerDisconnected(BasePlayer basePlayer)
        {
            var preferences = PlayerPreferences.Save(basePlayer.UserIDString);

            preferences?.ResetState();

            CancelTimeoutUpdate(basePlayer.UserIDString);
        }

        private object OnHammerHit(BasePlayer basePlayer, HitInfo info)
        {
            var preferences = PlayerPreferences.GetOrCreate(basePlayer.UserIDString);
            if (!preferences.Enabled)
                return null;

            var block = info.HitEntity as BuildingBlock;
            if (block == null)
                return null;

            if (!CanUse(basePlayer.IPlayer, GradingType.Hit))
                return null;

            Upgrade(basePlayer, preferences, block, false);

            return _config.CancelHammerHitDefaultBehavior ? false : (object)null;
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null)
                return;

            var preferences = PlayerPreferences.GetOrCreate(player.UserIDString);
            if (!preferences.Enabled)
            {
#if DEBUG
                Puts($"{nameof(OnEntityBuilt)} ({player.UserIDString}) > Ignored: Disabled");
#endif
                return;
            }

            if (!CanUse(player.IPlayer, GradingType.Build))
            {
#if DEBUG
                Puts($"{nameof(OnEntityBuilt)} ({player.UserIDString}) > Ignored: Cannot use");
#endif
                return;
            }

            var block = gameObject.ToBaseEntity() as BuildingBlock;
            if (block == null)
            {
#if DEBUG
                Puts($"{nameof(OnEntityBuilt)} ({player.UserIDString}) > Ignored: No building block");
#endif
                return;
            }

            Upgrade(player, preferences, block, false);
        }

        private void OnStructureUpgrade(BuildingBlock block, BasePlayer basePlayer, BuildingGrade.Enum grade,
            ulong skin)
        {
            var preferences = PlayerPreferences.GetOrCreate(basePlayer.UserIDString);
            if (!preferences.AutoGrade)
                return;

            // Ignore if upgrading the same tier and enabled
            // (To enable if not)
            if (preferences.Enabled && preferences.Grade == grade && preferences.Skin == skin)
                return;

            if (!CanUse(basePlayer.IPlayer, GradingType.Use))
                return;

            SetActiveGrade(basePlayer, preferences, grade, skin, false);
        }

        private void OnPlayerInput(BasePlayer basePlayer, InputState input)
        {
            if (!input.IsDown(BUTTON.FIRE_PRIMARY))
                return;

            if (!(basePlayer.GetHeldEntity() is Hammer))
                return;

            var preferences = PlayerPreferences.GetOrCreate(basePlayer.UserIDString);
            if (!preferences.Enabled)
                return;

            if (!CanUse(basePlayer.IPlayer, GradingType.Click))
                return;

            RaycastHit hit;
            if (!Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, _ins._config.Distance, _ins._maskConstruction))
                return;

            var block = hit.GetEntity() as BuildingBlock;
            if (block == null)
                return;

            Upgrade(basePlayer, preferences, block, true);
        }

        #endregion

        #region Commands

        private void CommandGrade(IPlayer player, string command, string[] args)
        {
            if (!CanUse(player, GradingType.Use))
            {
                player.Reply(GetMsg("Command: No Permission", player.Id));
                return;
            }

            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                player.Reply(GetMsg("Command: Player Only", player.Id));
                return;
            }

            if (args.Length == 0)
                goto syntax;

            switch (args[0].ToLower())
            {
                default:
                {
                    BuildingGrade.Enum grade;
                    if (!Enum.TryParse(args[0], true, out grade) || grade > BuildingGrade.Enum.TopTier ||
                        grade < BuildingGrade.Enum.None)
                    {
                        player.Reply(GetMsg("Command: Invalid Grade", player.Id));
                        return;
                    }

                    var preferences = PlayerPreferences.GetOrCreate(player.Id);

                    SetActiveGrade(basePlayer, preferences, grade, 0ul, false);
                    return;
                }

                case "t":
                case "timeout":
                {
                    if (args.Length < 2)
                        goto syntax;

                    float? timeout = null;
                    float parsedTimeout;
                    if (float.TryParse(args[1], out parsedTimeout))
                        timeout = parsedTimeout;

                    PlayerPreferences.GetOrCreate(player.Id).DisableIn = timeout;

                    player.Reply(GetMsg("Command: Timeout", player.Id)
                        .Replace("{timeout}", parsedTimeout.ToString("0.##")));

                    return;
                }

                case "ag":
                case "autograde":
                {
                    if (args.Length < 2)
                        goto syntax;

                    if (!_config.AutoGrade)
                    {
                        player.Reply(GetMsg("Command: Auto Grade: Force Disabled", player.Id));

                        return;
                    }

                    bool autograde;
                    if (!bool.TryParse(args[1], out autograde))
                        goto syntax;

                    PlayerPreferences.GetOrCreate(player.Id).AutoGrade = autograde;

                    player.Reply(GetMsg("Command: Auto Grade: " + (autograde ? "Enabled" : "Disabled"),
                        player.Id));

                    return;
                }
            }

            syntax:
            player.Reply(GetMsg("Command: Syntax", player.Id));
        }

        #endregion

        #region Availability Timers

        private Dictionary<string, Timer> _availabilityTimers = new Dictionary<string, Timer>();

        private void UpdateTimeout(BasePlayer basePlayer, PlayerPreferences preferences)
        {
            if (!preferences.Enabled || !preferences.DisableIn.HasValue)
                return;

            // ReSharper disable once PossibleInvalidOperationException
            var timePassed = (float)(DateTime.UtcNow - preferences.LastUsed.Value).TotalSeconds;
            var timeLeft = preferences.DisableIn.Value - timePassed;

#if DEBUG
            Puts($"{nameof(UpdateTimeout)} ({basePlayer.UserIDString}) > {timePassed:F1}s passed, {timeLeft:F1}s left");
#endif

            if (timeLeft < 0)
            {
                SetActive(basePlayer, preferences, false);
                return;
            }

            CancelTimeoutUpdate(basePlayer.UserIDString);

            _availabilityTimers[basePlayer.UserIDString] =
                timer.In(timeLeft, () => UpdateTimeout(basePlayer, preferences));
        }

        private void CancelTimeoutUpdate(string id)
        {
            Timer t;
            if (_availabilityTimers.TryGetValue(id, out t))
                timer.Destroy(ref t);
        }

        #endregion

        private void SetActiveGrade(BasePlayer basePlayer, PlayerPreferences preferences, BuildingGrade.Enum grade,
            ulong skin, bool suppressMessages)
        {
            if (preferences.Grade == grade && preferences.Skin == skin)
                return;

            if (grade > BuildingGrade.Enum.TopTier || grade < BuildingGrade.Enum.None)
                return;

            if (grade != BuildingGrade.Enum.None && !IsGradeEnabled(grade, skin))
                return;

            preferences.Grade = grade;
            preferences.Skin = skin;

            if (grade != BuildingGrade.Enum.None)
                SetActive(basePlayer, preferences, true);

            if (!suppressMessages)
            {
                var player = basePlayer.IPlayer;
                player.Message(GetMsg("Grade: Changed", player.Id)
                    .Replace("{grade}", grade.ToString()));
            }
        }

        private void SetActive(BasePlayer basePlayer, PlayerPreferences preferences, bool isActive)
        {
#if DEBUG
            Puts($"{nameof(SetActive)} ({basePlayer.UserIDString}) > {preferences.Enabled} -> {isActive}");
#endif

            if (preferences.Enabled == isActive)
            {
                if (!isActive)
                    return;

                // Update timeout if already active
                preferences.LastUsed = DateTime.UtcNow;
                UpdateTimeout(basePlayer, preferences);
                return;
            }

            if (isActive)
            {
                preferences.LastUsed = DateTime.UtcNow;

                _activePlayers.Add(basePlayer);
            }
            else
            {
                SetActiveGrade(basePlayer, preferences, BuildingGrade.Enum.None, 0ul, false);

                preferences.LastUsed = null;

                _activePlayers.Remove(basePlayer);
            }

            UpdateTimeout(basePlayer, preferences);

            if (_activePlayers.Count == 0) // -> 0
                Unsubscribe(nameof(OnPlayerInput));
            else if (isActive && _activePlayers.Count == 1) // 0 -> 1
                Subscribe(nameof(OnPlayerInput));
        }

        private void Upgrade(BasePlayer basePlayer, PlayerPreferences preferences, BuildingBlock block,
            bool suppressMessages)
        {
            // Ensure it's active and update the timeout
            SetActive(basePlayer, preferences, true);

            // Ignore if there is no need to upgrade
            if (preferences.Grade == block.grade && preferences.Skin == block.skinID)
            {
#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: Same grade");
#endif
                return;
            }

            var player = basePlayer.IPlayer;

            if (preferences.Grade < block.grade && !player.HasPermission(PermissionDowngrade))
            {
                if (!suppressMessages && _config.DowngradeMessage)
                {
                    player.Message(GetMsg("Grade: No Downgrade", player.Id));
                }

#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: No downgrade");
#endif
                return;
            }

            if (basePlayer.IsBuildingBlocked(block.transform.position, block.transform.rotation, block.bounds))
            {
                if (!suppressMessages)
                {
                    player.Message(GetMsg("Grade: Building Blocked", player.Id));
                }

#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: Building blocked");
#endif
                return;
            }

            if (block.IsUpgradeBlocked())
            {
                if (!suppressMessages)
                {
                    player.Message(GetMsg("Grade: Upgrade Blocked", player.Id));
                }

#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: Upgrade blocked");
#endif
                return;
            }

            if (block.SecondsSinceAttacked <= 30f)
            {
                if (!suppressMessages)
                {
                    player.Message(GetMsg("Grade: Recently Damaged", player.Id));
                }

#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: Recently damaged");
#endif
                return;
            }

            var grade = block.blockDefinition.GetGrade(preferences.Grade, preferences.Skin);
            if (grade == null)
            {
                PrintWarning($"'{nameof(grade)}' == null! Contact the plugin developer as this should never happen");
                return;
            }

            var hookResult =
                Interface.CallHook("CanChangeGrade", basePlayer, block, preferences.Grade, preferences.Skin);

            if (hookResult is bool && !(bool)hookResult)
            {
#if DEBUG
                Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: CanChangeGrade returned false");
#endif
                return;
            }

            if (!player.HasPermission(PermissionFree))
            {
                var costToBuild = grade.CostToBuild(block.grade);
                foreach (var item in costToBuild)
                {
                    if (basePlayer.inventory.GetAmount(item.itemid) >= item.amount)
                        continue;

                    if (!suppressMessages)
                    {
                        player.Message(GetMsg("Grade: Insufficient Resources", player.Id));
                    }

#if DEBUG
                    Puts($"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Ignored: Insufficient resources");
#endif
                    return;
                }

                var items = Pool.GetList<Item>();
                foreach (var item in costToBuild)
                {
                    basePlayer.inventory.Take(items, item.itemid, (int)item.amount);
                    basePlayer.Command("note.inv", item.itemid, item.amount * -1f);
                }

                foreach (var item in items)
                {
                    item.Remove();
                }

                ItemManager.DoRemoves();
                Pool.FreeList(ref items);
            }

#if DEBUG
            Puts(
                $"{nameof(Upgrade)} ({basePlayer.UserIDString}) > Upgraded to {preferences.Grade} ({preferences.Skin})");
#endif

            block.ClientRPC(null, "DoUpgradeEffect", (int)preferences.Grade, preferences.Skin);
            block.skinID = preferences.Skin;
            block.ChangeGrade(preferences.Grade, true);
        }

        #region Helpers

        private enum GradingType : byte
        {
            Use,
            Hit,
            Click,
            Build
        }

        private bool IsGradeEnabled(BuildingGrade.Enum grade, ulong skin)
        {
            foreach (var gradeEnabled in _config.GradesEnabled)
            {
                if (gradeEnabled.Grade != grade)
                {
                    continue;
                }

                if (gradeEnabled.Skin == null)
                {
                    return true;
                }

                if (gradeEnabled.Skin == skin)
                {
                    return true;
                }
            }

            return false;
        }

        private static bool CanUse(IPlayer player, GradingType type)
        {
            if (_ins == null)
                return false;

            if (!player.HasPermission(PermissionUse))
                return false;

            switch (type)
            {
                case GradingType.Hit:
                {
                    return player.HasPermission(PermissionGradeHit);
                }

                case GradingType.Click:
                {
                    return player.HasPermission(PermissionGradeClick);
                }

                case GradingType.Build:
                {
                    return player.HasPermission(PermissionGradeBuild);
                }

                default:
                {
                    return true;
                }
            }
        }

        private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);

        #endregion
    }
}

// --- End of file: EnhancedHammer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/emote ---
// --- Original File Path: E/Emote/Emote.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System;

namespace Oxide.Plugins
{
    [Info("Emote", "Hirsty", "1.0.12", ResourceId = 1353)]
    [Description("This will allow players to express their feelings!")]
    class Emote : CovalencePlugin
    {
		public static Dictionary<string, object> ChatDict = new Dictionary<string, object>();
        public static string version = "1.0.10";
        public string template = "";
        public string EnableEmotes = "false";
        #region Config Data
        protected override void LoadDefaultConfig()
        {

            PrintWarning("Whoops! No config file, lets create a new one!"); // Runs when no configuration file has been found
            Config.Clear();
            Config["Plugin", "Version"] = version;
            Config["Config", "Text"] = "<color=#f0f0f0><i><b>{Player}</b> {Message}</i></color>";
            Config["Config", "EnableEmotes"] = "false";
            Config["Config", "BetterChat"] = "false";
            Config["Emotes", ":)"] = "smiles";
            Config["Emotes", ":-)"] = "smiles";
            Config["Emotes", ":=)"] = "smiles";
            Config["Emotes", ":("] = "sulks";
            Config["Emotes", ":-("] = "sulks";
            Config["Emotes", ":=("] = "sulks";
            Config["Emotes", ":D"] = "grins";
            Config["Emotes", ":-D"] = "grins";
            Config["Emotes", ":=D"] = "grins";
            Config["Emotes", ":d"] = "grins";
            Config["Emotes", ":-d"] = "grins";
            Config["Emotes", ":=d"] = "grins";
            Config["Emotes", ":|"] = "is speechless";
            Config["Emotes", ":-|"] = "is speechless";
            Config["Emotes", ":=|"] = "is speechless";
            Config["Emotes", ":p"] = "sticks out a tongue";
            Config["Emotes", ":-p"] = "sticks out a tongue";
            Config["Emotes", ":=p"] = "sticks out a tongue";
            Config["Emotes", ":P"] = "sticks out a tongue";
            Config["Emotes", ":-P"] = "sticks out a tongue";
            Config["Emotes", ":=P"] = "sticks out a tongue";
            Config["Emotes", ":$"] = "blushes";
            Config["Emotes", ":-$"] = "blushes";
            Config["Emotes", ":=$"] = "blushes";
            Config["Emotes", "]:)"] = "gives an evil grin";
            Config["Emotes", ">:)"] = "gives an evil grin";
            Config["Emotes", ":*"] = "blows a kiss";
            Config["Emotes", ":-*"] = "blows a kiss";
            Config["Emotes", ":=*"] = "blows a kiss";
            Config["Emotes", ":@"] = "looks angry";
            Config["Emotes", ":-@"] = "looks angry";
            Config["Emotes", ":=@"] = "looks angry";
            Config["Emotes", "x("] = "looks angry";
            Config["Emotes", "x-("] = "looks angry";
            Config["Emotes", "x=("] = "looks angry";
            Config["Emotes", "X("] = "looks angry";
            Config["Emotes", "X-("] = "looks angry";
            Config["Emotes", "X=("] = "looks angry";
            Config["Emotes", "o/"] = "waves";
            Config["Emotes", "\\o"] = "waves back";
            SaveConfig();
        }
        private void Loaded() => LoadConfigData(); // What to do when plugin loaded
        [PluginReference] Plugin BetterChat;
        [PluginReference] Plugin BetterChatMute;
        private void LoadConfigData()
        {
            if(BetterChat){
                Puts("We found BetterChat! Enabling Support.");
                Config["Config", "BetterChat"] = "true";
            } else {
                Puts("No BetterChat found! Disabling Support.");
                Config["Config", "BetterChat"] = "false";
            }
            if (Config["Plugin", "Version"].ToString() != version)
            {
                Puts("Uh oh! Not up to date! No Worries, lets update you!");
                switch (version)
                {
                    case "1.0.1":
                        Config["Config", "EnableEmotes"] = "false";
                        Config["Emotes", ":)"] = "smiles";
                        Config["Emotes", ":-)"] = "smiles";
                        Config["Emotes", ":=)"] = "smiles";
                        Config["Emotes", ":("] = "sulks";
                        Config["Emotes", ":-("] = "sulks";
                        Config["Emotes", ":=("] = "sulks";
                        Config["Emotes", ":D"] = "grins";
                        Config["Emotes", ":-D"] = "grins";
                        Config["Emotes", ":=D"] = "grins";
                        Config["Emotes", ":d"] = "grins";
                        Config["Emotes", ":-d"] = "grins";
                        Config["Emotes", ":=d"] = "grins";
                        Config["Emotes", ":|"] = "is speechless";
                        Config["Emotes", ":-|"] = "is speechless";
                        Config["Emotes", ":=|"] = "is speechless";
                        Config["Emotes", ":p"] = "sticks out a tongue";
                        Config["Emotes", ":-p"] = "sticks out a tongue";
                        Config["Emotes", ":=p"] = "sticks out a tongue";
                        Config["Emotes", ":P"] = "sticks out a tongue";
                        Config["Emotes", ":-P"] = "sticks out a tongue";
                        Config["Emotes", ":=P"] = "sticks out a tongue";
                        Config["Emotes", ":$"] = "blushes";
                        Config["Emotes", ":-$"] = "blushes";
                        Config["Emotes", ":=$"] = "blushes";
                        Config["Emotes", "]:)"] = "gives an evil grin";
                        Config["Emotes", ">:)"] = "gives an evil grin";
                        Config["Emotes", ":*"] = "blows a kiss";
                        Config["Emotes", ":-*"] = "blows a kiss";
                        Config["Emotes", ":=*"] = "blows a kiss";
                        Config["Emotes", ":@"] = "looks angry";
                        Config["Emotes", ":-@"] = "looks angry";
                        Config["Emotes", ":=@"] = "looks angry";
                        Config["Emotes", "x("] = "looks angry";
                        Config["Emotes", "x-("] = "looks angry";
                        Config["Emotes", "x=("] = "looks angry";
                        Config["Emotes", "X("] = "looks angry";
                        Config["Emotes", "X-("] = "looks angry";
                        Config["Emotes", "X=("] = "looks angry";
                        Config["Emotes", "o/"] = "waves";
                        Config["Emotes", "\\o"] = "waves back";
                        break;
                    case "1.0.6":
                        Config["Config", "BetterChat"] = "false";
                        break;

                }
                Config["Plugin", "Version"] = version;
                Config.Save();
            }
            template = Config["Config", "Text"].ToString();
            EnableEmotes = Config["Config", "EnableEmotes"].ToString();

        }
        #endregion
        #region Hooks
        [HookMethod("CheckForEmotes")]
        public string EmoteCheck(IPlayer player, string checkmsg)
        {
            if (Config["Emotes", checkmsg] != null && EnableEmotes == "true")
            {
                string emote = Config["Emotes", checkmsg].ToString();

                string build = template;
                build = build.Replace("{Player}", player.Name);
                build = build.Replace("{Message}",  emote);
                return build;
            }
            else
            {
                return checkmsg;
            }
        }
        #endregion
        #region Chat Commands
        [Command("me"), Permission("emote.use")] // Whatever cammand you want the player to type
        object MeCommand(IPlayer player, string command, string[] args)
        {
            if (player.LastCommand == CommandType.Console) return null;
            string uid = player.Id.ToString();
			object muted = BetterChatMute?.Call("CheckMuted",player.Id);
            if(muted is bool && !(bool)muted){
                    return false;
            }
            string full = string.Join(" ", args);
            SendChatMessage(player, full);
            return true;
        
        }
        #endregion
		
        object OnBetterChat(Dictionary<string, object> Chat){
			IPlayer player = (IPlayer)Chat["Player"];
			if (Config["Emotes", Chat["Message"].ToString()] != null && EnableEmotes == "true" && player.HasPermission("emote.use"))
           { 
				return false;
		   }
		   return Chat;
		}
        object OnUserChat(IPlayer player, string message)
        {
           string uid = player.Id;
           if (Config["Emotes", message] != null && EnableEmotes == "true" && player.HasPermission("emote.use"))
           {
					SendChatMessage(player, Config["Emotes", message].ToString());
				
				return false;
            }
            return null;
        }
        object SendChatMessage(IPlayer player, string msg)
        {
            string build = template;
            build = build.Replace("{Player}", player.Name);
            build = build.Replace("{Message}", msg);
            server.Broadcast(build);
            //Puts(player.Name + " emoted: " + msg);
            return true;
        }
    }
}

// --- End of file: Emote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/eternal-plants ---
// --- Original File Path: E/EternalPlants/EternalPlants.cs ---

﻿using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Eternal Plants", "0x89A", "1.0.1")]
    [Description("Plants do not die after they are full grown")]
    class EternalPlants : RustPlugin
    {
        private const string _usePerm = "eternalplants.use";
        
        private void Init()
        {
            permission.RegisterPermission(_usePerm, this);
        }

        private object OnGrowableStateChange(GrowableEntity entity, PlantProperties.State state)
        {
            // (entity.harvests < entity.Properties.maxHarvests) - so plant dies when gathered.
            if (HasPermission(entity.OwnerID) && state == PlantProperties.State.Dying && entity.harvests < entity.Properties.maxHarvests)
            {
                entity.stageAge = entity.currentStage.lifeLengthSeconds;
                entity.Heal(100f);
                return true;
            }

            return null;
        }

        private bool HasPermission(ulong id)
        {
            return (_config.eternalOwnerless && id == 0) || permission.UserHasPermission(id.ToString(), _usePerm);
        }

        #region -Configuration-

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Ownerless plants don't die")]
            public bool eternalOwnerless = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}


// --- End of file: EternalPlants.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/rust-kits ---
// --- Original File Path: K/Kits/Kits.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "k1lly0u", "4.4.7"), Description("Create kits containing items that players can redeem")]
    class Kits : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin CopyPaste, ImageLibrary, ServerRewards, Economics;

        private DateTime _deprecatedHookTime = new DateTime(2021, 12, 31);

        private Hash<ulong, KitData.Kit> _kitCreators = new Hash<ulong, KitData.Kit>();

        private const string ADMIN_PERMISSION = "kits.admin";

        private const string BLUEPRINT_BASE = "blueprintbase";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            LoadData();

            permission.RegisterPermission(ADMIN_PERMISSION, this);
            kitData.RegisterPermissions(permission, this);

            _costType = ParseType<CostType>(Configuration.Currency);

            cmd.AddChatCommand(Configuration.Command, this, cmdKit);
            cmd.AddConsoleCommand(Configuration.Command, this, "ccmdKit");
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {
            LastWipeTime = SaveRestore.SaveCreatedTime.Subtract(Epoch).TotalSeconds;

            kitData.RegisterImages(ImageLibrary);

            CheckForShortnameUpdates();

            if (Configuration.AutoKits.Count == 0)
                Unsubscribe(nameof(OnPlayerRespawned));
        }

        private void OnNewSave(string filename)
        {
            if (Configuration.WipeData)
                playerData.Wipe();
        }

        private void OnServerSave() => SavePlayerData();

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (!player)
                return;

            if ((Interface.Oxide.CallDeprecatedHook("canRedeemKit", "CanRedeemKit", _deprecatedHookTime, player) ?? Interface.Oxide.CallHook("CanRedeemKit", player)) != null)
                return;

            if (Interface.Oxide.CallHook("CanRedeemAutoKit", player) != null)
                return;

            if (Configuration.AllowAutoToggle && !playerData[player.userID].ClaimAutoKits)
            {
                player.ChatMessage(Message("Error.AutoKitDisabled", player.userID));
                return;
            }

            for (int i = 0; i < Configuration.AutoKits.Count; i++)
            {
                if (!kitData.Find(Configuration.AutoKits[i], out KitData.Kit kit))
                    continue;

                object success = CanClaimKit(player, kit, true);
                if (success != null)
                    continue;

                player.inventory.Strip();

                success = GiveKit(player, kit);
                if (success is string)
                    continue;

                OnKitReceived(player, kit);
                return;
            }
        }

        private void Unload()
        {
            if (!Interface.Oxide.IsShuttingDown)
                SavePlayerData();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.DestroyUi(player, UI_POPUP);
            }

            Configuration = null;
        }
        #endregion

        #region Kit Claiming
        private bool TryClaimKit(BasePlayer player, string name, bool usingUI)
        {
            if (string.IsNullOrEmpty(name))
            {
                if (usingUI)
                    CreateMenuPopup(player, Message("Error.EmptyKitName", player.userID));
                else player.ChatMessage(Message("Error.EmptyKitName", player.userID));
                return false;
            }

            if (!kitData.Find(name, out KitData.Kit kit))
            {
                if (usingUI)
                    CreateMenuPopup(player, Message("Error.InvalidKitName", player.userID));
                else player.ChatMessage(Message("Error.InvalidKitName", player.userID));
                return false;
            }

            object success = CanClaimKit(player, kit) ?? GiveKit(player, kit);
            if (success is string s)
            {
                if (usingUI)
                    CreateMenuPopup(player, s);
                else player.ChatMessage(s);
                return false;
            }

            OnKitReceived(player, kit);
            return true;
        }

        private object CanClaimKit(BasePlayer player, KitData.Kit kit, bool ignoreAuthCost = false)
        {
            object success = Interface.Oxide.CallDeprecatedHook("canRedeemKit", "CanRedeemKit", _deprecatedHookTime, player) ?? Interface.Oxide.CallHook("CanRedeemKit", player);
            if (success != null)
            {
                if (success is string s)
                    return s;
                return Message("Error.CantClaimNow", player.userID);
            }

            if (!ignoreAuthCost && kit.RequiredAuth > 0 && player.net.connection.authLevel < kit.RequiredAuth)
                return Message("Error.CanClaim.Auth", player.userID);

            if (Configuration.AdminIgnoreRestrictions && IsAdmin(player))
            {
                if (!kit.HasSpaceForItems(player))
                    return Message("Error.CanClaim.InventorySpace", player.userID);

                return null;
            }

            if (!string.IsNullOrEmpty(kit.RequiredPermission) && !permission.UserHasPermission(player.UserIDString, kit.RequiredPermission))
                return Message("Error.CanClaim.Permission", player.userID);

            if (Configuration.WipeCooldowns.TryGetValue(kit.Name, out int wipeCooldownTime))
            {
                if (kitData.IsOnWipeCooldown(wipeCooldownTime, out wipeCooldownTime))
                    return string.Format(Message("Error.CanClaim.WipeCooldown", player.userID), FormatTime(wipeCooldownTime));
            }

            if (playerData.Find(player.userID, out PlayerData.PlayerUsageData playerUsageData))
            {
                if (kit.Cooldown > 0)
                {
                    double cooldownRemaining = playerUsageData.GetCooldownRemaining(kit.Name);
                    if (cooldownRemaining > 0)
                        return string.Format(Message("Error.CanClaim.Cooldown", player.userID), FormatTime(cooldownRemaining));
                }

                if (kit.MaximumUses > 0)
                {
                    int currentUses = playerUsageData.GetKitUses(kit.Name);
                    if (currentUses >= kit.MaximumUses)
                        return Message("Error.CanClaim.MaxUses", player.userID);
                }
            }

            if (!kit.HasSpaceForItems(player))
                return Message("Error.CanClaim.InventorySpace", player.userID);

            if (!ignoreAuthCost && kit.Cost > 0)
            {
                if (!ChargePlayer(player, kit.Cost))
                    return string.Format(Message("Error.CanClaim.InsufficientFunds", player.userID), kit.Cost, Message($"Cost.{_costType}", player.userID));
            }

            return null;
        }

        private object GiveKit(BasePlayer player, KitData.Kit kit)
        {
            if (!string.IsNullOrEmpty(kit.CopyPasteFile))
            {
                object success = CopyPaste?.CallHook("TryPasteFromSteamId", player.userID, kit.CopyPasteFile, Configuration.CopyPasteParams, null);
                if (success != null)
                    return success;
            }

            kit.GiveItemsTo(player);

            return true;
        }

        private void OnKitReceived(BasePlayer player, KitData.Kit kit)
        {
            playerData[player.userID].OnKitClaimed(kit);

            Interface.CallHook("OnKitRedeemed", player, kit.Name);

            if (Configuration.LogKitsGiven)
                LogToFile("Kits_Received", $"{player.displayName} ({player.userID}) - Received {kit.Name}", this);
        }
        #endregion

        #region Purchase Costs     
        private CostType _costType;

        private enum CostType { Scrap, ServerRewards, Economics }

        private const int SCRAP_ITEM_ID = -932201673;

        private bool ChargePlayer(BasePlayer player, int amount)
        {
            if (amount == 0)
                return true;

            switch (_costType)
            {
                case CostType.Scrap:
                    if (amount <= player.inventory.GetAmount(SCRAP_ITEM_ID))
                    {
                        player.inventory.Take(null, SCRAP_ITEM_ID, amount);
                        return true;
                    }
                    return false;
                case CostType.ServerRewards:
                    {
                        if ((ServerRewards?.Call<int>("CheckPoints", player.UserIDString) ?? 0) < amount)
                            return false;

                        return (bool)ServerRewards?.Call("TakePoints", player.userID, amount);
                    }
                case CostType.Economics:
                    return (bool)Economics?.Call("Withdraw", player.UserIDString, (double)amount);
            }
            return false;
        }
        #endregion

        #region Helpers
        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                return default(T);
            }
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds(time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (days > 0)
                return $"~{days:00}d:{hours:00}h";
            if (hours > 0)
                return $"~{hours:00}h:{mins:00}m";
            return mins > 0 ? $"{mins:00}m:{secs:00}s" : $"{secs}s";
        }

        private void GetUserValidKits(BasePlayer player, List<KitData.Kit> list, ulong npcId = 0UL)
        {
            bool isAdmin = IsAdmin(player);
            bool viewPermissionKits = Configuration.ShowPermissionKits;

            if (npcId != 0UL)
            {
                if (Configuration.NPCKitMenu.TryGetValue(npcId, out ConfigData.NPCKit npcKit))
                {
                    npcKit.Kits.ForEach(kitName =>
                    {
                        if (kitData.Find(kitName, out KitData.Kit kit))
                        {
                            if (!viewPermissionKits && !string.IsNullOrEmpty(kit.RequiredPermission) && !permission.UserHasPermission(player.UserIDString, kit.RequiredPermission) && !isAdmin)
                                return;

                            if (player.net.connection.authLevel < kit.RequiredAuth)
                                return;

                            list.Add(kit);
                        }
                    });
                }
            }
            else
            {
                kitData.ForEach(kit =>
                {
                    if (kit.IsHidden && !isAdmin)
                        return;

                    if (!viewPermissionKits && !string.IsNullOrEmpty(kit.RequiredPermission) && !permission.UserHasPermission(player.UserIDString, kit.RequiredPermission) && !isAdmin)
                        return;

                    if (player.net.connection.authLevel < kit.RequiredAuth)
                        return;

                    list.Add(kit);
                });
            }
        }

        private bool IsAdmin(BasePlayer player) => permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION);

        private BasePlayer FindPlayer(string partialNameOrID) => BasePlayer.allPlayerList.FirstOrDefault(x => x.UserIDString.Equals(partialNameOrID) ||            
                                                                                                                x.displayName.Equals(partialNameOrID, StringComparison.OrdinalIgnoreCase) ||
                                                                                                                x.displayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase));

        private BasePlayer RaycastPlayer(BasePlayer player)
        {
            if (!Physics.Raycast(new Ray(player.eyes.position, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward), out RaycastHit raycastHit, 5f))
                return null;

            return raycastHit.collider.GetComponentInParent<BasePlayer>();            
        }

        private static DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        private static double LastWipeTime;

        private static double CurrentTime => DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
        #endregion

        #region ImageLibrary        
        private void RegisterImage(string name, string url) => ImageLibrary?.Call("AddImage", url, name.Replace(" ", ""), 0UL, null);

        private string GetImage(string name, ulong skinId = 0UL) => ImageLibrary?.Call<string>("GetImage", name.Replace(" ", ""), skinId, false);
        #endregion

        #region HumanNPC
        private void OnUseNPC(BasePlayer npcPlayer, BasePlayer player)
        {
            if (Configuration.NPCKitMenu.ContainsKey(npcPlayer.userID))            
                OpenKitGrid(player, 0, npcPlayer.userID);            
        }
        #endregion

        #region Deprecated API 
        [HookMethod("isKit")]
        public bool isKit(string name) => IsKit(name);

        [HookMethod("GetAllKits")]
        public string[] GetAllKits() => kitData.Keys.ToArray();

        [HookMethod("KitImage")]
        public string KitImage(string name) => GetKitImage(name);

        [HookMethod("KitDescription")]
        public string KitDescription(string name) => GetKitDescription(name);

        [HookMethod("KitMax")]
        public int KitMax(string name) => GetKitMaxUses(name);

        [HookMethod("KitCooldown")]
        public double KitCooldown(string name) => GetKitCooldown(name);

        [HookMethod("PlayerKitMax")]
        public int PlayerKitMax(ulong playerId, string name) => GetPlayerKitUses(playerId, name);

        [HookMethod("PlayerKitCooldown")]
        public double PlayerKitCooldown(ulong playerId, string name) => GetPlayerKitCooldown(playerId, name);

        [HookMethod("GetKitContents")]
        public string[] GetKitContents(string name)
        {
            if (!kitData.Find(name, out KitData.Kit kit))
                return null;
            
            List<string> items = Pool.Get<List<string>>();
            
            void Append(List<string> items, ItemData[] itemData)
            {
                for (int i = 0; i < itemData.Length; i++)
                {
                    ItemData item = itemData[i];
                    string itemstring = $"{item.ItemID}_{item.Amount}";

                    if (item.Contents is { Length: > 0 })
                    {
                        for (int j = 0; j < item.Contents.Length; j++)
                            itemstring += $"_{item.Contents[j].ItemID}";
                    }

                    if (item.Container != null && item.Container.contents.Count > 0)
                    {
                        for (int j = 0; j < item.Container.contents.Count; j++)
                            itemstring += $"_{item.Container.contents[j].ItemID}";
                    }

                    items.Add(itemstring);
                }
            }
            
            Append(items, kit.BeltItems);
            Append(items, kit.MainItems);
            Append(items, kit.WearItems);

            string[] array = items.ToArray();
            Pool.FreeUnmanaged(ref items);

            return array;
        }

        [HookMethod("GetKitInfo")]
        public object GetKitInfo(string name)
        {
            if (kitData.Find(name, out KitData.Kit kit))
            {
                JObject obj = new JObject
                {
                    ["name"] = kit.Name,
                    ["permission"] = kit.RequiredPermission,
                    ["max"] = kit.MaximumUses,
                    ["image"] = kit.KitImage,
                    ["hide"] = kit.IsHidden,
                    ["description"] = kit.Description,
                    ["cooldown"] = kit.Cooldown,
                    ["building"] = kit.CopyPasteFile,
                    ["authlevel"] = kit.RequiredAuth
                };

                JArray array = new JArray();
                GetItemObject_Old(ref array, kit.BeltItems, "belt");
                GetItemObject_Old(ref array, kit.MainItems, "main");
                GetItemObject_Old(ref array, kit.WearItems, "wear");

                obj["items"] = array;
                return obj;
            }

            return null;
        }

        private void GetItemObject_Old(ref JArray array, ItemData[] items, string container)
        {
            for (int i = 0; i < items.Length; i++)
            {
                ItemData itemData = items[i];
                JObject item = new JObject
                {
                    ["amount"] = itemData.Amount,
                    ["container"] = container,
                    ["itemid"] = itemData.ItemID,
                    ["skinid"] = itemData.Skin,
                    ["weapon"] = !string.IsNullOrEmpty(itemData.Ammotype),
                    ["blueprint"] = itemData.BlueprintItemID
                };

                item["mods"] = new JArray();

                if (itemData.Contents is { Length: > 0 })
                {
                    for (int i1 = 0; i1 < itemData.Contents?.Length; i1++)
                        (item["mods"] as JArray).Add(itemData.Contents[i1].ItemID);
                }

                if (itemData.Container != null && itemData.Container.contents.Count > 0)
                {
                    for (int i3 = 0; i3 < itemData.Container.contents.Count; i3++)
                        (item["mods"] as JArray).Add(itemData.Container.contents[i3].ItemID);
                }

                array.Add(item);
            }
        }
        #endregion

        #region API
        [HookMethod("GiveKit")]
        public object GiveKit(BasePlayer player, string name)
        {
            if (!player)
                return null;

            if (string.IsNullOrEmpty(name))
                return Message("Error.EmptyKitName", player.userID);

            if (!kitData.Find(name, out KitData.Kit kit))
                return Message("Error.InvalidKitName", player.userID);

            return GiveKit(player, kit);
        }

        [HookMethod("IsKit")]
        public bool IsKit(string name) => !string.IsNullOrEmpty(name) && kitData.Exists(name);

        [HookMethod("GetKitNames")]
        public void GetKitNames(List<string> list) => list.AddRange(kitData.Keys);

        [HookMethod("GetKitImage")]
        public string GetKitImage(string name) => kitData[name]?.KitImage ?? string.Empty;

        [HookMethod("GetKitDescription")]
        public string GetKitDescription(string name) => kitData[name]?.Description ?? string.Empty;

        [HookMethod("GetKitMaxUses")]
        public int GetKitMaxUses(string name) => kitData[name]?.MaximumUses ?? 0;

        [HookMethod("GetKitCooldown")]
        public int GetKitCooldown(string name) => kitData[name]?.Cooldown ?? 0;

        [HookMethod("GetPlayerKitUses")]
        public int GetPlayerKitUses(ulong playerId, string name) => playerData.Exists(playerId) ? playerData[playerId].GetKitUses(name) : 0;

        [HookMethod("SetPlayerKitUses")]
        public void SetPlayerKitUses(ulong playerId, string name, int amount)
        {
            if (playerData.Exists(playerId))
                playerData[playerId].SetKitUses(name, amount);
        }

        [HookMethod("GetPlayerKitCooldown")]
        public double GetPlayerKitCooldown(ulong playerId, string name) => playerData.Exists(playerId) ? playerData[playerId].GetCooldownRemaining(name) : 0;

        [HookMethod("SetPlayerKitCooldown")]
        public void SetPlayerCooldown(ulong playerId, string name, double seconds)
        {
            if (playerData.Exists(playerId))
                playerData[playerId].SetCooldownRemaining(name, seconds);
        }

        [HookMethod("GetKitObject")]
        public JObject GetKitObject(string name)
        {
            if (!kitData.Find(name, out KitData.Kit kit))
                return null;

            return kit.ToJObject;
        }
        
        [HookMethod("CreateKitItems")]
        public IEnumerable<Item> CreateKitItems(string name)
        {
            if (!kitData.Find(name, out KitData.Kit kit))
                yield break;
            
            foreach (Item item in kit.CreateItems())
                yield return item;
        }
        #endregion

        #region UI
        private const string UI_MENU = "kits.menu";
        private const string UI_POPUP = "kits.popup";

        private const string DEFAULT_ICON = "kits.defaultkiticon";
        private const string MAGNIFY_ICON = "kits.magnifyicon";

        #region Kit Grid View
        private void OpenKitGrid(BasePlayer player, int page = 0, ulong npcId = 0UL)
        {
            CuiElementContainer container = UI.Container(UI_MENU, "0 0 0 0.9", new UI4(0.2f, 0.15f, 0.8f, 0.85f), true, "Hud");

            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.005f, 0.93f, 0.995f, 0.99f));

            UI.Label(container, UI_MENU, Message("UI.Title", player.userID), 20, new UI4(0.015f, 0.93f, 0.99f, 0.99f), TextAnchor.MiddleLeft);

            UI.Button(container, UI_MENU, Configuration.Menu.Color3.Get, "<b>×</b>", 20, new UI4(0.9575f, 0.9375f, 0.99f, 0.9825f), "kits.close");

            if (IsAdmin(player) && npcId == 0UL)            
                UI.Button(container, UI_MENU, Configuration.Menu.Color2.Get, Message("UI.CreateNew", player.userID), 14, new UI4(0.85f, 0.9375f, 0.9525f, 0.9825f), "kits.create");
            
            CreateGridView(player, container, page, npcId);

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        private void CreateGridView(BasePlayer player, CuiElementContainer container, int page = 0, ulong npcId = 0UL)
        {
            List<KitData.Kit> list = Pool.Get<List<KitData.Kit>>();

            GetUserValidKits(player, list, npcId);

            if (list.Count == 0)
            {
                UI.Label(container, UI_MENU, Message("UI.NoKitsAvailable", player.userID), 14, new UI4(0.015f, 0.88f, 0.99f, 0.92f), TextAnchor.MiddleLeft);
                return;
            }

            PlayerData.PlayerUsageData playerUsageData = playerData[player.userID];

            int max = Mathf.Min(list.Count, (page + 1) * 8);
            int count = 0;
            for (int i = page * 8; i < max; i++)                
            {
                CreateKitEntry(player, playerUsageData, container, list[i], count, page, npcId);                
                count += 1;
            }

            if (page > 0)
                UI.Button(container, UI_MENU, Configuration.Menu.Color1.Get, "◀\n\n◀\n\n◀", 16, new UI4(0.005f, 0.35f, 0.03f, 0.58f), $"kits.gridview page {page - 1} {npcId}");
            if (max < list.Count)
                UI.Button(container, UI_MENU, Configuration.Menu.Color1.Get, "▶\n\n▶\n\n▶", 16, new UI4(0.97f, 0.35f, 0.995f, 0.58f), $"kits.gridview page {page + 1} {npcId}");

            Pool.FreeUnmanaged(ref list);
        }

        private void CreateKitEntry(BasePlayer player, PlayerData.PlayerUsageData playerUsageData, CuiElementContainer container, KitData.Kit kit, int index, int page, ulong npcId)
        {            
            UI4 position = KitAlign.Get(index);

            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(position.xMin, position.yMax, position.xMax, position.yMax + 0.04f));
            UI.Label(container, UI_MENU, kit.Name, 14, new UI4(position.xMin, position.yMax, position.xMax, position.yMax + 0.04f));

            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, position);

            string imageId = string.IsNullOrEmpty(kit.KitImage) ? GetImage(DEFAULT_ICON) : GetImage(kit.Name);
            UI.Image(container, UI_MENU, imageId, new UI4(position.xMin + 0.005f, position.yMax - 0.3f, position.xMax - 0.005f, position.yMax - 0.0075f));
            
            UI.Button(container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(position.xMin + 0.005f, position.yMax - 0.3f, position.xMax - 0.005f, position.yMax - 0.0075f), $"kits.gridview inspect {CommandSafe(kit.Name)} {page} {npcId}");

            string buttonText;
            string buttonCommand = string.Empty;
            string buttonColor;

            double cooldown = playerUsageData.GetCooldownRemaining(kit.Name);
            int currentUses = playerUsageData.GetKitUses(kit.Name);

            if (Configuration.AdminIgnoreRestrictions && IsAdmin(player))
            {
                buttonText = Message("UI.Redeem", player.userID);
                buttonColor = Configuration.Menu.Color2.Get;
                buttonCommand = $"kits.gridview redeem {CommandSafe(kit.Name)} {page} {npcId}";
            }
            else
            {
                if (!string.IsNullOrEmpty(kit.RequiredPermission) && !permission.UserHasPermission(player.UserIDString, kit.RequiredPermission))
                {
                    buttonText = Message("UI.NeedsPermission", player.userID);
                    buttonColor = Configuration.Menu.Disabled.Get;
                }
                else if (kit.Cooldown > 0 && cooldown > 0)
                {
                    UI.Label(container, UI_MENU, string.Format(Message("UI.Cooldown", player.userID), FormatTime(cooldown)), 12,
                        new UI4(position.xMin + 0.005f, position.yMin + 0.0475f, position.xMax - 0.005f, position.yMax - 0.3f), TextAnchor.MiddleLeft);

                    buttonText = Message("UI.OnCooldown", player.userID);
                    buttonColor = Configuration.Menu.Disabled.Get;
                }
                else if (kit.MaximumUses > 0 && currentUses >= kit.MaximumUses)
                {
                    buttonText = Message("UI.MaximumUses", player.userID);
                    buttonColor = Configuration.Menu.Disabled.Get;
                }
                else if (kit.Cost > 0)
                {
                    UI.Label(container, UI_MENU, string.Format(Message("UI.Cost", player.userID), kit.Cost, Message($"Cost.{_costType}", player.userID)), 12,
                        new UI4(position.xMin + 0.005f, position.yMin + 0.0475f, position.xMax - 0.005f, position.yMax - 0.3f), TextAnchor.MiddleLeft);

                    buttonText = Message("UI.Purchase", player.userID);
                    buttonColor = Configuration.Menu.Color2.Get;
                    buttonCommand = $"kits.gridview redeem {CommandSafe(kit.Name)} {page} {npcId}";
                }
                else
                {
                    buttonText = Message("UI.Redeem", player.userID);
                    buttonColor = Configuration.Menu.Color2.Get;
                    buttonCommand = $"kits.gridview redeem {CommandSafe(kit.Name)} {page} {npcId}";
                }
            }

            UI.Button(container, UI_MENU, buttonColor, buttonText, 14, 
                new UI4(position.xMin + 0.038f, position.yMin + 0.0075f, position.xMax - 0.005f, position.yMin + 0.0475f), buttonCommand);

            UI.Button(container, UI_MENU, ICON_BACKGROUND_COLOR, GetImage(MAGNIFY_ICON), 
                new UI4(position.xMin + 0.005f, position.yMin + 0.0075f, position.xMin + 0.033f, position.yMin + 0.0475f), $"kits.gridview inspect {CommandSafe(kit.Name)} {page} {npcId}");
        }
        #endregion

        #region Kit View       
        private void OpenKitView(BasePlayer player, string name, int page, ulong npcId)
        {
            if (!kitData.Find(name, out KitData.Kit kit))
            {
                OpenKitGrid(player);
                return;
            }

            CuiElementContainer container = UI.Container(UI_MENU, "0 0 0 0.9", new UI4(0.2f, 0.15f, 0.8f, 0.85f), true, "Hud");

            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.005f, 0.93f, 0.995f, 0.99f));

            UI.Label(container, UI_MENU, $"{Message("UI.Title", player.userID)} - {name}", 20, new UI4(0.015f, 0.93f, 0.99f, 0.99f), TextAnchor.MiddleLeft);

            UI.Button(container, UI_MENU, Configuration.Menu.Color3.Get, "<b>×</b>", 20, new UI4(0.9575f, 0.9375f, 0.99f, 0.9825f), $"kits.gridview page 0 {npcId}");

            bool isAdmin = IsAdmin(player);
            if (isAdmin)
            {
                UI.Button(container, UI_MENU, Configuration.Menu.Color2.Get, Message("UI.EditKit", player.userID), 14, new UI4(0.7525f, 0.9375f, 0.845f, 0.9825f), $"kits.edit {CommandSafe(name)}");
                UI.Button(container, UI_MENU, Configuration.Menu.Color2.Get, Message("UI.CreateNew", player.userID), 14, new UI4(0.85f, 0.9375f, 0.9525f, 0.9825f), "kits.create");
            }

            PlayerData.PlayerUsageData playerUsageData = playerData[player.userID];

            int i = -1;

            if (!string.IsNullOrEmpty(kit.KitImage))
            {
                UI.Image(container, UI_MENU, GetImage(kit.Name), new UI4(0.15f, 0.62f, 0.35f, 0.92f));
                i = 6;
            }

            AddTitleSperator(container, i += 1, Message("UI.Details", player.userID));
            AddLabelField(container, i += 1, Message("UI.Name", player.userID), kit.Name);

            if (!string.IsNullOrEmpty(kit.Description)) 
            {
                int descriptionSlots = Mathf.Min(Mathf.CeilToInt((kit.Description.Length / 38f) / 1.25f), 4);
                AddLabelField(container, i += 1, Message("UI.Description", player.userID), kit.Description, descriptionSlots - 1);
                i += descriptionSlots - 1;
            }

            string buttonText = string.Empty;
            string buttonCommand = string.Empty;
            string buttonColor = string.Empty;
            
            if (kit.Cooldown != 0 || kit.MaximumUses != 0 || kit.Cost != 0)
            {
                AddTitleSperator(container, i += 1, Message("UI.Usage", player.userID));

                if (kit.MaximumUses != 0)
                {
                    int playerUses = playerUsageData.GetKitUses(kit.Name);

                    AddLabelField(container, i += 1, Message("UI.MaxUses", player.userID), kit.MaximumUses.ToString());
                    AddLabelField(container, i += 1, Message("UI.YourUses", player.userID), playerUses.ToString());

                    if (playerUses >= kit.MaximumUses)
                    {
                        buttonText = Message("UI.MaximumUses", player.userID);
                        buttonColor = Configuration.Menu.Disabled.Get;
                    }
                }
                if (kit.Cooldown != 0)
                {
                    double cooldownRemaining = playerUsageData.GetCooldownRemaining(kit.Name);

                    AddLabelField(container, i += 1, Message("UI.CooldownTime", player.userID), FormatTime(kit.Cooldown));
                    AddLabelField(container, i += 1, Message("UI.CooldownRemaining", player.userID), cooldownRemaining == 0 ? Message("UI.None", player.userID) : 
                                                                                                     FormatTime(cooldownRemaining));

                    if (string.IsNullOrEmpty(buttonText) && cooldownRemaining > 0)
                    {
                        buttonText = Message("UI.OnCooldown", player.userID);
                        buttonColor = Configuration.Menu.Disabled.Get;
                    }
                }
                if (kit.Cost != 0)
                {
                    AddLabelField(container, i += 1, Message("UI.PurchaseCost", player.userID), $"{kit.Cost} {(Message($"Cost.{_costType}", player.userID))}");

                    if (string.IsNullOrEmpty(buttonText))
                    {
                        buttonText = Message("UI.Purchase", player.userID);
                        buttonColor = Configuration.Menu.Color2.Get;
                        buttonCommand = $"kits.gridview redeem {CommandSafe(kit.Name)} {page} {npcId}";
                    }
                }
            }

            if (!string.IsNullOrEmpty(kit.RequiredPermission) && !permission.UserHasPermission(player.UserIDString, kit.RequiredPermission))
            {
                buttonText = Message("UI.NeedsPermission", player.userID);
                buttonColor = Configuration.Menu.Disabled.Get;
            }
            
            if (i <= 16 && !string.IsNullOrEmpty(kit.CopyPasteFile))
            {
                AddTitleSperator(container, i += 1, Message("UI.CopyPaste", player.userID));
                AddLabelField(container, i += 1, Message("UI.FileName", player.userID), kit.CopyPasteFile);
            }

            if ((Configuration.AdminIgnoreRestrictions && isAdmin) || string.IsNullOrEmpty(buttonText))
            {
                buttonText = Message("UI.Redeem", player.userID);
                buttonCommand = $"kits.gridview redeem {CommandSafe(kit.Name)} {page} {npcId}";
                buttonColor = Configuration.Menu.Color2.Get;
            }

            CreateKitLayout(player, container, kit);

            UI.Button(container, UI_MENU, buttonColor, buttonText, 14, new UI4(0.005f, 0.005f, 0.495f, 0.045f), buttonCommand);

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Kit Layout
        private const string ICON_BACKGROUND_COLOR = "1 1 1 0.15";

        private void CreateKitLayout(BasePlayer player, CuiElementContainer container, KitData.Kit kit)
        {
            UI.Panel(container, UI_MENU, Configuration.Menu.Color1.Get, new UI4(0.505f, 0.88f, 0.995f, 0.92f));
            UI.Label(container, UI_MENU, Message("UI.KitItems", player.userID), 14, new UI4(0.51f, 0.88f, 0.995f, 0.92f), TextAnchor.MiddleLeft);

            // Main Items
            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.505f, 0.835f, 0.995f, 0.875f));
            UI.Label(container, UI_MENU, Message("UI.MainItems", player.userID), 14, new UI4(0.51f, 0.835f, 0.995f, 0.875f), TextAnchor.MiddleLeft);
            CreateInventoryItems(container, MainAlign, kit.MainItems, 24);
            
            // Wear Items
            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.505f, 0.365f, 0.995f, 0.405f));
            UI.Label(container, UI_MENU, Message("UI.WearItems", player.userID), 14, new UI4(0.51f, 0.365f, 0.995f, 0.405f), TextAnchor.MiddleLeft);
            CreateInventoryItems(container, WearAlign, kit.WearItems, 8);
            
            /*// Backpack slot
            UI.Panel(container, UI_MENU, ICON_BACKGROUND_COLOR, new UI4(0.97f, 0.3675f, 0.9925f, 0.4025f));
            ItemData itemData = kit.GetBackpackSlot();
            if (itemData != null)
                UI.Image(container, UI_MENU, itemData.ItemID, itemData.Skin, new UI4(0.97f, 0.3675f, 0.9925f, 0.4025f));*/
            
            // Belt Items
            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.505f, 0.2225f, 0.995f, 0.2625f));
            UI.Label(container, UI_MENU, Message("UI.BeltItems", player.userID), 14, new UI4(0.51f, 0.2225f, 0.995f, 0.2625f), TextAnchor.MiddleLeft);
            CreateInventoryItems(container, BeltAlign, kit.BeltItems, 6);            
        }

        #region Item Layout Helpers
        private void CreateInventoryItems(CuiElementContainer container, GridAlignment alignment, ItemData[] items, int capacity)
        {
            for (int i = 0; i < capacity; i++)
                UI.Panel(container, UI_MENU, ICON_BACKGROUND_COLOR, alignment.Get(i));

            for (int i = 0; i < items.Length; i++)
            {
                ItemData itemData = items[i];
                if (itemData.Position > capacity - 1)
                    continue;

                UI4 position = alignment.Get(itemData.Position);

                UI.Image(container, UI_MENU, itemData.ItemID, itemData.Skin /*GetImage(itemData.Shortname, itemData.Skin)*/, position);

                if (itemData.IsBlueprint && !string.IsNullOrEmpty(itemData.BlueprintShortname))
                    UI.Image(container, UI_MENU, itemData.BlueprintItemID, 0UL /*GetImage(itemData.BlueprintShortname, 0UL)*/, position);

                if (itemData.Amount > 1)
                    UI.Label(container, UI_MENU, $"x{itemData.Amount}", 10, position, TextAnchor.LowerRight);
            }
        }
        #endregion
        #endregion

        #region Kit Editor
        private void OpenKitsEditor(BasePlayer player, bool overwrite = false)
        {
            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            CuiElementContainer container = UI.Container(UI_MENU, "0 0 0 0.9", new UI4(0.2f, 0.15f, 0.8f, 0.85f), true, "Hud");

            UI.Panel(container, UI_MENU, Configuration.Menu.Panel.Get, new UI4(0.005f, 0.93f, 0.995f, 0.99f));

            UI.Label(container, UI_MENU, Message("UI.Title.Editor", player.userID), 20, new UI4(0.015f, 0.93f, 0.99f, 0.99f), TextAnchor.MiddleLeft);

            UI.Button(container, UI_MENU, Configuration.Menu.Color3.Get, "<b>×</b>", 20, new UI4(0.9575f, 0.9375f, 0.99f, 0.9825f), "kits.close");

            // Kit Options
            AddTitleSperator(container, 0, Message("UI.Details", player.userID));
            AddInputField(container, 1, Message("UI.Name", player.userID), "name", kit.Name);
            AddInputField(container, 2, Message("UI.Description", player.userID), "description", kit.Description, 3);
            AddInputField(container, 6, Message("UI.IconURL", player.userID), "image", kit.KitImage);

            AddTitleSperator(container, 7, Message("UI.UsageAuthority", player.userID));
            AddInputField(container, 8, Message("UI.Permission", player.userID), "permission", kit.RequiredPermission);
            AddInputField(container, 9, Message("UI.AuthLevel", player.userID), "authLevel", kit.RequiredAuth);
            AddToggleField(container, 10, Message("UI.IsHidden", player.userID), "isHidden", kit.IsHidden);

            AddTitleSperator(container, 11, Message("UI.Usage", player.userID));
            AddInputField(container, 12, Message("UI.MaxUses", player.userID), "maximumUses", kit.MaximumUses);
            AddInputField(container, 13, Message("UI.CooldownSeconds", player.userID), "cooldown", kit.Cooldown);
            AddInputField(container, 14, Message("UI.PurchaseCost", player.userID), "cost", kit.Cost);

            AddTitleSperator(container, 15, Message("UI.CopyPaste", player.userID));
            AddInputField(container, 16, Message("UI.FileName", player.userID), "copyPaste", kit.CopyPasteFile);

            // Kit Items
            CreateKitLayout(player, container, kit);

            // Kit Saving            
            UI.Button(container, UI_MENU, Configuration.Menu.Color2.Get, Message("UI.SaveKit", player.userID), 14, new UI4(0.005f, 0.005f, 0.2475f, 0.045f), $"kits.savekit {overwrite}");
            UI.Toggle(container, UI_MENU, ICON_BACKGROUND_COLOR, 14, new UI4(0.2525f, 0.005f, 0.2825f, 0.045f), $"kits.toggleoverwrite {overwrite}", overwrite);
            UI.Label(container, UI_MENU, Message("UI.Overwrite", player.userID), 14, new UI4(0.2875f, 0.005f, 0.495f, 0.045f), TextAnchor.MiddleLeft);

            // Item Management            
            UI.Button(container, UI_MENU, Configuration.Menu.Color3.Get, Message("UI.ClearItems", player.userID), 14, new UI4(0.505f, 0.005f, 0.7475f, 0.045f), $"kits.clearitems {overwrite}");
            UI.Button(container, UI_MENU, Configuration.Menu.Color2.Get, Message("UI.CopyInv", player.userID), 14, new UI4(0.7525f, 0.005f, 0.995f, 0.045f), $"kits.copyinv {overwrite}");

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        #region Editor Helpers
        private const float EDITOR_ELEMENT_HEIGHT = 0.04f;

        private void AddInputField(CuiElementContainer container, int index, string title, string fieldName, object currentValue, int additionalHeight = 0)
        {
            float yMin = GetVerticalPos(index, 0.88f);
            float yMax = yMin + EDITOR_ELEMENT_HEIGHT;

            if (additionalHeight != 0)
                yMin = GetVerticalPos(index + additionalHeight, 0.88f);

            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.005f, yMin, 0.175f, yMax));
            UI.Label(container, UI_MENU, title, 12, new UI4(0.01f, yMin, 0.175f, yMax - 0.0075f), TextAnchor.UpperLeft);

            UI.Panel(container, UI_MENU, ICON_BACKGROUND_COLOR, new UI4(0.175f, yMin, 0.495f, yMax));

            string label = GetInputLabel(currentValue);
            if (!string.IsNullOrEmpty(label))
            {
                UI.Label(container, UI_MENU, label, 12, new UI4(0.18f, yMin, 0.47f, yMax - 0.0075f), TextAnchor.UpperLeft);
                UI.Button(container, UI_MENU, Configuration.Menu.Color3.Get, "X", 14, new UI4(0.47f, yMax - EDITOR_ELEMENT_HEIGHT, 0.495f, yMax), $"kits.clear {fieldName}");
            }
            else UI.Input(container, UI_MENU, string.Empty, 12, $"kits.creator {fieldName}", new UI4(0.18f, yMin, 0.495f, yMax - 0.0075f), TextAnchor.UpperLeft);
        }

        private void AddTitleSperator(CuiElementContainer container, int index, string title)
        {
            float yMin = GetVerticalPos(index, 0.88f);
            float yMax = yMin + EDITOR_ELEMENT_HEIGHT;

            UI.Panel(container, UI_MENU, Configuration.Menu.Color1.Get, new UI4(0.005f, yMin, 0.495f, yMax));
            UI.Label(container, UI_MENU, title, 14, new UI4(0.01f, yMin, 0.495f, yMax), TextAnchor.MiddleLeft);
        }

        private void AddLabelField(CuiElementContainer container, int index, string title, string value, int additionalHeight = 0)
        {
            float yMin = GetVerticalPos(index, 0.88f);
            float yMax = yMin + EDITOR_ELEMENT_HEIGHT;

            if (additionalHeight != 0)
                yMin = GetVerticalPos(index + additionalHeight, 0.88f);

            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.005f, yMin, 0.175f, yMax));
            UI.Label(container, UI_MENU, title, 12, new UI4(0.01f, yMin, 0.175f, yMax - 0.0075f), TextAnchor.UpperLeft);

            UI.Panel(container, UI_MENU, ICON_BACKGROUND_COLOR, new UI4(0.175f, yMin, 0.495f, yMax));
            UI.Label(container, UI_MENU, value, 12, new UI4(0.18f, yMin, 0.495f, yMax - 0.0075f), TextAnchor.UpperLeft);
        }

        private void AddToggleField(CuiElementContainer container, int index, string title, string fieldName, bool currentValue)
        {
            float yMin = GetVerticalPos(index, 0.88f);
            float yMax = yMin + EDITOR_ELEMENT_HEIGHT;

            UI.Panel(container, UI_MENU, Configuration.Menu.Color4.Get, new UI4(0.005f, yMin, 0.175f, yMax));
            UI.Label(container, UI_MENU, title, 12, new UI4(0.01f, yMin, 0.175f, yMax), TextAnchor.MiddleLeft);
            UI.Toggle(container, UI_MENU, ICON_BACKGROUND_COLOR, 14, new UI4(0.175f, yMin, 0.205f, yMax), $"kits.creator {fieldName} {!currentValue}", currentValue);
        }

        private string GetInputLabel(object obj)
        {
            if (obj is string s)
                return string.IsNullOrEmpty(s) ? null : s;
            if (obj is int i)
                return i <= 0 ? null : i.ToString();
            if (obj is float f)
                return f <= 0 ? null : f.ToString();
            return null;
        }

        private float GetVerticalPos(int i, float start = 0.9f) => start - (i * (EDITOR_ELEMENT_HEIGHT + 0.005f));
        #endregion
        #endregion

        #region Popup Messages
        private void CreateMenuPopup(BasePlayer player, string text, float duration = 5f)
        {
            CuiElementContainer container = UI.Container(UI_POPUP, Configuration.Menu.Color4.Get, new UI4(0.2f, 0.11f, 0.8f, 0.15f));
            UI.Label(container, UI_POPUP, text, 14, UI4.Full);

            CuiHelper.DestroyUi(player, UI_POPUP);
            CuiHelper.AddUi(player, container);

            player.Invoke(() => CuiHelper.DestroyUi(player, UI_POPUP), duration);
        }
        #endregion

        #region UI Grid Helper
        private readonly GridAlignment KitAlign = new GridAlignment(4, 0.04f, 0.2f, 0.04f, 0.87f, 0.39f, 0.06f);

        private readonly GridAlignment MainAlign = new GridAlignment(6, 0.545f, 0.065f, 0.0035f, 0.8275f, 0.1f, 0.005f);
        private readonly GridAlignment WearAlign = new GridAlignment(8, 0.505f, 0.0581875f, 0.0035f, 0.3575f, 0.0875f, 0.005f);
        private readonly GridAlignment BeltAlign = new GridAlignment(6, 0.545f, 0.065f, 0.0035f, 0.215f, 0.1f, 0.005f);

        private class GridAlignment
        {
            private readonly int _columns;
            private readonly float _xOffset;
            private readonly float _width;
            private readonly float _xSpacing;
            private readonly float _yOffset;
            private readonly float _height;
            private readonly float _ySpacing;

            internal GridAlignment(int columns, float xOffset, float width, float xSpacing, float yOffset, float height, float ySpacing)
            {
                _columns = columns;
                _xOffset = xOffset;
                _width = width;
                _xSpacing = xSpacing;
                _yOffset = yOffset;
                _height = height;
                _ySpacing = ySpacing;
            }

            internal UI4 Get(int index)
            {
                int rowNumber = index == 0 ? 0 : Mathf.FloorToInt(index / (float)_columns);
                int columnNumber = index - (rowNumber * _columns);

                float offsetX = _xOffset + (_width * columnNumber) + (_xSpacing * columnNumber);

                float offsetY = (_yOffset - (rowNumber * _height) - (_ySpacing * rowNumber));

                return new UI4(offsetX, offsetY - _height, offsetX + _width, offsetY);
            }
        }
        #endregion
        #endregion

        #region UI Commands
        #region View Commands
        [ConsoleCommand("kits.close")]
        private void ccmdKitsClose(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            _kitCreators.Remove(player.userID);

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.DestroyUi(player, UI_POPUP);
        }

        [ConsoleCommand("kits.gridview")]
        private void ccmdKitsGridView(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            switch (arg.GetString(0).ToLower())
            {
                case "page":
                    OpenKitGrid(player, arg.GetInt(1), arg.GetULong(2));
                    return;
                case "inspect":                    
                    OpenKitView(player, CommandSafe(arg.GetString(1), true), arg.GetInt(2), arg.GetULong(3));                    
                    return;
                case "redeem":
                    {
                        string kit = CommandSafe(arg.GetString(1), true);
                        if (TryClaimKit(player, kit, true))
                        {
                            CuiHelper.DestroyUi(player, UI_MENU);
                            CuiHelper.DestroyUi(player, UI_POPUP);
                            player.ChatMessage(string.Format(Message("Notification.KitReceived", player.userID), kit));
                        }
                        else OpenKitGrid(player, arg.GetInt(2), arg.GetULong(3));
                    }
                    return;
            }            
        }
        #endregion

        #region Editor Commands
        [ConsoleCommand("kits.create")]
        private void ccmdCreateKit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (IsAdmin(player))
            {
                _kitCreators[player.userID] = new KitData.Kit();
                OpenKitsEditor(player);
            }
        }

        [ConsoleCommand("kits.edit")]
        private void ccmdEditKit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (IsAdmin(player))
            {
                string name = CommandSafe(arg.GetString(0), true);

                if (!kitData.Find(name, out KitData.Kit editKit))
                {
                    player.ChatMessage(string.Format(Message("Chat.Error.DoesntExist", player.userID), name));
                    return;
                }

                _kitCreators[player.userID] = KitData.Kit.CloneOf(editKit);
                OpenKitsEditor(player);
            }
        }

        [ConsoleCommand("kits.savekit")]
        private void ccmdSaveKit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            if (string.IsNullOrEmpty(kit.Name))
            {
                CreateMenuPopup(player, Message("SaveKit.Error.NoName", player.userID));
                return;
            }

            if (kit.ItemCount == 0 && string.IsNullOrEmpty(kit.CopyPasteFile))
            {
                CreateMenuPopup(player, Message("SaveKit.Error.NoContents", player.userID));
                return;
            }

            if (kitData.Exists(kit.Name) && !arg.GetBool(0))
            {
                CreateMenuPopup(player, Message("SaveKit.Error.Exists", player.userID));
                return;
            }

            kitData[kit.Name] = kit;
            SaveKitData();

            _kitCreators.Remove(player.userID);

            if (!string.IsNullOrEmpty(kit.RequiredPermission) && !permission.PermissionExists(kit.RequiredPermission))
                permission.RegisterPermission(kit.RequiredPermission, this);

            if (!string.IsNullOrEmpty(kit.KitImage))
                RegisterImage(kit.Name, kit.KitImage);

            OpenKitView(player, kit.Name, 0, 0UL);
            CreateMenuPopup(player, string.Format(Message("SaveKit.Success", player.userID), kit.Name));
        }

        [ConsoleCommand("kits.toggleoverwrite")]
        private void ccmdToggleOverwrite(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            OpenKitsEditor(player, !arg.GetBool(0));
        }

        [ConsoleCommand("kits.clearitems")]
        private void ccmdClearItems(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            kit.ClearItems();

            OpenKitsEditor(player);
        }

        [ConsoleCommand("kits.copyinv")]
        private void ccmdCopyInv(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            kit.CopyItemsFrom(player);

            OpenKitsEditor(player);
        }

        [ConsoleCommand("kits.clear")]
        private void ccmdClearField(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            string fieldName = arg.GetString(0);

            switch (fieldName)
            {
                case "name":
                    kit.Name = string.Empty;
                    break;
                case "description":
                    kit.Description = string.Empty;
                    break;
                case "copyPaste":
                    kit.CopyPasteFile = string.Empty;
                    break;
                case "permission":
                    kit.RequiredPermission = string.Empty;
                    break;
                case "image":
                    kit.KitImage = string.Empty;
                    break;
                case "cost":
                    kit.Cost = 0;
                    break;
                case "cooldown":
                    kit.Cooldown = 0;
                    break;                
                case "maximumUses":
                    kit.MaximumUses = 0;
                    break;
                case "authLevel":
                    kit.RequiredAuth = 0;
                    break;
            }

            OpenKitsEditor(player);
        }

        [ConsoleCommand("kits.creator")]
        private void ccmdSetField(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player)
                return;

            if (!_kitCreators.TryGetValue(player.userID, out KitData.Kit kit))
                return;

            if (arg.HasArgs(2))
            {
                SetParameter(player, kit, arg.GetString(0), string.Join(" ", arg.Args.Skip(1)));
                OpenKitsEditor(player);
            }
        }

        private void SetParameter(BasePlayer player, KitData.Kit kit, string fieldName, object value)
        {
            if (value == null)
                return;

            switch (fieldName)
            {
                case "name":
                    kit.Name = (string)value;
                    break;
                case "description":
                    kit.Description = (string)value;
                    break;
                case "copyPaste":
                    kit.CopyPasteFile = (string)value;
                    break;
                case "permission":
                    if (!((string)value).StartsWith("kits."))
                    {
                        CreateMenuPopup(player, Message("EditKit.PermissionPrefix", player.userID));
                        return;
                    }
                    kit.RequiredPermission = (string)value;
                    break;
                case "image":
                    kit.KitImage = (string)value;
                    break;
                case "cost":
                    {
                        if (!TryConvertValue(value, out int intValue))
                            CreateMenuPopup(player, Message("EditKit.Number", player.userID));
                        else kit.Cost = intValue;
                    }
                    break;
                case "cooldown":
                    {
                        if (!TryConvertValue(value, out int intValue))
                            CreateMenuPopup(player, Message("EditKit.Number", player.userID));
                        else kit.Cooldown = intValue;
                    }
                    break;
                case "maximumUses":
                    {
                        if (!TryConvertValue(value, out int intValue))
                            CreateMenuPopup(player, Message("EditKit.Number", player.userID));
                        else kit.MaximumUses = intValue;
                    }
                    break;
                case "authLevel":
                    {
                        if (!TryConvertValue(value, out int intValue))
                            CreateMenuPopup(player, Message("EditKit.Number", player.userID));
                        else kit.RequiredAuth = Mathf.Clamp(intValue, 0, 2);                        
                    }
                    break;
                case "isHidden":
                    {
                        if (!TryConvertValue(value, out bool boolValue))
                            CreateMenuPopup(player, Message("EditKit.Bool", player.userID));
                        else kit.IsHidden = boolValue;
                    }
                    break;                
                default:                    
                    return;
            }
        }

        private bool TryConvertValue<T>(object value, out T result)
        {
            try
            {
                result = (T)Convert.ChangeType(value, typeof(T));
                return true;
            }
            catch
            {
                result = default(T);
                return false;
            }
        }
        #endregion
        #endregion

        #region Command Helpers
        private static string CommandSafe(string text, bool unpack = false) => unpack ? text.Replace("▊▊", " ") : text.Replace(" ", "▊▊");
        #endregion

        #region UI Helper
        public static class UI
        {
            public static CuiElementContainer Container(string panel, string color, UI4 dimensions, bool blur = true, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = color, Material = blur ? "assets/content/ui/uibackgroundblur-ingamemenu.mat" : string.Empty },
                            RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                            CursorEnabled = true
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }

            public static CuiElementContainer Popup(string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter, string parent = "Overlay")
            {
                CuiElementContainer container = Container(panel, "0 0 0 0", dimensions);

                Label(container, panel, text, size, UI4.Full, align);

                return container;
            }

            public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Button(CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            public static void Button(CuiElementContainer container, string panel, string color, string png, UI4 dimensions, string command)
            {
                Panel(container, panel, color, dimensions);
                Image(container, panel, png, dimensions);
                Button(container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static void Input(CuiElementContainer container, string panel, string text, int size, string command, UI4 dimensions, TextAnchor anchor = TextAnchor.MiddleLeft)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = anchor,                            
                            CharsLimit = 300,
                            Command = command + text,
                            FontSize = size,
                            IsPassword = false,
                            Text = text,
                            NeedsKeyboard = true
                        },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Image(CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Image(CuiElementContainer container, string panel, int itemId, ulong skinId, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiImageComponent { ItemId = itemId, SkinId = skinId },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Toggle(CuiElementContainer container, string panel, string boxColor, int fontSize, UI4 dimensions, string command, bool isOn)
            {
                Panel(container, panel, boxColor, dimensions);

                if (isOn)
                    Label(container, panel, "✔", fontSize, dimensions);

                Button(container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');

                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        public class UI4
        {
            public float xMin, yMin, xMax, yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {yMin}";

            public string GetMax() => $"{xMax} {yMax}";

            private static UI4 _full;

            public static UI4 Full
            {
                get
                {
                    if (_full == null)
                        _full = new UI4(0, 0, 1, 1);
                    return _full;
                }
            }
        }
        #endregion
                
        #region Chat Commands       
        private void cmdKit(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (Configuration.UseUI)
                    OpenKitGrid(player);
                else ReplyHelp(player);

                return;
            }

            bool isAdmin = IsAdmin(player);

            switch (args[0].ToLower())
            {
                case "help":
                    ReplyHelp(player);
                    return;

                case "list":
                    if (isAdmin)                    
                        player.ChatMessage(string.Format(Message("Chat.KitList", player.userID), kitData.Keys.ToSentence()));
                    else
                    {
                        List<KitData.Kit> kits = Pool.Get<List<KitData.Kit>>();
                        GetUserValidKits(player, kits);

                        player.ChatMessage(string.Format(Message("Chat.KitList", player.userID), kits.Select(kit => kit.Name).ToSentence()));
                        Pool.FreeUnmanaged(ref kits);
                    }  
                    return;

                case "add":
                case "new":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    _kitCreators[player.userID] = new KitData.Kit();
                    OpenKitsEditor(player);

                    return;

                case "edit":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    if (args.Length != 2)
                    {
                        player.ChatMessage(Message("Chat.Error.NoKit", player.userID));
                        return;
                    }

                    if (!kitData.Find(args[1], out KitData.Kit editKit))
                    {
                        player.ChatMessage(string.Format(Message("Chat.Error.DoesntExist", player.userID), args[1]));
                        return;
                    }

                    _kitCreators[player.userID] = KitData.Kit.CloneOf(editKit);
                    OpenKitsEditor(player);

                    return;

                case "remove":
                case "delete":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    if (args.Length != 2)
                    {
                        player.ChatMessage(Message("Chat.Error.NoKit", player.userID));
                        return;
                    }

                    if (!kitData.Find(args[1], out KitData.Kit deleteKit))
                    {
                        player.ChatMessage(string.Format(Message("Chat.Error.DoesntExist", player.userID), args[1]));
                        return;
                    }

                    kitData.Remove(deleteKit);
                    SaveKitData();
                    player.ChatMessage(string.Format(Message("Chat.KitDeleted", player.userID), args[1]));

                    return;

                case "give":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    if (args.Length != 3)
                    {
                        player.ChatMessage(Message("Chat.Error.GiveArgs", player.userID));
                        return;
                    }

                    BasePlayer target = FindPlayer(args[1]);
                    if (target == null)
                    {
                        player.ChatMessage(Message("Chat.Error.NoPlayer", player.userID));
                        return;
                    }

                    if (!kitData.Find(args[2], out KitData.Kit giveKit))
                    {
                        player.ChatMessage(Message("Chat.Error.DoesntExist", player.userID));
                        return;
                    }

                    GiveKit(target, giveKit);
                    player.ChatMessage(string.Format(Message("Chat.KitGiven", player.userID), target.displayName, args[2]));
                    return;

                case "givenpc":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    if (args.Length != 2)
                    {
                        player.ChatMessage(Message("Chat.Error.NPCGiveArgs", player.userID));
                        return;
                    }

                    if (!kitData.Find(args[1], out KitData.Kit npcGiveKit))
                    {
                        player.ChatMessage(Message("Chat.Error.DoesntExist", player.userID));
                        return;
                    }

                    BasePlayer npc = RaycastPlayer(player);
                    if (npc == null)
                    {
                        player.ChatMessage(Message("Chat.Error.NoNPCTarget", player.userID));
                        return;
                    }

                    npc.inventory.Strip();
                    GiveKit(npc, npcGiveKit);

                    player.ChatMessage(string.Format(Message("Chat.KitGiven", player.userID), npc.displayName, args[1]));
                    return;

                case "reset":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }

                    playerData.Wipe();
                    SavePlayerData();
                    player.ChatMessage(Message("Chat.ResetPlayers", player.userID));

                    return;
                
                case "resetuses":
                    if (!isAdmin)
                    {
                        player.ChatMessage(Message("Chat.Error.NotAdmin", player.userID));
                        return;
                    }
                    
                    if (args.Length <= 1)
                    {
                        player.ChatMessage(Message("Chat.ResetUses.Error.Args", player.userID));
                        return;
                    }

                    if (!kitData.Find(args[2], out KitData.Kit kit))
                    {
                        player.ChatMessage(Message("Chat.ResetUses.Error.Kit", player.userID));
                        return;
                    }

                    BasePlayer targetPlayer = FindPlayer(args[1]);
                    if (!targetPlayer)
                    {
                        player.ChatMessage(Message("Chat.ResetUses.Error.Player", player.userID));
                        return;
                    }

                    playerData[targetPlayer.userID].ClearKitUses(kit.Name);
                    
                    player.ChatMessage(string.Format(Message("Chat.ResetUses.Success", player.userID), targetPlayer.displayName, kit.Name));
                    
                    return;

                case "autokit":
                    if (Configuration.AllowAutoToggle)
                    {
                        bool v = playerData[player.userID].ClaimAutoKits = !playerData[player.userID].ClaimAutoKits;
                        player.ChatMessage(string.Format(Message("Chat.AutoKit.Toggle", player.userID), Message($"Chat.AutoKit.{v}", player.userID)));
                    }
                    return;

                default:
                    if (!kitData.Exists(args[0]))
                    {
                        player.ChatMessage(string.Format(Message("Chat.Error.DoesntExist", player.userID), args[0]));
                        return;
                    }

                    if (TryClaimKit(player, args[0], false))
                        player.ChatMessage(string.Format(Message("Notification.KitReceived", player.userID), args[0]));

                    break;
            }
        }

        private void ccmdKit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player != null && !IsAdmin(player))
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "kit list - List all kits");
                SendReply(arg, "kit delete <kitname> - Delete the specified kit");
                SendReply(arg, "kit give <playername> <kitname> - Give the specified kit to the specified player");
                SendReply(arg, "kit reset - Reset player usage data");
                SendReply(arg, "kit resetuses <playername> <kitname> - Reset the usage data for the specified kit for the specified player");
                return;
            }

            switch (arg.Args[0].ToLower())
            {               
                case "list":
                    SendReply(arg, $"Kit List: {kitData.Keys.ToSentence()}");
                    return;

                case "remove":
                case "delete":                    
                    if (arg.Args.Length != 2)
                    {
                        SendReply(arg, "You must specify a kit name");
                        return;
                    }

                    if (!kitData.Find(arg.Args[1], out KitData.Kit deleteKit))
                    {
                        SendReply(arg, $"The kit {arg.Args[1]} does not exist");
                        return;
                    }

                    kitData.Remove(deleteKit);
                    SaveKitData();
                    SendReply(arg, $"You have deleted the kit {arg.Args[1]}");

                    return;

                case "give":                   
                    if (arg.Args.Length != 3)
                    {
                        SendReply(arg, "You must specify target player and a kit name");
                        return;
                    }

                    BasePlayer target = FindPlayer(arg.Args[1]);
                    if (target == null)
                    {
                        SendReply(arg, "Failed to find a player with the specified name or ID");
                        return;
                    }

                    if (!kitData.Find(arg.Args[2], out KitData.Kit giveKit))
                    {
                        SendReply(arg, "The kit {0} does not exist");
                        return;
                    }

                    GiveKit(target, giveKit);
                    SendReply(arg, $"You have given {target.displayName} the kit {arg.Args[2]}");
                    return;
                
                case "reset":                    
                    playerData.Wipe();
                    SavePlayerData();
                    SendReply(arg, "You have wiped player usage data");
                    return;
                
                case "resetuses":
                    if (arg.Args.Length != 3)
                    {
                        SendReply(player, "kit resetuses <playername> <kitname>");
                        return;
                    }

                    if (!kitData.Find(arg.Args[2], out KitData.Kit kit))
                    {
                        SendReply(player, "Unable to find the specified kit");
                        return;
                    }

                    BasePlayer targetPlayer = FindPlayer(arg.Args[1]);
                    if (!targetPlayer)
                    {
                        SendReply(player, "Unable to find the specified player");
                        return;
                    }

                    playerData[targetPlayer.userID].ClearKitUses(kit.Name);
                    
                    SendReply(player, $"You have reset the uses for the kit {kit.Name} for the player {targetPlayer.displayName}");
                    return;
                
                default:
                    SendReply(arg, "Invalid syntax");
                    break;
            }
        }

        private void ReplyHelp(BasePlayer player)
        {
            player.ChatMessage(string.Format(Message("Chat.Help.Title", player.userID), Version));
            player.ChatMessage(Message("Chat.Help.1", player.userID));
            player.ChatMessage(Message("Chat.Help.2", player.userID));
            
            if (Configuration.AllowAutoToggle)
                player.ChatMessage(Message("Chat.Help.9", player.userID));

            if (IsAdmin(player))
            {
                player.ChatMessage(Message("Chat.Help.3", player.userID));
                player.ChatMessage(Message("Chat.Help.4", player.userID));
                player.ChatMessage(Message("Chat.Help.5", player.userID));
                player.ChatMessage(Message("Chat.Help.6", player.userID));
                player.ChatMessage(Message("Chat.Help.7", player.userID));
                player.ChatMessage(Message("Chat.Help.8", player.userID));
                player.ChatMessage(Message("Chat.Help.10", player.userID));
                player.ChatMessage(Message("Chat.Help.11", player.userID));
            }
        }
        #endregion

        #region Old Data Conversion
        [ConsoleCommand("kits.convertolddata")]
        private void ccmdConvertKitsData(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.Connection?.player as BasePlayer;
            if (player != null)
                return;

            ConvertOldKitData();
        }

        [ConsoleCommand("kits.convertoldplayerdata")]
        private void ccmdConvertPlayerData(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.Connection?.player as BasePlayer;
            if (player != null)
                return;

            ConvertOldPlayerData();
        }

        private void ConvertOldPlayerData()
        {
            try
            {
                Dictionary<ulong, Dictionary<string, OldKitData>> oldPlayerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, OldKitData>>>("Kits_Data");

                if (oldPlayerData != null)
                {
                    int success = 0;

                    foreach (KeyValuePair<ulong, Dictionary<string, OldKitData>> oldPlayer in oldPlayerData)
                    {
                        PlayerData.PlayerUsageData playerUsageData = playerData[oldPlayer.Key];

                        foreach(KeyValuePair<string, OldKitData> oldUsageData in oldPlayer.Value)
                        {
                            if (kitData.Exists(oldUsageData.Key))                            
                                playerUsageData.InsertOldData(oldUsageData.Key, oldUsageData.Value.max, oldUsageData.Value.cooldown);                            
                        }

                        success++;
                    }

                    if (success > 0)
                        SavePlayerData();

                    Debug.Log($"Successfully converted {success} / {oldPlayerData.Count} player's data");
                }
            }
            catch { }
        }

        private void ConvertOldKitData()
        {            
            try
            {
                DynamicConfigFile kits = Interface.Oxide.DataFileSystem.GetFile("Kits");
                kits.Settings.NullValueHandling = NullValueHandling.Ignore;
                OldStoredData oldStoredData = kits.ReadObject<OldStoredData>();

                int success = 0;

                foreach (OldKit oldKit in oldStoredData.Kits.Values)
                {
                    Debug.Log($"Converting Kit {oldKit.name} with {oldKit.items.Count} items");
                    KitData.Kit kit = new KitData.Kit
                    {
                        Name = oldKit.name,
                        Description = oldKit.description ?? string.Empty,
                        Cooldown = Convert.ToInt32(oldKit.cooldown),
                        CopyPasteFile = oldKit.building ?? string.Empty,
                        Cost = 0,
                        IsHidden = oldKit.hide,
                        KitImage = oldKit.image ?? string.Empty,
                        MaximumUses = oldKit.max,
                        RequiredAuth = oldKit.authlevel,
                        RequiredPermission = oldKit.permission ?? string.Empty
                    };

                    TryConvertItems(ref kit, oldKit.items);

                    kitData[oldKit.name] = kit;

                    success++;
                }

                if (success > 0)
                    SaveKitData();

                Debug.Log($"Successfully converted {success} / {oldStoredData.Kits.Count} kits");
            }
            catch { }
        }

        private void TryConvertItems(ref KitData.Kit kit, List<OldKitItem> items)
        {
            List<ItemData> wear = Pool.Get<List<ItemData>>();
            List<ItemData> belt = Pool.Get<List<ItemData>>();
            List<ItemData> main = Pool.Get<List<ItemData>>();

            ConvertItems(ref wear, items.Where(oldKitItem => oldKitItem.container == "wear"));
            ConvertItems(ref belt, items.Where(oldKitItem => oldKitItem.container == "belt"));
            ConvertItems(ref main, items.Where(oldKitItem => oldKitItem.container == "main"));

            kit.WearItems = wear.ToArray();
            kit.BeltItems = belt.ToArray();
            kit.MainItems = main.ToArray();

            Pool.FreeUnmanaged(ref wear);
            Pool.FreeUnmanaged(ref belt);
            Pool.FreeUnmanaged(ref main);
        } 

        private ItemDefinition FindItemDefinition(int itemID)
        {
            ItemDefinition itemDefinition;

            if (_itemIdShortnameConversions.TryGetValue(itemID, out string shortname))
                itemDefinition = ItemManager.FindItemDefinition(shortname);
            else itemDefinition = ItemManager.FindItemDefinition(itemID);

            return itemDefinition;
        }

        private void ConvertItems(ref List<ItemData> list, IEnumerable<OldKitItem> items)
        {
            int position = 0;
            foreach (OldKitItem oldKitItem in items)
            {
                ItemDefinition itemDefinition = FindItemDefinition(oldKitItem.itemid);

                if (itemDefinition == null)
                {
                    Debug.Log($"Failed to find ItemDefinition for item ID {oldKitItem.itemid}");
                    continue;
                }

                ItemData itemData = new ItemData
                {
                    Shortname = itemDefinition.shortname,
                    Amount = oldKitItem.amount,
                    Skin = oldKitItem.skinid,
                    Position = position
                };

                if (itemDefinition.condition.enabled)                
                    itemData.Condition = itemData.MaxCondition = itemDefinition.condition.max;

                if (itemData.IsBlueprint)
                {
                    itemDefinition = FindItemDefinition(oldKitItem.blueprintTarget);
                    if (itemDefinition == null) 
                    {
                        Debug.Log($"Failed to find ItemDefinition for blueprint target {oldKitItem.blueprintTarget}");
                        continue;
                    }

                    itemData.BlueprintShortname = itemDefinition.shortname;
                }
                
                if (oldKitItem.mods?.Count > 0)                
                {
                    List<ItemData> contents = Pool.Get<List<ItemData>>();

                    oldKitItem.mods.ForEach(itemId =>
                    {
                        itemDefinition = FindItemDefinition(itemId);
                        if (itemDefinition != null)
                        {
                            contents.Add(new ItemData
                            {
                                Shortname = itemDefinition.shortname,
                                Amount = 1
                            });
                        }
                    });

                    itemData.Contents = contents.ToArray();

                    Pool.FreeUnmanaged(ref contents);
                }

                list.Add(itemData);
                position++;
            }
        }

        private class OldStoredData
        {
            public Dictionary<string, OldKit> Kits = new Dictionary<string, OldKit>();
        }

        private class OldKitData
        {
            public int max;
            public double cooldown;
        }

        private class OldKitItem
        {
            public int itemid;
            public string container;
            public int amount;
            public ulong skinid;
            public bool weapon;
            public int blueprintTarget;
            public List<int> mods = new List<int>();
        }

        private class OldKit
        {
            public string name;
            public string description;
            public int max;
            public double cooldown;
            public int authlevel;
            public bool hide;
            public bool npconly;
            public string permission;
            public string image;
            public string building;
            public List<OldKitItem> items = new List<OldKitItem>();
        }

        private readonly Dictionary<int, string> _itemIdShortnameConversions = new Dictionary<int, string>
        {
            [-1461508848] = "rifle.ak",
            [2115555558] = "ammo.handmade.shell",
            [-533875561] = "ammo.pistol",
            [1621541165] = "ammo.pistol.fire",
            [-422893115] = "ammo.pistol.hv",
            [815896488] = "ammo.rifle",
            [805088543] = "ammo.rifle.explosive",
            [449771810] = "ammo.rifle.incendiary",
            [1152393492] = "ammo.rifle.hv",
            [1578894260] = "ammo.rocket.basic",
            [1436532208] = "ammo.rocket.fire",
            [542276424] = "ammo.rocket.hv",
            [1594947829] = "ammo.rocket.smoke",
            [-1035059994] = "ammo.shotgun",
            [1818890814] = "ammo.shotgun.fire",
            [1819281075] = "ammo.shotgun.slug",
            [1685058759] = "antiradpills",
            [93029210] = "apple",
            [-1565095136] = "apple.spoiled",
            [-1775362679] = "arrow.bone",
            [-1775249157] = "arrow.fire",
            [-1280058093] = "arrow.hv",
            [-420273765] = "arrow.wooden",
            [563023711] = "autoturret",
            [790921853] = "axe.salvaged",
            [-337261910] = "bandage",
            [498312426] = "barricade.concrete",
            [504904386] = "barricade.metal",
            [-1221200300] = "barricade.sandbags",
            [510887968] = "barricade.stone",
            [-814689390] = "barricade.wood",
            [1024486167] = "barricade.woodwire",
            [2021568998] = "battery.small",
            [97329] = "bbq",
            [1046072789] = "trap.bear",
            [97409] = "bed",
            [-1480119738] = "tool.binoculars",
            [1611480185] = "black.raspberries",
            [-1386464949] = "bleach",
            [93832698] = "blood",
            [-1063412582] = "blueberries",
            [-1887162396] = "blueprintbase",
            [-55660037] = "rifle.bolt",
            [919780768] = "bone.club",
            [-365801095] = "bone.fragments",
            [68998734] = "botabag",
            [-853695669] = "bow.hunting",
            [271534758] = "box.wooden.large",
            [-770311783] = "box.wooden",
            [-1192532973] = "bucket.water",
            [-307490664] = "building.planner",
            [707427396] = "burlap.shirt",
            [707432758] = "burlap.shoes",
            [-2079677721] = "cactusflesh",
            [-1342405573] = "tool.camera",
            [-139769801] = "campfire",
            [-1043746011] = "can.beans",
            [2080339268] = "can.beans.empty",
            [-171664558] = "can.tuna",
            [1050986417] = "can.tuna.empty",
            [-1693683664] = "candycaneclub",
            [523409530] = "candycane",
            [1300054961] = "cctv.camera",
            [-2095387015] = "ceilinglight",
            [1428021640] = "chainsaw",
            [94623429] = "chair",
            [1436001773] = "charcoal",
            [1711323399] = "chicken.burned",
            [1734319168] = "chicken.cooked",
            [-1658459025] = "chicken.raw",
            [-726947205] = "chicken.spoiled",
            [-341443994] = "chocholate",
            [1540879296] = "xmasdoorwreath",
            [94756378] = "cloth",
            [3059095] = "coal",
            [3059624] = "corn",
            [2045107609] = "clone.corn",
            [583366917] = "seed.corn",
            [2123300234] = "crossbow",
            [1983936587] = "crude.oil",
            [1257201758] = "cupboard.tool",
            [-1144743963] = "diving.fins",
            [-1144542967] = "diving.mask",
            [-1144334585] = "diving.tank",
            [1066729526] = "diving.wetsuit",
            [-1598790097] = "door.double.hinged.metal",
            [-933236257] = "door.double.hinged.toptier",
            [-1575287163] = "door.double.hinged.wood",
            [-2104481870] = "door.hinged.metal",
            [-1571725662] = "door.hinged.toptier",
            [1456441506] = "door.hinged.wood",
            [1200628767] = "door.key",
            [-778796102] = "door.closer",
            [1526866730] = "xmas.door.garland",
            [1925723260] = "dropbox",
            [1891056868] = "ducttape",
            [1295154089] = "explosive.satchel",
            [498591726] = "explosive.timed",
            [1755466030] = "explosives",
            [726730162] = "facialhair.style01",
            [-1034048911] = "fat.animal",
            [252529905] = "femalearmpithair.style01",
            [471582113] = "femaleeyebrow.style01",
            [-1138648591] = "femalepubichair.style01",
            [305916740] = "female_hairstyle_01",
            [305916742] = "female_hairstyle_03",
            [305916744] = "female_hairstyle_05",
            [1908328648] = "fireplace.stone",
            [-2078972355] = "fish.cooked",
            [-533484654] = "fish.raw",
            [1571660245] = "fishingrod.handmade",
            [1045869440] = "flamethrower",
            [1985408483] = "flameturret",
            [97513422] = "flare",
            [1496470781] = "flashlight.held",
            [1229879204] = "weapon.mod.flashlight",
            [-1722829188] = "floor.grill",
            [1849912854] = "floor.ladder.hatch",
            [-1266285051] = "fridge",
            [-1749787215] = "boots.frog",
            [28178745] = "lowgradefuel",
            [-505639592] = "furnace",
            [1598149413] = "furnace.large",
            [-1779401418] = "gates.external.high.stone",
            [-57285700] = "gates.external.high.wood",
            [98228420] = "gears",
            [1422845239] = "geiger.counter",
            [277631078] = "generator.wind.scrap",
            [115739308] = "burlap.gloves",
            [-522149009] = "gloweyes",
            [3175989] = "glue",
            [718197703] = "granolabar",
            [384204160] = "grenade.beancan",
            [-1308622549] = "grenade.f1",
            [-217113639] = "fun.guitar",
            [-1580059655] = "gunpowder",
            [-1832205789] = "male_hairstyle_01",
            [305916741] = "female_hairstyle_02",
            [936777834] = "attire.hide.helterneck",
            [-1224598842] = "hammer",
            [-1976561211] = "hammer.salvaged",
            [-1406876421] = "hat.beenie",
            [-1397343301] = "hat.boonie",
            [1260209393] = "bucket.helmet",
            [-1035315940] = "burlap.headwrap",
            [-1381682752] = "hat.candle",
            [696727039] = "hat.cap",
            [-2128719593] = "coffeecan.helmet",
            [-1178289187] = "deer.skull.mask",
            [1351172108] = "heavy.plate.helmet",
            [-450738836] = "hat.miner",
            [-966287254] = "attire.reindeer.headband",
            [340009023] = "riot.helmet",
            [124310981] = "hat.wolf",
            [1501403549] = "wood.armor.helmet",
            [698310895] = "hatchet",
            [523855532] = "hazmatsuit",
            [2045246801] = "clone.hemp",
            [583506109] = "seed.hemp",
            [-148163128] = "attire.hide.boots",
            [-132588262] = "attire.hide.skirt",
            [-1666761111] = "attire.hide.vest",
            [-465236267] = "weapon.mod.holosight",
            [-1211618504] = "hoodie",
            [2133577942] = "hq.metal.ore",
            [-1014825244] = "humanmeat.burned",
            [-991829475] = "humanmeat.cooked",
            [-642008142] = "humanmeat.raw",
            [661790782] = "humanmeat.spoiled",
            [-1440143841] = "icepick.salvaged",
            [569119686] = "bone.armor.suit",
            [1404466285] = "heavy.plate.jacket",
            [-1616887133] = "jacket.snow",
            [-1167640370] = "jacket",
            [-1284735799] = "jackolantern.angry",
            [-1278649848] = "jackolantern.happy",
            [776005741] = "knife.bone",
            [108061910] = "ladder.wooden.wall",
            [255101535] = "trap.landmine",
            [-51678842] = "lantern",
            [-789202811] = "largemedkit",
            [516382256] = "weapon.mod.lasersight",
            [50834473] = "leather",
            [-975723312] = "lock.code",
            [1908195100] = "lock.key",
            [-1097452776] = "locker",
            [146685185] = "longsword",
            [-1716193401] = "rifle.lr300",
            [193190034] = "lmg.m249",
            [371156815] = "pistol.m92",
            [3343606] = "mace",
            [825308669] = "machete",
            [830965940] = "mailbox",
            [1662628660] = "male.facialhair.style02",
            [1662628661] = "male.facialhair.style03",
            [1662628662] = "male.facialhair.style04",
            [-1832205788] = "male_hairstyle_02",
            [-1832205786] = "male_hairstyle_04",
            [1625090418] = "malearmpithair.style01",
            [-1269800768] = "maleeyebrow.style01",
            [429648208] = "malepubichair.style01",
            [-1832205787] = "male_hairstyle_03",
            [-1832205785] = "male_hairstyle_05",
            [107868] = "map",
            [997973965] = "mask.balaclava",
            [-46188931] = "mask.bandana",
            [-46848560] = "metal.facemask",
            [-2066726403] = "bearmeat.burned",
            [-2043730634] = "bearmeat.cooked",
            [1325935999] = "bearmeat",
            [-225234813] = "deermeat.burned",
            [-202239044] = "deermeat.cooked",
            [-322501005] = "deermeat.raw",
            [-1851058636] = "horsemeat.burned",
            [-1828062867] = "horsemeat.cooked",
            [-1966381470] = "horsemeat.raw",
            [968732481] = "meat.pork.burned",
            [991728250] = "meat.pork.cooked",
            [-253819519] = "meat.boar",
            [-1714986849] = "wolfmeat.burned",
            [-1691991080] = "wolfmeat.cooked",
            [179448791] = "wolfmeat.raw",
            [431617507] = "wolfmeat.spoiled",
            [688032252] = "metal.fragments",
            [-1059362949] = "metal.ore",
            [1265861812] = "metal.plate.torso",
            [374890416] = "metal.refined",
            [1567404401] = "metalblade",
            [-1057402571] = "metalpipe",
            [-758925787] = "mining.pumpjack",
            [-1411620422] = "mining.quarry",
            [88869913] = "fish.minnows",
            [-2094080303] = "smg.mp5",
            [843418712] = "mushroom",
            [-1569356508] = "weapon.mod.muzzleboost",
            [-1569280852] = "weapon.mod.muzzlebrake",
            [449769971] = "pistol.nailgun",
            [590532217] = "ammo.nailgun.nails",
            [3387378] = "note",
            [1767561705] = "burlap.trousers",
            [106433500] = "pants",
            [-1334615971] = "heavy.plate.pants",
            [-135651869] = "attire.hide.pants",
            [-1595790889] = "roadsign.kilt",
            [-459156023] = "pants.shorts",
            [106434956] = "paper",
            [-578028723] = "pickaxe",
            [-586116979] = "jar.pickle",
            [-1379225193] = "pistol.eoka",
            [-930579334] = "pistol.revolver",
            [548699316] = "pistol.semiauto",
            [142147109] = "planter.large",
            [148953073] = "planter.small",
            [102672084] = "attire.hide.poncho",
            [640562379] = "pookie.bear",
            [-1732316031] = "xmas.present.large",
            [-2130280721] = "xmas.present.medium",
            [-1725510067] = "xmas.present.small",
            [1974032895] = "propanetank",
            [-225085592] = "pumpkin",
            [509654999] = "clone.pumpkin",
            [466113771] = "seed.pumpkin",
            [2033918259] = "pistol.python",
            [2069925558] = "target.reactive",
            [-1026117678] = "box.repair.bench",
            [1987447227] = "research.table",
            [540154065] = "researchpaper",
            [1939428458] = "riflebody",
            [-288010497] = "roadsign.jacket",
            [-847065290] = "roadsigns",
            [3506021] = "rock",
            [649603450] = "rocket.launcher",
            [3506418] = "rope",
            [569935070] = "rug.bear",
            [113284] = "rug",
            [1916127949] = "water.salt",
            [-1775234707] = "salvaged.cleaver",
            [-388967316] = "salvaged.sword",
            [2007564590] = "santahat",
            [-1705696613] = "scarecrow",
            [670655301] = "hazmatsuit_scientist",
            [1148128486] = "hazmatsuit_scientist_peacekeeper",
            [-141135377] = "weapon.mod.small.scope",
            [109266897] = "scrap",
            [-527558546] = "searchlight",
            [-1745053053] = "rifle.semiauto",
            [1223860752] = "semibody",
            [-419069863] = "sewingkit",
            [-1617374968] = "sheetmetal",
            [2057749608] = "shelves",
            [24576628] = "shirt.collared",
            [-1659202509] = "shirt.tanktop",
            [2107229499] = "shoes.boots",
            [191795897] = "shotgun.double",
            [-1009492144] = "shotgun.pump",
            [2077983581] = "shotgun.waterpipe",
            [378365037] = "guntrap",
            [-529054135] = "shutter.metal.embrasure.a",
            [-529054134] = "shutter.metal.embrasure.b",
            [486166145] = "shutter.wood.a",
            [1628490888] = "sign.hanging.banner.large",
            [1498516223] = "sign.hanging",
            [-632459882] = "sign.hanging.ornate",
            [-626812403] = "sign.pictureframe.landscape",
            [385802761] = "sign.pictureframe.portrait",
            [2117976603] = "sign.pictureframe.tall",
            [1338515426] = "sign.pictureframe.xl",
            [-1455694274] = "sign.pictureframe.xxl",
            [1579245182] = "sign.pole.banner.large",
            [-587434450] = "sign.post.double",
            [-163742043] = "sign.post.single",
            [-1224714193] = "sign.post.town",
            [644359987] = "sign.post.town.roof",
            [-1962514734] = "sign.wooden.huge",
            [-705305612] = "sign.wooden.large",
            [-357728804] = "sign.wooden.medium",
            [-698499648] = "sign.wooden.small",
            [1213686767] = "weapon.mod.silencer",
            [386382445] = "weapon.mod.simplesight",
            [1859976884] = "skull_fire_pit",
            [960793436] = "skull.human",
            [1001265731] = "skull.wolf",
            [1253290621] = "sleepingbag",
            [470729623] = "small.oil.refinery",
            [1051155022] = "stash.small",
            [865679437] = "fish.troutsmall",
            [927253046] = "smallwaterbottle",
            [109552593] = "smg.2",
            [-2092529553] = "smgbody",
            [691633666] = "snowball",
            [-2055888649] = "snowman",
            [621575320] = "shotgun.spas12",
            [-2118132208] = "spear.stone",
            [-1127699509] = "spear.wooden",
            [-685265909] = "spikes.floor",
            [552706886] = "spinner.wheel",
            [1835797460] = "metalspring",
            [-892259869] = "sticks",
            [-1623330855] = "stocking.large",
            [-1616524891] = "stocking.small",
            [789892804] = "stone.pickaxe",
            [-1289478934] = "stonehatchet",
            [-892070738] = "stones",
            [-891243783] = "sulfur",
            [889398893] = "sulfur.ore",
            [-1625468793] = "supply.signal",
            [1293049486] = "surveycharge",
            [1369769822] = "fishtrap.small",
            [586484018] = "syringe.medical",
            [110115790] = "table",
            [1490499512] = "targeting.computer",
            [3552619] = "tarp",
            [1471284746] = "techparts",
            [456448245] = "smg.thompson",
            [110547964] = "torch",
            [1588977225] = "xmas.decoration.baubels",
            [918540912] = "xmas.decoration.candycanes",
            [-471874147] = "xmas.decoration.gingerbreadmen",
            [205978836] = "xmas.decoration.lights",
            [-1044400758] = "xmas.decoration.pinecone",
            [-2073307447] = "xmas.decoration.star",
            [435230680] = "xmas.decoration.tinsel",
            [-864578046] = "tshirt",
            [1660607208] = "tshirt.long",
            [260214178] = "tunalight",
            [-1847536522] = "vending.machine",
            [-496055048] = "wall.external.high.stone",
            [-1792066367] = "wall.external.high",
            [562888306] = "wall.frame.cell.gate",
            [-427925529] = "wall.frame.cell",
            [995306285] = "wall.frame.fence.gate",
            [-378017204] = "wall.frame.fence",
            [447918618] = "wall.frame.garagedoor",
            [313836902] = "wall.frame.netting",
            [1175970190] = "wall.frame.shopfront",
            [525244071] = "wall.frame.shopfront.metal",
            [-1021702157] = "wall.window.bars.metal",
            [-402507101] = "wall.window.bars.toptier",
            [-1556671423] = "wall.window.bars.wood",
            [61936445] = "wall.window.glass.reinforced",
            [112903447] = "water",
            [1817873886] = "water.catcher.large",
            [1824679850] = "water.catcher.small",
            [-1628526499] = "water.barrel",
            [547302405] = "waterjug",
            [1840561315] = "water.purifier",
            [-460592212] = "xmas.window.garland",
            [3655341] = "wood",
            [1554697726] = "wood.armor.jacket",
            [-1883959124] = "wood.armor.pants",
            [-481416622] = "workbench1",
            [-481416621] = "workbench2",
            [-481416620] = "workbench3",
            [-1151126752] = "xmas.lightstring",
            [-1926458555] = "xmas.tree"
        };

        
        #endregion
        
        #region Item Shortname Updates
        private void CheckForShortnameUpdates()
        {
            bool hasChanges = false;
            
            kitData.ForEach(kit =>
            {
                Action<ItemData[]> action = (items =>
                {
                    for (int i = 0; i < items.Length; i++)
                    {
                        ItemData kitItem = items[i];

                        if (_itemShortnameReplacements.TryGetValue(kitItem.Shortname, out string replacement))
                        {
                            kitItem.Shortname = replacement;
                            hasChanges = true;
                        }
                    }
                });

                action(kit.BeltItems);
                action(kit.WearItems);
                action(kit.MainItems);
            });
            
            if (hasChanges)
                SaveKitData();
        }
        
        private readonly Dictionary<string, string> _itemShortnameReplacements = new Dictionary<string, string>
        {
            ["chocholate"] = "chocolate"
        };
        #endregion

        #region Config        
        private static ConfigData Configuration;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Kit chat command")]
            public string Command { get; set; }

            [JsonProperty(PropertyName = "Currency used for purchase costs (Scrap, Economics, ServerRewards)")]
            public string Currency { get; set; }

            [JsonProperty(PropertyName = "Log kits given")]
            public bool LogKitsGiven { get; set; }

            [JsonProperty(PropertyName = "Wipe player data when the server is wiped")]
            public bool WipeData { get; set; }

            [JsonProperty(PropertyName = "Use the Kits UI menu")]
            public bool UseUI { get; set; }

            [JsonProperty(PropertyName = "Allow players to toggle auto-kits on spawn")]
            public bool AllowAutoToggle { get; set; }

            [JsonProperty(PropertyName = "Show kits with permissions assigned to players without the permission")]
            public bool ShowPermissionKits { get; set; }

            [JsonProperty(PropertyName = "Players with the admin permission ignore usage restrictions")]
            public bool AdminIgnoreRestrictions { get; set; }

            [JsonProperty(PropertyName = "Autokits ordered by priority")]
            public List<string> AutoKits { get; set; }

            [JsonProperty(PropertyName = "Post wipe cooldowns (kit name | seconds)")]
            public Hash<string, int> WipeCooldowns { get; set; }

            [JsonProperty(PropertyName = "Parameters used when pasting a building via CopyPaste")]
            public string[] CopyPasteParams { get; set; }

            [JsonProperty(PropertyName = "UI Options")]
            public MenuOptions Menu { get; set; }

            [JsonProperty(PropertyName = "Kit menu items when opened via HumanNPC (NPC user ID | Items)")]
            public Hash<ulong, NPCKit> NPCKitMenu { get; set; }

            public class MenuOptions
            {
                [JsonProperty(PropertyName = "Panel Color")]
                public UIColor Panel { get; set; }

                [JsonProperty(PropertyName = "Disabled Color")]
                public UIColor Disabled { get; set; }

                [JsonProperty(PropertyName = "Color 1")]
                public UIColor Color1 { get; set; }

                [JsonProperty(PropertyName = "Color 2")]
                public UIColor Color2 { get; set; }

                [JsonProperty(PropertyName = "Color 3")]
                public UIColor Color3 { get; set; }

                [JsonProperty(PropertyName = "Color 4")]
                public UIColor Color4 { get; set; }

                [JsonProperty(PropertyName = "Default kit image URL")]
                public string DefaultKitURL { get; set; }

                [JsonProperty(PropertyName = "View kit icon URL")]
                public string MagnifyIconURL { get; set; }
            }

            public class UIColor
            {
                public string Hex { get; set; }
                public float Alpha { get; set; }

                [JsonIgnore]
                private string _color;

                [JsonIgnore]
                public string Get
                {
                    get
                    {
                        if (string.IsNullOrEmpty(_color))
                            _color = UI.Color(Hex, Alpha);
                        return _color;
                    }
                }
            }

            public class NPCKit
            {
                [JsonProperty(PropertyName = "The list of kits that can be claimed from this NPC")]
                public List<string> Kits { get; set; }

                [JsonProperty(PropertyName = "The NPC's response to opening their kit menu")]
                public string Description { get; set; }
            }

            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Command = "kit",                
                Currency = "Scrap",
                LogKitsGiven = false,
                WipeData = false,
                ShowPermissionKits = false,
                UseUI = true,
                AllowAutoToggle = false,
                AutoKits = new List<string>
                {
                    "ExampleKitName",
                    "OtherKitName"
                },
                WipeCooldowns = new Hash<string, int>
                {
                    ["ExampleKitName"] = 3600,
                    ["OtherKitName"] = 600
                },
                CopyPasteParams = new[] { "deployables", "true", "inventories", "true" },
                Menu = new ConfigData.MenuOptions
                {
                    Panel = new ConfigData.UIColor { Hex = "#232323", Alpha = 1f },
                    Disabled = new ConfigData.UIColor { Hex = "#3e3e42", Alpha = 1f },
                    Color1 = new ConfigData.UIColor { Hex = "#007acc", Alpha = 1f },
                    Color2 = new ConfigData.UIColor { Hex = "#6a8b38", Alpha = 1f },
                    Color3 = new ConfigData.UIColor { Hex = "#d85540", Alpha = 1f },
                    Color4 = new ConfigData.UIColor { Hex = "#d08822", Alpha = 1f },
                    DefaultKitURL = "https://chaoscode.io/oxide/Images/kiticon.png",
                    MagnifyIconURL = "https://chaoscode.io/oxide/Images/magnifyingglass.png"
                },
                NPCKitMenu = new Hash<ulong, ConfigData.NPCKit>
                {
                    [0UL] = new ConfigData.NPCKit
                    {
                        Kits = new List<string>
                        {
                            "ExampleKitName",
                            "OtherKitName"
                        },
                        Description = "Welcome to this server! Here are some free kits you can claim"
                    },
                    [1111UL] = new ConfigData.NPCKit
                    {
                        Kits = new List<string>
                        {
                            "ExampleKitName",
                            "OtherKitName"
                        },
                        Description = "Welcome to this server! Here are some free kits you can claim"
                    },
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (Configuration.Version < new VersionNumber(4, 0, 0))
                Configuration = baseConfig;

            if (Configuration.Version < new VersionNumber(4, 0, 1))
            {
                Configuration.UseUI = true;
                Configuration.NPCKitMenu = baseConfig.NPCKitMenu;
            }

            if (Configuration.Version < new VersionNumber(4, 0, 12))
                Configuration.Command = baseConfig.Command;

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private KitData kitData;
        private PlayerData playerData;

        private DynamicConfigFile kitdata;
        private DynamicConfigFile playerdata;

        private void SaveKitData() => kitdata.WriteObject(kitData);

        private void SavePlayerData() => playerdata.WriteObject(playerData);

        private void LoadData()
        {
            kitdata = Interface.Oxide.DataFileSystem.GetFile("Kits/kits_data");
            playerdata = Interface.Oxide.DataFileSystem.GetFile("Kits/player_data");

            kitData = kitdata.ReadObject<KitData>();
            playerData = playerdata.ReadObject<PlayerData>();
            
            if (!kitData?.IsValid ?? true)
                kitData = new KitData();

            if (!playerData?.IsValid ?? true)
                playerData = new PlayerData();
        }

        private class KitData
        {
            [JsonProperty]
            private Dictionary<string, Kit> _kits = new Dictionary<string, Kit>(StringComparer.OrdinalIgnoreCase);

            internal Kit this[string key]
            {
                get
                {
                    if (_kits.TryGetValue(key, out Kit tValue))                    
                        return tValue;
                    
                    return null;
                }
                set
                {
                    if (value == null)
                    {
                        _kits.Remove(key);
                        return;
                    }
                    _kits[key] = value;
                }
            }

            internal int Count => _kits.Count;

            internal bool Find(string name, out Kit kit) => _kits.TryGetValue(name, out kit);

            internal bool Exists(string name) => _kits.ContainsKey(name);

            internal ICollection<string> Keys => _kits.Keys;

            internal ICollection<Kit> Values => _kits.Values;

            internal void ForEach(Action<Kit> action)
            {
                foreach(Kit kit in Values)
                {
                    action.Invoke(kit);
                }
            }

            internal void RegisterPermissions(Permission permission, Plugin plugin)
            {
                foreach(Kit kit in _kits.Values)
                {
                    if (!string.IsNullOrEmpty(kit.RequiredPermission))
                    {                        
                        if(!permission.PermissionExists(kit.RequiredPermission, plugin))
                            permission.RegisterPermission(kit.RequiredPermission, plugin);
                    }
                }
            }

            internal void RegisterImages(Plugin plugin)
            {
                Dictionary<string, string> loadOrder = new Dictionary<string, string>
                {
                    [DEFAULT_ICON] = Configuration.Menu.DefaultKitURL,
                    [MAGNIFY_ICON] = Configuration.Menu.MagnifyIconURL
                };

                foreach (Kit kit in _kits.Values)
                {
                    if (!string.IsNullOrEmpty(kit.KitImage))
                        loadOrder.Add(kit.Name.Replace(" ", ""), kit.KitImage);
                }

                plugin?.CallHook("ImportImageList", "Kits", loadOrder, 0UL, true, null);
            }

            internal bool IsOnWipeCooldown(int seconds, out int remaining)
            {
                double currentTime = CurrentTime;
                double nextUseTime = LastWipeTime + seconds;

                if (currentTime < nextUseTime)
                {
                    remaining = Mathf.RoundToInt((float)nextUseTime - (float)currentTime);
                    return true;
                }

                remaining = 0;
                return false;
            }

            internal void Remove(Kit kit) => _kits.Remove(kit.Name);

            internal bool IsValid => _kits != null;

            public class Kit
            {
                public string Name { get; set; } = string.Empty;
                public string Description { get; set; } = string.Empty;
                public string RequiredPermission { get; set; } = string.Empty;

                public int MaximumUses { get; set; }
                public int RequiredAuth { get; set; }
                public int Cooldown { get; set; }
                public int Cost { get; set; }

                public bool IsHidden { get; set; }

                public string CopyPasteFile { get; set; } = string.Empty;
                public string KitImage { get; set; } = string.Empty;

                public ItemData[] MainItems { get; set; } = new ItemData[0];
                public ItemData[] WearItems { get; set; } = new ItemData[0];
                public ItemData[] BeltItems { get; set; } = new ItemData[0];
                
                [JsonIgnore]
                internal int ItemCount => MainItems.Length + WearItems.Length + BeltItems.Length;

                [JsonIgnore]
                private JObject _jObject;

                [JsonIgnore]
                internal JObject ToJObject
                {
                    get
                    {
                        if (_jObject == null)
                        {
                            _jObject = new JObject
                            {
                                ["Name"] = Name,
                                ["Description"] = Description,
                                ["RequiredPermission"] = RequiredPermission,
                                ["MaximumUses"] = MaximumUses,
                                ["RequiredAuth"] = RequiredAuth,
                                ["Cost"] = Cost,
                                ["IsHidden"] = IsHidden,
                                ["CopyPasteFile"] = CopyPasteFile,
                                ["KitImage"] = KitImage,
                                ["MainItems"] = new JArray(),
                                ["WearItems"] = new JArray(),
                                ["BeltItems"] = new JArray()
                            };

                            for (int i = 0; i < MainItems.Length; i++)                            
                                (_jObject["MainItems"] as JArray).Add(MainItems[i].ToJObject);

                            for (int i = 0; i < WearItems.Length; i++)
                                (_jObject["WearItems"] as JArray).Add(WearItems[i].ToJObject);

                            for (int i = 0; i < BeltItems.Length; i++)
                                (_jObject["BeltItems"] as JArray).Add(BeltItems[i].ToJObject);
                        }

                        return _jObject;
                    }
                }

                internal static Kit CloneOf(Kit other)
                {
                    Kit kit = new Kit();

                    kit.Name = other.Name;
                    kit.Description = other.Description;
                    kit.RequiredPermission = other.RequiredPermission;

                    kit.MaximumUses = other.MaximumUses;
                    kit.RequiredAuth = other.RequiredAuth;
                    kit.Cooldown = other.Cooldown;
                    kit.Cost = other.Cost;

                    kit.IsHidden = other.IsHidden;

                    kit.CopyPasteFile = other.CopyPasteFile;
                    kit.KitImage = other.KitImage;

                    kit.MainItems = new ItemData[other.MainItems.Length];
                    Array.Copy(other.MainItems, kit.MainItems, other.MainItems.Length);

                    kit.WearItems = new ItemData[other.WearItems.Length];
                    Array.Copy(other.WearItems, kit.WearItems, other.WearItems.Length);

                    kit.BeltItems = new ItemData[other.BeltItems.Length];
                    Array.Copy(other.BeltItems, kit.BeltItems, other.BeltItems.Length);

                    return kit;
                }
                
                internal ItemData GetBackpackSlot()
                {
                    for (int i = 0; i < WearItems.Length; i++)
                    {
                        ItemData itemData = WearItems[i];
                        if (itemData.Position == 7)
                            return itemData;
                    }

                    return null;
                }

                internal bool HasSpaceForItems(BasePlayer player)
                {
                    int wearSpacesFree = 8 - player.inventory.containerWear.itemList.Count;
                    int mainSpacesFree = 24 - player.inventory.containerMain.itemList.Count;
                    int beltSpacesFree = 6 - player.inventory.containerBelt.itemList.Count;

                    return (wearSpacesFree >= WearItems.Length &&
                            beltSpacesFree >= BeltItems.Length &&
                            mainSpacesFree >= MainItems.Length) || ItemCount <= mainSpacesFree + beltSpacesFree;
                }

                internal void GiveItemsTo(BasePlayer player)
                {
                    List<ItemData> list = Pool.Get<List<ItemData>>();

                    GiveItems(MainItems, player.inventory.containerMain, ref list);
                    GiveItems(WearItems, player.inventory.containerWear, ref list, true);
                    GiveItems(BeltItems, player.inventory.containerBelt, ref list);

                    for (int i = 0; i < list.Count; i++)
                    {
                        Item item = CreateItem(list[i]);

                        if (!MoveToIdealContainer(player.inventory, item) && !item.MoveToContainer(player.inventory.containerMain) && !item.MoveToContainer(player.inventory.containerBelt))                        
                            item.Drop(player.GetDropPosition(), player.GetDropVelocity());                                                
                    }

                    Pool.FreeUnmanaged(ref list);
                }

                private void GiveItems(ItemData[] items, ItemContainer container, ref List<ItemData> leftOverItems, bool isWearContainer = false)
                {
                    for (int i = 0; i < items.Length; i++)
                    {
                        ItemData itemData = items[i];
                        if (itemData.Amount < 1)
                            continue;

                        if (container.GetSlot(itemData.Position) != null)
                            leftOverItems.Add(itemData);
                        else
                        {
                            Item item = CreateItem(itemData);
                            if (!isWearContainer || (isWearContainer && item.info.isWearable && CanWearItem(container, item)))
                            {
                                item.position = itemData.Position;
                                item.SetParent(container);
                            }
                            else
                            {
                                leftOverItems.Add(itemData);
                                item.Remove();
                            }
                        }
                    }
                }
                
                internal IEnumerable<Item> CreateItems()
                {
                    for (int i = 0; i < MainItems.Length; i++)
                    {
                        ItemData itemData = MainItems[i];
                        if (itemData.Amount > 0)
                            yield return CreateItem(itemData);
                    }
                    
                    for (int i = 0; i < WearItems.Length; i++)
                    {
                        ItemData itemData = WearItems[i];
                        if (itemData.Amount > 0)
                            yield return CreateItem(itemData);
                    }
                    
                    for (int i = 0; i < BeltItems.Length; i++)
                    {
                        ItemData itemData = BeltItems[i];
                        if (itemData.Amount > 0)
                            yield return CreateItem(itemData);
                    }
                }

                private bool MoveToIdealContainer(PlayerInventory playerInventory, Item item)
                {
                    if (item.info.isWearable && CanWearItem(playerInventory.containerWear, item))                    
                        return item.MoveToContainer(playerInventory.containerWear, -1, false);
                    
                    if (item.info.stackable > 1)
                    {
                        if (playerInventory.containerBelt != null && playerInventory.containerBelt.FindItemByItemID(item.info.itemid) != null)                        
                            return item.MoveToContainer(playerInventory.containerBelt);
                        

                        if (playerInventory.containerMain != null && playerInventory.containerMain.FindItemByItemID(item.info.itemid) != null)                        
                            return item.MoveToContainer(playerInventory.containerMain);
                        
                    }
                    if (item.info.HasFlag(ItemDefinition.Flag.NotStraightToBelt) || !item.info.isUsable)                    
                        return item.MoveToContainer(playerInventory.containerMain);                    

                    return item.MoveToContainer(playerInventory.containerBelt, -1, false); 
                }

                private bool CanWearItem(ItemContainer containerWear, Item item)
                {
                    ItemModWearable itemModWearable = item.info.GetComponent<ItemModWearable>();
                    if (itemModWearable == null)                  
                        return false;
                    
                    for (int i = 0; i < containerWear.itemList.Count; i++)
                    {
                        Item otherItem = containerWear.itemList[i];
                        if (otherItem != null)
                        {
                            ItemModWearable otherModWearable = otherItem.info.GetComponent<ItemModWearable>();                          
                            if (otherModWearable != null && !itemModWearable.CanExistWith(otherModWearable))
                                return false;
                        }
                    }

                    return true;
                }
                                
                internal void CopyItemsFrom(BasePlayer player)
                {
                    ItemData[] array = MainItems;
                    CopyItems(ref array, player.inventory.containerMain, 24);
                    MainItems = array;

                    array = WearItems;
                    CopyItems(ref array, player.inventory.containerWear, 8);
                    WearItems = array;

                    array = BeltItems;
                    CopyItems(ref array, player.inventory.containerBelt, 6);
                    BeltItems = array;
                }

                private void CopyItems(ref ItemData[] array, ItemContainer container, int limit)
                {
                    limit = Mathf.Min(container.itemList.Count, limit);

                    array = new ItemData[limit];

                    for (int i = 0; i < limit; i++)                    
                        array[i] = new ItemData(container.itemList[i]);                    
                }

                internal void ClearItems()
                {
                    MainItems = Array.Empty<ItemData>();
                    WearItems = Array.Empty<ItemData>();
                    BeltItems = Array.Empty<ItemData>();
                }
            }
        }

        private class PlayerData
        {
            [JsonProperty]
            private Dictionary<ulong, PlayerUsageData> _players = new Dictionary<ulong, PlayerUsageData>();

            internal bool Find(ulong playerId, out PlayerUsageData playerUsageData) => _players.TryGetValue(playerId, out playerUsageData);

            internal bool Exists(ulong playerId) => _players.ContainsKey(playerId);

            internal PlayerUsageData this[ulong key]
            {
                get
                {
                    if (_players.TryGetValue(key, out PlayerUsageData tValue))
                        return tValue;

                    tValue = (PlayerUsageData)Activator.CreateInstance(typeof(PlayerUsageData));
                    _players.Add(key, tValue);
                    return tValue;
                }
                set
                {
                    if (value == null)
                    {
                        _players.Remove(key);
                        return;
                    }
                    _players[key] = value;
                }
            }

            internal void OnKitClaimed(BasePlayer player, KitData.Kit kit)
            {
                if (kit.MaximumUses == 0 && kit.Cooldown == 0)
                    return;

                if (!_players.TryGetValue(player.userID, out PlayerUsageData playerUsageData))
                    playerUsageData = _players[player.userID] = new PlayerUsageData();

                playerUsageData.OnKitClaimed(kit);
            }
            
            internal bool ClearKitUses(BasePlayer player, KitData.Kit kit)
            {
                if (!_players.TryGetValue(player.userID, out PlayerUsageData playerUsageData))
                    return false;

                playerUsageData.ClearKitUses(kit.Name);
                return true;
            }

            internal void Wipe() => _players.Clear();

            internal bool IsValid => _players != null;

            public class PlayerUsageData
            {
                [JsonProperty]
                private Hash<string, KitUsageData> _usageData = new Hash<string, KitUsageData>();

                public bool ClaimAutoKits { get; set; } = true;

                internal double GetCooldownRemaining(string name)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        return 0;

                    double currentTime = CurrentTime;

                    return currentTime > kitUsageData.NextUseTime ? 0 : kitUsageData.NextUseTime - CurrentTime;
                }

                internal void SetCooldownRemaining(string name, double seconds)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        return;

                    kitUsageData.NextUseTime = CurrentTime + seconds;
                }

                internal int GetKitUses(string name)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        return 0;

                    return kitUsageData.TotalUses;
                }

                internal void SetKitUses(string name, int amount)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        return;

                    kitUsageData.TotalUses = amount;
                }

                internal void ClearKitUses(string name)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        return;

                    kitUsageData.TotalUses = 0;
                    kitUsageData.NextUseTime = 0;
                }

                internal void OnKitClaimed(KitData.Kit kit)
                {
                    if (!_usageData.TryGetValue(kit.Name, out KitUsageData kitUsageData))
                        kitUsageData = _usageData[kit.Name] = new KitUsageData();

                    kitUsageData.OnKitClaimed(kit.Cooldown);
                }

                internal void InsertOldData(string name, int totalUses, double nextUse)
                {
                    if (!_usageData.TryGetValue(name, out KitUsageData kitUsageData))
                        kitUsageData = _usageData[name] = new KitUsageData();

                    kitUsageData.NextUseTime = nextUse;
                    kitUsageData.TotalUses = totalUses;
                }

                public class KitUsageData
                {
                    public int TotalUses { get; set; }

                    public double NextUseTime { get; set; }

                    internal void OnKitClaimed(int cooldownSeconds)
                    {
                        TotalUses += 1;
                        NextUseTime = CurrentTime + cooldownSeconds;
                    }
                }
            }            
        }        
        #endregion

        #region Serialized Items
        private static Item CreateItem(ItemData itemData)
        {
            Item item = ItemManager.CreateByItemID(itemData.ItemID, itemData.Amount, itemData.Skin);
            
            if (!string.IsNullOrEmpty(itemData.DisplayName))
                item.name = itemData.DisplayName;

            if (!string.IsNullOrEmpty(itemData.Text))
                item.text = itemData.Text;
            
            item._condition = itemData.Condition;
            item._maxCondition = itemData.MaxCondition;
            
            if (itemData.Frequency > 0)
            {
                ItemModRFListener rfListener = item.info.GetComponentInChildren<ItemModRFListener>();
                if (rfListener)
                    (BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as PagerEntity)?.ChangeFrequency(itemData.Frequency);  
            }

            if (itemData.BlueprintItemID != 0)
            {
                if (item.instanceData == null)
                    item.instanceData = new ProtoBuf.Item.InstanceData();

                item.instanceData.ShouldPool = false;

                item.instanceData.blueprintAmount = 1;
                item.instanceData.blueprintTarget = itemData.BlueprintItemID;

                item.MarkDirty();
            }

            FlameThrower flameThrower = item.GetHeldEntity() as FlameThrower;
            if (flameThrower)
                flameThrower.ammo = itemData.Ammo;

            if (itemData.Contents != null)
            {
                foreach (ItemData contentData in itemData.Contents)
                {
                    Item newContent = CreateItem(contentData);
                    if (newContent != null)
                    {
                        if (!newContent.MoveToContainer(item.contents))
                            newContent.Remove();
                    }
                }
            }
            
            if (itemData.Container != null)
            {
                if (item.contents == null)
                {
                    ItemModContainerArmorSlot armorSlot = FindItemMod<ItemModContainerArmorSlot>(item);
                    if (armorSlot)
                        armorSlot.CreateAtCapacity(itemData.Container.slots, item);
                    else
                    {
                        item.contents = Pool.Get<ItemContainer>();
                        item.contents.ServerInitialize(item, itemData.Container.slots);
                        item.contents.GiveUID();
                    }
                }
                itemData.Container.Load(item.contents);
            }
            
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon)
            {
                weapon.DelayedModsChanged();
                
                if (!string.IsNullOrEmpty(itemData.Ammotype))
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemData.Ammotype);
                weapon.primaryMagazine.contents = itemData.Ammo;
            }


            item.MarkDirty();

            return item;
        }

        private static T FindItemMod<T>(Item item) where T : ItemMod
        {
            foreach (ItemMod itemMod in item.info.itemMods)
            {
                if (itemMod is T mod)
                    return mod;
            }

            return null;
        }

        public class ItemData
        {
            public string Shortname { get; set; }

            public string DisplayName { get; set; }

            public ulong Skin { get; set; }

            public int Amount { get; set; }

            public float Condition { get; set; }

            public float MaxCondition { get; set; }

            public int Ammo { get; set; }

            public string Ammotype { get; set; }

            public int Position { get; set; }

            public int Frequency { get; set; }

            public string BlueprintShortname { get; set; }

            public string Text { get; set; }
            
            /// <summary>
            /// Deprecated, replaced by serializing the item container instead of just the items in it
            /// </summary>
            public ItemData[] Contents { get; set; }
            
            public ItemContainer Container { get; set; }


            [JsonIgnore]
            private int _itemId;

            [JsonIgnore]
            private int _blueprintItemId;

            [JsonIgnore]
            private JObject _jObject;


            [JsonIgnore]
            internal int ItemID
            {
                get
                {
                    if (_itemId == 0)
                        _itemId = ItemManager.itemDictionaryByName[Shortname].itemid;
                    return _itemId;
                }
            }

            [JsonIgnore]
            internal bool IsBlueprint => Shortname.Equals(BLUEPRINT_BASE);

            [JsonIgnore]
            internal int BlueprintItemID
            {
                get
                {
                    if (_blueprintItemId == 0 && !string.IsNullOrEmpty(BlueprintShortname))
                        _blueprintItemId = ItemManager.itemDictionaryByName[BlueprintShortname].itemid;
                    return _blueprintItemId;
                }
            }

            [JsonIgnore]
            internal JObject ToJObject
            {
                get
                {
                    if (_jObject == null)
                    {
                        _jObject = new JObject
                        {
                            ["Shortname"] = Shortname,
                            ["DisplayName"] = DisplayName,
                            ["SkinID"] = Skin,
                            ["Amount"] = Amount,
                            ["Condition"] = Condition,
                            ["MaxCondition"] = MaxCondition,
                            ["IsBlueprint"] = BlueprintItemID != 0,
                            ["Ammo"] = Ammo,
                            ["AmmoType"] = Ammotype,
                            ["Text"] = Text,
                            ["Contents"] = new JArray()
                        };

                        for (int i = 0; i < Contents?.Length; i++)
                            (_jObject["Contents"] as JArray).Add(Contents[i].ToJObject);

                        if (Container != null && Container.contents.Count > 0)
                        {
                            for (int i = 0; i < Container.contents.Count; i++)
                                (_jObject["Contents"] as JArray).Add(Container.contents[i].ToJObject);
                        }
                    }

                    return _jObject;
                }
            }

            internal ItemData()
            {
            }

            internal ItemData(Item item)
            {
                Shortname = item.info.shortname;
                Amount = item.amount;
                DisplayName = item.name;
                Text = item.text;

                BaseEntity heldEntity = item.GetHeldEntity();
                if (heldEntity)
                {
                    Ammotype = heldEntity is BaseProjectile projectile ? projectile.primaryMagazine.ammoType.shortname : null;
                    Ammo = heldEntity is BaseProjectile baseProjectile ? baseProjectile.primaryMagazine.contents :
                        heldEntity is FlameThrower thrower ? thrower.ammo : 0;
                }

                Position = item.position;
                Skin = item.skin;

                Condition = item.condition;
                MaxCondition = item.maxCondition;

                Frequency = ItemModAssociatedEntity<PagerEntity>.GetAssociatedEntity(item)?.GetFrequency() ?? -1;

                if (item.instanceData != null && item.instanceData.blueprintTarget != 0)
                    BlueprintShortname = ItemManager.FindItemDefinition(item.instanceData.blueprintTarget).shortname;

                // Deprecated
                //Contents = item.contents?.itemList.Select(item1 => new ItemData(item1)).ToArray();

                if (item.contents != null)
                    Container = new ItemContainer(item.contents);
            }

            public class InstanceData
            {
                public int DataInt { get; set; }

                public int BlueprintTarget { get; set; }

                public int BlueprintAmount { get; set; }

                public uint SubEntityNetID { get; set; }

                internal InstanceData()
                {
                }

                internal InstanceData(Item item)
                {
                    if (item.instanceData == null)
                        return;

                    DataInt = item.instanceData.dataInt;
                    BlueprintAmount = item.instanceData.blueprintAmount;
                    BlueprintTarget = item.instanceData.blueprintTarget;
                }

                internal void Restore(Item item)
                {
                    if (item.instanceData == null)
                        item.instanceData = new ProtoBuf.Item.InstanceData();

                    item.instanceData.ShouldPool = false;

                    item.instanceData.blueprintAmount = BlueprintAmount;
                    item.instanceData.blueprintTarget = BlueprintTarget;
                    item.instanceData.dataInt = DataInt;

                    item.MarkDirty();
                }

                internal bool IsValid => DataInt != 0 || BlueprintAmount != 0 || BlueprintTarget != 0;
            }

            public class ItemContainer
            {
                public int slots;
                public float temperature;
                public int flags;
                public int allowedContents;
                public int maxStackSize;
                public List<int> allowedItems;
                public List<int> availableSlots;
                public int volume;
                public List<ItemData> contents;
                
                public ItemContainer(){}

                public ItemContainer(global::ItemContainer container)
                {
                    contents = new List<ItemData>();
                    slots = container.capacity;
                    temperature = container.temperature;
                    allowedContents = (int)container.allowedContents;
                    
                    if (container.HasLimitedAllowedItems)
                    {
                        allowedItems = new List<int>();
                        for (int i = 0; i < container.onlyAllowedItems.Length; i++)
                        {
                            if (container.onlyAllowedItems[i])
                            {
                                allowedItems.Add(container.onlyAllowedItems[i].itemid);
                            }
                        }
                    }

                    flags = (int)container.flags;
                    maxStackSize = container.maxStackSize;
                    volume = container.containerVolume;
                    
                    if (container.availableSlots is { Count: > 0 })
                    {
                        availableSlots = new List<int>();
                        for (int j = 0; j < container.availableSlots.Count; j++)
                        {
                            availableSlots.Add((int)container.availableSlots[j]);
                        }
                    }

                    for (int k = 0; k < container.itemList.Count; k++)
                    {
                        Item item = container.itemList[k];
                        if (item.IsValid())
                        {
                            contents.Add(new ItemData(item));
                        }
                    }
                }

                public void Load(global::ItemContainer itemContainer)
                {
                    itemContainer.capacity = slots;
                    itemContainer.itemList = Pool.Get<List<Item>>();
                    itemContainer.temperature = temperature;
                    itemContainer.flags = (global::ItemContainer.Flag)flags;
                    itemContainer.allowedContents = (global::ItemContainer.ContentsType)((allowedContents == 0) ? 1 : allowedContents);
                    
                    if (allowedItems is { Count: > 0 })
                    {
                        itemContainer.onlyAllowedItems = new ItemDefinition[allowedItems.Count];
                        for (int i = 0; i < allowedItems.Count; i++)
                        {
                            itemContainer.onlyAllowedItems[i] = ItemManager.FindItemDefinition(allowedItems[i]);
                        }
                    }
                    else
                    {
                        itemContainer.onlyAllowedItems = null;
                    }

                    itemContainer.maxStackSize = maxStackSize;
                    itemContainer.containerVolume = volume;
                    itemContainer.availableSlots.Clear();
                    
                    if (availableSlots != null)
                    {
                        for (int j = 0; j < availableSlots.Count; j++)
                        {
                            itemContainer.availableSlots.Add((ItemSlot)availableSlots[j]);
                        }
                    }

                    foreach (ItemData itemData in contents)
                    {
                        Item item = CreateItem(itemData);
                        if (item == null)
                            continue;

                        if (!item.MoveToContainer(itemContainer, itemData.Position) && !item.MoveToContainer(itemContainer))
                            item.Remove();
                    }

                    itemContainer.MarkDirty();
                }
            }
        }

        #endregion

        #region Localization
        private string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId != 0U ? playerId.ToString() : null);

        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Error.EmptyKitName"] = "No kit name was specified",
            ["Error.InvalidKitName"] = "No kit exists with the specified name",
            ["Error.CantClaimNow"] = "Another plugin is preventing you from receiving a kit",
            ["Error.CanClaim.Auth"] = "You do not have the required auth level to access this kit",
            ["Error.CanClaim.Permission"] = "You do not have the required permission to access this kit",
            ["Error.CanClaim.Cooldown"] = "You have a cooldown of {0} remaining before you can claim this kit",
            ["Error.CanClaim.MaxUses"] = "You have already reached the maximum number of uses allowed for this kit",
            ["Error.CanClaim.WipeCooldown"] = "This kit has a post-wipe cooldown of {0} remaining",
            ["Error.CanClaim.InventorySpace"] = "You do not have enough space in your inventory to claim this kit",
            ["Error.CanClaim.InsufficientFunds"] = "You need {0} {1} to claim this kit",
            ["Error.AutoKitDisabled"] = "Skipped giving auto-kit as you have it disabled",


            ["Cost.Scrap"] = "Scrap",
            ["Cost.ServerRewards"] = "RP",
            ["Cost.Economics"] = "Coins",

            ["Notification.KitReceived"] = "You have received the kit: <color=#ce422b>{0}</color>",

            ["Chat.Help.Title"] = "<size=18><color=#ce422b>Kits </color></size><size=14>v{0}</size>",
            ["Chat.Help.1"] = "<color=#ce422b>/kit</color> - Open the Kit menu",
            ["Chat.Help.9"] = "<color=#ce422b>/kit autokit</color> - Toggle auto-kits on/off",
            ["Chat.Help.2"] = "<color=#ce422b>/kit <name></color> - Claim the specified kit",
            ["Chat.Help.3"] = "<color=#ce422b>/kit new</color> - Create a new kit",
            ["Chat.Help.4"] = "<color=#ce422b>/kit edit <name></color> - Edit the specified kit",
            ["Chat.Help.5"] = "<color=#ce422b>/kit delete <name></color> - Delete the specified kit",
            ["Chat.Help.6"] = "<color=#ce422b>/kit list</color> - List all kits",
            ["Chat.Help.7"] = "<color=#ce422b>/kit give <player name or ID> <kit name></color> - Give the target player the specified kit",
            ["Chat.Help.8"] = "<color=#ce422b>/kit givenpc <kit name></color> - Give the NPC you are looking at the specified kit",
            ["Chat.Help.10"] = "<color=#ce422b>/kit reset</color> - Wipe's all player usage data",
            ["Chat.Help.11"] = "<color=#ce422b>/kit resetuses <player ID or name> <kit></color> - Wipes the kit usage for the specified kit and player",

            ["Chat.Error.NotAdmin"] = "You must either be a admin, or have the admin permission to use that command",
            ["Chat.Error.NoKit"] = "You must specify a kit name",
            ["Chat.Error.DoesntExist"] = "The kit <color=#ce422b>{0}</color> does not exist",
            ["Chat.Error.GiveArgs"] = "You must specify target player and a kit name",
            ["Chat.Error.NPCGiveArgs"] = "You must specify a kit name",
            ["Chat.Error.NoNPCTarget"] = "Failed to find the target player",
            ["Chat.Error.NoPlayer"] = "Failed to find a player with the specified name or ID",
            ["Chat.KitList"] = "<color=#ce422b>Kit List:</color> {0}",
            ["Chat.KitDeleted"] = "You have deleted the kit <color=#ce422b>{0}</color>",
            ["Chat.KitGiven"] = "You have given <color=#ce422b>{0}</color> the kit <color=#ce422b>{1}</color>",
            ["Chat.AutoKit.Toggle"] = "Auto-kits have been <color=#ce422b>{0}</color>",
            ["Chat.ResetPlayers"] = "You have wiped player usage data",
            ["Chat.AutoKit.True"] = "enabled",
            ["Chat.AutoKit.False"] = "disabled",
            ["Chat.ResetUses.Error.Args"] = "<color=#ce422b>/kit resetuses <player ID or name> <kit></color>",
            ["Chat.ResetUses.Error.Kit"] = "No kit found with the specified name",
            ["Chat.ResetUses.Error.Player"] = "No player found with the specified name or ID",
            ["Chat.ResetUses.Success"] = "You have reset the kit uses of {0} for the kit {1}",

            ["UI.Title"] = "Kits",
            ["UI.Title.Editor"] = "Kit Editor",
            ["UI.OnCooldown"] = "On Cooldown",
            ["UI.Cooldown"] = "Cooldown : {0}",
            ["UI.MaximumUses"] = "At Redeem Limit",
            ["UI.Purchase"] = "Purchase",
            ["UI.Cost"] = "Cost : {0} {1}",
            ["UI.Redeem"] = "Redeem",
            ["UI.Details"] = "Kit Details",
            ["UI.Name"] = "Name",
            ["UI.Description"] = "Description",
            ["UI.Usage"] = "Usage Details",
            ["UI.MaxUses"] = "Maximum Uses",
            ["UI.YourUses"] = "Your Uses",
            ["UI.CooldownTime"] = "Cooldown Time",
            ["UI.CooldownRemaining"] = "Remaining Cooldown",
            ["UI.None"] = "None",
            ["UI.PurchaseCost"] = "Purchase Cost",
            ["UI.CopyPaste"] = "CopyPaste Support",
            ["UI.FileName"] = "File Name",
            ["UI.KitItems"] = "Kit Items",
            ["UI.MainItems"] = "Main Items",
            ["UI.WearItems"] = "Wear Items",
            ["UI.BeltItems"] = "Belt Items",
            ["UI.IconURL"] = "Icon URL",
            ["UI.UsageAuthority"] = "Usage Authority",
            ["UI.Permission"] = "Permission",
            ["UI.AuthLevel"] = "Auth Level",
            ["UI.IsHidden"] = "Is Hidden",
            ["UI.CooldownSeconds"] = "Cooldown (seconds)",
            ["UI.SaveKit"] = "Save Kit",
            ["UI.Overwrite"] = "Overwrite Existing",
            ["UI.ItemManagement"] = "Item Management",
            ["UI.ClearItems"] = "Clear Items",
            ["UI.CopyInv"] = "Copy From Inventory",
            ["UI.CreateNew"] = "Create New",
            ["UI.EditKit"] = "Edit Kit",
            ["UI.NeedsPermission"] = "VIP Kit",
            ["UI.NoKitsAvailable"] = "There are currently no kits available",

            ["SaveKit.Error.NoName"] = "You must enter a kit name",
            ["SaveKit.Error.NoContents"] = "A kit must contain atleast 1 item, or a CopyPaste file reference",
            ["SaveKit.Error.Exists"] = "A kit with that name already exists. If you want to overwrite it check the 'Overwrite' toggle",
            ["SaveKit.Success"] = "You have saved the kit {0}",

            ["EditKit.PermissionPrefix"] = "Permissions must start with the 'kits.' prefix",
            ["EditKit.Number"] = "You must enter a number",
            ["EditKit.Bool"] = "You must enter true or false",
        };
        #endregion
    }
}


// --- End of file: Kits.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/keep-active-item ---
// --- Original File Path: K/KeepActiveItem/KeepActiveItem.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Keep Active Item", "Ryz0r", "2.1.0")]
    [Description("Restores a player's held item in their corpse's hotbar when they die.")]
    
    class KeepActiveItem : RustPlugin
    {
        const string PermissionName = "keepactiveitem.use";
        Dictionary<string, Item> _playerHeldItem = new Dictionary<string, Item>();

        private void Init() => permission.RegisterPermission(PermissionName, this);
        
        private void OnActiveItemChange(BasePlayer player, Item oldItem, ItemId newItemId)
        {
            var item = new Item().FindItem(newItemId);
            if (item == null) return;
            
            if (_playerHeldItem.ContainsKey(player.UserIDString))
            {
                _playerHeldItem[player.UserIDString] = item;
            }
            else
            {
                _playerHeldItem.Add(player.UserIDString, item);
            }
        }

        private void OnPlayerWound(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionName)) return;
            
            if (_playerHeldItem.ContainsKey(player.UserIDString)) _playerHeldItem[player.UserIDString].MoveToContainer(player.inventory.containerBelt);
        }

        private void OnPlayerRecover(BasePlayer player)
        {
            if (_playerHeldItem.ContainsKey(player.UserIDString)) _playerHeldItem.Remove(player.UserIDString);
        }

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionName)) return;
            if (!_playerHeldItem.ContainsKey(player.UserIDString)) return;

            Item item;
            _playerHeldItem.TryGetValue(player.UserIDString, out item);
            if (item == null) return;
            
            item.MoveToContainer(player.inventory.containerBelt);
            _playerHeldItem.Remove(player.UserIDString);
        }
    }
}


// --- End of file: KeepActiveItem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/karma-system ---
// --- Original File Path: K/KarmaSystem/KarmaSystem.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("KarmaSystem", "Ryan", "1.1.0")]
    [Description("Allows players to upvote/downvote other players")]
    internal class KarmaSystem : CovalencePlugin
    {
        #region Config

        private ConfigFile configFile;

        public class ConfigFile
        {
            public Upvote UpvoteSettings { get; set; }
            public Downvote DownvoteSettings { get; set; }
            public Ranking Top { get; set; }
            public Ranking Bottom { get; set; }
            public bool EnableKarmaCommand { get; set; }
            public float Cooldown { get; set; }
            public bool OneVotePerPlayer { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    UpvoteSettings = new Upvote
                    {
                        Amount = 1,
                        EnableCommand = true
                    },
                    DownvoteSettings = new Downvote
                    {
                        Amount = 1,
                        EnableCommand = true
                    },
                    Top = new Ranking()
                    {
                        ShowAmount = 5
                    },
                    Bottom = new Ranking()
                    {
                        ShowAmount = 5,
                    },
                    EnableKarmaCommand = true,
                    Cooldown = 60,
                    OneVotePerPlayer = false
                };
            }
        }

        public class Upvote
        {
            public int Amount { get; set; }
            public bool EnableCommand { get; set; }
        }

        public class Downvote
        {
            public int Amount { get; set; }
            public bool EnableCommand { get; set; }
        }

        public class Ranking
        {
            public int ShowAmount { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            configFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configFile = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configFile);
        }

        #endregion

        #region Lang

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                // Commands
                ["Cmd_Upvote"] =
                "You've upvoted player <color=orange>{0}</color>, they now have <color=orange>{1}</color> karma",
                ["Cmd_Downvote"] =
                "You've downvoted player <color=orange>{0}</color>, they now have <color=orange>{1}</color> karma",
                ["Cmd_Upvoted"] =
                "You've been upvoted by player <color=orange>{0}</color>, you now have <color=orange>{1}</color> karma",
                ["Cmd_Downvoted"] =
                "You've been downvoted by player <color=orange>{0}</color>, you now have <color=orange>{1}</color> karma",
                ["Cmd_Karma"] =
                "You have <color=orange>{0}</color> karma and you have voted for <color=orange>{1}</color> players",
                // Invalid args
                ["Cmd_InvalidArgs"] = "Invalid arguments. Usage: '/<color=orange>{0}</color> {1}'",
                ["Arg_Vote"] = "<player>",
                ["Arg_Ranking"] = "<top> OR <bottom>",
                // FindPlayer
                ["FP_NoPlayers"] = "Found no players with input '<color=orange>{0}</color>'",
                ["FP_MultiplePlayers"] =
                "Found the following players with input '<color=orange>{0}</color>', please refine your input. \n{1}",
                // Cant use
                ["CU_Cooldown"] = "You can't vote for a player for another <color=orange>{0}</color> seconds",
                ["CU_AlreadyVoted"] = "You have already voted for player <color=orange>{0}</color>",
                ["CU_Yourself"] = "You can't vote for yourself, that's cheating!",
                // Ranking
                ["Ranking_Info"] = "- <color=orange>{0}</color> (<color=orange>{1}</color> Karma)"
            }, this);
        }

        #endregion

        #region Data

        private static StoredData storedData;

        public class StoredData
        {
            public Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
        }

        public class PlayerData
        {
            public PlayerData()
            {
                Karma = 0;
                Cooldown = null;
                Votes = new List<string>();
            }

            public int Karma { get; set; }
            public DateTime? Cooldown { get; set; }
            public List<string> Votes { get; set; }
        }

        public class Data
        {
            public static void AddNew(IPlayer player)
            {
                if (!Exists(player))
                {
                    storedData.Players.Add(player.Id, new PlayerData());
                    Save();
                }
            }

            public static void AddVoted(IPlayer player, string ID)
            {
                if (Exists(player))
                {
                    storedData.Players[player.Id].Votes.Add(ID);
                    Save();
                }
            }

            public static bool Exists(IPlayer player)
            {
                if (storedData.Players.ContainsKey(player.Id)) return true;
                return false;
            }

            public static void Remove(IPlayer player)
            {
                if (Exists(player))
                {
                    storedData.Players.Remove(player.Id);
                    Save();
                }
            }

            public static void Clear()
            {
                storedData.Players.Clear();
                Save();
            }

            public static void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject("KarmaSystem", storedData);
            }
        }

        #endregion

        #region Methods

        private IPlayer FindPlayer(IPlayer player, string input)
        {
            var Players = new List<IPlayer>();
            foreach (var target in players.FindPlayers(input))
                if (target.IsConnected)
                    Players.Add(target);
            if (Players.Count > 1)
            {
                player.Reply(Lang("FP_MultiplePlayers", player.Id, input,
                    string.Join(", ", Players.Select(x => x.Name).ToArray())));
                return null;
            }
            if (Players.Count == 1)
            {
                var target = Players.First();
                if (!Data.Exists(target))
                    Data.AddNew(target);
                return target;
            }
            player.Reply(Lang("FP_NoPlayers", player.Id, input));
            return null;
        }

        private bool CanVote(IPlayer player, IPlayer target)
        {
            if (player.Id == target.Id)
            {
                player.Reply(Lang("CU_Yourself", player.Id));
                return false;
            }
            if (Data.Exists(player) && storedData.Players[player.Id].Cooldown != null && storedData.Players[player.Id].Cooldown.Value.AddMinutes(configFile.Cooldown) > DateTime.UtcNow)
            {
                player.Reply(Lang("CU_Cooldown", player.Id, (storedData.Players[player.Id].Cooldown.Value.AddMinutes(configFile.Cooldown) - DateTime.UtcNow).TotalSeconds));
                return false;
            }
            if (Data.Exists(player) && storedData.Players[player.Id].Votes.Contains(target.Id) && configFile.OneVotePerPlayer)
            {
                player.Reply(Lang("CU_AlreadyVoted", player.Id, target.Name));
                return false;
            }
            return true;
        }

        #endregion

        #region API

        int GetKarma(IPlayer player)
        {
            if (!Data.Exists(player))
                Data.AddNew(player);
            return storedData.Players[player.Id].Karma;
        }

        void AddKarma(IPlayer player, int amount)
        {
            if (!Data.Exists(player))
                Data.AddNew(player);
            storedData.Players[player.Id].Karma = storedData.Players[player.Id].Karma + amount;
            Data.Save();
        }

        void RemoveKarma(IPlayer player, int amount)
        {
            if (!Data.Exists(player))
                Data.AddNew(player);
            storedData.Players[player.Id].Karma = storedData.Players[player.Id].Karma - amount;
            Data.Save();
        }

        void AddPlayer(IPlayer player)
        {
            if (!Data.Exists(player))
                return;
            Data.AddNew(player);
        }

        void AddVoted(IPlayer player, string ID)
        {
            if (!Data.Exists(player))
                Data.AddNew(player);
            Data.AddVoted(player, ID);
        }

        void OnVoted(IPlayer player, IPlayer target, int amount)
        {
            storedData.Players[player.Id].Cooldown = DateTime.UtcNow;
            Interface.Call("OnKarmaVote", player, target, amount);
        }

        #endregion

        #region Hooks

        private void Unload()
        {
            Data.Save();
        }

        private void Loaded()
        {
            SaveConfig();
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        [Command("upvote")]
        private void upvoteCmd(IPlayer player, string command, string[] args)
        {
            if (!configFile.UpvoteSettings.EnableCommand)
            {
                return;
            }
            if (args.Length == 0)
            {
                player.Reply(Lang("Cmd_InvalidArgs", player.Id, command, Lang("Arg_Vote", player.Id)));
                return;
            }
            var target = FindPlayer(player, args[0]);
            if (target != null && CanVote(player, target))
            {
                AddKarma(target, configFile.UpvoteSettings.Amount);
                AddVoted(player, target.Id);
                OnVoted(player, target, configFile.UpvoteSettings.Amount);
                var karma = GetKarma(target);
                player.Reply(Lang("Cmd_Upvote", player.Id, target.Name, karma));
                target.Reply(Lang("Cmd_Upvoted", target.Id, player.Name, karma));
            }
        }

        [Command("downvote")]
        private void downvoteCmd(IPlayer player, string command, string[] args)
        {
            if (!configFile.DownvoteSettings.EnableCommand)
            {
                return;
            }
            if (args.Length == 0)
            {
                player.Reply(Lang("Cmd_InvalidArgs", player.Id, command, Lang("Arg_Vote", player.Id)));
                return;
            }
            var target = FindPlayer(player, args[0]);
            if (target != null && CanVote(player, target))
            {
                RemoveKarma(target, configFile.DownvoteSettings.Amount);
                AddVoted(player, target.Id);
                OnVoted(player, target, configFile.DownvoteSettings.Amount);
                var karma = GetKarma(target);
                player.Reply(Lang("Cmd_Downvote", player.Id, target.Name, karma));
                target.Reply(Lang("Cmd_Downvoted", target.Id, player.Name, karma));
            }
        }

        [Command("karma")]
        private void karmaCmd(IPlayer player, string command, string[] args)
        {
            if (!configFile.EnableKarmaCommand)
            {
                return;
            }
            if (args.Length == 0)
            {
                player.Reply(Lang("Cmd_Karma", player.Id, GetKarma(player), storedData.Players[player.Id].Votes.Count));
                return;
            }
            if (args.Length == 1)
            {
                switch (args[0])
                {
                    case "top":
                        foreach (var info in storedData.Players.OrderByDescending(x => x.Value.Karma).Take(configFile.Top.ShowAmount))
                            player.Reply(Lang("Ranking_Info", player.Id, players.FindPlayerById(info.Key).Name, info.Value.Karma));
                        return;

                    case "bottom":
                        foreach (var info in storedData.Players.OrderByDescending(x => x.Value.Karma).Reverse().Take(configFile.Bottom.ShowAmount))
                            player.Reply(Lang("Ranking_Info", player.Id, players.FindPlayerById(info.Key).Name, info.Value.Karma));
                        return;

                    default:
                        var target = FindPlayer(player, args[0]);
                        if (target != null)
                        {
                            if(!Data.Exists(target))
                                Data.AddNew(target);
                            player.Reply(Lang("Ranking_Info", player.Id, target.Name, storedData.Players[target.Id].Karma));
                        }
                        return;
                }
            }
            player.Reply(Lang("Cmd_InvalidArgs", player.Id, command, Lang("Arg_Ranking", player.Id)));
        }

        #endregion
    }
}


// --- End of file: KarmaSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kick-cooldown ---
// --- Original File Path: K/KickCooldown/KickCooldown.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    // TODO LIST
    // Nothing, yet.

    [Info("KickCooldown", "Kappasaurus", "1.0.1")]

    class KickCooldown : CovalencePlugin
    {
        List<string> kicked = new List<string>();
        float kickCooldown = 300f;

        void Init() => LoadConfig();

        void OnUserDisconnected(IPlayer player, string reason)
        {
            if (reason.ToLower().Contains("kick"))
                kicked.Add(player.Id);

            timer.Once(kickCooldown, () =>
            {
                kicked.Remove(player.Id);
            });
        }

        object CanUserLogin(string name, string id, string ip)
        {
            return kicked.Contains(id) ? lang.GetMessage("Kick Cooldown", this, id) : null;
        }

        #region Configuration

        private new void LoadConfig()
        {
            GetConfig(ref kickCooldown, "Kick cooldown (seconds)");

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion

        #region Helpers

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kick Cooldown"] = "You can't join, you're on kick cooldown!"
            }, this);
        }

        #endregion
    }
}

// --- End of file: KickCooldown.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-rewards ---
// --- Original File Path: K/KillRewards/KillRewards.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Kill Rewards", "birthdates", "1.1.2")]
    [Description("Get rewards for getting x amount of kills during 1 life or the entire wipe")]
    public class KillRewards : RustPlugin
    {
        #region Variables

        private const string permission_use = "killrewards.use";

        #endregion

        #region Hooks

        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(permission_use, this);
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>(Name);
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnEntityDeath(BasePlayer target, HitInfo info)
        {
            if (info == null || target == null || !target.userID.IsSteamId()) return;
            if (_config.oneLife) ClearKills(target.UserIDString);
            if (info.InitiatorPlayer == null || info.InitiatorPlayer == target) return;
            var player = info.InitiatorPlayer;
            var ID = player.UserIDString;
            if (!permission.UserHasPermission(ID, permission_use)) return;
            var amount = AddKill(ID);
            KillReward Reward;
            if (!TryGetReward(amount, out Reward)) return;
            Reward.Commands.ForEach(Command => Server.Command(string.Format(Command, ID)));
            player.ChatMessage(string.Format(lang.GetMessage("KillRewarded", this, player.UserIDString), amount));
        }

        private bool TryGetReward(int Kills, out KillReward Reward)
        {
            Reward = _config.rewards.Find(reward => reward.Kills == Kills);
            return Reward != null;
        }

        private void ClearKills(string ID)
        {
            _data.kills.Remove(ID);
        }

        private int AddKill(string ID)
        {
            var kills = 1;
            if (_data.kills.ContainsKey(ID))
                kills = _data.kills[ID]++;
            else
                _data.kills.Add(ID, 1);
            return kills;
        }

        #endregion

        #region Configuration & Language

        private ConfigFile _config;
        private Data _data;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"KillRewarded", "Woohoo! A {0} killstreak!"}
            }, this);
        }

        private class Data
        {
            public readonly Dictionary<string, int> kills = new Dictionary<string, int>();
        }


        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        public class KillReward
        {
            public List<string> Commands;

            [JsonProperty("Kill Goal")] public int Kills;
        }

        public class ConfigFile
        {
            [JsonProperty("One Life?")] public bool oneLife;

            [JsonProperty("Rewards")] public List<KillReward> rewards;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    oneLife = true,
                    rewards = new List<KillReward>
                    {
                        new KillReward
                        {
                            Kills = 1,
                            Commands = new List<string>
                            {
                                "inventory.giveto {0} stones 100"
                            }
                        },
                        new KillReward
                        {
                            Kills = 5,
                            Commands = new List<string>
                            {
                                "inventory.giveto {0} stones 500"
                            }
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: KillRewards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kdr-gui ---
// --- Original File Path: K/KDRGui/KDRGui.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("KDR GUI", "Ankawi", "2.0.3")]
    [Description("GUI that portrays kills, deaths, player name, and K/D ratio")]
    class KDRGui : RustPlugin
    {
        Dictionary<ulong, HitInfo> LastWounded = new Dictionary<ulong, HitInfo>();

        static HashSet<PlayerData> LoadedPlayerData = new HashSet<PlayerData>();
        List<UIObject> UsedUI = new List<UIObject>();

        #region UI Classes

        // UI Classes - Created by LaserHydra
        class UIColor
        {
            double red;
            double green;
            double blue;
            double alpha;

            public UIColor(double red, double green, double blue, double alpha)
            {
                this.red = red;
                this.green = green;
                this.blue = blue;
                this.alpha = alpha;
            }

            public override string ToString()
            {
                return $"{red.ToString()} {green.ToString()} {blue.ToString()} {alpha.ToString()}";
            }
        }

        class UIObject
        {
            List<object> ui = new List<object>();
            List<string> objectList = new List<string>();

            public UIObject()
            {
            }

            public string RandomString()
            {
                string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
                List<char> charList = chars.ToList();

                string random = "";

                for (int i = 0; i <= UnityEngine.Random.Range(5, 10); i++)
                    random = random + charList[UnityEngine.Random.Range(0, charList.Count - 1)];

                return random;
            }

            public void Draw(BasePlayer player)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", JsonConvert.SerializeObject(ui).Replace("{NEWLINE}", Environment.NewLine));
            }

            public void Destroy(BasePlayer player)
            {
                foreach (string uiName in objectList)
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", uiName);
            }

            public string AddPanel(string name, double left, double top, double width, double height, UIColor color, bool mouse = false, string parent = "Overlay")
            {
                name = name + RandomString();

                string type = "";
                if (mouse) type = "NeedsCursor";

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Image"},
                                {"color", color.ToString()}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            },
                            new Dictionary<string, string> {
                                {"type", type}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddText(string name, double left, double top, double width, double height, UIColor color, string text, int textsize = 15, string parent = "Overlay", int alignmode = 0)
            {
                name = name + RandomString(); text = text.Replace("\n", "{NEWLINE}"); string align = "";

                switch (alignmode)
                {
                    case 0: { align = "LowerCenter"; break; };
                    case 1: { align = "LowerLeft"; break; };
                    case 2: { align = "LowerRight"; break; };
                    case 3: { align = "MiddleCenter"; break; };
                    case 4: { align = "MiddleLeft"; break; };
                    case 5: { align = "MiddleRight"; break; };
                    case 6: { align = "UpperCenter"; break; };
                    case 7: { align = "UpperLeft"; break; };
                    case 8: { align = "UpperRight"; break; };
                }

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Text"},
                                {"text", text},
                                {"fontSize", textsize.ToString()},
                                {"color", color.ToString()},
                                {"align", align}
                            },
                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddButton(string name, double left, double top, double width, double height, UIColor color, string command = "", string parent = "Overlay", string closeUi = "")
            {
                name = name + RandomString();

                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Button"},
                                {"close", closeUi},
                                {"command", command},
                                {"color", color.ToString()},
                                {"imagetype", "Tiled"}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString()} {((1 - top) - height).ToString()}"},
                                {"anchormax", $"{(left + width).ToString()} {(1 - top).ToString()}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }

            public string AddImage(string name, double left, double top, double width, double height, UIColor color, string url = "", string parent = "Overlay")
            {
                ui.Add(new Dictionary<string, object> {
                    {"name", name},
                    {"parent", parent},
                    {"components",
                        new List<object> {
                            new Dictionary<string, string> {
                                {"type", "UnityEngine.UI.Button"},
                                {"sprite", "assets/content/textures/generic/fulltransparent.tga"},
                                {"url", url},
                                {"color", color.ToString()},
                                {"imagetype", "Tiled"}
                            },

                            new Dictionary<string, string> {
                                {"type", "RectTransform"},
                                {"anchormin", $"{left.ToString().Replace(",", ".")} {((1 - top) - height).ToString().Replace(",", ".")}"},
                                {"anchormax", $"{(left + width).ToString().Replace(",", ".")} {(1 - top).ToString().Replace(",", ".")}"}
                            }
                        }
                    }
                });

                objectList.Add(name);
                return name;
            }
        }
        #endregion

        #region Data
        class PlayerData
        {
            public ulong id;
            public string name;
            public int kills;
            public int deaths;
            internal float KDR => deaths == 0 ? kills : (float)Math.Round(((float)kills) / deaths, 1);

            internal static void TryLoad(BasePlayer player)
            {
                if (Find(player) != null)
                    return;

                PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"KDRGui/{player.userID}");

                if (data == null || data.id == 0)
                {
                    data = new PlayerData
                    {
                        id = player.userID,
                        name = player.displayName
                    };
                }
                else
                    data.Update(player);

                data.Save();
                LoadedPlayerData.Add(data);
            }

            internal void Update(BasePlayer player)
            {
                name = player.displayName;
                Save();
            }

            internal void Save() => Interface.Oxide.DataFileSystem.WriteObject($"KDRGui/{id}", this, true);
            internal static PlayerData Find(BasePlayer player)
            {

                PlayerData data = LoadedPlayerData.ToList().Find((p) => p.id == player.userID);

                return data;
            }
        }
        #endregion

        #region Hooks
        void OnPlayerConnected(BasePlayer player)
        {
            PlayerData.TryLoad(player);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            PlayerData.TryLoad(player);
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                foreach (var ui in UsedUI)
                    ui.Destroy(player);
            }
        }

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                PlayerData.TryLoad(player);
            }

        }
        HitInfo TryGetLastWounded(ulong id, HitInfo info)
        {
            if (LastWounded.ContainsKey(id))
            {
                HitInfo output = LastWounded[id];
                LastWounded.Remove(id);
                return output;
            }

            return info;
        }

        void OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (info?.Initiator?.ToPlayer() != null)
            {
                NextTick(() =>
                {
                    if (player.IsWounded())
                        LastWounded[player.userID] = info;
                });
            }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            try
            {
                if (player == info.Initiator) return;
                if (player == null || info.Initiator == null) return;

                if (player.IsWounded())
                {
                    info = TryGetLastWounded(player.userID, info);
                }
                if (info?.Initiator != null && info.Initiator is BasePlayer)
                {
                    PlayerData victimData = PlayerData.Find(player);
                    PlayerData attackerData = PlayerData.Find((BasePlayer)info.Initiator);

                    victimData.deaths++;
                    attackerData.kills++;

                    victimData.Save();
                    attackerData.Save();
                }
            }
            catch (Exception ex)
            {
            }
        }
        #endregion

        #region UI Handling
        void DrawKDRWindow(BasePlayer player)
        {
            UIObject ui = new UIObject();
            string panel = ui.AddPanel("panel1", 0.0132382892057026, 0.0285714285714286, 0.958248472505092, 0.874285714285714, new UIColor(0, 0, 0, 1), true, "Overlay");
            ui.AddText("label8", 0.675876726886291, 0.248366013071895, 0.272051009564293, 0.718954248366013, new UIColor(1, 1, 1, 1), GetNames(), 24, panel, 7);
            ui.AddText("label7", 0.483528161530287, 0.248366013071895, 0.0563230605738576, 0.718954248366013, new UIColor(1, 1, 1, 1), GetKDRs(), 24, panel, 6);
            ui.AddText("label6", 0.269925611052072, 0.248366013071895, 0.0456960680127524, 0.718954248366013, new UIColor(1, 1, 1, 1), GetDeaths(), 24, panel, 6);
            ui.AddText("label5", 0.0786397449521785, 0.248366013071895, 0.0456960680127524, 0.718954248366013, new UIColor(1, 1, 1, 1), GetTopKills(), 24, panel, 6);
            string close = ui.AddButton("button1", 0.849096705632306, 0.0326797385620915, 0.124335812964931, 0.0871459694989107, new UIColor(1, 0, 0, 1), "", panel, panel);
            ui.AddText("button1_Text", 0, 0, 1, 1, new UIColor(0, 0, 0, 1), "Close", 19, close, 3);
            ui.AddText("label4", 0.470775770456961, 0.163398692810458, 0.0935175345377258, 0.0610021786492375, new UIColor(1, 0, 0, 1), "K/D Ratio", 24, panel, 7);
            ui.AddText("label3", 0.260361317747078, 0.163398692810458, 0.0722635494155154, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Deaths", 24, panel, 7);
            ui.AddText("label2", 0.0786397449521785, 0.163398692810458, 0.0467587672688629, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Kills", 24, panel, 7);
            ui.AddText("label1", 0.675876726886291, 0.163398692810458, 0.125398512221041, 0.0610021786492375, new UIColor(1, 0, 0, 1), "Player Name", 24, panel, 7);

            ui.Draw(player);
            UsedUI.Add(ui);
        }
        private void LoadSleepers()
        {
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
                PlayerData.TryLoad(player);
        }
        string GetTopKills()
        {
            LoadSleepers();
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.kills}").Take(15).ToArray());
        }
        string GetDeaths()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.deaths}").Take(15).ToArray());
        }
        string GetKDRs()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.KDR}").Take(15).ToArray());
        }
        string GetNames()
        {
            return string.Join("\n", LoadedPlayerData.OrderByDescending((d) => d.kills).Select((d) => $"{d.name}").Take(15).ToArray());
        }
        #endregion

        //add a new command to delete data, use WriteObject(null)
        #region Commands
        [ChatCommand("top")]
        void cmdTop(BasePlayer player, string command, string[] args)
        {
            DrawKDRWindow(player);
        }

        [ChatCommand("kdr")]
        void cmdKdr(BasePlayer player, string command, string[] args)
        {
            GetCurrentStats(player);
        }

        void GetCurrentStats(BasePlayer player)
        {
            PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"KDRGui/{player.userID}");
            int kills = data.kills;
            int deaths = data.deaths;
            string playerName = data.name;
            float kdr = data.KDR;

            PrintToChat(player, "<color=#ff0000> Player Name : </color>" + $"{playerName}"
                        + "\n" + "<color=#00ff00> Kills : </color>" + $"{kills}"
                        + "\n" + "<color=#00ff00> Deaths : </color>" + $"{deaths}"
                        + "\n" + "<color=#00ff00> K/D Ratio : </color>" + $"{kdr}");
        }
        #endregion
    }
}

// --- End of file: KDRGui.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-records ---
// --- Original File Path: K/KillRecords/KillRecords.cs ---

﻿/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using MySql.Data.MySqlClient;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Kill Records", "MACHIN3", "1.3.800")]
	[Description("Records number of kills by each player for selected entities")]
	public class KillRecords : RustPlugin
	{
		public const string version = "1.3.800";
        #region Update Log

        /*****************************************************
		【 𝓜𝓐𝓒𝓗𝓘𝓝𝓔 】
        Website: https://www.rustlevels.com/
        Discord: http://discord.rustlevels.com/
        *****************************************************/
        #region 1.3.8
        /*

		✯ Fixed Patrol Helicopter not being tracked
		✯ Fixed Animal Harvest not being tracked
		✯ Fixed Human Harvest not being tracked
		✯ Fixed wolf tracking with new wolf AI

		NOTES:
			* Report any issues in our discord
			
		*/
        #endregion
        #region 1.3.7
        /*

		✯ Fixed data loading issues due to last major update

		NOTES:
			* There is a known issue with NightZombies mod not counting some kills which is still being worked on
			
		*/
        #endregion
        #region 1.3.6
        /*
		✯ Version 1.3.6

		✯ New special character ignore method for SQL usage
		✯ Possible fix for SQL NRE errors
		✯ Fix for Rust May Update

		*/
        #endregion
        #region 1.3.5
        /*
		✯ update 1.3.5
		✯ Updated for OnCollectiblePickup hook changes
		*/
        #endregion
        #region 1.3.4
        /*
		✯ update 1.3.4
		✯ Fixed OnEntityDeath error from turrets
		*/
        #endregion
        #region 1.3.3
        /*
		✯ update 1.3.3
		✯ Added Scare Crow tracking
		✯ Added Turret Tracking
		✯ Code cleanup
		*/
        #endregion
        #region 1.3.2
        /*
		✯ update 1.3.2
		✯ Fixed non players being added to data records
		✯ Will automatically remove any non valid steam players from records
		*/
        #endregion
        #region 1.3.1
        /*
		✯ update 1.3.1
		✯ Fixed SQL issues with adding Polar Bear tracking
		✯ All chat commands are now configurable
		✯ Added harvest API for XPerience and XPerienceAddon
        ✯ New SQL update method for creating new columns in existing SQL database

		New Harvest Tracking:
		✯ Trees cut
		✯ Ore mined
		✯ Wood pickup
		✯ Ore pickup
		✯ Berries
		✯ Pumpkins
		✯ Potatos
		✯ Corn
		✯ Mushrrom
		✯ Hemp
		✯ Seeds

		Harvest tracking will only count the number of harvests NOT total resources gathered! XPerience will track total amount harvested.
		*/
        #endregion
        #region 1.3.0
        /*
		✯ update 1.3.0
		✯ Fixed horse kills not counting
		✯ Added PolarBear Tracking
		*/
        #endregion
        #region 1.2.9
        /*
		✯ update 1.2.9
		✯ Fixed scientists kills not counting
		*/
        #endregion
        #region 1.2.8
        /*
		✯ update 1.2.8
		✯ Cleaned up coding
		✯ Added API needed for XPerienceAddon
		*/
        #endregion
        #region 1.2.7
        /*
		✯ update 1.2.7
		✯ Fixed SQL update issues
		*/
        #endregion
        #region 1.2.6
        /*
		✯ update 1.2.6
		✯ Improved code performance
		*/
        #endregion
        #region 1.2.5
        /*
		✯ update 1.2.5
		✯ Added BradleyAPC and Patrol Helicopter tracking
		*/
        #endregion
        #region 1.2.4
        /*
		✯ update 1.2.4
		✯ Added UINotify Support
		✯ Complete rewrite of config file and settings
		✯ Changed OnFishCaught to OnFishCatch so fish tracking works again
		*/
        #endregion
        #region 1.2.3
        /*
		✯ update 1.2.3
		✯ Added Fish tracking 
		*/
        #endregion
        #region 1.2.2
        /*
		✯ update 1.2.2
		✯ fixed SQL errors with player displayname 
		✯ fixed players not being able to disable chat messages when given permission
		✯ fix for onplayerdeath error
		*/
        #endregion
        #region 1.2.1
        /*
		✯ this update 1.2.1
		✯ fixed possible player search issues when using SQL
		✯ fixed issues with SQL not tracking stats
		✯ added support for ImageLibrary for player avatars
		✯ added new leaderboards UI
		✯ linked all UIs with buttons
		✯ names in all UIs now clickable to player stats
		✯ added option to manually order each entity in UIs
		✯ added command to clear all player data
		*/
        #endregion
        #region 1.2.0
        /*
		✯ update 1.2.0
		✯ fixed top ten list showing players with 0
		✯ new global kill stats
		✯ option to disable UI
		✯ rewrote top list with selection menu
		✯ SQL support
		✯ New commands (datafile save, sql save, etc..)
		✯ Added horse kill tracking
		*/
        #endregion
        #region 1.1.9
        /*
		✯ update 1.1.9
		✯ cleaned coding
		✯ fixed killchat permission
		✯ More chat argument definitions
		✯ Added animal/corpse harvest to top lists
		*/
        #endregion
        #region 1.1.8
        /*
		✯ update 1.1.8
		✯ Changed UI locations
		✯ rewrote webrequest & labels
		✯ Changed star to arrow on top list
		✯ Rewrote language and chat messages
		✯ Full language support
		✯ Option to limit kill messages
		✯ Permissions to disable kill messages
		✯ Option for players to disable kill messages
		✯ More chat argument definitions
		*/
        #endregion
        #endregion

        #region References
        [PluginReference]
		private readonly Plugin ImageLibrary, UINotify;
		#endregion

		#region Fields
		private PlayData _playData;
		private TempData _tempData;
		private HeliHits _heliHits;
		private DynamicConfigFile _KillData;
		private DynamicConfigFile _EntityData;
		private Dictionary<string, Record> _recordCache;
		private Dictionary<ulong, Data> _dataCache;
		private Dictionary<ulong, Heli> _heliCache;
		private Configuration config;
		private const string KRUIName = "KillRecordsUI";
		private const string KRUIMainName = "KillRecordsUIMain";
		private const string KRUISelection = "KillRecordsUISelection";
		private const string Admin = "killrecords.admin";
		private const string Killchat = "killrecords.killchat";
        private Timer _helitracker;
        #endregion

        #region Config
        private class Configuration : SerializableConfiguration
		{
			[JsonProperty("Tracking Options")]
			public TrackingOptions trackingoptions = new TrackingOptions();

			[JsonProperty("Player Chat Commands")]
			public PlayerChatCommands playerChatCommands = new PlayerChatCommands();

			[JsonProperty("Admin Chat Commands")]
			public AdminChatCommands adminChatCommands = new AdminChatCommands();

			[JsonProperty("Harvest Options")]
			public HarvestOptions harvestoptions = new HarvestOptions();

			[JsonProperty("Order Options")]
			public OrderOptions orderoptions = new OrderOptions();

			[JsonProperty("Chat & UI Options")]
			public ChatUI chatui = new ChatUI();

			[JsonProperty("Web Request")]
			public WebRequest webrequest = new WebRequest();

			[JsonProperty("SQL")]
			public KRSQL krsql = new KRSQL();
		}
		public class PlayerChatCommands
		{
			public string krhelp = "krhelp";
			public string pkills = "pkills";
			public string pkillschat = "pkillschat";
			public string topkills = "topkills";
			public string topkillschat = "topkillschat";
			public string totalkills = "totalkills";
			public string totalkillschat = "totalkillschat";
			public string leadkills = "leadkills";
			public string pstats = "pstats";
			public string pstatschat = "pstatschat";
			public string topstats = "topstats";
			public string totalstats = "totalstats";
			public string totalstatschat = "totalstatschat";
			public string killchat = "killchat";
		}
		public class AdminChatCommands
		{
			public string krhelpadmin = "krhelpadmin";
			public string krweb = "krweb";
			public string krsql = "krsql";
			public string krbackup = "krbackup";
			public string krreset = "krreset";
		}
		private class TrackingOptions
        {
			public bool Trackchicken = true;
			public bool Trackboar = true;
			public bool Trackstag = true;
			public bool Trackwolf = true;
			public bool Trackbear = true;
			public bool Trackpolarbear = true;
			public bool Trackshark = true;
			public bool Trackhorse = true;
			public bool Trackfish = true;
			public bool TrackPlayer = true;
			public bool Trackscientist = true;
			public bool Trackscarecrow = true;
			public bool Trackdweller = true;
			public bool Tracklootcontainer = true;
			public bool Trackunderwaterlootcontainer = true;
			public bool Trackbradhelicrate = true;
			public bool Trackhackablecrate = true;
			public bool Trackdeaths = true;
			public bool Tracksuicides = true;
			public bool TrackAnimalHarvest = true;
			public bool TrackCorpseHarvest = true;
			public bool TrackBradley = true;
			public bool TrackHeli = true;
			public bool Trackturret = true;
			public bool Trackzombie = true;
		}
		private class HarvestOptions
		{
			public bool treescut = true;
			public bool oremined= true;
			public bool cactuscut= false;
			public bool woodpickup= true;
			public bool orepickup= true;
			public bool berriespickup= true;
			public bool pumpkinpickup= true;
			public bool potatopickup= true;
			public bool cornpickup= true;
			public bool mushroompickup= true;
			public bool hemppickup= true;
			public bool seedpickup= true;
        }
		private class OrderOptions
        {
			public int chickenpos = 1;
			public int boarpos = 2;
			public int stagpos = 3;
			public int wolfpos = 4;
			public int bearpos = 5;
			public int polarbearpos = 22;
			public int sharkpos = 6;
			public int horsepos = 7;
			public int fishpos = 19;
			public int playerpos = 8;
			public int scientistpos = 9;
			public int dwellerpos = 10;
			public int lootpos = 11;
			public int unlootpos = 12;
			public int bradhelicratepos = 13;
			public int hackablecratepos = 14;
			public int deathpos = 15;
			public int suicidepos = 16;
			public int corpsepos = 17;
			public int pcorpsepos = 18;
			public int bradleypos = 20;
			public int helipos = 21;
			public int scarecrowpos = 23;
			public int turretpos = 24;
		}
		private class ChatUI
        {
			public bool enableui = true;
			public bool UseImageLibrary = false;
			public bool ShowKillMessages = true;
			public int KillMessageInterval = 1;
			public int KillMessageLimit = 5000;
			public bool enableuinotify = false;
			public bool disablechats = false;
			public int uinotifytype = 0;
		}
		private class WebRequest
        {
			public bool UseWebrequests = false;
			public string DataURL = "URL";
			public string SecretKey = "SecretKey";
		}
		private class KRSQL
        {
			public bool UseSQL = false;
			public int FileType = 0;
			public string SQLhost = "localhost";
			public int SQLport = 3306;
			public string SQLdatabase = "databasename";
			public string SQLusername = "username";
			public string SQLpassword = "password";
		}
		protected override void LoadDefaultConfig() => config = new Configuration();
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
				{
					throw new JsonException();
				}
				if (MaybeUpdateConfig(config))
				{
					PrintWarning("Configuration appears to be outdated; updating and saving");
					SaveConfig();
				}
			}
			catch
			{
				PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
				LoadDefaultConfig();
			}
		}
		protected override void SaveConfig()
		{
			PrintWarning($"Configuration changes saved to {Name}.json");
			Config.WriteObject(config, true);
		}
        #endregion

        #region UpdateChecker
        internal class SerializableConfiguration
		{
			public string ToJson() => JsonConvert.SerializeObject(this);

			public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
		}
		private static class JsonHelper
		{
			public static object Deserialize(string json) => ToObject(JToken.Parse(json));

			private static object ToObject(JToken token)
			{
				switch (token.Type)
				{
					case JTokenType.Object:
						return token.Children<JProperty>().ToDictionary(prop => prop.Name, prop => ToObject(prop.Value));
					case JTokenType.Array:
						return token.Select(ToObject).ToList();

					default:
						return ((JValue)token).Value;
				}
			}
		}
		private bool MaybeUpdateConfig(SerializableConfiguration config)
		{
			var currentWithDefaults = config.ToDictionary();
			var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
			return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
		}
		private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
		{
			bool changed = false;

			foreach (var key in currentWithDefaults.Keys)
			{
				object currentRawValue;
				if (currentRaw.TryGetValue(key, out currentRawValue))
				{
					var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
					var currentDictValue = currentRawValue as Dictionary<string, object>;

					if (defaultDictValue != null)
					{
						if (currentDictValue == null)
						{
							currentRaw[key] = currentWithDefaults[key];
							changed = true;
						}
						else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
							changed = true;
					}
				}
				else
				{
					currentRaw[key] = currentWithDefaults[key];
					changed = true;
				}
			}

			return changed;
		}
		#endregion

		#region Storage
		private void SaveData()
		{
			if (_playData != null)
			{
				_playData.KillRecords = _recordCache;
				_KillData.WriteObject(_playData);
			}
		}
		private void SaveTemp()
		{
			_EntityData = Interface.Oxide.DataFileSystem.GetFile(nameof(KillRecords) + "/KillRecordsEntityData");
			_dataCache.Clear();
			if (_tempData != null)
			{
				_tempData.EntityRecords = _dataCache;
				_EntityData.WriteObject(_tempData);
			}
		}
		private void LoadData()
		{
			try
			{
				_playData = _KillData.ReadObject<PlayData>();
				_recordCache = _playData.KillRecords;
			}
			catch
			{
				_playData = new PlayData();
			}

			try
			{
				_tempData = _EntityData.ReadObject<TempData>();
				_dataCache = _tempData.EntityRecords;
			}
			catch
			{
				_tempData = new TempData();
			}
		}
		private class TempData
		{
			public Dictionary<ulong, Data> EntityRecords = new Dictionary<ulong, Data>();
		}
		private class Data
		{
			public ulong entity;
			public List<string> id;
		}
		private class PlayData
		{
			public Dictionary<string, Record> KillRecords = new Dictionary<string, Record>();
		}
		private class Record
		{
			public int chicken;
			public int boar;
			public int stag;
			public int wolf;
			public int bear;
			public int polarbear;
			public int shark;
			public int horse;
			public int fish;
			public int scientistnpcnew;
			public int scarecrow;
			public int dweller;
			public int baseplayer;
			public int basecorpse;
			public int npcplayercorpse;
			public int zombie;
			public int deaths;
			public int suicides;
			public int lootcontainer;
			public int underwaterlootcontainer;
			public int bradhelicrate;
			public int hackablecrate;
			public int bradley;
			public int heli;
			public int turret;
			public string displayname;
			public string id;
			public bool killchat;
			public int treescut;
			public int oremined;
			public int cactuscut;
			public int woodpickup;
			public int orepickup;
			public int berriespickup;
			public int pumpkinpickup;
			public int potatopickup;
			public int cornpickup;
			public int mushroompickup;
			public int hemppickup;
			public int seedpickup;
		}
		private class HeliHits 
		{
			public Dictionary<ulong, Heli> HeliRecords = new Dictionary<ulong, Heli>();
        }
        private class Heli
        {
            public ulong heli;
            public ulong player;
        }

        #endregion

        #region SQL
        private string RemoveSpecialCharacters(string name)
        {
            string newname = Regex.Replace(name, @"[^0-9a-zA-Z]+", "");
            return newname;
        }

        private readonly Core.MySql.Libraries.MySql sqlLibrary = Interface.Oxide.GetLibrary<Core.MySql.Libraries.MySql>();
		Connection sqlConnection;
		//SQL Table
		private void CreatSQLTable()
		{
			sqlLibrary.Insert(Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS KillRecords (" +
				$" `id` BIGINT(255) NOT NULL AUTO_INCREMENT," +
				$" `steamid` BIGINT(255) NOT NULL," +
				$" `displayname` VARCHAR(255) NOT NULL," +
				$" `chicken` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `boar` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `stag` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `wolf` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `bear` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `polarbear` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `shark` BIGINT(255) NOT NULL DEFAULT '0'," +
                $" `horse` BIGINT(255) NOT NULL DEFAULT '0'," +
                $" `fish` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `scientistnpcnew` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `scarecrow` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `dweller` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `baseplayer` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `basecorpse` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `npcplayercorpse` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `zombie` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `deaths` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `suicides` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `lootcontainer` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `bradhelicrate` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `hackablecrate` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `bradley` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `heli` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `turret` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `underwaterlootcontainer` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `killchat` VARCHAR(255) NOT NULL DEFAULT 'True'," +
				$" `treescut` BIGINT(255) NOT NULL DEFAULT '0'," +
				$" `oremined` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `cactuscut` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `woodpickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `orepickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `berriespickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `pumpkinpickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `potatopickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `cornpickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `mushroompickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `hemppickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$" `seedpickup` VARCHAR(255) NOT NULL DEFAULT '0'," +
				$"PRIMARY KEY (id)" +
				$" );"), sqlConnection);
		}
		private void UpdateSQLTable()
		{
			try
			{
				bool treescut = false;
				bool oremined = false;
				bool cactuscut = false;
				bool woodpickup = false;
				bool orepickup = false;
				bool berriespickup = false;
				bool pumpkinpickup = false;
				bool potatopickup = false;
				bool cornpickup = false;
				bool mushroompickup = false;
				bool hemppickup = false;
				bool seedpickup = false;
				bool polarbear = false;
				bool bradley = false;
				bool heli = false;
				bool scarecrow = false;
				bool turret = false;
				bool zombie = false;
				sqlLibrary.Query(Sql.Builder.Append($"SELECT * FROM KillRecords"), sqlConnection, list =>
				{
					foreach (var entry in list)
					{
						if (!entry.ContainsKey("zombie"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `treescut` BIGINT(255) NOT NULL DEFAULT '0' AFTER killchat"), sqlConnection); 
							zombie = true;
						}					
						if (!entry.ContainsKey("treescut"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `treescut` BIGINT(255) NOT NULL DEFAULT '0' AFTER killchat"), sqlConnection); 
							treescut = true;
						}					
						if (!entry.ContainsKey("oremined"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `oremined` BIGINT(255) NOT NULL DEFAULT '0' AFTER treescut"), sqlConnection);
							oremined = true;
						}
						if (!entry.ContainsKey("cactuscut"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `cactuscut` BIGINT(255) NOT NULL DEFAULT '0' AFTER oremined"), sqlConnection);
							cactuscut = true;
						}
						if (!entry.ContainsKey("woodpickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `woodpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER cactuscut"), sqlConnection);
							woodpickup = true;
						}
						if (!entry.ContainsKey("orepickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `orepickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER woodpickup"), sqlConnection);
							orepickup = true;
						}
						if (!entry.ContainsKey("berriespickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `berriespickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER orepickup"), sqlConnection);
							berriespickup = true;
						}
						if (!entry.ContainsKey("pumpkinpickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `pumpkinpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER berriespickup"), sqlConnection);
							pumpkinpickup = true;
						}
						if (!entry.ContainsKey("potatopickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `potatopickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER pumpkinpickup"), sqlConnection);
							potatopickup = true;
						}
						if (!entry.ContainsKey("cornpickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `cornpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER potatopickup"), sqlConnection);
							cornpickup = true;
						}
						if (!entry.ContainsKey("mushroompickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `mushroompickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER cornpickup"), sqlConnection);
							mushroompickup = true;
						}
						if (!entry.ContainsKey("hemppickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `hemppickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER mushroompickup"), sqlConnection);
							hemppickup = true;
						}
						if (!entry.ContainsKey("seedpickup"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `seedpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER hemppickup"), sqlConnection);
							seedpickup = true;
						}
						if (!entry.ContainsKey("polarbear"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `polarbear` BIGINT(255) NOT NULL DEFAULT '0' AFTER bear"), sqlConnection);
							polarbear = true;
						}
						if (!entry.ContainsKey("bradley"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `bradley` BIGINT(255) NOT NULL DEFAULT '0' AFTER hackablecrate"), sqlConnection);
							bradley = true;
						}
						if (!entry.ContainsKey("heli"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `heli` BIGINT(255) NOT NULL DEFAULT '0' AFTER bradley"), sqlConnection);
							heli = true;
						}
						if (!entry.ContainsKey("scarecrow"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `scarecrow` BIGINT(255) NOT NULL DEFAULT '0' AFTER scientistnpcnew"), sqlConnection);
							scarecrow = true;
						}
						if (!entry.ContainsKey("turret"))
						{
							//sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `turret` BIGINT(255) NOT NULL DEFAULT '0' AFTER heli"), sqlConnection);
							turret = true;
						}
					}
					if (zombie)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `zombie` BIGINT(255) NOT NULL DEFAULT '0' AFTER npcplayercorpse"), sqlConnection);
					}
					if (treescut)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `treescut` BIGINT(255) NOT NULL DEFAULT '0' AFTER killchat"), sqlConnection);
					}
					if (oremined)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `oremined` BIGINT(255) NOT NULL DEFAULT '0' AFTER treescut"), sqlConnection);
					}
					if (cactuscut)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `cactuscut` BIGINT(255) NOT NULL DEFAULT '0' AFTER oremined"), sqlConnection);
					}
					if (woodpickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `woodpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER cactuscut"), sqlConnection);
					}
					if (orepickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `orepickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER woodpickup"), sqlConnection);
					}
					if (berriespickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `berriespickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER orepickup"), sqlConnection);
					}
					if (pumpkinpickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `pumpkinpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER berriespickup"), sqlConnection);
					}
					if (potatopickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `potatopickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER pumpkinpickup"), sqlConnection);
					}
					if (cornpickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `cornpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER potatopickup"), sqlConnection);
					}
					if (mushroompickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `mushroompickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER cornpickup"), sqlConnection);
					}
					if (hemppickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `hemppickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER mushroompickup"), sqlConnection);
					}
					if (seedpickup)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `seedpickup` BIGINT(255) NOT NULL DEFAULT '0' AFTER hemppickup"), sqlConnection);
					}
					if (polarbear)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `polarbear` BIGINT(255) NOT NULL DEFAULT '0' AFTER bear"), sqlConnection);
					}
					if (bradley)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `bradley` BIGINT(255) NOT NULL DEFAULT '0' AFTER hackablecrate"), sqlConnection);
					}
					if (heli)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `heli` BIGINT(255) NOT NULL DEFAULT '0' AFTER bradley"), sqlConnection);
					}
					if (scarecrow)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `scarecrow` BIGINT(255) NOT NULL DEFAULT '0' AFTER scientistnpcnew"), sqlConnection);
					}
					if (turret)
                    {
						sqlLibrary.Insert(Sql.Builder.Append($"ALTER TABLE KillRecords ADD COLUMN `turret` BIGINT(255) NOT NULL DEFAULT '0' AFTER heli"), sqlConnection);
					}
				});
			}
			catch (MySqlException e)
			{
				PrintError("Failed to Update Table (" + e.Message + ")");
			}
		}
		//SQL Player Create/Update
		private void CreatePlayerDataSQL(BasePlayer player)
		{
			if (player == null || !player.userID.Get().IsSteamId()) return;
			Record record = GetRecord(player);
			sqlLibrary.Insert(Sql.Builder.Append($"INSERT KillRecords (steamid, displayname, chicken, boar, stag, wolf, bear, polarbear, shark, horse, fish, scientistnpcnew, scarecrow, dweller, baseplayer, basecorpse, npcplayercorpse, zombie, deaths, suicides, lootcontainer, bradhelicrate, hackablecrate, bradley, heli, turret, underwaterlootcontainer, killchat, treescut, oremined, cactuscut, woodpickup, orepickup, berriespickup, pumpkinpickup, potatopickup, cornpickup, mushroompickup, hemppickup, seedpickup) " +
			$"VALUES ('" +
			$"{record.id}', " +
			$"'{RemoveSpecialCharacters(record.displayname)}', " +
			$"'{record.chicken}', " +
			$"'{record.boar}', " +
			$"'{record.stag}', " +
			$"'{record.wolf}', " +
			$"'{record.bear}', " +
			$"'{record.polarbear}', " +
			$"'{record.shark}', " +
            $"'{record.horse}', " +
            $"'{record.fish}', " +
			$"'{record.scientistnpcnew}', " +
			$"'{record.scarecrow}', " +
			$"'{record.dweller}', " +
			$"'{record.baseplayer}', " +
			$"'{record.basecorpse}', " +
			$"'{record.npcplayercorpse}', " +
			$"'{record.zombie}', " +
			$"'{record.deaths}', " +
			$"'{record.suicides}', " +
			$"'{record.lootcontainer}', " +
			$"'{record.bradhelicrate}', " +
			$"'{record.hackablecrate}', " +
			$"'{record.bradley}', " +
			$"'{record.heli}', " +
			$"'{record.turret}', " +
			$"'{record.underwaterlootcontainer}', " +
			$"'{record.killchat}', " +
			$"'{record.treescut}', " +
			$"'{record.oremined}', " +
			$"'{record.cactuscut}', " +
			$"'{record.woodpickup}', " +
			$"'{record.orepickup}', " +
			$"'{record.berriespickup}', " +
			$"'{record.pumpkinpickup}', " +
			$"'{record.potatopickup}', " +
			$"'{record.cornpickup}', " +
			$"'{record.mushroompickup}', " +
			$"'{record.hemppickup}', " +
			$"'{record.seedpickup}'" +
			$");"), sqlConnection);
		}
		private void UpdatePlayersSQL()
		{
			bool newplayer = false;
			sqlLibrary.Query(Sql.Builder.Append($"SELECT steamid FROM KillRecords"), sqlConnection, list =>
			{
				if (list.IsEmpty())
				{
					newplayer = true;
				}
				if (newplayer)
				{
					foreach (var r in _recordCache)
					{
						if (!r.Key.IsSteamId()) continue;
						sqlLibrary.Insert(Sql.Builder.Append($"INSERT KillRecords (steamid, displayname, chicken, boar, stag, wolf, bear, polarbear, shark, horse, fish, scientistnpcnew, scarecrow, dweller, baseplayer, basecorpse, npcplayercorpse, zombie, deaths, suicides, lootcontainer, bradhelicrate, hackablecrate, bradley, heli, turret, underwaterlootcontainer, killchat, treescut, oremined, cactuscut, woodpickup, orepickup, berriespickup, pumpkinpickup, potatopickup, cornpickup, mushroompickup, hemppickup, seedpickup) " +
						$"VALUES ('" +
						$"{r.Value.id}', " +
						$"'{RemoveSpecialCharacters(r.Value.displayname)}', " +
						$"'{r.Value.chicken}', " +
						$"'{r.Value.boar}', " +
						$"'{r.Value.stag}', " +
						$"'{r.Value.wolf}', " +
						$"'{r.Value.bear}', " +
						$"'{r.Value.polarbear}', " +
						$"'{r.Value.shark}', " +
                        $"'{r.Value.horse}', " +
                        $"'{r.Value.fish}', " +
						$"'{r.Value.scientistnpcnew}', " +
						$"'{r.Value.scarecrow}', " +
						$"'{r.Value.dweller}', " +
						$"'{r.Value.baseplayer}', " +
						$"'{r.Value.basecorpse}', " +
						$"'{r.Value.npcplayercorpse}', " +
						$"'{r.Value.zombie}', " +
						$"'{r.Value.deaths}', " +
						$"'{r.Value.suicides}', " +
						$"'{r.Value.lootcontainer}', " +
						$"'{r.Value.bradhelicrate}', " +
						$"'{r.Value.hackablecrate}', " +
						$"'{r.Value.bradley}', " +
						$"'{r.Value.heli}', " +
						$"'{r.Value.turret}', " +
						$"'{r.Value.underwaterlootcontainer}', " +
						$"'{r.Value.killchat}', " +
						$"'{r.Value.treescut}', " +
						$"'{r.Value.oremined}', " +
						$"'{r.Value.cactuscut}', " +
						$"'{r.Value.woodpickup}', " +
						$"'{r.Value.orepickup}', " +
						$"'{r.Value.berriespickup}', " +
						$"'{r.Value.pumpkinpickup}', " +
						$"'{r.Value.potatopickup}', " +
						$"'{r.Value.cornpickup}', " +
						$"'{r.Value.mushroompickup}', " +
						$"'{r.Value.hemppickup}', " +
						$"'{r.Value.seedpickup}' " +
						$");"), sqlConnection);
					}
				}
			});

			sqlLibrary.Query(Sql.Builder.Append($"SELECT steamid FROM KillRecords"), sqlConnection, list =>
			{
				foreach (var entry in list)
				{
					foreach (var r in _recordCache)
					{
						if (!r.Key.IsSteamId()) continue;
						if (r.Key == entry["steamid"].ToString())
						{
							sqlLibrary.Update(Sql.Builder.Append($"UPDATE KillRecords SET " +
							$"steamid='{r.Value.id}', " +
							$"displayname='{RemoveSpecialCharacters(r.Value.displayname)}', " +
							$"chicken='{r.Value.chicken}', " +
							$"boar='{r.Value.boar}', " +
							$"stag='{r.Value.stag}', " +
							$"wolf='{r.Value.wolf}', " +
							$"bear='{r.Value.bear}', " +
							$"polarbear='{r.Value.polarbear}', " +
							$"shark='{r.Value.shark}', " +
							$"horse='{r.Value.horse}', " +
							$"fish='{r.Value.fish}', " +
							$"scientistnpcnew='{r.Value.scientistnpcnew}', " +
							$"scarecrow='{r.Value.scarecrow}', " +
							$"dweller='{r.Value.dweller}', " +
							$"baseplayer='{r.Value.baseplayer}', " +
							$"basecorpse='{r.Value.basecorpse}', " +
							$"npcplayercorpse='{r.Value.npcplayercorpse}', " +
							$"zombie='{r.Value.zombie}', " +
							$"deaths='{r.Value.deaths}', " +
							$"suicides='{r.Value.suicides}', " +
							$"lootcontainer='{r.Value.lootcontainer}', " +
							$"bradhelicrate='{r.Value.bradhelicrate}', " +
							$"hackablecrate='{r.Value.hackablecrate}', " +
							$"bradley='{r.Value.bradley}', " +
							$"heli='{r.Value.heli}', " +
							$"turret='{r.Value.turret}', " +
							$"underwaterlootcontainer='{r.Value.underwaterlootcontainer}', " +
							$"killchat='{r.Value.killchat}', " +
							$"treescut='{r.Value.treescut}', " +
							$"oremined='{r.Value.oremined}', " +
							$"cactuscut='{r.Value.cactuscut}', " +
							$"woodpickup='{r.Value.woodpickup}', " +
							$"orepickup='{r.Value.orepickup}', " +
							$"berriespickup='{r.Value.berriespickup}', " +
							$"pumpkinpickup='{r.Value.pumpkinpickup}', " +
							$"potatopickup='{r.Value.potatopickup}', " +
							$"cornpickup='{r.Value.cornpickup}', " +
							$"mushroompickup='{r.Value.mushroompickup}', " +
							$"hemppickup='{r.Value.hemppickup}', " +
							$"seedpickup='{r.Value.seedpickup}' " +
							$"WHERE steamid = '{r.Key}';"), sqlConnection);
						}
					}
				}
			});
		}
		private void UpdatePlayersDataSQL()
		{
			foreach (var r in _recordCache)
			{
                if (!r.Key.IsSteamId()) continue;
                sqlLibrary.Update(Sql.Builder.Append($"UPDATE KillRecords SET " +
					$"steamid='{r.Value.id}', " +
					$"displayname='{RemoveSpecialCharacters(r.Value.displayname)}', " +
					$"chicken='{r.Value.chicken}', " +
					$"boar='{r.Value.boar}', " +
					$"stag='{r.Value.stag}', " +
					$"wolf='{r.Value.wolf}', " +
					$"bear='{r.Value.bear}', " +
					$"polarbear='{r.Value.polarbear}', " +
					$"shark='{r.Value.shark}', " +
                    $"horse='{r.Value.horse}', " +
                    $"fish='{r.Value.fish}', " +
					$"scientistnpcnew='{r.Value.scientistnpcnew}', " +
					$"scarecrow='{r.Value.scarecrow}', " +
					$"dweller='{r.Value.dweller}', " +
					$"baseplayer='{r.Value.baseplayer}', " +
					$"basecorpse='{r.Value.basecorpse}', " +
					$"npcplayercorpse='{r.Value.npcplayercorpse}', " +
					$"zombie='{r.Value.zombie}', " +
					$"deaths='{r.Value.deaths}', " +
					$"suicides='{r.Value.suicides}', " +
					$"lootcontainer='{r.Value.lootcontainer}', " +
					$"bradhelicrate='{r.Value.bradhelicrate}', " +
					$"hackablecrate='{r.Value.hackablecrate}', " +
					$"bradley='{r.Value.bradley}', " +
					$"heli='{r.Value.heli}', " +
					$"turret='{r.Value.turret}', " +
					$"underwaterlootcontainer='{r.Value.underwaterlootcontainer}', " +
					$"killchat='{r.Value.killchat}', " +
					$"treescut='{r.Value.treescut}', " +
					$"oremined='{r.Value.oremined}', " +
					$"cactuscut='{r.Value.cactuscut}', " +
					$"woodpickup='{r.Value.woodpickup}', " +
					$"orepickup='{r.Value.orepickup}', " +
					$"berriespickup='{r.Value.berriespickup}', " +
					$"pumpkinpickup='{r.Value.pumpkinpickup}', " +
					$"potatopickup='{r.Value.potatopickup}', " +
					$"cornpickup='{r.Value.cornpickup}', " +
					$"mushroompickup='{r.Value.mushroompickup}', " +
					$"hemppickup='{r.Value.hemppickup}', " +
					$"seedpickup='{r.Value.seedpickup}' " +
					$"WHERE steamid = '{r.Key}';"), sqlConnection);
			}
		}		
		private void UpdatePlayerDataSQL(BasePlayer player)
		{
            if (player == null || !player.userID.Get().IsSteamId()) return;
            Record record = GetRecord(player);
			sqlLibrary.Update(Sql.Builder.Append($"UPDATE KillRecords SET " +
			$"steamid='{record.id}', " +
			$"displayname='{RemoveSpecialCharacters(player.displayName)}', " +
			$"chicken='{record.chicken}', " +
			$"boar='{record.boar}', " +
			$"stag='{record.stag}', " +
			$"wolf='{record.wolf}', " +
			$"bear='{record.bear}', " +
			$"polarbear='{record.polarbear}', " +
			$"shark='{record.shark}', " +
            $"horse='{record.horse}', " +
            $"fish='{record.fish}', " +
			$"scientistnpcnew='{record.scientistnpcnew}', " +
			$"scarecrow='{record.scarecrow}', " +
			$"dweller='{record.dweller}', " +
			$"baseplayer='{record.baseplayer}', " +
			$"basecorpse='{record.basecorpse}', " +
			$"npcplayercorpse='{record.npcplayercorpse}', " +
			$"zombie='{record.zombie}', " +
			$"deaths='{record.deaths}', " +
			$"suicides='{record.suicides}', " +
			$"lootcontainer='{record.lootcontainer}', " +
			$"bradhelicrate='{record.bradhelicrate}', " +
			$"hackablecrate='{record.hackablecrate}', " +
			$"bradley='{record.bradley}', " +
			$"heli='{record.heli}', " +
			$"turret='{record.turret}', " +
			$"underwaterlootcontainer='{record.underwaterlootcontainer}', " +
			$"killchat='{record.killchat}', " +
			$"treescut='{record.treescut}', " +
			$"oremined='{record.oremined}', " +
			$"cactuscut='{record.cactuscut}', " +
			$"woodpickup='{record.woodpickup}', " +
			$"orepickup='{record.orepickup}', " +
			$"berriespickup='{record.berriespickup}', " +
			$"pumpkinpickup='{record.pumpkinpickup}', " +
			$"potatopickup='{record.potatopickup}', " +
			$"cornpickup='{record.cornpickup}', " +
			$"mushroompickup='{record.mushroompickup}', " +
			$"hemppickup='{record.hemppickup}', " +
			$"seedpickup='{record.seedpickup}' " +
			$"WHERE steamid = '{player.UserIDString}';"), sqlConnection);
		}
		private void CheckPlayerDataSQL(BasePlayer player)
		{
            if (player == null || !player.userID.Get().IsSteamId()) return;
            bool newplayer = true;
			sqlLibrary.Query(Sql.Builder.Append($"SELECT steamid FROM KillRecords"), sqlConnection, list =>
			{
				foreach (var entry in list)
				{
					if (entry["steamid"].ToString() == player.UserIDString)
					{
						UpdatePlayerDataSQL(player);
						newplayer = false;
					}
				}
				if (newplayer)
				{
					CreatePlayerDataSQL(player);
				}
			});

		}
		//SQL Load Data
		private void LoadSQL()
		{
			sqlLibrary.Query(Sql.Builder.Append($"SELECT * FROM KillRecords"), sqlConnection, list =>
			{
				foreach (var tsqlplayer in list)
				{
					Record record;
					if (!_recordCache.TryGetValue(tsqlplayer["steamid"].ToString(), out record))
					{
						_recordCache[tsqlplayer["steamid"].ToString()] = record = new Record
						{
                            chicken = Convert.ToInt32(tsqlplayer["chicken"]),
							boar = Convert.ToInt32(tsqlplayer["boar"]),
							stag = Convert.ToInt32(tsqlplayer["stag"]),
							wolf = Convert.ToInt32(tsqlplayer["wolf"]),
							bear = Convert.ToInt32(tsqlplayer["bear"]),
							shark = Convert.ToInt32(tsqlplayer["shark"]),
							horse = Convert.ToInt32(tsqlplayer["horse"]),
							fish = Convert.ToInt32(tsqlplayer["fish"]),
							scientistnpcnew = Convert.ToInt32(tsqlplayer["scientistnpcnew"]),
							dweller = Convert.ToInt32(tsqlplayer["dweller"]),
							baseplayer = Convert.ToInt32(tsqlplayer["baseplayer"]),
							basecorpse = Convert.ToInt32(tsqlplayer["basecorpse"]),
							npcplayercorpse = Convert.ToInt32(tsqlplayer["npcplayercorpse"]),
							zombie = Convert.ToInt32(tsqlplayer["zombie"]),
							deaths = Convert.ToInt32(tsqlplayer["deaths"]),
							suicides = Convert.ToInt32(tsqlplayer["suicides"]),
							lootcontainer = Convert.ToInt32(tsqlplayer["lootcontainer"]),
							bradhelicrate = Convert.ToInt32(tsqlplayer["bradhelicrate"]),
							hackablecrate = Convert.ToInt32(tsqlplayer["hackablecrate"]),
							bradley = Convert.ToInt32(tsqlplayer["bradley"]),
							heli = Convert.ToInt32(tsqlplayer["heli"]),
							underwaterlootcontainer = Convert.ToInt32(tsqlplayer["underwaterlootcontainer"]),
							killchat = Convert.ToBoolean(tsqlplayer["killchat"]),
							treescut = Convert.ToInt32(tsqlplayer["treescut"]),
							oremined = Convert.ToInt32(tsqlplayer["oremined"]),
							cactuscut = Convert.ToInt32(tsqlplayer["cactuscut"]),
							woodpickup = Convert.ToInt32(tsqlplayer["woodpickup"]),
							orepickup = Convert.ToInt32(tsqlplayer["orepickup"]),
							berriespickup = Convert.ToInt32(tsqlplayer["berriespickup"]),
							pumpkinpickup = Convert.ToInt32(tsqlplayer["pumpkinpickup"]),
							potatopickup = Convert.ToInt32(tsqlplayer["potatopickup"]),
							cornpickup = Convert.ToInt32(tsqlplayer["cornpickup"]),
							mushroompickup = Convert.ToInt32(tsqlplayer["mushroompickup"]),
							hemppickup = Convert.ToInt32(tsqlplayer["hemppickup"]),
							seedpickup = Convert.ToInt32(tsqlplayer["seedpickup"])
						};
						record.id = tsqlplayer["steamid"].ToString();
						record.displayname = tsqlplayer["displayname"].ToString();
					}
				}
			});
		}
		//SQL Delete Data
		private void DeleteSQL()
		{
			sqlLibrary.Delete(Sql.Builder.Append($"DELETE FROM KillRecords;"), sqlConnection);
		}
		#endregion

		#region Load/Save
		private void Init()
		{
			_recordCache = new Dictionary<string, Record>();
			_dataCache = new Dictionary<ulong, Data>();
			_heliCache = new Dictionary<ulong, Heli>();
		}
		private void OnServerInitialized()
		{
			cmd.AddChatCommand(config.playerChatCommands.krhelp, this, KRHelp);
			cmd.AddChatCommand(config.playerChatCommands.pkills, this, PKills);
			cmd.AddChatCommand(config.playerChatCommands.pkillschat, this, PKillsChat);
			cmd.AddChatCommand(config.playerChatCommands.topkills, this, TopKills);
			cmd.AddChatCommand(config.playerChatCommands.topkillschat, this, TopKillsChat);
			cmd.AddChatCommand(config.playerChatCommands.totalkills, this, TotalKills);
			cmd.AddChatCommand(config.playerChatCommands.totalkillschat, this, TotalKillsChat);
			cmd.AddChatCommand(config.playerChatCommands.leadkills, this, LeadKills);
			cmd.AddChatCommand(config.playerChatCommands.pstats, this, PStats);
			cmd.AddChatCommand(config.playerChatCommands.pstatschat, this, PStatsChat);
			cmd.AddChatCommand(config.playerChatCommands.topstats, this, TopStats);
			cmd.AddChatCommand(config.playerChatCommands.totalstats, this, TotalStats);
			cmd.AddChatCommand(config.playerChatCommands.totalstatschat, this, TotalStatsChat);
			cmd.AddChatCommand(config.playerChatCommands.killchat, this, KillChat);
			cmd.AddChatCommand(config.adminChatCommands.krhelpadmin, this, AdminKRHelp);
			cmd.AddChatCommand(config.adminChatCommands.krweb, this, AdminKRWeb);
			cmd.AddChatCommand(config.adminChatCommands.krsql, this, AdminKRsql);
			cmd.AddChatCommand(config.adminChatCommands.krbackup, this, AdminKRBackup);
			cmd.AddChatCommand(config.adminChatCommands.krreset, this, AdminKRReset);

			if (config.krsql.FileType == 1 && config.krsql.UseSQL == false)
			{
				PrintError("Config Options Not Properly Set! Data Type cannot = 1 While Use SQL Database = false");
				Interface.Oxide.UnloadPlugin("KillRecords");
			}			
			if (!config.trackingoptions.Trackdeaths)
			{
				Unsubscribe(nameof(OnPlayerDeath));
			}
			permission.RegisterPermission(Admin, this);
			permission.RegisterPermission(Killchat, this);
			if (config.krsql.FileType == 0)
			{
				_KillData = Interface.Oxide.DataFileSystem.GetFile(nameof(KillRecords) + "/KillRecords");
				foreach (var krrecord in _KillData)
				{
					if (!krrecord.Key.IsSteamId())
					{
						_KillData.Remove(krrecord.Key);
					}
				}
				LoadData();
				SaveData();
			}
			if (config.krsql.FileType == 0 && config.krsql.UseSQL)
			{
				sqlConnection = sqlLibrary.OpenDb(config.krsql.SQLhost, config.krsql.SQLport, config.krsql.SQLdatabase, config.krsql.SQLusername, config.krsql.SQLpassword, this);
				CreatSQLTable();
				UpdateSQLTable();
			}
			if (config.krsql.FileType == 1)
			{
				sqlConnection = sqlLibrary.OpenDb(config.krsql.SQLhost, config.krsql.SQLport, config.krsql.SQLdatabase, config.krsql.SQLusername, config.krsql.SQLpassword, this);
				CreatSQLTable();
				UpdateSQLTable();
				LoadData();
				LoadSQL();
				if (_recordCache != null)
				{
					_playData.KillRecords = _recordCache;
					_recordCache = _playData.KillRecords;
				}
			}
			SaveTemp();
			if (config.krsql.FileType == 0 && config.krsql.UseSQL)
			{
				UpdatePlayersSQL();
			}
			foreach (var player in BasePlayer.activePlayerList)
			{
				GetRecord(player);
			}
		}
		private void Unload()
		{
			if (config.krsql.FileType == 0)
			{
				SaveData();
			}
			foreach (var player in BasePlayer.activePlayerList)
			{
				DestroyUi(player, KRUIName);
			}
			if (config.krsql.FileType == 0 && config.krsql.UseSQL)
			{
				UpdatePlayersDataSQL();
				sqlLibrary.CloseDb(sqlConnection);
			}
			if (config.krsql.FileType == 1)
			{
				UpdatePlayersDataSQL();
				sqlLibrary.CloseDb(sqlConnection);
				_KillData = Interface.Oxide.DataFileSystem.GetFile(nameof(KillRecords) + "/KillRecords");
				SaveData();
			}
		}
		private void OnServerShutDown()
		{
			if (config.krsql.FileType == 0)
			{
				SaveData();
			}
			if (config.krsql.FileType == 0 && config.krsql.UseSQL)
			{
				UpdatePlayersDataSQL();
				sqlLibrary.CloseDb(sqlConnection);
			}
			if (config.krsql.FileType == 1)
			{
				UpdatePlayersDataSQL();
				sqlLibrary.CloseDb(sqlConnection);
				_KillData = Interface.Oxide.DataFileSystem.GetFile(nameof(KillRecords) + "/KillRecords");
				SaveData();
			}
		}
		private void OnServerSave()
		{
			if (config.krsql.FileType == 0)
			{
				SaveData();
			}

			if (config.krsql.UseSQL)
			{
				foreach (var player in BasePlayer.activePlayerList)
				{
					CheckPlayerDataSQL(player);
				}
				UpdatePlayersDataSQL();
			}
		}
		private void OnPlayerConnected(BasePlayer player)
		{
			GetRecord(player);
			if (config.krsql.UseSQL || config.krsql.FileType == 1)
			{
				CheckPlayerDataSQL(player);
			}
		}
		private void OnPlayerDisconnected(BasePlayer player)
		{
			DestroyUi(player, KRUIName);
			if (config.krsql.UseSQL || config.krsql.FileType == 1) { CheckPlayerDataSQL(player); }
			if (config.webrequest.UseWebrequests) { SaveKillRecordWeb(player); }
		}
		#endregion

		#region PlayerData
		private void AddData(BasePlayer player, BaseEntity entity)
		{
			Data data;
			if (!_dataCache.TryGetValue(entity.net.ID.Value, out data))
			{
				_dataCache.Add(entity.net.ID.Value, data = new Data
				{
					id = new List<string>(),
				});
			}

			if (!data.id.Contains(player.UserIDString))
			{
				data.id.Add(player.UserIDString);
			}
		}
		private void UpdateData(BasePlayer player)
		{
			GetRecord(player);
			if (config.krsql.FileType == 0) { SaveData(); }
			if (config.krsql.FileType == 1) { UpdatePlayersDataSQL(); }
		}
		private Record GetRecord(BasePlayer player)
		{
			if (player == null || !player.userID.Get().IsSteamId()) return null;
			Record record;
			if (_recordCache.TryGetValue(player.UserIDString, out record))
			{
				return record;
			}

			if (!_recordCache.TryGetValue(player.UserIDString, out record))
			{
				_recordCache[player.UserIDString] = record = new Record
				{
					chicken = 0,
					boar = 0,
					stag = 0,
					wolf = 0,
					bear = 0,
					polarbear = 0,
					shark = 0,
					horse = 0,
					fish = 0,
					scientistnpcnew = 0,
					scarecrow = 0,
					dweller = 0,
					baseplayer = 0,
					basecorpse = 0,
					npcplayercorpse = 0,
					zombie = 0,
					deaths = 0,
					suicides = 0,
					lootcontainer = 0,
					bradhelicrate = 0,
					hackablecrate = 0,
					bradley = 0,
					heli = 0,
					turret = 0,
					underwaterlootcontainer = 0,
					killchat = true,
					treescut = 0,
					oremined = 0,
					cactuscut = 0,
					woodpickup = 0,
					orepickup = 0,
					berriespickup = 0,
					pumpkinpickup = 0,
					potatopickup = 0,
					cornpickup = 0,
					mushroompickup = 0,
					hemppickup = 0,
					seedpickup = 0
				};
				record.id = player.UserIDString;
				record.displayname = player.displayName;
			}

			if (config.krsql.FileType == 0)
            {
				return record;
			}
			
			if (config.krsql.FileType == 1)
			{
				sqlLibrary.Query(Sql.Builder.Append($"SELECT * FROM KillRecords"), sqlConnection, list =>
				{
					foreach (var sqlplayer in list)
					{
						if (player.UserIDString == sqlplayer["steamid"].ToString())
						{
							_recordCache[player.UserIDString] = record = new Record
							{
								chicken = Convert.ToInt32(sqlplayer["chicken"]),
								boar = Convert.ToInt32(sqlplayer["boar"]),
								stag = Convert.ToInt32(sqlplayer["stag"]),
								wolf = Convert.ToInt32(sqlplayer["wolf"]),
								bear = Convert.ToInt32(sqlplayer["bear"]),
								polarbear = Convert.ToInt32(sqlplayer["polarbear"]),
								shark = Convert.ToInt32(sqlplayer["shark"]),
								horse = Convert.ToInt32(sqlplayer["horse"]),
								fish = Convert.ToInt32(sqlplayer["fish"]),
								scientistnpcnew = Convert.ToInt32(sqlplayer["scientistnpcnew"]),
								scarecrow = Convert.ToInt32(sqlplayer["scarecrow"]),
								dweller = Convert.ToInt32(sqlplayer["dweller"]),
								baseplayer = Convert.ToInt32(sqlplayer["baseplayer"]),
								basecorpse = Convert.ToInt32(sqlplayer["basecorpse"]),
								npcplayercorpse = Convert.ToInt32(sqlplayer["npcplayercorpse"]),
								zombie = Convert.ToInt32(sqlplayer["zombie"]),
								deaths = Convert.ToInt32(sqlplayer["deaths"]),
								suicides = Convert.ToInt32(sqlplayer["suicides"]),
								lootcontainer = Convert.ToInt32(sqlplayer["lootcontainer"]),
								bradhelicrate = Convert.ToInt32(sqlplayer["bradhelicrate"]),
								hackablecrate = Convert.ToInt32(sqlplayer["hackablecrate"]),
								bradley = Convert.ToInt32(sqlplayer["bradley"]),
								heli = Convert.ToInt32(sqlplayer["heli"]),
								turret = Convert.ToInt32(sqlplayer["turret"]),
								underwaterlootcontainer = Convert.ToInt32(sqlplayer["underwaterlootcontainer"]),
								killchat = Convert.ToBoolean(sqlplayer["killchat"]),
								treescut = Convert.ToInt32(sqlplayer["treescut"]),
								oremined = Convert.ToInt32(sqlplayer["oremined"]),
								cactuscut = Convert.ToInt32(sqlplayer["cactuscut"]),
								woodpickup = Convert.ToInt32(sqlplayer["woodpickup"]),
								orepickup = Convert.ToInt32(sqlplayer["orepickup"]),
								berriespickup = Convert.ToInt32(sqlplayer["berriespickup"]),
								pumpkinpickup = Convert.ToInt32(sqlplayer["pumpkinpickup"]),
								potatopickup = Convert.ToInt32(sqlplayer["potatopickup"]),
								cornpickup = Convert.ToInt32(sqlplayer["cornpickup"]),
								mushroompickup = Convert.ToInt32(sqlplayer["mushroompickup"]),
								hemppickup = Convert.ToInt32(sqlplayer["hemppickup"]),
								seedpickup = Convert.ToInt32(sqlplayer["seedpickup"])
							};
							record.id = player.UserIDString;
							record.displayname = player.displayName;
						}
					}
				});
			}
			return record;
		}
		private static BasePlayer FindPlayer(string playerid)
		{
			foreach (var activePlayer in BasePlayer.activePlayerList)
			{
				if (activePlayer.UserIDString == playerid)
					return activePlayer;
			}
			foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
			{
				if (sleepingPlayer.UserIDString == playerid)
					return sleepingPlayer;
			}
			return null;
		}
        #endregion

        #region Hooks
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
		{
            // Check for null or npcs
            if (entity == null || hitInfo == null || hitInfo.Initiator == null) return;
            // Turret Kills
            if (hitInfo.Initiator is AutoTurret && config.trackingoptions.Trackturret)
			{
				var turret = hitInfo.Initiator as AutoTurret;
				var turretowner = FindPlayer(turret.OwnerID.ToString());
				if (!turret.OwnerID.IsSteamId() || turretowner == null) return;
				Record records = GetRecord(turretowner);
				KRKillMessages(turretowner, "turret", ++records.turret, records.killchat);
				return;
			}
			// Count Player Suicide Separately If Enabled
			if (config.trackingoptions.Tracksuicides && entity == hitInfo.Initiator)
			{
				var suicider = entity as BasePlayer;
				if (suicider == null || suicider.IsNpc || !suicider.userID.Get().IsSteamId()) return;
				var r = GetRecord(suicider);
				KRKillMessages(suicider, "suicide", ++r.suicides, r.killchat);
				return;
			}
			// Ignore Player Suicide If Disabled and Count as Death
			if (entity == hitInfo.Initiator) return;
			// Get Killer Info
			var attacker = hitInfo.Initiator as BasePlayer;
            if (attacker == null || !attacker.userID.Get().IsSteamId()) return;
            string KillType = entity.ShortPrefabName.ToLower();
			if (KillType.Contains("corpse"))
			{
				if (KillType.Contains("scientist") || KillType.Contains("player"))
				{
					KillType = "basecorpse";
				}
				else
				{
					KillType = "corpse";
				}
            }
            if (KillType.Contains("horse"))
            {
                KillType = "horse";
            }
            if (KillType.Contains("dweller"))
            {
                KillType = "dweller";
            }
            if (KillType.Contains("loot") || KillType.Contains("barrel"))
            {
                KillType = "lootcontainer";
            }
            Record record = GetRecord(attacker);
			// Update DataCache On Kill
			switch (KillType)
			{
				case "chicken":
					if (config.trackingoptions.Trackchicken)
					KRKillMessages(attacker, KillType, ++record.chicken, record.killchat);					
					break;
				case "boar":
					if (config.trackingoptions.Trackboar)
					KRKillMessages(attacker, KillType, ++record.boar, record.killchat);
					break;
				case "stag":
					if (config.trackingoptions.Trackstag)
					KRKillMessages(attacker, KillType, ++record.stag, record.killchat);
					break;
				case "wolf":
				case "wolf2":
					if (config.trackingoptions.Trackwolf)
					KRKillMessages(attacker, KillType, ++record.wolf, record.killchat);
					break;
				case "bear":
					if (config.trackingoptions.Trackbear)
					KRKillMessages(attacker, KillType, ++record.bear, record.killchat);
					break;
				case "polarbear":
					if (config.trackingoptions.Trackpolarbear)
					KRKillMessages(attacker, KillType, ++record.polarbear, record.killchat);
					break;
				case "simpleshark":
					if (config.trackingoptions.Trackshark)
					KRKillMessages(attacker, KillType, ++record.shark, record.killchat);
					break;
				case "horse":
					if (config.trackingoptions.Trackhorse)
					KRKillMessages(attacker, "horse", ++record.horse, record.killchat);
					break;
				case "scientist":
					if (config.trackingoptions.Trackscientist)
					KRKillMessages(attacker, "scientists", ++record.scientistnpcnew, record.killchat);
					break;
				case "dweller":
					if (config.trackingoptions.Trackdweller)
					KRKillMessages(attacker, "dweller", ++record.dweller, record.killchat);
					break;
				case "baseplayer":
				case "player":
					if (config.trackingoptions.TrackPlayer)
					KRKillMessages(attacker, "players", ++record.baseplayer, record.killchat);
					break;
				case "lootcontainer":
					if (config.trackingoptions.Tracklootcontainer)
					KRKillMessages(attacker, "loot", ++record.lootcontainer, record.killchat);
					break;
				case "corpse":
					if (config.trackingoptions.TrackAnimalHarvest)
					KRKillMessages(attacker, "corpse", ++record.basecorpse, record.killchat);
					break;
				case "npcplayercorpse":
				case "basecorpse":
					if (config.trackingoptions.TrackCorpseHarvest)
					KRKillMessages(attacker, "pcorpse", ++record.npcplayercorpse, record.killchat);
					break;
				case "bradleyapc":
					if (config.trackingoptions.TrackBradley)
					KRKillMessages(attacker, KillType, ++record.bradley, record.killchat);
					break;
				case "patrolhelicopter":
					if (config.trackingoptions.TrackHeli)
					KRKillMessages(attacker, KillType, ++record.heli, record.killchat);
					break;
				case "scarecrownpc":
				case "scarecrow":
					if (config.trackingoptions.Trackscarecrow)
					KRKillMessages(attacker, "scarecrow", ++record.scarecrow, record.killchat);
					break;
                case "zombienpc":
                case "zombie":
					if(config.trackingoptions.Trackzombie)
                    KRKillMessages(attacker, "zombie", ++record.zombie, record.killchat);
					break;
            }
        }
		private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
		{
			if (config.trackingoptions.Trackdeaths)
			{
				// Check for null or NPC
				if (player == null || player.IsNpc || !player.userID.Get().IsSteamId()) return;
				// If Suicide Tracking Enabled Ingnore Death 
				if (config.trackingoptions.Tracksuicides && player == hitInfo?.Initiator) return;
				// Check For Non Attack Death Types
				Record record = GetRecord(player);
				if (record == null) return;
				if (player.lastDamage == DamageType.Thirst || player.lastDamage == DamageType.Hunger || player.lastDamage == DamageType.Cold || player.lastDamage == DamageType.Heat || player.lastDamage == DamageType.Fall)
				{
					KRKillMessages(player, "deaths", ++record.deaths, record.killchat);
					return;
				}
				// If Attack Type Not Detected Remove Error
				if (hitInfo == null) return;
				// Update Player Data On Other deaths
				KRKillMessages(player, "deaths", ++record.deaths, record.killchat);
			}
		}
		private void OnLootEntity(BasePlayer player, BaseEntity entity)
		{
			if (player == null || !player.userID.Get().IsSteamId() || !entity.IsValid()) return;
			var loot = entity.GetType().Name.ToLower();
			if (loot == null) return;
			if (_dataCache.ContainsKey(entity.net.ID.Value) && _dataCache[entity.net.ID.Value].id.Contains(player.UserIDString))
			{
				return;
			}
			AddData(player, entity);
			Record record = GetRecord(player);
			switch (loot)
            {
				case "freeablelootcontainer":
					if (config.trackingoptions.Trackunderwaterlootcontainer)
					KRKillMessages(player, "unloot", ++record.underwaterlootcontainer, record.killchat);
					break;
				case "lootcontainer":
					if (config.trackingoptions.Tracklootcontainer)
					KRKillMessages(player, "loot", ++record.lootcontainer, record.killchat);
					break;
				case "lockedbyentcrate":
					if (config.trackingoptions.Trackbradhelicrate)
					KRKillMessages(player, "bradheliloot", ++record.bradhelicrate, record.killchat);
					break;
				case "hackablelockedcrate":
					if (config.trackingoptions.Trackhackablecrate)
					KRKillMessages(player, "hackloot", ++record.hackablecrate, record.killchat);
					break;
			}
		}
		private void OnFishCatch(Item fish, BasePlayer player)
		{
			if (player == null || !player.userID.Get().IsSteamId() || fish == null) return;
			Record record = GetRecord(player);
			if (config.trackingoptions.Trackfish)
			{
				var fishname = fish.info.shortname;
				if (fishname.Contains("anchovy") || fishname.Contains("catfish") || fishname.Contains("herring") || fishname.Contains("minnow") || fishname.Contains("roughy") || fishname.Contains("salmon") || fishname.Contains("sardine") || fishname.Contains("shark") || fishname.Contains("trout") || fishname.Contains("Perch"))
				{
					KRKillMessages(player, "fish", ++record.fish, record.killchat);
				}
			}
		}
		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
		{
			if (player == null || !player.userID.Get().IsSteamId() || dispenser == null || item == null) return;
			Record record = GetRecord(player);
			var gatherType = dispenser.gatherType;
			if (gatherType == ResourceDispenser.GatherType.Tree)
			{
				KRKillMessages(player, "treecut", ++record.treescut, record.killchat);
			}
			else if (gatherType == ResourceDispenser.GatherType.Ore)
			{
				KRKillMessages(player, "oremined", ++record.oremined, record.killchat);

			}
			else if (item.info.shortname == "cactusflesh")
			{
				KRKillMessages(player, "cactuscut", ++record.cactuscut, record.killchat);

			}
		}
		private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
		{
			if (player == null || !player.userID.Get().IsSteamId() || collectible == null) return;
			Record record = GetRecord(player);
			foreach (var itemAmount in collectible.itemList)
			{
				var name = itemAmount.itemDef.shortname;
				if (name.Contains("wood"))
				{
					KRKillMessages(player, "woodpickup", ++record.woodpickup, record.killchat);
				}
				else if (name.Contains("ore") || name.Contains("stone"))
				{
					KRKillMessages(player, "orepickup", ++record.orepickup, record.killchat);
				}
				else if (name.Contains("berry") && !name.Contains("seed"))
				{
					KRKillMessages(player, "berries", ++record.berriespickup, record.killchat);
				}
				else if (name.Contains("seed"))
				{
					KRKillMessages(player, "seeds", ++record.seedpickup, record.killchat);
				}
				else if (name == "mushroom")
				{
					KRKillMessages(player, "mushroom", ++record.mushroompickup, record.killchat);
				}
				else if (name == "cloth")
				{
					KRKillMessages(player, "hemp", ++record.hemppickup, record.killchat);
				}
				else if (name == "pumpkin")
				{
					KRKillMessages(player, "pumpkin", ++record.pumpkinpickup, record.killchat);
				}
				else if (name == "corn")
				{
					KRKillMessages(player, "corn", ++record.cornpickup, record.killchat);
				}
				else if (name == "potato")
				{
					KRKillMessages(player, "potato", ++record.potatopickup, record.killchat);
				}
			}
		}
		private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
		{
			if (player == null || !player.userID.Get().IsSteamId() || growable == null || item == null) return;
			Record record = GetRecord(player);
			var name = item.info.shortname;
			if (name.Contains("wood"))
			{
				KRKillMessages(player, "woodpickup", ++record.woodpickup, record.killchat);
			}
			else if (name.Contains("berry") && !name.Contains("seed"))
			{
				KRKillMessages(player, "berries", ++record.berriespickup, record.killchat);
			}
			else if (name.Contains("seed"))
			{
				KRKillMessages(player, "seeds", ++record.seedpickup, record.killchat);
			}
			else if (name == "mushroom")
			{
				KRKillMessages(player, "mushroom", ++record.mushroompickup, record.killchat);
			}
			else if (name == "cloth")
			{
				KRKillMessages(player, "hemp", ++record.hemppickup, record.killchat);
			}
			else if (name == "pumpkin")
			{
				KRKillMessages(player, "pumpkin", ++record.pumpkinpickup, record.killchat);
			}
			else if (name == "corn")
			{
				KRKillMessages(player, "corn", ++record.cornpickup, record.killchat);
			}
			else if (name == "potato")
			{
				KRKillMessages(player, "potato", ++record.potatopickup, record.killchat);
			}
		}
		private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;
            var patrolheli = entity as PatrolHelicopter;
			if (patrolheli is PatrolHelicopter)
			{
                Heli patrol;
                if (_heliCache.TryGetValue(patrolheli.net.ID.Value, out patrol))
                {
					var player = FindPlayer(patrol.player.ToString());
					if (player is BasePlayer && player.userID.Get().IsSteamId())
					{
                        Record record = GetRecord(player);
						if (config.trackingoptions.TrackHeli)
							KRKillMessages(player, "patrolhelicopter", ++record.heli, record.killchat);
					}
                }
                _helitracker?.Destroy();
                _heliCache.Remove(patrolheli.net.ID.Value);
            }
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo) 
		{
            if (entity == null || hitInfo == null || hitInfo.Initiator == null) return;
            PatrolHelicopter patrolheli = entity as PatrolHelicopter;
            if (patrolheli is PatrolHelicopter)
            {
                var attacker = hitInfo.Initiator as BasePlayer;
                if (attacker == null || !attacker.userID.Get().IsSteamId()) return;

                Heli patrol;
				if (_heliCache.TryGetValue(patrolheli.net.ID.Value, out patrol))
				{
					patrol.heli = patrolheli.net.ID.Value;
					patrol.player = attacker.userID.Get();
				}
				else
				{
                    _heliCache.Add(patrolheli.net.ID.Value, new Heli
                    {
                        heli = patrolheli.net.ID.Value,
                        player = attacker.userID.Get()
                    });
                    _helitracker?.Destroy();
					_helitracker = timer.Once(90f, () =>
					{
						_heliCache.Remove(patrolheli.net.ID.Value);
					});
                }
            }
        }
        #endregion

        #region Commands
        //Player Commands
        private void KRHelp(BasePlayer player, string command, string[] args)
		{
			player.ChatMessage(KRLang("KRHelp", player.UserIDString));
		}
		private void PKills(BasePlayer player, string command, string[] args)
		{
			string playerinfo;
			if (args.Length == 0)
			{
				playerinfo = player.UserIDString;
			}
			else
			{
				playerinfo = args[0].ToLower();
			}
			if (config.chatui.enableui)
			{
				KRUIplayers(player, playerinfo);
			}
			else
			{
				PlayerKillsChat(player, playerinfo);
			}
		}
		private void PKillsChat(BasePlayer player, string command, string[] args)
		{
			string playerinfo;
			if (args.Length == 0)
			{
				playerinfo = player.UserIDString;
			}
			else
			{
				playerinfo = args[0].ToLower();
			}
			PlayerKillsChat(player, playerinfo);
		}
		private void TopKills(BasePlayer player, string command, string[] args)
		{
			if (config.chatui.enableui)
			{
				if (args.Length == 0)
				{
					var KillType = KillTypesEnabled();
					KRUITop(player, KillType);
					return;
				}
				var cmdArg = args[0].ToLower();
				KRUITop(player, cmdArg);
			}
			else
			{
				if (args.Length == 0)
				{
					player.ChatMessage(KRLang("KRHelp", player.UserIDString));
					return;
				}
				var cmdArg = args[0].ToLower();
				TopKillsChat(player, cmdArg);
			}
		}
		private void TopKillsChat(BasePlayer player, string command, string[] args)
		{
			if (args.Length == 0)
			{
				player.ChatMessage(KRLang("KRHelp", player.UserIDString));
				return;
			}
			var cmdArg = args[0].ToLower();
			TopKillsChat(player, cmdArg);
		}
		private void TotalKills(BasePlayer player, string command, string[] args)
		{
			if (config.chatui.enableui)
			{
				KRUITotal(player);
			}
			else
			{
				TotalKillsChat(player);
			}
		}		
		private void TotalKillsChat(BasePlayer player, string command, string[] args)
		{
			TotalKillsChat(player);
		}
		private void LeadKills(BasePlayer player, string command, string[] args)
		{
			KRUITopAll(player);
		}
		private void PStats(BasePlayer player, string command, string[] args)
		{
			string playerinfo;
			if (args.Length == 0)
			{
				playerinfo = player.UserIDString;
			}
			else
			{
				playerinfo = args[0].ToLower();
			}
			if (config.chatui.enableui)
			{
				KRUIStatsplayers(player, playerinfo);
			}
			else
			{
				PlayerStatsChat(player, playerinfo);
			}
		}
		private void PStatsChat(BasePlayer player, string command, string[] args)
		{
			string playerinfo;
			if (args.Length == 0)
			{
				playerinfo = player.UserIDString;
			}
			else
			{
				playerinfo = args[0].ToLower();
			}
			PlayerStatsChat(player, playerinfo);
		}
		private void TopStats(BasePlayer player, string command, string[] args)
		{
			if (config.chatui.enableui)
			{
				if (args.Length == 0)
				{
					var KillType = KillTypesEnabled();
					KRUIStatsTop(player, KillType);
					return;
				}
				var cmdArg = args[0].ToLower();
				KRUIStatsTop(player, cmdArg);
			}
		}
		private void TotalStats(BasePlayer player, string command, string[] args)
		{
			if (config.chatui.enableui)
			{
				KRUIStatsTotal(player);
			}
			else
			{
				TotalStatsChat(player);
			}
		}	
		private void TotalStatsChat(BasePlayer player, string command, string[] args)
		{
			TotalStatsChat(player);
		}
		private void KillChat(BasePlayer player, string command, string[] args)
		{
			if (!permission.UserHasPermission(player.UserIDString, Killchat)) return;
			if (args.Length == 0)
			{
				player.ChatMessage(KRLang("killchat", player.UserIDString, _recordCache[player.UserIDString].killchat));
				return;
			}

			var cmdArg = args[0].ToLower();
			if (cmdArg == "true")
			{
				_recordCache[player.UserIDString].killchat = true;
				player.ChatMessage(KRLang("killchat", player.UserIDString, cmdArg));
				return;
			}

			if (cmdArg == "false")
			{
				_recordCache[player.UserIDString].killchat = false;
				player.ChatMessage(KRLang("killchat", player.UserIDString, cmdArg));
			}
		}
		//Admin Commands
		private void AdminKRHelp(BasePlayer player, string command, string[] args)
		{
			if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Admin)) return;
			player.ChatMessage(KRLang("KRHelpadmin", player.UserIDString));
		}
		private void AdminKRWeb(BasePlayer player, string command, string[] args)
		{
			if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Admin)) return;
			if (config.webrequest.UseWebrequests)
			{
				SaveKillRecordWeb(player);
				player.ChatMessage(KRLang("webrequestgood", player.UserIDString));
			}
			else
			{
				player.ChatMessage(KRLang("webrequestdisabled", player.UserIDString));
			}
		}
		private void AdminKRsql(BasePlayer player, string command, string[] args)
		{
			if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Admin)) return;
			if (!config.krsql.UseSQL) return;
			var cmdArg = args[0].ToLower();
			if (config.krsql.UseSQL && cmdArg == "update")
			{
				UpdatePlayerDataSQL(player);
				player.ChatMessage(KRLang("sqlupdate", player.UserIDString));
			}
			if (config.krsql.UseSQL && cmdArg == "check")
			{
				CheckPlayerDataSQL(player);
				player.ChatMessage(KRLang("sqlcheck", player.UserIDString));
			}
			if (config.krsql.UseSQL && cmdArg == "checkall")
			{
				UpdatePlayersSQL();
				UpdatePlayersDataSQL();
				player.ChatMessage(KRLang("sqlcheckall", player.UserIDString));
			}
		}
		private void AdminKRBackup(BasePlayer player, string command, string[] args)
		{
			if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Admin)) return;
			_KillData = Interface.Oxide.DataFileSystem.GetFile(nameof(KillRecords) + "/KillRecords");
			SaveData();
			player.ChatMessage(KRLang("datafilebackup", player.UserIDString));
		}
		private void AdminKRReset(BasePlayer player, string command, string[] args)
		{
			if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, Admin)) return;
			if (config.krsql.UseSQL)
			{
				DeleteSQL();
			}

			_recordCache.Clear();

			if (config.krsql.FileType == 0)
			{
				_KillData.Clear();
			}

			Interface.Oxide.ReloadPlugin("KillRecords");
			player.ChatMessage(KRLang("resetkills", player.UserIDString));
		}
		#endregion

		#region CommandHandlers & TopStats
		//UI Command Handler
		[ConsoleCommand("kr.topkills")]
		private void Cmdtopkills(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();			
			if (player == null) return;
			var killtype = arg.GetString(0);
			DestroyUi(player, KRUIName);
			KRUITop(player, killtype);
		}
		[ConsoleCommand("kr.topstats")]
		private void Cmdtopstats(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();			
			if (player == null) return;
			var killtype = arg.GetString(0);
			DestroyUi(player, KRUIName);
			KRUIStatsTop(player, killtype);
		}
		[ConsoleCommand("kr.topplayers")]
		private void Cmdtopplayers(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			var playername = arg.GetString(0);
			DestroyUi(player, KRUIName);
			KRUIplayers(player, playername.ToLower());
		}
		[ConsoleCommand("kr.topplayersstats")]
		private void Cmdtopplayersstats(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			var playername = arg.GetString(0);
			DestroyUi(player, KRUIName);
			KRUIStatsplayers(player, playername.ToLower());
		}
		[ConsoleCommand("kr.leaderboard")]
		private void Cmdleaderboard(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			DestroyUi(player, KRUIName);
			KRUITopAll(player);
		}
		[ConsoleCommand("kr.totalkills")]
		private void Cmdtotalkills(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			DestroyUi(player, KRUIName);
			KRUITotal(player);
		}
		// Hooks
		private IEnumerable<Record> GetTopKills(int page, int takeCount, string KillType)
		{
			IEnumerable<Record> data = null;
			if (KillType == "chicken")
			{
				data = _recordCache.Values.OrderByDescending(i => i.chicken);
			}
			else if (KillType == "boar")
			{
				data = _recordCache.Values.OrderByDescending(i => i.boar);
			}
			else if (KillType == "stag")
			{
				data = _recordCache.Values.OrderByDescending(i => i.stag);
			}
			else if (KillType == "wolf")
			{
				data = _recordCache.Values.OrderByDescending(i => i.wolf);
			}
			else if (KillType == "bear")
			{
				data = _recordCache.Values.OrderByDescending(i => i.bear);
			}
			else if (KillType == "polarbear")
			{
				data = _recordCache.Values.OrderByDescending(i => i.polarbear);
			}
			else if (KillType == "shark")
			{
				data = _recordCache.Values.OrderByDescending(i => i.shark);
			}
			else if (KillType == "horse")
			{
				data = _recordCache.Values.OrderByDescending(i => i.horse);
			}
			else if (KillType == "fish")
			{
				data = _recordCache.Values.OrderByDescending(i => i.fish);
			}
			else if (KillType == "scientist")
			{
				data = _recordCache.Values.OrderByDescending(i => i.scientistnpcnew);
			}
			else if (KillType == "dweller")
			{
				data = _recordCache.Values.OrderByDescending(i => i.dweller);
			}
			else if (KillType == "player")
			{
				data = _recordCache.Values.OrderByDescending(i => i.baseplayer);
			}
			else if (KillType == "zombie")
			{
				data = _recordCache.Values.OrderByDescending(i => i.zombie);
			}
			else if (KillType == "loot")
			{
				data = _recordCache.Values.OrderByDescending(i => i.lootcontainer);
			}
			else if (KillType == "underwaterloot")
			{
				data = _recordCache.Values.OrderByDescending(i => i.underwaterlootcontainer);
			}
			else if (KillType == "bradhelicrate")
			{
				data = _recordCache.Values.OrderByDescending(i => i.bradhelicrate);
			}
			else if (KillType == "hackablecrate")
			{
				data = _recordCache.Values.OrderByDescending(i => i.hackablecrate);
			}
			else if (KillType == "bradleyapc")
			{
				data = _recordCache.Values.OrderByDescending(i => i.bradley);
			}
			else if (KillType == "patrolhelicopter")
			{
				data = _recordCache.Values.OrderByDescending(i => i.heli);
			}
			else if (KillType == "death")
			{
				data = _recordCache.Values.OrderByDescending(i => i.deaths);
			}
			else if (KillType == "suicide")
			{
				data = _recordCache.Values.OrderByDescending(i => i.suicides);
			}
			else if (KillType == "corpse" || KillType == "animals" || KillType == "animalsharvested")
			{
				data = _recordCache.Values.OrderByDescending(i => i.basecorpse);
			}
			else if (KillType == "pcorpse" || KillType == "bodies" || KillType == "bodiesharvested")
			{
				data = _recordCache.Values.OrderByDescending(i => i.npcplayercorpse);
			}
			else if (KillType == "trees")
			{
				data = _recordCache.Values.OrderByDescending(i => i.treescut);
			}
			else if (KillType == "oremined")
			{
				data = _recordCache.Values.OrderByDescending(i => i.oremined);
			}
			else if (KillType == "cactus")
			{
				data = _recordCache.Values.OrderByDescending(i => i.cactuscut);
			}
			else if (KillType == "wood")
			{
				data = _recordCache.Values.OrderByDescending(i => i.woodpickup);
			}
			else if (KillType == "ore")
			{
				data = _recordCache.Values.OrderByDescending(i => i.orepickup);
			}
			else if (KillType == "berries")
			{
				data = _recordCache.Values.OrderByDescending(i => i.berriespickup);
			}
			else if (KillType == "seeds")
			{
				data = _recordCache.Values.OrderByDescending(i => i.seedpickup);
			}
			else if (KillType == "mushroom")
			{
				data = _recordCache.Values.OrderByDescending(i => i.mushroompickup);
			}
			else if (KillType == "hemp")
			{
				data = _recordCache.Values.OrderByDescending(i => i.hemppickup);
			}
			else if (KillType == "corn")
			{
				data = _recordCache.Values.OrderByDescending(i => i.cornpickup);
			}
			else if (KillType == "potato")
			{
				data = _recordCache.Values.OrderByDescending(i => i.potatopickup);
			}
			else if (KillType == "pumpkin")
			{
				data = _recordCache.Values.OrderByDescending(i => i.pumpkinpickup);
			}
			else if (KillType == "turret")
			{
				data = _recordCache.Values.OrderByDescending(i => i.turret);
			}
			else if (KillType == "scarecrow")
			{
				data = _recordCache.Values.OrderByDescending(i => i.scarecrow);
			}

			return data?
			.Skip((page - 1) * takeCount)
			.Take(takeCount);
		}
		private int GetTotalKills(string KillType)
		{
			int totalkills = 0;
			foreach (var x in _recordCache.Values)
			{
				if (KillType == "chicken")
				{
					totalkills += x.chicken;
				}
				if (KillType == "boar")
				{
					totalkills += x.boar;
				}
				if (KillType == "stag")
				{
					totalkills += x.stag;
				}
				if (KillType == "wolf")
				{
					totalkills += x.wolf;
				}
				if (KillType == "bear")
				{
					totalkills += x.bear;
				}
				if (KillType == "polarbear")
				{
					totalkills += x.polarbear;
				}
				if (KillType == "shark")
				{
					totalkills += x.shark;
				}
				if (KillType == "horse")
				{
					totalkills += x.horse;
				}
				if (KillType == "fish")
				{
					totalkills += x.fish;
				}
				if (KillType == "scientist")
				{
					totalkills += x.scientistnpcnew;
				}
				if (KillType == "dweller")
				{
					totalkills += x.dweller;
				}
				if (KillType == "player")
				{
					totalkills += x.baseplayer;
				}
				if (KillType == "corpse")
				{
					totalkills += x.basecorpse;
				}
				if (KillType == "pcorpse")
				{
					totalkills += x.npcplayercorpse;
				}
				if (KillType == "zombie")
				{
					totalkills += x.zombie;
				}
				if (KillType == "deaths")
				{
					totalkills += x.deaths;
				}
				if (KillType == "suicides")
				{
					totalkills += x.suicides;
				}
				if (KillType == "lootcontainer")
				{
					totalkills += x.lootcontainer;
				}
				if (KillType == "bradhelicrate")
				{
					totalkills += x.bradhelicrate;
				}
				if (KillType == "hackablecrate")
				{
					totalkills += x.hackablecrate;
				}
				if (KillType == "bradleyapc")
				{
					totalkills += x.bradley;
				}
				if (KillType == "patrolhelicopter")
				{
					totalkills += x.heli;
				}
				if (KillType == "underwaterloot")
				{
					totalkills += x.underwaterlootcontainer;
				}
				if (KillType == "trees")
				{
					totalkills += x.treescut;
				}
				if (KillType == "oremined")
				{
					totalkills += x.oremined;
				}
				if (KillType == "cactus")
				{
					totalkills += x.cactuscut;
				}
				if (KillType == "wood")
				{
					totalkills += x.woodpickup;
				}
				if (KillType == "ore")
				{
					totalkills += x.orepickup;
				}
				if (KillType == "berries")
				{
					totalkills += x.berriespickup;
				}
				if (KillType == "seeds")
				{
					totalkills += x.seedpickup;
				}
				if (KillType == "mushroom")
				{
					totalkills += x.mushroompickup;
				}
				if (KillType == "potato")
				{
					totalkills += x.potatopickup;
				}
				if (KillType == "corn")
				{
					totalkills += x.cornpickup;
				}
				if (KillType == "pumpkin")
				{
					totalkills += x.pumpkinpickup;
				}
				if (KillType == "hemp")
				{
					totalkills += x.hemppickup;
				}
				if (KillType == "scarecrow")
				{
					totalkills += x.scarecrow;
				}
				if (KillType == "turret")
				{
					totalkills += x.turret;
				}
			}
			return totalkills;
		}
		private void KRKillMessages(BasePlayer player, string languagetype, int newkills, bool killchat)
		{
			if (!config.chatui.ShowKillMessages || !killchat) return;
			int Killinterval = config.chatui.KillMessageInterval;
			int KillMessageLimit = config.chatui.KillMessageLimit;
			if (newkills == Killinterval)
			{
				// UINotify
				if (UINotify != null && config.chatui.enableuinotify)
				{
					UINotify.Call("SendNotify", player, config.chatui.uinotifytype, KRLang(languagetype, player.UserIDString, newkills));
				}
				if (!config.chatui.disablechats)
				{
					player.ChatMessage(KRLang(languagetype, player.UserIDString, newkills));
				}
			}
			else
			{
				double Killintervals = Killinterval;
				for (int k = 0; k < KillMessageLimit; ++k)
				{
					Killintervals += Killinterval + k / KillMessageLimit;

					if (newkills == Killintervals)
					{
						if (UINotify != null && config.chatui.enableuinotify)
						{
							UINotify.Call("SendNotify", player, config.chatui.uinotifytype, KRLang(languagetype, player.UserIDString, newkills));
						}
						if (!config.chatui.disablechats)
						{
							player.ChatMessage(KRLang(languagetype, player.UserIDString, newkills));
						}
					}
				}
			}
		}
		private void PlayerKillsChat(BasePlayer player, string playerinfo)
		{
			if (playerinfo == null) return;
			var user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			if (playerinfo == player.UserIDString)
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.id.ToString().Contains(playerinfo));
			}
			else
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			}
			if (user.Value == null)
			{
				player.ChatMessage(KRLang("noplayer", player.UserIDString, playerinfo));
				return;
			}
			var textTable = new TextTable();

			textTable.AddColumn($"{user.Value.displayname} \n");
			textTable.AddColumn("---------------------- \n");

			if (config.trackingoptions.Trackchicken)
			{ 
				textTable.AddColumn($"{KRLang("chicken", user.Value.id, user.Value.chicken)} \n");
			}
			if (config.trackingoptions.Trackboar) 
			{ 
				textTable.AddColumn($"{KRLang("boar", user.Value.id, user.Value.boar)} \n");
			}
			if (config.trackingoptions.Trackstag) 
			{ 
				textTable.AddColumn($"{KRLang("stag", user.Value.id, user.Value.stag)} \n");
			}
			if (config.trackingoptions.Trackwolf) 
			{ 
				textTable.AddColumn($"{KRLang("wolf", user.Value.id, user.Value.wolf)} \n");
			}
			if (config.trackingoptions.Trackbear)
			{ 
				textTable.AddColumn($"{KRLang("bear", user.Value.id, user.Value.bear)} \n"); 
			}
			if (config.trackingoptions.Trackpolarbear)
			{ 
				textTable.AddColumn($"{KRLang("polarbear", user.Value.id, user.Value.polarbear)} \n"); 
			}
			if (config.trackingoptions.Trackshark)
			{ 
				textTable.AddColumn($"{KRLang("simpleshark", user.Value.id, user.Value.shark)} \n"); 
			}
			if (config.trackingoptions.Trackhorse)
			{ 
				textTable.AddColumn($"{KRLang("horse", user.Value.id, user.Value.horse)} \n"); 
			}
			if (config.trackingoptions.Trackfish)
			{ 
				textTable.AddColumn($"{KRLang("fish", user.Value.id, user.Value.fish)} \n"); 
			}
			if (config.trackingoptions.Trackscientist) 
			{ 
				textTable.AddColumn($"{KRLang("scientists", user.Value.id, user.Value.scientistnpcnew)} \n");
			}
			if (config.trackingoptions.Trackscarecrow) 
			{ 
				textTable.AddColumn($"{KRLang("scarecrow", user.Value.id, user.Value.scarecrow)} \n");
			}
			if (config.trackingoptions.Trackzombie) 
			{ 
				textTable.AddColumn($"{KRLang("zombie", user.Value.id, user.Value.zombie)} \n");
			}
			if (config.trackingoptions.Trackdweller) 
			{ 
				textTable.AddColumn($"{KRLang("dweller", user.Value.id, user.Value.dweller)} \n"); 
			}
			if (config.trackingoptions.TrackPlayer) 
			{ 
				textTable.AddColumn($"{KRLang("players", user.Value.id, user.Value.baseplayer)} \n");
			}
			if (config.trackingoptions.Trackdeaths) 
			{ 
				textTable.AddColumn($"{KRLang("deaths", user.Value.id, user.Value.deaths)} \n"); 
			}
			if (config.trackingoptions.Tracksuicides) 
			{ 
				textTable.AddColumn($"{KRLang("suicide", user.Value.id, user.Value.suicides)} \n"); 
			}
			if (config.trackingoptions.Tracklootcontainer)
			{ 
				textTable.AddColumn($"{KRLang("loot", user.Value.id, user.Value.lootcontainer)} \n");
			}
			if (config.trackingoptions.Trackunderwaterlootcontainer)
			{ 
				textTable.AddColumn($"{KRLang("unloot", user.Value.id, user.Value.underwaterlootcontainer)} \n");
			}
			if (config.trackingoptions.Trackbradhelicrate)
			{ 
				textTable.AddColumn($"{KRLang("bradheliloot", user.Value.id, user.Value.bradhelicrate)} \n");
			}
			if (config.trackingoptions.Trackhackablecrate)
			{ 
				textTable.AddColumn($"{KRLang("hackloot", user.Value.id, user.Value.hackablecrate)} \n");
			}
			if (config.trackingoptions.TrackBradley)
			{ 
				textTable.AddColumn($"{KRLang("bradley", user.Value.id, user.Value.bradley)} \n");
			}
			if (config.trackingoptions.TrackHeli)
			{ 
				textTable.AddColumn($"{KRLang("heli", user.Value.id, user.Value.heli)} \n");
			}
			if (config.trackingoptions.Trackturret)
			{ 
				textTable.AddColumn($"{KRLang("turret", user.Value.id, user.Value.turret)} \n");
			}
			if (config.trackingoptions.TrackAnimalHarvest) 
			{ 
				textTable.AddColumn($"{KRLang("corpse", user.Value.id, user.Value.basecorpse)} \n");
			}
			if (config.trackingoptions.TrackCorpseHarvest) 
			{ 
				textTable.AddColumn($"{KRLang("pcorpse", user.Value.id, user.Value.npcplayercorpse)} \n");
			}
	
			player.ChatMessage($"Kill Records:\n\n {textTable}");
		}
		private void PlayerStatsChat(BasePlayer player, string playerinfo)
		{
			if (playerinfo == null) return;
			var user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			if (playerinfo == player.UserIDString)
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.id.ToString().Contains(playerinfo));
			}
			else
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			}
			if (user.Value == null)
			{
				player.ChatMessage(KRLang("noplayer", player.UserIDString, playerinfo));
				return;
			}
			var textTable = new TextTable();

			textTable.AddColumn($"{user.Value.displayname} \n");
			textTable.AddColumn("---------------------- \n");

			if (config.harvestoptions.treescut)
			{ 
				textTable.AddColumn($"{KRLang("treecut", user.Value.id, user.Value.treescut)} \n");
			}
			if (config.harvestoptions.oremined)
			{ 
				textTable.AddColumn($"{KRLang("oremined", user.Value.id, user.Value.oremined)} \n");
			}
			if (config.harvestoptions.woodpickup)
			{ 
				textTable.AddColumn($"{KRLang("woodpickup", user.Value.id, user.Value.woodpickup)} \n");
			}
			if (config.harvestoptions.cactuscut)
			{ 
				textTable.AddColumn($"{KRLang("catuscut", user.Value.id, user.Value.cactuscut)} \n");
			}
			if (config.harvestoptions.orepickup)
			{ 
				textTable.AddColumn($"{KRLang("orepickup", user.Value.id, user.Value.orepickup)} \n");
			}
			if (config.harvestoptions.berriespickup)
			{ 
				textTable.AddColumn($"{KRLang("berries", user.Value.id, user.Value.berriespickup)} \n");
			}
			if (config.harvestoptions.mushroompickup)
			{ 
				textTable.AddColumn($"{KRLang("mushroom", user.Value.id, user.Value.mushroompickup)} \n");
			}
			if (config.harvestoptions.hemppickup)
			{ 
				textTable.AddColumn($"{KRLang("hemp", user.Value.id, user.Value.hemppickup)} \n");
			}
			if (config.harvestoptions.potatopickup)
			{ 
				textTable.AddColumn($"{KRLang("potato", user.Value.id, user.Value.potatopickup)} \n");
			}
			if (config.harvestoptions.pumpkinpickup)
			{ 
				textTable.AddColumn($"{KRLang("pumpkin", user.Value.id, user.Value.pumpkinpickup)} \n");
			}
			if (config.harvestoptions.seedpickup)
			{ 
				textTable.AddColumn($"{KRLang("seeds", user.Value.id, user.Value.seedpickup)} \n");
			}
			if (config.harvestoptions.cornpickup)
			{ 
				textTable.AddColumn($"{KRLang("corn", user.Value.id, user.Value.cornpickup)} \n");
			}
	
			player.ChatMessage($"Harvest Records:\n\n {textTable}");
		}
		private void TopKillsChat(BasePlayer player, string KillType)
		{
			var textTable = new TextTable();
			var vals = GetTopKills(0, 10, KillType);
			var index = 0;
			int n = 0;
			for (int i = 0; i < 10; i++)
			{
				n++;
				if (vals.ElementAtOrDefault(index) == null)
				{
					continue;
				}
				var playerdata = vals.ElementAtOrDefault(index);
				if (playerdata == null) continue;
				if (config.trackingoptions.Trackchicken && KillType == "chicken" && playerdata.chicken != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.chicken} \n");
				}
				if (config.trackingoptions.Trackboar && KillType == "boar" && playerdata.boar != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.boar} \n");
				}
				if (config.trackingoptions.Trackstag && KillType == "stag" && playerdata.stag != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.stag} \n");
				}
				if (config.trackingoptions.Trackwolf && KillType == "wolf" && playerdata.wolf != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.wolf} \n");
				}
				if (config.trackingoptions.Trackbear && KillType == "bear" && playerdata.bear != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.bear} \n");
				}
				if (config.trackingoptions.Trackpolarbear && KillType == "polarbear" && playerdata.polarbear != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.polarbear} \n");
				}
				if (config.trackingoptions.Trackshark && KillType == "shark" && playerdata.shark != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.shark} \n");
				}
				if (config.trackingoptions.Trackhorse && (KillType == "horse" || KillType == "ridablehorse") && playerdata.horse != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.horse} \n");
				}
				if (config.trackingoptions.Trackfish && KillType == "fish" && playerdata.fish != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.fish} \n");
				}
				if (config.trackingoptions.Trackscientist && KillType == "scientist" && playerdata.scientistnpcnew != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.scientistnpcnew} \n");
				}
				if (config.trackingoptions.Trackscarecrow && KillType == "scarecrow" && playerdata.scarecrow != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.scarecrow} \n");
				}
				if (config.trackingoptions.Trackzombie && KillType == "zombie" && playerdata.zombie != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.zombie} \n");
				}
				if (config.trackingoptions.Trackdweller && KillType == "dweller" && playerdata.dweller != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.dweller} \n");
				}
				if (config.trackingoptions.TrackPlayer && KillType == "player" && playerdata.baseplayer != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.baseplayer} \n");
				}
				if (config.trackingoptions.Tracklootcontainer && (KillType == "loot" || KillType == "lootcontainer") && playerdata.lootcontainer != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.lootcontainer} \n");
				}
				if (config.trackingoptions.Trackunderwaterlootcontainer && (KillType == "underwaterloot" || KillType == "underwaterlootcontainer") && playerdata.underwaterlootcontainer != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.underwaterlootcontainer} \n");
				}
				if (config.trackingoptions.Trackbradhelicrate && (KillType == "bradhelicrate") && playerdata.bradhelicrate != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.bradhelicrate} \n");
				}
				if (config.trackingoptions.Trackhackablecrate && KillType == "hackablecrate" && playerdata.hackablecrate != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.hackablecrate} \n");
				}
				if (config.trackingoptions.TrackBradley && (KillType == "bradleyapc") && playerdata.bradley != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.bradley} \n");
				}
				if (config.trackingoptions.TrackHeli && KillType == "patrolhelicopter" && playerdata.heli != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.heli} \n");
				}
				if (config.trackingoptions.Trackturret && KillType == "turret" && playerdata.turret != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.turret} \n");
				}
				if (config.trackingoptions.Trackdeaths && KillType == "death" && playerdata.deaths != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.deaths} \n");
				}
				if (config.trackingoptions.Tracksuicides && KillType == "suicide" && playerdata.suicides != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.suicides} \n");
				}
				if (config.trackingoptions.Tracksuicides && (KillType == "corpse" || KillType == "animals" || KillType == "animalsharvested") && playerdata.basecorpse != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.basecorpse} \n");
				}
				if (config.trackingoptions.Tracksuicides && (KillType == "pcorpse" || KillType == "bodies" || KillType == "bodiesharvested") && playerdata.npcplayercorpse != 0)
				{
					textTable.AddColumn($"{n}. {playerdata.displayname}: {playerdata.npcplayercorpse} \n");
				}
				index++;
			}
			player.ChatMessage($"Kill Records Top {UILabels(player, KillType)}:\n\n {textTable}");
		}
		private void TotalKillsChat(BasePlayer player)
		{
			var textTable = new TextTable();
			textTable.AddColumn($"{KRLang("totalkills", player.UserIDString)} \n");
			textTable.AddColumn("---------------------- \n");

			if (config.trackingoptions.Trackchicken)
			{ 
				textTable.AddColumn($"{KRLang("chicken", player.UserIDString, GetTotalKills("chicken"))} \n");
			}
			if (config.trackingoptions.Trackboar) 
			{ 
				textTable.AddColumn($"{KRLang("boar", player.UserIDString, GetTotalKills("boar"))} \n");
			}
			if (config.trackingoptions.Trackstag) 
			{ 
				textTable.AddColumn($"{KRLang("stag", player.UserIDString, GetTotalKills("stag"))} \n");
			}
			if (config.trackingoptions.Trackwolf) 
			{ 
				textTable.AddColumn($"{KRLang("wolf", player.UserIDString, GetTotalKills("wolf"))} \n");
			}
			if (config.trackingoptions.Trackbear)
			{ 
				textTable.AddColumn($"{KRLang("bear", player.UserIDString, GetTotalKills("bear"))} \n"); 
			}
			if (config.trackingoptions.Trackpolarbear)
			{ 
				textTable.AddColumn($"{KRLang("polarbear", player.UserIDString, GetTotalKills("polarbear"))} \n"); 
			}
			if (config.trackingoptions.Trackshark)
			{ 
				textTable.AddColumn($"{KRLang("simpleshark", player.UserIDString, GetTotalKills("shark"))} \n"); 
			}
			if (config.trackingoptions.Trackfish)
			{ 
				textTable.AddColumn($"{KRLang("fish", player.UserIDString, GetTotalKills("fish"))} \n"); 
			}
			if (config.trackingoptions.Trackscientist) 
			{ 
				textTable.AddColumn($"{KRLang("scientists", player.UserIDString, GetTotalKills("scientist"))} \n");
			}
			if (config.trackingoptions.Trackscarecrow) 
			{ 
				textTable.AddColumn($"{KRLang("scarecrow", player.UserIDString, GetTotalKills("scarecrow"))} \n");
			}
			if (config.trackingoptions.Trackzombie) 
			{ 
				textTable.AddColumn($"{KRLang("zombie", player.UserIDString, GetTotalKills("zombie"))} \n");
			}
			if (config.trackingoptions.Trackdweller) 
			{ 
				textTable.AddColumn($"{KRLang("dweller", player.UserIDString, GetTotalKills("dweller"))} \n"); 
			}
			if (config.trackingoptions.TrackPlayer) 
			{ 
				textTable.AddColumn($"{KRLang("players", player.UserIDString, GetTotalKills("player"))} \n");
			}
			if (config.trackingoptions.Trackdeaths) 
			{ 
				textTable.AddColumn($"{KRLang("deaths", player.UserIDString, GetTotalKills("deaths"))} \n"); 
			}
			if (config.trackingoptions.Tracksuicides) 
			{ 
				textTable.AddColumn($"{KRLang("suicide", player.UserIDString, GetTotalKills("suicides"))} \n"); 
			}
			if (config.trackingoptions.Tracklootcontainer)
			{ 
				textTable.AddColumn($"{KRLang("loot", player.UserIDString, GetTotalKills("lootcontainer"))} \n");
			}
			if (config.trackingoptions.Trackunderwaterlootcontainer)
			{ 
				textTable.AddColumn($"{KRLang("unloot", player.UserIDString, GetTotalKills("underwaterloot"))} \n");
			}
			if (config.trackingoptions.Trackbradhelicrate)
			{ 
				textTable.AddColumn($"{KRLang("bradheliloot", player.UserIDString, GetTotalKills("bradhelicrate"))} \n");
			}
			if (config.trackingoptions.Trackhackablecrate)
			{ 
				textTable.AddColumn($"{KRLang("hackloot", player.UserIDString, GetTotalKills("hackablecrate"))} \n");
			}
			if (config.trackingoptions.TrackBradley)
			{ 
				textTable.AddColumn($"{KRLang("bradley", player.UserIDString, GetTotalKills("bradleyapc"))} \n");
			}
			if (config.trackingoptions.TrackHeli)
			{ 
				textTable.AddColumn($"{KRLang("heli", player.UserIDString, GetTotalKills("patrolhelicopter"))} \n");
			}
			if (config.trackingoptions.TrackAnimalHarvest) 
			{ 
				textTable.AddColumn($"{KRLang("corpse", player.UserIDString, GetTotalKills("corpse"))} \n");
			}
			if (config.trackingoptions.TrackCorpseHarvest) 
			{ 
				textTable.AddColumn($"{KRLang("pcorpse", player.UserIDString, GetTotalKills("pcorpse"))} \n");
			}
	
			player.ChatMessage($"Kill Records:\n\n {textTable}");
		}
		private void TotalStatsChat(BasePlayer player)
		{
			var textTable = new TextTable();
			textTable.AddColumn($"{KRLang("totalstats", player.UserIDString)} \n");
			textTable.AddColumn("---------------------- \n");

			if (config.harvestoptions.treescut)
			{ 
				textTable.AddColumn($"{KRLang("treecut", player.UserIDString, GetTotalKills("tree"))} \n");
			}
			if (config.harvestoptions.oremined)
			{ 
				textTable.AddColumn($"{KRLang("oremined", player.UserIDString, GetTotalKills("oremined"))} \n");
			}
			if (config.harvestoptions.cactuscut)
			{ 
				textTable.AddColumn($"{KRLang("cactuscut", player.UserIDString, GetTotalKills("cactus"))} \n");
			}
			if (config.harvestoptions.woodpickup)
			{ 
				textTable.AddColumn($"{KRLang("woodpickup", player.UserIDString, GetTotalKills("wood"))} \n");
			}
			if (config.harvestoptions.orepickup)
			{ 
				textTable.AddColumn($"{KRLang("orepickup", player.UserIDString, GetTotalKills("ore"))} \n");
			}
			if (config.harvestoptions.berriespickup)
			{ 
				textTable.AddColumn($"{KRLang("berries", player.UserIDString, GetTotalKills("berries"))} \n");
			}
			if (config.harvestoptions.seedpickup)
			{ 
				textTable.AddColumn($"{KRLang("seeds", player.UserIDString, GetTotalKills("seeds"))} \n");
			}
			if (config.harvestoptions.mushroompickup)
			{ 
				textTable.AddColumn($"{KRLang("mushroom", player.UserIDString, GetTotalKills("mushrrom"))} \n");
			}
			if (config.harvestoptions.potatopickup)
			{ 
				textTable.AddColumn($"{KRLang("potatos", player.UserIDString, GetTotalKills("potatos"))} \n");
			}
			if (config.harvestoptions.pumpkinpickup)
			{ 
				textTable.AddColumn($"{KRLang("pumpkin", player.UserIDString, GetTotalKills("pumpkin"))} \n");
			}
			if (config.harvestoptions.cornpickup)
			{ 
				textTable.AddColumn($"{KRLang("corn", player.UserIDString, GetTotalKills("corn"))} \n");
			}
			if (config.harvestoptions.hemppickup)
			{ 
				textTable.AddColumn($"{KRLang("hemp", player.UserIDString, GetTotalKills("hemp"))} \n");
			}
	
			player.ChatMessage($"Harvest Records:\n\n {textTable}");
		}
		private string KillTypesEnabled()
		{
			string KillType = "";
			if (config.trackingoptions.Trackchicken)
			{ KillType = "chicken"; }
			else if (config.trackingoptions.Trackboar)
			{ KillType = "boar"; }
			else if(config.trackingoptions.Trackstag)
			{ KillType = "stag"; }
			else if (config.trackingoptions.Trackwolf)
			{ KillType = "wolf"; }
			else if (config.trackingoptions.Trackbear)
			{ KillType = "bear"; }
			else if (config.trackingoptions.Trackpolarbear)
			{ KillType = "polarbear"; }
			else if (config.trackingoptions.Trackshark)
			{ KillType = "shark"; }
			else if (config.trackingoptions.Trackhorse)
			{ KillType = "horse"; }
			else if (config.trackingoptions.Trackfish)
			{ KillType = "fish"; }
			else if (config.trackingoptions.TrackPlayer)
			{ KillType = "player"; }
			else if (config.trackingoptions.Trackscientist)
			{ KillType = "scientist"; }
			else if (config.trackingoptions.Trackscarecrow)
			{ KillType = "scarecrow"; }
			else if (config.trackingoptions.Trackzombie)
			{ KillType = "zombie"; }
			else if (config.trackingoptions.Trackdweller)
			{ KillType = "dweller"; }
			else if (config.trackingoptions.TrackAnimalHarvest)
			{ KillType = "corpse"; }
			else if (config.trackingoptions.TrackCorpseHarvest)
			{ KillType = "pcorpse"; }
			else if (config.trackingoptions.Tracklootcontainer)
			{ KillType = "loot"; }
			else if (config.trackingoptions.Trackunderwaterlootcontainer)
			{ KillType = "underwaterloot"; }
			else if (config.trackingoptions.Trackbradhelicrate)
			{ KillType = "bradhelicrate"; }
			else if (config.trackingoptions.Trackhackablecrate)
			{ KillType = "hackablecrate"; }
			else if (config.trackingoptions.Trackbradhelicrate)
			{ KillType = "bradleyapc"; }
			else if (config.trackingoptions.TrackBradley)
			{ KillType = "patrolhelicopter"; }
			else if (config.trackingoptions.TrackHeli)
			{ KillType = "deaths"; }
			else if (config.trackingoptions.Trackturret)
			{ KillType = "turret"; }
			else if (config.trackingoptions.Tracksuicides)
			{ KillType = "suicides"; }
			return KillType;
		}
		private string GatherTypesEnabled()
		{
			string KillType = "";
			if (config.harvestoptions.treescut)
			{ KillType = "trees"; }
			else if (config.harvestoptions.oremined)
			{ KillType = "oremined"; }
			else if (config.harvestoptions.cactuscut)
			{ KillType = "catus"; }
			else if (config.harvestoptions.woodpickup)
			{ KillType = "wood"; }
			else if (config.harvestoptions.orepickup)
			{ KillType = "ore"; }
			else if (config.harvestoptions.berriespickup)
			{ KillType = "berries"; }
			else if (config.harvestoptions.seedpickup)
			{ KillType = "seeds"; }
			else if (config.harvestoptions.mushroompickup)
			{ KillType = "mushroom"; }
			else if (config.harvestoptions.cornpickup)
			{ KillType = "corn"; }
			else if (config.harvestoptions.potatopickup)
			{ KillType = "potato"; }
			else if (config.harvestoptions.pumpkinpickup)
			{ KillType = "pumpkin"; }
			else if (config.harvestoptions.hemppickup)
			{ KillType = "hemp"; }
			return KillType;
		}
		private string LeaderboardPositionLB(int position)
        {
			var LB = "";
			// Row 1
			if (position == 1)
			{
				LB = "0.005 0.715";
			}
			if (position == 2)
			{
				LB = "0.15 0.715";
			}
			if (position == 3)
			{
				LB = "0.295 0.715";
			}
			if (position == 4)
			{
				LB = "0.435 0.715";
			}
			if (position == 5)
			{
				LB = "0.575 0.715";
			}
			if (position == 6)
			{
				LB = "0.715 0.715";
			}
			if (position == 7)
			{
				LB = "0.855 0.715";
			}
			// Row 2
			if (position == 8)
			{
				LB = "0.005 0.47";
			}
			if (position == 9)
			{
				LB = "0.15 0.47";
			}
			if (position == 10)
			{
				LB = "0.295 0.47";
			}
			if (position == 11)
			{
				LB = "0.435 0.47";
			}
			if (position == 12)
			{
				LB = "0.575 0.47";
			}
			if (position == 13)
			{
				LB = "0.715 0.47";
			}
			if (position == 14)
			{
				LB = "0.855 0.47";
			}
			// Row 3
			if (position == 15)
			{
				LB = "0.005 0.235";
			}
			if (position == 16)
			{
				LB = "0.15 0.235";
			}
			if (position == 17)
			{
				LB = "0.295 0.235";
			}
			if (position == 18)
			{
				LB = "0.435 0.235";
			}
			if (position == 19)
			{
				LB = "0.575 0.235";
			}
			if (position == 20)
			{
				LB = "0.715 0.235";
			}
			if (position == 21)
			{
				LB = "0.855 0.235";
			}
			// Row 4
			if (position == 22)
			{
				LB = "0.005 0.01";
			}
			if (position == 23)
			{
				LB = "0.15 0.01";
			}
			if (position == 24)
			{
				LB = "0.295 0.01";
			}
			// Return Position

			return LB;
        }
		private string LeaderboardPositionRT(int position)
        {
			var RT = "";
			// Row 1
			if (position == 1)
			{
				RT = "0.145 0.94";
			}
			if (position == 2)
			{
				RT = "0.29 0.94";
			}
			if (position == 3)
			{
				RT = "0.43 0.94";
			}
			if (position == 4)
			{
				RT = "0.57 0.94";
			}
			if (position == 5)
			{
				RT = "0.71 0.94";
			}
			if (position == 6)
			{
				RT = "0.85 0.94";
			}
			if (position == 7)
			{
				RT = "0.99 0.94";
			}
			// Row 2
			if (position == 8)
			{
				RT = "0.145 0.705";
			}
			if (position == 9)
			{
				RT = "0.29 0.705";
			}
			if (position == 10)
			{
				RT = "0.43 0.705";
			}
			if (position == 11)
			{
				RT = "0.57 0.705";
			}
			if (position == 12)
			{
				RT = "0.71 0.705";
			}
			if (position == 13)
			{
				RT = "0.85 0.705";
			}
			if (position == 14)
			{
				RT = "0.99 0.705";
			}
			//Row 3
			if (position == 15)
			{
				RT = "0.145 0.46";
			}
			if (position == 16)
			{
				RT = "0.29 0.46";
			}
			if (position == 17)
			{
				RT = "0.43 0.46";
			}
			if (position == 18)
			{
				RT = "0.57 0.46";
			}
			if (position == 19)
			{
				RT = "0.71 0.46";
			}
			if (position == 20)
			{
				RT = "0.85 0.46";
			}
			if (position == 21)
			{
				RT = "0.99 0.46";
			}
			// Row 4
			if (position == 22)
			{
				RT = "0.145 0.225";
			}
			if (position == 23)
			{
				RT = "0.29 0.225";
			}
			if (position == 24)
			{
				RT = "0.43 0.225";
			}
			// Return Position
			return RT;
        }
		#endregion

		#region KRUI
		private object UILabels(BasePlayer player, string KillType)
        {
			if(KillType == "chicken")
            {
				return KRLang("chickenui", player.UserIDString);
			}
			if(KillType == "boar")
            {
				return KRLang("boarui", player.UserIDString);
			}
			if(KillType == "stag")
            {
				return KRLang("stagui", player.UserIDString);
			}
			if(KillType == "wolf")
            {
				return KRLang("wolfui", player.UserIDString);
			}
			if(KillType == "bear")
            {
				return KRLang("bearui", player.UserIDString);
			}
			if(KillType == "polarbear")
            {
				return KRLang("polarbearui", player.UserIDString);
			}
			if(KillType == "shark")
            {
				return KRLang("sharkui", player.UserIDString);
			}
			if(KillType == "horse")
            {
				return KRLang("horseui", player.UserIDString);
			}
			if(KillType == "fish")
            {
				return KRLang("fishui", player.UserIDString);
			}
			if(KillType == "scientist")
            {
				return KRLang("scientistui", player.UserIDString);
			}
			if(KillType == "scarecrow")
            {
				return KRLang("scarecrowui", player.UserIDString);
			}
			if(KillType == "dweller")
            {
				return KRLang("dwellerui", player.UserIDString);
			}
			if(KillType == "loot" || KillType == "lootcontainer")
            {
				return KRLang("lootui", player.UserIDString);
			}
			if(KillType == "bradhelicrate")
            {
				return KRLang("bradheliui", player.UserIDString);
			}
			if(KillType == "hackablecrate")
            {
				return KRLang("hackableui", player.UserIDString);
			}
			if(KillType == "bradleyapc")
            {
				return KRLang("bradleyui", player.UserIDString);
			}
			if(KillType == "patrolhelicopter")
            {
				return KRLang("patrolhelicopterui", player.UserIDString);
			}
			if(KillType == "turret")
            {
				return KRLang("turretui", player.UserIDString);
			}
			if(KillType == "underwaterloot" || KillType == "underwaterlootcontainer")
            {
				return KRLang("wlootui", player.UserIDString);
			}
			if(KillType == "death")
            {
				return KRLang("deathui", player.UserIDString);
			}
			if(KillType == "suicide")
            {
				return KRLang("suicideui", player.UserIDString);
			}
			if(KillType == "player")
            {
				return KRLang("playerui", player.UserIDString);
			}
			if(KillType == "corpse" || KillType == "animals" || KillType == "animalsharvested")
            {
				return KRLang("corpseui", player.UserIDString);
			}
			if(KillType == "pcorpse" || KillType == "bodies" || KillType == "bodiesharvested")
            {
				return KRLang("pcorpseui", player.UserIDString);
			}
			if (KillType == "trees")
			{
				return KRLang("treeui", player.UserIDString);
			}
			if (KillType == "oremined")
			{
				return KRLang("oreminedui", player.UserIDString);
			}
			if (KillType == "cactus")
			{
				return KRLang("cactusui", player.UserIDString);
			}
			if (KillType == "wood")
			{
				return KRLang("woodui", player.UserIDString);
			}
			if (KillType == "ore")
			{
				return KRLang("oreui", player.UserIDString);
			}
			if (KillType == "berries")
			{
				return KRLang("berriesui", player.UserIDString);
			}
			if (KillType == "seeds")
			{
				return KRLang("seedsui", player.UserIDString);
			}
			if (KillType == "potato")
			{
				return KRLang("potatoui", player.UserIDString);
			}
			if (KillType == "pumpkin")
			{
				return KRLang("pumpkinui", player.UserIDString);
			}
			if (KillType == "corn")
			{
				return KRLang("cornui", player.UserIDString);
			}
			if (KillType == "hemp")
			{
				return KRLang("hempui", player.UserIDString);
			}
			if (KillType == "mushroom")
			{
				return KRLang("mushroomui", player.UserIDString);
			}
			if (KillType == "zombie")
			{
				return KRLang("zombieui", player.UserIDString);
			}

			return null;
        }
		private CuiPanel KRUIPanel(string anchorMin, string anchorMax, string color = "0 0 0 0")
		{
			return new CuiPanel
			{
				Image =
				{
					Color = color
				},
				RectTransform =
				{
					AnchorMin = anchorMin,
					AnchorMax = anchorMax
				}
			};
		}
		private CuiLabel KRUILabel(string text, int i, float height, TextAnchor align = TextAnchor.MiddleLeft, int fontSize = 13, string xMin = "0", string xMax = "1", string color = "1.0 1.0 1.0 1.0")
		{
			return new CuiLabel
			{
				Text =
				{
					Text = text,
					FontSize = fontSize,
					Align = align,
					Color = color
				},
				RectTransform =
				{
					AnchorMin = $"{xMin} {1 - height*i + i * .002f}",
					AnchorMax = $"{xMax} {1 - height*(i-1) + i * .002f}"
				}
			};
		}
		private CuiButton KRUIButton(string command, int i, float rowHeight, int fontSize = 11, string color = "1.0 0.0 0.0 0.7", string content = "+", string xMin = "0", string xMax = "1", TextAnchor align = TextAnchor.MiddleLeft)
		{
			return new CuiButton
			{
					Button =
				{
					Command = command,
					Color = $"{color}"
				},
					RectTransform =
				{
					AnchorMin = $"{xMin} {1 - rowHeight*i + i * .002f}",
					AnchorMax = $"{xMax} {1 - rowHeight*(i-1) + i * .002f}"
				},
					Text =
				{
					Text = content,
					FontSize = fontSize,
					Align = align,
				}
			};
		}
		private void KRUIplayers(BasePlayer player, string playerinfo)
		{
			if (playerinfo == null) return;
			var user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			if (playerinfo == player.UserIDString)
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.id.ToString().Contains(playerinfo));
			}
			else
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			}
			if (user.Value == null)
			{
				player.ChatMessage(KRLang("noplayer", player.UserIDString, playerinfo));
				return;
			}
			var KRUIelements = new CuiElementContainer();
			var height = 0.041f;
			// Main UI
			KRUIelements.Add(new CuiPanel 
			{ 
				Image = 
				{ 
					Color = "0.0 0.0 0.0 0.95" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = $"0.83 0.27", 
					AnchorMax = $"0.997 0.95"
				}, 
				CursorEnabled = true 
			}, "Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton 
			{ 
				Button = 
				{ 
					Close = KRUIName, 
					Color = "0.0 0.0 0.0 0.0" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = "0.87 0.94", 
					AnchorMax = "1.0 1.002" 
				}, 
				Text = 
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter 
				} 
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("☠ Kill Records:", 1, 0.043f, TextAnchor.MiddleCenter, 17, "0.03", "0.85", "1.0 0.0 0.0 1.0"), KRUIName);
			// Top Kills Button
			var KillType = KillTypesEnabled();
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Command = $"kr.topkills {KillType} {player.UserIDString}",
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.00 0.91",
					AnchorMax = "0.07 0.99"
				},
				Text =
				{
					Text = "⋘",
					FontSize = 23,
					Color = "0.0 0.0 1.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			// Main UI
			KRUIelements.Add(KRUIPanel("0.04 0.02", "0.98 0.94"), KRUIName, KRUIMainName);
			KRUIelements.Add(KRUILabel($"〖 {user.Value.displayname} 〗", 1, height, TextAnchor.MiddleCenter, 17), KRUIMainName);
			//i++;
			KRUIelements.Add(KRUILabel(("────────────────────────"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int i = 2;
			
			if (config.trackingoptions.Trackchicken)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("chicken", user.Value.id, user.Value.chicken)}"), config.orderoptions.chickenpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackboar) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("boar", user.Value.id, user.Value.boar)}"), config.orderoptions.boarpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackstag) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("stag", user.Value.id, user.Value.stag)}"), config.orderoptions.stagpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackwolf) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("wolf", user.Value.id, user.Value.wolf)}"), config.orderoptions.wolfpos +i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackbear) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bear", user.Value.id, user.Value.bear)}"), config.orderoptions.bearpos + i, height), KRUIMainName);
			}

			if (config.trackingoptions.Trackpolarbear) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("polarbear", user.Value.id, user.Value.polarbear)}"), config.orderoptions.polarbearpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackshark) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("simpleshark", user.Value.id, user.Value.shark)}"), config.orderoptions.sharkpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackhorse) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("horse", user.Value.id, user.Value.horse)}"), config.orderoptions.horsepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackfish) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("fish", user.Value.id, user.Value.fish)}"), config.orderoptions.fishpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackscientist) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("scientists", user.Value.id, user.Value.scientistnpcnew)}"), config.orderoptions.scientistpos + i, height), KRUIMainName);
			}

			if (config.trackingoptions.Trackscarecrow) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("scarecrow", user.Value.id, user.Value.scarecrow)}"), config.orderoptions.scarecrowpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackdweller) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("dweller", user.Value.id, user.Value.dweller)}"), config.orderoptions.dwellerpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackPlayer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("players", user.Value.id, user.Value.baseplayer)}"), config.orderoptions.playerpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackdeaths) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("deaths", user.Value.id, user.Value.deaths)}"), config.orderoptions.deathpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Tracksuicides) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("suicide", user.Value.id, user.Value.suicides)}"), config.orderoptions.suicidepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Tracklootcontainer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("loot", user.Value.id, user.Value.lootcontainer)}"), config.orderoptions.lootpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackunderwaterlootcontainer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("unloot", user.Value.id, user.Value.underwaterlootcontainer)}"), config.orderoptions.unlootpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackbradhelicrate) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bradheliloot", user.Value.id, user.Value.bradhelicrate)}"), config.orderoptions.bradhelicratepos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackhackablecrate) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("hackloot", user.Value.id, user.Value.hackablecrate)}"), config.orderoptions.hackablecratepos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackBradley) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bradley", user.Value.id, user.Value.bradley)}"), config.orderoptions.bradleypos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackHeli) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("heli", user.Value.id, user.Value.heli)}"), config.orderoptions.helipos + i, height), KRUIMainName); 
			}

			if (config.trackingoptions.Trackturret) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("turret", user.Value.id, user.Value.turret)}"), config.orderoptions.turretpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackAnimalHarvest)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("corpse", user.Value.id, user.Value.basecorpse)}"), config.orderoptions.corpsepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.TrackCorpseHarvest)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("pcorpse", user.Value.id, user.Value.npcplayercorpse)}"), config.orderoptions.pcorpsepos + i, height), KRUIMainName);
			}
			
			CuiHelper.AddUi(player, KRUIelements);
			return;
		}
		private void KRUIStatsplayers(BasePlayer player, string playerinfo)
		{
			if (playerinfo == null) return;
			var user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			if (playerinfo == player.UserIDString)
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.id.ToString().Contains(playerinfo));
			}
			else
			{
				user = _recordCache.ToList().FirstOrDefault(x => x.Value.displayname.ToString().ToLower().Contains(playerinfo));
			}
			if (user.Value == null)
			{
				player.ChatMessage(KRLang("noplayer", player.UserIDString, playerinfo));
				return;
			}
			var KRUIelements = new CuiElementContainer();
			var height = 0.043f;
			// Main UI
			KRUIelements.Add(new CuiPanel 
			{ 
				Image = 
				{ 
					Color = "0.0 0.0 0.0 0.95" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = $"0.83 0.27", 
					AnchorMax = $"0.997 0.95"
				}, 
				CursorEnabled = true 
			}, "Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton 
			{ 
				Button = 
				{ 
					Close = KRUIName, 
					Color = "0.0 0.0 0.0 0.0" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = "0.87 0.94", 
					AnchorMax = "1.0 1.002" 
				}, 
				Text = 
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter 
				} 
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("❀ Harvest Records:", 1, height, TextAnchor.MiddleCenter, 19, "0.03", "0.85", "0 1 0 1"), KRUIName);
			// Top Kills Button
			var KillType = GatherTypesEnabled();
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Command = $"kr.topstats {KillType} {player.UserIDString}",
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.00 0.91",
					AnchorMax = "0.07 0.99"
				},
				Text =
				{
					Text = "⋘",
					FontSize = 23,
					Color = "0.0 0.0 1.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);	
			// Main UI
			KRUIelements.Add(KRUIPanel("0.04 0.02", "0.98 0.94"), KRUIName, KRUIMainName);
			KRUIelements.Add(KRUILabel($"〖 {user.Value.displayname} 〗", 1, height, TextAnchor.MiddleCenter, 17), KRUIMainName);
			//i++;
			KRUIelements.Add(KRUILabel(("────────────────────────"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int i = 3;			
			if (config.harvestoptions.treescut)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("treecut", user.Value.id, user.Value.treescut)}"), i, height), KRUIMainName);
				i++;
			}		
			if (config.harvestoptions.oremined)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("oremined", user.Value.id, user.Value.oremined)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.woodpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("woodpickup", user.Value.id, user.Value.woodpickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.orepickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("orepickup", user.Value.id, user.Value.orepickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.berriespickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("berries", user.Value.id, user.Value.berriespickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.mushroompickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("mushroom", user.Value.id, user.Value.mushroompickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.potatopickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("potato", user.Value.id, user.Value.potatopickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.pumpkinpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("pumpkin", user.Value.id, user.Value.pumpkinpickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.cornpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("corn", user.Value.id, user.Value.cornpickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.hemppickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("hemp", user.Value.id, user.Value.hemppickup)}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.seedpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("seeds", user.Value.id, user.Value.seedpickup)}"), i, height), KRUIMainName);
				i++;
			}
			CuiHelper.AddUi(player, KRUIelements);
			return;
		}
		private void KRUITop(BasePlayer player, string KillType)
		{
			if (player == null) return;
			if (KillType == null)
			{
				KillType = KillTypesEnabled();
			}
			var KRUIelements = new CuiElementContainer();
			var height = 0.075f;
			var selectionheight = 0.043f;
			var vals = GetTopKills(0, 10, KillType);
			if (vals == null) { return; }
			var index = 0;
			// Main UI
			KRUIelements.Add(new CuiPanel{
				Image = 
				{
					Color = "0.0 0.0 0.0 0.9"
				},
				RectTransform = 
				{
					AnchorMin = "0.75 0.25",
					AnchorMax = "0.995 0.90"
				},
				CursorEnabled = true
			},"Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Close = KRUIName,
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.87 0.93",
					AnchorMax = "1.0 1.002"
				},
				Text =
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("☠ Top 10 Kill Records", 1, height, TextAnchor.MiddleCenter, 19, "0.03", "0.85", "1.0 0.0 0.0 1.0"), KRUIName);
			// Leaderboard Button
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Command = $"kr.leaderboard {player.UserIDString}",
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.00 0.91",
					AnchorMax = "0.07 0.99"
				},
				Text =
				{
					Text = "⋘",
					FontSize = 23,
					Color = "0.0 0.0 1.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			// Selections UI
			KRUIelements.Add(KRUIPanel("0.01 0.00", "0.35 0.9"), KRUIName, KRUISelection);
			var selected = "➤";
			var dcolor = "0.0 0.0 0.0 0.7";
			var scolor = "1.0 0.0 0.0 0.7";
			if (config.trackingoptions.Trackchicken)
			{				
				if (KillType == "chicken")
				{
					KRUIelements.Add(KRUIButton("kr.topkills chicken", config.orderoptions.chickenpos, selectionheight, 11, scolor, $"{selected} {KRLang("chickenui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills chicken", config.orderoptions.chickenpos, selectionheight, 11, dcolor, $" {KRLang("chickenui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackboar)
			{
				if (KillType == "boar")
				{
					KRUIelements.Add(KRUIButton("kr.topkills boar", config.orderoptions.boarpos, selectionheight, 11, scolor, $"{selected} {KRLang("boarui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills boar", config.orderoptions.boarpos, selectionheight, 11, dcolor, $" {KRLang("boarui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackstag)
			{				
				if (KillType == "stag")
				{
					KRUIelements.Add(KRUIButton("kr.topkills stag", config.orderoptions.stagpos, selectionheight, 11, scolor, $"{selected} {KRLang("stagui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills stag", config.orderoptions.stagpos, selectionheight, 11, dcolor, $" {KRLang("stagui", player.UserIDString)}"), KRUISelection);
				}
			}			
			if (config.trackingoptions.Trackwolf)
			{
				if (KillType == "wolf")
				{
					KRUIelements.Add(KRUIButton("kr.topkills wolf", config.orderoptions.wolfpos, selectionheight, 11, scolor, $"{selected} {KRLang("wolfui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills wolf", config.orderoptions.wolfpos, selectionheight, 11, dcolor, $" {KRLang("wolfui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackbear)
			{
				if (KillType == "bear")
				{
					KRUIelements.Add(KRUIButton("kr.topkills bear", config.orderoptions.bearpos, selectionheight, 11, scolor, $"{selected} {KRLang("bearui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills bear", config.orderoptions.bearpos, selectionheight, 11, dcolor, $" {KRLang("bearui", player.UserIDString)}"), KRUISelection);
				}
			}			
			if (config.trackingoptions.Trackpolarbear)
			{
				if (KillType == "polarbear")
				{
					KRUIelements.Add(KRUIButton("kr.topkills polarbear", config.orderoptions.polarbearpos, selectionheight, 11, scolor, $"{selected} {KRLang("polarbearui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills polarbear", config.orderoptions.polarbearpos, selectionheight, 11, dcolor, $" {KRLang("polarbearui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackshark)
			{
				if (KillType == "shark")
				{
					KRUIelements.Add(KRUIButton("kr.topkills shark", config.orderoptions.sharkpos, selectionheight, 11, scolor, $"{selected} {KRLang("sharkui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills shark", config.orderoptions.sharkpos, selectionheight, 11, dcolor, $" {KRLang("sharkui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackhorse)
			{
				if (KillType == "horse")
				{
					KRUIelements.Add(KRUIButton("kr.topkills horse", config.orderoptions.horsepos, selectionheight, 11, scolor, $"{selected} {KRLang("horseui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills horse", config.orderoptions.horsepos, selectionheight, 11, dcolor, $" {KRLang("horseui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackfish)
			{
				if (KillType == "fish")
				{
					KRUIelements.Add(KRUIButton("kr.topkills fish", config.orderoptions.fishpos, selectionheight, 11, scolor, $"{selected} {KRLang("fishui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills fish", config.orderoptions.fishpos, selectionheight, 11, dcolor, $" {KRLang("fishui", player.UserIDString)}"), KRUISelection);
				}
			}			
			if (config.trackingoptions.Trackscientist)
			{
				if (KillType == "scientist")
				{
					KRUIelements.Add(KRUIButton("kr.topkills scientist", config.orderoptions.scientistpos, selectionheight, 11, scolor, $"{selected} {KRLang("scientistui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills scientist", config.orderoptions.scientistpos, selectionheight, 11, dcolor, $" {KRLang("scientistui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackscarecrow)
			{
				if (KillType == "scarecrow")
				{
					KRUIelements.Add(KRUIButton("kr.topkills scarecrow", config.orderoptions.scarecrowpos, selectionheight, 11, scolor, $"{selected} {KRLang("scarecrowui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills scarecrow", config.orderoptions.scarecrowpos, selectionheight, 11, dcolor, $" {KRLang("scarecrowui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackdweller)
			{
				if (KillType == "dweller")
				{
					KRUIelements.Add(KRUIButton("kr.topkills dweller", config.orderoptions.dwellerpos, selectionheight, 11, scolor, $"{selected} {KRLang("dwellerui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills dweller", config.orderoptions.dwellerpos, selectionheight, 11, dcolor, $" {KRLang("dwellerui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.TrackPlayer)
			{
				if (KillType == "player")
				{
					KRUIelements.Add(KRUIButton("kr.topkills player", config.orderoptions.playerpos, selectionheight, 11, scolor, $"{selected} {KRLang("playerui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills player", config.orderoptions.playerpos, selectionheight, 11, dcolor, $" {KRLang("playerui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Tracklootcontainer)
			{
				if (KillType == "loot")
				{
					KRUIelements.Add(KRUIButton("kr.topkills loot", config.orderoptions.lootpos, selectionheight, 11, scolor, $"{selected} {KRLang("lootui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills loot", config.orderoptions.lootpos, selectionheight, 11, dcolor, $" {KRLang("lootui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackunderwaterlootcontainer)
			{
				if (KillType == "underwaterloot")
				{
					KRUIelements.Add(KRUIButton("kr.topkills underwaterloot", config.orderoptions.unlootpos, selectionheight, 11, scolor, $"{selected} {KRLang("wlootui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills underwaterloot", config.orderoptions.unlootpos, selectionheight, 11, dcolor, $" {KRLang("wlootui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackbradhelicrate)
			{
				if (KillType == "bradhelicrate")
				{
					KRUIelements.Add(KRUIButton("kr.topkills bradhelicrate", config.orderoptions.bradhelicratepos, selectionheight, 11, scolor, $"{selected} {KRLang("bradheliui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills bradhelicrate", config.orderoptions.bradhelicratepos, selectionheight, 11, dcolor, $" {KRLang("bradheliui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackhackablecrate)
			{
				if (KillType == "hackablecrate")
				{
					KRUIelements.Add(KRUIButton("kr.topkills hackablecrate", config.orderoptions.hackablecratepos, selectionheight, 11, scolor, $"{selected} {KRLang("hackableui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills hackablecrate", config.orderoptions.hackablecratepos, selectionheight, 11, dcolor, $" {KRLang("hackableui", player.UserIDString)}"), KRUISelection);
				}
			}			
			if (config.trackingoptions.TrackBradley)
			{
				if (KillType == "bradleyapc")
				{
					KRUIelements.Add(KRUIButton("kr.topkills bradleyapc", config.orderoptions.bradleypos, selectionheight, 11, scolor, $"{selected} {KRLang("bradleyui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills bradleyapc", config.orderoptions.bradleypos, selectionheight, 11, dcolor, $" {KRLang("bradleyui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.TrackHeli)
			{
				if (KillType == "patrolhelicopter")
				{
					KRUIelements.Add(KRUIButton("kr.topkills patrolhelicopter", config.orderoptions.helipos, selectionheight, 11, scolor, $"{selected} {KRLang("patrolhelicopterui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills patrolhelicopter", config.orderoptions.helipos, selectionheight, 11, dcolor, $" {KRLang("patrolhelicopterui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackturret)
			{
				if (KillType == "turret")
				{
					KRUIelements.Add(KRUIButton("kr.topkills turret", config.orderoptions.turretpos, selectionheight, 11, scolor, $"{selected} {KRLang("turretui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills turret", config.orderoptions.turretpos, selectionheight, 11, dcolor, $" {KRLang("turretui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Trackdeaths)
			{
				if (KillType == "death")
				{
					KRUIelements.Add(KRUIButton("kr.topkills death", config.orderoptions.deathpos, selectionheight, 11, scolor, $"{selected} {KRLang("deathui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills death", config.orderoptions.deathpos, selectionheight, 11, dcolor, $" {KRLang("deathui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.Tracksuicides)
			{
				if (KillType == "suicide")
				{
					KRUIelements.Add(KRUIButton("kr.topkills suicide", config.orderoptions.suicidepos, selectionheight, 11, scolor, $"{selected} {KRLang("suicideui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills suicide", config.orderoptions.suicidepos, selectionheight, 11, dcolor, $" {KRLang("suicideui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.TrackAnimalHarvest)
			{
				if (KillType == "corpse")
				{
					KRUIelements.Add(KRUIButton("kr.topkills corpse", config.orderoptions.corpsepos, selectionheight, 11, scolor, $"{selected} {KRLang("corpseui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills corpse", config.orderoptions.corpsepos, selectionheight, 11, dcolor, $" {KRLang("corpseui", player.UserIDString)}"), KRUISelection);
				}
			}
			if (config.trackingoptions.TrackCorpseHarvest)
			{
				if (KillType == "pcorpse")
				{
					KRUIelements.Add(KRUIButton("kr.topkills pcorpse", config.orderoptions.pcorpsepos, selectionheight, 11, scolor, $"{selected} {KRLang("pcorpseui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topkills pcorpse", config.orderoptions.pcorpsepos, selectionheight, 11, dcolor, $" {KRLang("pcorpseui", player.UserIDString)}"), KRUISelection);
				}
			}
			// List UI
			KRUIelements.Add(KRUIPanel("0.40 0.09", "0.98 0.9"), KRUIName, KRUIMainName);
			// Inner UI Labels
			KRUIelements.Add(KRUILabel($"〖 {UILabels(player, KillType)} 〗", 1, height, TextAnchor.MiddleCenter, 16), KRUIMainName);
			KRUIelements.Add(KRUILabel(("﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int n = 0;
			for (int i = 3; i < 13; i++)
			{
				n++;
				if (vals.ElementAtOrDefault(index) == null)
				{ 
					continue; 
				}
				var playerdata = vals.ElementAtOrDefault(index);
				if (playerdata == null) continue;
				if (KillType == "chicken" && playerdata?.chicken != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.06", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.chicken}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "boar" && playerdata.boar != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.boar}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "stag" && playerdata.stag != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.stag}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "wolf" && playerdata.wolf != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.wolf}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "bear" && playerdata.bear != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.bear}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "polarbear" && playerdata.polarbear != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.polarbear}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "shark" && playerdata.shark != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.shark}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "horse" && playerdata.horse != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.horse}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "fish" && playerdata.fish != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.fish}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "scientist" && playerdata.scientistnpcnew != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.scientistnpcnew}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "scarecrow" && playerdata.scarecrow != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.scarecrow}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "dweller" && playerdata.dweller != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.dweller}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "player" && playerdata.baseplayer != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.baseplayer}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "loot" && playerdata.lootcontainer != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.lootcontainer}", "0.03", "1"), KRUIMainName);
				}
				else if ((KillType == "underwaterloot" || KillType == "underwaterlootcontainer") && playerdata.underwaterlootcontainer != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.underwaterlootcontainer}", "0.03", "1"), KRUIMainName);
				}
				else if ((KillType == "bradhelicrate") && playerdata.bradhelicrate != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.bradhelicrate}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "hackablecrate" && playerdata.hackablecrate != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.hackablecrate}", "0.03", "1"), KRUIMainName);
				}
				else if ((KillType == "bradleyapc") && playerdata.bradley != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.bradley}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "patrolhelicopter" && playerdata.heli != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.heli}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "turret" && playerdata.turret != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.turret}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "death" && playerdata.deaths != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.deaths}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "suicide" && playerdata.suicides != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.suicides}", "0.03", "1"), KRUIMainName);
				}
				else if ((KillType == "corpse" || KillType == "animals" || KillType == "animalsharvested") && playerdata.basecorpse != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.basecorpse}", "0.03", "1"), KRUIMainName);
				}
				else if ((KillType == "pcorpse" || KillType == "bodies" || KillType == "bodiesharvested") && playerdata.npcplayercorpse != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.npcplayercorpse}", "0.03", "1"), KRUIMainName);
				} 
				index++;
			}
			CuiHelper.AddUi(player, KRUIelements);
		}
		private void KRUIStatsTop(BasePlayer player, string KillType)
		{
			if (player == null) return;
			if (KillType == null)
			{
				KillType = GatherTypesEnabled();
			}
			var KRUIelements = new CuiElementContainer();
			var height = 0.075f;
			var selectionheight = 0.045f;
			int r = 1;
			var vals = GetTopKills(0, 10, KillType);
			if (vals == null) { return; }
			var index = 0;
			// Main UI
			KRUIelements.Add(new CuiPanel{
				Image = 
				{
					Color = "0.0 0.0 0.0 0.9"
				},
				RectTransform = 
				{
					AnchorMin = "0.75 0.25",
					AnchorMax = "0.995 0.90"
				},
				CursorEnabled = true
			},"Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Close = KRUIName,
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.87 0.93",
					AnchorMax = "1.0 1.002"
				},
				Text =
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("❀ Top 10 Harvest Records", 1, height, TextAnchor.MiddleCenter, 19, "0.03", "0.85", "0 1 0 1"), KRUIName);
			// Selections UI
			KRUIelements.Add(KRUIPanel("0.01 0.00", "0.35 0.9"), KRUIName, KRUISelection);
			var selected = "➤";
			var dcolor = "0.0 0.0 0.0 0.7";
			var scolor = "1.0 0.0 0.0 0.7";
			if (config.harvestoptions.treescut)
			{				
				if (KillType == "trees")
				{
					KRUIelements.Add(KRUIButton("kr.topstats trees", r, selectionheight, 11, scolor, $"{selected} {KRLang("treeui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats trees", r, selectionheight, 11, dcolor, $" {KRLang("treeui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.oremined)
			{				
				if (KillType == "oremined")
				{
					KRUIelements.Add(KRUIButton("kr.topstats oremined", r, selectionheight, 11, scolor, $"{selected} {KRLang("oreminedui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats oremined", r, selectionheight, 11, dcolor, $" {KRLang("oreminedui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.cactuscut)
			{				
				if (KillType == "cactus")
				{
					KRUIelements.Add(KRUIButton("kr.topstats cactus", r, selectionheight, 11, scolor, $"{selected} {KRLang("cactusui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats cactus", r, selectionheight, 11, dcolor, $" {KRLang("cactusui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.woodpickup)
			{				
				if (KillType == "wood")
				{
					KRUIelements.Add(KRUIButton("kr.topstats wood", r, selectionheight, 11, scolor, $"{selected} {KRLang("woodui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats wood", r, selectionheight, 11, dcolor, $" {KRLang("woodui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.orepickup)
			{				
				if (KillType == "ore")
				{
					KRUIelements.Add(KRUIButton("kr.topstats ore", r, selectionheight, 11, scolor, $"{selected} {KRLang("oreui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats ore", r, selectionheight, 11, dcolor, $" {KRLang("oreui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.berriespickup)
			{				
				if (KillType == "berries")
				{
					KRUIelements.Add(KRUIButton("kr.topstats berries", r, selectionheight, 11, scolor, $"{selected} {KRLang("berriesui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats berries", r, selectionheight, 11, dcolor, $" {KRLang("berriesui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.seedpickup)
			{				
				if (KillType == "seeds")
				{
					KRUIelements.Add(KRUIButton("kr.topstats seeds", r, selectionheight, 11, scolor, $"{selected} {KRLang("seedsui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats seeds", r, selectionheight, 11, dcolor, $" {KRLang("seedsui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.mushroompickup)
			{				
				if (KillType == "mushroom")
				{
					KRUIelements.Add(KRUIButton("kr.topstats mushroom", r, selectionheight, 11, scolor, $"{selected} {KRLang("mushroomui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats mushroom", r, selectionheight, 11, dcolor, $" {KRLang("mushroomui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.potatopickup)
			{				
				if (KillType == "potato")
				{
					KRUIelements.Add(KRUIButton("kr.topstats potato", r, selectionheight, 11, scolor, $"{selected} {KRLang("potatoui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats potato", r, selectionheight, 11, dcolor, $" {KRLang("potatoui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.pumpkinpickup)
			{				
				if (KillType == "pumpkin")
				{
					KRUIelements.Add(KRUIButton("kr.topstats pumpkin", r, selectionheight, 11, scolor, $"{selected} {KRLang("pumpkinui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats pumpkin", r, selectionheight, 11, dcolor, $" {KRLang("pumpkinui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.cornpickup)
			{				
				if (KillType == "corn")
				{
					KRUIelements.Add(KRUIButton("kr.topstats corn", r, selectionheight, 11, scolor, $"{selected} {KRLang("cornui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats corn", r, selectionheight, 11, dcolor, $" {KRLang("cornui", player.UserIDString)}"), KRUISelection);
				}
				r++;
			}
			if (config.harvestoptions.hemppickup)
			{				
				if (KillType == "hemp")
				{
					KRUIelements.Add(KRUIButton("kr.topstats hemp", r, selectionheight, 11, scolor, $"{selected} {KRLang("hempui", player.UserIDString)}"), KRUISelection);
				}
				else
				{
					KRUIelements.Add(KRUIButton("kr.topstats hemp", r, selectionheight, 11, dcolor, $" {KRLang("hempui", player.UserIDString)}"), KRUISelection);
				}
			}
			// List UI
			KRUIelements.Add(KRUIPanel("0.40 0.09", "0.98 0.9"), KRUIName, KRUIMainName);
			// Inner UI Labels
			KRUIelements.Add(KRUILabel($"〖 {UILabels(player, KillType)} 〗", 1, height, TextAnchor.MiddleCenter, 16), KRUIMainName);
			KRUIelements.Add(KRUILabel(("﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int n = 0;
			for (int i = 3; i < 13; i++)
			{
				n++;
				if (vals.ElementAtOrDefault(index) == null)
				{ 
					continue; 
				}
				var playerdata = vals.ElementAtOrDefault(index);
				if (playerdata == null) continue;

				if (KillType == "trees" && playerdata?.treescut != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.06", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.treescut}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "oremined" && playerdata.oremined != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.oremined}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "catus" && playerdata.cactuscut != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.cactuscut}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "wood" && playerdata.woodpickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.woodpickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "ore" && playerdata.orepickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.orepickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "berries" && playerdata.berriespickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.berriespickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "seeds" && playerdata.seedpickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.seedpickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "mushroom" && playerdata.mushroompickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.mushroompickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "potato" && playerdata.potatopickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.potatopickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "pumpkin" && playerdata.pumpkinpickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.pumpkinpickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "corn" && playerdata.cornpickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.cornpickup}", "0.03", "1"), KRUIMainName);
				}
				else if (KillType == "hemp" && playerdata.hemppickup != 0)
				{
					if (playerdata.displayname == _recordCache[player.UserIDString].displayname)
					{
						KRUIelements.Add(KRUILabel(("➤"), i, height, TextAnchor.MiddleLeft, 15, "-0.050", "1", "1 0.92 0.016 1"), KRUIMainName);
					}
					KRUIelements.Add(KRUIButton($"kr.topplayersstats {playerdata.displayname}", i, height, 15, "0.0 0.0 0.0 0.0", $"{n}. {playerdata.displayname}: {playerdata.hemppickup}", "0.03", "1"), KRUIMainName);
				}
				index++;
			}
				CuiHelper.AddUi(player, KRUIelements);
		}
		private void KRUITopAll(BasePlayer player)
        {
			if (player == null) return;
			var KRUIelements = new CuiElementContainer();
			var height = 0.053f;
			// Main UI
			KRUIelements.Add(new CuiPanel
			{
				Image =
				{
					Color = "0.0 0.0 0.0 0.95"
				},
				RectTransform =
				{
					AnchorMin = $"0.10 0.20",
					AnchorMax = $"0.90 0.90"
				},
				CursorEnabled = true
			}, "Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Close = KRUIName,
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.95 0.94",
					AnchorMax = "1.0 1.0"
				},
				Text =
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			KRUIelements.Add(KRUILabel("☠ Kill Records Top Players:", 1, height, TextAnchor.MiddleCenter, 15, "0.00", "0.90", "1.0 0.0 0.0 1.0"), KRUIName);
			// TotalKills Button
            KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Command = $"kr.totalkills {player.UserIDString}",
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.009 0.95",
					AnchorMax = "0.05 0.99"
				},
				Text =
				{
					Text = "◄＃",
					FontSize = 13,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleLeft
				}
			}, KRUIName);
			var t = "";
			var f = 0;
			var c = "0.0 0.0 0.0 0.0";
			if (!config.chatui.UseImageLibrary)
			{
				t = "웃";
				f = 25;
				c = "0.0 0.0 1.0 0.5";
			}
			int position;
			if (config.trackingoptions.Trackchicken)
			{
				position = config.orderoptions.chickenpos;
				string KillType = "chicken";		
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills chicken", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("chickenui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.chicken != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.chicken})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills chicken",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills chicken", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}		
			if (config.trackingoptions.Trackboar)
			{
				position = config.orderoptions.boarpos;
				string KillType = "boar";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills boar", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("boarui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.boar != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
					{
						Command = $"kr.topplayers {playerdata.displayname}",
						Color = $"{c}"
					},
						RectTransform =
					{
							AnchorMin = "0.30 0.40",
							AnchorMax = "0.70 0.75"
					},
						Text =
					{
						Text = $"{t}",
						FontSize = f,
						Color = "0.0 0.0 0.0",
						Align = TextAnchor.MiddleCenter
					}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.boar})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills boar",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills boar", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackstag)
			{
				position = config.orderoptions.stagpos;
				string KillType = "stag";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills stag", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("stagui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.stag != 0)
				{
					if (config.chatui.UseImageLibrary)
				{
					CuiRawImageComponent rawImage = new CuiRawImageComponent();
					if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
					}
					else
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
					}
					KRUIelements.Add(new CuiElement
					{
						Parent = KRUIMainName,
						Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
					});
				}

					KRUIelements.Add(new CuiButton
				{
					Button =
					{
						Command = $"kr.topplayers {playerdata.displayname}",
						Color = $"{c}"
					},
					RectTransform =
					{
							AnchorMin = "0.30 0.40",
							AnchorMax = "0.70 0.75"
					},
					Text =
					{
						Text = $"{t}",
						FontSize = f,
						Color = "0.0 0.0 0.0",
						Align = TextAnchor.MiddleCenter
					}
				}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.stag})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills stag",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills stag", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackwolf)
			{
				position = config.orderoptions.wolfpos;
				string KillType = "wolf";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills wolf", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("wolfui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.wolf != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.wolf})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills wolf",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills wolf", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackbear)
			{
				position = config.orderoptions.bearpos;
				string KillType = "bear";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills bear", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("bearui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.bear != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.bear})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills bear",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills bear", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}	
			if (config.trackingoptions.Trackpolarbear)
			{
				position = config.orderoptions.polarbearpos;
				string KillType = "polarbear";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills polarbear", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("polarbearui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.polarbear != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.polarbear})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills polarbear",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills polarbear", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}			
			if (config.trackingoptions.Trackshark)
			{
				position = config.orderoptions.sharkpos;
				string KillType = "shark";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills shark", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("sharkui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.shark != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.shark})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills shark",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills shark", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}				
			if (config.trackingoptions.Trackhorse)
			{
				position = config.orderoptions.horsepos;
				string KillType = "horse";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills horse", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("horseui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.horse != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.horse})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills horse",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills horse", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}			
			if (config.trackingoptions.Trackfish)
			{
				position = config.orderoptions.fishpos;
				string KillType = "fish";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills fish", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("fishui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.fish != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.fish})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills fish",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills fish", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.TrackPlayer)
			{
				position = config.orderoptions.playerpos;
				string KillType = "player";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills player", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("playerui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.baseplayer != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.baseplayer})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills player",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills player", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackscientist)
			{
				position = config.orderoptions.scientistpos;
				string KillType = "scientist";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills scientist", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("scientistui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.scientistnpcnew != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.scientistnpcnew})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills scientist",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills scientist", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackscarecrow)
			{
				position = config.orderoptions.scarecrowpos;
				string KillType = "scarecrow";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills scarecrow", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("scarecrowui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.scarecrow != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);
					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.scarecrow})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills scarecrow",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills scarecrow", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackdweller)
			{
				position = config.orderoptions.dwellerpos;
				string KillType = "dweller";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills dweller", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("dwellerui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.dweller != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.dweller})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills dweller",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills dweller", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Tracklootcontainer)
			{
				position = config.orderoptions.lootpos;
				string KillType = "loot";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills loot", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("lootui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.lootcontainer != 0)
				{
					if (config.chatui.UseImageLibrary)
				{
					CuiRawImageComponent rawImage = new CuiRawImageComponent();
					if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
					}
					else
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
					}
					KRUIelements.Add(new CuiElement
					{
						Parent = KRUIMainName,
						Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
					});
				}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.lootcontainer})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
							{
								Command = "kr.topkills loot",
								Color = "0.0 0.0 0.0 0.0"
							},
						RectTransform =
							{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
							},
						Text =
							{
								Text = "☠",
								FontSize = 30,
								Color = "1.0 0.0 0.0",
								Align = TextAnchor.MiddleCenter
							}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills loot", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackunderwaterlootcontainer)
			{
				position = config.orderoptions.unlootpos;
				string KillType = "underwaterloot";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills underwaterloot", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("wlootui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.underwaterlootcontainer != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.underwaterlootcontainer})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills underwaterloot",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills underwaterloot", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackbradhelicrate)
			{
				position = config.orderoptions.bradhelicratepos;
				string KillType = "bradhelicrate";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills bradhelicrate", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("bradheliui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.bradhelicrate != 0)
				{
					if (config.chatui.UseImageLibrary)
				{
					CuiRawImageComponent rawImage = new CuiRawImageComponent();
					if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
					}
					else
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
					}
					KRUIelements.Add(new CuiElement
					{
						Parent = KRUIMainName,
						Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
					});
				}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.bradhelicrate})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills bradhelicrate",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills bradhelicrate", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackhackablecrate)
			{
				position = config.orderoptions.hackablecratepos;
				string KillType = "hackablecrate";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills hackablecrate", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("hackableui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.hackablecrate != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.hackablecrate})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills hackablecrate",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills hackablecrate", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.TrackBradley)
			{
				position = config.orderoptions.bradleypos;
				string KillType = "bradleyapc";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills bradleyapc", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("bradleyui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.bradley != 0)
				{
					if (config.chatui.UseImageLibrary)
				{
					CuiRawImageComponent rawImage = new CuiRawImageComponent();
					if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
					}
					else
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
					}
					KRUIelements.Add(new CuiElement
					{
						Parent = KRUIMainName,
						Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
					});
				}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.bradley})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills bradleyapc",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills bradleyapc", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.TrackHeli)
			{
				position = config.orderoptions.helipos;
				string KillType = "patrolhelicopter";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills patrolhelicopter", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("patrolhelicopterui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.heli != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.heli})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills patrolhelicopter",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills patrolhelicopter", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackturret)
			{
				position = config.orderoptions.turretpos;
				string KillType = "turret";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills turret", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("turretui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.turret != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.turret})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills turret",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills turret", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Trackdeaths)
			{
				position = config.orderoptions.deathpos;
				string KillType = "death";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills death", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("deathui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.deaths != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.deaths})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills death",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills death", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.Tracksuicides)
			{
				position = config.orderoptions.suicidepos;
				string KillType = "suicide";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills suicide", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("suicideui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.suicides != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.suicides})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills suicide",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills suicide", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.TrackAnimalHarvest)
			{
				position = config.orderoptions.corpsepos;
				string KillType = "corpse";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills corpse", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("corpseui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.basecorpse != 0)
				{
					if (config.chatui.UseImageLibrary)
					{
						CuiRawImageComponent rawImage = new CuiRawImageComponent();
						if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
						}
						else
						{
							rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
						}
						KRUIelements.Add(new CuiElement
						{
							Parent = KRUIMainName,
							Components =
							{
								rawImage,
								new CuiRectTransformComponent
								{
									AnchorMin = "0.30 0.40",
									AnchorMax = "0.70 0.75"
								}
							}
						});
					}

					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = $"kr.topplayers {playerdata.displayname}",
							Color = $"{c}"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = $"{t}",
							FontSize = f,
							Color = "0.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.basecorpse})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills corpse",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills corpse", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
				//position++;
			}
			if (config.trackingoptions.TrackCorpseHarvest)
			{
				position = config.orderoptions.pcorpsepos;
				string KillType = "pcorpse";
				var vals = GetTopKills(0, 1, KillType);
				var playerdata = vals.ElementAtOrDefault(0);
				KRUIelements.Add(KRUIPanel($"{LeaderboardPositionLB(position)}", $"{LeaderboardPositionRT(position)}", "0.1 0.1 0.1 0.95"), KRUIName, KRUIMainName);
				KRUIelements.Add(KRUIButton("kr.topkills pcorpse", 1, 0.22f, 13, "0.0 0.0 0.0 0.5", $"〖{KRLang("pcorpseui", player.UserIDString)}〗", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				if (playerdata?.npcplayercorpse != 0)
				{
					if (config.chatui.UseImageLibrary)
				{
					CuiRawImageComponent rawImage = new CuiRawImageComponent();
					if ((bool)(ImageLibrary?.Call("HasImage", playerdata.id) ?? false))
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", playerdata.id);
					}
					else
					{
						rawImage.Png = (string)ImageLibrary?.Call("GetImage", null);
					}
					KRUIelements.Add(new CuiElement
					{
						Parent = KRUIMainName,
						Components =
						{
							rawImage,
							new CuiRectTransformComponent
							{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
							}
						}
					});
				}

					KRUIelements.Add(new CuiButton
				{
					Button =
					{
						Command = $"kr.topplayers {playerdata.displayname}",
						Color = $"{c}"
					},
					RectTransform =
					{
							AnchorMin = "0.30 0.40",
							AnchorMax = "0.70 0.75"
					},
					Text =
					{
						Text = $"{t}",
						FontSize = f,
						Color = "0.0 0.0 0.0",
						Align = TextAnchor.MiddleCenter
					}
				}, KRUIMainName);

					KRUIelements.Add(KRUIButton($"kr.topplayers {playerdata.displayname}", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", $"{playerdata.displayname}", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
					KRUIelements.Add(KRUILabel($"({playerdata.npcplayercorpse})", 6, 0.17f, TextAnchor.MiddleCenter, 10, "0.00", "0.99", "1.0 1.0 1.0 1.0"), KRUIMainName);
				}
				else
				{
					KRUIelements.Add(new CuiButton
					{
						Button =
						{
							Command = "kr.topkills pcorpse",
							Color = "0.0 0.0 0.0 0.0"
						},
						RectTransform =
						{
								AnchorMin = "0.30 0.40",
								AnchorMax = "0.70 0.75"
						},
						Text =
						{
							Text = "☠",
							FontSize = 30,
							Color = "1.0 0.0 0.0",
							Align = TextAnchor.MiddleCenter
						}
					}, KRUIMainName);

					KRUIelements.Add(KRUIButton("kr.topkills pcorpse", 5, 0.17f, 11, "0.0 0.0 0.0 0.5", "(No Top Player)", "0", "1", TextAnchor.MiddleCenter), KRUIMainName);
				}
			}
			CuiHelper.AddUi(player, KRUIelements);
			return;
		}
		private void KRUITotal(BasePlayer player)
		{
			var KRUIelements = new CuiElementContainer();
			var height = 0.041f;
			// Main UI
			KRUIelements.Add(new CuiPanel 
			{ 
				Image = 
				{ 
					Color = "0.0 0.0 0.0 0.9" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = $"0.83 0.27", 
					AnchorMax = $"0.997 0.95"
				}, 
				CursorEnabled = true 
			}, "Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton 
			{ 
				Button = 
				{ 
					Close = KRUIName, 
					Color = "0.0 0.0 0.0 0.0" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = "0.87 0.94", 
					AnchorMax = "1.0 1.002" 
				}, 
				Text = 
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter 
				} 
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("☠ Kill Records:", 1, 0.043f, TextAnchor.MiddleCenter, 17, "0.03", "0.85", "1.0 0.0 0.0 1.0"), KRUIName);
			// Leaderboard Button
			KRUIelements.Add(new CuiButton
			{
				Button =
				{
					Command = $"kr.leaderboard {player.UserIDString}",
					Color = "0.0 0.0 0.0 0.0"
				},
				RectTransform =
				{
					AnchorMin = "0.00 0.91",
					AnchorMax = "0.07 0.99"
				},
				Text =
				{
					Text = "⋘",
					FontSize = 23,
					Color = "0.0 0.0 1.0",
					Align = TextAnchor.MiddleCenter
				}
			}, KRUIName);
			// Inner UI
			KRUIelements.Add(KRUIPanel("0.04 0.02", "0.98 0.94"), KRUIName, KRUIMainName);
			KRUIelements.Add(KRUILabel($"{KRLang("totalkills", player.UserIDString)}", 1, height, TextAnchor.MiddleCenter, 17), KRUIMainName);
			KRUIelements.Add(KRUILabel(("﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int i = 2;
			
			if (config.trackingoptions.Trackchicken)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("chicken", player.UserIDString, GetTotalKills("chicken"))}"), config.orderoptions.chickenpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackboar) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("boar", player.UserIDString, GetTotalKills("boar"))}"), config.orderoptions.boarpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackstag) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("stag", player.UserIDString, GetTotalKills("stag"))}"), config.orderoptions.stagpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackwolf) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("wolf", player.UserIDString, GetTotalKills("wolf"))}"), config.orderoptions.wolfpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackbear) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bear", player.UserIDString, GetTotalKills("bear"))}"), config.orderoptions.bearpos + i, height), KRUIMainName);
			}

			if (config.trackingoptions.Trackpolarbear) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("polarbear", player.UserIDString, GetTotalKills("polarbear"))}"), config.orderoptions.polarbearpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackshark) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("simpleshark", player.UserIDString, GetTotalKills("shark"))}"), config.orderoptions.sharkpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackhorse) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("horse", player.UserIDString, GetTotalKills("horse"))}"), config.orderoptions.horsepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackfish) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("fish", player.UserIDString, GetTotalKills("fish"))}"), config.orderoptions.fishpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackscientist) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("scientists", player.UserIDString, GetTotalKills("scientist"))}"), config.orderoptions.scientistpos + i, height), KRUIMainName);
			}

			if (config.trackingoptions.Trackscarecrow) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("scarecrow", player.UserIDString, GetTotalKills("scarecrow"))}"), config.orderoptions.scarecrowpos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Trackdweller) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("dweller", player.UserIDString, GetTotalKills("dweller"))}"), config.orderoptions.dwellerpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackPlayer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("players", player.UserIDString, GetTotalKills("player"))}"), config.orderoptions.playerpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackdeaths) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("deaths", player.UserIDString, GetTotalKills("deaths"))}"), config.orderoptions.deathpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Tracksuicides) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("suicide", player.UserIDString, GetTotalKills("suicides"))}"), config.orderoptions.suicidepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.Tracklootcontainer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("loot", player.UserIDString, GetTotalKills("lootcontainer"))}"), config.orderoptions.lootpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackunderwaterlootcontainer) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("unloot", player.UserIDString, GetTotalKills("underwaterloot"))}"), config.orderoptions.unlootpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackbradhelicrate) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bradheliloot", player.UserIDString, GetTotalKills("bradhelicrate"))}"), config.orderoptions.bradhelicratepos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.Trackhackablecrate) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("hackloot", player.UserIDString, GetTotalKills("hackablecrate"))}"), config.orderoptions.hackablecratepos + i, height), KRUIMainName); 
			}
				
			if (config.trackingoptions.TrackBradley) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("bradley", player.UserIDString, GetTotalKills("bradleyapc"))}"), config.orderoptions.bradleypos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackHeli) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("heli", player.UserIDString, GetTotalKills("patrolhelicopter"))}"), config.orderoptions.helipos + i, height), KRUIMainName); 
			}

			if (config.trackingoptions.Trackturret) 
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("turret", player.UserIDString, GetTotalKills("turret"))}"), config.orderoptions.turretpos + i, height), KRUIMainName); 
			}
			
			if (config.trackingoptions.TrackAnimalHarvest)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("corpse", player.UserIDString, GetTotalKills("corpse"))}"), config.orderoptions.corpsepos + i, height), KRUIMainName);
			}
			
			if (config.trackingoptions.TrackCorpseHarvest)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("pcorpse", player.UserIDString, GetTotalKills("pcorpse"))}"), config.orderoptions.pcorpsepos + i, height), KRUIMainName);
			}
			
			CuiHelper.AddUi(player, KRUIelements);
			return;
		}
		private void KRUIStatsTotal(BasePlayer player)
		{
			var KRUIelements = new CuiElementContainer();
			var height = 0.043f;
			// Main UI
			KRUIelements.Add(new CuiPanel 
			{ 
				Image = 
				{ 
					Color = "0.0 0.0 0.0 0.9" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = $"0.83 0.27", 
					AnchorMax = $"0.997 0.95"
				}, 
				CursorEnabled = true 
			}, "Overlay", KRUIName);
			// Close Button
			KRUIelements.Add(new CuiButton 
			{ 
				Button = 
				{ 
					Close = KRUIName, 
					Color = "0.0 0.0 0.0 0.0" 
				}, 
				RectTransform = 
				{ 
					AnchorMin = "0.87 0.94", 
					AnchorMax = "1.0 1.002" 
				}, 
				Text = 
				{
					Text = "ⓧ",
					FontSize = 20,
					Color = "1.0 0.0 0.0",
					Align = TextAnchor.MiddleCenter 
				} 
			}, KRUIName);
			// Main UI Label
			KRUIelements.Add(KRUILabel("❀ Harvest Records:", 1, height, TextAnchor.MiddleCenter, 19, "0.03", "0.85", "0 1 0 1"), KRUIName);
			// Inner UI
			KRUIelements.Add(KRUIPanel("0.04 0.02", "0.98 0.94"), KRUIName, KRUIMainName);
			KRUIelements.Add(KRUILabel($"{KRLang("totalstats", player.UserIDString)}", 1, height, TextAnchor.MiddleCenter, 17), KRUIMainName);
			KRUIelements.Add(KRUILabel(("﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌"), 2, height, TextAnchor.MiddleCenter), KRUIMainName);
			int i = 3;		
			if (config.harvestoptions.treescut)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("treecut", player.UserIDString, GetTotalKills("trees"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.oremined)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("oremined", player.UserIDString, GetTotalKills("oremined"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.cactuscut)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("cactuscut", player.UserIDString, GetTotalKills("cactus"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.woodpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("woodpickup", player.UserIDString, GetTotalKills("wood"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.orepickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("orepickup", player.UserIDString, GetTotalKills("ore"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.berriespickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("berries", player.UserIDString, GetTotalKills("berries"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.seedpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("seeds", player.UserIDString, GetTotalKills("seeds"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.mushroompickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("mushroom", player.UserIDString, GetTotalKills("mushroom"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.cornpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("corn", player.UserIDString, GetTotalKills("corn"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.potatopickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("potato", player.UserIDString, GetTotalKills("potato"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.pumpkinpickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("pumpkin", player.UserIDString, GetTotalKills("pumpkin"))}"), i, height), KRUIMainName);
				i++;
			}
			if (config.harvestoptions.hemppickup)
			{
				KRUIelements.Add(KRUILabel(($"{KRLang("hemp", player.UserIDString, GetTotalKills("hemp"))}"), i, height), KRUIMainName);
			}			
			CuiHelper.AddUi(player, KRUIelements);
			return;
		}
		private void DestroyUi(BasePlayer player, string name)
		{
			CuiHelper.DestroyUi(player, name);
		}
		#endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
	        lang.RegisterMessages(new Dictionary<string, string>
	        {
		        ["players"] = "Players: {0}",
				["noplayer"] = "Kill Records:\n No player found with: {0}",
				["chicken"] = "Chickens: {0}",
				["boar"] = "Boars: {0}",
				["stag"] = "Stags: {0}",
				["wolf"] = "Wolves: {0}",
				["bear"] = "Bears: {0}",
				["polarbear"] = "PolarBears: {0}",
				["simpleshark"] = "Sharks: {0}",
				["horse"] = "Horses: {0}",
				["fish"] = "Fish: {0}",
				["treecut"] = "Trees: {0}",
				["oremined"] = "Ore Mined: {0}",
				["cactuscut"] = "Cactus Cut: {0}",
				["woodpickup"] = "Wood Pickup: {0}",
				["orepickup"] = "Ore Pickup: {0}",
				["berries"] = "Berries: {0}",
				["seeds"] = "Seeds: {0}",
				["mushroom"] = "Mushroom: {0}",
				["corn"] = "Corn: {0}",
				["potato"] = "Potato: {0}",
				["pumpkin"] = "Pumpkin: {0}",
				["hemp"] = "Hemp: {0}",
				["dweller"] = "Dwellers: {0}",
		        ["corpse"] = "Animals Harvested: {0}",
		        ["pcorpse"] = "Bodies Harvested: {0}",
		        ["zombie"] = "Zombies: {0}",
		        ["loot"] = "Loot Containers: {0}",
				["unloot"] = "Underwater Loot Containers: {0}",
				["bradheliloot"] = "Brad/Heli Crates: {0}",
				["hackloot"] = "Hackable Crates: {0}",
				["bradley"] = "Bradley: {0}",
				["heli"] = "Patrol Helicopter: {0}",
				["turret"] = "Turret: {0}",
				["bradleyapc"] = "Bradley: {0}",
				["patrolhelicopter"] = "Patrol Helicopter: {0}",
		        ["scientists"] = "Scientist: {0}",
		        ["scarecrow"] = "Scare Crow: {0}",
		        ["deaths"] = "Deaths: {0}",
		        ["suicide"] = "Suicides: {0}",
				["killchat"] = "Show chat kill messages {0}",
				["chickenui"] = "Chickens",
				["boarui"] = "Boars",
				["stagui"] = "Stags",
				["wolfui"] = "Wolves",
				["bearui"] = "Bears",
				["polarbearui"] = "PolarBears",
				["sharkui"] = "Sharks",
				["horseui"] = "Horses",
				["fishui"] = "Fish",
				["playerui"] = "Players",
				["scientistui"] = "Scientists",
				["scarecrowui"] = "Scare Crow",
				["zombieui"] = "Zombies",
				["dwellerui"] = "Dwellers",
				["deathui"] = "Deaths",
				["suicideui"] = "Suicides",
				["lootui"] = "Loot Containters",
				["wlootui"] = "Underwater Loots",
				["bradheliui"] = "Brad/Heli Crates",
				["hackableui"] = "Hackable Crates",
				["bradleyui"] = "Bradley",
				["turretui"] = "Turret",
				["treeui"] = "Trees",
				["oreminedui"] = "Ore Mined",
				["cactusui"] = "Cactus Cut",
				["woodui"] = "Wood Picked Up",
				["oreui"] = "Ore Picked Up",
				["mushroomui"] = "Mushrooms",
				["potatoui"] = "Potatos",
				["pumpkinui"] = "Pumpkins",
				["hempui"] = "Hemp",
				["berriesui"] = "Berries",
				["seedsui"] = "Seeds",
				["cornui"] = "Corn",
				["patrolhelicopterui"] = "Patrol Helicopter",
				["corpseui"] = "Animals Harvested",
				["pcorpseui"] = "Bodies Harvested",
		        ["webrequestgood"] = "Kill Record Data Sent to Website:",
		        ["webrequestbad"] = "Couldn't get an answer from Website!",
		        ["webrequestdisabled"] = "WebRequest Disabled - Enable in Config file",
				["totalkills"] = "Total Kills All Players",		
				["totalstats"] = "Total Harvests All Players",		
				["sqlupdate"] = "Your records have been manually updated in the database",	
				["sqlcheck"] = "Your records have been checked and updated in database",	
				["sqlcheckall"] = "All players have been checked and updated in database",
				["datafilebackup"] = "Records have been manually saved to data file",
				["datafilenotinuse"] = "DataFile not in use, config is set to SQL only",
				["resetkills"] = "All Kill Records have been reset and plugin reloaded",
				["KRHelp"] = 
					"Kill Records by MACHIN3 \n" +
					"/pkills - Open Kill Records UI \n" +
					"/pkillschat - Show kill Records in chat \n" +
					"/pkills (playername) - Open players Kill Records UI \n" +
					"/pkillschat (playername) - Show players Kill Records in chat \n" +
					"/topkills - Open top players UI \n" +
					"/topkillschat (type) - Show top players list in chat \n" +
					"/leadkills - Opens leaderboards UI \n" +
                    "/totalkills - Show global kill count for all entities \n" +
                    "/totalkillschat - Show global kill count in chat \n" +
					"/killchat true/false - Enable/Disable Kill messages",
				["KRHelpadmin"] =
					"Kill Records by MACHIN3 \n" +
					"/krbackup - Manually saves records to datafile \n" +
					"/krweb - Manually sends records over webrequest if webrequest enabled \n" +
					"/krsql update - Manually updates your records to SQL if SQL enabled \n" +
					"/krsql check - Checks SQL to see if your records exist, if not will create if SQL enabled \n" +
					"/krsql checkall - Checks SQL to see if all records exist, if not will create if SQL enabled \n" +
					"/resetkillrecords - Clears all kill record data for all players"

			}, this);
        }
        private string KRLang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
		#endregion

		#region WebRequest
		private void SaveKillRecordWeb(BasePlayer player)
        {
	        if (config.webrequest.UseWebrequests)
	        {
				// Get display name for regex
				Record record = GetRecord(player);
				// Remove special characters in names to prevent injection
		        string removespecials = "(['^$.|?*+()&{}\\\\])";
		        string replacename = "\\$1";
		        Regex rgx = new Regex(removespecials);
		        var playername = rgx.Replace(player.displayName, replacename);

				webrequest.Enqueue(
					$"{config.webrequest.DataURL}?" +
                    $"secretKey={config.webrequest.SecretKey}&" +
                    $"steamid={record.id}&" +
                    $"displayname={playername}&" +
                    $"chicken={record.chicken}&" +
                    $"boar={record.boar}&" +
                    $"wolf={record.wolf}&" +
                    $"stag={record.stag}&" +
                    $"bear={record.bear}&" +
                    $"polarbear={record.polarbear}&" +
                    $"shark={record.shark}&" +
                    $"horse={record.horse}&" +
                    $"fish={record.fish}&" +
                    $"scientist={record.scientistnpcnew}&" +
                    $"scarecrow={record.scarecrow}&" +
                    $"zombie={record.zombie}&" +
                    $"dweller={record.dweller}&" +
                    $"baseplayer={record.baseplayer}&" +
                    $"lootcontainer={record.lootcontainer}&" +
                    $"underwaterlootcontainer={record.underwaterlootcontainer}&" +
                    $"treescut={record.treescut}&" +
                    $"oremined={record.oremined}&" +
                    $"cactuscut={record.cactuscut}&" +
                    $"woodpickup={record.woodpickup}&" +
                    $"orepickup={record.orepickup}&" +
                    $"berriespickup={record.berriespickup}&" +
                    $"mushroompickup={record.mushroompickup}&" +
                    $"hemppickup={record.hemppickup}&" +
                    $"cornpickup={record.cornpickup}&" +
                    $"seedpickup={record.seedpickup}&" +
                    $"potatopickup={record.potatopickup}&" +
                    $"pumpkinpickup={record.pumpkinpickup}&" +
                    $"bradhelicrate={record.bradhelicrate}&" +
                    $"hackablecrate={record.hackablecrate}&" +
                    $"bradley={record.bradley}&" +
                    $"heli={record.heli}&" +
                    $"turret={record.turret}&" +
                    $"animalharvest={record.basecorpse}&" +
                    $"bodiesharvest={record.npcplayercorpse}&" +
                    $"deaths={record.deaths}&" +
                    $"suicides={record.suicides}"
					, null, (code, response) =>
		        {
			        if (code != 200 || response == null)
			        {
				        Puts($"Couldn't get an answer from Website!");
				        return;
			        }
			        Puts($"Kill Record Data Sent to Website: {response}");
		        }, this, RequestMethod.POST);
	        }
        }
		#endregion

		#region API
		private object GetKillRecord(string playerid, string KillType)
		{
			Record record;
			if (!_recordCache.TryGetValue(playerid, out record)) return 0;
			if (KillType == "chicken")
			{
				return record.chicken;
			}
			else if (KillType == "boar")
			{ 
				return record.boar;
			}
			else if (KillType == "stag")
			{ 
				return record.stag; 
			}
			else if (KillType == "wolf")
			{
				return record.wolf; 
			}
			else if (KillType == "bear")
			{ 
				return record.bear;
			}
			else if (KillType == "polarbear")
			{ 
				return record.polarbear;
			}
			else if (KillType == "shark")
			{ 
				return record.shark;
			}
			else if (KillType == "horse" || KillType == "ridablehorse")
			{ 
				return record.horse;
			}
			else if (KillType == "fish")
			{ 
				return record.fish;
			}
			else if (KillType == "scientistnpcnew" || KillType == "scientist") 
			{
				return record.scientistnpcnew;
			}
			else if (KillType == "scarecrow") 
			{
				return record.scarecrow;
			}
			else if (KillType == "zombie" || KillType == "zombienpc") 
			{
				return record.zombie;
			}
			else if (KillType == "dweller" || KillType == "tunneldweller" || KillType == "underwaterdweller") 
			{ 
				return record.dweller; 
			}
			else if (KillType == "baseplayer")
			{
				return record.baseplayer;
			}
			else if (KillType == "lootcontainer") 
			{ 
				return record.lootcontainer; 
			}
			else if (KillType == "underwaterlootcontainer") 
			{ 
				return record.underwaterlootcontainer; 
			}
			else if (KillType == "lockedbyentcrate") 
			{ 
				return record.bradhelicrate; 
			}
			else if (KillType == "hackablelockedcrate") 
			{ 
				return record.hackablecrate; 
			}
			else if (KillType == "bradleyapc") 
			{ 
				return record.bradley; 
			}
			else if (KillType == "patrolhelicopter") 
			{ 
				return record.heli; 
			}
			else if (KillType == "turret") 
			{ 
				return record.turret; 
			}
			else if (KillType == "basecorpse")
			{ 
				return record.basecorpse;
			}
			else if (KillType == "npcplayercorpse") 
			{
				return record.npcplayercorpse;
			}
			else if (KillType == "death")
			{
				return record.deaths;
			}
			else if (KillType == "suicide")
			{
				return record.suicides;
			}
			else if (KillType == "trees")
			{
				return record.treescut;
			}
			else if (KillType == "oremined")
			{
				return record.oremined;
			}
			else if (KillType == "catus")
			{
				return record.cactuscut;
			}
			else if (KillType == "wood")
			{
				return record.woodpickup;
			}
			else if (KillType == "orepickup")
			{
				return record.orepickup;
			}
			else if (KillType == "berries")
			{
				return record.berriespickup;
			}
			else if (KillType == "seed")
			{
				return record.seedpickup;
			}
			else if (KillType == "hemp")
			{
				return record.hemppickup;
			}
			else if (KillType == "potato")
			{
				return record.potatopickup;
			}
			else if (KillType == "pumpkin")
			{
				return record.pumpkinpickup;
			}
			else if (KillType == "mushroom")
			{
				return record.mushroompickup;
			}
			else if (KillType == "corn")
			{
				return record.cornpickup;
			}
			// Return all player data in Json if requested
			if (KillType == "all")
			{
				return JsonConvert.SerializeObject(record);
			}
			return 0;
		}
		private object GetCach()
		{
			return _recordCache;
		}
		private string GetVersion()
		{
			return version;
		}
		#endregion
	}
}

// --- End of file: KillRecords.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kdr-scoreboard ---
// --- Original File Path: K/KDRScoreboard/KDRScoreboard.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using System;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("KDR Scoreboard", "Ankawi", "1.0.2")]
    [Description("Enables scoreboards that can show Kills, Deaths, or K/D ratio")]
    class KDRScoreboard : RustPlugin
    {
        [PluginReference]
        Plugin Scoreboards;

        private static KDRScoreboard Instance;

        Dictionary<ulong, HitInfo> LastWounded = new Dictionary<ulong, HitInfo>();

        static HashSet<PlayerData> LoadedPlayerData = new HashSet<PlayerData>();

        #region Data
        class PlayerData
        {
            public ulong id;
            public string name;
            public int kills;
            public int deaths;
            internal float KDR => deaths == 0 ? kills : (float)Math.Round(((float)kills) / deaths, 1);

            internal static void TryLoad(BasePlayer player)
            {
                if (Find(player) != null)
                    return;

                PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"KDRScoreboard/{player.userID}");

                if (data == null || data.id == 0)
                {
                    data = new PlayerData
                    {
                        id = player.userID,
                        name = player.displayName
                    };
                }
                else
                    data.Update(player);

                data.Save();
                LoadedPlayerData.Add(data);
            }

            internal void Update(BasePlayer player)
            {
                name = player.displayName;
                Save();
            }

            internal void Save()
            {
                Instance.UpdateScoreboard();
                Interface.Oxide.DataFileSystem.WriteObject($"KDRScoreboard/{id}", this, true);
            }

            internal static PlayerData Find(BasePlayer player)
            {

                PlayerData data = LoadedPlayerData.ToList().Find((p) => p.id == player.userID);

                return data;
            }
        }
        #endregion

        #region Hooks
        void OnPlayerConnected(BasePlayer player)
        {
            PlayerData.TryLoad(player);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            PlayerData.TryLoad(player);
        }
        void OnServerInitialized()
        {
            if (!Scoreboards)
            {
                PrintWarning("The Scoreboard API must be enabled for this plugin to fully function, Get it here: https://umod.org/plugins/scoreboards");
            }

            Instance = this;

            foreach (var player in BasePlayer.activePlayerList)
            {
                PlayerData.TryLoad(player);
            }

            KDR_Scoreboard();
            KillsScoreboard();
            DeathsScoreboard();
        }
        HitInfo TryGetLastWounded(ulong id, HitInfo info)
        {
            if (LastWounded.ContainsKey(id))
            {
                HitInfo output = LastWounded[id];
                LastWounded.Remove(id);
                return output;
            }

            return info;
        }
        void OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player != null && info?.Initiator?.ToPlayer() != null)
            {
                NextTick(() =>
                {
                    if (player.IsWounded())
                        LastWounded[player.userID] = info;
                });
            }
        }
        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            try
            {
                if (player == info.Initiator) return;
                if (player == null || info.Initiator == null) return;

                if (player.IsWounded())
                {
                    info = TryGetLastWounded(player.userID, info);
                }
                if (info.Initiator is BasePlayer)
                {
                    PlayerData victimData = PlayerData.Find(player);
                    PlayerData attackerData = PlayerData.Find((BasePlayer)info.Initiator);

                    victimData.deaths++;
                    attackerData.kills++;

                    victimData.Save();
                    attackerData.Save();
                }
            }
            catch (Exception ex)
            {
            }
        }
        #endregion

        #region Scoreboards
        void KDR_Scoreboard()
        {
            Dictionary<string, string> topKdr = new Dictionary<string, string>();
            List<PlayerData> topKDRData = LoadedPlayerData.OrderByDescending(d => d.KDR).Take(15).ToList();

            foreach (var playerData in topKDRData)
                topKdr.Add(playerData.name, playerData.KDR.ToString());

            Scoreboards?.Call("CreateScoreboard", "K/D Ratio", "Lists the top KDRs", topKdr.ToArray<KeyValuePair<string, string>>());
        }
        void KillsScoreboard()
        {
            Dictionary<string, string> topKills = new Dictionary<string, string>();
            List<PlayerData> topKillsData = LoadedPlayerData.OrderByDescending(d => d.kills).Take(15).ToList();

            foreach (var playerData in topKillsData)
                topKills.Add(playerData.name, playerData.KDR.ToString());

            Scoreboards?.Call("CreateScoreboard", "Top Kills", "Lists the top Kills", topKills.ToArray<KeyValuePair<string, string>>());
        }
        void DeathsScoreboard()
        {
            Dictionary<string, string> topDeaths = new Dictionary<string, string>();
            List<PlayerData> topDeathsData = LoadedPlayerData.OrderByDescending(d => d.KDR).Take(15).ToList();

            foreach (var playerData in topDeathsData)
                topDeaths.Add(playerData.name, playerData.KDR.ToString());

            Scoreboards?.Call("CreateScoreboard", "Top Deaths", "Lists the top Deaths", topDeaths.ToArray<KeyValuePair<string, string>>());
        }

        void UpdateScoreboard()
        {
            Dictionary<string, string> topKdr = new Dictionary<string, string>();
            List<PlayerData> topKDRData = LoadedPlayerData.OrderByDescending(d => d.KDR).Take(15).ToList();
            foreach (var kdrData in topKDRData)
            {
                topKdr.Add(kdrData.name, kdrData.KDR.ToString("0.00"));
            }

            Dictionary<string, string> topKills = new Dictionary<string, string>();
            List<PlayerData> topKillsData = LoadedPlayerData.OrderByDescending(d => d.kills).Take(15).ToList();

            foreach(var killsData in topKillsData)
            {
                topKills.Add(killsData.name, killsData.kills.ToString());
            }

            Dictionary<string, string> topDeaths = new Dictionary<string, string>();
            List<PlayerData> topDeathsData = LoadedPlayerData.OrderByDescending(d => d.deaths).Take(15).ToList();
            foreach(var deathsData in topDeathsData)
            {
                topDeaths.Add(deathsData.name, deathsData.deaths.ToString());
            }
            Scoreboards?.Call("UpdateScoreboard", "K/D Ratio", topKdr.ToArray<KeyValuePair<string, string>>());
            Scoreboards?.Call("UpdateScoreboard", "Top Kills", topKills.ToArray<KeyValuePair<string, string>>());
            Scoreboards?.Call("UpdateScoreboard", "Top Deaths", topDeaths.ToArray<KeyValuePair<string, string>>());
        }
        #endregion

        #region Commands

        [ChatCommand("kdr")]
        void cmdKdr(BasePlayer player, string command, string[] args)
        {
            GetCurrentStats(player);
        }
        void GetCurrentStats(BasePlayer player)
        {
            PlayerData data = Interface.Oxide.DataFileSystem.ReadObject<PlayerData>($"KDRScoreboard/{player.userID}");
            int kills = data.kills;
            int deaths = data.deaths;
            string playerName = data.name;
            float kdr = data.KDR;

            PrintToChat(player, "<color=red> Player Name : </color>" + $"{playerName}"
                                        + "\n" + "<color=lime> Kills : </color>" + $"{kills}"
                                        + "\n" + "<color=lime> Deaths : </color>" + $"{deaths}"
                                        + "\n" + "<color=lime> K/D Ratio : </color>" + $"{kdr}");
        }
        #endregion
    }
}

// --- End of file: KDRScoreboard.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/karma-kills ---
// --- Original File Path: K/KarmaKills/KarmaKills.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Karma Kills", "Ryan", "1.0.3")]
    [Description("Rewards players on karma on kill, or takes karma away from them")]
    public class KarmaKills : RustPlugin
    {
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        [PluginReference] private Plugin KarmaSystem;

        #region Config

        private ConfigFile configFile;

        public class ConfigFile
        {
            public PlayerKills PlayerKills { get; set; }
            public AnimalKills AnimalKills { get; set; }
            public Killstreak Killstreak { get; set; }
            public Hero Hero { get; set; }
            public Bandit Bandit { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    PlayerKills = new PlayerKills()
                    {
                        Enabled = true,
                        AddKarma = new Karma()
                        {
                            Enabled = false,
                            Amount = 1
                        },
                        RemoveKarma = new Karma()
                        {
                            Enabled = true,
                            Amount = 1
                        }
                    },
                    AnimalKills = new AnimalKills()
                    {
                        Enabled = true,
                        AddKarma = new Karma()
                        {
                            Enabled = true,
                            Amount = 1
                        },
                        RemoveKarma = new Karma()
                        {
                            Enabled = false,
                            Amount = 1
                        }
                    },
                    Killstreak = new Killstreak()
                    {
                        Amount = 5
                    },
                    Hero = new Hero()
                    {
                        RemoveKarma = new Karma()
                        {
                            Amount = 2,
                            Enabled = true
                        }
                    },
                    Bandit = new Bandit()
                    {
                        AddKarma = new Karma()
                        {
                            Amount = 2,
                            Enabled = true
                        }
                    }
                };
            }
        }

        public class Killstreak
        {
            [JsonProperty(PropertyName = "Kills before a bounty is placed")]
            public int Amount { get; set; }
        }

        public class PlayerKills
        {
            public bool Enabled { get; set; }
            public Karma AddKarma { get; set; }
            public Karma RemoveKarma { get; set; }
        }

        public class AnimalKills
        {
            public bool Enabled { get; set; }
            public Karma AddKarma { get; set; }
            public Karma RemoveKarma { get; set; }
        }

        public class Karma
        {
            public bool Enabled { get; set; }
            public int Amount { get; set; }
        }

        public class Hero
        {
            [JsonProperty(PropertyName = "Remove Karma to killer of Hero")]
            public Karma RemoveKarma { get; set; }
        }

        public class Bandit
        {
            [JsonProperty(PropertyName = "Add Karma to killer of Bandit")]
            public Karma AddKarma { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            configFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configFile = Config.ReadObject<ConfigFile>();
        }

        protected override void SaveConfig() => Config.WriteObject(configFile);

        #endregion Config

        #region Data

        private static StoredData storedData;

        public class StoredData
        {
            public Dictionary<ulong, int> Killstreaks = new Dictionary<ulong, int>();
            public List<ulong> Heroes = new List<ulong>();
            public List<ulong> Bandits = new List<ulong>();
        }

        public class Data
        {
            public class Killstreaks
            {
                public static void Add(BasePlayer player)
                {
                    if (!Exists(player))
                    {
                        storedData.Killstreaks.Add(player.userID, 0);
                        SaveData();
                    }
                }

                public static void Remove(BasePlayer player)
                {
                    if (Exists(player))
                    {
                        storedData.Killstreaks.Remove(player.userID);
                        SaveData();
                    }
                }

                public static bool Exists(BasePlayer player)
                {
                    if (storedData.Killstreaks.ContainsKey(player.userID))
                    {
                        return true;
                    }
                    return false;
                }

                public static void IncrementStreak(BasePlayer player)
                {
                    if (Exists(player))
                    {
                        storedData.Killstreaks[player.userID]++;
                        SaveData();
                    }
                }

                public static int GetStreak(BasePlayer player)
                {
                    if (Exists(player))
                    {
                        return storedData.Killstreaks[player.userID];
                    }
                    return 0;
                }
            }

            public class Heroes
            {
                public static void Add(BasePlayer player)
                {
                    if (!Exists(player))
                    {
                        storedData.Heroes.Add(player.userID);
                    }
                }

                public static void Remove(BasePlayer player)
                {
                    if (Exists(player))
                    {
                        storedData.Heroes.Remove(player.userID);
                        SaveData();
                    }
                }

                public static bool Exists(BasePlayer player)
                {
                    if (storedData.Heroes.Exists(x => x == player.userID))
                    {
                        return true;
                    }
                    return false;
                }
            }

            public class Bandits
            {
                public static void Add(BasePlayer player)
                {
                    if (!Exists(player))
                    {
                        storedData.Bandits.Add(player.userID);
                    }
                }

                public static void Remove(BasePlayer player)
                {
                    if (Exists(player))
                    {
                        storedData.Bandits.Remove(player.userID);
                        SaveData();
                    }
                }

                public static bool Exists(BasePlayer player)
                {
                    if (storedData.Bandits.Exists(x => x == player.userID))
                    {
                        return true;
                    }
                    return false;
                }
            }

            public static void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("KarmaKills", storedData);
        }

        #endregion Data

        #region Lang

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Add_PlayerKill"] =
                "You've been awarded <color=orange>{0}</color> Karma for killing player <color=orange>{1}</color>",
                ["Add_AnimalKill"] =
                "You've been awareded <color=orange>{0}</color> Karma for killing a <color=orange>{1}</color>",
                ["Remove_PlayerKill"] =
                "You have lost <color=orange>{0}</color> Karma for killing player <color=orange>{1}</color>",
                ["Remove_AnimalKill"] =
                "You have lost <color=orange>{0}</color> Karma for killing a <color=orange>{1}</color>",

                ["Chat_KillStreak"] =
                "<color=orange>{0}</color> is now on a <color=orange>{1}</color> killstreak, kill the Bandit for a <color=orange>{2} Karma reward.",
                ["Chat_Reward"] =
                "<color=orange>{0}</color> is now a Hero for killing a Bandit named <color=orange>{1}</color>, the Hero was rewarded <color=orange>{2}</color> Karma.",
                ["Chat_Punishment"] =
                "<color=orange>{0}</color> is now a Bandit for killing a Hero named <color=orange>{1}</color>, the Bandit has lost <color=orange>{2}</color> Karma.",

                ["Cmd_CurrentBandits"] = "The current Bandits online are \n{0}",
                ["Cmd_NoBandits"] = "There's currently no Bandits on the server",
                ["Cmd_CurrentHeroes"] = "The current Heroes online are \n{0}",
                ["Cmd_NoHeroes"] = "There's currently no Heroes on the server",
            }, this);
        }

        #endregion Lang

        #region Methods

        private void CheckStatus(BasePlayer player)
        {
            if (Data.Killstreaks.Exists(player))
            {
                if (Data.Killstreaks.GetStreak(player) > configFile.Killstreak.Amount)
                {
                    if (!Data.Bandits.Exists(player))
                    {
                        Data.Bandits.Add(player);
                        foreach (var target in BasePlayer.activePlayerList)
                            PrintToChat(player,
                                Lang("Chat_KillStreak", target.UserIDString, player.displayName,
                                    Data.Killstreaks.GetStreak(player)));
                    }
                }
            }
        }

        private bool WasBandit(BasePlayer player)
        {
            if (Data.Bandits.Exists(player))
            {
                return true;
            }
            return false;
        }

        private bool WasHero(BasePlayer player)
        {
            if (Data.Heroes.Exists(player))
            {
                return true;
            }
            return false;
        }

        private string GetAnimalName(string name)
        {
            if (name.Contains("bear"))
                return "Bear";
            if (name.Contains("boar"))
                return "Boar";
            if (name.Contains("chicken"))
                return "Chicken";
            if (name.Contains("horse"))
                return "Horse";
            if (name.Contains("stag"))
                return "Stag";
            if (name.Contains("wolf"))
                return "Wolf";
            return null;
        }

        #endregion Methods

        #region Hooks

        private void Loaded()
        {
            SaveConfig();
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            if (!KarmaSystem)
                PrintWarning("KarmaSystem is required for this plugin to function properly!");
            if (configFile.AnimalKills.AddKarma.Enabled && configFile.AnimalKills.RemoveKarma.Enabled)
                PrintWarning(
                    "It's not recommended to have 'AddKarma' AND 'RemoveKarma' enabled at the same time (AnimalKills)");
            if (configFile.PlayerKills.AddKarma.Enabled && configFile.PlayerKills.RemoveKarma.Enabled)
                PrintWarning(
                    "It's not recommended to have 'AddKarma' AND 'RemoveKarma' enabled at the same time (PlayerKills)");
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;

            var player = info.Initiator?.ToPlayer();
            var attacker = info.Initiator?.ToPlayer();

            if (player == null) return;
            if (attacker != null && attacker.userID == player.userID)
                return;

            if (entity.ToPlayer() != null)
            {
                if (configFile.PlayerKills.AddKarma.Enabled)
                {
                    KarmaSystem?.Call("AddKarma", covalence.Players.FindPlayerById(player.UserIDString),
                        configFile.PlayerKills.AddKarma.Amount);
                    PrintToChat(player,
                        Lang("Add_PlayerKill", player.UserIDString, configFile.PlayerKills.AddKarma.Amount,
                            entity.ToPlayer().displayName));
                }
                else
                {
                    KarmaSystem?.Call("RemoveKarma", covalence.Players.FindPlayerById(player.UserIDString),
                        configFile.PlayerKills.RemoveKarma.Amount);
                    PrintToChat(player,
                        Lang("Remove_PlayerKill", player.UserIDString, configFile.PlayerKills.RemoveKarma.Amount,
                            entity.ToPlayer().displayName));
                }

                if (Data.Killstreaks.Exists(player))
                {
                    Data.Killstreaks.IncrementStreak(player);
                    CheckStatus(player);
                }
                else
                    Data.Killstreaks.Add(player);

                if (Data.Killstreaks.Exists(entity.ToPlayer()))
                    Data.Killstreaks.Remove(player);

                if (WasBandit(entity.ToPlayer()) && configFile.Bandit.AddKarma.Enabled)
                {
                    foreach (var p in BasePlayer.activePlayerList)
                        PrintToChat(p,
                            Lang("Chat_Reward", player.UserIDString, player.displayName, entity.ToPlayer().displayName,
                                configFile.Bandit.AddKarma.Amount));

                    Data.Bandits.Remove(entity.ToPlayer());
                    Data.Heroes.Add(player);
                }
                else if (WasHero(entity.ToPlayer()) && configFile.Hero.RemoveKarma.Enabled)
                {
                    foreach (var p in BasePlayer.activePlayerList)
                        PrintToChat(p,
                            Lang("Chat_Punishment", player.UserIDString, player.displayName,
                                entity.ToPlayer().displayName, configFile.Hero.RemoveKarma.Amount));

                    Data.Heroes.Remove(entity.ToPlayer());
                    Data.Bandits.Add(player);
                }
            }
            else if (entity.name.ToLower().Contains("rust.ai"))
            {
                if (configFile.AnimalKills.AddKarma.Enabled)
                {
                    KarmaSystem?.Call("AddKarma", covalence.Players.FindPlayerById(player.UserIDString),
                        configFile.AnimalKills.AddKarma.Amount);
                    PrintToChat(player,
                        Lang("Add_AnimalKill", player.UserIDString, configFile.AnimalKills.AddKarma.Amount,
                            GetAnimalName(entity.name)));
                }
                if (configFile.AnimalKills.RemoveKarma.Enabled)
                {
                    KarmaSystem?.Call("RemoveKarma", covalence.Players.FindPlayerById(player.UserIDString),
                        configFile.AnimalKills.RemoveKarma.Amount);
                    PrintToChat(player,
                        Lang("Remove_AnimalKill", player.UserIDString, configFile.AnimalKills.RemoveKarma.Amount,
                            GetAnimalName(entity.name)));
                }
            }
        }

        [ChatCommand("bandits")]
        private void banditCmd(BasePlayer player, string command, string[] args)
        {
            var banditNames = new List<string>();

            foreach (var bandit in storedData.Bandits)
            {
                var banditPlayer = covalence.Players.FindPlayerById(bandit.ToString());
                if (banditPlayer.IsConnected)
                    banditNames.Add(banditPlayer.Name);
            }

            if (banditNames.Count > 0)
                PrintToChat(player,
                    Lang("Cmd_CurrentBandits", player.UserIDString, string.Join(",", banditNames.ToArray())));
            else
                PrintToChat(player, Lang("Cmd_NoBandits", player.UserIDString));
        }

        [ChatCommand("heroes")]
        private void heroCmd(BasePlayer player, string command, string[] args)
        {
            var heroNames = new List<string>();

            foreach (var hero in storedData.Bandits)
            {
                var heroPlayer = covalence.Players.FindPlayerById(hero.ToString());
                if (heroPlayer.IsConnected)
                    heroNames.Add(heroPlayer.Name);
            }

            if (heroNames.Count > 0)
                PrintToChat(player,
                    Lang("Cmd_CurrentHeroes", player.UserIDString, string.Join(",", heroNames.ToArray())));
            else
                PrintToChat(player, Lang("Cmd_NoHeroes", player.UserIDString));
        }

        #endregion Hooks
    }
}


// --- End of file: KarmaKills.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-feed ---
// --- Original File Path: K/KillFeed/KillFeed.cs ---

﻿using System.Collections.Generic;
using System.Collections;
using System.Text;
using System;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Newtonsoft.Json;
using UnityEngine;
using Network;
using Rust;

namespace Oxide.Plugins
{
    [Info("Kill Feed", "Tuntenfisch", "1.18")]
    [Description("Displays a basic Kill Feed on screen")]
    public class KillFeed : RustPlugin
    {
        #region Fields
        const float _screenAspectRatio = 9f / 16f;
        const float _height = 0.1f;
        const float _halfHeight = _height / 2f;

        static int _debugging;

        static bool useServerFileStorage;

        static char _formattingChar = '§';

        static List<string> debugLog;

        static GameObject _killFeedObject;

        static FileManager _fileManager;

        static Timer _timer;

        static Dictionary<ulong, KillFeedPlayer> _players;

        float width;
        float horizontalSpacing;
        float verticalSpacing;
        float fadeIn;
        float fadeOut;
        float destroyAfter;
        float iconHalfHeight;
        float iconHalfWidth;
        float halfWidth;

        int numberOfCharacters;
        int fontSize;

        bool outline;
        bool removeTags;
        bool removeSpecialCharacters;
        bool enableAnimals;
        bool displayPlayerDeaths;
        bool logEntries;
        bool printEntriesToConsole;
        bool[] allowedCharacters;

        string chatIcon;
        string font;
        string formatting;

        Vector2 anchormin;
        Vector2 anchormax;

        CuiElementContainer[] entries;

        List<string> entryLog;
        #endregion

        #region Hooks
        /// <summary>
        /// Effectively, the entry point for this plugin.
        /// </summary>
        void OnServerInitialized()
        {
            // initialize _killFeedObject
            _killFeedObject = new GameObject();

            // initialize _fileManager
            _fileManager = _killFeedObject.AddComponent<FileManager>();

            // initialize _timer
            _timer = _killFeedObject.AddComponent<Timer>();

            // initialize allowedCharacters and populate initial allowedCharacters population
            allowedCharacters = new bool[65536];
            for (char c = '0'; c <= '9'; c++) allowedCharacters[c] = true;
            for (char c = 'A'; c <= 'Z'; c++) allowedCharacters[c] = true;
            for (char c = 'a'; c <= 'z'; c++) allowedCharacters[c] = true;

            LoadConfig();

            // initialize and populate _players
            _players = new Dictionary<ulong, KillFeedPlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                AddPlayer(player);
            }

            if (logEntries)
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/EntryLog"))
                {
                    entryLog = Interface.Oxide.DataFileSystem.ReadObject<List<string>>($"{Name}/EntryLog");        // either get existing entryLog or...
                }
                else
                {
                    entryLog = new List<string>();                                                                  // ...create a new entryLog if no existing entryLog is found
                }
            }
            if (_debugging == 2)
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/DebugLog"))
                {
                    debugLog = Interface.Oxide.DataFileSystem.ReadObject<List<string>>($"{Name}/DebugLog");        // either get existing debugLog or...
                }
                else
                {
                    debugLog = new List<string>();                                                                  // ...create a new debugLog if no existing debugLog is found
                }
            }
        }

        /// <summary>
        /// Makes sure that the plugin doesn't leave traces behind if the plugin is unloaded.
        /// </summary>
        void Unload()
        {
            if (entries != null)
            {
                DestroyUI(ConvertToSingleContainer(entries));
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                RemovePlayer(player);
            }

            if (logEntries && entryLog.Count > 0)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/EntryLog", entryLog);                          // save the entryLog to EntryLog.json if necessary
            }
            if (_debugging == 2 && debugLog.Count > 0)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/DebugLog", debugLog);                          // save the debugLog to DebugLog.json if necessary
            }

            UnityEngine.Object.Destroy(_killFeedObject);
        }

        /// <summary>
        /// Adds a new player to _players if one connects.
        /// </summary>
        /// <param name="player"> The player who connected.</param>
        void OnPlayerConnected(BasePlayer player)
        {
            AddPlayer(player);
        }

        /// <summary>
        /// Removes an existing player from the _players if he disconnects.
        /// </summary>
        /// <param name="player"> The <c>BasePlayer</c> instance which disconnected.</param>
        void OnPlayerDisconnected(BasePlayer player)
        {
            RemovePlayer(player);
        }

        /// <summary>
        /// The entry point for a new Kill Feed entry. Only encompasses players being wounded.
        /// </summary>
        /// <remarks>
        /// If <c>displayPlayerDeaths</c> is true, player deaths will be processed by <c>OnEntityDeath(BaseCombatEntity entity, HitInfo info)</c> instead.
        /// </remarks>
        /// <param name="player"> The player who was wounded.</param>
        /// <param name="info"> Contains information about the, in this case, wounding hit.</param>
        void CanBeWounded(BasePlayer player, HitInfo info)
        {
            if (displayPlayerDeaths) return;

            if (info == null) return;

            if (!enableAnimals && info.Initiator is BaseNpc) return;                                            // if animals are off and the initiator is an animal, return

            EntryData entryData = new EntryData(player, info);

            if (entryData.weaponInfo == null) return;

            OnWoundedOrDeath(entryData);
        }

        /// <summary>
        /// The second entry point for a new Kill Feed entry. Encompasses all entity deaths.
        /// </summary>
        /// <param name="entity"> The entity that died.</param>
        /// <param name="info"> Contains information about the, in this case, killing hit.</param>
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!enableAnimals && !displayPlayerDeaths) return;

            if (info == null) return;

            if (!enableAnimals && (info.Initiator is BaseNpc || entity is BaseNpc)) return;                     // if animals are off and either the initator or the entity is an animal, return
            if (!displayPlayerDeaths && entity.ToPlayer() != null) return;

            if (!(entity is BaseNpc) && !(entity is BaseHelicopter) && entity.ToPlayer() == null) return;       // if the entity isn't an animal, patrolhelicopter or player, return
            if ((info.Initiator is BaseNpc || info.Initiator is BaseHelicopter) && entity is BaseNpc) return;   // if the initator is either an animal or a patrolhelicopter and the entity is an animal, return
            if (entity is BaseNpc && (info.damageTypes?.GetMajorityDamageType() == DamageType.Hunger
                || info.damageTypes?.GetMajorityDamageType() == DamageType.Thirst)) return;                     // if an animal either died of hunger or of thirst, return

            EntryData entryData = new EntryData(entity, info);

            if (entryData.weaponInfo == null) return;

            OnWoundedOrDeath(entryData);
        }
        #endregion

        #region Commands
        /// <summary>
        /// Chat command for disabling, enabling the visual component of the plugin on a per player basis.
        /// </summary>
        /// <param name="player"> The player who used the command.</param>
        /// <param name="command"> The command that was entered.</param>
        /// <param name="args"> List of chat arguments trailing the initial command.</param>
        [ChatCommand("killfeed")]
        void ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)                                                                               // if no arguments are given, output additional information about possible arguments to the player
            {
                player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed", this));
            }
            else if (args[0].Equals("enable"))                                                                  // the player wants to enable the visual component of the plugin
            {
                KillFeedPlayer p;
                if (_players.TryGetValue(player.userID, out p))
                {
                    if (!p.enabled)
                    {
                        p.enabled = true;
                        AddUI(ConvertToSingleContainer(entries), p);

                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed enable > enabled", this));
                    }
                    else
                    {
                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed enable > already enabled", this));
                    }
                }
            }
            else if (args[0].Equals("disable"))                                                                 // the player wants to disable the visual component of the plugin
            {
                KillFeedPlayer p;
                if (_players.TryGetValue(player.userID, out p))
                {
                    if (p.enabled)
                    {
                        DestroyUI(ConvertToSingleContainer(entries), p);
                        p.enabled = false;

                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed disable > disabled", this));
                    }
                    else
                    {
                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed disable > already disabled", this));
                    }
                }
            }
            else if (args[0].Equals("status"))                                                                  // the player wants to know whether the visual component of the plugin is enabled or disabled
            {
                KillFeedPlayer p;
                if (_players.TryGetValue(player.userID, out p))
                {
                    if (p.enabled)
                    {
                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed status > is enabled", this));
                    }
                    else
                    {
                        player.SendConsoleCommand("chat.add", chatIcon, lang.GetMessage("killfeed status > is disabled", this));
                    }
                }
            }
        }
        #endregion

        #region Config
        /// <summary>
        /// Provides the default values for each configuration file value for easy access.
        /// </summary>
        static class DefaultConfig
        {
            public static readonly Dictionary<string, ConfigValue> values = new Dictionary<string, ConfigValue>()
            {
                { "chatIcon",                   new ConfigValue("76561198263554080",                                                        "1. General", "1.1 chat icon") },
                { "font",                       new ConfigValue("robotocondensed-bold.ttf",                                                 "1. General", "1.2 Text", "1.2.1 font") },
                { "outline",                    new ConfigValue(false,                                                                      "1. General", "1.2 Text", "1.2.2 outline") },
                { "fontSize",                   new ConfigValue(18,                                                                         "1. General", "1.2 Text", "1.2.3 font size") },
                { "numberOfCharacters",         new ConfigValue(12,                                                                         "1. General", "1.2 Text", "1.2.4 number of characters") },
                { "removeSpecialCharacters",    new ConfigValue(true,                                                                       "1. General", "1.2 Text", "1.2.5 remove special characters") },
                { "removeTags",                 new ConfigValue(false,                                                                      "1. General", "1.2 Text", "1.2.6 remove tags") },
                { "enableAnimals",              new ConfigValue(true,                                                                       "1. General", "1.3 Eligible For Entry", "1.3.1 animals") },
                { "displayPlayerDeaths",        new ConfigValue(false,                                                                      "1. General", "1.3 Eligible For Entry", "1.3.2 player deaths") },
                { "logEntries",                 new ConfigValue(false,                                                                      "1. General", "1.4 Monitoring", "1.4.1 log entries") },
                { "printEntriesToConsole",      new ConfigValue(false,                                                                      "1. General", "1.4 Monitoring", "1.4.2 print entries to console") },
                { "debugging",                  new ConfigValue(0,                                                                          "1. General", "1.4 Monitoring", "1.4.3 debugging") },

                { "formatting",                 new ConfigValue("{initiator}§{hitBone}§{distance}§{hitEntity}",                             "2. Kill Feed", "2.1 formatting") },
                { "numberOfEntries",            new ConfigValue(3,                                                                          "2. Kill Feed", "2.2 number of entries") },
                { "destroyAfter",               new ConfigValue(30.0f,                                                                      "2. Kill Feed", "2.3 destroy after") },
                { "width",                      new ConfigValue(0.3f,                                                                       "2. Kill Feed", "2.4 Dimensions", "2.4.1 width") },
                { "iconHalfHeight",             new ConfigValue(0.35f,                                                                      "2. Kill Feed", "2.4 Dimensions", "2.4.2 icon half-height") },
                { "x",                          new ConfigValue(0.175f,                                                                     "2. Kill Feed", "2.5 Position", "2.5.1 x") },
                { "y",                          new ConfigValue(0.95f,                                                                      "2. Kill Feed", "2.5 Position", "2.5.2 y") },
                { "horizontal",                 new ConfigValue(0.0f,                                                                       "2. Kill Feed", "2.6 Spacing", "2.6.1 horizontal") },
                { "vertical",                   new ConfigValue(-0.005f,                                                                    "2. Kill Feed", "2.6 Spacing", "2.6.2 vertical") },
                { "in",                         new ConfigValue(0.0f,                                                                       "2. Kill Feed", "2.7 Fade", "2.7.1 in") },
                { "out",                        new ConfigValue(0.0f,                                                                       "2. Kill Feed", "2.7 Fade", "2.7.2 out") },
                { "initiator",                  new ConfigValue("#336699",                                                                  "2. Kill Feed", "2.8 Colors", "2.8.1 inititator") },
                { "info",                       new ConfigValue("#b38600",                                                                  "2. Kill Feed", "2.8 Colors", "2.8.2 info") },
                { "hitEntity",                  new ConfigValue("#800000",                                                                  "2. Kill Feed", "2.8 Colors", "2.8.3 hit entity") },
                { "npc",                        new ConfigValue("#267326",                                                                  "2. Kill Feed", "2.8 Colors", "2.8.4 npc") },

                { "useServerFileStorage",       new ConfigValue(true,                                                                       "3. Data", "3.1 use server file storage") },
                { "fileDirectory",              new ConfigValue("http://vignette1.wikia.nocookie.net/play-rust/images/",                    "3. Data", "3.2 file directory") },
                { "Files",                      new ConfigValue(GetDefaultFiles(),                                                          "3. Data", "3.3 Files") },
                { "DamageTypeFiles",            new ConfigValue(GetDefaultDamageTypeFiles(),                                                "3. Data", "3.4 Damagetype Files") },
                { "NPCNames",                   new ConfigValue(GetDefaultNPCNames(),                                                       "3. Data", "3.5 NPC Names") },
                { "BoneNames",                  new ConfigValue(GetDefaultBoneNames(),                                                      "3. Data", "3.6 Bone Names") },
                { "AllowedSpecialCharacters",   new ConfigValue(GetDefaultAllowedSpecialCharacters(),                                       "3. Data", "3.7 Allowed Special Characters") }
            };

            private static Dictionary<string, string> GetDefaultFiles()
            {
                Dictionary<string, string> files = new Dictionary<string, string>()
                {
                    { "autoturret", "f/f9/Auto_Turret_icon.png" },
                    { "axe.salvaged", "c/c9/Salvaged_Axe_icon.png" },
                    { "barricade.metal", "b/bb/Metal_Barricade_icon.png" },
                    { "barricade.wood", "e/e5/Wooden_Barricade_icon.png" },
                    { "barricade.woodwire", "7/7b/Barbed_Wooden_Barricade_icon.png" },
                    { "bone.club", "1/19/Bone_Club_icon.png" },
                    { "bow.hunting", "2/25/Hunting_Bow_icon.png" },
                    { "crossbow", "2/23/Crossbow_icon.png" },
                    { "explosive.satchel", "0/0b/Satchel_Charge_icon.png" },
                    { "explosive.timed", "6/6c/Timed_Explosive_Charge_icon.png" },
                    { "flamethrower", "5/55/Flame_Thrower_icon.png" },
                    { "flameturret", "f/f9/Flame_Turret_icon.png" },
                    { "gates.external.high.stone", "8/85/High_External_Stone_Gate_icon.png" },
                    { "gates.external.high.wood", "5/53/High_External_Wooden_Gate_icon.png" },
                    { "grenade.beancan", "b/be/Beancan_Grenade_icon.png" },
                    { "grenade.f1", "5/52/F1_Grenade_icon.png" },
                    { "guntrap", "http://i.imgur.com/10MOtwu.png" },
                    { "hammer.salvaged", "f/f8/Salvaged_Hammer_icon.png" },
                    { "hatchet", "0/06/Hatchet_icon.png" },
                    { "icepick.salvaged", "e/e1/Salvaged_Icepick_icon.png" },
                    { "knife.bone", "c/c7/Bone_Knife_icon.png" },
                    { "landmine", "8/83/Land_Mine_icon.png" },
                    { "lmg.m249", "c/c6/M249_icon.png" },
                    { "lock.code", "0/0c/Code_Lock_icon.png" },
                    { "longsword", "3/34/Longsword_icon.png" },
                    { "mace", "4/4d/Mace_icon.png" },
                    { "machete", "3/34/Machete_icon.png" },
                    { "pickaxe", "8/86/Pick_Axe_icon.png" },
                    { "pistol.eoka", "b/b5/Eoka_Pistol_icon.png" },
                    { "pistol.m92", "4/43/M92_Pistol_icon.png" },
                    { "pistol.python", "d/d4/Python_Revolver_icon.png" },
                    { "pistol.revolver", "5/58/Revolver_icon.png" },
                    { "pistol.semiauto", "6/6b/Semi-Automatic_Pistol_icon.png" },
                    { "rifle.ak", "d/d1/Assault_Rifle_icon.png" },
                    { "rifle.bolt", "5/55/Bolt_Action_Rifle_icon.png" },
                    { "rifle.lr300", "d/d9/LR-300_Assault_Rifle_icon.png" },
                    { "rifle.semiauto", "8/8d/Semi-Automatic_Rifle_icon.png" },
                    { "rock", "f/ff/Rock_icon.png" },
                    { "rocket.launcher", "0/06/Rocket_Launcher_icon.png" },
                    { "salvaged.cleaver", "7/7e/Salvaged_Cleaver_icon.png" },
                    { "salvaged.sword", "7/77/Salvaged_Sword_icon.png" },
                    { "shotgun.pump", "6/60/Pump_Shotgun_icon.png" },
                    { "shotgun.waterpipe", "1/1b/Waterpipe_Shotgun_icon.png" },
                    { "shotgun.double", "3/3f/Double_Barrel_Shotgun_icon.png" },
                    { "smg.2", "9/95/Custom_SMG_icon.png" },
                    { "smg.mp5", "c/c0/MP5A4_icon.png" },
                    { "smg.thompson", "4/4e/Thompson_icon.png" },
                    { "spear.stone", "0/0a/Stone_Spear_icon.png" },
                    { "spear.wooden", "f/f2/Wooden_Spear_icon.png" },
                    { "spikes.floor", "f/f7/Wooden_Floor_Spikes_icon.png" },
                    { "stone.pickaxe", "7/77/Stone_Pick_Axe_icon.png" },
                    { "stonehatchet", "9/9b/Stone_Hatchet_icon.png" },
                    { "surveycharge", "9/9a/Survey_Charge_icon.png" },
                    { "torch", "4/48/Torch_icon.png" },
                    { "trap.bear", "b/b0/Snap_Trap_icon.png" },
                    { "wall.external.high", "9/96/High_External_Wooden_Wall_icon.png" },
                    { "wall.external.high.stone", "b/b6/High_External_Stone_Wall_icon.png" }
                };
                return files;
            }

            private static Dictionary<string, string> GetDefaultDamageTypeFiles()
            {
                Dictionary<string, string> files = new Dictionary<string, string>()
                {
                    { "bite", "1/17/Bite_icon.png" },
                    { "bleeding", "e/e5/Bleeding_icon.png" },
                    { "blunt", "8/83/Blunt_icon.png" },
                    { "bullet", "5/5a/Bullet_icon.png" },
                    { "cold", "7/74/Freezing_icon.png" },
                    { "drowned", "8/81/Drowning_icon.png" },
                    { "electricShock", "a/af/Electric_icon.png" },
                    { "explosion", "5/50/Explosion_icon.png" },
                    { "fall", "f/ff/Fall_icon.png" },
                    { "generic", "b/be/Missing_icon.png" },
                    { "heat", "e/e4/Ignite_icon.png" },
                    { "hunger", "8/84/Hunger_icon.png" },
                    { "poison", "8/84/Poison_icon.png" },
                    { "radiation", "4/44/Radiation_icon.png" },
                    { "slash", "5/50/Slash_icon.png" },
                    { "stab", "3/3e/Stab_icon.png" },
                    { "suicide", "b/be/Missing_icon.png" },
                    { "thirst", "8/8e/Thirst_icon.png" }
                };
                return files;
            }

            private static Dictionary<string, string> GetDefaultNPCNames()
            {
                Dictionary<string, string> names = new Dictionary<string, string>()
                {
                    { "bear", "Bear" },
                    { "boar", "Boar" },
                    { "chicken", "Chicken" },
                    { "horse", "Horse" },
                    { "patrolhelicopter", "Helicopter" },
                    { "stag", "Stag" },
                    { "wolf", "Wolf" }
                };
                return names;
            }

            private static Dictionary<string, string> GetDefaultBoneNames()
            {
                Dictionary<string, string> names = new Dictionary<string, string>()
                {
                    { "body", "Body" },
                    { "chest", "Chest" },
                    { "groin", "Groin" },
                    { "head", "Head" },
                    { "hip", "Hip" },
                    { "jaw", "Jaw" },
                    { "left arm", "Arm" },
                    { "left eye", "Eye" },
                    { "left foot", "Foot" },
                    { "left forearm", "Forearm" },
                    { "left hand", "Hand" },
                    { "left knee", "Knee" },
                    { "left ring finger", "Finger" },
                    { "left shoulder", "Shoulder" },
                    { "left thumb", "Thumb" },
                    { "left toe", "Toe" },
                    { "left wrist", "Wrist" },
                    { "lower spine", "Spine" },
                    { "neck", "Neck" },
                    { "pelvis", "Pelvis" },
                    { "right arm", "Arm" },
                    { "right eye", "Eye" },
                    { "right foot", "Foot" },
                    { "right forearm", "Forearm" },
                    { "right hand", "Hand" },
                    { "right knee", "Knee" },
                    { "right ring finger", "Finger" },
                    { "right shoulder", "Shoulder" },
                    { "right thumb", "Thumb" },
                    { "right toe", "Toe" },
                    { "right wrist", "Wrist" },
                    { "stomach", "Stomach" }
                };
                return names;
            }

            private static List<char> GetDefaultAllowedSpecialCharacters()
            {
                List<char> characters = new List<char>
                {
                    '.',
                    ' ',
                    '[',
                    ']',
                    '(',
                    ')',
                    '<',
                    '>'
                };
                return characters;
            }
        }

        /// <summary>
        /// Wrapper for a config value.
        /// </summary>
        /// <remarks>
        /// Contains both, the config value and the corresponding path.
        /// </remarks>
        class ConfigValue
        {
            public object value { private set; get; }
            public string[] path { private set; get; }

            public ConfigValue(object value, params string[] path)
            {
                this.value = value;
                this.path = path;
            }
        }

        /// <summary>
        /// Responsible for getting a value from the configuration file.
        /// </summary>
        /// <typeparam name="T"> The type that should be returned.</typeparam>
        /// <param name="saveConfig"> Indicates whether the configuration file should be saved.</param>
        /// <param name="defaultValue"> The defaultValue that will be returned if the actual value cannot be found.</param>
        /// <param name="keys"> The keys pointing to the value which should be returned.</param>
        /// <returns> Returns either the defaultValue or the value of the configuration file associated with the provided keys.</returns>
        T GetConfig<T>(ref bool saveConfig, T defaultValue, params string[] keys)
        {
            object value = Config.Get(keys);

            // get the value associated with the provided keys and check if the value is valid
            if (!IsValueValid(value, defaultValue))
            {
                object[] objArray = new object[keys.Length + 1];
                for (int i = 0; i < keys.Length; i++)
                {
                    objArray[i] = keys[i];
                }
                objArray[keys.Length] = defaultValue;

                Config.Set(objArray);

                saveConfig = true;
                return defaultValue;
            }
            return JsonConvert.DeserializeObject<T>(JsonConvert.SerializeObject(value));
        }

        /// <summary>
        /// Overload function for getting a value from the configuration file.
        /// </summary>
        /// <typeparam name="T"> The type that should be returned.</typeparam>
        /// <param name="saveConfig"> Indicates whether the configuration file should be saved.</param>
        /// <param name="configValue"> Holds information both about the actual config value and the corresponding path.</param>
        /// <returns> Returns either the defaultValue or the value of the configuration file associated with the provided keys.</returns>
        T GetConfig<T>(ref bool saveConfig, ConfigValue configValue)
        {
            string[] keys = configValue.path;
            object defaultValue = configValue.value;

            return GetConfig(ref saveConfig, (T)defaultValue, keys);
        }

        /// <summary>
        /// Checks if a value is valid by comparing the types of two objects and checking if both objects are of the same type or not.
        /// </summary>
        /// <param name="value"> The value that needs to be checked for validity.</param>
        /// <param name="defaultValue"> The defaultValue which is used for checking if the value is valid.</param>
        /// <returns> A bool indicating whether the value is valid.</returns>
        bool IsValueValid(object value, object defaultValue)
        {
            if (value == null) return false;

            Type type = value.GetType();
            Type defaultType = defaultValue.GetType();

            if (type != defaultType && type != typeof(double) && defaultType != typeof(float))
            {
                if (type.IsGenericType && defaultType.IsGenericType)
                {
                    if (type.GetGenericTypeDefinition() != defaultType.GetGenericTypeDefinition())
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Checks whether the configuration file contains unused keys and removes them.
        /// </summary>
        void CleanupConfig()
        {
            List<string[]> paths = new List<string[]>();

            // iterate over the current configuration file to find all existing paths
            IEnumerator enumerator = Config.GetEnumerator();
            try
            {
                while (enumerator.MoveNext())
                {
                    KeyValuePair<string, object> pair = (KeyValuePair<string, object>)enumerator.Current;

                    if (pair.Value.GetType().IsGenericType && pair.Value.GetType().GetGenericTypeDefinition() == typeof(Dictionary<,>) && ((IDictionary)pair.Value).Count != 0)
                    {
                        Dictionary<string, object> dictionary = new Dictionary<string, object>();
                        foreach (DictionaryEntry entry in (IDictionary)pair.Value)
                        {
                            dictionary.Add((string)entry.Key, entry.Value);
                        }

                        foreach (KeyValuePair<string, object> pair2 in dictionary)
                        {
                            if (pair2.Value.GetType().IsGenericType && pair2.Value.GetType().GetGenericTypeDefinition() == typeof(Dictionary<,>) && ((IDictionary)pair.Value).Count != 0)
                            {
                                Dictionary<string, object> dictionary2 = new Dictionary<string, object>();
                                foreach (DictionaryEntry entry in (IDictionary)pair2.Value)
                                {
                                    dictionary2.Add((string)entry.Key, entry.Value);
                                }

                                foreach (KeyValuePair<string, object> pair3 in dictionary2)
                                {
                                    if (char.IsDigit(pair3.Key[0]) && pair3.Key[1].Equals('.') && char.IsDigit(pair3.Key[2]) && pair3.Key[3].Equals('.') && char.IsDigit(pair3.Key[4]))
                                    {
                                        paths.Add(new string[3] { pair.Key, pair2.Key, pair3.Key });
                                    }
                                    else
                                    {
                                        paths.Add(new string[2] { pair.Key, pair2.Key });
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                paths.Add(new string[2] { pair.Key, pair2.Key });
                            }
                        }
                    }
                    else
                    {
                        paths.Add(new string[1] { pair.Key });
                    }
                }
            }
            finally
            {
                ((IDisposable)enumerator).Dispose();
            }

            // iterate over the found paths and determine whether they are part of the default configuration
            foreach (string[] path in paths)
            {
                int index = -1;

                foreach (ConfigValue value in DefaultConfig.values.Values)
                {
                    if (path.Length != value.path.Length) continue;

                    for (int j = 0; j < path.Length; j++)
                    {
                        if (path[j].Equals(value.path[j]))
                        {
                            index = j > index ? j : index;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // if a path is not part of the default configuration remove it
                if (index < path.Length - 1)
                {
                    if (index == -1)
                    {
                        Config.Remove(path[index + 1]);
                    }
                    else
                    {
                        string[] strArray = new string[index + 1];
                        for (int j = 0; j < strArray.Length; j++)
                        {
                            strArray[j] = path[j];
                        }
                        ((Dictionary<string, object>)Config.Get(strArray)).Remove(path[index + 1]);
                    }
                }
            }
        }

        /// <summary>
        /// Responsible for creating a configuration file and populating it with the required default values.
        /// </summary>
        /// <remarks>
        /// This function is called automatically by oxide if no configuration file could be found.
        /// </remarks>
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating configuration file!");

            Config.Clear();

            foreach (ConfigValue value in DefaultConfig.values.Values)
            {
                object[] objArray = new object[value.path.Length + 1];
                for (int i = 0; i < value.path.Length; i++)
                {
                    objArray[i] = value.path[i];
                }
                objArray[value.path.Length] = value.value;

                Config.Set(objArray);
            }
            SaveConfig();
        }

        /// <summary>
        /// Responsible for loading the configuration file.
        /// </summary>
        new void LoadConfig()
        {
            Puts("Loading configuration file!");

            bool saveConfig = false;

            // 1. General
            chatIcon = GetConfig<string>(ref saveConfig, DefaultConfig.values["chatIcon"]);
            font = GetConfig<string>(ref saveConfig, DefaultConfig.values["font"]);
            outline = GetConfig<bool>(ref saveConfig, DefaultConfig.values["outline"]);
            fontSize = GetConfig<int>(ref saveConfig, DefaultConfig.values["fontSize"]);
            numberOfCharacters = GetConfig<int>(ref saveConfig, DefaultConfig.values["numberOfCharacters"]);
            removeSpecialCharacters = GetConfig<bool>(ref saveConfig, DefaultConfig.values["removeSpecialCharacters"]);
            removeTags = GetConfig<bool>(ref saveConfig, DefaultConfig.values["removeTags"]);
            enableAnimals = GetConfig<bool>(ref saveConfig, DefaultConfig.values["enableAnimals"]);
            displayPlayerDeaths = GetConfig<bool>(ref saveConfig, DefaultConfig.values["displayPlayerDeaths"]);
            logEntries = GetConfig<bool>(ref saveConfig, DefaultConfig.values["logEntries"]);
            printEntriesToConsole = GetConfig<bool>(ref saveConfig, DefaultConfig.values["printEntriesToConsole"]);
            _debugging = GetConfig<int>(ref saveConfig, DefaultConfig.values["debugging"]);

            // 2. Kill Feed
            formatting = GetConfig<string>(ref saveConfig, DefaultConfig.values["formatting"]);

            int numberOfEntries = GetConfig<int>(ref saveConfig, DefaultConfig.values["numberOfEntries"]);
            entries = new CuiElementContainer[numberOfEntries];

            width = GetConfig<float>(ref saveConfig, DefaultConfig.values["width"]);
            halfWidth = width / 2f;

            iconHalfHeight = GetConfig<float>(ref saveConfig, DefaultConfig.values["iconHalfHeight"]);
            iconHalfWidth = iconHalfHeight * _screenAspectRatio / (width / _height);

            destroyAfter = GetConfig<float>(ref saveConfig, DefaultConfig.values["destroyAfter"]);

            float x = GetConfig<float>(ref saveConfig, DefaultConfig.values["x"]);
            float y = GetConfig<float>(ref saveConfig, DefaultConfig.values["y"]);
            anchormin = new Vector2(x - halfWidth, y - _halfHeight);
            anchormax = new Vector2(x + halfWidth, y + _halfHeight);

            float xSpacing = GetConfig<float>(ref saveConfig, DefaultConfig.values["horizontal"]);
            if (xSpacing != 0.0f)
            {
                bool positive = xSpacing > 0.0f;
                horizontalSpacing = positive ? xSpacing + halfWidth : xSpacing - halfWidth;
            }
            else
            {
                horizontalSpacing = xSpacing;
            }

            float ySpacing = GetConfig<float>(ref saveConfig, DefaultConfig.values["vertical"]);
            if (ySpacing != 0.0f)
            {
                bool positive = ySpacing > 0.0f;
                verticalSpacing = positive ? ySpacing + _halfHeight : ySpacing - _halfHeight;
            }
            else
            {
                verticalSpacing = ySpacing;
            }

            fadeIn = GetConfig<float>(ref saveConfig, DefaultConfig.values["in"]);
            fadeOut = GetConfig<float>(ref saveConfig, DefaultConfig.values["out"]);
            EntryData._initiatorColor = GetConfig<string>(ref saveConfig, DefaultConfig.values["initiator"]);
            EntryData._infoColor = GetConfig<string>(ref saveConfig, DefaultConfig.values["info"]);
            EntryData._hitEntityColor = GetConfig<string>(ref saveConfig, DefaultConfig.values["hitEntity"]);
            EntryData._npcColor = GetConfig<string>(ref saveConfig, DefaultConfig.values["npc"]);

            // 3. Data
            useServerFileStorage = GetConfig<bool>(ref saveConfig, DefaultConfig.values["useServerFileStorage"]);

            FileManager.fileDirectory = GetConfig<string>(ref saveConfig, DefaultConfig.values["fileDirectory"]);

            FileManager.fileIDs.Clear();
            FileManager.Store(GetConfig<Dictionary<string, string>>(ref saveConfig, DefaultConfig.values["Files"]));
            FileManager.Store(GetConfig<Dictionary<string, string>>(ref saveConfig, DefaultConfig.values["DamageTypeFiles"]));

            EntryData._npcNames.Clear();
            EntryData._npcNames = GetConfig<Dictionary<string, string>>(ref saveConfig, DefaultConfig.values["NPCNames"]);

            EntryData._boneNames.Clear();
            EntryData._boneNames = GetConfig<Dictionary<string, string>>(ref saveConfig, DefaultConfig.values["BoneNames"]);

            foreach (char c in GetConfig<List<char>>(ref saveConfig, DefaultConfig.values["AllowedSpecialCharacters"]))
            {
                if (c == _formattingChar) continue;
                allowedCharacters[c] = true;
            }

            if (saveConfig)
            {
                CleanupConfig();

                PrintWarning("Updating configuration file!");

                SaveConfig();
            }
        }
        #endregion

        #region Lang
        /// <summary>
        /// Responsible for creating a language file and populating it with the required default values.
        /// </summary>
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "killfeed", "<color=red>[KillFeed]</color> /killfeed disable<color=red>|</color>enable<color=red>|</color>status" },
                { "killfeed enable > enabled", "<color=red>[KillFeed]</color> enabled!" },
                { "killfeed enable > already enabled", "<color=red>[KillFeed]</color> already enabled!" },
                { "killfeed disable > disabled", "<color=red>[KillFeed]</color> disabled!" },
                { "killfeed disable > already disabled", "<color=red>[KillFeed]</color> already disabled!" },
                { "killfeed status > is enabled", "<color=red>[KillFeed]</color> is enabled!" },
                { "killfeed status > is disabled", "<color=red>[KillFeed]</color> is disabled!" },
            }, this);
        }
        #endregion

        #region Helper
        /// <summary>
        /// Set of helper functions for modifying strings.
        /// </summary>
        static class StringHelper
        {
            /// <summary>
            /// Removes a tag infront of a string.
            /// </summary>
            /// <param name="str"> The string that contains the tag.</param>
            /// <returns> The string without the tag.</returns>
            public static string RemoveTag(string str)
            {
                if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                {
                    str = str.Substring(str.IndexOf("]") + 1).Trim();
                }
                return str;
            }

            /// <summary>
            /// Removes special characters from a string.
            /// </summary>
            /// <param name="str"> The string that should be modified.</param>
            /// <param name="allowedCharacters"> The characters that are allowed.</param>
            /// /// <param name="flag"> The flag indicates whether the characters provided are allowed characters (false) or banned characters (true).</param>
            /// <returns> The string with all non allowed characters removed.</returns>
            public static string RemoveSpecialCharacters(string str, bool[] characters, bool flag = false)
            {
                char[] buffer = new char[str.Length];
                int index = 0;
                foreach (char c in str)
                {
                    if (characters[c] ^ flag)
                    {
                        buffer[index] = c;
                        index++;
                    }
                }
                return new string(buffer, 0, index);
            }

            /// <summary>
            /// Trims a string to a defined size if the string is longer.
            /// </summary>
            /// <param name="str"> the string that should be trimmed.</param>
            /// <param name="size"> the maximum size of the string.</param>
            /// <returns> The string trimmed to the defined size.</returns>
            public static string TrimToSize(string str, int size)
            {
                if (str.Length > size)
                {
                    str = str.Substring(0, size);
                }
                return str;
            }
        }

        /// <summary>
        /// Wrapper for logging debug messages.
        /// </summary>
        /// <param name="args"> The debug messages which should be logged.</param>
        static void LogDebug(params string[] args)
        {
            if (_debugging != 1 && _debugging != 2) return;

            StringBuilder builder = new StringBuilder("{1}");
            for (int i = 0; i < args.Length; i++)
            {
                builder.Append(" ");
                builder.Append("{" + i + "}");
            }

            if (_debugging == 1)
            {
                Interface.Oxide.LogDebug(builder.ToString(), args);
            }
            else if (_debugging == 2)
            {
                debugLog.Add(string.Format(builder.ToString(), args));
            }
        }
        #endregion

        #region FileManager
        /// <summary>
        /// Responsible for storing the png files in the server's file storage and keeping track of them.
        /// </summary>
        class FileManager : MonoBehaviour
        {
            public static string fileDirectory;

            public static Dictionary<string, string> fileIDs = new Dictionary<string, string>();

            /// <summary>
            /// Stores a value inside the server's file storage.
            /// </summary>
            /// <param name="key"> The key that is used to keep track of the value.</param>
            /// <param name="value"> The value containing the url to the png file.</param>
            public static void Store(string key, string value)
            {
                StringBuilder url = new StringBuilder();
                if (value.StartsWith("file:///") || value.StartsWith("http://"))
                {
                    url.Append(value);
                }
                else
                {
                    url.Append(fileDirectory);
                    url.Append(value);
                }

                if (useServerFileStorage)
                {
                    _fileManager.StartCoroutine(WaitForRequest(key, url.ToString()));
                }
                else
                {
                    fileIDs[key] = url.ToString();
                }
            }

            /// <summary>
            /// Stores a list of value inside the server's file storage.
            /// </summary>
            /// <param name="files"> The list of values that should be stored. The list of keys is used to keep track of the values.</param>
            public static void Store(Dictionary<string, string> files)
            {
                foreach (KeyValuePair<string, string> pair in files)
                {
                    Store(pair.Key, pair.Value);
                }
            }

            /// <summary>
            /// Coroutine that waits for the url data to be loaded and stores it once it is loaded.
            /// </summary>
            /// <param name="shortname"> The shortname of a given item.</param>
            /// <param name="url"> The url that points to the data that should be stored.</param>
            /// <returns></returns>
            private static IEnumerator WaitForRequest(string shortname, string url)
            {
                WWW www = new WWW(url);

                yield return www;

                if (string.IsNullOrEmpty(www.error))
                {
                    fileIDs[shortname] = FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                }
                else
                {
                    LogDebug("[Kill Feed]", "[" + DateTime.Now.ToString("mm'/'HH'/'dd'/'MM'/'yyyy") + "]", "[WaitForRequest(...)]", shortname, url, www.error);
                }
            }
        }
        #endregion

        #region Timer
        /// <summary>
        /// Provides a basic timer for executing an action after a specified delay.
        /// </summary>
        class Timer : MonoBehaviour
        {
            bool isRunning;

            Coroutine instance;

            /// <summary>
            /// Functions as a wrapper for Unity coroutines.
            /// </summary>
            /// <param name = "action"> The action that should be executed.</param>
            /// <param name="delay"> The delay after which the action should be executed.</param>
            public void DelayedAction(Action action, float delay)
            {
                if (isRunning)
                {
                    StopCoroutine(instance);
                    isRunning = false;

                    instance = StartCoroutine(WaitForDelay(action, delay));
                }
                else
                {
                    instance = StartCoroutine(WaitForDelay(action, delay));
                }
            }

            /// <summary>
            /// Waits for a specified amount of time and exectues the specified action.
            /// </summary>
            /// <param name = "action"> The action that should be executed.</param>
            /// <param name="delay"> The delay after which the action should be executed.</param>
            /// <returns></returns>
            private IEnumerator WaitForDelay(Action action, float delay)
            {
                isRunning = true;

                yield return new WaitForSeconds(delay);

                action();
                isRunning = false;
            }
        }
        #endregion

        #region Key
        /// <summary>
        /// Wrapper for a keyboard or mouse key.
        /// </summary>
        class Key
        {
            public string key;
            public string action;
            public string defaultAction;
        }
        #endregion

        #region KillFeedPlayer
        /// <summary>
        /// Handles player related features on a per player basis, e.g. enabling/disabling the ui.
        /// </summary>
        class KillFeedPlayer
        {
            public bool enabled { get; set; } = true;

            public string username { get; private set; }
            public string lastAction { get; set; }

            public Connection connection { get; private set; }

            public KillFeedPlayer(Connection connection, string username)
            {
                this.username = username;
                this.connection = connection;
                this.lastAction = "";
            }
        }

        /// <summary>
        /// Formats a string/username.
        /// </summary>
        /// <param name="username"> The username that should be formatted.</param>
        /// <returns> The formatted username</returns>
        string FormatUsername(string username)
        {
            if (removeTags)
            {
                username = StringHelper.RemoveTag(username);
            }
            if (removeSpecialCharacters)
            {
                username = StringHelper.RemoveSpecialCharacters(username, allowedCharacters);
                username = StringHelper.TrimToSize(username, numberOfCharacters);
            }
            else
            {
                bool[] characters = new bool[65536];
                characters[_formattingChar] = true;
                username = StringHelper.RemoveSpecialCharacters(username, characters, true);
                username = StringHelper.TrimToSize(username, numberOfCharacters);
            }
            return username;
        }

        /// <summary>
        /// Adds a player to the _players dictionary.
        /// </summary>
        /// <param name="player"> The player that should be added.</param>
        void AddPlayer(BasePlayer player)
        {
            if (_players == null) return;

            string username = FormatUsername(player.displayName);

            _players[player.userID] = new KillFeedPlayer(player.net.connection, username);
        }

        /// <summary>
        /// Removes a player from the _players dictionary.
        /// </summary>
        /// <param name="player"> The player that should be removed.</param>
        void RemovePlayer(BasePlayer player)
        {
            if (_players == null) return;

            _players.Remove(player.userID);
        }
        #endregion

        #region Entry Setup
        class EntryData
        {
            #region Fields
            public static string _initiatorColor { private get; set; }
            public static string _infoColor { private get; set; }
            public static string _hitEntityColor { private get; set; }
            public static string _npcColor { private get; set; }

            public static Dictionary<string, string> _npcNames { get; set; } = new Dictionary<string, string>();
            public static Dictionary<string, string> _boneNames { get; set; } = new Dictionary<string, string>();

            public bool selfInflicted { get; private set; }
            public bool needsFormatting { get; private set; }

            public EntityInfo initiatorInfo { get; private set; }
            public EntityInfo hitEntityInfo { get; private set; }

            public string initiatorColor { get; private set; }
            public string hitEntityColor { get; private set; }

            public WeaponInfo weaponInfo { get; private set; }

            public string hitBone { get; private set; }
            public string distance { get; private set; }

            public string infoColor
            {
                get
                {
                    return _infoColor;
                }
            }
            #endregion

            /// <summary>
            /// Constructer that is used to generate the data that is needed for a new Kill Feed entry.
            /// </summary>
            /// <param name="entity"> The entity that either died or got wounded.</param>
            /// <param name="info"> Contains information about the killing or wounding hit.</param>
            public EntryData(BaseCombatEntity entity, HitInfo info)
            {
                initiatorInfo = GetInitiator(info);
                hitEntityInfo = GetHitEntity(entity);

                weaponInfo = GetWeapon(info);

                hitBone = GetHitBone(info);

                distance = GetDistance(entity, info);

                // determines the colors of the initiator and the hitEntity
                if (initiatorInfo.userID != 0)                                                                  // initiator is a player
                {
                    initiatorColor = _initiatorColor;
                }
                else                                                                                            // initiator is a npc
                {
                    initiatorColor = _npcColor;
                }

                if (hitEntityInfo.userID != 0)                                                                  // hitEntity is a player
                {
                    hitEntityColor = _hitEntityColor;
                }
                else                                                                                            // hitEntity is a npc
                {
                    hitEntityColor = _npcColor;
                }

                if (initiatorInfo.userID == hitEntityInfo.userID)
                {
                    selfInflicted = true;
                }

                if (selfInflicted)                                                                              // initiator and hitEntity are the same entity
                {
                    initiatorInfo.name = hitEntityInfo.name;
                    initiatorColor = hitEntityColor;
                }
            }

            /// <summary>
            /// Determines the name and the userID of the initiator.
            /// </summary>
            /// <param name="info"> Contains information about the initiator.</param>
            /// <returns> A instance that contains both the name and the userID of the initiator.</returns>
            EntityInfo GetInitiator(HitInfo info)
            {
                string name = "";
                ulong userID = 0;

                if (info.Initiator?.ToPlayer() != null)                                                         // initiator is player
                {
                    userID = info.Initiator.ToPlayer().userID;

                    KillFeedPlayer player;
                    if (_players.TryGetValue(info.Initiator.ToPlayer().userID, out player))
                    {
                        name = player.username;
                    }
                    else
                    {
                        needsFormatting = true;
                        name = info.Initiator.ToPlayer().displayName;
                    }
                }
                else if (info.WeaponPrefab != null && info.WeaponPrefab.name.Equals("rocket_heli"))             // initiator is patrolhelicopter
                {
                    if (!_npcNames.TryGetValue("patrolhelicopter", out name))
                    {
                        name = "patrolhelicopter";
                    }
                }
                else                                                                                            // initiator is npc
                {
                    string npcName = info.Initiator?.ShortPrefabName ?? "";
                    if (!_npcNames.TryGetValue(npcName, out name))
                    {
                        name = npcName;
                    }
                }
                return new EntityInfo(name, userID);
            }

            /// <summary>
            /// Determines the name and the userID of the entity that died or got wounded.
            /// </summary>
            /// <param name="entity"> The entity that died or got wounded.</param>
            /// <returns> A instance that contains both the name and the userID of the entity.</returns>
            EntityInfo GetHitEntity(BaseCombatEntity entity)
            {
                string name = "";
                ulong userID = 0;

                if (entity.ToPlayer() != null)                                                                  // hitEntity is player
                {
                    userID = entity.ToPlayer().userID;

                    KillFeedPlayer player;
                    if (_players.TryGetValue(entity.ToPlayer().userID, out player))
                    {
                        name = player.username;
                    }
                    else if (entity.ToPlayer().HasPlayerFlag(BasePlayer.PlayerFlags.Sleeping))                  // hitEntity (player) is sleeping and his name needs to be formatted
                    {
                        needsFormatting = true;
                        name = entity.ToPlayer().displayName;
                    }
                    else if (entity.ToPlayer().userID > 0L && entity.ToPlayer().userID < 76560000000000000L)    // hitEntity (player) is actually a npc and his name needs to be formatted
                    {
                        needsFormatting = true;
                        name = entity.ToPlayer().displayName;
                    }
                }
                else                                                                                            // hitEntity is npc
                {
                    string npcName = entity.ShortPrefabName ?? "";
                    if (npcName.Equals("patrolhelicopter"))
                    {
                        selfInflicted = true;
                    }
                    if (!_npcNames.TryGetValue(npcName, out name))
                    {
                        name = npcName;
                    }
                }
                return new EntityInfo(name, userID);
            }

            /// <summary>
            /// Used to store an entity's name and userID.
            /// </summary>
            public class EntityInfo
            {
                public string name { get; set; }
                public ulong userID { get; private set; }

                public EntityInfo(string name, ulong userID)
                {
                    this.name = name;
                    this.userID = userID;
                }
            }

            /// <summary>
            /// Determines the weapon that was used to deliver the killing or wounding hit and returns the shortname and id of that weapon.
            /// </summary>
            /// <remarks>
            /// The weapon id represents the id of the stored png file of that weapon's icon.
            /// </remarks>
            /// <param name="info"> Contains information about the killing or wounding hit.</param>
            /// <returns> A instance containing both the shortname and the id of a weapon</returns>
            WeaponInfo GetWeapon(HitInfo info)
            {
                string weaponID;

                string weapon = info.Weapon?.GetItem()?.info?.shortname;

                // special case handling if the traditional way of getting a weapons shortname doesn't return results.
                if (string.IsNullOrEmpty(weapon))
                {
                    if (info.WeaponPrefab != null)
                    {
                        if (info.WeaponPrefab.ShortPrefabName.Equals("axe_salvaged.entity")) weapon = "axe.salvaged";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("bone_club.entity")) weapon = "bone.club";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("explosive.satchel.deployed")) weapon = "explosive.satchel";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("explosive.timed.deployed")) weapon = "explosive.timed";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("flamethrower.entity")) weapon = "flamethrower";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("flameturret.deployed"))
                        {
                            weapon = "flameturret";
                            selfInflicted = true;
                        }
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("grenade.beancan.deployed")) weapon = "grenade.beancan";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("grenade.f1.deployed")) weapon = "grenade.f1";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("hammer_salvaged.entity")) weapon = "hammer.salvaged";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("hatchet.entity")) weapon = "hatchet";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("hatchet_pickaxe.entity")) weapon = "stone.pickaxe";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("icepick_salvaged.entity")) weapon = "icepick.salvaged";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("knife_bone.entity")) weapon = "knife.bone";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("landmine"))
                        {
                            weapon = "landmine";
                            selfInflicted = true;
                        }
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("longsword.entity")) weapon = "longsword";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("mace.entity")) weapon = "mace";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("machete.weapon")) weapon = "machete";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("pickaxe.entity")) weapon = "pickaxe";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("rock.entity")) weapon = "rock";
                        else if (info.WeaponPrefab.ShortPrefabName.Contains("rocket")) weapon = "rocket.launcher";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("salvaged_cleaver.entity")) weapon = "salvaged.cleaver";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("salvaged_sword.entity")) weapon = "salvaged.sword";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("spear_stone.entity")) weapon = "spear.stone";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("spear_wooden.entity")) weapon = "spear.wooden";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("stonehatchet.entity")) weapon = "stonehatchet";
                        else if (info.WeaponPrefab.ShortPrefabName.Equals("survey_charge.deployed")) weapon = "surveycharge";
                    }
                    else if (info.Initiator != null)
                    {
                        if (info.Initiator.ShortPrefabName.Equals("autoturret_deployed"))
                        {
                            weapon = "autoturret";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("beartrap"))
                        {
                            weapon = "trap.bear";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("barricade.metal"))
                        {
                            weapon = "barricade.metal";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("barricade.wood"))
                        {
                            weapon = "barricade.wood";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("barricade.woodwire"))
                        {
                            weapon = "barricade.woodwire";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("gates.external.high.stone"))
                        {
                            weapon = "gates.external.high.stone";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("gates.external.high.wood"))
                        {
                            weapon = "gates.external.high.wood";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("guntrap.deployed"))
                        {
                            weapon = "guntrap";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("lock.code")) weapon = "lock.code";
                        else if (info.Initiator.ShortPrefabName.Equals("spikes.floor"))
                        {
                            weapon = "spikes.floor";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("wall.external.high.stone"))
                        {
                            weapon = "wall.external.high.stone";
                            selfInflicted = true;
                        }
                        else if (info.Initiator.ShortPrefabName.Equals("wall.external.high.wood"))
                        {
                            weapon = "wall.external.high";
                            selfInflicted = true;
                        }
                    }
                }

                // mainly used for determining whether the killing or wounding hit was self inflicted or not.
                if (!selfInflicted && (string.IsNullOrEmpty(weapon) || !weapon.Equals("flamethrower")))
                {
                    switch (info.damageTypes.GetMajorityDamageType())
                    {
                        case DamageType.Bite:
                            if (string.IsNullOrEmpty(weapon)) weapon = "bite";
                            break;

                        case DamageType.Bleeding:
                            if (string.IsNullOrEmpty(weapon)) weapon = "bleeding";
                            selfInflicted = true;
                            break;

                        case DamageType.Blunt:
                            if (string.IsNullOrEmpty(weapon)) weapon = "blunt";
                            break;

                        case DamageType.Bullet:
                            if (string.IsNullOrEmpty(weapon)) weapon = "bullet";
                            break;

                        case DamageType.Cold:
                        case DamageType.ColdExposure:
                            if (string.IsNullOrEmpty(weapon)) weapon = "cold";
                            selfInflicted = true;
                            break;

                        case DamageType.Drowned:
                            if (string.IsNullOrEmpty(weapon)) weapon = "drowned";
                            selfInflicted = true;
                            break;

                        case DamageType.ElectricShock:
                            if (string.IsNullOrEmpty(weapon)) weapon = "electricShock";
                            selfInflicted = true;
                            break;

                        case DamageType.Explosion:
                            if (string.IsNullOrEmpty(weapon)) weapon = "explosion";
                            break;

                        case DamageType.Fall:
                            if (string.IsNullOrEmpty(weapon)) weapon = "fall";
                            selfInflicted = true;
                            break;

                        case DamageType.Generic:
                            if (string.IsNullOrEmpty(weapon)) weapon = "generic";
                            break;

                        case DamageType.Heat:
                            if (string.IsNullOrEmpty(weapon)) weapon = "heat";
                            selfInflicted = true;
                            break;

                        case DamageType.Hunger:
                            if (string.IsNullOrEmpty(weapon)) weapon = "hunger";
                            selfInflicted = true;
                            break;

                        case DamageType.Poison:
                            if (string.IsNullOrEmpty(weapon)) weapon = "poison";
                            selfInflicted = true;
                            break;

                        case DamageType.Radiation:
                        case DamageType.RadiationExposure:
                            if (string.IsNullOrEmpty(weapon)) weapon = "radiation";
                            selfInflicted = true;
                            break;

                        case DamageType.Slash:
                            if (string.IsNullOrEmpty(weapon)) weapon = "slash";
                            break;

                        case DamageType.Stab:
                            if (string.IsNullOrEmpty(weapon)) weapon = "stab";
                            break;

                        case DamageType.Suicide:
                            if (string.IsNullOrEmpty(weapon)) weapon = "suicide";
                            selfInflicted = true;
                            break;

                        case DamageType.Thirst:
                            if (string.IsNullOrEmpty(weapon)) weapon = "thirst";
                            selfInflicted = true;
                            break;
                    }
                }

                if (!string.IsNullOrEmpty(weapon) && FileManager.fileIDs.TryGetValue(weapon, out weaponID))
                {
                    return new WeaponInfo(weapon, weaponID);
                }
                return null;
            }

            /// <summary>
            /// Used to store a weapon's shortname and id.
            /// </summary>
            public class WeaponInfo
            {
                public string shortname { get; private set; }
                public string weaponID { get; private set; }

                public WeaponInfo(string shortname, string weaponID)
                {
                    this.shortname = shortname;
                    this.weaponID = weaponID;
                }
            }

            /// <summary>
            /// Gets the distance between the entity that got killed or wounded and the initiator right when the entity was killed or wounded.
            /// </summary>
            /// <param name="entity"> The entity that was killed or wounded.</param>
            /// <param name="info"> Contains information about the initiator.</param>
            /// <returns> The distance.</returns>
            string GetDistance(BaseCombatEntity entity, HitInfo info)
            {
                float distance = 0.0f;

                if (entity != null && info.Initiator != null)
                {
                    distance = Vector3.Distance(info.Initiator.transform.position, entity.transform.position);
                }
                return distance.ToString("0.0").Equals("0.0") ? "" : distance.ToString("0.0") + "m";
            }

            /// <summary>
            /// Gets the name of the bone that was hit.
            /// </summary>
            /// <param name="info"> Contains information about the bone that was hit.</param>
            /// <returns> The name of the bone.</returns>
            string GetHitBone(HitInfo info)
            {
                if (info.HitEntity == null || info.HitEntity.ToPlayer() == null) return "";

                string hitBone;

                BaseCombatEntity hitEntity = info.HitEntity as BaseCombatEntity;

                SkeletonProperties.BoneProperty boneProperty = hitEntity.skeletonProperties?.FindBone(info.HitBone);

                string bone = boneProperty?.name?.english ?? "";

                if (!_boneNames.TryGetValue(bone, out hitBone))
                {
                    hitBone = bone;
                }
                return hitBone;
            }
        }

        /// <summary>
        /// Creates a new Kill Feed entry formatted with the information provided through the parameters.
        /// </summary>
        /// <param name="entryData"> The data that is need for a new entry.</param>
        /// <returns> A list containing all UI elements.</returns>
        CuiElementContainer GetKillFeedEntry(EntryData entryData)
        {
            StringBuilder builder = new StringBuilder(formatting);
            builder.Replace("{initiator}", "<color=" + entryData.initiatorColor + ">" + entryData.initiatorInfo.name + "</color>");
            builder.Replace("{hitBone}", "<color=" + entryData.infoColor + ">" + entryData.hitBone + "</color>");
            builder.Replace("{distance}", "<color=" + entryData.infoColor + ">" + entryData.distance + "</color>");
            builder.Replace("{hitEntity}", "<color=" + entryData.hitEntityColor + ">" + (entryData.needsFormatting ? FormatUsername(entryData.hitEntityInfo.name) : entryData.hitEntityInfo.name) + "</color>");

            string[] splitStrings = builder.ToString().Split(new char[] { _formattingChar }, 4, StringSplitOptions.None);
            string[] stringElements = { "", "", "", "" };
            Array.Copy(splitStrings, stringElements, splitStrings.Length);

            CuiElementContainer container = new CuiElementContainer();

            #region feedEntryElement
            CuiElement feedEntryElement = new CuiElement
            {
                Name = "{0} feedEntry",
                Parent = "Hud",
                FadeOut = fadeOut,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = anchormin.x + " " + anchormin.y,
                            AnchorMax = anchormax.x + " " + anchormax.y
                        }
                    }
            };
            #endregion

            #region outerLeftHandElement
            CuiElement outerLeftHandElement = new CuiElement
            {
                Name = "{0} outerLeftHandString",
                Parent = "{0} feedEntry",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = stringElements[0],
                        Font = font,
                        FontSize = fontSize,
                        Align = TextAnchor.MiddleLeft,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0",
                        AnchorMax = 0.5f - iconHalfWidth + " 1.0"
                    }
                }
            };
            #endregion

            #region innerLeftHandElement
            CuiElement innerLeftHandElement = new CuiElement
            {
                Name = "{0} innerLeftHandString",
                Parent = "{0} feedEntry",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = stringElements[1],
                        Font = font,
                        FontSize = fontSize,
                        Align = TextAnchor.MiddleRight,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.0 0.0",
                        AnchorMax = 0.5f - iconHalfWidth + " 1.0"
                    }
                }
            };
            #endregion

            #region weaponElement
            CuiElement weaponElement = new CuiElement
            {
                Name = "{0} weapon",
                Parent = "{0} feedEntry",
                FadeOut = fadeOut
            };

            CuiRawImageComponent weaponRawImageComponent = new CuiRawImageComponent();
            weaponRawImageComponent.Sprite = "assets/content/textures/generic/fulltransparent.tga";
            if (useServerFileStorage) weaponRawImageComponent.Png = entryData.weaponInfo.weaponID;
            else weaponRawImageComponent.Url = entryData.weaponInfo.weaponID;
            weaponRawImageComponent.FadeIn = fadeIn;

            CuiRectTransformComponent weaponRectTransformComponent = new CuiRectTransformComponent();
            weaponRectTransformComponent.AnchorMin = 0.5f - iconHalfWidth + " " + (0.5f - iconHalfHeight);
            weaponRectTransformComponent.AnchorMax = 0.5f + iconHalfWidth + " " + (0.5f + iconHalfHeight);

            weaponElement.Components.Add(weaponRawImageComponent);
            weaponElement.Components.Add(weaponRectTransformComponent);
            #endregion

            #region outerRightHandElement
            CuiElement outerRightHandElement = new CuiElement
            {
                Name = "{0} outerRightHandString",
                Parent = "{0} feedEntry",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = stringElements[3],
                        Font = font,
                        FontSize = fontSize,
                        Align = TextAnchor.MiddleRight,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = 0.5f + iconHalfWidth + " 0.0",
                        AnchorMax = "1.0 1.0",
                    }
                }
            };
            #endregion

            #region innerRightHandElement
            CuiElement innerRightHandElement = new CuiElement
            {
                Name = "{0} innerRightHandString",
                Parent = "{0} feedEntry",
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = stringElements[2],
                        Font = font,
                        FontSize = fontSize,
                        Align = TextAnchor.MiddleLeft,
                        FadeIn = fadeIn,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = 0.5f + iconHalfWidth + " 0.0",
                        AnchorMax = "1.0 1.0",
                    }
                }
            };
            #endregion

            #region outline
            if (outline)
            {
                CuiOutlineComponent outlineComponent = new CuiOutlineComponent
                {
                    Distance = "1.0 1.0",
                    Color = "0.0 0.0 0.0 1.0"
                };
                outerLeftHandElement.Components.Add(outlineComponent);
                innerLeftHandElement.Components.Add(outlineComponent);
                outerRightHandElement.Components.Add(outlineComponent);
                innerRightHandElement.Components.Add(outlineComponent);
            }
            #endregion

            container.Add(feedEntryElement);
            container.Add(outerLeftHandElement);
            container.Add(innerLeftHandElement);
            container.Add(weaponElement);
            container.Add(outerRightHandElement);
            container.Add(innerRightHandElement);

            return container;
        }

        /// <summary>
        /// Handles moving of existing entries and the addition of new entries.
        /// </summary>
        /// <param name="entryData"> The data that is need for a new entry.</param>
        void OnWoundedOrDeath(EntryData entryData)
        {
            // move existing entries
            for (int i = entries.Length - 1; i > 0; i--)
            {
                if (entries[i - 1] == null) continue;

                CuiElementContainer container = entries[i - 1];

                foreach (CuiElement element in container)
                {
                    element.Name = element.Name.Replace("{" + (i - 1) + "}", "{" + i + "}");

                    if (element.Parent.Equals("Hud"))
                    {
                        CuiRectTransformComponent transform = (CuiRectTransformComponent)element.Components.Find(x => x.Type.Equals("RectTransform"));
                        transform.AnchorMin = (anchormin.x + horizontalSpacing * i) + " " + (anchormin.y + verticalSpacing * i);
                        transform.AnchorMax = (anchormax.x + horizontalSpacing * i) + " " + (anchormax.y + verticalSpacing * i);
                    }
                    else
                    {
                        element.Parent = element.Parent.Replace("{" + (i - 1) + "}", "{" + i + "}");
                    }
                }
                entries[i] = container;
            }

            // setup new entry
            entries[0] = GetKillFeedEntry(entryData);

            AddUI(ConvertToSingleContainer(entries));

            // handel delayed destroying of entries
            if (destroyAfter > 0.0f)
            {
                _timer.DelayedAction(() =>
                {
                    DestroyUI(ConvertToSingleContainer(entries));

                    for (int i = 0; i < entries.Length; i++)
                    {
                        entries[i] = null;
                    }
                }, destroyAfter);
            }

            if (logEntries || printEntriesToConsole)
            {
                int count = 30;

                object[] columns = new object[6];
                columns[0] = DateTime.Now.ToString("mm'/'HH'/'dd'/'MM'/'yyyy");
                columns[1] = entryData.initiatorInfo.name.PadRight(count);
                columns[2] = entryData.hitBone.PadRight(count);
                columns[3] = entryData.weaponInfo.shortname.PadRight(count);
                columns[4] = entryData.distance.PadRight(count);
                columns[5] = entryData.needsFormatting ? FormatUsername(entryData.hitEntityInfo.name) : entryData.hitEntityInfo.name;

                string entry = string.Format("[{0}] {1} {2} {3} {4} {5}", columns);

                if (printEntriesToConsole)
                {
                    Puts(entry);
                }
                if (logEntries)
                {
                    entryLog.Add(entry);
                }
            }
        }
        #endregion

        #region UI Wrapper
        /// <summary>
        /// Adds the specified UI elements to every player on the server.
        /// </summary>
        /// <param name = "elements"> The UI elements that should be added.</param>>
        static void AddUI(CuiElementContainer elements)
        {
            foreach (KillFeedPlayer player in _players.Values)
            {
                DestroyUI(elements, player);

                AddUI(elements, player);
            }
        }

        /// <summary>
        /// Adds the specified UI elements to one specific player.
        /// </summary>
        /// <param name = "elements"> The UI elements that should be added.</param>
        /// <param name="player"> That player that the UI elements should be added to.</param>
        static void AddUI(CuiElementContainer elements, KillFeedPlayer player)
        {
            if (player.connection == null || !player.enabled) return;

            CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(player.connection), null, "AddUI", elements.ToJson());
        }

        /// <summary>
        /// Destroys the specified UI elements for every player on the server.
        /// </summary>
        /// <param name = "elements"> The UI elements that should be destroyed.</param>
        static void DestroyUI(CuiElementContainer elements)
        {
            foreach (KillFeedPlayer player in _players.Values)
            {
                DestroyUI(elements, player);
            }
        }

        /// <summary>
        /// Destroys the specified UI elements for one specific player.
        /// </summary>
        /// <param name = "elements"> The UI elements that should be destroyed.</param>
        /// <param name="player"> The player that should have his UI elements destroyed.</param>
        static void DestroyUI(CuiElementContainer elements, KillFeedPlayer player)
        {
            if (player.connection == null || !player.enabled) return;

            foreach (CuiElement element in elements)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(player.connection), null, "DestroyUI", element.Name);
            }
        }

        /// <summary>
        /// Converts an array of containers into a single container.
        /// </summary>
        /// <param name="containers"> The container array that should be converted.</param>
        /// <returns> The container containing all elements of the container array.</returns>
        static CuiElementContainer ConvertToSingleContainer(CuiElementContainer[] containers)
        {
            CuiElementContainer elements = new CuiElementContainer();
            for (int i = 0; i < containers.Length; i++)
            {
                if (containers[i] == null) break;

                CuiElementContainer container = containers[i];

                foreach (CuiElement element in container)
                {
                    if (element == null) continue;

                    elements.Add(element);
                }
            }
            return elements;
        }
        #endregion
    }
}


// --- End of file: KillFeed.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/key-lock-raiding ---
// --- Original File Path: K/KeyLockRaiding/KeyLockRaiding.cs ---

﻿using Newtonsoft.Json;
using JetBrains.Annotations;

namespace Oxide.Plugins
{
    [Info("Key Lock Raiding", "birthdates", "1.0.2")]
    [Description("Bring back key lock guessing!")]
    public class KeyLockRaiding : RustPlugin
    {
        #region Hooks

        /// <summary>
        ///     When the server initializes, reset all key locks that have a bigger combination than <see cref="ConfigFile.MaxCombinations"/>
        /// </summary>
        [UsedImplicitly]
        private void OnServerInitialized()
        {
            var count = -1;
            var list = BaseNetworkable.serverEntities.entityList.Values;
            while (count++ < list.Count)
            {
                var keyLock = list[count] as KeyLock;
                if (keyLock == null || keyLock.keyCode < _config.MaxCombinations) continue;
                OnItemDeployed(null, null, keyLock);
            }
        }
        
        /// <summary>
        ///     When a <see cref="KeyLock"/> is deployed, reset it's combination to a random number between 0 & <see cref="ConfigFile.MaxCombinations"/>
        /// </summary>
        /// <param name="deployer">Person who placed the lock</param>
        /// <param name="entity">Parent</param>
        /// <param name="keyLock">Key lock</param>
        private void OnItemDeployed(Deployer deployer, BaseEntity entity, KeyLock keyLock)
        {
            keyLock.keyCode = Core.Random.Range(_config.MaxCombinations);
        }

        #endregion
        
        #region Configuration

        private ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Max Possible Combinations (Rust default is 100000)")]
            public int MaxCombinations { get; set; }
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    MaxCombinations = 100
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}

// --- End of file: KeyLockRaiding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-complement ---
// --- Original File Path: K/KillComplement/KillComplement.cs ---

using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Kill Complement", "ProCelle", "1.0.5")]
    [Description("Get health and reload your gun for killing another player")]
    public class KillComplement : RustPlugin
    {
        private PluginConfig config;
        void OnServerInitialized(bool initial)
        {
		config = Config.ReadObject<PluginConfig>();
        permission.RegisterPermission(USE, this);
        }     
        private const string USE = "killcomplement.use";           
        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            var starter = info?.InitiatorPlayer;
            var projectile = info.Weapon as BaseProjectile; 
            if (starter == null ||  projectile == null || player.userID.IsSteamId() == false || starter?.userID.IsSteamId() == false && !permission.UserHasPermission(player.UserIDString, USE))
            {
                return;
            }            
            starter.Heal(config.Heal);       
            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate(); 
            
            
        }
        private class PluginConfig
		{
			[JsonProperty("Healed ammoun on kill")] public float Heal { get; set; }
		}

		private PluginConfig GetDefaultConfig()
		{
			return new PluginConfig
			{
				Heal = 100f
			};
		}

		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}
        

    }



}

// --- End of file: KillComplement.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-info ---
// --- Original File Path: K/KillInfo/KillInfo.cs ---

﻿using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{

    [Info("Kill Info", "birthdates", "1.0", ResourceId = 0)]
	[Description("Kill and Wound Info")]
    public class KillInfo : RustPlugin
    {
		private bool Wounded_Info;
		private bool Killed_Info;
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating a new config...");
            Config["Wounded_Info"] = true;
            Config["Killed_Info"] = true;
        }

		void Init() {
			Wounded_Info = (bool)Config["Wounded_Info"];
			Killed_Info = (bool)Config["Killed_Info"];
		}

        protected override void LoadDefaultMessages() => lang.RegisterMessages(new Dictionary<string, string>
        {
                {"Wounded_Info","Wounded - You have wounded {0}."},
                {"Killed_Info", "Killed - You have killed {0} with a hit to the {1} and did a finishing damage of {2}."},
            }, this);

        void OnPlayerWound(BasePlayer player)
        {
           

            if (player != null)
            {
                
                if(player.lastAttacker != null) {
					BasePlayer attacker = player.lastAttacker.ToPlayer();
					if (Wounded_Info && attacker != null)
					{
						SendReply(attacker, lang.GetMessage("Wounded_Info",this,player.UserIDString),player.displayName);
					}
				}


            }
        }

        void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            BasePlayer attacker = null;
            if(player.lastAttacker != null) {
			    attacker = player.lastAttacker.ToPlayer();
			}
            
            if(Killed_Info && attacker != null)
            {
                SendReply(attacker, lang.GetMessage("Killed_Info", this,player.UserIDString), player.displayName,info.boneName,Math.Round(info.damageTypes.Total()));
            }


        }
    }
}

// --- End of file: KillInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-streaks ---
// --- Original File Path: K/KillStreaks/KillStreaks.cs ---

﻿using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.Linq;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Kill Streaks", "Default", "0.1.8")]
    [Description("Adds redeemable kilstreak rewards")]
    class KillStreaks : RustPlugin
    {
        [PluginReference]
        private Plugin Airstrike, Clans, Economics, EventManager, Friends, Kits, ServerRewards, AdvAirstrike, FancyDrop, ZoneManager;

        private Dictionary<ulong, int> cachedData = new Dictionary<ulong, int>();
		readonly DynamicConfigFile zdataFile = Interface.Oxide.DataFileSystem.GetFile("KillStreaks-Zones");
        private List<BaseHelicopter> activeHelis = new List<BaseHelicopter>();
        private List<ulong> aasGren = new List<ulong>();
        private List<ulong> sqGren = new List<ulong>();
        private List<ulong> naGren = new List<ulong>();
        private List<ulong> nuGren = new List<ulong>();
        private List<ulong> spGren = new List<ulong>();
        private List<ulong> asGren = new List<ulong>();
        private List<ulong> ssGren = new List<ulong>();
        private List<ulong> arGren = new List<ulong>();
        private List<ulong> heGren = new List<ulong>();
        private List<ulong> mrtdm = new List<ulong>();
        private List<ulong> turret = new List<ulong>();
		private List<AutoTurret> TurretList = new List<AutoTurret>();
		private List<string> zones = new List<string>();

        private Dictionary<ulong, StreakType> activeGrenades = new Dictionary<ulong, StreakType>();

        private Dictionary<int, StreakType> streakTypes = new Dictionary<int, StreakType>()
        {
            { 0, StreakType.None },
            { 1, StreakType.Airstrike },
            { 2, StreakType.SquadStrike },
            { 3, StreakType.Artillery },
            { 4, StreakType.Helicopter },
            { 5, StreakType.SupplyDrop },
            { 6, StreakType.AirstrikeGrenade },
            { 7, StreakType.SquadStrikeGrenade },
            { 8, StreakType.ArtilleryGrenade },
            { 9, StreakType.HelicopterGrenade },
            { 10, StreakType.Martyrdom },
            { 11, StreakType.TurretDrop },
            { 12, StreakType.Coins },
            { 13, StreakType.RP },
            { 14, StreakType.AdvAirstrike },
            { 15, StreakType.AdvAirstrikeGrenade },
            { 16, StreakType.SupplySignal },
            { 17, StreakType.AdvAirstrikeSquad },
            { 18, StreakType.AdvAirstrikeNapalm },
            { 19, StreakType.AdvAirstrikeNuke },
            { 20, StreakType.AdvAirstrikeSpectre },
            { 21, StreakType.AdvAirstrikeSquadGrenade },
            { 22, StreakType.AdvAirstrikeNapalmGrenade },
            { 23, StreakType.AdvAirstrikeNukeGrenade },
            { 24, StreakType.AdvAirstrikeSpectreGrenade },
            { 25, StreakType.KitOnly }
        };

        DataStorage data;
        Player_DataStorage pdata;
        private DynamicConfigFile KSData;
        private DynamicConfigFile KSPData;

        private static Vector2 warningPos = new Vector2(0.25f, 0.13f);
        private static Vector2 warningDim = new Vector2(0.5f, 0.12f);

        private readonly int triggerMask = LayerMask.GetMask("Trigger");
        private const string supplydrop_prefab = "assets/prefabs/misc/supply drop/supply_drop.prefab";

		private const string KillStreakPermission     = "killstreaks.allowed";

        #region oxide hooks

        void OnServerInitialized()
        {
            RegisterMessages();
            KSData = Interface.Oxide.DataFileSystem.GetFile("killstreak_data");
            KSPData = Interface.Oxide.DataFileSystem.GetFile("killstreak_player_data");
            LoadData();
            LoadVariables();
            CheckDependencies();
			permission.RegisterPermission(KillStreakPermission , this);
			SaveStreakData();
        }

        private void CheckDependencies()
        {
            if (Friends == null)
            {
                if (useFriendsAPI)
                {
                    PrintWarning($"FriendsAPI is not found! Disabling friends feature.");
                    useFriendsAPI = false;
                }
            }

            if (Clans == null)
            {
                if (useClans)
                {
                    PrintWarning($"Clans is not found! Disabling clans feature.");
                    useClans = false;
                }
            }
            if (Airstrike == null)
            {
                if (useAirstrike)
                {
                    PrintWarning($"Airstrike is not found! Disabling airstrike feature.");
                    useAirstrike = false;
                }
            }

            if (AdvAirstrike == null)
            {
                if (useAdvAirstrike)
                {
                    PrintWarning($"Advanced Airstrike is not found! Disabling advanced airstrike feature.");
                    useAirstrike = false;
                }
            }

            if (Economics == null)
            {
                PrintWarning("Economics is not found! Unable to issue Economics rewards.");
            }
            if (ServerRewards == null)
            {
                PrintWarning("ServerRewards is not found! Unable to issue RP rewards.");
            }

            if (PVPOnly && PeopleOnly)
            {
                PrintWarning("You can have either PVP Only or People Only, not Both, setting to People Only (That includes players and NPCs)");
                PVPOnly = false;
                PeopleOnly = true;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity == null || hitinfo == null || hitinfo?.Initiator == null) return;

            if (entity is BasePlayer && !((entity as BasePlayer).IsNpc))
                ProcessDeath((BasePlayer)entity, hitinfo);

			BasePlayer killer = hitinfo?.Initiator?.ToPlayer();

			if (killer == null || killer?.UserIDString == null) return;
			if ((usePermissions && !permission.UserHasPermission(killer?.UserIDString, KillStreakPermission))) return;

			// only zone check if set, there is a zone entry and ZoneManagers is loaded
			if (useZoneManager && zones.Count > 0 && ZoneManager != null)
			{
				bool       inZone = false;

				//Puts("count zones: " + zones.Count);
				foreach(string zs in zones)
				{
					if (String.IsNullOrWhiteSpace(zs))
						Puts("Empty Zone Multiplier name please check your json");
					else if ((bool)ZoneManager?.Call("isPlayerInZone",zs, killer))
					{
						inZone = true;
						//	Puts(zs);
						break;
					}
				}
				if (!inZone)
					return;  // not in a valid zone so no reward
			}

            if (entity is BaseHelicopter && activeHelis.Contains((BaseHelicopter)entity))
                activeHelis.Remove((BaseHelicopter)entity);

            if (!(hitinfo.Initiator is BasePlayer) || (hitinfo.Initiator as BasePlayer).IsNpc)
                return;  // NPC do not get killstreaks

            if (entity is BasePlayer && hitinfo.Initiator is BasePlayer &&
               (entity as BasePlayer).UserIDString == (hitinfo.Initiator as BasePlayer).UserIDString) // no credit for killing yourself
                return;

            if (PVPOnly && (!(entity is BasePlayer) || (entity as BasePlayer).IsNpc))
                return;  // If it is PVP and you kill is not an actual player it does not count

            if (entity is BasePlayer && !((entity as BasePlayer).IsNpc))  // process kill of player
                ProcessKill((BasePlayer)hitinfo.Initiator, (BasePlayer)entity);
            if (PeopleOnly && entity is BasePlayer && ((entity as BasePlayer).IsNpc))  // process kill of NPC
                ProcessKill((BasePlayer)hitinfo.Initiator, (BasePlayer)null);
            else if (!PVPOnly && !PeopleOnly)  // PVE process kill of non-players (NPC, Animals, Heli, CH47 and Bradley)
            {
                if ((entity is BasePlayer && (entity as BasePlayer).IsNpc) || // NPC
                     entity is BaseNpc || (!String.IsNullOrWhiteSpace(entity.name) && entity.name.Contains("assets/rust.ai/")) ||  // Animals
                     entity is BaseHelicopter || entity is CH47HelicopterAIController || entity is BradleyAPC // hard to kill entities
                   )
                    ProcessKill((BasePlayer)hitinfo.Initiator, (BasePlayer)null);
            }
        }

        void OnPlayerDisconnected(BasePlayer player) => ProcessDeath(player, null, true);

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!entity.name.Contains("grenade.smoke")) return;

			if ((player.UserIDString == null) || (usePermissions && !permission.UserHasPermission(player.UserIDString, KillStreakPermission))) return;

            if (activeGrenades.ContainsKey(player.userID))
            {
                //entity.CancelInvoke((entity as SupplySignal).Explode);
                entity.Invoke(entity.KillMessage, 10f);
                timer.Once(3, () =>
                {
                    //Effect.server.Run("assets/bundled/prefabs/fx/smoke_signal.prefab", entity, 0, new Vector3(), new Vector3());
                    Vector3 pos = entity.transform.position;
                    if (pos == null)
                        pos = player.transform.position;

                    switch (activeGrenades[player.userID])
                    {
                        case StreakType.AdvAirstrikeGrenade:
                            CallAdvAirstrike(pos,activeGrenades[player.userID]);
                            break;
                        case StreakType.AdvAirstrikeSquadGrenade:
                            CallAdvAirstrike(pos,activeGrenades[player.userID]);
                            break;
                        case StreakType.AdvAirstrikeNapalmGrenade:
                            CallAdvAirstrike(pos,activeGrenades[player.userID]);
                            break;
                        case StreakType.AdvAirstrikeNukeGrenade:
                            CallAdvAirstrike(pos,activeGrenades[player.userID]);
                            break;
                        case StreakType.AdvAirstrikeSpectreGrenade:
                            CallAdvAirstrike(pos,activeGrenades[player.userID]);
                            break;
                        case StreakType.AirstrikeGrenade:
                            CallAirstrike(pos);
                            break;
                        case StreakType.SquadStrikeGrenade:
                            CallAirstrike(pos, false);
                            break;
                        case StreakType.ArtilleryGrenade:
                            LaunchArtillery(pos);
                            break;
                        case StreakType.HelicopterGrenade:
                            CallHeli(pos, cachedData[player.userID], true);
                            break;
                        case StreakType.TurretDrop:
                            DropTurret(pos, player);
                            break;
                        default:
                            return;
                    }
                    activeGrenades.Remove(player.userID);
                });
            }
        }

        void Unload()
        {
            SaveData();
            KillHeli();
			KillTurret();
        }
        #endregion

        #region functions
        private bool HasPriv(BasePlayer player)
        {
            var hit = Physics.OverlapSphere(player.transform.position, 2f, triggerMask);
            foreach (var entity in hit)
            {
                BuildingPrivlidge privs = entity.GetComponentInParent<BuildingPrivlidge>();
                if (privs != null)
                    if (privs.IsAuthed(player)) return true;
            }
            return false;
        }

        private void ProcessKill(BasePlayer player, BasePlayer victim)
        {
            if (ignoreBuildPriv && HasPriv(player))
                return;
            if (useClans && victim != null && IsClanmate(player.UserIDString, victim.UserIDString))
                return;
            if (useFriendsAPI && victim != null && IsFriend(player.userID, victim.userID))
                return;
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                    if ((bool)isPlaying)
                        return;
            }
            if (!pdata.killStreakData.ContainsKey(player.userID))
                pdata.killStreakData.Add(player.userID, new KSPDATA() { Name = player.displayName, highestKS = 0 });

            if (!cachedData.ContainsKey(player.userID))
                cachedData.Add(player.userID, 0);

            cachedData[player.userID]++;

            if (cachedData[player.userID] > pdata.killStreakData[player.userID].highestKS)
                pdata.killStreakData[player.userID].highestKS = cachedData[player.userID];

            Deal(player, victim);
        }

        private void ProcessDeath(BasePlayer player, HitInfo info, bool disconnected = false)
        {
            if (cachedData.ContainsKey(player.userID))
            {
                if (!disconnected)
                    if (mrtdm.Contains(player.userID))
                        ChooseRandomExp(player.transform.position);

                ClearPlayerRewards(player);

                string deathType = lang.GetMessage("suic", this, player.UserIDString);
                if (disconnected)
                {
                    if (NoDisconnect)
                        return;
                    else
                        deathType = lang.GetMessage("disconnected", this, player.UserIDString);
                }
                else if (info != null)
                    deathType = GetDeathType(info.Initiator);

                if (broadcastEnd)
                    BroadcastToAll(lang.GetMessage("endstreak", this, player.UserIDString) + deathType, player.displayName);
            }
        }
        private void ClearPlayerRewards(BasePlayer player)
        {
            ulong ID = player.userID;
            if (aasGren.Contains(ID))   aasGren.Remove(ID);
            if (sqGren.Contains(ID))    sqGren.Remove(ID);
            if (naGren.Contains(ID))    naGren.Remove(ID);
            if (nuGren.Contains(ID))    nuGren.Remove(ID);
            if (spGren.Contains(ID))    spGren.Remove(ID);
            if (asGren.Contains(ID))    asGren.Remove(ID);
            if (ssGren.Contains(ID))    ssGren.Remove(ID);
            if (arGren.Contains(ID))    arGren.Remove(ID);
            if (heGren.Contains(ID))    heGren.Remove(ID);
            if (mrtdm.Contains(ID))     mrtdm.Remove(ID);
            if (turret.Contains(ID))    turret.Remove(ID);
            cachedData.Remove(ID);
        }
        public string GetDeathType(BaseEntity entity)
        {
            string deathtype = "";
            if (entity == null)
                return null;
            else if (entity.ToPlayer() != null) deathtype = entity.ToPlayer().displayName;
            else if (entity.name.Contains("patrolhelicopter.pr")) deathtype = lang.GetMessage("aheli", this);
            else if (entity.name.Contains("animals/")) deathtype = lang.GetMessage("aanim", this);
            else if (entity.name.Contains("beartrap.prefab")) deathtype = lang.GetMessage("abt", this);
            else if (entity.name.Contains("landmine.prefab")) deathtype = lang.GetMessage("aldm", this);
            else if (entity.name.Contains("spikes.floor.prefab")) deathtype = lang.GetMessage("flrsp", this);
            else if (entity.name.Contains("autoturret_deployed.prefab")) deathtype = lang.GetMessage("aturr", this);
            else if (entity.name.Contains("deployable/barricades") || entity.name.Contains("wall.external.high")) deathtype = lang.GetMessage("awall", this);
            return deathtype;
        }
        private void BroadcastToAll(string msg, string keyword) => PrintToChat(fontColor1 + keyword + " </color>" + fontColor2 + msg + "</color>");
        private void BroadcastToPlayer(BasePlayer player, string msg, string keyword) => SendReply(player, fontColor1 + keyword + " </color>" + fontColor2 + msg + "</color>");
        private void GUIToPlayer(BasePlayer player, string msg, string keyword) => KSUI.GetPlayer(player).UseUI(fontColor1 + keyword + " </color>" + fontColor2 + msg + "</color>", warningPos, warningDim, 20);
        private bool IsClanmate(string playerId, string friendId)
        {
            if (!Clans || !useClans) return false;
            if ((bool)Clans?.Call("IsMemberOrAlly", playerId, friendId))
                return true;
            return false;
        }
        private List<BasePlayer> FindNearbyFriends(BasePlayer player)
        {
            List<BaseEntity> nearbyPlayers = new List<BaseEntity>();
            List<BasePlayer> nearbyFriends = new List<BasePlayer>();
            Vis.Entities(player.transform.position, nearbyRadius, nearbyPlayers);
            foreach (var entry in nearbyPlayers)
                if (entry is BasePlayer)
                    if (entry != null)
                        if (IsClanmate(entry.ToPlayer().UserIDString, player.UserIDString) || IsFriend(entry.ToPlayer().userID, player.userID))
                            nearbyFriends.Add(entry.ToPlayer());
            if (nearbyFriends.Count > 0)
                return nearbyFriends;
            return null;
        }

        private bool IsFriend(ulong playerID, ulong friendID)
        {
            if (!Friends || !useFriendsAPI) return false;
            bool isFriend = (bool)Friends?.Call("IsFriend", playerID, friendID);
            return isFriend;
        }

        private Item GiveSmokeSignal()
        {
            var definition = ItemManager.FindItemDefinition("grenade.smoke");
            if (definition != null)
            {
                Item item = ItemManager.CreateByItemID((int)definition.itemid, 1);
                return item;
            }
            return null;
        }

        private Item GiveSupplySignal()
        {
            var definition = ItemManager.FindItemDefinition("supply.signal");
            if (definition != null)
            {
                Item item = ItemManager.CreateByItemID((int)definition.itemid, 1);
                return item;
            }
            return null;
        }
        #endregion

        #region punishments/prizes
        private void Deal(BasePlayer player, BasePlayer victim)
        {
            var count = cachedData[player.userID];
            if (data.killStreaks.ContainsKey(count))
            {
				string vict_name = victim?.displayName;
                string langKey = data.killStreaks[count].Message;
                if (broadcastMsg)
				{
                    if (showVictim && !string.IsNullOrEmpty(vict_name))
						BroadcastToAll(langKey + string.Format(lang.GetMessage("kill_mess_victim", this), count, vict_name), player.displayName);
					else
						BroadcastToAll(langKey + string.Format(lang.GetMessage("kill_message", this), count), player.displayName);
                }
				else
				{
					if (showVictim && !string.IsNullOrEmpty(vict_name))
						BroadcastToPlayer(player, player.displayName + langKey, string.Format(lang.GetMessage("kill_mess_victim", this, player.UserIDString), count, vict_name));
					else
						BroadcastToPlayer(player, player.displayName + langKey, string.Format(lang.GetMessage("kill_message", this, player.UserIDString), count));
				}
                string message = lang.GetMessage("attract", this);

                if (data.killStreaks[count].StreakType != StreakType.None)
                {

                    var streakType = data.killStreaks[count].StreakType;
                    var pos = player.transform.position;

					string kitname = data.killStreaks[count].KitName;
                    if (!string.IsNullOrEmpty(kitname) && kitname != "null" && Kits)
					{
						message = GiveKit(player, kitname, count);
						GUIToPlayer(player, message, lang.GetMessage("warning", this));
					}

					if (streakType != StreakType.KitOnly)
					{
						switch (streakType)
						{
							case StreakType.Airstrike:
								if (!Airstrike) return;
								CallAirstrike(pos);
								message = lang.GetMessage("asLaunch", this, player.UserIDString);
								break;
							case StreakType.SquadStrike:
								if (!Airstrike) return;
								CallAirstrike(pos, false);
								message = lang.GetMessage("ssLaunch", this, player.UserIDString);
								break;
							case StreakType.Artillery:
								LaunchArtillery(pos);
								message = lang.GetMessage("arLaunch", this, player.UserIDString);
								break;
							case StreakType.Helicopter:
								CallHeli(player.transform.position, count, false, player);
								message = lang.GetMessage("asLaunch", this, player.UserIDString);
								break;
							case StreakType.SupplyDrop:
								SendSupplyDrop(player, count);
								message = lang.GetMessage("sdLaunch", this, player.UserIDString);
								break;
							case StreakType.Martyrdom:
								SetMartyrdom(player);
								message = lang.GetMessage("mrtdmActive", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeGrenade:
								GiveRewardGrenade(player, StreakType.AdvAirstrikeGrenade);
								message = lang.GetMessage("aasGrenade", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeSquadGrenade:
								GiveRewardGrenade(player, StreakType.AdvAirstrikeSquadGrenade);
								message = lang.GetMessage("sqGrenade", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeNapalmGrenade:
								GiveRewardGrenade(player, StreakType.AdvAirstrikeNapalmGrenade);
								message = lang.GetMessage("naGrenade", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeNukeGrenade:
								GiveRewardGrenade(player, StreakType.AdvAirstrikeNukeGrenade);
								message = lang.GetMessage("nuGrenade", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeSpectreGrenade:
								GiveRewardGrenade(player, StreakType.AdvAirstrikeSpectreGrenade);
								message = lang.GetMessage("spGrenade", this, player.UserIDString);
								break;
							case StreakType.AirstrikeGrenade:
								GiveRewardGrenade(player, StreakType.AirstrikeGrenade);
								message = lang.GetMessage("asGrenade", this, player.UserIDString);
								break;
							case StreakType.SquadStrikeGrenade:
								GiveRewardGrenade(player, StreakType.SquadStrikeGrenade);
								message = lang.GetMessage("ssGrenade", this, player.UserIDString);
								break;
							case StreakType.ArtilleryGrenade:
								GiveRewardGrenade(player, StreakType.ArtilleryGrenade);
								message = lang.GetMessage("arGrenade", this, player.UserIDString);
								break;
							case StreakType.HelicopterGrenade:
								GiveRewardGrenade(player, StreakType.HelicopterGrenade);
								message = lang.GetMessage("heGrenade", this, player.UserIDString);
								break;
							case StreakType.TurretDrop:
								GiveRewardGrenade(player, StreakType.TurretDrop);
								message = lang.GetMessage("tuGrenade", this, player.UserIDString);
								break;
							case StreakType.Coins:
								if (!Economics) return;
								message = GiveEconomics(player, count);
								break;
							case StreakType.RP:
								if (!ServerRewards) return;
								message = GiveRP(player, count);
								break;
							case StreakType.AdvAirstrike:
								CallAdvAirstrike(pos,streakType);
								message = lang.GetMessage("aasLaunch", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeSquad:
								CallAdvAirstrike(pos,streakType);
								message = lang.GetMessage("sqLaunch", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeNapalm:
								CallAdvAirstrike(pos,streakType);
								message = lang.GetMessage("naLaunch", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeNuke:
								CallAdvAirstrike(pos,streakType);
								message = lang.GetMessage("nuLaunch", this, player.UserIDString);
								break;
							case StreakType.AdvAirstrikeSpectre:
								CallAdvAirstrike(pos,streakType);
								message = lang.GetMessage("spLaunce", this, player.UserIDString);
								break;
							case StreakType.SupplySignal:
								player.inventory.GiveItem(GiveSupplySignal());
								message = lang.GetMessage("sdSignal", this, player.UserIDString);
								break;
						}
						GUIToPlayer(player, message, lang.GetMessage("warning", this));
					}
					Effect.server.Run("assets/prefabs/npc/autoturret/effects/targetacquired.prefab", player.transform.position);
                }

            }
        }
        private void GiveRewardGrenade(BasePlayer player, StreakType type)
        {
            List<ulong> list = new List<ulong>();
            if (type == StreakType.ArtilleryGrenade) list = arGren;
            else if (type == StreakType.AdvAirstrikeGrenade) list = aasGren;
            else if (type == StreakType.AdvAirstrikeSquadGrenade) list = sqGren;
            else if (type == StreakType.AdvAirstrikeNapalmGrenade) list = naGren;
            else if (type == StreakType.AdvAirstrikeNukeGrenade) list = nuGren;
            else if (type == StreakType.AdvAirstrikeSpectreGrenade) list = spGren;
            else if (type == StreakType.AirstrikeGrenade) list = asGren;
            else if (type == StreakType.SquadStrikeGrenade) list = ssGren;
            else if (type == StreakType.HelicopterGrenade) list = heGren;
            else if (type == StreakType.TurretDrop) list = turret;
            player.inventory.GiveItem(GiveSmokeSignal());
            if (list != null) list.Add(player.userID);
        }

        #region airstrike
        private void CallAirstrike(Vector3 target, bool type = true)
        {
            if (Airstrike)
            {
                if (type) Airstrike?.Call("CallStrike", target);
                else Airstrike?.Call("CallSquad", target);
            }
            else Puts(lang.GetMessage("noAirstrike", this));
        }
        #endregion

        #region advairstrike
        private void CallAdvAirstrike(Vector3 target, StreakType type)
        {
            if (AdvAirstrike)
            {
                if (type == StreakType.AdvAirstrike ) AdvAirstrike?.Call("CallStrike", target);
                else if (type == StreakType.AdvAirstrikeSquad ) AdvAirstrike?.Call("CallSquad", target);
                else if (type == StreakType.AdvAirstrikeNapalm ) AdvAirstrike?.Call("CallNapalm", target);
                else if (type == StreakType.AdvAirstrikeNuke ) AdvAirstrike?.Call("CallNuke", target);
                else if (type == StreakType.AdvAirstrikeSpectre ) AdvAirstrike?.Call("CallSpectre", target);
				else Puts(lang.GetMessage("noAdvAirstrikeType", this));
            }
            else Puts(lang.GetMessage("noAdvAirstrike", this));
        }
        #endregion

        #region artillery
        private void LaunchArtillery(Vector3 target)
        {
            timer.Repeat(rocketInterval, rocketAmount, () => RocketSpread(target));
        }
        private void RocketSpread(Vector3 targetPos)
        {
            targetPos = Quaternion.Euler(UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f), UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f), UnityEngine.Random.Range((float)(-rocketSpread * 0.2), rocketSpread * 0.2f)) * targetPos;
            CreateRocket(targetPos);
        }
        private BaseEntity CreateRocket(Vector3 targetPos)
        {
            string fireRocket = "ammo.rocket.fire";
            string rocketType = "ammo.rocket.basic";
            var rocket = rocketType;
            int rand = UnityEngine.Random.Range(1, 7);
            if (rand == 1)
                rocket = fireRocket;

            var launchPos = targetPos + new Vector3(0, 200, 0);

            ItemDefinition projectileItem = ItemManager.FindItemDefinition(rocket);
            ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();

            BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, launchPos, new Quaternion(), true);

            TimedExplosive rocketExplosion = entity.GetComponent<TimedExplosive>();
            ServerProjectile rocketProjectile = entity.GetComponent<ServerProjectile>();

            rocketExplosion.timerAmountMin = 60;
            rocketExplosion.timerAmountMax = 60;

            Vector3 newDirection = (targetPos - launchPos);

            entity.SendMessage("InitializeVelocity", (newDirection));
            entity.Spawn();

            return null;
        }
        #endregion

        #region helicopters

        private int HeliDistance = 50;
        private static LayerMask GROUND_MASKS = LayerMask.GetMask("Terrain", "World", "Construction");

        private void CallHeli(Vector3 pos, int streaknum, bool onSmoke = false, BasePlayer player = null)
        {
            int amount = data.killStreaks[streaknum].Amount;
            int i = 0;
            while (i < amount)
            {
                BaseEntity entity = CreateHeli(pos);
                MoveEntity(entity, pos);
                if (!onSmoke)
                    if (player != null)
                        CheckDistance(entity, player);
                i++;
            }
        }
        private BaseEntity CreateHeli(Vector3 pos)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
            if (!entity) return null;
            ((BaseCombatEntity)entity).startHealth = HeliHealth;
            var weakspots = ((BaseHelicopter)entity).weakspots;
            weakspots[0].maxHealth = MainRotorHealth;
            weakspots[0].health = MainRotorHealth;
            weakspots[1].maxHealth = TailRotorHealth;
            weakspots[1].health = TailRotorHealth;
            entity.GetComponent<BaseHelicopter>().maxCratesToSpawn = 2;
            entity.Spawn();
            activeHelis.Add((BaseHelicopter)entity);
            ConVar.PatrolHelicopter.bulletAccuracy = HeliAccuracy;
            entity.GetComponent<PatrolHelicopterAI>().State_Move_Enter(pos + new Vector3(0.0f, 10f, 0.0f));
            return entity;
        }
        private Vector3 calculateSpawnPos(Vector3 arenaPos)
        {
            Vector3 spawnPos = new Vector3(0, 0, 0);
            float randX = RandomRange(SpawnDistance);
            float randZ = RandomRange(SpawnDistance);
            spawnPos.x = arenaPos.x - randX;
            spawnPos.z = arenaPos.z - randZ;

            var ang = UnityEngine.Random.Range(1, 360);
            Vector3 finalPos = GetGroundPosition(spawnPos);
            finalPos.y = finalPos.y + 30;
            finalPos.x = spawnPos.x + SpawnDistance * Mathf.Sin(ang * Mathf.Deg2Rad);
            finalPos.z = spawnPos.z + SpawnDistance * Mathf.Cos(ang * Mathf.Deg2Rad);

            return finalPos;
        }
        private float RandomRange(float distance, float difference = 50)
        {
            float rand = UnityEngine.Random.Range(distance - difference, distance + difference);
            return rand;
        }
        private void MoveEntity(BaseEntity entity, Vector3 pos)
        {
            Vector3 spawnPos = calculateSpawnPos(pos);
            entity.transform.position = spawnPos;
        }
        private void CheckDistance(BaseEntity entity, BasePlayer player)
        {
            if (entity == null || player == null) return;
            if (cachedData.ContainsKey(player.userID))
            {
                var currentPos = entity.transform.position;
                var targetPos = player.transform.position;
                if (targetPos != null)
                {
                    if (Vector3.Distance(currentPos, targetPos) < (currentPos.y + HeliDistance))
                    {
                        PatrolHelicopterAI heliAI = entity.GetComponent<PatrolHelicopterAI>();
                        heliAI.State_Orbit_Enter(50);
                        heliAI.maxSpeed = HeliSpeed;
                    }
                    else
                        entity.GetComponent<PatrolHelicopterAI>().State_Move_Enter(targetPos + new Vector3(0.0f, 10f, 0.0f));
                }
                timer.Once(7, () => CheckDistance(entity, player));
            }
        }
        static Vector3 GetGroundPosition(Vector3 sourcePos) // credit Wulf & Nogrod
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, GROUND_MASKS))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }
        private void KillHeli()
        {
            int i = 0;
            foreach (var heli in activeHelis) { heli.KillMessage(); i++; }
            if (i > 0) Puts("Destroyed {0} KillStreak Helicopters", i);
        }

        private void KillTurret()
        {
            int i = 0;
            foreach (var turret in TurretList)
			{
				if (turret == null || turret.IsDead()) continue;
				turret.DieInstantly();
				i++;
			}
            if (i > 0) Puts("Destroyed {0} KillStreak Turrets", i);
        }
        #endregion

        #region martyrdom
        private void SetMartyrdom(BasePlayer player) => mrtdm.Add(player.userID);

        private void ChooseRandomExp(Vector3 pos)
        {
            int num = UnityEngine.Random.Range(1, 6);
            if (num == 1 || num == 2 || num == 3) dropGrenade(pos);
            else if (num == 4 || num == 5) dropBeancan(pos);
            else if (num == 6) dropExplosive(pos);
        }
        private void dropGrenade(Vector3 deathPos)
        {
            timer.Once(0.1f, () => Effect.server.Run("assets/prefabs/weapons/f1 grenade/effects/bounce.prefab", deathPos));
            timer.Once(4f, () =>
            {
                Effect.server.Run("assets/prefabs/weapons/f1 grenade/effects/f1grenade_explosion.prefab", deathPos);
                dealDamage(deathPos, grenadeDamage, grenadeRadius);
            });
        }

        private void dropBeancan(Vector3 deathPos)
        {
            timer.Once(0.1f, () => Effect.server.Run("assets/prefabs/weapons/beancan grenade/effects/bounce.prefab", deathPos));
            timer.Once(4f, () =>
            {
                Effect.server.Run("assets/prefabs/weapons/beancan grenade/effects/beancan_grenade_explosion.prefab", deathPos);
                dealDamage(deathPos, beancanDamage, beancanRadius);
            });
        }

        private void dropExplosive(Vector3 deathPos)
        {
            timer.Once(0.1f, () => Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", deathPos));
            timer.Once(2f, () => Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab.prefab", deathPos));
            timer.Once(4f, () => Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab.prefab", deathPos));
            timer.Once(6f, () => Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab.prefab", deathPos));
            timer.Once(8f, () =>
            {
                Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", deathPos);
                dealDamage(deathPos, explosiveDamage, explosiveRadius);
            });
        }
        #endregion

        #region supplydrop
        private void SendSupplyDrop(BasePlayer player, int streaknum)
        {
            if (player == null) return;
            int amount = data.killStreaks[streaknum].Amount;
            int i = 0;
            while (i < amount)
            {
                SpawnSignal(player);
                i++;
            }
        }
        private void SpawnSignal(BasePlayer player)
        {
            if (FancyDrop)
                rust.RunServerCommand("ad.dropplayer " + player.UserIDString);
            else
            {
                var pos = player.transform.position;
                Vector3 setPos = pos + new Vector3(RandomRange(10, 5), 200, RandomRange(10, 5));
                BaseEntity drop = GameManager.server.CreateEntity(supplydrop_prefab, setPos);
                drop.globalBroadcast = true;
                drop.Spawn();
            }
        }
        #endregion

        #region turret drop
        private void DropTurret(Vector3 pos, BasePlayer player)
        {
            AutoTurret turret = CreateTurret(pos);
			// safety check if the turret was unable to spawn
			if (turret != null || !turret.IsDead())
			 {
				TurretList.Add(turret);
				AssignTurretAuth(player, turret);
				player.SendNetworkUpdateImmediate();
				// set timer to remove it after 30 minutes
				timer.Once(1800, () =>
                {
					if (turret != null && !turret.IsDead())
						turret.DieInstantly();
				});
			 }
        }
        private AutoTurret CreateTurret(Vector3 targetPos)
        {
            BaseEntity turret = GameManager.server.CreateEntity("assets/prefabs/npc/autoturret/autoturret_deployed.prefab", targetPos, new Quaternion(), true);
            turret.Spawn();
			return (AutoTurret)turret;
        }

        private void AssignTurretAuth(BasePlayer player, AutoTurret turret)
        {
            var nearbyFriends = FindNearbyFriends(player);
            if (nearbyFriends != null)
            {
                foreach (var entry in nearbyFriends)
                    if (entry != null)
                        turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() { userid = entry.userID, username = entry.displayName });
            }

            // Item weapon = ItemManager.CreateByItemID(1545779598); // m249
			Item weapon = ItemManager.CreateByItemID(28201841); // m39
            weapon.MoveToContainer(turret.inventory, 0, false);
            turret.UpdateAttachedWeapon();

            turret.inventory.AddItem(ItemManager.FindItemDefinition(turretAmmoTypeName), turretAmmoCount);
            turret.InitiateStartup();
            turret.SendNetworkUpdateImmediate();
        }
        #endregion

        #region payment
        private string GiveEconomics(BasePlayer player, int streaknum)
        {
            double amount = data.killStreaks[streaknum].Amount;
            Economics?.Call("Deposit", player.userID, amount);
            return string.Format(lang.GetMessage("coinsActive", this, player.UserIDString), amount);
        }

        private string GiveRP(BasePlayer player, int streaknum)
        {
            int amount = data.killStreaks[streaknum].Amount;
            ServerRewards?.Call("AddPoints", player.userID, amount);
            return string.Format(lang.GetMessage("rpActive", this, player.UserIDString), amount);
        }

        private string GiveKit(BasePlayer player, string kitname, int streaknum)
        {
			if (string.IsNullOrEmpty(kitname) || kitname == "null")
				return string.Format(lang.GetMessage("noKit", this, player.UserIDString));
			else
			{
				Kits?.Call("GiveKit",  new object[] { player, kitname});
				return string.Format(lang.GetMessage("kitActive", this, player.UserIDString), kitname);
			}
        }

        #endregion

        #region damage
        private void dealDamage(Vector3 deathPos, float damage, float radius)
        {
            List<BaseCombatEntity> entitiesClose = new List<BaseCombatEntity>();
            List<BaseCombatEntity> entitiesNear = new List<BaseCombatEntity>();
            List<BaseCombatEntity> entitiesFar = new List<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(deathPos, radius / 3, entitiesClose);
            Vis.Entities<BaseCombatEntity>(deathPos, radius / 2, entitiesNear);
            Vis.Entities<BaseCombatEntity>(deathPos, radius, entitiesFar);

            foreach (BaseCombatEntity entity in entitiesClose)
            {
                entity.Hurt(damage, Rust.DamageType.Explosion, null, true);
            }

            foreach (BaseCombatEntity entity in entitiesNear)
            {
                if (entitiesClose.Contains(entity)) return;
                entity.Hurt(damage / 2, Rust.DamageType.Explosion, null, true);
            }

            foreach (BaseCombatEntity entity in entitiesFar)
            {
                if (entitiesClose.Contains(entity) || entitiesNear.Contains(entity)) return;
                entity.Hurt(damage / 4, Rust.DamageType.Explosion, null, true);
            }
        }
        #endregion

        #endregion

        #region chat commands
        //[ChatCommand("a")]
        //void asd(BasePlayer player, string command, string[] args)
        //{
        //    if (!pdata.killStreakData.ContainsKey(player.userID))
        //        pdata.killStreakData.Add(player.userID, new KSPDATA() { Name = player.displayName, highestKS = 0 });

        //    if (!cachedData.ContainsKey(player.userID))
        //        cachedData.Add(player.userID, 0);

        //    cachedData[player.userID]++;

        //    if (cachedData[player.userID] > pdata.killStreakData[player.userID].highestKS)
        //        pdata.killStreakData[player.userID].highestKS = cachedData[player.userID];

        //    Deal(player);
        //}
        [ChatCommand("ks")]
        void cmdTarget(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                SendReply(player, fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>");
                BroadcastToPlayer(player, lang.GetMessage("kstop2", this, player.UserIDString), lang.GetMessage("kstop", this, player.UserIDString));
                BroadcastToPlayer(player, lang.GetMessage("kspb2", this, player.UserIDString), lang.GetMessage("kspb", this, player.UserIDString));
                if (isAuth(player))
                {
                    BroadcastToPlayer(player, lang.GetMessage("ksAdd1", this, player.UserIDString), lang.GetMessage("ksAdd", this, player.UserIDString));
                    BroadcastToPlayer(player, lang.GetMessage("ksRem1", this, player.UserIDString), lang.GetMessage("ksRem", this, player.UserIDString));
                    BroadcastToPlayer(player, lang.GetMessage("ksList1", this, player.UserIDString), lang.GetMessage("ksList", this, player.UserIDString));
                    BroadcastToPlayer(player, lang.GetMessage("ksListNum1", this, player.UserIDString), lang.GetMessage("ksListNum", this, player.UserIDString));

                    BroadcastToPlayer(player, lang.GetMessage("kswipe2", this, player.UserIDString), lang.GetMessage("kswipe", this, player.UserIDString));
                }
                return;
            }
            var ID = player.userID;
            // write data since it might be references
            KSPData.WriteObject(pdata);
            switch (args[0].ToLower())
            {
                case "top":
                    if (args.Length >= 1)
                    {
                        int amount = 5;
                        if (args.Length >= 2)
                            if (!int.TryParse(args[1], out amount))
                                amount = 5;
                        Dictionary<string, int> top5 = pdata.killStreakData.OrderByDescending(pair => pair.Value.highestKS).Take(amount).ToDictionary(pair => pair.Value.Name, pair => pair.Value.highestKS);
                        if (top5.Count > 0)
                        {
                            SendReply(player, fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>" + fontColor2 + lang.GetMessage("bestHits", this, player.UserIDString) + "</color>");
                            foreach (var name in top5)
                            {
                                SendReply(player, string.Format(fontColor2 + lang.GetMessage("topList", this, player.UserIDString) + "</color>", name.Key, name.Value));
                            }
                        }
                    }
                    return;
                case "wipe":
                    if (isAuth(player))
                    {
                        foreach (BasePlayer onlinePlayer in BasePlayer.activePlayerList)
                        {
                            ClearPlayerRewards(onlinePlayer);
                        }
                        pdata.killStreakData.Clear();
                        KSPData.WriteObject(pdata);
                        SendReply(player, lang.GetMessage("wipedata", this, player.UserIDString));
                    }
                    return;
                case "pb":
                    if (pdata.killStreakData.ContainsKey(ID))
                        BroadcastToPlayer(player, pdata.killStreakData[ID].highestKS.ToString(), lang.GetMessage("pb", this, player.UserIDString));
                    else
                        BroadcastToPlayer(player, "0", lang.GetMessage("pb", this, player.UserIDString));
                    return;
                case "list":
                    if (isAuth(player))
                    {
                        if (args.Length >= 2)
                        {
                            int i = -1;
                            int.TryParse(args[1], out i);
                            if (i <= 0) { BroadcastToPlayer(player, lang.GetMessage("invKsNum", this, player.UserIDString), lang.GetMessage("ksListNum", this, player.UserIDString)); return; }
                            if (!data.killStreaks.ContainsKey(i)) { SendReply(player, string.Format(fontColor1 + lang.GetMessage("invKey", this, player.UserIDString) + "</color>", i)); return; }
                            BroadcastToPlayer(player, i.ToString(), lang.GetMessage("kills", this, player.UserIDString));
                            BroadcastToPlayer(player, data.killStreaks[i].StreakType.ToString(), lang.GetMessage("type", this, player.UserIDString));
                            BroadcastToPlayer(player, data.killStreaks[i].Amount.ToString(), lang.GetMessage("amount", this, player.UserIDString));
                            string message = data.killStreaks[i].Message;
                            BroadcastToPlayer(player, message, lang.GetMessage("message", this, player.UserIDString));
                            return;
                        }
                        else
                        {
                            BroadcastToPlayer(player, "", lang.GetMessage("regStreaks", this, player.UserIDString));
                            foreach (var entry in data.killStreaks) BroadcastToPlayer(player, entry.Key.ToString(), "");
                        }
                    }
                    return;
                case "add":
                    if (isAuth(player))
                    {
                        if (args.Length >= 3)
                        {
                            int i = -1;
                            int.TryParse(args[1], out i);
                            if (i <= 0) { BroadcastToPlayer(player, "", lang.GetMessage("invKillNum", this, player.UserIDString)); return; }
                            if (data.killStreaks.ContainsKey(i))
                            {
                                BroadcastToPlayer(player, "", string.Format(lang.GetMessage("amountUsed", this, player.UserIDString), i));
                                return;
                            }
                            data.killStreaks.Add(i, new Streaks() { Message = args[2], StreakType = StreakType.None, Amount = 0 });

                            if (args.Length >= 4)
                            {
                                int sNum = -1;
                                int.TryParse(args[3], out sNum);
                                if (!streakTypes.ContainsKey(sNum)) { BroadcastToPlayer(player, "", string.Format(lang.GetMessage("invST", this, player.UserIDString), args[3])); return; }
                                data.killStreaks[i].StreakType = streakTypes[sNum];
                                int o = -1;
                                if (args.Length >= 5) int.TryParse(args[4], out o);
                                if (o != -1)
                                    data.killStreaks[i].Amount = o;
                            }
                            SaveStreakData();
                            BroadcastToPlayer(player, "", string.Format(lang.GetMessage("addSuccess", this, player.UserIDString), i));
                            return;
                        }
                        BroadcastToPlayer(player, "V " + Version, lang.GetMessage("title", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("ksAddForm1", this, player.UserIDString), lang.GetMessage("ksAddForm", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("kNum1", this, player.UserIDString), lang.GetMessage("kNum", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("kMes1", this, player.UserIDString), lang.GetMessage("kMes", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("kTyp1", this, player.UserIDString), lang.GetMessage("kTyp", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("kAmo1", this, player.UserIDString), lang.GetMessage("kAmo", this, player.UserIDString));
                        BroadcastToPlayer(player, lang.GetMessage("showTypes1", this, player.UserIDString), lang.GetMessage("showTypes", this, player.UserIDString));
                    }
                    return;
                case "show":
                    if (isAuth(player))
                    {
                        BroadcastToPlayer(player, lang.GetMessage("availTypes", this, player.UserIDString), lang.GetMessage("title", this, player.UserIDString));
                        foreach (var entry in streakTypes)
                        {
                            BroadcastToPlayer(player, entry.Value.ToString(), entry.Key.ToString());
                        }
                    }
                    return;
                case "remove":
                    if (isAuth(player))
                    {
                        if (args.Length >= 2)
                        {
                            int i = -1;
                            int.TryParse(args[1], out i);
                            if (i == -1) { BroadcastToPlayer(player, lang.GetMessage("invKSNum", this, player.UserIDString), lang.GetMessage("ksRem", this, player.UserIDString)); return; }
                            if (!data.killStreaks.ContainsKey(i)) { BroadcastToPlayer(player, "", string.Format(lang.GetMessage("invKey", this, player.UserIDString), i)); return; }
                            data.killStreaks.Remove(i);

                            BroadcastToPlayer(player, "", string.Format(lang.GetMessage("remKS", this, player.UserIDString), i.ToString()));
                            SaveData();
                        }
                    }
                    return;
                case "astrike":

                    if (aasGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AdvAirstrikeGrenade);
                        else
                            activeGrenades[ID] = StreakType.AdvAirstrikeGrenade;
                        aasGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("aasActive", this, player.UserIDString));
                    }
                    return;
                case "napalm":

                    if (naGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AdvAirstrikeNapalmGrenade);
                        else
                            activeGrenades[ID] = StreakType.AdvAirstrikeNapalmGrenade;
                        naGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("naActive", this, player.UserIDString));
                    }
                    return;
                case "nuke":

                    if (nuGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AdvAirstrikeNukeGrenade);
                        else
                            activeGrenades[ID] = StreakType.AdvAirstrikeNukeGrenade;
                        nuGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("nuActive", this, player.UserIDString));
                    }
                    return;
                case "spectre":

                    if (aasGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AdvAirstrikeGrenade);
                        else
                            activeGrenades[ID] = StreakType.AdvAirstrikeGrenade;
                        aasGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("aasActive", this, player.UserIDString));
                    }
                    return;
                case "asquad":

                    if (sqGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AdvAirstrikeSpectreGrenade);
                        else
                            activeGrenades[ID] = StreakType.AdvAirstrikeSpectreGrenade;
                        sqGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("asqActive", this, player.UserIDString));
                    }
                    return;
                case "strike":

                    if (asGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.AirstrikeGrenade);
                        else
                            activeGrenades[ID] = StreakType.AirstrikeGrenade;
                        asGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("asActive", this, player.UserIDString));
                    }
                    return;
                case "squad":
                    if (ssGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.SquadStrikeGrenade);
                        else
                            activeGrenades[ID] = StreakType.SquadStrikeGrenade;
                        ssGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("ssActive", this, player.UserIDString));
                    }
                    return;
                case "art":
                    if (arGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.ArtilleryGrenade);
                        else
                            activeGrenades[ID] = StreakType.ArtilleryGrenade;
                        arGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("arActive", this, player.UserIDString));
                    }
                    return;
                case "heli":
                    if (heGren.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.HelicopterGrenade);
                        else
                            activeGrenades[ID] = StreakType.HelicopterGrenade;
                        heGren.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("heActive", this, player.UserIDString));
                    }
                    return;
                case "turret":
                    if (turret.Contains(ID))
                    {
                        if (!activeGrenades.ContainsKey(ID))
                            activeGrenades.Add(ID, StreakType.TurretDrop);
                        else
                            activeGrenades[ID] = StreakType.TurretDrop;
                        turret.Remove(ID);
                        BroadcastToPlayer(player, "", lang.GetMessage("tuActive", this, player.UserIDString));
                    }
                    return;
            }
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 1)
                    return false;
            return true;
        }

        #endregion

        #region gui

        class KSUI : MonoBehaviour
        {
            int i;

            private BasePlayer player;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                i = 0;
            }

            public static KSUI GetPlayer(BasePlayer player)
            {
                KSUI p = player.GetComponent<KSUI>();
                if (p == null) p = player.gameObject.AddComponent<KSUI>();
                return p;
            }

            public void UseUI(string msg, Vector2 pos, Vector2 dim, int size = 18)
            {
                i++;
                string uiNum = i.ToString();

                Vector2 posMin = pos;
                Vector2 posMax = posMin + dim;

                var elements = new CuiElementContainer();
                CuiElement textElement = new CuiElement
                {
                    Name = uiNum,
                    Parent = "Overlay",
                    FadeOut = 0.3f,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = msg,
                            FontSize = size,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = 0.3f
                        },
                        new CuiOutlineComponent
                        {
                            Distance = "1.0 1.0",
                            Color = "0.0 0.0 0.0 1.0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = posMin.x + " " + posMin.y,
                            AnchorMax = posMax.x + " " + posMax.y
                        }
                    }
                };
                elements.Add(textElement);
                CuiHelper.AddUi(player, elements);
                Interface.GetMod().CallHook("DestroyWarningMsg", new object[] { player, uiNum, 5 });
            }
        }
        private void DestroyNotification(BasePlayer player, string msgNum)
        {
            bool t = CuiHelper.DestroyUi(player, msgNum);
            if (!t) DestroyNotification(player, msgNum);
        }
        private void DestroyWarningMsg(BasePlayer player, string msgNum, int duration)
        {
            timer.Once(duration, () => DestroyNotification(player, msgNum));
        }
        #endregion

        #region config

        bool Changed;

		static bool broadcastEnd = true;
		static bool broadcastMsg = true;
		static bool ignoreBuildPriv = false;
		static bool showVictim = true;
		static bool useAdvAirstrike = true;
		static bool useAirstrike = true;
		static bool useClans = true;
		static bool useFriendsAPI = true;
		static bool usePermissions = false;
		static bool useZoneManager = true;

        static int saveTimer = 10;

        static bool PVPOnly = false;
        static bool PeopleOnly = false;
        static bool NoDisconnect = false;

        static float HeliBulletDamage = 3.0f;
        static float HeliHealth = 4000.0f;
        static float MainRotorHealth = 400.0f;
        static float TailRotorHealth = 250.0f;
        static float HeliSpeed = 30.0f;
        static float HeliAccuracy = 6.0f;
        static float SpawnDistance = 500f;

        static string fontColor1 = "<color=orange>";
        static string fontColor2 = "<color=#939393>";

        static float rocketInterval = 0.5f;
        static float rocketSpread = 6.0f;
        static int rocketAmount = 20;

        static float grenadeRadius = 5f;
        static float grenadeDamage = 75f;
        static float beancanRadius = 4f;
        static float beancanDamage = 30f;
        static float explosiveRadius = 10f;
        static float explosiveDamage = 110f;

        static float nearbyRadius = 50f;
        static string turretAmmoTypeName = "ammo.rifle";
        static int turretAmmoCount = 1000;

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
			zones = zdataFile.ReadObject<List<string>>();
        }
        private void LoadConfigVariables()
        {
            CheckCfgFloat("Helicopter - Bullet damage", ref HeliBulletDamage);
            CheckCfgFloat("Helicopter - Health", ref HeliHealth);
            CheckCfgFloat("Helicopter - Mail rotor health", ref MainRotorHealth);
            CheckCfgFloat("Helicopter - Tail rotor health", ref TailRotorHealth);
            CheckCfgFloat("Helicopter - Speed", ref HeliSpeed);
            CheckCfgFloat("Helicopter - Accuracy", ref HeliAccuracy);
            CheckCfgFloat("Helicopter - Spawn distance (away from player)", ref SpawnDistance);

            CheckCfgFloat("Artillery - Rocket interval", ref rocketInterval);
            CheckCfgFloat("Artillery - Rocket spread", ref rocketSpread);
            CheckCfg("Artillery - Rocket amount", ref rocketAmount);

            CheckCfgFloat("Martyrdom - Explosive radius - Grenade", ref grenadeRadius);
            CheckCfgFloat("Martyrdom - Explosive radius - Beancan", ref beancanRadius);
            CheckCfgFloat("Martyrdom - Explosive radius - Explosive", ref explosiveRadius);
            CheckCfgFloat("Martyrdom - Explosive damage - Grenade", ref grenadeDamage);
            CheckCfgFloat("Martyrdom - Explosive damage - Beancan", ref beancanDamage);
            CheckCfgFloat("Martyrdom - Explosive damage - Explosive", ref explosiveDamage);

            CheckCfgFloat("TurretDrop - Auto-authorize radius", ref nearbyRadius);
            CheckCfg("TurretDrop - Ammunition type shortname", ref turretAmmoTypeName);
            CheckCfg("TurretDrop - Ammunition amount", ref turretAmmoCount);

            CheckCfg("Options - Use FriendsAPI", ref useFriendsAPI);
            CheckCfg("Options - Use Clans", ref useClans);
            CheckCfg("Options - Use Airstrike", ref useAirstrike);
            CheckCfg("Options - Use Advanced Airstrike", ref useAdvAirstrike);
            CheckCfg("Options - Ignore kills in building privilege", ref ignoreBuildPriv);
            CheckCfg("Options - Use Zone Manager", ref useZoneManager);

            CheckCfg("Options - Data save timer", ref saveTimer);
            CheckCfg("Options - usePermissions", ref usePermissions);
            CheckCfg("Options - PVPOnly", ref PVPOnly);
            CheckCfg("Options - NPCs and Players Only", ref PeopleOnly);
            CheckCfg("Options - NoDisconnect", ref NoDisconnect);

            CheckCfg("Messages - Broadcast streak message", ref broadcastMsg);
            CheckCfg("Messages - Show Vicitm Player Name", ref showVictim);
            CheckCfg("Messages - Broadcast streak end", ref broadcastEnd);
            CheckCfg("Messages - Message color", ref fontColor2);
            CheckCfg("Messages - Main color", ref fontColor1);
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion

        #region classes and data storage
        void SaveStreakData()
        {
            KSData.WriteObject(data);
        }

        void SaveData()
        {
            foreach (var entry in cachedData)
            {
                var d = pdata.killStreakData;
                if (!d.ContainsKey(entry.Key))
                    d.Add(entry.Key, new KSPDATA());
                if (d[entry.Key].highestKS < entry.Value)
                    d[entry.Key].highestKS = entry.Value;
            }
            KSPData.WriteObject(pdata);
        }
        void SaveLoop()
        {
            SaveData();
            timer.Once(saveTimer * 60, () => SaveData());
        }
        void LoadData()
        {
            try
            {
                pdata = Interface.GetMod().DataFileSystem.ReadObject<Player_DataStorage>("killstreak_player_data");
            }
            catch
            {
                pdata = new Player_DataStorage();
            }
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("killstreak_data");
            }
            catch
            {
                data = new DataStorage();
                data.killStreaks = ksDefault;
            }


            if (data.killStreaks == null || data.killStreaks.Count < 1) data.killStreaks = ksDefault;
            timer.Once(saveTimer, () => SaveLoop());
        }
        void RegisterMessages() => lang.RegisterMessages(messages, this);

        class Player_DataStorage
        {
            public Dictionary<ulong, KSPDATA> killStreakData = new Dictionary<ulong, KSPDATA>();
            public Player_DataStorage() { }
        }
        class DataStorage
        {
            public Dictionary<int, Streaks> killStreaks = new Dictionary<int, Streaks>();
            public DataStorage() { }
        }

        class KSPDATA
        {
            public string Name;
            public int highestKS = 0;
        }

        class Streaks
        {
            public string Message;
            public StreakType StreakType;
            public int Amount = 1;
            public string KitName;
        }

        enum StreakType
        {
            None,
            Airstrike,
            SquadStrike,
            Artillery,
            Helicopter,
            SupplyDrop,
            AirstrikeGrenade,
            SquadStrikeGrenade,
            ArtilleryGrenade,
            HelicopterGrenade,
            Martyrdom,
            TurretDrop,
            Coins,
            RP,
            AdvAirstrike,
            AdvAirstrikeGrenade,
            SupplySignal,
			AdvAirstrikeSquad,
			AdvAirstrikeNapalm,
			AdvAirstrikeNuke,
			AdvAirstrikeSpectre,
			AdvAirstrikeSquadGrenade,
			AdvAirstrikeNapalmGrenade,
			AdvAirstrikeNukeGrenade,
			AdvAirstrikeSpectreGrenade,
            Command,
			KitOnly
        }
        #endregion

        #region defaultks

        Dictionary<int, Streaks> ksDefault = new Dictionary<int, Streaks>()
        {
            {5, new Streaks() {StreakType = StreakType.SupplyDrop, Message = " is on a killing spree!" } },
            {10, new Streaks() {StreakType = StreakType.ArtilleryGrenade, Message = " is on a kill frenzy!" } },
            {15, new Streaks() {StreakType = StreakType.Martyrdom, Message = " is running riot!" } },
            {20, new Streaks() {StreakType = StreakType.Helicopter, Amount = 1, Message = " is on a rampage!" } },
            {25, new Streaks() {StreakType = StreakType.HelicopterGrenade, Message = " is untouchable!"} },
            {30, new Streaks() {StreakType = StreakType.SquadStrike, Amount = 1, Message = " is invincible!" } },
            {35, new Streaks() {StreakType = StreakType.SupplyDrop, Amount = 3, Message = " is a god!" } }
        };

        #endregion

        #region message
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"kill_message", " {0} kills"},
            {"kill_mess_victim", " {0} kills by killing {1}"},
			{"title", "Killstreaks: "},
            {"aheli", "a helicopter" },
            {"aanim", "a animal" },
            {"abt", "a bear trap" },
            {"aldm", "a landmine" },
            {"flrsp", "floor spikes" },
            {"aturr", "a turret" },
            {"awall", "a wall" },
            {"endstreak", "'s killstreak has been ended by " },
            {"suic", "suicide" },
            {"disconnected", "disconnection" },
            {"attract", "Your killstreak has attracted attention!" },
            {"warning", "WARNING! " },
            {"pb", "Highest kill streak: " },
            {"kstop", "/ks top" },
            {"kswipe", "/ks wipe" },
            {"kspb", "/ks pb" },
            {"kswipe2", "- Clears all Killstreak data" },
            {"kstop2", "- Displays top Killstreaks" },
            {"kspb2", "- Shows your personal best Killstreak" },
            {"topList", "{0} : {1} kills" },
            {"bestHits", "Top killstreaks" },
            {"noAdvAirstrike", "Advanced Airstrike is not installed, unable to send strike" },
            {"noAirstrike", "Airstrike is not installed, unable to send strike" },
            {"ksAdd", "/ks add" },
            {"amountUsed", "You already have a killstreak set for {0} kills" },
            {"ksRem", "/ks remove ##" },
            {"ksList", "/ks list" },
            {"ksListNum", "/ks list ##" },
            {"ksAdd1", " - Displays the required format to add a kill streak" },
            {"ksRem1", " - Remove a kill streak" },
            {"ksList1", " - List current kills" },
            {"ksListNum1", " - Display kill streak information for <killnumber>" },
            {"invKSNum", " - You must enter a number." },
            {"invKey", "You do not have a killstreak set to {0} kills" },
            {"kills", "Kills: " },
            {"type", "Type: " },
            {"amount", "Amount: " },
            {"message", "Message: " },
            {"regStreaks", "You have kill streaks registered to the following kills:" },
            {"invKillNum", "You must enter a number of kills!" },
            {"invST", "{0} is a invalid Streak type!" },
            {"addSuccess", "You have successfully registered a kill streak for {0} kills" },
            { "ksAddForm", "/ks add <killnumber> <message> <opt:type> <opt:amount>" },
            { "ksAddForm1", " - Kill number and message are required!" },
            { "kNum", "<killnumber>" },
            { "kNum1", " - The amount of kills required to activate the streak" },
            { "kMes", "<message>" },
            { "kMes1", " - The message that will be globally broadcast" },
            { "kTyp", "<opt:type>" },
            { "kTyp1", " - (Optional) Type of streak" },
            { "kAmo",        "<opt:amount>" },
            { "kAmo1",       " - (Optional) Amount of times the type will be called" },
            { "remKS",       "You have removed the kill streak for {0}" },
            { "showTypes",   "/ks show" },
            { "showTypes1",  " - Show available killstreak types and their ID" },
            { "availTypes",  " - Available streak types:" },
            { "aasGrenade",  "You have been given a Advanced Airstrike signal. Activate it with /ks astrike" },
            { "naGrenade",   "You have been given a Advanced Airstrike Napalm signal. Activate it with /ks napalm" },
            { "nuGrenade",   "You have been given a Advanced Airstrike Nuke signal. Activate it with /ks nuke" },
            { "sqGrenade",   "You have been given a Advanced Airstrike Squad signal. Activate it with /ks asquad" },
            { "spGrenade",   "You have been given a Advanced Airstrike Spectre signal. Activate it with /ks spectre" },
            { "asGrenade",   "You have been given a Airstrike signal. Activate it with /ks strike" },
            { "ssGrenade",   "You have been given a SquadStrike signal. Activate it with /ks squad" },
            { "arGrenade",   "You have been given a Artillery signal. Activate it with /ks art" },
            { "heGrenade",   "You have been given a Helicopter signal. Activate it with /ks heli" },
            { "tuGrenade",   "You have been given a Turret Drop signal. Activate it with /ks turret" },
            { "mrtdmActive", "You have earnt the perk Martyrdom. When you die next you will drop a random explosive!" },
            { "aasLaunch",   "An Advanced Airstrike has been launched at your position!" },
            { "asLaunch",    "An Airstrike has been launched at your position!" },
            { "naLaunch",    "An Advanced Airstrike Napalm has been launched at your position!" },
            { "nuLaunch",    "An Advanced Airstrike Nuke has been launched at your position!" },
            { "sqLaunch",    "An Advanced Airstrike Squad has been launched at your position!" },
            { "spLaunch",    "An Advanced Airstrike Spectre has been launched at your position!" },
            { "arLaunch",    "An Artillery strike has been launched at your position!" },
            { "ssLaunch",    "An SquadStrike has been launched at your position!" },
            { "heLaunch",    "An helicopter has been sent to your position!" },
            { "sdLaunch",    "A supply drop is inbound on your position!" },
            { "sdSignal",    "You have earned a supply signal" },
            { "aasActive",   "You have activated your Advanced Airstrike, throw the smoke grenade to call it" },
            { "asqActive",   "You have activated your Advanced Airstrike Squad, throw the smoke grenade to call it" },
            { "naActive",    "You have activated your Advanced Airstrike Napalm, throw the smoke grenade to call it" },
            { "nuActive",    "You have activated your Advanced Airstrike Nuke, throw the smoke grenade to call it" },
            { "spActive",    "You have activated your Advanced Airstrike Spectre, throw the smoke grenade to call it" },
            { "asActive",    "You have activated your Airstrike, throw the smoke grenade to call it" },
            { "ssActive",    "You have activated your SquadStrike, throw the smoke grenade to call it" },
            { "arActive",    "You have activated your Artillery Strike, throw the smoke grenade to launch" },
            { "heActive",    "You have activated your Helicopter Strike, throw the smoke grenadel to call it" },
            { "tuActive",    "You have activated your Turret Drop, throw the smoke grenade to call it" },
            { "coinsActive", "You have earnt {0} coins" },
            { "rpActive",    "You have earnt {0} RP"},
            { "kitActive",   "You have earnt {0} Kit"},
            { "noKit",       "No kit defined for for streak {0}"},
            { "wipedata",   "Kill Streak Player Data wiped"}
        };
        #endregion
    }
}


// --- End of file: KillStreaks.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/kill-health ---
// --- Original File Path: K/KillHealth/KillHealth.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Kill Health", "Orange", "1.0.0")]
    [Description("Get health for killing another player")]
    public class KillHealth : RustPlugin
    {
        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            var initiator = info?.InitiatorPlayer;
            if (initiator == null || player.userID.IsSteamId() == false || initiator?.userID.IsSteamId() == false)
            {
                return;
            }
            
            initiator.Heal(100f);
        }
    }
}

// --- End of file: KillHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/knock-open ---
// --- Original File Path: K/KnockOpen/KnockOpen.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Knock Open", "OfficerJAKE", "2.5.8")]
    [Description("Opens security doors when knocked on by players and holding the correct card")]
    internal class KnockOpen : RustPlugin
    {

        public static string eff = string.Empty;
        public static Vector3 effTarget = Vector3.zero;
        public static string cardColor = string.Empty;
        public static string doorColor = string.Empty;
        public static string logMsg = string.Empty;

        Configuration config;

        class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings settings = new Settings();

            [JsonProperty(PropertyName = "Tuners")]
            public Tuners tuners = new Tuners();

            public class Settings
            {
                [JsonProperty(PropertyName = "Post To Chat")]
                public bool PostToChat = true;

                [JsonProperty(PropertyName = "Damage Keycards")]
                public bool DamageKeycards = true;

                [JsonProperty(PropertyName = "Use Effects")]
                public bool UseEffects = true;

                [JsonProperty(PropertyName = "Close Doors")]
                public bool CloseDoors = true;

                [JsonProperty(PropertyName = "Hurt On Shock")]
                public bool HurtOnShock = false;
            }

            public class Tuners
            {
                [JsonProperty(PropertyName = "Close Door Delay")]
                public float CloseDoorDelay = 15.0F;

                [JsonProperty(PropertyName = "Damage To Deal")]
                public float DamageToDeal = 1.0F;

                [JsonProperty(PropertyName = "Hurt Amount")]
                public float HurtAmount = 5.0F;
				
                [JsonProperty(PropertyName = "Effect On Success")]
                public string EffectSuccess = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";

                [JsonProperty(PropertyName = "Effect On Failure")]
                public string EffectFailure = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SUCCESS"] = "You opened the door by knocking and waving your card",
                ["FAILURE"] = "You need to be holding a keycard in your hands when you knock",
                ["WRONG_CARD"] = "It appears you have a {0} card, but need a {1} one",
                ["ITEM_BROKE"] = "Your {0} card just broke, so we threw it away",
            }, this);
        }
		
        void OnDoorKnocked(Door door, BasePlayer player)
        {
			
            if (!door.isSecurityDoor || player == null) return;
			
            switch (door.PrefabName)
            {
                case "assets/bundled/prefabs/static/door.hinged.security.green.prefab":
                    {
                        doorColor = "green";
                        break;
                    }
                case "assets/bundled/prefabs/static/door.hinged.security.blue.prefab":
                    {
                        doorColor = "blue";
                        break;
                    }
                case "assets/bundled/prefabs/static/door.hinged.security.red.prefab":
                    {
                        doorColor = "red";
                        break;
                    }
                default: return;
            }

            HeldEntity heldEnt = player.GetHeldEntity() as HeldEntity;
            if (heldEnt == null)
            {
                Logging(player, Lang("FAILURE"));
                return;
            }

            Item card = (Item)player.GetActiveItem();
            if (card == null) return;

            switch (heldEnt.GetOwnerItemDefinition().shortname)
            {
                case "keycard_green":
                    {
                        cardColor = "green";
                        break;
                    }
                case "keycard_blue":
                    {
                        cardColor = "blue";
                        break;
                    }
                case "keycard_red":
                    {
                        cardColor = "red";
                        break;
                    }
                default:
                    {
                        Logging(player, Lang("FAILURE"));
                        return;
                    }
            }
			
			//player holding card in hand - toggle door
            ToggleDoor(player, door, eff, doorColor, cardColor, card);
        }

        private void ToggleDoor(BasePlayer player, Door door, string eff, string doorColor, string cardColor, Item card)
        {

            if (doorColor.ToLower() != cardColor.ToLower())
            {

                DoEffect(player, door, card, "SHOCK");
                if (config.settings.HurtOnShock)
                {
                    DoEffect(player, door, card, "FAKE_HURT");
                    player.Hurt(config.tuners.HurtAmount);
                }
				
                DoEffect(player, door, card, "FAILURE");
                Logging(player, Lang("WRONG_CARD", null, cardColor, doorColor));
                return;
            }

            Timer openDoor = timer.In(2.0F, () =>
            {
                door.SetOpen(true);
                card.MarkDirty();
                DoEffect(player, door, card, "SUCCESS");
                Logging(player, Lang("SUCCESS"));
            });

            if (config.settings.DamageKeycards)
            {
                DamageCards(player, door, eff, doorColor, cardColor, card);
            }

            if (config.settings.CloseDoors)
            {
				
                Timer closeDoor = timer.Once(config.tuners.CloseDoorDelay, () => door.SetOpen(false));
            }

        }

        private void DamageCards(BasePlayer player, Door door, string eff, string doorColor, string cardColor, Item card)
        {

            float DamageToDo = config.tuners.DamageToDeal;

            card.condition = (card.condition - DamageToDo);
            card.MarkDirty();

            if (card.isBroken)
            {
				//card broke, lets hurl it away
                Vector3 myVector = new Vector3(0.0f, 1.0f, 0.0f);
                card.DropAndTossUpwards(myVector, 3.0F);

                DoEffect(player, door, card, "ITEM_BROKE");
                Logging(player, Lang("ITEM_BROKE", null, cardColor));

            }
        }

        private void DoEffect(BasePlayer player, Door door, Item card, string eff)
        {
            switch (eff)
            {
                case "SUCCESS":
                    {
                        eff = config.tuners.EffectSuccess;
                        effTarget = door.transform.position;
                        if (eff == string.Empty || eff == "")
                        {
                            eff = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";
                        }
                        break;
                    }
                case "FAILURE":
                    {
                        eff = config.tuners.EffectFailure;
                        effTarget = door.transform.position;
                        if (eff == string.Empty || eff == "")
                        {
                            eff = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
                        }
                        break;
                    }
                case "SHOCK":
                    {
                        eff = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab";
                        effTarget = door.transform.position;
                        break;
                    }
                case "FAKE_HURT":
                    {
                        eff = "assets/bundled/prefabs/fx/takedamage_generic.prefab";
                        effTarget = player.transform.position;
                        break;
                    }
                case "ITEM_BROKE":
                    {
                        eff = "assets/bundled/prefabs/fx/item_break.prefab";
                        effTarget = player.transform.position;
                        break;
                    }

                default: return;
            }

            if (config.settings.UseEffects)
            {
                Effect.server.Run(eff, effTarget);
            }

        }

        private void Logging(BasePlayer player, string logMsg)
        {

            if (config.settings.PostToChat)
            {
                player.ChatMessage(logMsg);
            }

        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

    }
}


// --- End of file: KnockOpen.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/keywords ---
// --- Original File Path: K/Keywords/Keywords.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Keywords", "Wulf", "1.3.1")]
    [Description("Sends notifications when a keyword is used in the chat")]
    public class Keywords : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        public class Configuration
        {
            [JsonProperty("Permission required to trigger keywords")]
            public bool UsePermissions = false;

            [JsonProperty("Include original message with notification")]
            public bool IncludeOriginal = true;

            [JsonProperty("Match only exact keywords")]
            public bool MatchExact = true;

            [JsonProperty("Auto-reply for triggered keywords")]
            public bool AutoReply = false;

            [JsonProperty("Notify configured players in chat")]
            public bool NotifyPlayers = false;

            [JsonProperty("Players to notify in chat", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> PlayersToNotify = new List<string> { "PLAYER_ID", "PLAYER_ID_2" };

            [JsonProperty("Notify configured groups in chat")]
            public bool NotifyGroups = true;

            [JsonProperty("Notify configured group in chat")]
            private bool NotifyGroupsOld { set { NotifyGroups = value; } } // TODO: From version 1.2.4; remove eventually

            [JsonProperty("Groups to notify in chat", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> GroupsToNotify = new List<string> { "admin", "moderator" };
#if RUST
            [JsonProperty("Notify using GUI Announcements")]
            public bool NotifyGuiAnnouncements = false;

            [JsonProperty("Banner color to use for GUI (RGBA or color name)")]
            public string GuiBannerColor = "0.1 0.1 0.1 0.7";

            [JsonProperty("Text color to use for GUI (RGB or color name)")]
            public string GuiTextColor = "1 1 1";

            [JsonProperty("Notify using UI Notify")]
            public bool NotifyUiNotify = false;

            [JsonProperty("Notification type for UI Notify")]
            public bool UiNotifyType = false;
#endif
            [JsonProperty("Notify in Discord channel")]
            public bool NotifyInDiscord = false;

            [JsonProperty("Discord embed color (decimal color code)")]
            public string DiscordEmbedColor = "16538684";

            [JsonProperty("Role IDs to mention on Discord", ObjectCreationHandling = ObjectCreationHandling.Replace)] // <@&ROLE_ID> for roles
            public List<ulong> RolesToMention = new List<ulong> { 305751989176762388 };

            [JsonProperty("Roles to mention on Discord",
            ObjectCreationHandling = ObjectCreationHandling.Replace)]
            private List<string> RolesToMentionOld // TODO: From version 1.2.4; remove eventually
            {
                set
                {
                    List<ulong> roles = new List<ulong>();
                    for (int i = 0; i < value.Count; i++)
                    {
                        ulong roleId;
                        if (ulong.TryParse(value[i], out roleId))
                        {
                            roles.Add(roleId);
                        }
                    }
                    RolesToMention = roles;
                }
            }

            [JsonProperty("User IDs to mention on Discord", ObjectCreationHandling = ObjectCreationHandling.Replace)] // <@USER_ID> for users
            public List<ulong> UsersToMention = new List<ulong> { 97031326011506688 };

            [JsonProperty("Users to mention on Discord", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            private List<string> UsersToMentionOld // TODO: From version 1.2.4; remove eventually
            {
                set
                {
                    List<ulong> users = new List<ulong>();
                    for (int i = 0; i < value.Count; i++)
                    {
                        ulong userId;
                        if (ulong.TryParse(value[i], out userId))
                        {
                            users.Add(userId);
                        }
                    }
                    UsersToMention = users;
                }
            }

            [JsonProperty("Discord webhook URL")]
            public string DiscordWebhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty("Keywords to listen for in chat", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Keywords = new List<string> { "admin", "crash", "bug" };

            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AutoReply"] = "Your message has triggered a notification to admin",
                ["KeywordsChat"] = "{0} ({1}) has used the keywords: {2}",
                ["DiscordKeywordsFieldName"] = "Keywords",
                ["DiscordMentionsFieldName"] = "Mentions",
                ["DiscordMessageFieldName"] = "Message",
                ["DiscordPlayerFieldName"] = "Player"
            }, this);
        }

        #endregion Localization

        #region Initialization

        [PluginReference]
        private Plugin BetterChat, GUIAnnouncements, UINotify;

        private readonly Regex _keywordRegex = new Regex("\\w+(?:'(?![aeiou])\\w+)?", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        private const string DiscordJson = @"{
            ""embeds"":[{
                    ""color"": ""${discord.embed.color}"",
                    ""fields"": [
                    {
                        ""name"": ""${player.field.name}"",
                        ""value"": ""${player}""
                    },
                    {
                        ""name"": ""${keywords.field.name}"",
                        ""value"": ""${keywords}""
                    },
                    {
                        ""name"": ""${message.field.name}"",
                        ""value"": ""${message}""
                    },
                    {
                        ""name"": ""${mentions.field.name}"",
                        ""value"": ""${mentions}""
                    }
                ]
            }]
        }";
        private const string PermissionUse = "keywords.use";
        private const string PermissionBypass = "keywords.bypass";

        private string _roleMentions;
        private string _userMentions;

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionBypass, this);

            if (_config.RolesToMention.Count > 0)
            {
                for (int i = 0; i < _config.RolesToMention.Count; i++)
                {
                    _roleMentions += $"<@&{_config.RolesToMention[i]}>";
                }
            }
            if (_config.UsersToMention.Count > 0)
            {
                for (int i = 0; i < _config.UsersToMention.Count; i++)
                {
                    _userMentions += $"<@{_config.UsersToMention[i]}>";
                }
            }

            if (BetterChat != null && BetterChat.IsLoaded)
            {
                Unsubscribe(nameof(OnUserChat));
            }
        }

        #endregion Initialization

        #region Chat Handling

        private void HandleChat(IPlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message))
            {
                return;
            }

            if (_config.UsePermissions && (!player.HasPermission(PermissionUse) || player.HasPermission(PermissionBypass)))
            {
                return;
            }

#if DEBUG
            LogWarning($"DEBUG: Message from {player.Name} ({player.Id}): {message}");
#endif
            List<string> matches = new List<string>();
            MatchCollection keywordMatches = _keywordRegex.Matches(message);
            if (_config.MatchExact)
            {
#if DEBUG
                LogWarning("DEBUG: Looking for exact matches...");
                LogWarning($"DEBUG: Regex matches: {keywordMatches.Count}");
#endif
                // These are exact matches
                matches = keywordMatches.Cast<Match>().Select(m => m.Value).Intersect(_config.Keywords, StringComparer.OrdinalIgnoreCase).ToList(); // TODO: Find alternative to Linq
            }
            else
            {
#if DEBUG
                LogWarning("DEBUG: Looking for partial matches...");
#endif
                // These are partial matches
                for (int i = 0; i < keywordMatches.Count; i++)
                {
                    if (_config.Keywords.Contains(keywordMatches[i].Value))
                    {
                        matches.Add(keywordMatches[i].Value);
                    }
                }
            }

#if DEBUG
            LogWarning($"DEBUG: Matches found: {matches.Count}");
#endif
            if (matches.Count > 0)
            {
                string[] triggers = matches.Distinct().ToArray(); // TODO: Find alternative to Linq
#if DEBUG
                LogWarning($"DEBUG: Keywords triggered by {player.Name} ({player.Id})! {string.Join(", ", triggers)}");
#endif
                if (_config.NotifyPlayers)
                {
                    foreach (string targetId in _config.PlayersToNotify)
                    {
                        IPlayer target = players.FindPlayer(targetId);
                        if (target != null && target.IsConnected)
                        {
                            string notification = GetLang("KeywordsChat", target.Id, player.Name, player.Id, string.Join(", ", triggers));
                            target.Message(_config.IncludeOriginal ? notification + $" | {message}" : notification);
                            SendGuiNotification(target, notification);
                        }
                    }
                }

                if (_config.NotifyGroups)
                {
                    foreach (IPlayer target in players.Connected)
                    {
                        foreach (string group in _config.GroupsToNotify)
                        {
                            if (target.BelongsToGroup(group.ToLower()) && _config.NotifyPlayers && !_config.PlayersToNotify.Contains(target.Id) && target.IsConnected)
                            {
                                string notification = GetLang("KeywordsChat", target.Id, player.Name, player.Id, string.Join(", ", triggers));
                                target.Message(_config.IncludeOriginal ? notification + $" | {message}" : notification);
                                SendGuiNotification(target, notification);
                            }
                        }
                    }
                }

                if (_config.NotifyInDiscord && _config.DiscordWebhook.Contains("/api/webhooks"))
                {
                    for (int i = 0; i < triggers.Length; i++)
                    {
                        message = message.Replace(triggers[i], $"**{triggers[i]}**");
                    }
                    string content = DiscordJson
                        .Replace("${discord.embed.color}", _config.DiscordEmbedColor)
                        .Replace("${player.field.name}", GetLang("DiscordPlayerFieldName"))
                        .Replace("${player}", $"{player.Name.Sanitize()} ({player.Id})")
                        .Replace("${keywords.field.name}", GetLang("DiscordKeywordsFieldName"))
                        .Replace("${keywords}", string.Join(", ", triggers))
                        .Replace("${message.field.name}", GetLang("DiscordMessageFieldName"))
                        .Replace("${message}", message.Sanitize())
                        .Replace("${mentions.field.name}", GetLang("DiscordMentionsFieldName"))
                        .Replace("${mentions}", _roleMentions + _userMentions);
#if DEBUG
                    LogWarning($"DEBUG: {content}");
#endif

                    webrequest.Enqueue(_config.DiscordWebhook, content, (code, response) =>
                    {
#if DEBUG
                        LogWarning($"DEBUG: {_config.DiscordWebhook}");
                        if (!string.IsNullOrEmpty(response))
                        {
                            LogWarning($"DEBUG: {response}");
                        }
#endif
                        if (code != 204)
                        {
                            LogWarning($"Discord.com responded with code {code}");
                        }
                    }, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
                }

                if (_config.AutoReply)
                {
                    player.Reply(GetLang("AutoReply", player.Id));
                }
            }
        }
        private void OnBetterChat(Dictionary<string, object> data)
        {
            HandleChat(data["Player"] as IPlayer, data["Message"] as string);
        }

        private void OnUserChat(IPlayer player, string message) => HandleChat(player, message);

        #endregion Chat Handling

        #region Helpers

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void SendGuiNotification(IPlayer target, string notification)
        {
#if RUST
            if (_config.NotifyGuiAnnouncements && GUIAnnouncements != null && GUIAnnouncements.IsLoaded)
            {
                GUIAnnouncements.Call("CreateAnnouncement", notification, _config.GuiBannerColor, _config.GuiTextColor, target);
            }
            if (_config.NotifyUiNotify && UINotify != null && UINotify.IsLoaded)
            {
                UINotify.Call("SendNotify", target.Id, _config.UiNotifyType, notification);
            }
#endif
        }

        #endregion Helpers
    }
}

// --- End of file: Keywords.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/knock-knock ---
// --- Original File Path: K/KnockKnock/KnockKnock.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Knock Knock", "MisterPixie", "1.1.13")]
    [Description("Allows users to set messages on doors when someone knocks")]
    class KnockKnock : RustPlugin
    {
        public string KnockPerm = "knockknock.allow";
        public string KnockAutoPerm = "knockknock.auto.allow";
        List<string> doors = new List<string>()
        {
            "door.double.hinged.metal",
            "door.double.hinged.toptier",
            "door.double.hinged.wood",
            "door.hinged.metal",
            "door.hinged.toptier",
            "door.hinged.wood",
            "wall.frame.garagedoor"
        };

        #region Data
        Dictionary<ulong, KnockData> knockData = new Dictionary<ulong, KnockData>();

        private class KnockData
        {
            public bool EnableAutoMessages { get; set; }
            public string AutoMessage { get; set; }
            public Dictionary<int, KnockMessages> knockMessages { get; set; }
        }

        private class KnockMessages
        {
            public string Message { get; set; }
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("KnockData", knockData);
        }

        void OnServerSave()
        {
            SaveData();
        }

        #endregion

        #region Lang

        private string Lang(string key, string id = null, params object[] args) => configData.prefixs.UsePerfix ? string.Format(configData.prefixs.Prefix + lang.GetMessage(key, this, id), args) : string.Format(lang.GetMessage(key, this, id), args);

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You don't have permissions to run this command.",
                ["NoDoor"] = "Make sure you are looking at a door.",
                ["DontOwnDoor"] = "You don't own this door",
                ["MessageAdded"] = "New Message added to Door\n{0}",
                ["RemovedMessage"] = "Door Message Removed.",
                ["DoorMessage"] = "{0}",
                ["NoMessageOnDoor"] = "The door does not have a message set.",
                ["Commands"] = "List of Commands:\n/{0} add (Message) - Adds Message to your door\n/{0} remove - Removes door's message",
                ["PermCommands"] = "List of Commands:\n/{0} add (Message) - Adds Message to your door\n/{0} remove - Removes door's message\n/{0} auto - Turns on auto messages\n/{0} auto (Message) - Set's a message for auto message",
                ["AddCommand"] = "Incorrect Syntax - /{0} add (Message)",
                ["ToggleAutoOn"] = "Auto messages have been turned On",
                ["ToggleAutoOff"] = "Auto messages have been turned Off",
                ["AutoMessageSet"] = "Your Auto message has been set\n{0}"


            }, this);
        }
        #endregion

        private void Init()
        {
            LoadVariables();
            cmd.AddChatCommand(configData.Command, this, "KnockCommand");
            permission.RegisterPermission(KnockPerm, this);
            permission.RegisterPermission(KnockAutoPerm, this);
            knockData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, KnockData>>("KnockData");
            if (!configData.EnableAuto)
            {
                Unsubscribe("OnEntityBuilt");
            }
        }

        void Unload()
        {
            SaveData();
        }

        void OnNewSave()
        {
            foreach (var i in knockData)
            {
                i.Value.knockMessages.Clear();
            }
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();

            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, KnockPerm) || !permission.UserHasPermission(player.UserIDString, KnockAutoPerm))
                return;

            if (plan.GetDeployable() == null || !doors.Contains(plan.GetDeployable().hierachyName))
                return;

            KnockData value;

            if (!knockData.TryGetValue(player.userID, out value))
            {
                knockData.Add(player.userID, new KnockData()
                {
                    AutoMessage = string.Empty,
                    EnableAutoMessages = false,
                    knockMessages = new Dictionary<int, KnockMessages>()
                });
            }
            else
            {
                if (value.EnableAutoMessages)
                {
                    RaycastHit rhit;
                    if (!Physics.Raycast(player.eyes.HeadRay(), out rhit))
                    {
                        return;
                    }

                    var entity = rhit.GetEntity();

                    value.knockMessages.Add(entity.GetInstanceID(), new KnockMessages()
                    {
                        Message = value.AutoMessage
                    });
                }
            }

        }

        private void KnockCommand(BasePlayer player, string command, string[] args)
        {
            if (configData.permissions.UsePermission)
            {
                if (!permission.UserHasPermission(player.UserIDString, KnockPerm))
                {
                    SendReply(player, Lang("NoPermission", player.UserIDString));
                    return;
                }
            }

            KnockData knockvalue;

            if (!knockData.TryGetValue(player.userID, out knockvalue))
            {
                knockData.Add(player.userID, new KnockData()
                {
                    AutoMessage = "",
                    EnableAutoMessages = false,
                    knockMessages = new Dictionary<int, KnockMessages>()
                });
            }

            if (args.Length == 0)
            {
                if (configData.EnableAuto)
                {
                    if (permission.UserHasPermission(player.UserIDString, KnockAutoPerm))
                    {
                        SendReply(player, Lang("PermCommands", player.UserIDString, configData.Command));
                    }
                    else
                    {
                        SendReply(player, Lang("Commands", player.UserIDString, configData.Command));
                    }
                }
                else
                {
                    SendReply(player, Lang("Commands", player.UserIDString, configData.Command));
                }
            }
            else
            {
                if (configData.EnableAuto)
                {
                    if (args[0].ToLower() == "auto")
                    {
                        KnockAuto(player, args, knockvalue);
                        return;
                    }
                }

                var id = GetRaycast(player);

                if (id == null)
                    return;

                switch (args[0].ToLower())
                {
                    case "add":
                        KnockAdd(player, args, id.GetInstanceID(), knockvalue);
                        break;
                    case "remove":
                        KnockRemove(player, args, id.GetInstanceID(), knockvalue);
                        break;
                    default:
                        if (configData.EnableAuto)
                        {
                            if (permission.UserHasPermission(player.UserIDString, KnockAutoPerm))
                            {
                                SendReply(player, Lang("PermCommands", player.UserIDString, configData.Command));
                            }
                            else
                            {
                                SendReply(player, Lang("Commands", player.UserIDString, configData.Command));
                            }
                        }
                        else
                        {
                            SendReply(player, Lang("Commands", player.UserIDString, configData.Command));
                        }
                        break;
                }
            }
        }

        private void OnDoorKnocked(Door door, BasePlayer player)
        {
            KnockData knockvalue;
            KnockMessages knockmsgvalue;

            if (!knockData.TryGetValue(door.OwnerID, out knockvalue) || !knockvalue.knockMessages.TryGetValue(door.GetInstanceID(), out knockmsgvalue))
            {
                return;
            }

            SendReply(player, Lang("DoorMessage", player.UserIDString, knockmsgvalue.Message));
        }

        private void KnockAdd(BasePlayer player, string[] args, int id, KnockData value)
        {
            if (args.Length <= 1)
            {
                SendReply(player, Lang("AddCommand", player.UserIDString, configData.Command));
            }
            else
            {
                KnockMessages knockmsgvalue;

                string message = string.Join(" ", args.Skip(1).ToArray());
                if (!value.knockMessages.TryGetValue(id, out knockmsgvalue))
                {

                    value.knockMessages.Add(id, new KnockMessages()
                    {
                        Message = message
                    });

                    SendReply(player, Lang("MessageAdded", player.UserIDString, message));
                }
                else
                {
                    knockmsgvalue.Message = message;
                    SendReply(player, Lang("MessageAdded", player.UserIDString, message));
                }

                SaveData();
            }
        }

        private void KnockRemove(BasePlayer player, string[] args, int id, KnockData value)
        {
            if (value.knockMessages.ContainsKey(id))
            {
                value.knockMessages.Remove(id);
                SendReply(player, Lang("RemovedMessage", player.UserIDString));

                SaveData();
            }
            else
            {
                SendReply(player, Lang("NoMessageOnDoor", player.UserIDString));
            }
        }

        private void KnockAuto(BasePlayer player, string[] args, KnockData value)
        {
            if (!permission.UserHasPermission(player.UserIDString, KnockAutoPerm))
            {
                SendReply(player, Lang("NoPermission", player.UserIDString));
                return;
            }

            if (args.Length <= 1)
            {
                if (value.EnableAutoMessages)
                {
                    value.EnableAutoMessages = false;
                    SendReply(player, Lang("ToggleAutoOff", player.UserIDString));
                }
                else
                {
                    value.EnableAutoMessages = true;
                    SendReply(player, Lang("ToggleAutoOn", player.UserIDString));
                }
            }
            else
            {
                string message = string.Join(" ", args.Skip(1).ToArray());
                value.AutoMessage = message;
                SendReply(player, Lang("AutoMessageSet", player.UserIDString, message));
            }

            SaveData();
        }

        private BaseEntity GetRaycast(BasePlayer player)
        {
            RaycastHit rhit;
            if (!Physics.Raycast(player.eyes.HeadRay(), out rhit))
            {
                return null;
            }

            var entity = rhit.GetEntity();

            if (entity == null || !doors.Contains(entity.ShortPrefabName))
            {
                SendReply(player, Lang("NoDoor", player.UserIDString));
                return null;
            }

            if (entity.OwnerID != player.userID)
            {
                SendReply(player, Lang("DontOwnDoor", player.UserIDString));
                return null;
            }

            return entity;
        }

        #region Config

        private class Permissions
        {
            [JsonProperty(PropertyName = "Permission to use Auto Message Function")]
            public bool UseAutoPerm;

            [JsonProperty(PropertyName = "Permission to use Main Plugin Functions")]
            public bool UsePermission;
        }

        private class Prefixs
        {
            [JsonProperty(PropertyName = "Message Prefix")]
            public string Prefix;

            [JsonProperty(PropertyName = "Use Message Prefix")]
            public bool UsePerfix;
        }


        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission Settings")]
            public Permissions permissions;

            [JsonProperty(PropertyName = "Prefix Settings")]
            public Prefixs prefixs;

            [JsonProperty(PropertyName = "Enable Auto Function")]
            public bool EnableAuto;

            public string Command;
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                permissions = new Permissions
                {
                    UseAutoPerm = true,
                    UsePermission = true,
                },
                prefixs = new Prefixs
                {
                    Prefix = "<color=#cf4d4d>KnockKnock: </color>",
                    UsePerfix = false
                },
                EnableAuto = true,
                Command = "knock",
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}

// --- End of file: KnockKnock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-earthquake-panel ---
// --- Original File Path: M/MagicEarthquakePanel/MagicEarthquakePanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Earthquake Panel", "MJSU", "1.0.1")]
    [Description("Displays if the earthquake event is active")]
    public class MagicEarthquakePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, Earthquake;

        private PluginConfig _pluginConfig; //Plugin Config
        private int _activeEarthQuakes;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/9X78h9kC/iatpmwU.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.1f, 0.1f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }

            if (Earthquake == null)
            {
                PrintError("Missing plugin dependency Earthquake");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        
        private void CheckEvent()
        {
            if (_activeEarthQuakes == 0 || _activeEarthQuakes == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEarthquakeStarted));
            Unsubscribe(nameof(OnEarthquakeFinished));
        }
        #endregion

        #region Earthquake Hooks

        private void OnEarthquakeStarted()
        {
            _activeEarthQuakes++;
            CheckEvent();
        }

        private void OnEarthquakeFinished()
        {
            _activeEarthQuakes = Mathf.Min(0, _activeEarthQuakes - 1);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeEarthQuakes != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicEarthquakePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-teleporter ---
// --- Original File Path: M/MonumentTeleporter/MonumentTeleporter.cs ---

// Requires: MonumentFinder

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Monument Teleporter", "Iv Misticos", "1.0.1")]
    [Description("Teleport to monuments found with Monument Finder")]
    class MonumentTeleporter : CovalencePlugin
    {
        #region Variables

        private const string PermissionUse = "monumentteleporter.use";

        // ReSharper disable once InconsistentNaming
        [PluginReference]
        #pragma warning disable 649
        private Plugin MonumentFinder;
        #pragma warning restore 649
        
        #endregion
        
        #region Configuration
        
        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "mtp";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();
        
        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have enough permissions (monumentteleporter.use)"},
                {"Monument Not Found", "Monument not found"},
                {"Position Not Found", "Position to spawn not found"},
                {"Teleported", "You were teleported"},
                {"Only Players", "Only players are allowed to use this command"}
            }, this);
        }

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            
            AddCovalenceCommand(_config.Command, nameof(CommandTeleport));
        }
        
        #endregion
        
        #region Commands

        private void CommandTeleport(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionUse))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            if (player.Object == null)
            {
                player.Reply(GetMsg("Only Players", player.Id));
                return;
            }

            var filter = args == null || args.Length != 1 ? string.Empty : args[0];
            var monuments = MonumentFinder.Call<List<MonumentInfo>>("FindMonuments", filter);
            if (monuments == null || monuments.Count == 0)
            {
                player.Reply(GetMsg("Monument Not Found", player.Id));
                return;
            }
            
            var pos = monuments[0].transform.position;
            RaycastHit hit;
            if (!Physics.Raycast(new Ray(pos + Vector3.up * 10, Vector3.down), out hit))
            {
                player.Reply(GetMsg("Position Not Found", player.Id));
                return;
            }

            pos = hit.point;
            
            player.Teleport(pos.x, pos.y, pos.z);
            player.Reply(GetMsg("Teleported", player.Id));
        }
        
        #endregion
        
        #region Helpers

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: MonumentTeleporter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/minstrel ---
// --- Original File Path: M/Minstrel/Minstrel.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;

namespace Oxide.Plugins
{
    [Info("Minstrel", "4seti [Lunatiq] for Rust Planet", "0.0.7", ResourceId = 981)]
    public class Minstrel : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
                return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion

        void Loaded()
        {
            Log("Loaded");
        }

        #region VARS
        private static FieldInfo serverinput;
        Dictionary<string, List<TuneNote>> tuneDict;
        Dictionary<ulong, List<TuneNote>> tuneRecTemp;
        List<string> cfgTunes;
        #endregion

        // Loads the default configuration
        protected override void LoadDefaultConfig()
        {
            Log("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            Config["tunes"] = new List<string>();
            Config["version"] = Version;
        }

        void Init()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Instance | BindingFlags.NonPublic));
            try
            {
                LoadConfig();
                tuneRecTemp = new Dictionary<ulong, List<TuneNote>>();
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
                var savedTunes = GetConfig<List<object>>("tunes", new List<object>());
                tuneDict = new Dictionary<string,List<TuneNote>>();
                cfgTunes = new List<string>();
                foreach (var savedTune in savedTunes)
                {
                    cfgTunes.Add((string)savedTune);
                    List<TuneNote> loadTune;
                    if (LoadTune((string)savedTune, out loadTune))
                        tuneDict.Add((string)savedTune, loadTune);
                }

            }
            catch (Exception ex)
            {
                Error("Init failed: " + ex.Message);
            }
        }
        void Unload()
        {
            DestroyAll<KeyboardGuitar>();
        }
        private static void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (UnityEngine.Object gameObj in objects)
                    GameObject.Destroy(gameObj);
        }
        
        
        [ChatCommand("ms")]
        void cmdToggleMS(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (player.GetComponent<KeyboardGuitar>() == null)
            {
                player.gameObject.AddComponent<KeyboardGuitar>();
                player.ChatMessage("ON - Added");
                player.ChatMessage(BuildNoteList(2.9f, 0));
            }
            else
            {
                if (player.GetComponent<KeyboardGuitar>().enabled)
                {
                    player.ChatMessage("OFF");
                    player.GetComponent<KeyboardGuitar>().enabled = false;
                }
                else
                {
                    player.ChatMessage("ON");
                    player.GetComponent<KeyboardGuitar>().enabled = true;
                    player.ChatMessage(BuildNoteList(player.GetComponent<KeyboardGuitar>().adjust, player.GetComponent<KeyboardGuitar>().start));
                }
            }
        }

        private bool LoadTune(string tuneName, out List<TuneNote> list)
        {
            try
            {
				list = Interface.GetMod().DataFileSystem.ReadObject<List<TuneNote>>("ms-" + tuneName);				
                return true;                
            }
            catch (Exception ex)
            {
				list = new List<TuneNote>();
                return false;
            }
        }
        void SaveTune(string playerName, string tuneName, ulong userID)
        {
            Interface.GetMod().DataFileSystem.WriteObject<List<TuneNote>>("ms-" + tuneName, tuneRecTemp[userID]);
            Log("Tune " + tuneName + " saved by " + playerName);
        }

        private string BuildNoteList(float adjust, float start)
        {
            string noteList = string.Empty;
            for (int i = 1; i < 9; i++)
            {
                noteList += string.Format("{0}: {1:0.00} ", i, (i-1) / adjust + start);
            }
            return noteList;
        }

        [ChatCommand("ms_tune")]
        void cmdTune(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (!checkComponent(player)) return;
            if (args.Length == 0) return;
            if (tuneDict.ContainsKey(args[0]))
            {
				if (!player.GetComponent<KeyboardGuitar>().playingTune)
				{
					player.ChatMessage("Playing: " + args[0]);
					playTune(player, args[0]);
				}
				else
				{
					player.ChatMessage("Already playing");
				}
            }
            else
                player.ChatMessage("Tune doesn't exists: " + args[0]);
        }
        
        [ChatCommand("ms_rec")]
        void cmdRec(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (!checkComponent(player)) return;
            if (args.Length == 0)
            {
                if (!player.GetComponent<KeyboardGuitar>().Recording)
                {
                    player.GetComponent<KeyboardGuitar>().Recording = true;
                    player.ChatMessage("Recording started...");
                }
                else
                {
                    player.GetComponent<KeyboardGuitar>().Recording = false;
                    if (tuneRecTemp.ContainsKey(player.userID))
                        tuneRecTemp[player.userID] = player.GetComponent<KeyboardGuitar>().recTune;
                    else
                        tuneRecTemp.Add(player.userID, player.GetComponent<KeyboardGuitar>().recTune);
                    player.GetComponent<KeyboardGuitar>().recTune = null;
                    //foreach (var item in playbackTune)
                    //{
                    //    player.ChatMessage(string.Format("NoteScale: {0:N2} - Delay: {1:N2}", item.NoteScale, item.Delay));
                    //}                    
                    player.ChatMessage("Recording stoped!");
                    player.ChatMessage(string.Format("Notes: {0} - Length: {1:N2}", tuneRecTemp[player.userID].Count, tuneRecTemp[player.userID].Sum(x => x.Delay)));
                }
            }
            else if (args.Length > 1 && !player.GetComponent<KeyboardGuitar>().Recording)
            {
                if (args[0] == "save")
                {
                    string tuneName = args[1];
                    if (!tuneRecTemp.ContainsKey(player.userID))
                    {
                        player.ChatMessage("Nothing to save!");
                    }
                    else
                    {
                        SaveTune(player.displayName, tuneName, player.userID);
                        if (tuneDict.ContainsKey(tuneName)) tuneDict.Remove(tuneName);
                        tuneDict.Add(tuneName, tuneRecTemp[player.userID]);
                        player.ChatMessage("Tune " + tuneName + " saved!");
                        cfgTunes.Add(tuneName);
                        Config["tunes"] = cfgTunes;
                        SaveConfig();
                        tuneRecTemp.Remove(player.userID);
                    }
                }
            }

        }
        void playTune(BasePlayer player, string tuneName)
        {
            player.GetComponent<KeyboardGuitar>().curTune = tuneDict[tuneName];
            player.GetComponent<KeyboardGuitar>().PlayTune();            
        }

        private bool checkComponent(BasePlayer player)
        {
            if (player.GetComponent<KeyboardGuitar>() == null)
            {
                player.ChatMessage("You have " + Title + " disabled!");
                return false;
            }
            return true;
        }

        List<object> getTune(string tuneName)
        {
            if (!tuneDict.ContainsKey(tuneName)) return null;
            var tunes = new List<object>();
            foreach (TuneNote note in tuneDict[tuneName])
            {
                var tunenote = new Dictionary<string, object>();
                tunenote.Add("NoteScale", note.NoteScale);
                tunenote.Add("Delay", note.Delay);
                tunenote.Add("Pluck", note.Pluck);
                tunes.Add(tunenote);
            }
            return tunes;
        }

        [ChatCommand("ms_adj")]
        void cmdMSAdjust(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;

            if (!checkComponent(player))
            {
                player.ChatMessage("Turn it ON, before using this");
            }
            else
            {
                if (player.GetComponent<KeyboardGuitar>().enabled)
                {
                    float adjust;
                    if (float.TryParse(args[0], out adjust))
                    {
                        player.GetComponent<KeyboardGuitar>().adjust = adjust;
                        player.ChatMessage(string.Format("Adjusted to: {0:N2}", adjust));
                    }
                    if (args.Length > 1)
                    {
                        float start;
                        if (float.TryParse(args[1], out start))
                        {
                            player.GetComponent<KeyboardGuitar>().start = start;
                            player.ChatMessage(string.Format("Start set to: {0:N2}", start));
                        }
                    }
                    player.ChatMessage(BuildNoteList(player.GetComponent<KeyboardGuitar>().adjust, player.GetComponent<KeyboardGuitar>().start));
                }
                else
                {
                    player.ChatMessage("Turn it ON, before using this");               
                }
            }
        }

        [ChatCommand("ms_list")]
        void cmdMSList(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (tuneDict.Count > 0)
            {
                player.ChatMessage("List of tunes avaliable");
                foreach (var tune in tuneDict)
                {
                    player.ChatMessage(string.Format("Name: {0}, Duration: {1:N2} seconds", tune.Key, tune.Value.Sum(x => x.Delay)));
                }
            }
            else
                player.ChatMessage("List of tunes is EMPTY");
        }

        [ChatCommand("ms_rel")]
        void cmdMSReload(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;
            List<TuneNote> tune;
            if (LoadTune(args[0], out tune))
            {
                if (tuneDict.ContainsKey(args[0]))
                {
                    tuneDict[args[0]] = tune;
                    player.ChatMessage("Reloaded: " + args[0]);
                }
                else
                {
                    tuneDict.Add(args[0], tune);
                    cfgTunes.Add(args[0]);
                    Config["tunes"] = cfgTunes;
                    SaveConfig();
                    player.ChatMessage("Tune: " + args[0] + " was added to playlist");
                }
            }
            else
            {
                player.ChatMessage("File not found!");
            }
        }

        [ChatCommand("ms_del")]
        void cmdMSDelete(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (args.Length == 0) return;
            List<TuneNote> tune;
            if (LoadTune(args[0], out tune))
            {
                if (tuneDict.ContainsKey(args[0]))
                {
                    cfgTunes.Remove(args[0]);
                    Config["tunes"] = cfgTunes;
                    SaveConfig();
                    tuneDict.Remove(args[0]);
                    player.ChatMessage("Removed from loadup: " + args[0] + " remove file in /data/ folder manually");
                }
                else
                {
                    player.ChatMessage("Tune wasn't added to loadup, but file exists!");
                }
            }
            else
            {
                player.ChatMessage("File not found!");
            }
        }

		[ChatCommand("msp")]
		void cmdMSPluck(BasePlayer player, string cmd, string[] args)
		{
			if (player.net.connection.authLevel == 0) return;
			if (args.Length == 0) return;
			if (!checkComponent(player))
			{
				player.ChatMessage("Turn it ON, before using this");
			}
			else
			{
				if (player.GetComponent<KeyboardGuitar>().enabled)
				{
					float scale;
					float repeat = 1;
					if (args.Length > 1)
						float.TryParse(args[1], out repeat);

                    if (float.TryParse(args[0], out scale))
					{
						List<TuneNote> repeatNote = new List<TuneNote>();
						for (int i = 0; i < repeat; i++)
						{
							repeatNote.Add(new TuneNote(scale, 2f));
                        }
						player.GetComponent<KeyboardGuitar>().curTune = repeatNote;
						if (!player.GetComponent<KeyboardGuitar>().playingTune)
						{
							player.GetComponent<KeyboardGuitar>().PlayTune();
							player.ChatMessage(string.Format("Note playing: {0:N2} - {1} times", scale, repeat));
						}
						else
							player.ChatMessage("Already playing");
					}					
				}
				else
				{
					player.ChatMessage("Turn it ON, before using this");
				}
			}
		}

		public class KeyboardGuitar : MonoBehaviour
        {
            private static float noteTime = 0.1f;

            public float adjust, start, NextTimeToPress, noteToPlay;
            private InputState input;
            public bool Recording = false;
            public BasePlayer owner;
            public List<TuneNote> recTune;
            public float nextNoteTime;
            //private TuneNote prevNote;
            Effect effectP = new Effect("fx/gestures/guitarpluck", new Vector3(0, 0, 0), Vector3.forward);
            Effect effectS = new Effect("fx/gestures/guitarstrum", new Vector3(0, 0, 0), Vector3.forward);
            void Awake()
            {
                owner = GetComponent<BasePlayer>();
                input = serverinput.GetValue(owner) as InputState;
                //enabled = false;
                adjust = 2.9f;
                NextTimeToPress = 0f;
                start = 0f;
            }
            void FixedUpdate()
            {
                float time = Time.realtimeSinceStartup;
                if (input.current.buttons != input.previous.buttons && input.current.buttons != 0 && NextTimeToPress < time)
                {
                    float num_shift = input.WasDown(BUTTON.SPRINT) ? 0.2f : 0;
                    bool Strum = input.WasDown(BUTTON.DUCK);
                        //fx/gestures/guitarstrum
                    NextTimeToPress = time + noteTime;
                    float num = (float)Math.Log((input.current.buttons / 262144), 2) / adjust + num_shift + start;
                    //owner.ChatMessage(num.ToString("N2"));
                    if (float.IsInfinity(num)) return;
                    if (num > 7) num = 7;
                    else if (num < -2) num = -2;
                    if (!Strum)
                    {
                        effectP.worldPos = transform.position;
                        effectP.origin = transform.position;
                        effectP.scale = num;
                        EffectNetwork.Send(effectP);
                    }
                    else
                    {
                        effectS.worldPos = transform.position;
                        effectS.origin = transform.position;
                        effectS.scale = num;
                        EffectNetwork.Send(effectS);
                    }
                    if (Recording)
                    {
                        if (recTune == null) recTune = new List<TuneNote>();
                        if (recTune.Count == 0)
                        {
                            recTune = new List<TuneNote>();
                            TuneNote curNote = new TuneNote(num, 0f, !Strum);
                            recTune.Add(curNote);
                            nextNoteTime = time;
                        }
                        else
                        {
                            recTune[recTune.Count - 1].Delay = time - nextNoteTime;
                            TuneNote curNote = new TuneNote(num, 0f, !Strum);
                            recTune.Add(curNote);
                            nextNoteTime = time;
                        }
                    }
                }   
            }

			public void PlayNote(float scale)
			{				
					effectP.worldPos = transform.position;
					effectP.origin = transform.position;
					effectP.scale = scale;
					EffectNetwork.Send(effectP);
			}

			public List<TuneNote> curTune;
			private Stack<TuneNote> tuneToPlay;
            public bool playingTune = false;
			private TuneNote nextNote;
			public void PlayTune()
			{
				tuneToPlay = new Stack<TuneNote>();
				foreach (var note in curTune.Reverse<TuneNote>())				
					tuneToPlay.Push(note);


				curTune = new List<TuneNote>();
				if (tuneToPlay.Count > 0)
				{
					nextNote = tuneToPlay.Pop();
					if (!playingTune)
						PlayTuneStack();
				}
            }
            private void PlayTuneStack()
            {
                if (!playingTune) playingTune = true;
                if (nextNote.Pluck)
                {
                    effectP.worldPos = transform.position;
                    effectP.origin = transform.position;
                    effectP.scale = nextNote.NoteScale;
                    EffectNetwork.Send(effectP);
                }
                else
                {
                    effectS.worldPos = transform.position;
                    effectS.origin = transform.position;
                    effectS.scale = nextNote.NoteScale;
                    EffectNetwork.Send(effectS);
                }
                if (tuneToPlay.Count > 0 && enabled)
                {					
					Invoke("PlayTuneStack", nextNote.Delay);
					nextNote = tuneToPlay.Pop();
				}
                else
                {
					if (!enabled)
						tuneToPlay = new Stack<TuneNote>();
					playingTune = false;
                }
            }
        }
        public class TuneNote
        {
            public float NoteScale, Delay;
            public bool Pluck;
            public TuneNote(float note, float delay, bool pluck = true)
            {
                NoteScale = note;
                Delay = delay;
                Pluck = pluck;
            }
        }
    }
}

// --- End of file: Minstrel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/movable-cctv ---
// --- Original File Path: M/MovableCCTV/MovableCCTV.cs ---

/*
 * Copyright (c) 2023 Bazz3l
 *
 * Moveable CCTV a cannot be copied, edited and/or (re)distributed without the express permission of Bazz3l.
 * Discord bazz3l
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Movable CCTV", "Bazz3l", "1.1.2")]
    [Description("Allow players to control placed cctv cameras using WASD")]
    internal class MovableCCTV : CovalencePlugin
    {
        #region Fields

        private const string PERM_USE = "movablecctv.use";
        private static MovableCCTV _plugin;
        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = new PluginConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null) throw new JsonException();
                
                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Config was updated");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning("Invalid config, default config has been loaded.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            public float RotateSpeed = 0.2f;
            public string TextColor = "1 1 1 0.5";
            public int TextSize = 14;
            public string AnchorMin = "0.293 0.903";
            public string AnchorMax = "0.684 0.951";

            public string ToJson() => JsonConvert.SerializeObject(this);
            
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }
        
        #endregion

        #region Lang
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Description", "Control the camera using WASD" }
            }, this);
        }
        
        #endregion

        #region Oxide Hooks

        private void OnServerInitialized() => CheckCctv();

        private void Init()
        {
            permission.RegisterPermission(PERM_USE, this);
            
            _plugin = this;
        }
        
        private void Unload()
        {
            CctvCamMover.RemoveAll();
            UI.RemoveAll();
            
            _plugin = null;
        }

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            var cctvRc = go.ToBaseEntity() as CCTV_RC;
            if (cctvRc != null && !cctvRc.IsStatic())
                cctvRc.hasPTZ = true;
        }

        private void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, IRemoteControllable entity)
        {
            if (!HasPermission(player))
                return;
            
            UI.RemoveUI(player);
            
            var cctvRc = entity as CCTV_RC;
            if (cctvRc == null|| cctvRc.IsStatic() || cctvRc.rcControls != RemoteControllableControls.None || BecomeMovableWasBlocked(cctvRc, player))
                return;
            
            player.GetOrAddComponent<CctvCamMover>();
            
            UI.CreateUI(player, Lang("Description", player.UserIDString));
        }
        
        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, CCTV_RC cctvRc)
        {
            if (!HasPermission(player))
                return;
            
            if (player.HasComponent<CctvCamMover>())
                player.GetComponent<CctvCamMover>()?.DestroyImmediate();
            
            UI.RemoveUI(player);
        }
        
        #endregion

        #region Cctv Cam Mover

        private void CheckCctv()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var cctv = entity as CCTV_RC;
                if (cctv != null && !cctv.IsStatic())
                    cctv.hasPTZ = true;
            }
        }
        
        private class CctvCamMover : MonoBehaviour
        {
            public static void RemoveAll()
            {
                foreach (var player in BasePlayer.activePlayerList)
                    player.GetComponent<CctvCamMover>()?.DestroyMe();
            }
            
            private ComputerStation _station;
            private BasePlayer _player;

            private void Awake()
            {
                _player = GetComponent<BasePlayer>();
                _station = _player.GetMounted() as ComputerStation;
            }

            private void FixedUpdate()
            {
                var cctvRc = GetControlledCctv(_station);
                if (cctvRc == null || cctvRc.IsStatic())
                    return;

                var y = _player.serverInput.IsDown(BUTTON.FORWARD) ? 1f : (_player.serverInput.IsDown(BUTTON.BACKWARD) ? -1f : 0f);
                var x = _player.serverInput.IsDown(BUTTON.LEFT) ? -1f : (_player.serverInput.IsDown(BUTTON.RIGHT) ? 1f : 0f);

                var inputState = new InputState();
                inputState.current.mouseDelta.y = y * _plugin._config.RotateSpeed;
                inputState.current.mouseDelta.x = x * _plugin._config.RotateSpeed;
                
                cctvRc.UserInput(inputState, new CameraViewerId(_player.userID, 0));
            }

            public void DestroyMe() => Destroy(this);
            
            public void DestroyImmediate() => DestroyImmediate(this);

            private CCTV_RC GetControlledCctv(ComputerStation computerStation)
            {
                if (computerStation == null || computerStation.IsDestroyed)
                    return null;
                
                return computerStation.currentlyControllingEnt.Get(serverside: true) as CCTV_RC;
            }
        }
        
        #endregion

        #region UI

        private static class UI
        {
            private const string PANEL_NAME = "MovableCCTV";

            public static void CreateUI(BasePlayer player, string description = "")
            {
                CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiPanel {
                    Image =
                    {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = _plugin._config.AnchorMin,
                        AnchorMax = _plugin._config.AnchorMax
                    }
                }, "Overlay", PANEL_NAME);
                
                container.Add(new CuiLabel
                {
                    Text = {
                        FontSize = _plugin._config.TextSize,
                        Color = _plugin._config.TextColor,
                        Text  = description,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }, PANEL_NAME);
                
                CuiHelper.AddUi(player, container);
            }
            
            public static void RemoveUI(BasePlayer player) => CuiHelper.DestroyUi(player, PANEL_NAME);

            public static void RemoveAll()
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    RemoveUI(player);
            }
        }
        
        #endregion

        #region Helpers

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        
        private bool HasPermission(BasePlayer player) => permission.UserHasPermission(player.UserIDString, PERM_USE);
        
        private bool BecomeMovableWasBlocked(CCTV_RC cctvRc, BasePlayer player)
        {
            object hookResult = Interface.CallHook("OnCCTVMovableBecome", cctvRc, player);
            return hookResult is bool && (bool)hookResult == false;
        }
        
        #endregion
    }
}


// --- End of file: MovableCCTV.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/minicopter-seating ---
// --- Original File Path: M/MinicopterSeating/MinicopterSeating.cs ---

/*
 * Copyright (c) 2022 Bazz3l
 *
 * Minicopter Seating cannot be copied, edited and/or (re)distributed without the express permission of Bazz3l.
 * Discord bazz3l
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Minicopter Seating", "Bazz3l", "1.1.7")]
    [Description("Spawn extra seats on each side of the minicopter.")]
    internal class MinicopterSeating : RustPlugin
    {
        #region Fields
        
        private readonly GameObjectRef _gameObjectSeat = new GameObjectRef { guid = "dc329880dec7ab343bc454fd969d5709" };

        private readonly Vector3 _seat1 = new Vector3(0.6f, 0.2f, -0.3f);
        private readonly Vector3 _seat2 = new Vector3(-0.6f, 0.2f, -0.3f);

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized() => Subscribe("OnEntitySpawned");

        private void Init() => Unsubscribe("OnEntitySpawned");

        private void OnEntitySpawned(Minicopter copter)
        {
            if (copter == null || copter.IsDestroyed || copter.mountPoints == null || copter is ScrapTransportHelicopter)
                return;
            
            if (copter.mountPoints.Count >= 4)
                return;

            SetupSeating(copter);
        }

        #endregion

        #region Core

        private void SetupSeating(BaseVehicle vehicle)
        {
            vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints[1], _seat1));
            vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints[1], _seat2));
        }

        private BaseVehicle.MountPointInfo CreateMount(BaseVehicle.MountPointInfo mountPoint, Vector3 position)
        {
            return new BaseVehicle.MountPointInfo
           {
               pos = position,
               rot = mountPoint.rot,
               prefab = _gameObjectSeat,
               mountable = mountPoint.mountable,
           };
        }

        #endregion
    }
}

// --- End of file: MinicopterSeating.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-message-panel ---
// --- Original File Path: M/MagicMessagePanel/MagicMessagePanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Message Panel", "MJSU", "1.2.1")]
    [Description("Displays messages in magic panel")]
    public class MagicMessagePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, PlaceholderAPI;

        private DynamicConfigFile _newConfig;
        private PluginConfig _pluginConfig; //Plugin Config

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        private enum State {In, NotIn}
        
        private readonly Hash<ulong, int> _playerIndex = new Hash<ulong, int>();
        private readonly Hash<ulong, string> _playerLastMessage = new Hash<ulong, string>();
        
        private Action<IPlayer, StringBuilder, bool> _replacer;
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            _newConfig = new DynamicConfigFile(path);
            if (!_newConfig.Exists())
            {
                LoadDefaultConfig();
                _newConfig.Save();
            }
            try
            {
                _newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            _newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(_newConfig.ReadObject<PluginConfig>());
            _newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panels = config.Panels ?? new Hash<string, PanelData>
            {
                [$"{Name}_1"] = new PanelData
                {
                    Panel = new Panel
                    {
                        Text = new PanelText
                        {
                            Enabled = true,
                            Color = "#FFFFFFFF",
                            Order = 1,
                            Width = 1f,
                            FontSize = 14,
                            Padding = new TypePadding(0.05f, 0.05f, 0.1f, 0.00f),
                            TextAnchor = TextAnchor.MiddleCenter,
                            Text = ""
                        }
                    },
                    PermMessages = new List<MessageGroupData>
                    {
                        new MessageGroupData
                        {
                            Enabled = true,
                            GroupOrPerm = "default",
                            State = State.In,
                            Messages = new List<string>
                            {
                               "You must be in the default group to see this message"
                            }
                        },
                        new MessageGroupData
                        {
                            Enabled = true,
                            GroupOrPerm = "VIP",
                            State = State.NotIn,
                            Messages = new List<string>
                            {
                                "Messages here for players not in VIP group or perm"
                            }
                        }
                    },
                    PanelSettings = new PanelRegistration
                    {
                        BackgroundColor = "#FFF2DF08",
                        Dock = "bottom",
                        Order = 0,
                        Width = 0.2954f
                    },
                    UpdateRate = 15f,
                    Enabled = true
                }
            };
            
            return config;
        }

        private void OnServerInitialized()
        {
            //*****BEGIN TEMPORARY REMOVE AFTER 02/03/2021
            bool changed = false;
            foreach (PanelData panel in _pluginConfig.Panels.Values)
            {
                if (panel.ShouldSerializeMessages())
                {
                    panel.PermMessages = new List<MessageGroupData>
                    {
                        new MessageGroupData
                        {
                            Messages =  panel.Messages,
                            Enabled = true,
                            GroupOrPerm = "default",
                            State = State.In
                        }
                    };

                    changed = true;
                }
            }
            
            if (changed)
            {
                _newConfig.WriteObject(_pluginConfig);
            }
            //*****END TEMPORARY REMOVE AFTER 02/03/2021
            
            MagicPanelRegisterPanels();
            
            foreach (IGrouping<float, KeyValuePair<string, PanelData>> panelUpdates in _pluginConfig.Panels.Where(p => p.Value.Enabled).GroupBy(p => p.Value.UpdateRate))
            {
                timer.Every(panelUpdates.Key, () =>
                {
                    foreach (KeyValuePair<string, PanelData> data in panelUpdates)
                    {
                        MagicPanel?.Call("UpdatePanel", data.Key, (int)UpdateEnum.Text);
                    }
                });
            }
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            foreach (KeyValuePair<string, PanelData> panel in _pluginConfig.Panels)
            {
                if (!panel.Value.Enabled)
                {
                    continue;
                }
                
                MagicPanel?.Call("RegisterPlayerPanel", this, panel.Key, JsonConvert.SerializeObject(panel.Value.PanelSettings), nameof(GetPanel));
            }
        }
        #endregion

        #region MagicPanel Hook
        private List<string> GetPlayerMessages(BasePlayer player, string panelName)
        {
            PanelData panel = _pluginConfig.Panels[panelName];
            List<string> messages = new List<string>();

            foreach (MessageGroupData data in panel.PermMessages)
            {
                if (data.State == State.In ? InPermOrGroup(player, data.GroupOrPerm) : !InPermOrGroup(player, data.GroupOrPerm))
                {
                    messages.AddRange(data.Messages);
                }
            }

            return messages;
        }

        private bool InPermOrGroup(BasePlayer player, string permGroup)
        {
            return permission.UserHasPermission(player.UserIDString, permGroup) || permission.UserHasGroup(player.UserIDString, permGroup);
        }
        
        private Hash<string, object> GetPanel(BasePlayer player, string panelName)
        {
            PanelData panelData = _pluginConfig.Panels[panelName];
            Panel panel = panelData.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                List<string> playerMessages = GetPlayerMessages(player, panelName);
                if (playerMessages.Count == 0)
                {
                    text.Text = string.Empty;
                }
                else if (playerMessages.Count == 1)
                {
                    text.Text = playerMessages[0];
                }
                else if (panelData.RandomOrder)
                {
                    string previous = _playerLastMessage[player.userID];
                    text.Text = playerMessages.Where(m => previous != m)
                        .Skip(Random.Range(0, playerMessages.Count - 1))
                        .FirstOrDefault();
                    _playerLastMessage[player.userID] = text.Text;
                }
                else
                {
                    int index = _playerIndex[player.userID];
                    index = (index + 1) % playerMessages.Count;
                    text.Text = playerMessages[index];
                    _playerIndex[player.userID] = index;
                }

                text.Text = ParseText(text.Text);
            }

            return panel.ToHash();
        }
        #endregion
        
        #region PlaceholderAPI
        private string ParseText(string text)
        {
            Action<IPlayer, StringBuilder, bool> replacer = GetReplacer();
            if (replacer == null)
            {
                return text;
            }
            
            StringBuilder sb = new StringBuilder(text);

            replacer.Invoke(null, sb, false);

            return sb.ToString();
        }
        
        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin?.Name == "PlaceholderAPI")
            {
                _replacer = null;
            }
        }

        private Action<IPlayer, StringBuilder, bool> GetReplacer()
        {
            if (!IsPlaceholderApiLoaded())
            {
                return _replacer;
            }
            
            return _replacer ?? (_replacer = PlaceholderAPI.Call<Action<IPlayer, StringBuilder, bool>>("GetProcessPlaceholders", 1));
        }

        private bool IsPlaceholderApiLoaded() => PlaceholderAPI != null && PlaceholderAPI.IsLoaded;
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Message Panels")]
            public Hash<string, PanelData> Panels { get; set; }
        }

        private class PanelData
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }
            
            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
            
            [JsonProperty(PropertyName = "Messages to all players")]
            public List<string> Messages { get; set; }

            [JsonProperty(PropertyName = "Perm or Group messages")]
            public List<MessageGroupData> PermMessages = new List<MessageGroupData>();

            [JsonProperty(PropertyName = "Random Message Display Order")]
            public bool RandomOrder { get; set; }
            
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }
            
            public bool ShouldSerializeMessages()
            {
                return Messages != null && Messages.Count > 0;
            }
        }

        private class MessageGroupData
        {
            [JsonProperty(PropertyName = "Messages")]
            public List<string> Messages { get; set; }
            
            [JsonProperty(PropertyName = "Group or Permission")]
            public string GroupOrPerm { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Player Group or Permission State (In, NotIn)")]
            public State State { get; set; }
            
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicMessagePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-loot ---
// --- Original File Path: M/MagicLoot/MagicLoot.cs ---

using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;

namespace Oxide.Plugins
{
    [Info("Magic Loot", "collect_vood", "1.0.5")]
    [Description("Simple components multiplier and loot system")]
    public class MagicLoot : CovalencePlugin
    {
        #region Fields

        private bool _initialized = false;

        private readonly int _maxContainerSlots = 18;

        private int _scrapStack;

        private Dictionary<Rarity, List<string>> _sortedRarities;

        private Dictionary<int, List<ulong>> _skinsCache = new Dictionary<int, List<ulong>>();

        private Dictionary<LootSpawn, ItemAmountRanged[]> _originItemAmountRange = new Dictionary<LootSpawn, ItemAmountRanged[]>();

        #endregion

        #region Configuration

        private ConfigurationFile _configuration;

        public class ConfigurationFile
        {
            [JsonProperty(PropertyName = "General Settings")]
            public SettingsFile Settings = new SettingsFile();

            [JsonProperty(PropertyName = "Extra Loot")]
            public ExtraLootFile ExtraLoot = new ExtraLootFile();

            [JsonProperty(PropertyName = "Blacklisted Items (Item-Shortnames)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> BlacklistedItems = new List<string>()
            { 
                "ammo.rocket.smoke"
            };            
            
            [JsonProperty(PropertyName = "Blacklisted Workshop Skins (Workshop Ids)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> BlacklistSkins = new List<ulong>()
            {
                10180
            };

            [JsonProperty(PropertyName = "Manual Item Multipliers (Key: Item-Shortname, Value: Multiplier)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> ManualItemMultipliers = new Dictionary<string, float>();

            [JsonProperty(PropertyName = "Containers Data (Key: Container-Shortname, Value: Container Settings)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, ContainerData> ContainersData = new Dictionary<string, ContainerData>();

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        public class SettingsFile
        {
            [JsonProperty(PropertyName = "General Item List Multiplier (All items in the 'Manual Item Multipliers' List)")]
            public float ItemListMultiplier = 1f;

            [JsonProperty(PropertyName = "Non Item List Multiplier (All items not listed in the 'Manual Item Multipliers' List)")]
            public float NonItemListMultiplier = 1f;

            [JsonProperty(PropertyName = "Limit Multipliers to Stacksizes")]
            public bool LimitToStacksizes = true;

            [JsonProperty(PropertyName = "Multiply Blueprints")]
            public bool BlueprintDuplication = false;              
            
            [JsonProperty(PropertyName = "Disable Blueprint Drops")]
            public bool DisableBlueprints = false;            
            
            [JsonProperty(PropertyName = "Random Workshop Skins")]
            public bool RandomWorkshopSkins = false;            
            
            [JsonProperty(PropertyName = "Multiply Tea Buffs")]
            public bool MultiplyTeaBuff = false;            
            
            [JsonProperty(PropertyName = "Force Custom Loot Tables for Default Loot on all Containers")]
            public bool ForceCustomLootTables = false;
        }

        public class ExtraLootFile
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled = false;

            [JsonProperty(PropertyName = "Extra Items Min")]
            public int ExtraItemsMin = 0;

            [JsonProperty(PropertyName = "Extra Items Max")]
            public int ExtraItemsMax = 0;

            [JsonProperty(PropertyName = "Prevent Duplicates")]
            public bool PreventDuplicates = true;

            [JsonProperty(PropertyName = "Prevent Duplicates Retries")]
            public int PreventDuplicatesRetries = 10;

            [JsonProperty(PropertyName = "Force Custom Loot Tables for Extra Loot on all Containers")]
            public bool ForceCustomLootTables = false;
        }

        public class ContainerData
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled = true;

            [JsonProperty(PropertyName = "Extra Items Min")]
            public int ExtraItemsMin = 0;

            [JsonProperty(PropertyName = "Extra Items Max")]
            public int ExtraItemsMax = 0;

            [JsonProperty(PropertyName = "Loot Multiplier")]
            public float Multiplier = 1f;

            [JsonProperty(PropertyName = "Utilize Vanilla Loot Tables on Default Loot")]
            public bool VanillaLootTablesDefault = true;            
            
            [JsonProperty(PropertyName = "Utilize Vanilla Loot Tables on Extra Loot")]
            public bool VanillaLootTablesExtra = true;

            [JsonProperty(PropertyName = "Utilize Random Rarity (depending on Items ALREADY in the container)")]
            public bool RandomRarities = true;

            [JsonProperty(PropertyName = "Rarity To Use (ONLY if 'Utilize Vanilla Loot Tables' is FALSE & 'Utilize Random Rarity' is FALSE | 0 = None, 1 = Common, 2 = Uncommon, 3 = Rare, 4 = Very Rare)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Rarity> Rarities = new List<Rarity>() { Rarity.Common, Rarity.Uncommon, Rarity.Rare, Rarity.VeryRare };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");

            _configuration = new ConfigurationFile();

            foreach (var itemDef in ItemManager.itemList)
            {
                if (itemDef.category != ItemCategory.Component)
                {
                    continue;
                }

                _configuration.ManualItemMultipliers.Add(itemDef.shortname, 1f);
            }
    
            _configuration.ManualItemMultipliers.Add("scrap", 1f);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);

        #endregion

        #region Data

        private void LoadData()
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<DataFile>(Name);

            int count = 0;
            foreach (var item in ItemManager.itemList)
            {
                if (_data.Items.ContainsKey(item.shortname))
                {
                    continue;
                }

                _data.Items.Add(item.shortname, item.stackable);
                count++;
            }

            SaveData();

            if (count > 0)
            {
                Puts($"Added {count} new items to the item list!");
            }

            //Determine if rarity system is needed
            if (_configuration.Settings.ForceCustomLootTables || _configuration.ExtraLoot.ForceCustomLootTables)
            {
                _sortedRarities = GetSortedRarities();
            }
            else
            {
                foreach (var container in _configuration.ContainersData)
                {
                    if (!container.Value.VanillaLootTablesDefault
                        || !container.Value.VanillaLootTablesExtra)
                    {
                        _sortedRarities = GetSortedRarities();
                        break;
                    }
                }
            }

            _scrapStack = _data.Items["scrap"];
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private DataFile _data;

        public class DataFile
        {
            [JsonProperty(PropertyName = "Item Data (Key: Item Shortname, Value: Stacksize)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> Items = new Dictionary<string, int>();
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            _initialized = true;

            if (!_configuration.Settings.MultiplyTeaBuff)
            {
                Unsubscribe(nameof(OnBonusItemDrop));
            }

            LoadData();

            ModifyItemAmountRanges();

            AddMissingContainers();

            Puts($"Loaded at x{_configuration.Settings.NonItemListMultiplier} vanilla rate" +
                $" | Manual Item List at x{_configuration.Settings.ItemListMultiplier} rate [Extra Loot: {_configuration.ExtraLoot.Enabled}, Multiply Tea Buffs: {_configuration.Settings.MultiplyTeaBuff}]");

            RepopulateContainers(); 
        }

        private object OnLootSpawn(LootContainer container)
        {
            if (!_initialized || container?.inventory?.itemList == null)
            {
                return null;
            }
            
            ContainerData containerData;
            if (!_configuration.ContainersData.TryGetValue(container.ShortPrefabName, out containerData))
            {
                _configuration.ContainersData.Add(container.ShortPrefabName, containerData = new ContainerData());
                SaveConfig();
            }

            if (IgnoreContainer(containerData))
            {
                return null;
            }

            PopulateContainer(container, containerData);

            if (container.shouldRefreshContents && container.isLootable)
            {
                container.Invoke(new Action(container.SpawnLoot), UnityEngine.Random.Range(
                    container.minSecondsBetweenRefresh, container.maxSecondsBetweenRefresh));
            }

            return container;
        }

        private void OnBonusItemDrop(Item item, BasePlayer player)
        {
            ReinforceRules(item, null);
        }

        private void Unload()
        {
            _initialized = false;

            RestoreItemAmountRanges();

            foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>())
            {
                if (container?.inventory == null)
                {
                    continue;
                }

                container.SpawnLoot();
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Adds missing containers to the configuration file
        /// </summary>
        private void AddMissingContainers()
        {
            int count = 0;
            foreach (var container in UnityEngine.Resources.FindObjectsOfTypeAll<LootContainer>())
            {
                if (!container.enabled)
                {
                    continue;
                }

                ContainerData containerData;
                if (_configuration.ContainersData.TryGetValue(container.ShortPrefabName, out containerData))
                {
                    continue;
                }

                _configuration.ContainersData.Add(container.ShortPrefabName, containerData = new ContainerData());

                count++;
            }

            if (count > 0)
            {
                Puts($"Added {count} missing containers to the config file.");
            }            
        }

        /// <summary>
        /// Repopulates all LootContainers
        /// </summary>
        private void RepopulateContainers()
        {
            int count = 0;
            foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>())
            {
                var containerData = _configuration.ContainersData[container.ShortPrefabName];
                
                if (IgnoreContainer(containerData))
                {
                    continue;
                }

                container.inventory.Clear();
                ItemManager.DoRemoves();

                PopulateContainer(container, containerData);

                count++;
            }
           
            SaveConfig();

            Puts("Repopulated " + count.ToString() + " loot containers.");
        }

        /// <summary>
        /// Populates the Container
        /// </summary>
        /// <param name="container"></param>
        /// <param name="containerData"></param>
        private void PopulateContainer(LootContainer container, ContainerData containerData)
        {
            container.inventory.capacity = _maxContainerSlots;

            AddDefaultLoot(container, containerData);

            AddExtraLoot(container, containerData);

            RandomizeDurability(container);

            //Generate scrap late so it is in the last slot
            if (_scrapStack > 0)
            {
                container.GenerateScrap();
            }
           
            ReinforceRules(container, containerData);
        }

        /// <summary>
        /// Removes blacklisted items, applies item skins and applies multipliers
        /// </summary>
        /// <param name="container"></param>
        private void ReinforceRules(LootContainer container, ContainerData containerData)
        {
            for (int i = 0; i < container.inventory.itemList.Count; i++)
            {
                var item = container.inventory.itemList[i];
                ReinforceRules(item, containerData);                         
            }
        }

        /// <summary>
        /// Removes blacklisted item, applies item skin and applies multipliers
        /// </summary>
        /// <param name="item"></param>
        /// <param name="containerData"></param>
        private void ReinforceRules(Item item, ContainerData containerData = null)
        {
            if (_configuration.Settings.DisableBlueprints && item.IsBlueprint())
            {
                item.info = ItemManager.FindItemDefinition(item.blueprintTarget);
                item.blueprintTarget = 0;

                item.maxCondition = item.info.condition.max;
                item.condition = item.info.condition.max;
                item.OnItemCreated();
            }

            if (!_configuration.Settings.BlueprintDuplication && item.IsBlueprint())
            {
                return;
            }

            if (_configuration.Settings.RandomWorkshopSkins && item.info.shortname != "hazmatsuit")
            {
                var skinId = GetRandomSkin(item.info);
                ApplySkinToItem(item, skinId);
            }

            float multiplier = 1f;
            var inItemList = _configuration.ManualItemMultipliers.TryGetValue(
                item.info.shortname, out multiplier);

            if (!inItemList)
            {
                multiplier = 1f;
            }

            //Do not multiply
            if (multiplier == 0f)
            {
                return;
            }

            multiplier *= inItemList ? _configuration.Settings.ItemListMultiplier
                : _configuration.Settings.NonItemListMultiplier;

            if (containerData != null)
            {
                multiplier *= containerData.Multiplier;
            }

            var maxAmount = _data.Items[item.info.shortname];
            if (maxAmount <= 0)
            {
                PrintWarning($"Item '{item.info.shortname}' spawned with 0 amount...");
            }

            item.amount = _configuration.Settings.LimitToStacksizes ? (int)Math.Min(item.amount * multiplier, maxAmount)
                : (int)(item.amount * multiplier);
        }

        /// <summary>
        /// Returns a list of items where duplicated items are found
        /// </summary>
        /// <param name="item"></param>
        /// <param name="items"></param>
        /// <returns></returns>
        private void FindDuplicates(int itemId, List<Item> items, ref List<Item> duplicateItems)
        {
            foreach (var cItem in items)
            {
                if (cItem.info.itemid != itemId)
                {
                    continue;
                }

                duplicateItems.Add(cItem);
            }
        }

        private bool IsValid(ItemDefinition itemDefintion)
        {
            if (!_configuration.Settings.LimitToStacksizes)
            {
                return true;
            }
            else if (_configuration.BlacklistedItems.Contains(itemDefintion.shortname))
            {
                return false;
            }
            else if (_data.Items[itemDefintion.shortname] <= 0)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates all Loot Spawns found
        /// </summary>
        private void ModifyItemAmountRanges()
        {
            if (_configuration.Settings.ForceCustomLootTables && (_configuration.ExtraLoot.Enabled && _configuration.ExtraLoot.ForceCustomLootTables))
            {
                Puts("Skipping modifying default loot tables...");
                return;
            }

            var lootSpawns = UnityEngine.Resources.FindObjectsOfTypeAll<LootSpawn>();
            foreach (var lootSpawn in lootSpawns)
            {
                if (lootSpawn?.items == null)
                {
                    PrintDebug("Loot spawn data is null");
                    continue;
                }
                
                ModifyItemAmountRange(lootSpawn);
            }

            if (_originItemAmountRange.Count > 0)
            {
                Puts($"Modified '{_originItemAmountRange.Count}' loot data item ranges out of a total of '{lootSpawns.Length}' ...");
            }
        }

        /// <summary>
        /// Validates given item amount ranged array and modifies/removes items if needed
        /// </summary>
        /// <param name="origin"></param>
        private void ModifyItemAmountRange(LootSpawn origin)
        {
            var tempItemsToSpawn = Pool.GetList<ItemAmountRanged>();
            for (int i = 0; i < origin.items.Length; i++)
            {
                var itemRangeToSpawn = origin.items[i];

                if (!IsValid(itemRangeToSpawn.itemDef))
                {                    
                    continue;
                }

                tempItemsToSpawn.Add(itemRangeToSpawn);
            }

            if (tempItemsToSpawn.Count != origin.items.Length)
            {
                _originItemAmountRange.Add(origin, origin.items.Clone() as ItemAmountRanged[]);
                origin.items = tempItemsToSpawn.ToArray();
                PrintDebug($"Modified loot data of '{origin.name}'...");
            }
            
            Pool.FreeList(ref tempItemsToSpawn);
        }

        /// <summary>
        /// Resets all initially stored loot spawns to their default item ranges
        /// </summary>
        private void RestoreItemAmountRanges()
        {
            foreach (var lootSpawn in _originItemAmountRange)
            {
                lootSpawn.Key.items = lootSpawn.Value;
            }

            Puts($"Restored '{_originItemAmountRange.Count}' loot data item ranges to default...");
        }

        /// <summary>
        /// Adds default loot to the container
        /// </summary>
        /// <param name="container"></param>
        /// <param name="containerData"></param>
        private void AddDefaultLoot(LootContainer container, ContainerData containerData)
        {
            var useDefaultLootTables = !(containerData.Enabled && !containerData.VanillaLootTablesDefault);
            if (useDefaultLootTables)
            {
                useDefaultLootTables = !_configuration.Settings.ForceCustomLootTables;
            }

            if (container.LootSpawnSlots.Length != 0)
            {
                for (int i = 0; i < container.LootSpawnSlots.Length; i++)
                {
                    var lootSpawnSlot = container.LootSpawnSlots[i];

                    for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
                    {
                        if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
                        {
                            if (useDefaultLootTables)
                            {                               
                                lootSpawnSlot.definition.SpawnIntoContainer(container.inventory);                               
                                continue;
                            }

                            AddRandomItem(container, containerData);
                        }
                    }
                }
            }
            else if (container.lootDefinition != null)
            {
                for (int k = 0; k < container.maxDefinitionsToSpawn; k++)
                {
                    if (useDefaultLootTables)
                    {
                        container.lootDefinition.SpawnIntoContainer(container.inventory);
                        continue;
                    }

                    AddRandomItem(container, containerData);
                }
            }
        }

        /// <summary>
        /// Adds extra loot to the container, depending on both the Extra Loot and Specific Container Data
        /// </summary>
        /// <param name="container"></param>
        private void AddExtraLoot(LootContainer container, ContainerData containerData)
        {
            var useDefaultLootTables = !(containerData.Enabled && !containerData.VanillaLootTablesExtra);
            if (useDefaultLootTables)
            {
                useDefaultLootTables = !_configuration.ExtraLoot.ForceCustomLootTables;
            }

            var additionalItemsMin = 0;
            var additionalItemsMax = 0;

            if (_configuration.ExtraLoot.Enabled)
            {
                additionalItemsMin += _configuration.ExtraLoot.ExtraItemsMin;
                additionalItemsMax += _configuration.ExtraLoot.ExtraItemsMax;
            }

            if (containerData.Enabled) 
            {
                additionalItemsMin += containerData.ExtraItemsMin;
                additionalItemsMax += containerData.ExtraItemsMax;
            }

            var additionalItems = UnityEngine.Random.Range(additionalItemsMin, additionalItemsMax + 1);
            for (int i = 0; i < additionalItems; i++)
            {
                if (useDefaultLootTables)
                {
                    AddRandomVanillaItem(container);
                }
                else
                {
                    AddRandomItem(container, containerData);
                }
            }
        }

        /// <summary>
        /// Adds a random Vanilla-LootTable Item to the Container
        /// </summary>
        /// <param name="container"></param>
        private void AddRandomVanillaItem(LootContainer container)
        {
            if (container.lootDefinition != null)
            {
                container.lootDefinition.SpawnIntoContainer(container.inventory);
            }
        }

        /// <summary>
        /// Adds a random Item to the Container
        /// </summary>
        /// <param name="container"></param>
        private void AddRandomItem(LootContainer container, ContainerData containerData)
        {
            if (containerData.Rarities.Count == 0)
            {
                PrintWarning("Using Non-Vanilla-LootTables but no set Rarity found in list for container : " + container.ShortPrefabName);
                containerData.Rarities.Add(Rarity.Common);
                SaveConfig();
            }

            var randomContainerRarity = Rarity.Common;            
            if (containerData.RandomRarities && container.inventory.itemList.Count > 0)
            {
                randomContainerRarity = container.inventory.itemList[UnityEngine.Random.Range(0, container.inventory.itemList.Count)].info.rarity;
            }
            else
            {
                randomContainerRarity = containerData.Rarities[UnityEngine.Random.Range(0, containerData.Rarities.Count)];
            }
            
            var rarities = _sortedRarities[randomContainerRarity];
            var randomItemShortname = rarities[UnityEngine.Random.Range(0, rarities.Count)];
            var randomItem = ItemManager.itemDictionaryByName[randomItemShortname];

            if (_configuration.ExtraLoot.PreventDuplicates)
            {
                var duplicateItems = Pool.GetList<Item>();

                for (int i = 0; i < _configuration.ExtraLoot.PreventDuplicatesRetries; i++)
                {
                    FindDuplicates(randomItem.itemid, container.inventory.itemList, ref duplicateItems);

                    if (duplicateItems.Count > 0)
                    {
                        randomItemShortname = rarities[UnityEngine.Random.Range(0, rarities.Count)];
                        randomItem = ItemManager.itemDictionaryByName[randomItemShortname];
                        
                        duplicateItems.Clear();

                        if (i >= _configuration.ExtraLoot.PreventDuplicatesRetries - 1)
                        {
                            PrintDebug("Unable to solve duplicate conflict with " + container.ShortPrefabName + " " + container.transform.position);
                        }
                    }
                    else
                    {
                        break;
                    }
                }
              
                Pool.FreeList(ref duplicateItems);
            }

            var maxAmount = _data.Items[randomItemShortname];
            if (maxAmount > 0)
            {
                container.inventory.AddItem(randomItem, UnityEngine.Random.Range(1, maxAmount));
            }
        }

        /// <summary>
        /// Randomizes the durability of the Items in the Container if ROADSIDE or TOWN Container
        /// </summary>
        /// <param name="container"></param>
        private void RandomizeDurability(LootContainer container)
        {
            if (container.SpawnType == LootContainer.spawnType.ROADSIDE || container.SpawnType == LootContainer.spawnType.TOWN)
            {
                foreach (Item item in container.inventory.itemList)
                {
                    if (!item.hasCondition)
                    {
                        continue;
                    }

                    item.condition = UnityEngine.Random.Range(item.info.condition.foundCondition.fractionMin, item.info.condition.foundCondition.fractionMax) * item.info.condition.max;
                }
            }
        }

        /// <summary>
        /// Generates a Rarity Dictionary containing only Item Definitions that are not Blacklisted
        /// </summary>
        /// <returns></returns>
        private Dictionary<Rarity, List<string>> GetSortedRarities()
        {
            var sortedRarities = new Dictionary<Rarity, List<string>>();

            foreach (var itemDef in ItemManager.itemList)
            {
                if (_configuration.BlacklistedItems.Contains(itemDef.shortname))
                {
                    PrintDebug($"Filtering out '{itemDef.shortname}'");
                    continue;
                }

                if (_data.Items[itemDef.shortname] <= 0)
                {
                    continue;
                }

                if (!sortedRarities.ContainsKey(itemDef.rarity))
                {
                    sortedRarities.Add(itemDef.rarity, new List<string>() { itemDef.shortname });
                    continue;
                }

                sortedRarities[itemDef.rarity].Add(itemDef.shortname);
            }

            Puts("Loaded Rarities...");

            return sortedRarities;
        }

        /// <summary>
        /// Returns if the container is NOT needed to be custom populated
        /// </summary>
        /// <param name="container"></param>
        /// <returns></returns>
        private bool IgnoreContainer(ContainerData containerData)
        {
            return !containerData.Enabled;
        }

        private ulong GetRandomSkin(ItemDefinition itemDef)
        {
            List<ulong> possibleSkins;
            if (_skinsCache.TryGetValue(itemDef.itemid, out possibleSkins))
            {
                return possibleSkins[UnityEngine.Random.Range(0, possibleSkins.Count)];
            }

            possibleSkins = new List<ulong>() { 0 };

            foreach (var skin in ItemSkinDirectory.ForItem(itemDef))
            {
                var skinId = (ulong)skin.id;

                if (_configuration.BlacklistSkins.Contains(skinId))
                {
                    continue;
                }

                possibleSkins.Add(skinId);
            }

            foreach (var skin in Rust.Workshop.Approved.All.Values)
            {
                if (skin.Skinnable.ItemName != itemDef.shortname)
                {
                    continue;
                }

                if (_configuration.BlacklistSkins.Contains(skin.WorkshopdId))
                {
                    continue;
                }

                possibleSkins.Add(skin.WorkshopdId);
            }

            _skinsCache.Add(itemDef.itemid, possibleSkins);

            return possibleSkins[UnityEngine.Random.Range(0, possibleSkins.Count)];
        }

        private void ApplySkinToItem(Item item, ulong skinId)
        {
            if (skinId == 0)
            {
                return;
            }

            item.skin = skinId;
            item.MarkDirty();
            BaseEntity heldEntity = item.GetHeldEntity();
            if (heldEntity != null)
            {
                heldEntity.skinID = skinId;
                heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
        }

        private void PrintDebug(object message)
        {
            if (!_configuration.Debug)
            {
                return;
            }

            Puts(message.ToString());
        }

        #endregion
    }
}

// --- End of file: MagicLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-my-airdrop ---
// --- Original File Path: M/MapMyAirDrop/MapMyAirDrop.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
	[Info("Map My AirDrop", "ColdUnwanted", "0.1.0")]
	[Description("Display a pop-up on Cargo Plane spawn, and a marker on in-game map at drop position.")]

	public class MapMyAirDrop : RustPlugin
	{
		// Configuration
		private bool ConfigChanged;

		// Configuration Variables
		// Supply Drop Marker Configuration
		private float mapmarkerradius;
		private float mapMarkerAlpha;
		private string mapMarkerColor;
		private float mapMarkerLootedAlpha;
		private string mapMarkerLootedColor;

		// Banner Configuration
		private bool displayHudForAll;
		private bool displayGuiForAll;
		private int bannerHUDLimit;
		private Dictionary<string, string> bannerGUIData;
		private Dictionary<string, string> bannerHUDData;

		// Variable Declaration
		// Supply Drop Variables
		private Color markerColor;
		private Color markerLootedColor;
		private Dictionary<BaseEntity, MapMarkerGenericRadius> dropradius = new Dictionary<BaseEntity, MapMarkerGenericRadius>();
		private Dictionary<BaseEntity, bool> lootedornot = new Dictionary<BaseEntity, bool>();
		private Dictionary<BaseEntity, SupplyDrop> entsupply = new Dictionary<BaseEntity, SupplyDrop>();
		private Dictionary<BaseEntity, Vector3> dropposition = new Dictionary<BaseEntity, Vector3>();
		private List<Vector3> supplySignalPosition = new List<Vector3>();

		// Permission Variables
		private const string MapMyAirdropHUD = "mapmyairdrop.hud";
		private const string MapMyAirdropBanner = "mapmyairdrop.banner";

		// HUD Variables
		private Dictionary<BasePlayer, List<string>> HUDlist = new Dictionary<BasePlayer, List<string>>();
		private string hudAnchorMin;
		private string hudAnchorMax;
		private string hudOffsetMin;
		private string hudOffsetMax;
		private bool alreadyUpdating;

		// Banner Variables
		private Dictionary<BasePlayer, List<string>> bannerlist = new Dictionary<BasePlayer, List<string>>();
		private string bannerAnchorMin;
		private string bannerAnchorMax;
		private string bannerOffsetMin;
		private string bannerOffsetMax;

		#region Configuration
		private static Dictionary<string, object> defaultBannerGUI()
		{
			Dictionary<string, object> thisDictGui = new Dictionary<string, object>();
			thisDictGui.Add("Anchor Min", "0.0 0.85");
			thisDictGui.Add("Anchor Max", "1.0 0.90");
			thisDictGui.Add("Offset Min", "0 0");
			thisDictGui.Add("Offset Max", "0 0");

			return thisDictGui;
		}

		private static Dictionary<string, object> defaultBannerHUD()
		{
			Dictionary<string, object> thisDictHud = new Dictionary<string, object>();
			thisDictHud.Add("Anchor Min", "0.1 0.91");
			thisDictHud.Add("Anchor Max", "0.17 0.96");
			thisDictHud.Add("Offset Min", "0 0");
			thisDictHud.Add("Offset Max", "0 0");

			return thisDictHud;
		}

		protected override void LoadDefaultConfig()
		{
			LoadVariables();
		}

		private void LoadVariables()
		{
			// Marker settings
			mapmarkerradius = Convert.ToSingle(GetConfig("Map Marker settings", "The Map Marker Radius On The Map", "1"));
			mapMarkerAlpha = Convert.ToSingle(GetConfig("Map Marker settings", "The Map Marker Alpha On The Map (0 to 1)", "0.4"));
			mapMarkerColor = Convert.ToString(GetConfig("Map Marker settings", "The Map Marker Color On The Map (Hex Code)", "#FF00FF"));
			mapMarkerLootedAlpha = Convert.ToSingle(GetConfig("Map Marker settings", "The Map Marker Looted Alpha On The Map (0 to 1)", "0.4"));
			mapMarkerLootedColor = Convert.ToString(GetConfig("Map Marker settings", "The Map Marker Looted Color On The Map (Hex Code)", "#00FFFF"));

			// Banner settings
			displayHudForAll = Convert.ToBoolean(GetConfig("Banner Settings", "Display Drop HUD For All Users (Overrides 'mapmyairdrop.hud')", "false"));
			displayGuiForAll = Convert.ToBoolean(GetConfig("Banner Settings", "Display Drop Banner For All Users (Overrides 'mapmyairdrop.banner')", "false"));
			Dictionary<string, object> bannerGUIObject = (Dictionary<string, object>)GetConfig("Banner Settings", "Banner GUI Settings", defaultBannerGUI());
			bannerGUIData = new Dictionary<string, string>();
			foreach (KeyValuePair<string, object> obj in bannerGUIObject)
			{
				bannerGUIData.Add(obj.Key, Convert.ToString(obj.Value));
			}
			Dictionary<string, object> bannerHUDObject = (Dictionary<string, object>)GetConfig("Banner Settings", "Banner HUD Settings", defaultBannerHUD());
			bannerHUDData = new Dictionary<string, string>();
			foreach (KeyValuePair<string, object> obj in bannerHUDObject)
			{
				bannerHUDData.Add(obj.Key, Convert.ToString(obj.Value));
			}
			bannerHUDLimit = Convert.ToInt32(GetConfig("Banner Settings", "HUD Banner Display Limit", "5"));

			if (!ConfigChanged)
			{
				return;
			}

			SaveConfig();
			ConfigChanged = false;
		}

		private object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				ConfigChanged = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				ConfigChanged = true;
			}
			return value;
		}
		#endregion

		#region Messages
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				// General
				["ColorError"] = "Hex Conversion Error For {0}, Unable To Convert The Hex: {1}. Using Default Hex Color Instead!",

				["DroppedMsg"] = "Airdrop dropped! Check its position on your MAP (G).",
				["SpawnMsg"] = "A Cargo Plan has spawn. Airdrop will be notified on time.",
				["LootedMsg"] = "Someone is looting a SupplyDrop. Marker changed color.",
				["KilledMsg"] = "A SupplyDrop has despawn.",
				["HUDDistanceMsg"] = "<size=12><color=orange>{0}m.</color></size> away!",
				["HUDAirdropMsg"] = "<color=white>AIRDROP</color><color=black>#</color>{0}\n{1}",
			}, this, "en");
		}
		#endregion

		#region Player Disconnect
		void OnPlayerDisconnected(BasePlayer player, string reason)
		{
			// Destory their banner and hud
			DestroyOneBanner(player);
			DestroyOneHUD(player);
		}

		void DestroyOneBanner(BasePlayer player)
		{
			// Remove banner for that player
			List<string> todel = new List<string>();

			// Check if banner list is empty
			if (bannerlist != null)
			{
				foreach (var playerbanner in bannerlist)
				{
					if (playerbanner.Key == player)
					{
						todel = playerbanner.Value;
					}
				}

				foreach (var item in todel)
				{
					CuiHelper.DestroyUi(player, item);
				}
			}

			bannerlist.Remove(player);
		}

		void DestroyOneHUD(BasePlayer player)
		{
			List<string> todel = new List<string>();
			if (HUDlist != null)
			{
				foreach (var playerhud in HUDlist)
				{
					if (playerhud.Key == player)
					{
						todel = playerhud.Value;
					}
				}

				foreach (var item in todel)
				{
					CuiHelper.DestroyUi(player, item);
				}
			}
			HUDlist.Remove(player);
		}
		#endregion

		#region Player Connect
		void OnPlayerConnected(BasePlayer player)
		{
			// Generate the marker of the current drops in the map
			GenerateMarkers();
			DisplayDropHUD("update");
		}
		#endregion

		#region Unload
		void Unload()
		{
			foreach (var paire in dropradius)
			{
				if (paire.Value != null)
				{
					paire.Value.Kill();
					paire.Value.SendUpdate();
				}
			}

			DestoyAllUi();
		}

		void DestoyAllUi()
		{
			DestroyAllHUD();
			DestroyAllBanner();
		}

		void DestroyAllHUD()
		{
			List<string> todel = new List<string>();

			if (HUDlist != null)
			{
				foreach (var player in BasePlayer.activePlayerList.ToList())
				{
					todel = new List<string>();
					foreach (var playerhud in HUDlist)
					{
						if (playerhud.Key == player)
						{
							todel = playerhud.Value;

						}
					}
					foreach (var item in todel)
					{
						CuiHelper.DestroyUi(player, item);
					}
				}
			}
		}

		void DestroyAllBanner()
		{
			List<string> todel = new List<string>();

			if (HUDlist != null)
			{
				foreach (var player in BasePlayer.activePlayerList.ToList())
				{
					todel = new List<string>();
					foreach (var playerbanner in bannerlist)
					{
						if (playerbanner.Key == player)
						{
							todel = playerbanner.Value;
						}
					}
					foreach (var item in todel)
					{
						CuiHelper.DestroyUi(player, item);
					}
				}
			}
		}
		#endregion

		#region Initialization
		void Init()
		{
			// Load configuration
			LoadVariables();

			// Register Permission
			permission.RegisterPermission(MapMyAirdropHUD, this);
			permission.RegisterPermission(MapMyAirdropBanner, this);

			// Check if the config was setup correctly
			// Cap the range 
			mapMarkerAlpha = Mathf.Clamp(mapMarkerAlpha, 0, 1);
			mapMarkerLootedAlpha = Mathf.Clamp(mapMarkerLootedAlpha, 0, 1);

			// Check if the hex was a legit hex
			string defaultMapMarkerColor = "#FF00FF";
			string defaultMapMarkerLootedColor = "#00FFFF";

			// If it is not legit then just use the default
			if (!ColorUtility.TryParseHtmlString(mapMarkerColor, out markerColor))
			{
				// Use the default color and log it in console
				string message = lang.GetMessage("ColorError", this);
				PrintError(string.Format(message, "Map Marker Color", mapMarkerColor));

				ColorUtility.TryParseHtmlString(defaultMapMarkerColor, out markerColor);
			}

			if (!ColorUtility.TryParseHtmlString(mapMarkerLootedColor, out markerLootedColor))
			{
				// Use the default color and log it in console
				string message = lang.GetMessage("ColorError", this);
				PrintError(string.Format(message, "Map Marker Looted Color", mapMarkerColor));

				ColorUtility.TryParseHtmlString(defaultMapMarkerLootedColor, out markerLootedColor);
			}

			// Convert the dictionary for the banner gui to it's respective data
			if (!bannerGUIData.TryGetValue("Anchor Min", out bannerAnchorMin))
			{
				object thisObj;
				defaultBannerGUI().TryGetValue("Achor Min", out thisObj);
				bannerAnchorMin = Convert.ToString(thisObj);
			}

			if (!bannerGUIData.TryGetValue("Anchor Max", out bannerAnchorMax))
			{
				object thisObj;
				defaultBannerGUI().TryGetValue("Achor Max", out thisObj);
				bannerAnchorMax = Convert.ToString(thisObj);
			}

			if (!bannerGUIData.TryGetValue("Offset Min", out bannerOffsetMin))
			{
				object thisObj;
				defaultBannerGUI().TryGetValue("Offset Min", out thisObj);
				bannerOffsetMin = Convert.ToString(thisObj);
			}

			if (!bannerGUIData.TryGetValue("Offset Min", out bannerOffsetMax))
			{
				object thisObj;
				defaultBannerGUI().TryGetValue("Offset Min", out thisObj);
				bannerOffsetMax = Convert.ToString(thisObj);
			}

			// Convert the dictionary for the banner hud to it's respective data
			if (!bannerHUDData.TryGetValue("Anchor Min", out hudAnchorMin))
			{
				object thisObj;
				defaultBannerHUD().TryGetValue("Achor Min", out thisObj);
				hudAnchorMin = Convert.ToString(thisObj);
			}

			if (!bannerHUDData.TryGetValue("Anchor Max", out hudAnchorMax))
			{
				object thisObj;
				defaultBannerHUD().TryGetValue("Achor Max", out thisObj);
				hudAnchorMax = Convert.ToString(thisObj);
			}

			if (!bannerHUDData.TryGetValue("Offset Min", out hudOffsetMin))
			{
				object thisObj;
				defaultBannerHUD().TryGetValue("Offset Min", out thisObj);
				hudOffsetMin = Convert.ToString(thisObj);
			}

			if (!bannerHUDData.TryGetValue("Offset Min", out hudOffsetMax))
			{
				object thisObj;
				defaultBannerHUD().TryGetValue("Offset Min", out thisObj);
				hudOffsetMax = Convert.ToString(thisObj);
			}

			// Find all dropped supply drop after a delay of 1 minute if cant find
			try
			{
				FindAllDrops();
				DisplayDropHUD("update");
			}
			catch
			{
				timer.Once(60, () =>
				{
					FindAllDrops();
					DisplayDropHUD("update");
				});
			}
		}

		private void FindAllDrops()
		{
			// Find all supply drops object
			SupplyDrop[] allDrops = UnityEngine.Object.FindObjectsOfType<SupplyDrop>();

			// Add the supply drop location then generate marker
			foreach (SupplyDrop drops in allDrops)
			{
				Vector3 location = drops.transform.position;
				BaseEntity entity = drops.GetEntity();
				entsupply.Add(entity, drops);
				Vector3 positionOffset = location;
				positionOffset.x += UnityEngine.Random.Range(-80 * mapmarkerradius, 80 * mapmarkerradius);
				positionOffset.z += UnityEngine.Random.Range(-80 * mapmarkerradius, 80 * mapmarkerradius);
				dropposition.Add(entity, positionOffset);
			}

			GenerateMarkers();
		}
		#endregion

		#region Map Marker
		private void GenerateMarkers()
		{
			// Generate the map marker
			// Clear all the previously generated map markers
			if (dropradius != null)
			{
				foreach (var paire in dropradius)
				{
					MapMarkerGenericRadius MapMarkerDel = paire.Value;

					if (MapMarkerDel != null)
					{
						MapMarkerDel.Kill();
						MapMarkerDel.SendUpdate();
					}
				}
			}

			// For each of the drops, generate a marker on the map
			foreach (var paire in dropposition)
			{
				// Variables needed
				Vector3 position = paire.Value;
				bool looted;
				lootedornot.TryGetValue(paire.Key, out looted);
				MapMarkerGenericRadius MapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position) as MapMarkerGenericRadius;

				// Check if map marker was generated, if not end this whole function because there was an error
				if (MapMarker == null)
				{
					return;
				}

				// Set the marker's color and alpha
				MapMarker.alpha = mapMarkerAlpha;
				MapMarker.color1 = markerColor;

				// Set the color to looted if the crate has already been looted
				if (looted)
				{
					MapMarker.color1 = markerLootedColor;
				}

				MapMarker.color2 = Color.black; // I honestly dont know why is this here

				// Set the marker's radius
				MapMarker.radius = mapmarkerradius;

				// Remove the previous marker data if there is then add the new one
				dropradius.Remove(paire.Key);
				dropradius.Add(paire.Key, MapMarker);
			}

			// Spawn the markers
			foreach (var markers in dropradius)
			{
				markers.Value.Spawn();
				markers.Value.SendUpdate();
			}
		}

		private void MarkerDisplayingDelete(BaseEntity Entity)
		{
			// Delete the marker
			MapMarkerGenericRadius delmarker;
			dropradius.TryGetValue(Entity, out delmarker);

			foreach (var paire in dropradius)
			{
				if (paire.Value == delmarker)
				{
					delmarker.Kill();
					delmarker.SendUpdate();
				}
			}
		}
		#endregion

		#region Hud
		private void DisplayDropHUD(string reason)
		{
			// Clear all the hud
			DestroyAllHUD();
			HUDlist.Clear();

			List<Vector3> positionlist = new List<Vector3>();
			List<BaseEntity> droplist = new List<BaseEntity>();
			List<string> HUDforplayers = new List<string>();

			/*if (reason == "spawn")
            {

            }*/
			if (reason == "dropped" || reason == "update" || reason == "killed" || reason == "looted")
            {
				// Remove the previous data if there is then add the new data
				foreach (var Suppliez in entsupply)
				{
					Vector3 supplyupdated = Suppliez.Key.transform.position;
					dropposition.Remove(Suppliez.Key);
					dropposition.Add(Suppliez.Key, supplyupdated);
				}

				// Add the data into the local list
				foreach (var pair in dropposition)
				{
					droplist.Add(pair.Key);
					positionlist.Add(pair.Value);
				}

				int round = 0;
				foreach (var player in BasePlayer.activePlayerList.ToList())
				{
					bool HUDview = permission.UserHasPermission(player.UserIDString, MapMyAirdropHUD);

					// Check if user has the permission
					if (!HUDview && !displayHudForAll)
                    {
						continue;
                    }

					// Storer for all the drops
					Dictionary<Vector3, int> allDropsAvailable = new Dictionary<Vector3, int>();

					// Loop for each drops
					foreach(Vector3 drop_posi in positionlist)
					{
						// Sort the data base on distance
						int dist = (int)Vector3.Distance(drop_posi, player.transform.position);
						allDropsAvailable.Add(drop_posi, dist);
					}

					// Only run if the list is has data
					if (allDropsAvailable.Count > 0)
                    {
						// Sort the list based on distance
						var dictList = allDropsAvailable.ToList();
						dictList.Sort((pair1, pair2) => pair1.Value.CompareTo(pair2.Value));

						int counter = 0;
						foreach (KeyValuePair<Vector3, int> theData in dictList)
                        {
							// Break it at 5, limit it to 5 on the screen
							if (counter == bannerHUDLimit)
                            {
								break;
                            }

							// Increment the counter
							counter++;

							// Offset between each gui element
							double columnOffset = 0.08 * round++;

							// Generate the gui
							var CuiElement = new CuiElementContainer();
							string CargoHUDBanner = CuiElement.Add(new CuiPanel
							{
								Image = {
								Color = "0.5 0.5 0.5 0.2",
							},
								RectTransform = {
								AnchorMin = Convert.ToDouble(hudAnchorMin.Split()[0]) + columnOffset + " " + Convert.ToDouble(hudAnchorMin.Split()[1]),
								AnchorMax = Convert.ToDouble(hudAnchorMax.Split()[0]) + columnOffset + " " + Convert.ToDouble(hudAnchorMax.Split()[1]),
								OffsetMin = hudOffsetMin,
								OffsetMax = hudOffsetMax,
							},
								CursorEnabled = false,
							});

							var closeButton = new CuiButton
							{
								Button = {
								Close = CargoHUDBanner,
								Color = "0.0 0.0 0.0 0.6",
							},
								RectTransform = {
								AnchorMin = "0.90 0.00",
								AnchorMax = "1.00 1.00",
							},
								Text = {
								Text = "X",
								FontSize = 8,
								Align = TextAnchor.MiddleCenter,
							},
							};

							// CuiElement.Add(closeButton, CargoHUDBanner);

							// Get the distance between the player
							int dist = theData.Value;
							string message = string.Format(lang.GetMessage("HUDDistanceMsg", this, player.UserIDString), dist.ToString());

							// Player distance GUI
							var playerdistance = CuiElement.Add(new CuiLabel
							{
								Text = {
								Text = string.Format(lang.GetMessage("HUDAirdropMsg", this, player.UserIDString), round, message),
								Color = "1.0 1.0 1.0 1.0",
								FontSize = 10,
								Align = TextAnchor.MiddleCenter
							},
								RectTransform = {
								AnchorMin = "0.0 0.0",
								AnchorMax = "0.85 1.0",
							},
							}, CargoHUDBanner);

							// Add The GUI
							CuiHelper.AddUi(player, CuiElement);
							HUDforplayers.Add(CargoHUDBanner);
						}
                    }

					HUDlist.Remove(player);
					HUDlist.Add(player, HUDforplayers);
				}

				if (!alreadyUpdating && HUDlist.Count > 0)
                {
					alreadyUpdating = true;
					timer.Once(10, () =>
					{
						DisplayDropHUD("update");
					});
                }
				else if (alreadyUpdating && HUDlist.Count == 0)
                {
					alreadyUpdating = false;
                }
				else if (alreadyUpdating && HUDlist.Count > 0)
                {
					alreadyUpdating = true;
					timer.Once(10, () =>
					{
						DisplayDropHUD("update");
					});
				}
            }
		}
		#endregion

		#region Spawn Detection
		private void OnSupplyDropLanded(SupplyDrop drop)
        {
			// Display banner to user
			DisplayBannerToAll("dropped");
			DisplayDropHUD("dropped");

			// Store the drop data
			BaseEntity entity = drop.GetEntity();
			Vector3 dropPosition = drop.transform.position;

			bool show = true;
			Vector3 thatPos = Vector3.zero;
			foreach (Vector3 position in supplySignalPosition)
            {
                if ((dropPosition.x - 10) <= position.x && (dropPosition.x + 10) >= position.x && (dropPosition.z - 10) <= position.z && (dropPosition.z + 10) >= position.z)
                {
					show = false;
					thatPos = position;
					break;
                }
            }

			if (show)
            {
				// Remove the previous data if there is then add the new data
				entsupply.Remove(entity);
				dropposition.Remove(entity);
				entsupply.Add(entity, drop);
				Vector3 positionOffset = dropPosition;
				positionOffset.x += UnityEngine.Random.Range(-80 * mapmarkerradius, 80 * mapmarkerradius);
				positionOffset.z += UnityEngine.Random.Range(-80 * mapmarkerradius, 80 * mapmarkerradius);
				dropposition.Add(entity, positionOffset);

				// Generate Marker
				GenerateMarkers();
			}
			else
            {
				supplySignalPosition.Remove(thatPos);
            }
        }

		private void OnExplosiveDropped(BasePlayer player, BaseEntity entity)
        {
			// Check if the entity is a supply signal
			if (entity.name == "assets/prefabs/tools/supply signal/grenade.supplysignal.deployed.prefab")
            {
				// Store the data
				supplySignalPosition.Add(entity.transform.position);
            }
        }

		private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
		{
			// Check if the entity is a supply signal
			if (entity.name == "assets/prefabs/tools/supply signal/grenade.supplysignal.deployed.prefab")
			{
				// Store the data
				supplySignalPosition.Add(entity.transform.position);
			}
		}

		private void OnEntitySpawned(BaseEntity Entity)
		{
			// Check if entity does not exist
			if (Entity == null)
			{
				return;
			}

			// Check if it's a cargo plane entity
			if (Entity is CargoPlane)
			{
				DisplayBannerToAll("spawn");
			}
		}

		void OnEntityKill(BaseNetworkable entity)
		{
			// Get the base entity
			BaseEntity killed = entity as BaseEntity;

			// Check if the supply list contains the base entity
			if (entsupply.ContainsKey(killed))
			{
				// Delete the marker
				MarkerDisplayingDelete(killed);

				// Remove the data from the list
				entsupply.Remove(killed);
				dropposition.Remove(killed);
				dropradius.Remove(killed);
				lootedornot.Remove(killed);

				// Display the banner
				DisplayBannerToAll("killed");
				DisplayDropHUD("killed");
			}
		}

		void OnLootEntity(BasePlayer player, BaseEntity entity)
		{
			// Only care if it's supply drop
			if (entity is SupplyDrop)
			{
				// Check if there was already a key inside the lootedornot list 
				if (lootedornot.ContainsKey(entity))
				{
					// If has the key and is looted then end this function
					bool looted;
					lootedornot.TryGetValue(entity, out looted);

					if (looted)
					{
						return;
					}
				}

				// Check if the key is in the array
				foreach (var paire in entsupply)
				{
					if (paire.Key == entity)
					{
						// Remove the entity data if there is then add the new data
						lootedornot.Remove(entity);
						lootedornot.Add(entity, true);

						// Display banner
						DisplayBannerToAll("looted");
						DisplayDropHUD("looted");
					}
				}

				// Regenerate marker here
				GenerateMarkers();
			}
		}
		#endregion

		#region Banner
		void DisplayBannerToAll(string reason)
		{
			// Clear all the previous banner
			DestroyAllBanner();
			bannerlist.Clear();

			// Run it for all player
			foreach (var player in BasePlayer.activePlayerList.ToList())
			{
				// Check if user has the permission
				bool hasPermission = permission.UserHasPermission(player.UserIDString, MapMyAirdropBanner);

				if (!hasPermission && !displayGuiForAll)
                {
					continue;
                }

				// Here, user have permission so just create the banner
				List<string> bannerforplayers = new List<string>();

				// Generate the message
				string message = string.Empty;
				switch (reason)
				{
					case "spawn":
					{
						message = lang.GetMessage("SpawnMsg", this, player.UserIDString);
						break;
					}
					case "dropped":
					{
						message = lang.GetMessage("DroppedMsg", this, player.UserIDString);
						break;
					}
					case "looted":
					{
						message = lang.GetMessage("LootedMsg", this, player.UserIDString);
						break;
					}
					case "killed":
					{
						message = lang.GetMessage("KilledMsg", this, player.UserIDString);
						break;
					}
				}

				// Create the banner element
				CuiElementContainer CuiElement = new CuiElementContainer();
				CuiPanel bannerPanel = new CuiPanel
				{
					Image = {
						Color = "0.5 0.5 0.5 0.30",
					},
					RectTransform = {
						AnchorMin = bannerAnchorMin,
						AnchorMax = bannerAnchorMax,
						OffsetMin = bannerOffsetMin,
						OffsetMax = bannerOffsetMax,
					},
					CursorEnabled = false,
				};

				string CargoBanner = CuiElement.Add(bannerPanel);
				var closeButton = new CuiButton{
					Button = {
						Close = CargoBanner,
						Color = "0.0 0.0 0.0 0.6",
					},
					RectTransform = {
						AnchorMin = "0.90 0.01",
						AnchorMax = "0.99 0.99",
					},
					Text = {
						Text = "X",
						FontSize = 12,
						Align = TextAnchor.MiddleCenter
					},
				};

				// CuiElement.Add(closeButton, CargoBanner);

				CuiElement.Add(new CuiLabel{
					Text = {
						Text = message,
						FontSize = 14,
						FadeIn = 1.0f,
						Align = TextAnchor.MiddleCenter,
						Color = "1.0 1.0 1.0 1"
					},
					RectTransform = {
						AnchorMin = "0.10 0.10",
						AnchorMax = "0.90 0.90",
					},
				},
				CargoBanner);

				CuiHelper.AddUi(player, CuiElement);
				timer.Once(6, () =>
				{
					CuiHelper.DestroyUi(player, CargoBanner);
				});

				bannerforplayers.Add(CargoBanner);
				bannerlist.Remove(player);
				bannerlist.Add(player, bannerforplayers);
			}
		}
		#endregion
	}
}

// --- End of file: MapMyAirDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-server-rewards-panel ---
// --- Original File Path: M/MagicServerRewardsPanel/MagicServerRewardsPanel.cs ---

﻿using System;
using System.Collections;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Server Rewards Panel", "MJSU", "1.0.7")]
    [Description("Displays player server rewards data in MagicPanel")]
    public class MagicServerRewardsPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, ServerRewards;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private readonly Hash<ulong, int> _playerRewards = new Hash<ulong, int>();

        private Coroutine _updateRoutine;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/d3mgtKD8/2kGm5dH.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.67f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0:0.00}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftmiddle",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.0625f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
            
            if (ServerRewards == null)
            {
                PrintError("Missing plugin dependency ServerRewards: https://umod.org/plugins/server-rewards");
                UnsubscribeAll();
                return;
            }
        
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerRewards, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _playerRewards[player.userID] = GetServerRewards(player.userID);
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerRewards.Remove(player.userID);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerRewards);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }
        #endregion
        
        #region Player Server Rewards Update
        private void UpdatePlayerRewards()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdateServerRewards());
        }

        private IEnumerator HandleUpdateServerRewards()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                int rewards = GetServerRewards(player.userID);
                int previous = _playerRewards[player.userID];
                yield return null;
                if (rewards == previous)
                {
                    continue;
                }

                _playerRewards[player.userID] = rewards;
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                int points = _playerRewards[player.userID];
                text.Text = string.Format(_textFormat, points);
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods

        private int GetServerRewards(ulong userId)
        {
            object points = ServerRewards?.Call("CheckPoints", userId);
            if (points == null)
            {
                return 0;
            }
            
            return (int)points;
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Panel Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }
            
            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicServerRewardsPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-dangerous-treasures-panel ---
// --- Original File Path: M/MagicDangerousTreasuresPanel/MagicDangerousTreasuresPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Component = UnityEngine.Component;

namespace Oxide.Plugins
{
    [Info("Magic Dangerous Treasures Panel", "MJSU", "1.0.4")]
    [Description("Displays if the dangerous treasures event is active")]
    public class MagicDangerousTreasuresPanel : RustPlugin
    {
        #region Class Fields

        [PluginReference] private readonly Plugin MagicPanel, DangerousTreasures;

        private PluginConfig _pluginConfig; //Plugin Config
        private readonly List<BoxStorage> _activeTreasure = new List<BoxStorage>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        
        private const string ComponentName = "TreasureChest";
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/Cx1bFTKk/9dhnu44.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 14,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
            _init = true;
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
            
            if (DangerousTreasures == null)
            {
                PrintError("Missing plugin dependency DangerousTreasures: https://umod.org/plugins/dangerous-treasures");
                UnsubscribeAll();
                return;
            }

            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        
        private void CheckEvent()
        {
            if (_activeTreasure.Count == 0 || _activeTreasure.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks
        private void OnEntitySpawned(BoxStorage box)
        {
            if (!_init)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (CanShowPanel(box))
                {
                    _activeTreasure.Add(box);
                    CheckEvent();
                }
            });
        }

        private void OnEntityKill(BoxStorage box)
        {
            if (!_activeTreasure.Remove(box))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeTreasure.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(BoxStorage box)
        {
            return HasComponent(box, ComponentName);
        }

        private bool? MagicPanelCanShow(string name, BoxStorage box)
        {
            if (HasComponent(box, ComponentName))
            {
                return false;
            }

            return null;
        }
        
        private bool HasComponent(BaseEntity entity, string name)
        {
            return entity.GetComponents<Component>().Any(component => component.GetType().Name == name);
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#EECD60FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicDangerousTreasuresPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/minicopter-lock ---
// --- Original File Path: M/MiniCopterLock/MiniCopterLock.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{   
    [Info("MiniCopter Lock", "Thisha", "0.1.7")]
    [Description("Gives players the ability to lock a minicopter")]
    class MiniCopterLock : RustPlugin
    {
        #region variables
        private const string keyLockPrefab = "assets/prefabs/locks/keylock/lock.key.prefab";
        private const string codeLockPrefab = "assets/prefabs/locks/keypad/lock.code.prefab";
        private const string effectDenied = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
        private const string effectDeployed = "assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab";
        private const string keylockpermissionName = "minicopterlock.usekeylock";
        private const string codelockpermissionName = "minicopterlock.usecodelock";
        private const string kickpermissionName = "minicopterlock.kick";

        private const int doorkeyItemID = -1112793865;
        private const int keylockItemID = -850982208;
        private const int codelockItemID = 1159991980;

        private enum AllowedLockType { keylock, codelock, both};
        internal enum LockType { Keylock, Codelock, None};
        private enum PayType { Inventory, Resources, Free};

        private CooldownManager cooldownManager;
        #endregion variables

        #region localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission Key"] = "You are not allowed to add keylocks",
                ["No Permission Code"] = "You are not allowed to add codelocks",
                ["No Permission Kick"] = "You are not allowed to use the kick command",
                ["Cannot Afford"] = "You need a lock or the resources to craft one",
                ["Already Has Lock"] = "This minicopter already has a lock",
                ["Not A MiniCopter"] = "This entity is not a minicopter",
                ["Cooldown active"] = "You must wait approximately {0} seconds",
                ["Cannot have passengers"] = "Passengers must dismount first"
            }, this);
        }
        #endregion localization

        #region config
        private ConfigData config;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Sound Effects")]
            public bool SoundEffects = true;

            [JsonProperty(PropertyName = "Locks Are Free")]
            public bool LocksAreFree = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                    throw new Exception();

                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion config

        #region chatommands
        [ChatCommand("lockmini.key")]
        private void LockWithkeyLock1(BasePlayer player, string command, string[] args)
        {
            LockIt(player, LockType.Keylock);
        }

        [ChatCommand("lockmini.code")]
        private void LockWithCodeLock1(BasePlayer player, string command, string[] args)
        {
            LockIt(player, LockType.Codelock);
        }

        [ChatCommand("lockit.key")]
        private void LockWithkeyLock2(BasePlayer player, string command, string[] args)
        {
            LockIt(player, LockType.Keylock);
        }

        [ChatCommand("lockit.code")]
        private void LockWithCodeLock2(BasePlayer player, string command, string[] args)
        {
            LockIt(player, LockType.Codelock);
        }
        
        [ConsoleCommand("heli.kick")]
        private void KickPassenger(ConsoleSystem.Arg arg)
        {
            BasePlayer basePlayer = arg.Player();
            if (basePlayer == null)
                return;

            if (!permission.UserHasPermission(basePlayer.UserIDString, kickpermissionName))
            {
                basePlayer.ChatMessage(Lang("No Permission Kick", basePlayer.UserIDString));
                return;
            }

            if (basePlayer.isMounted)
            {
                BaseVehicle vehicle = basePlayer.GetMountedVehicle();
                PlayerHelicopter heli = vehicle.GetComponentInParent<PlayerHelicopter>();
                if (heli == null)
                    return;

                if (HasLock(heli) == LockType.None)
                    return;

                if (basePlayer == vehicle.GetDriver())
                {
                    HasAnyAuthorizedMounted(heli, basePlayer, true, true);
                }
            }
        }
        #endregion chatommands

        #region hooks
        private void Init()
        {
            permission.RegisterPermission(keylockpermissionName, this);
            permission.RegisterPermission(codelockpermissionName, this);
            permission.RegisterPermission(kickpermissionName, this);

            cooldownManager = new CooldownManager();
        }

        object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            PlayerHelicopter heli = entity.GetComponentInParent<PlayerHelicopter>();
            if (heli == null)
                return null;

            BaseLock baseLock = heli.GetComponentInChildren<BaseLock>();
            if (baseLock == null)
                return null;

            if (!baseLock.IsLocked())
                return null;

            if (!HasAnyAuthorizedMounted(heli, null, false, false))
            {
                if (PlayerIsAuthorized(player, heli))
                {
                    return null;
                } 
                else
                {
                    if (config.SoundEffects)
                        Effect.server.Run(effectDenied, heli.transform.position);

                    return true;
                }
            }
            
            return null;
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            PlayerHelicopter heli = entity.GetComponentInParent<PlayerHelicopter>();
            if (heli == null)
                return;

            if (HasLock(heli) == LockType.None)
                return;

            if (PlayerIsAuthorized(player, heli))
                HasAnyAuthorizedMounted(heli, player, true, false);
        }

        object CanLock(BasePlayer player, KeyLock keyLock)
        {
            return CheckLock(player, keyLock, true);
        }

        object CanLock(BasePlayer player, CodeLock codeLock)
        {
            PlayerHelicopter heli = (codeLock.GetComponentInParent<PlayerHelicopter>());
            if (heli == null)
                return null;

            if (heli.AnyMounted())
                DismountPlayers(heli);

            return null;
        }

        object CanUnlock(BasePlayer player, KeyLock keyLock)
        {
            return CheckLock(player, keyLock, false);
        }

        object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
        {
            PlayerHelicopter heli = (codeLock.GetComponentInParent<PlayerHelicopter>());
            if (heli == null)
                return null;

            if (heli.AnyMounted())
                DismountPlayers(heli);

            return null;
        }

        object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            if (baseLock.GetComponentInParent<PlayerHelicopter>() != null)
                if (config.LocksAreFree)
                {
                    baseLock.Kill();
                    return false;
                }

            return null;
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            PlayerHelicopter heli = container.GetComponentInParent<PlayerHelicopter>();
            if (heli == null)
                return null;

            LockType lockType = HasLock(heli);
            if (lockType != LockType.None)
            {
                switch (lockType)
                {
                    case LockType.Keylock:
                        {
                            KeyLock keyLock = heli.GetComponentInChildren<KeyLock>();
                            if (!keyLock.IsLocked())
                                return null;

                            if (PlayerHasTheKey(player, Convert.ToInt32(heli.net.ID)))
                                return null;

                            break;
                        }

                    case LockType.Codelock:
                        {
                            CodeLock codeLock = heli.GetComponentInChildren<CodeLock>();
                            if (!codeLock.IsLocked())
                                return null;

                            if (codeLock.whitelistPlayers.Contains(player.userID))
                                return null;

                            break;
                        }
                }                
                
                if (config.SoundEffects)
                    Effect.server.Run(effectDenied, heli.transform.position);
                
                return false;
            }

            return null;
        }

        object OnVehiclePush(BaseVehicle vehicle, BasePlayer player)
        {
            PlayerHelicopter heli = (vehicle.GetComponentInParent<PlayerHelicopter>());
            if (heli == null)
                return null;

            BaseLock baseLock = heli.GetComponentInChildren<BaseLock>();
            if (baseLock == null)
                return null;

            if (!baseLock.IsLocked())
                return null;

            if (!PlayerIsAuthorized(player, heli))
            {
                if (config.SoundEffects)
                    Effect.server.Run(effectDenied, heli.transform.position);

                return vehicle;
            }

            return null;
        }
        #endregion hooks

        #region methods
        private void LockIt(BasePlayer player, LockType lockType)
        {
            switch (lockType)
            {
                case LockType.Keylock:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, keylockpermissionName))
                        {
                            player.ChatMessage(Lang("No Permission Key", player.UserIDString));
                            return;
                        }
                        break;
                    }

                case LockType.Codelock:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, codelockpermissionName))
                        {
                            player.ChatMessage(Lang("No Permission Code", player.UserIDString));
                            return;
                        }
                        break;
                    }
            }
            
            RaycastHit hit;
            if (!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hit, 5f))
                return;

            BaseEntity heliEntity = hit.GetEntity();
            if (heliEntity is PlayerHelicopter)
            {
                PlayerHelicopter heli = heliEntity.GetComponentInChildren<PlayerHelicopter>();

                if (heli.AnyMounted())
                {
                    player.ChatMessage(Lang("Cannot have passengers", player.UserIDString));
                    return;
                }
                
                if (HasLock(heli) != LockType.None)
                {
                    player.ChatMessage(Lang("Already Has Lock", player.UserIDString));
                    