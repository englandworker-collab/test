return;
                }

                if (config.LocksAreFree == false)
                {
                    float secondsRemaining = 0;
                    if (PlayerHasCooldown(player.UserIDString, lockType, out secondsRemaining))
                    {
                        player.ChatMessage(Lang("Cooldown active", player.UserIDString, Math.Round(secondsRemaining).ToString()));
                        return;
                    }
                }

                PayType payType;
                if (CanAffordLock(player, lockType, out payType))
                {
                    if (lockType == LockType.Keylock)
                        AddKeylock(hit.GetEntity().GetComponent<PlayerHelicopter>(), player);
                    else
                        AddCodelock(hit.GetEntity().GetComponent<PlayerHelicopter>(), player, config.LocksAreFree);

                    PayForlock(player, lockType, payType);

                    cooldownManager.UpdateLastUsedForPlayer(player.UserIDString, lockType);
                }
                else
                    player.ChatMessage(Lang("Cannot Afford", player.UserIDString));
            }
            else
            {
                player.ChatMessage(Lang("Not A MiniCopter", player.UserIDString));
            }
        }

        private LockType HasLock(PlayerHelicopter heli)
        {
            if (heli.GetComponentInChildren<KeyLock>())
                return LockType.Keylock;

            if (heli.GetComponentInChildren<CodeLock>())
                return LockType.Codelock;

            return LockType.None;
        }

        private bool CanAffordLock(BasePlayer player, LockType lockType, out PayType payType)
        {
            payType = PayType.Inventory;

            if (config.LocksAreFree)
            {
                payType = PayType.Free;
                return true;
            }
                
            int itemID = 0;

            switch (lockType)
            {
                case LockType.Keylock:
                    itemID = keylockItemID;
                    break;

                case LockType.Codelock:
                    itemID = codelockItemID;
                    break;
            }

            if ((uint)player.inventory.GetAmount(itemID) >= 1)
            {
                payType = PayType.Inventory;
                return true;
            }
            
            if (player.inventory.crafting.CanCraft(ItemManager.FindBlueprint(ItemManager.FindItemDefinition(itemID)), 1, false))
            {
                payType = PayType.Resources;
                return true;
            }

            return false;
        }

        private void PayForlock(BasePlayer player, LockType lockType, PayType payType)
        {
            if (payType == PayType.Free)
                return;

            int itemID = keylockItemID;
            if (lockType == LockType.Codelock)
                itemID = codelockItemID;

            if (payType == PayType.Inventory)
            {
                player.inventory.Take(new List<Item>(), itemID, 1);
            }
            else
            {
                List<Item> items = new List<Item>();
                foreach (ItemAmount ingredient in ItemManager.FindBlueprint(ItemManager.FindItemDefinition(itemID)).ingredients)
                {
                    player.inventory.Take(items, ingredient.itemid, (int)ingredient.amount);
                    player.Command("note.inv", new object[] { itemID, ((int)ingredient.amount * -1f )});
                }
            }
        }
        
        private void AddKeylock(PlayerHelicopter heli, BasePlayer player)
        {
            BaseEntity ent = GameManager.server.CreateEntity(keyLockPrefab, heli.transform.position);
            if (!ent)
                return;

            ent.Spawn();
            ent.SetParent(heli);
            ent.transform.localEulerAngles = new Vector3(0, 180, 0);
            ent.transform.localPosition = new Vector3(0.27f, 0.67f, 0.1f);

            if (heli.GetComponentInChildren<ScrapTransportHelicopter>() != null)
            {
                ent.transform.localEulerAngles = new Vector3(0, 0, 0);
                ent.transform.localPosition = new Vector3(-1.31f, 1.28f, 1.74f);
            }

            KeyLock keylock = ent.GetComponent<KeyLock>();
            keylock.keyCode = Convert.ToInt32(heli.net.ID);
            keylock.OwnerID = player.userID;
            keylock.enableSaving = true;
            heli.SetSlot(BaseEntity.Slot.Lock, ent);

            ent.SendNetworkUpdateImmediate();
            if (config.SoundEffects)
                Effect.server.Run(effectDeployed, ent.transform.position);
        }

        private void AddCodelock(PlayerHelicopter heli, BasePlayer player, bool isfree)
        {
            BaseEntity ent = GameManager.server.CreateEntity(codeLockPrefab, heli.transform.position);
            if (!ent)
                return;

            ent.Spawn();
            ent.SetParent(heli);
            ent.transform.localEulerAngles = new Vector3(0, 180, 0);
            ent.transform.localPosition = new Vector3(0.27f, 0.67f, 0.1f);

            if (heli.GetComponentInChildren<ScrapTransportHelicopter>() != null) 
            {
                ent.transform.localEulerAngles = new Vector3(0, 0, 0);
                ent.transform.localPosition = new Vector3(-1.25f, 1.22f, 1.99f);   
            }

            CodeLock codelock = ent.GetComponent<CodeLock>();
            codelock.OwnerID = 0;
            codelock.enableSaving = true;
            heli.SetSlot(BaseEntity.Slot.Lock, ent);

            ent.SendNetworkUpdateImmediate();
            if (config.SoundEffects)
                Effect.server.Run(effectDeployed, ent.transform.position);
        }

        private object CheckLock(BasePlayer player, KeyLock keyLock, bool forLocking)
        {
            PlayerHelicopter heli = (keyLock.GetComponentInParent<PlayerHelicopter>());
            if (heli == null)
                return null;

            if (forLocking)
            {
                if (heli.AnyMounted())
                    DismountPlayers(heli);
            }

            if (PlayerHasTheKey(player, Convert.ToInt32(heli.net.ID)))
                return null;

            if (config.SoundEffects)
                Effect.server.Run(effectDenied, keyLock.transform.position);

            return false;
        }

        private bool HasAnyAuthorizedMounted(PlayerHelicopter heli, BasePlayer dismounted, bool kick, bool hardkick)
        {
            List<BaseVehicle.MountPointInfo>.Enumerator enumerator = heli.mountPoints.GetEnumerator();
            try
            {
                while (enumerator.MoveNext())
                {
                    BaseVehicle.MountPointInfo current = enumerator.Current;
                    if (!(current.mountable != null))
                    {
                        continue;
                    } 
                    else
                    {
                        BasePlayer player = current.mountable.GetMounted();
                        if (player == null)
                            continue;
                        else
                        {
                            if (player == dismounted)
                            {
                                continue;
                            }
                            else
                            {
                                if (hardkick)
                                {
                                    heli.GetComponent<BaseMountable>().DismountPlayer(player);
                                    player.EnsureDismounted();
                                    continue;
                                }

                                if (!PlayerIsAuthorized(player, heli))
                                {
                                    if (kick)
                                    {
                                        heli.GetComponent<BaseMountable>().DismountPlayer(player);
                                        player.EnsureDismounted();
                                    }
                                }
                                else
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            finally
            {
                ((IDisposable)enumerator).Dispose();
            }
        }

        private bool PlayerIsAuthorized(BasePlayer player, PlayerHelicopter heli)
        {
            LockType lockType = HasLock(heli);

            switch (lockType)
            {
                case LockType.Keylock:
                    return (PlayerHasTheKey(player, Convert.ToInt32(heli.net.ID)));

                case LockType.Codelock:
                    return (heli.GetComponentInChildren<CodeLock>().whitelistPlayers.Contains(player.userID) || (heli.GetComponentInChildren<CodeLock>().guestPlayers.Contains(player.userID)));
            }

            return true;
        }

        private bool PlayerHasTheKey(BasePlayer player, int keyCode)
        {
            foreach (Item item in player.inventory.containerMain.itemList)   
            {
                if (IsMatchingKey(item, keyCode))
                    return true;
            }
            
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (IsMatchingKey(item, keyCode))
                    return true;
            }
            
            return false;
        }

        private bool IsMatchingKey(Item item, int keyCode)
        {
            if (item.info.itemid == doorkeyItemID)
            {
                if (item.instanceData.dataInt == keyCode)
                    return true;
            }

            return false;
        }

        private void DismountPlayers(PlayerHelicopter heli)
        {
            List<BaseVehicle.MountPointInfo>.Enumerator enumerator = heli.mountPoints.GetEnumerator();
            try
            {
                while (enumerator.MoveNext())
                {
                    BaseVehicle.MountPointInfo current = enumerator.Current;
                    if (!(current.mountable != null))
                    {
                        continue;
                    }
                    else
                    {
                        BasePlayer player = current.mountable.GetMounted();
                        if (player == null)
                            continue;
                        else
                        {
                            heli.GetComponent<BaseMountable>().DismountPlayer(player);
                            player.EnsureDismounted();
                        }
                    }
                }
            }
            finally
            {
                ((IDisposable)enumerator).Dispose();
            }
        }
        #endregion methods

        #region cooldown
        internal class CooldownManager
        {
            private readonly Dictionary<string, CooldownInfo> Cooldowns = new Dictionary<string, CooldownInfo>();

            public CooldownManager()
            {
                
            }

            private class CooldownInfo
            {
                public float CraftTime = Time.realtimeSinceStartup;
                public float CoolDown = 0;

                public CooldownInfo(float craftTime, float duration)
                {
                    CraftTime = craftTime;
                    CoolDown = duration;
                }
            }

            public void UpdateLastUsedForPlayer(string userID, LockType lockType)
            {
                string key = userID + "-" + lockType.ToString();
                float duration = 0;

                switch(lockType)
                {
                    case LockType.Keylock:
                        {
                            duration = ItemManager.FindBlueprint(ItemManager.FindItemDefinition(keylockItemID)).time;
                            break;
                        }

                    case LockType.Codelock:
                        {
                            duration = ItemManager.FindBlueprint(ItemManager.FindItemDefinition(codelockItemID)).time;
                            break;
                        }
                }
                
                if (Cooldowns.ContainsKey(key))
                {
                    Cooldowns[key].CraftTime = Time.realtimeSinceStartup;
                    Cooldowns[key].CoolDown = 10;
                }
                else
                {
                    CooldownInfo info = new CooldownInfo(Time.realtimeSinceStartup, duration);
                    Cooldowns.Add(key, info);
                }
            }

            public float GetSecondsRemaining(string userID, LockType lockType)
            {
                string key = userID + "-" + lockType.ToString();

                if (!Cooldowns.ContainsKey(key))
                    return 0;

                return Cooldowns[key].CraftTime + Cooldowns[key].CoolDown - Time.realtimeSinceStartup;
            }
        }

        private bool PlayerHasCooldown(string userID, LockType lockType, out float secondsRemaining)
        {
            secondsRemaining = (float) Math.Round(cooldownManager.GetSecondsRemaining(userID,lockType));
            
            if (secondsRemaining <= 0) 
                return false;
            
            return true;
        }
        #endregion cooldown

        #region helpers
        private static BasePlayer FindBasePlayer(Vector3 pos)
        {
            RaycastHit[] hits = UnityEngine.Physics.SphereCastAll(pos, 4f, Vector3.up);
            return (from hit in hits where hit.GetEntity()?.GetComponent<BasePlayer>() select hit.GetEntity()?.GetComponent<BasePlayer>()).FirstOrDefault();
        }

        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);

        private LockType GetLockType(string allowedLockType)
        {
            if (allowedLockType.ToLower() == AllowedLockType.keylock.ToString().ToLower())
                return LockType.Keylock;
            else
                return LockType.Codelock;
        }
        #endregion helpers
    }
}

// --- End of file: MiniCopterLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-air-strike-panel ---
// --- Original File Path: M/MagicAirStrikePanel/MagicAirStrikePanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Air Strike Panel", "MJSU", "1.0.4")]
    [Description("Displays if the air strike event is active")]
    public class MagicAirStrikePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, Airstrike;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<CargoPlane> _activeStrikePlanes = new List<CargoPlane>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 2,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/c4VdJfxh/h3ayf2x.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.1f, 0.1f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeStrikePlanes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
            
            if (Airstrike == null)
            {
                PrintError("Missing plugin dependency Airstrike: https://umod.org/plugins/airstrike");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeStrikePlanes.Count == 0 || _activeStrikePlanes.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(CargoPlane plane)
        {
            if (!_init)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (!CanShowPanel(plane))
                {
                    return;
                }

                _activeStrikePlanes.Add(plane);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(CargoPlane plane)
        {
            if (!_activeStrikePlanes.Remove(plane))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeStrikePlanes.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(CargoPlane plane)
        {
            if (!IsStrikePlane(plane))
            {
                return false;
            }

            return true;
        }

        private bool IsStrikePlane(CargoPlane plane)
        {
            return Airstrike?.Call<bool>("isStrikePlane", plane) ?? false;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }

            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }

            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicAirStrikePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mlrs-fixer ---
// --- Original File Path: M/MLRSFixer/MLRSFixer.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MLRS Fixer", "Aspect.dev", "0.1.3")]
    [Description("Provides commands to fix all MLRS on your server.")]
    internal class MLRSFixer : CovalencePlugin
    {
        public const string fixPermission = "mlrsfixer.fixmlrs";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command.",
                ["NoMLRS"] = "There are no broken MLRS vehicles on this server.",
                ["ResetCooldowns"] = "Successfully reset the cooldown on all {COUNT} MLRS vehicles.",
            }, this, "en");
        }

        void Init() => permission.RegisterPermission(fixPermission, this);

        [Command("fixmlrs")]
        void FixMLRS(IPlayer sender, string command, string[] args)
        {
            if (!sender.HasPermission(fixPermission))
            {
                sender.Message(lang.GetMessage("NoPermission", this, sender.Id));
                return;
            }

            var mlrsList = BaseNetworkable.serverEntities.OfType<MLRS>()?.Where(x => x.HasFlag(BaseEntity.Flags.Broken));
            if (mlrsList == null) return;

            var mlrsCount = mlrsList.Count();

            if (mlrsCount < 1)
            {
                sender.Message(lang.GetMessage("NoMLRS", this, sender.Id));
                return;
            }

            foreach (MLRS mlrs in mlrsList) mlrs.SetFlag(BaseEntity.Flags.Broken, false, false, true);

            sender.Message(lang.GetMessage("ResetCooldowns", this, sender.Id).Replace("{COUNT}", mlrsCount.ToString()));
            return;
        }
    }
}


// --- End of file: MLRSFixer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/minicopter-licence-plate ---
// --- Original File Path: M/MiniPlate/MiniPlate.cs ---

﻿using Newtonsoft.Json;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Minicopter Licence Plate", "The Friendly Chap", "1.1.6")]
    [Description("Spawn a licence plate (Small Wooden Board) at the back of the minicopter, with optional permissions.")]
    class MiniPlate : RustPlugin
    {
        const string PlatePrefab = "assets/prefabs/deployable/signs/sign.small.wood.prefab";
        private static readonly Vector3 PlatePosition = new Vector3(0.0f, 0.20f, -0.85f);
        private static readonly Quaternion PlateRotation = Quaternion.Euler(180, 0, 180);

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Use Permissions")]
            public bool UsePermissions = false;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        void Init()
        {
            ShowLogo();
            permission.RegisterPermission("miniplate.use", this);

            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete the file or check the syntax and fix it.");
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file.");
            configData = new ConfigData();
            SaveConfig(configData);
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        private void OnServerInitialized()
        {
            FindMinicopters();
        }

        void FindMinicopters()
        {
            foreach (var mini in BaseNetworkable.serverEntities.OfType<Minicopter>())
            {
                if (mini.children != null)
                {
                    foreach (var child in mini.children)
                    {
                        DestroyUnnecessaryComponents(child);
                    }
                }
            }
        }

        void OnEntitySpawned(Minicopter mini)
        {
            if (configData.UsePermissions)
            {
                string userID = $"{mini.OwnerID}";
                if (!permission.UserHasPermission(userID, "miniplate.use")) return;
            }

            if (mini.children == null || !mini.children.Any(child => child.PrefabName == PlatePrefab))
            {
                AttachLicensePlate(mini);
            }
        }

        void AttachLicensePlate(BaseVehicle vehicle)
        {
            CreateLicensePlate(vehicle, PlatePosition);
        }

        void CreateLicensePlate(BaseVehicle vehicle, Vector3 position)
        {
            var entity = GameManager.server.CreateEntity(PlatePrefab, vehicle.transform.position, PlateRotation);
            if (entity == null) return;

            DestroyUnnecessaryComponents(entity);
            entity.SetParent(vehicle);
            entity.transform.localPosition = position;
            entity.Spawn();
        }

        void DestroyUnnecessaryComponents(BaseEntity entity)
        {
            if (configData.Debug) Puts($"Destroying components for {entity}");

            var groundComp = entity.GetComponent<DestroyOnGroundMissing>();
            if (groundComp != null) UnityEngine.Object.DestroyImmediate(groundComp);

            var groundWatch = entity.GetComponent<GroundWatch>();
            if (groundWatch != null) UnityEngine.Object.DestroyImmediate(groundWatch);

            var decayComp = entity.GetComponent<DeployableDecay>();
            if (decayComp != null) UnityEngine.Object.DestroyImmediate(decayComp);

            var meshColliders = entity.GetComponentsInChildren<MeshCollider>();
            foreach (var meshCollider in meshColliders)
            {
                UnityEngine.Object.DestroyImmediate(meshCollider);
                if (entity.PrefabName == PlatePrefab)
                {
                    var boxCollider = entity.gameObject.AddComponent<BoxCollider>();
                    boxCollider.size = new Vector3(entity.bounds.size.x, entity.bounds.size.y, entity.bounds.size.z);
                }
            }
        }

        private void ShowLogo()
        {
            Puts(" _______ __               _______        __                 __ __             ______ __");
            Puts("|_     _|  |--.-----.    |    ___|.----.|__|.-----.-----.--|  |  |.--.--.    |      |  |--.---.-.-----.");
            Puts("  |   | |     |  -__|    |    ___||   _||  ||  -__|     |  _  |  ||  |  |    |   ---|     |  _  |  _  |");
            Puts("  |___| |__|__|_____|    |___|    |__|  |__||_____|__|__|_____|__||___  |    |______|__|__|___._|   __|");
            Puts("                         Check Plugins v1.0.0                     |_____|                       |__|");      
        }
    }
}


// --- End of file: MiniPlate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/modded-work-carts ---
// --- Original File Path: M/ModdedWorkCarts/ModdedWorkCarts.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Modded Work Carts", "Kopter", "1.0.2")]
    [Description("Allows making modifications to Work Carts, such as adding Auto Turret, Storage")]

    public class ModdedWorkCarts : RustPlugin
    {
        #region Variables

        int AutoTurretID;
        List<ulong> PlayersOnCoolDown = new List<ulong>();

        private const string StoragePrefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";
        private const string ChairPrefab = "assets/prefabs/vehicle/seats/passengerchair.prefab";
        private const string InvisibleChairPrefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
        private const string AutoTurretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private const string ElectricSwitchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";

        private const string AutoTurretSound = "assets/prefabs/npc/autoturret/effects/autoturret-deploy.prefab";

        private const string TurretPermission = "moddedworkcarts.turret";

        public List<Vector3> ChairPositions = new List<Vector3>()
        {
            new Vector3(-1.1f, 1.40f, -4.15f),
            new Vector3(-0.36f, 1.40f, -4.15f),
            new Vector3(0.36f, 1.40f, -4.15f),
            new Vector3(1.1f, 1.40f, -4.15f),
        };

        public List<Vector3> StoragePositions = new List<Vector3>()
        {
            new Vector3(0.85f, 2.63f, 0.3f),
            new Vector3(0.85f, 2.63f, 1.44f)
        };

        Vector3 AutoTurretPosition = new Vector3(0.7f, 3.8f, 3.7f);
        Vector3 ElectricSwitchPosition = new Vector3(-0.59f, -2, -1.9f);

        #endregion

        #region Oxide Hooks

        void Init()
        {
            permission.RegisterPermission(TurretPermission, this);

            AutoTurretID = ItemManager.FindItemDefinition("autoturret").itemid;

            PlayersOnCoolDown.Clear();
        }

        void OnEntitySpawned(TrainCar WorkCart)
        {
            if (Rust.Application.isLoadingSave) return;

            NextTick(() =>
            {
                if (WorkCart == null) return;

                if (config.Chairs) SpawnChairs(WorkCart);

                if (config.Storage) SpawnStorage(WorkCart);

                if (config.AutoTurret) SpawnAutoTurretAndSwitch(WorkCart);
            });
        }

        object OnSwitchToggled(ElectricSwitch ElectricSwitch)
        {
            var AutoTurret = ElectricSwitch.GetParentEntity() as AutoTurret;

            if (AutoTurret == null) return null;

            var WorkCart = AutoTurret.GetParentEntity() as TrainCar;

            if (WorkCart == null) return null;

            if (ElectricSwitch.IsOn()) AutoTurret.InitiateStartup();

            else AutoTurret.InitiateShutdown();

            return null;
        }

        object OnEntityTakeDamage(ElectricSwitch ElectricSwitch)
        {
            var AutoTurret = ElectricSwitch.GetParentEntity();

            if (AutoTurret == null) return null;

            var WorkCart = AutoTurret.GetParentEntity();

            if (WorkCart == null) return null;

            return true;
        }

        void OnEntityKill(StorageContainer Storage)
        {
            var WorkCart = Storage.GetParentEntity() as TrainCar;

            if (WorkCart == null) return;

            Storage.DropItems();
        }

        #endregion

        #region Commands

        [ChatCommand("workcartturret")]
        void WorkCartTurretCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, TurretPermission))
            {
                player.ChatMessage($"{Lang("NoPermission", player.UserIDString)}");
                return;
            }

            if (PlayersOnCoolDown.Contains(player.userID))
            {
                player.ChatMessage($"{Lang("OnCooldown", player.UserIDString, config.CommandCooldown)}");
                return;
            }

            TrainCar WorkCart;

            if (!VerifyWorkCartFound(player, out WorkCart))
            {
                player.ChatMessage($"{Lang("NoWorkCartFound", player.UserIDString)}");
                return;
            }

            if (GetWorkCartAutoTurret(WorkCart) != null)
            {
                player.ChatMessage($"{Lang("WorkCartHasTurret", player.UserIDString)}"); 
                return;
            }

            if (player.inventory.GetAmount(AutoTurretID) < 1)
            {
                player.ChatMessage($"{Lang("NoAutoTurret", player.UserIDString)}");
                return;
            }

            AutoTurret AutoTurret = (AutoTurret)SpawnAutoTurretAndSwitch(WorkCart);

            if (AutoTurret == null) return;

            Effect.server.Run(AutoTurretSound, AutoTurret.transform.position);

            player.inventory.Take(null, AutoTurretID, 1);

            AutoTurret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID
            {
                userid = player.userID,
                username = player.displayName
            });

            AutoTurret.SendNetworkUpdate();

            player.ChatMessage($"{Lang("AutoTurretPlaced", player.UserIDString)}");

            if (config.CommandCooldown > 0)
            {
                PlayersOnCoolDown.Add(player.userID);

                timer.Once(config.CommandCooldown * 60, () =>
                {
                    PlayersOnCoolDown.Remove(player.userID);
                });
            }
        }

        #endregion

        #region Functions

        void SpawnChairs(TrainCar WorkCart)
        {
            foreach (Vector3 Position in ChairPositions)
            {
                BaseMountable Chair = GameManager.server.CreateEntity(ChairPrefab, WorkCart.transform.position) as BaseMountable;
                BaseMountable InvisibleChair = GameManager.server.CreateEntity(InvisibleChairPrefab, WorkCart.transform.position) as BaseMountable;

                if (Chair == null || InvisibleChair == null) return;

                Chair.Spawn();
                InvisibleChair.Spawn();

                Chair.SetParent(WorkCart);
                InvisibleChair.SetParent(WorkCart);

                Chair.transform.localPosition = Position;
                InvisibleChair.transform.localPosition = Position;

                RemoveColliderProtection(Chair);
                RemoveColliderProtection(InvisibleChair);

                Chair.SendNetworkUpdateImmediate();
                InvisibleChair.SendNetworkUpdateImmediate();
            }
        }

        void SpawnStorage(TrainCar WorkCart)
        {
            foreach (Vector3 Position in StoragePositions)
            {
                StorageContainer Storage = GameManager.server.CreateEntity(StoragePrefab, WorkCart.ServerPosition) as StorageContainer;

                if (Storage == null) return;

                Storage.Spawn();

                Storage.SetParent(WorkCart);

                Storage.transform.localPosition = Position;

                Storage.DropItems();

                RemoveColliderProtection(Storage);

                Storage.SendNetworkUpdateImmediate();
            }
        }

        object SpawnAutoTurretAndSwitch(TrainCar WorkCart)
        {
            Quaternion ElectricSwitchRotation = new Quaternion(0, WorkCart.transform.rotation.y, 0, WorkCart.transform.rotation.x);

            AutoTurret AutoTurret = GameManager.server.CreateEntity(AutoTurretPrefab, WorkCart.ServerPosition) as AutoTurret;
            ElectricSwitch ElectricSwitch = GameManager.server.CreateEntity(ElectricSwitchPrefab, WorkCart.ServerPosition, ElectricSwitchRotation) as ElectricSwitch;
            
            if (AutoTurret == null || ElectricSwitch == null) return null;

            AutoTurret.Spawn();
            ElectricSwitch.Spawn();

            AutoTurret.SetParent(WorkCart);
            ElectricSwitch.SetParent(AutoTurret);

            AutoTurret.transform.localPosition = AutoTurretPosition;
            ElectricSwitch.transform.localPosition = ElectricSwitchPosition;

            AutoTurret.pickup.enabled = false;
            ElectricSwitch.pickup.enabled = false;

            ElectricSwitch.SetFlag(IOEntity.Flag_HasPower, true);

            RemoveColliderProtection(AutoTurret);
            RemoveColliderProtection(ElectricSwitch);

            foreach (var Input in AutoTurret.inputs)
                Input.type = IOEntity.IOType.Generic;

            foreach (var Output in AutoTurret.outputs)
                Output.type = IOEntity.IOType.Generic;

            foreach (var Input in ElectricSwitch.inputs)
                Input.type = IOEntity.IOType.Generic;

            foreach (var Output in ElectricSwitch.outputs)
                Output.type = IOEntity.IOType.Generic;

            AutoTurret.SendNetworkUpdateImmediate();
            ElectricSwitch.SendNetworkUpdateImmediate();

            return AutoTurret;
        }

        void RemoveColliderProtection(BaseEntity Entity)
        {
            foreach (var MeshCollider in Entity.GetComponentsInChildren<MeshCollider>())
            {
                UnityEngine.Object.DestroyImmediate(MeshCollider);
            }

            UnityEngine.Object.DestroyImmediate(Entity.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(Entity.GetComponent<DestroyOnGroundMissing>());
        }

        private bool VerifyWorkCartFound(BasePlayer player, out TrainCar WorkCart)
        {
            RaycastHit hit;

            var Entity = Physics.Raycast(player.eyes.HeadRay(), out hit, 3, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore) ? hit.GetEntity() : null;

            WorkCart = Entity as TrainCar;

            if (WorkCart != null) return true;

            return false;
        }

        private static AutoTurret GetWorkCartAutoTurret(TrainCar WorkCart)
        {
            foreach (var Child in WorkCart.children)
            {
                var AutoTurret = Child as AutoTurret;

                if (AutoTurret != null) return AutoTurret;
            }

            return null;
        }

        #endregion

        #region Config

        private ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Add a Auto Turret on top of the driver cabin")]
            public bool AutoTurret = false;

            [JsonProperty(PropertyName = "Add Storage Boxes on top of the fuel deposit")]
            public bool Storage = false;

            [JsonProperty(PropertyName = "Add chairs at the back of the Work Cart")]
            public bool Chairs = false;

            [JsonProperty(PropertyName = "Turret Command Cooldown in Minutes (If 0 there will be none)")]
            public float CommandCooldown = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have permission to use this command!"},
                {"OnCooldown", "You are currently on a cooldown, you can use this command every {0} minutes!"},
                {"NoWorkCartFound", "A Work Cart was not found!"},
                {"WorkCartHasTurret", "This Work Cart already has a turret!"},
                {"NoAutoTurret", "You need a Auto Turret on your inventory to use this command!"},
                {"AutoTurretPlaced", "The Auto Turret was placed!"}
            }, this);
        }

        #endregion

        #region Helpers

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

    }
}

// --- End of file: ModdedWorkCarts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-cargo-ship-panel ---
// --- Original File Path: M/MagicCargoShipPanel/MagicCargoShipPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Cargo Ship Panel", "MJSU", "1.0.2")]
    [Description("Displays if the cargo ship event is active")]
    public class MagicCargoShipPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<CargoShip> _activeCargoShips = new List<CargoShip>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/C13zpXQC/LhZndt9.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.0f, 0.0f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 5,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeCargoShips = UnityEngine.Object.FindObjectsOfType<CargoShip>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
                foreach (CargoShip ship in _activeCargoShips)
                {
                    Puts($"Ship Found @ {ship.transform.position}");
                }
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeCargoShips.Count == 0 || _activeCargoShips.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(CargoShip ship)
        {
            if (!_init)
            {
                return;
            }
        
            NextTick(() =>
            {
                if (!CanShowPanel(ship))
                {
                    return;
                }
            
                _activeCargoShips.Add(ship);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(CargoShip ship)
        {
            if (!_activeCargoShips.Remove(ship))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeCargoShips.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private bool CanShowPanel(CargoShip cargo)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, cargo);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#DE8732FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicCargoShipPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/marker-manager ---
// --- Original File Path: M/MarkerManager/MarkerManager.cs ---

﻿using ConVar;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using VLB;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("Marker Manager", "DezLife", "3.0.3")]
    public class MarkerManager : RustPlugin
    {
        #region Vars
        public static StringBuilder StringBuilderInstance;

        private const string genericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string vendingPrefab = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string permUse = "markermanager.use";
        private const string chatCommand = "marker";
        private readonly List<CustomMapMarker> mapMarkers = new List<CustomMapMarker>();
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            cmd.AddChatCommand(chatCommand, this, nameof(cmdMarkerChat));
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            foreach (CustomMapMarker marker in mapMarkers)
                if (marker != null) marker.UpdateMarkers();
        }
        private void OnServerInitialized()
        {
            StringBuilderInstance = new StringBuilder();
            LoadData();
            LoadCustomMarkers();
        }

        private void Unload()
        {
            SaveData();
            RemoveMarkers();
            StringBuilderInstance = null;
        }

        #endregion

        #region Metods

        private void CreateMarker(Vector3 position, int duration, float refreshRate, string name, string displayName, float radius = 0.3f, float alpha = 0.75f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CustomMapMarker marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.alpha = alpha;
            marker.position = position;
            marker.duration = duration;
            marker.refreshRate = refreshRate;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
            mapMarkers.Add(marker);
        }

        private void CreateMarker(BaseEntity entity, int duration, float refreshRate, string name, string displayName, float radius = 0.3f, float alpha = 0.75f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CustomMapMarker marker = entity.gameObject.GetOrAddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.alpha = alpha;
            marker.refreshRate = refreshRate;
            marker.parent = entity;
            marker.position = entity.transform.position;
            marker.duration = duration;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
            mapMarkers.Add(marker);
        }

        private void RemoveMarker(string name)
        {
            foreach (CustomMapMarker marker in mapMarkers)
            {
                if (marker.name != null && marker.name == name) UnityEngine.Object.Destroy(marker);
            }
        }

        private void RemoveMarkers()
        {
            foreach (CustomMapMarker marker in mapMarkers)
            {
                if (marker.name != null) UnityEngine.Object.Destroy(marker);
            }
        }
        private void RemoveCustomMarker(string name, BasePlayer player = null)
        {
            int i = 0;
            foreach (CustomMapMarker marker in mapMarkers)
            {
                if (marker.name == null || marker.placedByPlayer == false) continue;

                if (marker.name == name)
                {
                    UnityEngine.Object.Destroy(marker);
                    i++;
                }
            }
            RemoveSavedMarker(name);
            Message(player, "Removed", i);
        }

        private void CreateCustomMarker(CachedMarker def, BasePlayer player = null)
        {
            CustomMapMarker marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = def.name;
            marker.displayName = def.displayName;
            marker.radius = def.radius;
            marker.alpha = def.alpha;
            marker.position = def.position;
            marker.duration = def.duration;
            marker.refreshRate = def.refreshRate;
            marker.placedByPlayer = true;
            ColorUtility.TryParseHtmlString($"#{def.color1}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{def.color2}", out marker.color2);
            mapMarkers.Add(marker);
            if(player != null) Message(player, "Added", marker.displayName, marker.position);
        }

        private void SaveCustomMarker(CachedMarker def)
        {
            data.Add(def);
        }

        private void LoadCustomMarkers()
        {
            foreach (CachedMarker def in data)
            {
                CreateCustomMarker(def);
            }
        }

        private void RemoveSavedMarker(string name)
        {
            data.RemoveAll(x => x.name == name);
        }
        #endregion

        #region Command
        private void cmdMarkerChat(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                Message(player, "Permission");
                return;
            }

            if (args == null || args?.Length == 0)
            {
                Message(player, "Usage");
                return;
            }

            switch (args[0].ToLower())
            {
                default:
                    Message(player, "Usage");
                    break;

                case "add":
                case "create":
                    if (args.Length < 8)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        CachedMarker def = new CachedMarker
                        {
                            position = player.transform.position,
                            name = args[1],
                            duration = Convert.ToInt32(args[2]),
                            refreshRate = Convert.ToSingle(args[3]),
                            radius = Convert.ToSingle(args[4]),
                            displayName = args[5],
                            color1 = args[6],
                            color2 = args[7],
                            alpha = Convert.ToSingle(args[8]),
                        };

                        CreateCustomMarker(def, player);
                        SaveCustomMarker(def);
                    }

                    return;

                case "remove":
                case "delete":
                    if (args.Length < 2)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        RemoveCustomMarker(args[1], player);
                    }

                    return;
            }
        }

        #endregion

        #region Data 1.0.0

        private const string filename = "MarkerManager/Custom";
        private static List<CachedMarker> data = new List<CachedMarker>();

        private class CachedMarker
        {
            public float radius;
            public float alpha;
            public string color1;
            public string color2;
            public string displayName;
            public string name;
            public float refreshRate;
            public Vector3 position;
            public int duration;
        }

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<List<CachedMarker>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(Core.Random.Range(500, 700f), SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion

        #region API

        private void API_CreateMarker(Vector3 position, string name, int duration = 0, float refreshRate = 3f, float radius = 0.4f, string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF" , float alpha = 0.75f)
        {
            CreateMarker(position, duration, refreshRate, name, displayName, radius, alpha, colorMarker, colorOutline);
        }

        private void API_CreateMarker(BaseEntity entity, string name, int duration = 0, float refreshRate = 3f, float radius = 0.4f, string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF", float alpha = 0.75f)
        {
            CreateMarker(entity, duration, refreshRate, name, displayName, radius, alpha, colorMarker, colorOutline);
        }

        private void API_RemoveMarker(string name)
        {
            RemoveMarker(name);
        }

        #endregion

        #region Localization 1.1.1

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Usage", "<color=#00ffff>Используйте:</color>\n" + " <color=#00ffff>/marker add</color> name(code name) duration(секунды, 0 - неудолямый) refreshRate(30) radius(0.4) displayName (Названия маркера на карте) colorInline (HEX) colorOutline (HEX) alpha (прозрачность 0.75) - Добавить маркер на карту\n" + " <color=#00ffff>/marker remove</color> name (code name, только для маркеров созданных командой) - Удалить маркер с карты" },
                {"Permission", "У вас недостаточно разрешений для использования этой команды!"},
                {"Added", "Маркер '{0}' был добавлен {1}!"},
                {"Removed", "{0} маркер(а) с таким названием были удалены!"},
                {"RemovedOldVersion", "Вам нужно удалить плагин MarkerManager. Данные плагины не совместимы!"}
            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Usage", "<color=#00ffff>Usage:</color>\n" + " <color=#00ffff>/marker add</color> name(code name) duration(seconds, 0 to permanent) refreshRate(30) radius(0.4) displayName (on map) colorInline (HEX) colorOutline (HEX) alpha (0.75)  - Add marker on map\n" + " <color=#00ffff>/marker remove</color> name (code name, only for custom markers) - Remove marker from map" },
                {"Permission", "You don't have permission to use that!"},
                {"Added", "Marker '{0}' was added on {1}!"},
                {"Removed", "{0} markers with that name was removed!"},
                {"RemovedOldVersion", "You need to remove the MarkerManager plugin. These plugins are not compatible!"}

            }, this);
        }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            StringBuilderInstance.Clear();
            if (args != null)
            {
                StringBuilderInstance.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return StringBuilderInstance.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            string message = GetLang(messageKey, player.UserIDString, args);
            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, 0, message);
        }

        #endregion

        #region Scripts
        private class CustomMapMarker : MonoBehaviour
        {
            private VendingMachineMapMarker vending;
            private MapMarkerGenericRadius generic;
            public BaseEntity parent;
            private bool asChild;

            public new string name;
            public float radius;
            public float alpha;
            public Color color1;
            public Color color2;
            public string displayName;
            public float refreshRate;
            public Vector3 position;
            public int duration;
            public bool placedByPlayer;


            private void Start()
            {
                transform.position = position;
                asChild = parent != null;
                CreateMarkers();
            }

            private void CreateMarkers()
            {
                vending = GameManager.server.CreateEntity(vendingPrefab, position) .GetComponent<VendingMachineMapMarker>();
                vending.markerShopName = displayName;
                vending.enableSaving = false;
                vending.Spawn();

                generic = GameManager.server.CreateEntity(genericPrefab).GetComponent<MapMarkerGenericRadius>();
                generic.color1 = color1;
                generic.color2 = color2;
                generic.radius = radius;
                generic.alpha = alpha;
                generic.enableSaving = false;
                generic.SetParent(vending);
                generic.Spawn();

                if (duration != 0)
                {
                    Invoke(nameof(DestroyMakers), duration);
                }

                UpdateMarkers();

                if (refreshRate > 0f)
                {
                    if (asChild)
                    {
                        InvokeRepeating(nameof(UpdatePosition), refreshRate, refreshRate);
                    }
                    else
                    {
                        InvokeRepeating(nameof(UpdateMarkers), refreshRate, refreshRate);
                    }
                }
            }

            private void UpdatePosition()
            {
                if (asChild == true)
                {
                    if (parent.IsValid() == false)
                    {
                        Destroy(this);
                        return;
                    }
                    else
                    {
                        Vector3 pos = parent.transform.position;
                        transform.position = pos;
                        vending.transform.position = pos;
                    }
                }

                UpdateMarkers();
            }

            public void UpdateMarkers()
            {
                vending.SendNetworkUpdate();
                generic.SendUpdate();
            }

            private void DestroyMakers()
            {
                if (vending.IsValid())
                {
                    vending.Kill();
                }

                if (generic.IsValid())
                {
                    generic.Kill();
                }
            }

            private void OnDestroy()
            {
                DestroyMakers();
            }
        }
        #endregion
    }
}

// --- End of file: MarkerManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-panel ---
// --- Original File Path: M/MagicPanel/MagicPanel.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Panel", "MJSU", "1.0.8")]
    [Description("Displays information to the players on their hud.")]
    internal class MagicPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin ImageLibrary;
        
        private StoredData _storedData; //Plugin Data
        private PluginConfig _pluginConfig; //Plugin Config

        private readonly Hash<string, Hash<string, float>> _panelPositions = new Hash<string, Hash<string, float>>();
        private readonly Hash<string, PanelRegistration> _registeredPanels = new Hash<string, PanelRegistration>();
        private readonly Hash<string, HiddenPanelInfo> _hiddenPanels = new Hash<string, HiddenPanelInfo>();
        private readonly Hash<string, string> _imageCache = new Hash<string, string>();

        private const string AccentColor = "#de8732";

        private bool _init;
        private bool _imageLibraryEnabled;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        private enum PanelAlignEnum { Left = 1, Center = 2, Right = 3 }
        private enum PanelTypeEnum { Global = 1, Player = 2 }
        
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            
            cmd.AddChatCommand(_pluginConfig.ChatCommand, this, MagicPanelChatCommand);
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.On] = "on",
                [LangKeys.Off] = "off",
                [LangKeys.SettingsChanged] = "All your panels are now {0}",
                [LangKeys.Help] = "Controls the visibility of the magic panels:\n" +
                                  $"<color={AccentColor}>/mp on</color> shows all the magic panels\n" +
                                  $"<color={AccentColor}>/mp off</color> hides all the magic panels"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.TextOutline = new TextOutlineSettings
            {
                Enabled = config.TextOutline?.Enabled ?? false,
                Color = config.TextOutline?.Color ?? "#000000FF",
                Distance = config.TextOutline?.Distance ?? "0.5 -0.5"
            };
            
            config.Docks = config.Docks ?? new Hash<string, DockData>
            {
                ["lefttop"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Left,
                    Position = new DockPosition
                    {
                        XPos = .07f,
                        StartYPos = 0.072f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["leftmiddle"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Left,
                    Position = new DockPosition
                    {
                        XPos = .07f,
                        StartYPos = 0.036f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["leftbottom"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Left,
                    Position = new DockPosition
                    {
                        XPos = .07f,
                        StartYPos = 0.0f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["image"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Left,
                    Position = new DockPosition
                    {
                        XPos = 0.65f,
                        StartYPos = 0.0f,
                        Height = 0.1f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["center"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Right,
                    Position = new DockPosition
                    {
                        XPos = 0.644f,
                        StartYPos = 0.109f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["centerupper"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Center,
                    Position = new DockPosition
                    {
                        XPos = .4966f,
                        StartYPos = 0.145f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["bottom"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Center,
                    Position = new DockPosition
                    {
                        XPos = .4966f,
                        StartYPos = 0.0f,
                        Height = 0.0235f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                },
                ["undercompass"] = new DockData
                {
                    BackgroundColor = "#00000000",
                    Enabled = true,
                    Alignment = PanelAlignEnum.Center,
                    Position = new DockPosition
                    {
                        XPos = .4966f,
                        StartYPos = 0.92f,
                        Height = 0.035f
                    },
                    DockPadding = new TypePadding(0.001f, 0.001f, 0, 0),
                    PanelPadding = 0.004f
                }
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _imageLibraryEnabled = ImageLibrary != null && _pluginConfig.UseImageLibrary;

            if (_pluginConfig.ParentLayer != "Overlay"
                && _pluginConfig.ParentLayer != "Hud.Menu"
                && _pluginConfig.ParentLayer != "Hud"
                && _pluginConfig.ParentLayer != "Under"
               )
            {
                PrintWarning($"Invalid UI Parent Layer: {_pluginConfig.ParentLayer}. Valid Values are (Overlay, Hud.Menu, Hud, Under)");
                _pluginConfig.ParentLayer = "Overlay";
            }
            
            NextTick(() =>
            {
                Interface.Call("MagicPanelRegisterPanels");
                _init = true;

                DrawDock(BasePlayer.activePlayerList);

                foreach (PanelRegistration panel in _registeredPanels.Values)
                {
                    DrawPanel(BasePlayer.activePlayerList, panel, UpdateEnum.All);
                }
            });
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyAllUi(player);
            }
        }
        #endregion

        #region Chat Commands
        private void MagicPanelChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                DisplayHelp(player);
                return;
            }
            
            PlayerSettings settings = _storedData.Settings[player.userID];
            if (settings == null)
            {
                settings = new PlayerSettings
                {
                    Enabled = true
                };
                _storedData.Settings[player.userID] = settings;
            }

            switch (args[0].ToLower())
            {
                case "on":
                    settings.Enabled = true;
                    OnPlayerConnected(player);
                    Chat(player, Lang(LangKeys.SettingsChanged, player, Lang(LangKeys.On, player)));
                    break;

                case "off":
                    settings.Enabled = false;
                    DestroyAllUi(player);
                    Chat(player, Lang(LangKeys.SettingsChanged, player, Lang(LangKeys.Off, player)));
                    break;

                default:
                    DisplayHelp(player);
                    break;
            }

            SaveData();
        }

        private void DisplayHelp(BasePlayer player)
        {
            Chat(player, Lang(LangKeys.Help, player));
        }
        #endregion

        #region uMod Hooks
        private void OnPluginUnloaded(Plugin plugin)
        {
            UnregisterPluginPanels(plugin);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1f, () => { OnPlayerConnected(player); });
                return;
            }

            DrawDock(new List<BasePlayer> { player });

            NextTick(() =>
            {
                List<BasePlayer> playerList = new List<BasePlayer> { player };
                foreach (PanelRegistration panel in _registeredPanels.Values)
                {
                    DrawPanel(playerList, panel, UpdateEnum.All);
                }
            });
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            DestroyAllUi(player);
            foreach (HiddenPanelInfo info in _hiddenPanels.Values)
            {
                info.PlayerHidden.Remove(player.userID);
            }
        }
        #endregion

        #region Panel Register
        private void RegisterPlayerPanel(Plugin plugin, string name, string panelData, string getMethodName, string permission = "")
        {
            RegisterPanel(plugin, name, panelData, getMethodName, PanelTypeEnum.Player, permission);
        }

        private void RegisterGlobalPanel(Plugin plugin, string name, string panelData, string getMethodName, string permission = "")
        {
            RegisterPanel(plugin, name, panelData, getMethodName, PanelTypeEnum.Global, permission);
        }

        private void RegisterPanel(Plugin plugin, string name, string panelData, string getMethodName, PanelTypeEnum type, string permission)
        {
            PanelRegistration panel = JsonConvert.DeserializeObject<PanelRegistration>(panelData);
            panel.Plugin = plugin;
            panel.PanelType = type;
            panel.GetPanelMethod = getMethodName;
            panel.Name = name;
            panel.BackgroundColor = Ui.Color(panel.BackgroundColor);
            panel.Permission = permission;
            
            if (string.IsNullOrEmpty(panel.Name))
            {
                PrintError("A registered panel must have a name");
                return;
            }

            if (!_pluginConfig.Docks.ContainsKey(panel.Dock))
            {
                PrintError($"Dock '{panel.Dock}' does not exist for panel '{panel.Name}'");
                return;
            }

            if (!_pluginConfig.Docks[panel.Dock].Enabled)
            {
                PrintError($"Dock '{panel.Dock}' is not enabled and can't have panels assigned to it");
                return;
            }

            _registeredPanels[panel.Name] = panel;
            _hiddenPanels[panel.Name] = new HiddenPanelInfo();
            RecalculatePositions(panel.Dock);
            DrawDock(BasePlayer.activePlayerList);
        }

        private void UnregisterPanel(PanelRegistration panel)
        {
            if (!_registeredPanels.ContainsKey(panel.Name))
            {
                return;
            }

            _registeredPanels.Remove(panel.Name);

            string panelUiName = GetPanelUiName(panel.Name);
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, panelUiName);
            }

            _hiddenPanels[panel.Name] = null;
            RecalculatePositions(panel.Dock);
            DrawDock(BasePlayer.activePlayerList);
        }

        private void UnregisterPluginPanels(Plugin plugin)
        {
            foreach (PanelRegistration panel in _registeredPanels.Values.Where(rp => rp.Plugin.Name == plugin.Name).ToList())
            {
                UnregisterPanel(panel);
            }
        }

        private void RecalculatePositions(string dockName)
        {
            Hash<string, float> panelPositions = _panelPositions[dockName];
            if (panelPositions == null)
            {
                panelPositions = new Hash<string, float>();
                _panelPositions[dockName] = panelPositions;
            }
            
            panelPositions.Clear();

            PanelAlignEnum align = _pluginConfig.Docks[dockName].Alignment;
            DockData dock = _pluginConfig.Docks[dockName];
            DockPosition pos = dock.Position;
            float leftOffset = dock.DockPadding.Left;
            float rightOffSet = dock.DockPadding.Right;

            List<PanelRegistration> dockPanels = _registeredPanels.Values
                .Where(rp => rp.Dock == dockName)
                .OrderBy(rp => rp.Order)
                .ToList();

            float startX = pos.XPos;
            if (align == PanelAlignEnum.Right)
            {
                foreach (PanelRegistration panel in dockPanels)
                {
                    startX -= panel.Width + dock.PanelPadding;
                }
                
                startX -= leftOffset + rightOffSet;
                dockPanels = dockPanels.OrderByDescending(p => p.Order).ToList();
            }
            else if (align == PanelAlignEnum.Center)
            {
                foreach (PanelRegistration panel in dockPanels)
                {
                    startX -= panel.Width / 2 + dock.PanelPadding / 2;
                }

                startX -= (leftOffset + rightOffSet) / 2;
            }

            float offset = leftOffset;
            foreach (PanelRegistration panel in dockPanels)
            {
                panelPositions[panel.Name] = startX + offset;
                offset += panel.Width + dock.PanelPadding;
                DrawPanel(BasePlayer.activePlayerList, panel, UpdateEnum.All);
            }
        }
        #endregion

        #region Panel Update API
        private void UpdatePanel(string panelName, int update)
        {
            if (!_registeredPanels.ContainsKey(panelName))
            {
                return;
            }

            if (_hiddenPanels[panelName].All)
            {
                return;
            }

            NextTick(() =>
            {
                DrawPanel(BasePlayer.activePlayerList, _registeredPanels[panelName], (UpdateEnum)update);
            });
        }

        private void UpdatePanel(BasePlayer player, string panelName, int update)
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                sb.AppendLine($"A - {panelName} - {update}");
                if (!_registeredPanels.ContainsKey(panelName))
                {
                    sb.AppendLine("B");
                    return;
                }
                
                sb.AppendLine("C");

                HiddenPanelInfo hidden = _hiddenPanels[panelName];
                sb.AppendLine($"D - {hidden == null} {hidden?.PlayerHidden == null} {player == null}");
                if (hidden.All || hidden.PlayerHidden.Contains(player.userID))
                {
                    sb.AppendLine("E");
                    return;
                }

                sb.AppendLine("F");
                NextTick(() =>
                {
                    sb.AppendLine("G");
                    DrawPanel(new List<BasePlayer> {player}, _registeredPanels[panelName], (UpdateEnum) update);
                    sb.AppendLine("H");
                });
            }
            catch (Exception ex)
            {
                PrintError($"{sb}\n{ex}");
            }
        }
        #endregion

        #region Panel Show / Hide API
        private void ShowPanel(string name)
        {
            if (!_hiddenPanels[name].All)
            {
                return;
            }

            _hiddenPanels[name].All = false;
            DrawPanel(BasePlayer.activePlayerList, _registeredPanels[name], UpdateEnum.All);
        }

        private void ShowPanel(BasePlayer player, string name)
        {
            if (!_hiddenPanels[name].PlayerHidden.Contains(player.userID))
            {
                return;
            }
            
            _hiddenPanels[name].PlayerHidden.RemoveAll(p => p == player.userID);
            DrawPanel(new List<BasePlayer> { player }, _registeredPanels[name], UpdateEnum.All);
        }

        private void HidePanel(string name)
        {
            if (_hiddenPanels[name].All)
            {
                return;
            }
            
            _hiddenPanels[name].All = true;
            DrawPanel(BasePlayer.activePlayerList, _registeredPanels[name], UpdateEnum.All);
        }

        private void HidePanel(BasePlayer player, string name)
        {
            if (_hiddenPanels[name].PlayerHidden.Contains(player.userID))
            {
                return;
            }
            
            _hiddenPanels[name].PlayerHidden.Add(player.userID);
            DrawPanel(new List<BasePlayer> { player }, _registeredPanels[name], UpdateEnum.All);
        }
        #endregion

        #region Panel Draw

        private void DrawDock(IEnumerable<BasePlayer> players)
        {
            foreach (BasePlayer player in players)
            {
                PlayerSettings settings = _storedData.Settings[player.userID];
                if (settings != null && !settings.Enabled)
                {
                    continue;
                }

                foreach (KeyValuePair<string, DockData> dock in _pluginConfig.Docks.Where(d => d.Value.Enabled))
                {
                    string dockName = GetDockUiName(dock.Key);
                    CuiElementContainer container = Ui.Container(Ui.Color(dock.Value.BackgroundColor), GetDockUiPosition(dock.Value.Position, dock.Key), dockName, _pluginConfig.ParentLayer);
                    CuiHelper.DestroyUi(player, dockName);
                    CuiHelper.AddUi(player, container);
                }
            }
        }

        private void DrawPanel(IEnumerable<BasePlayer> players, PanelRegistration registeredPanel, UpdateEnum updateEnum)
        {
            if (!_init)
            {
                return;
            }

            players = players
                .Where(p => _storedData.Settings[p.userID]?.Enabled ?? true
                            && (string.IsNullOrEmpty(registeredPanel.Permission)
                            || permission.UserHasPermission(p.UserIDString, registeredPanel.Permission)))
                .ToList();
            if (!players.Any())
            {
                return;
            }

            PanelSetup setup = new PanelSetup
            {
                Pos = _pluginConfig.Docks[registeredPanel.Dock].Position,
                PanelColor = registeredPanel.BackgroundColor,
                StartPos = _panelPositions[registeredPanel.Dock][registeredPanel.Name],
                UiParentPanel = GetPanelUiName(registeredPanel.Name),
                PanelReg = registeredPanel,
            };
            
            if (registeredPanel.PanelType == PanelTypeEnum.Global)
            {
                DrawGlobalPanel(players, setup, updateEnum);
            }
            else if (registeredPanel.PanelType == PanelTypeEnum.Player)
            {
                DrawPlayersPanel(players, setup, updateEnum);
            }
        }

        private void DrawGlobalPanel(IEnumerable<BasePlayer> players, PanelSetup setup, UpdateEnum updateEnum)
        {
            PanelRegistration reg = setup.PanelReg;
            HiddenPanelInfo info = _hiddenPanels[reg.Name];
            if (info.All)
            {
                return;
            }
            
            Hash<string, object> panelData = reg.Plugin.Call(reg.GetPanelMethod, reg.Name) as Hash<string, object>;
            if (panelData == null)
            {
                PrintError($"DrawGlobalPanel: {reg.Plugin.Name} returned no data from {reg.GetPanelMethod} method");
                return;
            }
            
            Panel panel = new Panel(panelData);
            List<PanelUpdate> containers = CreatePanel(panel, setup, updateEnum);
            foreach (PanelUpdate update in containers)
            {
                string json = CuiHelper.ToJson(update.Container);
                foreach (BasePlayer player in players)
                {
                    CuiHelper.DestroyUi(player, update.PanelName);
                    if (!info.PlayerHidden.Contains(player.userID))
                    {
                        CuiHelper.AddUi(player, json);
                    }
                }
            }
        }

        private void DrawPlayersPanel(IEnumerable<BasePlayer> players, PanelSetup setup, UpdateEnum updateEnum)
        {
            HiddenPanelInfo info = _hiddenPanels[setup.PanelReg.Name];
            if (info.All)
            {
                return;
            }
            
            foreach (BasePlayer player in players)
            {
                PanelRegistration reg = setup.PanelReg;
                Hash<string, object> panelData = reg.Plugin.Call(reg.GetPanelMethod, player, reg.Name) as Hash<string, object>;
                if (panelData == null)
                {
                    PrintError($"DrawPlayersPanel: {reg.Plugin.Name} returned no data from {reg.GetPanelMethod} method");
                    return;
                }
                
                Panel panel = new Panel(panelData);
                foreach (PanelUpdate update in CreatePanel(panel, setup, updateEnum))
                {
                    CuiHelper.DestroyUi(player, update.PanelName);
                    if (!info.PlayerHidden.Contains(player.userID))
                    {
                        CuiHelper.AddUi(player, update.Container);
                    }
                }
            }
        }

        private List<PanelUpdate> CreatePanel(Panel panel, PanelSetup setup, UpdateEnum update)
        {
            List<PanelUpdate> containers = new List<PanelUpdate>();
            
            if (update == UpdateEnum.All || update == UpdateEnum.Panel)
            {
                TypePadding dockPadding = _pluginConfig.Docks[setup.PanelReg.Dock].DockPadding;
                UiPosition pos = GetPanelPosition(setup, dockPadding);
                CuiElementContainer container = Ui.Container(setup.PanelColor, pos, setup.UiParentPanel, _pluginConfig.ParentLayer);
                containers.Add(new PanelUpdate
                {
                    Container = container,
                    PanelName = setup.UiParentPanel
                });
            }

            List<PanelType> panelTypes = new List<PanelType>();
            if (panel.Text != null)
            {
                panelTypes.Add(panel.Text);
            }

            if (panel.Image != null)
            {
                panelTypes.Add(panel.Image);
            }
            
            float offset = 0;
            foreach (PanelType type in panelTypes.Where(pt => pt.Enabled).OrderBy(pt => pt.Order))
            {
                if (type is PanelText)
                {
                    if (update == UpdateEnum.All || update == UpdateEnum.Text)
                    {
                        containers.Add(CreateText(panel, setup.UiParentPanel, offset));
                    }
                }
                else if (type is PanelImage)
                {
                    if (update == UpdateEnum.All || update == UpdateEnum.Image)
                    {
                        containers.Add(CreateImage(panel, setup.UiParentPanel, offset));
                    }
                }
                
                offset += type.Width;
            }

            return containers;
        }

        private PanelUpdate CreateImage(Panel panel, string panelName, float offset)
        {
            string imageName = GetPanelUiImageName(panelName);
            UiPosition pos = GetTypePosition(offset, panel.Image.Width, panel.Image.Padding);
            CuiElementContainer container = Ui.Container(_clearColor, pos, imageName, panelName);
            Ui.Image(ref container, ImageLibraryGetImage(panel.Image.Url) ?? string.Empty, Ui.Color(panel.Image.Color), _fullSize);
            return new PanelUpdate
            {
                Container = container,
                PanelName = imageName
            };
        }

        private PanelUpdate CreateText(Panel panel, string panelName, float offset)
        {
            string textName = GetPanelUiTextName(panelName);
            UiPosition pos = GetTypePosition(offset, panel.Text.Width, panel.Text.Padding);
            CuiElementContainer container = Ui.Container(_clearColor, pos, textName, panelName);
            if (_pluginConfig.TextOutline.Enabled)
            {
                Ui.OutlineLabel(ref container, panel.Text.Text ?? string.Empty, panel.Text.FontSize, Ui.Color(panel.Text.Color), 
                    Ui.Color(_pluginConfig.TextOutline.Color), _pluginConfig.TextOutline.Distance, _fullSize, panel.Text.TextAnchor);
            }
            else
            {
                Ui.Label(ref container, panel.Text.Text ?? string.Empty, panel.Text.FontSize, Ui.Color(panel.Text.Color), _fullSize, panel.Text.TextAnchor);
            }
            
            return new PanelUpdate
            {
                Container = container,
                PanelName = textName
            };
        }
        #endregion

        #region Image Library
        private bool IsImageLibraryReady()
        {
            return ImageLibrary?.Call<bool>("IsReady") ?? false;
        }
        
        private void ImageLibraryAddImage(string image)
        {
            ImageLibrary.Call("AddImage", image, image, (ulong)0);
        }
        
        private bool ImageLibraryHasImage(string image)
        {
            return ImageLibrary.Call<bool>("HasImage", image, (ulong)0);
        }

        private string ImageLibraryGetImage(string image)
        {
            if (!_imageLibraryEnabled)
            {
                return image;
            }
            
            string cache = _imageCache[image];
            if (!string.IsNullOrEmpty(cache))
            {
                return cache;
            }
            
            if (!IsImageLibraryReady())
            {
                return image;
            }
            
            if (!ImageLibraryHasImage(image))
            {
                ImageLibraryAddImage(image);
                return image;
            }
            
            string data = ImageLibrary.Call<string>("GetImage", image, (ulong)0, true);
            if (string.IsNullOrEmpty(data))
            {
                return image;
            }

            _imageCache[image] = data;
            return data;
        }
        #endregion

        #region Helper Methods

        private string GetPanelUiName(string panelName)
        {
            return $"{UiPanelName}_{panelName}";
        }

        private string GetPanelUiImageName(string panelName)
        {
            return $"{panelName}_Image";
        }

        private string GetPanelUiTextName(string panelName)
        {
            return $"{panelName}_Text";
        }

        private string GetDockUiName(string dockName)
        {
            return $"{UiPanelName}_dock_{dockName}";
        }

        private UiPosition GetTypePosition(float startPos, float width, TypePadding padding)
        {
            UiPosition pos = new UiPosition(startPos + padding.Left,
                padding.Bottom,
                width * (1 - (padding.Left + padding.Right)),
                1 - (padding.Top + padding.Bottom));
            return pos;
        }

        private UiPosition GetPanelPosition(PanelSetup setup, TypePadding dockPadding)
        {
           return new UiPosition(setup.StartPos, 
               setup.Pos.StartYPos + dockPadding.Bottom,
               setup.PanelReg.Width, 
               setup.Pos.Height - (dockPadding.Bottom + dockPadding.Top));
        }

        private UiPosition GetDockUiPosition(DockPosition pos, string dockName)
        {
            float startPos = 0f;
            float endPos = 0f;
            if (_panelPositions.ContainsKey(dockName))
            {
                DockData dock = _pluginConfig.Docks[dockName];
                ICollection<float> panels = _panelPositions[dockName].Values;
                if (panels.Count != 0)
                {
                    startPos = panels.Min(pp => pp) - dock.DockPadding.Left;
                    endPos = panels.Max(pp => pp) + dock.DockPadding.Right;
                    endPos += _registeredPanels.Values.Where(p => p.Dock == dockName).OrderBy(p => p.Order).Last()?.Width ?? 0;
                }
            }
            
            return new UiPosition(startPos, pos.StartYPos, endPos - startPos , pos.Height);
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void Chat(BasePlayer player, string format, params object[] args) => PrintToChat(player, Lang(LangKeys.Chat, player, format), args);

        private string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue("mp")]
            [JsonProperty(PropertyName = "Chat Command")]
            public string ChatCommand { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Use Image Library")]
            public bool UseImageLibrary { get; set; }
            
            [DefaultValue("Under")]
            [JsonProperty(PropertyName = "Parent UI Layer (Overlay, Hud.Menu, Hud, Under)")]
            public string ParentLayer { get; set; }
            
            [JsonProperty(PropertyName = "Text Outline Settings")]
            public TextOutlineSettings TextOutline { get; set; }
            
            [JsonProperty(PropertyName = "Docks")]
            public Hash<string, DockData> Docks { get; set; }
        }
        
        private class TextOutlineSettings
        {
            [JsonProperty(PropertyName = "Enable Text Outline")]
            public bool Enabled { get; set; }
            
            [JsonProperty(PropertyName = "Text Outline Color")]
            public string Color { get; set; }            
            
            [JsonProperty(PropertyName = "Text Outline Distance")]
            public string Distance { get; set; }
        }

        private class DockData
        {
            [JsonProperty(PropertyName = "Position")]
            public DockPosition Position { get; set; }

            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Background Color")]
            public string BackgroundColor { get; set; }
            
            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Panel Alignment (Left, Center, Right)")]
            public PanelAlignEnum Alignment { get; set; }

            [JsonProperty(PropertyName = "Panel Padding")]
            public float PanelPadding { get; set; }
            
            [JsonProperty(PropertyName = "Dock Padding")]
            public TypePadding DockPadding { get; set; }
        }

        private class DockPosition
        {
            [JsonProperty(PropertyName = "X Position")]
            public float XPos { get; set; }

            [JsonProperty(PropertyName = "Y Start Position")]
            public float StartYPos { get; set; }

            [JsonProperty(PropertyName = "Height")]
            public float Height { get; set; }
        }

        private class StoredData
        {
            public Hash<ulong, PlayerSettings> Settings = new Hash<ulong, PlayerSettings>();
        }
        
        private static class LangKeys
        {
            public const string On = "On";
            public const string Off = "Off";
            public const string SettingsChanged = "SettingsChanged";
            public const string Chat = "Chat";
            public const string Help = "Help";
        }

        private class PlayerSettings
        {
            public bool Enabled { get; set; }
        }

        private class PanelRegistration
        {
            public string Name { get; set; }
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
            public string GetPanelMethod { get; set; }
            public PanelTypeEnum PanelType { get; set; }
            public Plugin Plugin { get; set; }
            public string Permission { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; }
            public PanelText Text { get; }
            
            public Panel(Hash<string, object> data)
            {
                if (data.ContainsKey(nameof(Image)))
                {
                    Image = new PanelImage((Hash<string, object>)data[nameof(Image)]);
                }
                
                if (data.ContainsKey(nameof(Text)))
                {
                    Text = new PanelText((Hash<string, object>)data[nameof(Text)]);
                }
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; }
            public string Color { get; }
            public int Order { get; }
            public float Width { get; }
            public TypePadding Padding { get; }
            
            protected PanelType(Hash<string, object> data)
            {
                Enabled = (bool) data[nameof(Enabled)];
                Color = (string) data[nameof(Color)];
                Order = (int) data[nameof(Order)];
                Width = (float) data[nameof(Width)];
                Padding = new TypePadding((Hash<string,object>)data[nameof(Padding)]);
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; }
            
            public PanelImage(Hash<string, object> data) : base(data)
            {
                Url = (string) data[nameof(Url)];
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; }
            public int FontSize { get; }
            public TextAnchor TextAnchor { get; }
            
            public PanelText(Hash<string, object> data) : base(data)
            {
                Text = (string) data[nameof(Text)];
                FontSize = (int) data[nameof(FontSize)];
                TextAnchor = (TextAnchor) data[nameof(TextAnchor)];
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            [JsonConstructor]
            public TypePadding() { }
            
            public TypePadding(Hash<string, object> data)
            {
                Left = (float) data[nameof(Left)];
                Right = (float) data[nameof(Right)];
                Top = (float) data[nameof(Top)];
                Bottom = (float) data[nameof(Bottom)];
            }
            
            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
        }

        private class PanelSetup
        {
            public DockPosition Pos { get; set; }
            public float StartPos { get; set; }
            public string UiParentPanel { get; set; }
            public string PanelColor { get; set; }
            public PanelRegistration PanelReg { get; set; }
        }

        private class PanelUpdate
        {
            public CuiElementContainer Container { get; set; }
            public string PanelName { get; set; }
        }

        private class HiddenPanelInfo
        {
            public List<ulong> PlayerHidden { get; }
            public bool All { get; set; }

            public HiddenPanelInfo()
            {
                All = false;
                PlayerHidden = new List<ulong>();
            }
        }
        #endregion

        #region UI
        private const string UiPanelName = "MagicPanel";
        private readonly string _clearColor = Ui.Color("#00000000");
        private readonly UiPosition _fullSize = new UiPosition(0, 0, 1, 1);

        private static class Ui
        {
            private static string UiPanel { get; set; }

            public static CuiElementContainer Container(string color, UiPosition pos, string panel, string parent)
            {
                UiPanel = panel;
                return new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax()},
                            CursorEnabled = false
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
            }

            public static void Label(ref CuiElementContainer container, string text, int size, string color, UiPosition pos, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Color = color },
                    RectTransform = { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() }
                },
                UiPanel);
            }
            
            public static void OutlineLabel(ref CuiElementContainer container, string text, int size, string color, string outlineColor, string distance, UiPosition pos, TextAnchor align = TextAnchor.MiddleCenter)
            {
                string name = CuiHelper.GetGuid();

                CuiOutlineLabel outlineLabel = new CuiOutlineLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Color = color },
                    RectTransform = { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() },
                    Outline = { Color = outlineColor, Distance = distance }
                };
                
                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = UiPanel,
                    FadeOut = outlineLabel.FadeOut,
                    Components = {
                        outlineLabel.Text,
                        outlineLabel.RectTransform,
                        outlineLabel.Outline
                    }
                });
                
                container.Add(new CuiOutlineLabel
                    {
                        Text = { FontSize = size, Align = align, Text = text, Color = color },
                        RectTransform = { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() },
                        Outline = { Color = outlineColor, Distance = "1.0 -1.0"}
                    },
                    UiPanel);
            }

            public static void Image(ref CuiElementContainer container, string png, string color, UiPosition pos)
            {
                uint value;
                bool isPng = uint.TryParse(png, out value);

                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = UiPanel,
                    Components =
                    {
                        new CuiRawImageComponent { Color = color, Png = isPng ? png : null, Url = !isPng ? png : null },
                        new CuiRectTransformComponent { AnchorMin = pos.GetMin(), AnchorMax = pos.GetMax() }
                    }
                });
            }

            public static string Color(string hexColor)
            {
                hexColor = hexColor.TrimStart('#');
                if (hexColor.Length != 6 && hexColor.Length != 8)
                {
                    hexColor = "000000";
                }
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                int alpha = 255;
                if (hexColor.Length == 8)
                {
                    alpha = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
                }

                return $"{red / 255.0} {green / 255.0} {blue / 255.0} {alpha / 255.0}";
            }
        }

        private class CuiOutlineLabel : CuiLabel
        {
            public CuiOutlineComponent Outline { get; } = new CuiOutlineComponent();
        }

        private class UiPosition
        {
            private float XPos { get; }
            private float YPos { get; }
            private float Width { get; }
            private float Height { get; }

            public UiPosition(float xPos, float yPos, float width, float height)
            {
                XPos = xPos;
                YPos = yPos;
                Width = width;
                Height = height;
            }

            public string GetMin() => $"{XPos} {YPos}";
            public string GetMax() => $"{XPos + Width} {YPos + Height}";

            public override string ToString()
            {
                return $"{XPos} {YPos} {Width} {Height}";
            }
        }

        private void DestroyAllUi(BasePlayer player)
        {
            foreach (PanelRegistration panel in _registeredPanels.Values)
            {
                string panelName = GetPanelUiName(panel.Name);
                CuiHelper.DestroyUi(player, panelName);
                CuiHelper.DestroyUi(player, GetPanelUiImageName(panelName));
                CuiHelper.DestroyUi(player, GetPanelUiTextName(panelName));
            }

            foreach (string dock in _pluginConfig.Docks.Keys)
            {
                CuiHelper.DestroyUi(player, GetDockUiName(dock));
            }
        }
        #endregion
    }
}


// --- End of file: MagicPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-birthday-cake ---
// --- Original File Path: M/MyBirthdayCake/MyBirthdayCake.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;   //String.
using Convert = System.Convert;
using Oxide.Core;   //storeddata

namespace Oxide.Plugins
{
    [Info("My Birthday Cake", "Krungh Crow", "1.1.0")]
    [Description("Throw a Birthday Cake Bomb")]

    #region Changelogs and ToDo
    /*******************************************************************************
    * 
    * Thanks to BuzZ[PHOQUE] the original author of this plugin
    * 
    * 1.0.1 :   Started to maintain
    *       :   Updated Hook (OnActiveItemChanged)
    * 1.1.0 :   Reformatting the coding
    *       :   Fixed Compiling issues
    * 
    ********************************************************************************/
    #endregion

    public class MyBirthdayCake : RustPlugin
    {
        bool debug = false;
        private bool ConfigChanged;

        string Prefix = "[MBC] ";
        ulong ChatIcon = 76561198357983957;
        float flamingtime = 30f;
        string cakename = "Birthday Cake ";
        const string Cake_Perm = "mybirthdaycake.use";
    
        class StoredData
        {
            public Dictionary<ulong, Cake> Cakes = new Dictionary<ulong,Cake>();
            public StoredData() { }
        }
        private StoredData storedData;

        class Cake
        {
            public ulong playerownerID;
            public bool explosion;
            //public bool smokebirthday;
            public bool fire;
            public bool oilflames;
            public bool napalmflames;
            public bool flameonthrow;
        }

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(Cake_Perm, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermMsg", "You don't have permission to do that."},
                {"SpecifyMsg", "Please specify - explose - oil - napalm - fire"},
                {"GiftMsg", "Gift : Birthday Cake with {0} !"},
                {"WishMsg", "Wish a Happy Birthday !!"},
                {"NotYoursMsg", "This Cake is not yours ! It is no more a special one ..."},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermMsg", "Vous n'avez pas la permission."},
                {"SpecifyMsg", "Merci de préciser - explose - oil - napalm - fire"},
                {"GiftMsg", "Cadeau : un beau gâteau {0} !"},
                {"WishMsg", "Souhaitez un Joyeux Zanniversaire!!"},
                {"NotYoursMsg", "Ce gâteau n'est pas à vous, suppression de ses capacités meurtrières ..."},

            }, this, "fr");
        }

#endregion

        #region Config

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            ChatIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon" , "76561198357983957"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NONE YET /
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Plugin Prefix", "[MBC] "));
            flamingtime = Convert.ToSingle(GetConfig("Flames Settings", "Duration in seconds", "30"));
            cakename = Convert.ToString(GetConfig("Cake Settings", "Name", "Birthday Cake "));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

        #endregion

        #region Chat Commands
        [ChatCommand("cake")]
        private void Cake_Permer(BasePlayer player , string command , string[] args)
        {
            bool isauth = permission.UserHasPermission(player.UserIDString , Cake_Perm);
            if (!isauth)
            {
                Player.Message(player , lang.GetMessage("NoPermMsg" , this , player.UserIDString) , Prefix , ChatIcon);
                return;
            }
            CreateCake(player , args);
        }
        #endregion

        #region Hooks
        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name , storedData);
        }

        void OnMeleeThrown(BasePlayer player , Item item)
        {
            if (storedData.Cakes.ContainsKey(item.uid.Value) == false) return;
            if (debug) Puts($"BIRTHDAYCAKE !!! {item}");
            timer.Once(5f , () =>
            {
                DelaydCakeTrigger(item.uid.Value , item);
            });
        }

        void OnActiveItemChanged(BasePlayer player , Item oldItem , Item newItem)
        {
            if (player == null) return;
            if (newItem == null) return;
            ulong cakeId = new ulong();
            foreach (var item in storedData.Cakes)
            {
                if (newItem.uid.Value == item.Key)
                {
                    Cake cake = item.Value;
                    if (cake.playerownerID == player.userID)
                        Player.Message(player , lang.GetMessage("WishMsg" , this , player.UserIDString) , Prefix , ChatIcon);
                    else
                    {
                        Player.Message(player , lang.GetMessage("NotYoursMsg" , this , player.UserIDString) , Prefix , ChatIcon);
                        cakeId = item.Key;
                    }
                }
            }
            if (cakeId != null) storedData.Cakes.Remove(cakeId);
        }
        #endregion

        #region Methods

        void DelaydCakeTrigger(ulong cakeid, Item item)
        {
            BaseEntity entity = item.GetWorldEntity();
            if (entity == null)
            {
                if (debug) Puts("ENTITY NULL !");
                return;
            }
            Cake cake = new Cake();
            storedData.Cakes.TryGetValue(cakeid, out cake);
            if (cake == null) return;
            // type of explosion
            ////if (cake.smokebirthday) CakeRunTrigger(item, "smoke", entity);
            if (cake.explosion) CakeRunTrigger(item, "explose", entity);
            // type of flames
            if (cake.oilflames) CakeRunTrigger(item, "oil", entity);
            if (cake.napalmflames) CakeRunTrigger(item, "napalm", entity);
            if (cake.fire) CakeRunTrigger(item, "fire", entity);
            NextFrame(() =>
            {
                entity.Kill();
                storedData.Cakes.Remove(item.uid.Value);
                });
            }

        void CakeRunTrigger(Item item, string birthdaytype, BaseEntity entity)
        {
            if (debug) Puts("BoomBoom sequence");
            Vector3 daboom = new Vector3(entity.transform.position.x,entity.transform.position.y,entity.transform.position.z);
            if (debug) Puts($"Vector3 {daboom}");
            TimedExplosive boom = new TimedExplosive();
            //SmokeGrenade boomboom = new SmokeGrenade();
            if (birthdaytype == "explose")
            {
                BaseEntity GrenadeF1 = GameManager.server.CreateEntity("assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", daboom, new Quaternion(), true);
                if (GrenadeF1 == null) if (debug) Puts("GrenadeF1 NULL BaseEntity ENTITY !!!!");
                else if (debug) Puts($"oright {GrenadeF1}");
                boom = GrenadeF1.GetComponent<TimedExplosive>();
                if (boom == null) Puts("boom NULL TimedExplosive ENTITY !!!!");
                if (debug) Puts("F1 BIRTHDAY !!!!");
                boom.Explode();
                return;
             }
            /*if (birthdaytype == "smoke")
            {
                prefab = "assets/prefabs/tools/smoke grenade/grenade.smoke.deployed.prefab";
                Puts("SMOKE BIRTHDAY !!!!");
                BaseEntity GrenadeSmoke = GameManager.server.CreateEntity(prefab, daboom, new Quaternion(), true);
                if (GrenadeSmoke == null) Puts("GrenadeSmoke NULL BaseEntity ENTITY !!!!");
                else Puts($"oright {GrenadeSmoke}");
                boomboom = GrenadeSmoke.GetComponent<SmokeGrenade>();
                if (boomboom != null) Puts($"SmokeGrenade {boomboom}");
                boomboom.smokeDuration = 20f;
                GrenadeSmoke.Spawn();
                //boomboom.Explode();
                return;
            }*/
            string prefab = string.Empty;
            if (birthdaytype == "fire") prefab = "assets/bundled/prefabs/fireball.prefab";
            if (birthdaytype == "oil") prefab = "assets/bundled/prefabs/oilfireballsmall.prefab";
            if (birthdaytype == "napalm") prefab = "assets/bundled/prefabs/napalm.prefab";
            BaseEntity GrenadeFlames = GameManager.server.CreateEntity(prefab, daboom, new Quaternion(), true);
            if (GrenadeFlames == null) if (debug) Puts("GrenadeFlames NULL BaseEntity ENTITY !!!!");
            else if (debug) Puts($"oright fireflames {GrenadeFlames}");
            GrenadeFlames?.Spawn();
            timer.Once(flamingtime, () => 
            {
                if (GrenadeFlames != null) GrenadeFlames.Kill();
            });
        }

        private void CreateCake(BasePlayer player , string[] args)
        {
            Cake cake = new Cake();
            cake.playerownerID = player.userID;
            string CakeType = "";
            if (args.Contains("explose"))
            {
                CakeType = "|Xplosiv";
                cake.explosion = true;
            }
            /*if (args.Contains("smoke"))
            {
                CakeType = $"{CakeType}|Smoke";
                cake.smokebirthday = true;
            }*/
            if (args.Contains("oil"))
            {
                CakeType = $"{CakeType}|Oil";
                cake.oilflames = true;
            }
            if (args.Contains("napalm"))
            {
                CakeType = $"{CakeType}|Napalm";
                cake.napalmflames = true;
            }
            if (args.Contains("fire"))
            {
                CakeType = $"{CakeType}|Fire";
                cake.fire = true;
            }
            if (CakeType == "")
            {
                Player.Message(player , lang.GetMessage("SpecifyMsg" , this , player.UserIDString) , Prefix , ChatIcon);
                return;
            }
            Item caketogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(1973165031).itemid , 1 , 0);
            if (caketogive != null)
            {
                caketogive.name = cakename + CakeType;
                player.GiveItem(caketogive);
                storedData.Cakes.Add(caketogive.uid.Value , cake);
                Player.Message(player , String.Format(lang.GetMessage("GiftMsg" , this , player.UserIDString) , CakeType) , Prefix , ChatIcon);
            }
        }

        #endregion
    }
}

// --- End of file: MyBirthdayCake.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-my-death ---
// --- Original File Path: M/MapMyDeath/MapMyDeath.cs ---

﻿using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using System.Linq;  //tolist
using UnityEngine;  //txtanchor
using Convert = System.Convert;
using System;   //String.format

namespace Oxide.Plugins
{
    [Info("Map My Death", "BuzZ[PHOQUE]", "0.0.4")]
    [Description("Displays a mapmarker and a popup with distance on player death")]

/*======================================================================================================================= 
*
*   THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   0.0.2   20190201    NRE code
*   0.0.3   20190517    networkto conflict vanishes
*
*=======================================================================================================================*/

    public class MapMyDeath : RustPlugin
    {
        //NO CHAT MESSAGES ON THIS VERSION
        //string Prefix = "[MMD] ";                       // CHAT PLUGIN PREFIX
        //ulong SteamIDIcon = 76561197991909498;          // SteamID FOR PLUGIN ICON

    class StoredData
    {
        public Dictionary<ulong, DeathInfo> playerdeath = new Dictionary<ulong, DeathInfo>();    
        
        public StoredData()
        {
        }
    }

    class DeathInfo
    {
        public float playerx;
        public float playery;
        public float playerz;
// timeofdeath
// lastdamage
    }

    private StoredData storedData;

    public Dictionary<ulong, MapMarkerGenericRadius> MapMarker = new Dictionary<ulong, MapMarkerGenericRadius>(); 

    bool debug = false;
    float markertime;
    bool ConfigChanged;
    string markertimeint = "2";
    int meters;
    float daradius = 3;

    void Init()
    {
        LoadVariables();
        storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
    }

#region MESSAGES

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"RespawnMsg", "A black marker shows on map where your corpse was last seen, at {0}m. away"},
        }, this, "en");

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"RespawnMsg", "Un marqueur noir indique sur votre carte le lieu de votre dernière mort, à {0}m. d'ici"},
        }, this, "fr");
    }


#endregion
#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {

            markertimeint = Convert.ToString(GetConfig("Map Marker will show", "Value in minutes", "2"));       
            daradius = Convert.ToSingle(GetConfig("Marker Settings", "Radius", "3"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion
#region UNLOAD = KILL MARKERS

    void Unload()
    {
        if (MapMarker != null)
        {
            foreach (var markerz in MapMarker)
            {
                if (markerz.Value != null)
                {
                    markerz.Value.Kill();
                    markerz.Value.SendUpdate();
                    if (debug) Puts($"-> UNLOAD DEATH MARKER");
                }
            }
        }                   
        Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
    }
#endregion
#region ON DEATH
        
    void OnPlayerDeath(BasePlayer player, HitInfo info)
    {
        if (player == null)
        {
            if (debug) Puts($"-> ERROR on VOID OnPlayerDie -> BasePlayer is Null");
            return;
        }
        if (MapMarker.ContainsKey(player.userID))
        {
            MapMarkerGenericRadius tokill = new MapMarkerGenericRadius();
            MapMarker.TryGetValue(player.userID, out tokill);
            if (tokill != null)
            {
                tokill.Kill();
                tokill.SendUpdate();
                if (debug) Puts($"-> UNLOAD DEATH MARKER ON NEW DEATH");
            }
        }   
        foreach(BasePlayer playerzonlinez in BasePlayer.activePlayerList.ToList())
        {
            if (player == playerzonlinez)
            {
                            
            //future
            //player.UserIDString; 
            //string playername;
            //string shortplayername;
            //shortplayername = playername.Substring(0,8);

            UpdatePos(player);

            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

                if (debug) Puts($"-> PLAYER DEATH recorded for {player.UserIDString}");
            }
        }
    }

#endregion
#region NETWORK FILTER

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (entity is MapMarkerGenericRadius)
            {
                MapMarkerGenericRadius entitymarker = entity.GetComponent<MapMarkerGenericRadius>();
                if (entitymarker == null || target == null) return null;
                if (MapMarker.ContainsValue(entitymarker))
                {
                    foreach (var deadmarkers in MapMarker)
                    {
                        if (deadmarkers.Value == entitymarker)
                        {
                            if (deadmarkers.Key == target.userID) return null;
                            else return true;
                        }
                    }
                }
            }
            return null;
        }

#endregion
#region UPDATE POSITION

    void UpdatePos(BasePlayer player)
    {
        float posx;
        posx = player.transform.position.x;
        float posy;
        posy = player.transform.position.y;
        float posz;
        posz = player.transform.position.z;
        float check;

        if (posx == null || posy == null || posz == null)
        {           
            if (debug) Puts($"-> DEATH Position update ERROR for {player.UserIDString}");
            return;
        }

        if (storedData.playerdeath.ContainsKey(player.userID)) storedData.playerdeath.Remove(player.userID);
        DeathInfo deadnow = new DeathInfo();
        deadnow.playerx = posx;
        deadnow.playery = posy;
        deadnow.playerz = posz;
        storedData.playerdeath.Remove(player.userID);        
        storedData.playerdeath.Add(player.userID, deadnow);
        if (debug) Puts($"-> DEATH Position updated for {player.UserIDString}");
    }
#endregion
#region GET PLAYER POSITION AND MARKER

    void GetPos(BasePlayer player)
    {
        if (storedData.playerdeath.ContainsKey(player.userID) == false)
        {
            Puts($"-> DEATH Position unknown for {player.UserIDString}");
            return;
        }  
        float posx = storedData.playerdeath[player.userID].playerx;
        float posy = storedData.playerdeath[player.userID].playery;
        float posz = storedData.playerdeath[player.userID].playerz;
        Vector3 deadly = new Vector3(posx,posy,posz);
        meters = (int)Vector3.Distance(deadly, player.transform.position);
        MapMarkerGenericRadius deathmarker = new MapMarkerGenericRadius();
        deathmarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", deadly) as MapMarkerGenericRadius;
        if (deathmarker == null)
        {
            if (debug) Puts("ERROR - NULL MARKER CREATION");
            return;
        }
        deathmarker.alpha = 1f;
        deathmarker.color1 = Color.black;
        deathmarker.color2 = Color.white;
        deathmarker.radius = daradius;
        MapMarker.Remove(player.userID);        
        MapMarker.Add(player.userID, deathmarker);
        if (debug) Puts($"-> DEATH MARKER prefab for {player.UserIDString} {posx} {posy} {posz}");
    }
#endregion
#region ON RESPAWN - SLEEP ENDED

    private void OnPlayerSleepEnded(BasePlayer player)
    {
        if (storedData.playerdeath.ContainsKey(player.userID))
        {
            GetPos(player);
            if (MapMarker.ContainsKey(player.userID))
            {                       
                MapMarkerGenericRadius deathmarker = new MapMarkerGenericRadius();
                MapMarker.TryGetValue(player.userID, out deathmarker);
                if (deathmarker != null)
                {
                    deathmarker.Spawn();
                    deathmarker.SendUpdate();
                    if (debug) Puts($"-> DEATH MARKER SPAWN for {player.UserIDString}");
                }
            
// CUI POPUP - INFO MESSAGE

                timer.Once(10f, () =>
                {
                    var CuiElement = new CuiElementContainer();
                    var DeadBanner = CuiElement.Add(new CuiPanel{Image ={Color = "0.5 0.5 0.5 0.75"},
                        RectTransform ={AnchorMin = "0.20 0.85",AnchorMax = "0.80 0.90"},
                        CursorEnabled = false});
                    var closeButton = new CuiButton{Button ={Close = DeadBanner,Color = "0.0 0.0 0.0 0.6"},
                        RectTransform ={AnchorMin = "0.90 0.01",AnchorMax = "0.99 0.99"},
                        Text ={Text = "X",FontSize = 20,Align = TextAnchor.MiddleCenter}
                        };
                    CuiElement.Add(closeButton, DeadBanner);
                    CuiElement.Add(new CuiLabel{Text ={Text = String.Format(lang.GetMessage("RespawnMsg", this, player.UserIDString), meters),FontSize = 18,
                        Align = TextAnchor.MiddleCenter,Color = "1.0 1.0 1.0 1"},
                        RectTransform ={AnchorMin = "0.10 0.10",   AnchorMax = "0.90 0.90"}
                        }, DeadBanner);
                        CuiHelper.AddUi(player, CuiElement);
                    timer.Once(25f, () =>
                    {
                            CuiHelper.DestroyUi(player, DeadBanner);
                    });
                });                

// KILL MARKER AFTER 2 MINUTES
                if (debug) Puts($"-> TIME IN CONF : {markertimeint}");
                markertime = Convert.ToSingle(markertimeint);
                if (debug) Puts($"-> MARKER TIME TO FLOAT FROM CONF : {markertime}");
                markertime = markertime * 60;
                if (debug) Puts($"-> MARKER TIME IN SECONDS {markertime}");
                if (markertime <= 0)
                {
                    markertime = 120;
                    if (debug) Puts($"-> ERROR :/ wrong entry value in config file.");           
                    if (debug) Puts($"-> MARKER TIME IN SECONDS {markertime}");
                }
                timer.Once(markertime, () =>
                {
                    if (deathmarker != null)
                    {
                        deathmarker.Kill();
                        deathmarker.SendUpdate();
                        storedData.playerdeath.Remove(player.userID);
                    }
                });
            }
        }
    }

#endregion
  
    }
}


// --- End of file: MapMyDeath.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-lifts ---
// --- Original File Path: M/MonumentLifts/MonumentLifts.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Monument Lifts", "Mevent", "1.0.3")]
	[Description("Adds lifts to monuments")]
	public class MonumentLifts : RustPlugin
	{
		#region Fields

		private readonly List<ModularCarGarage> _lifts = new List<ModularCarGarage>();

		#endregion

		#region Config

		private Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Prefab")]
			public string Prefab =
				"assets/prefabs/deployable/modular car lift/electrical.modularcarlift.deployed.prefab";

			[JsonProperty(PropertyName = "Spawn Setting (name - pos correction)",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public Dictionary<string, Vector3> Monuments = new Dictionary<string, Vector3>
			{
				["gas_station_1"] = new Vector3(4.2f, 0f, -0.5f),
				["supermarket_1"] = new Vector3(0.2f, 0f, 17.5f)
			};
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
		}

		#endregion

		#region Hooks

		private void OnServerInitialized()
		{
			TerrainMeta.Path.Monuments.ForEach(monument =>
			{
				if (monument == null) return;

				var correct = _config.Monuments.FirstOrDefault(x => monument.name.Contains(x.Key)).Value;
				if (correct == Vector3.zero) return;

				var transform = monument.transform;
				var rot = transform.rotation;
				var pos = transform.position + rot * correct;
				pos.y = TerrainMeta.HeightMap.GetHeight(pos);

				SpawnEntity(pos, rot);
			});
		}

		private void Unload()
		{
			_lifts
				.ToList()
				.ForEach(lift =>
				{
					if (lift == null || lift.IsDestroyed) return;

					lift.Kill();
				});
		}

		private void OnEntityTakeDamage(ModularCarGarage entity, HitInfo info)
		{
			if (entity == null || info == null || !_lifts.Contains(entity)) return;
			info.damageTypes.ScaleAll(0);
		}

		#endregion

		#region Utils

		private void SpawnEntity(Vector3 pos, Quaternion rot)
		{
			var entity = GameManager.server.CreateEntity(_config.Prefab, pos, rot) as ModularCarGarage;
			if (entity == null) return;

			entity.enableSaving = false;

			entity.Spawn();
			entity.needsElectricity = false;
			entity.SetFlag(BaseEntity.Flags.On, true);

			_lifts.Add(entity);
		}

		#endregion
	}
}

// --- End of file: MonumentLifts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-chat ---
// --- Original File Path: M/MagicChat/MagicChat.cs ---

using System;
using System.Collections.Generic;
using Rust;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Chat", "Norn", "0.1.3")]
    [Description("An alternative chat system")]
    public class MagicChat : RustPlugin
    {
        string DEFAULT_COLOR = "#81DAF5";

        [PluginReference]
        Plugin PopupNotifications;

        class StoredData
        {
            public Dictionary<ulong, UserInfo> Users = new Dictionary<ulong, UserInfo>();
            public StoredData()
            {
            }
        }

        class UserInfo
        {
            public ulong iUserId; // Steam ID
            public string tLastName; // Display Name
            public int iWorld; // World (0 for now)
            public bool uVoiceMuted; // Voice Chat
            public bool uPublicMuted; // Public Chat (OOC)
            public bool uLocalMuted; // Local Chat
            public bool uCanColor; // Name Color
            public string tColor; // Color hex
            public bool uColorEnabled;
            public bool uCanCustomTag; // Can Use Custom Tag In Chat
            public bool uCustomTagEnabled; // Enabled Or Not
            public string tCustomTag; // The custom tag string
            public int iMessagesSent; // Message count
            public int iInitTimestamp; // First Init
            public bool uShowIcon; // Hide/Show Icon In Chat
            public bool uIconStatus; // Hide/Show Icon In Chat
            public int iLastSeenTimestamp;
            public bool uShowPublicChat;
            public UserInfo()
            {
            }
        }

        StoredData MCData;
        private void OnServerInitialized()
        {
            MCData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(this.Title);
            if (!PopupNotifications && Convert.ToBoolean(Config["Dependencies", "PopupNotifications"])) { Config["Dependencies", "PopupNotifications"] = false; Puts("PopupNotifications [1252] has not been found. [Resetting to false]"); }
            int config_protocol = Convert.ToInt32(Config["General", "Protocol"]); if (Config["General", "Protocol"] == null)
            { Config["General", "Protocol"] = Protocol.network; }
            else if (Convert.ToInt32(Config["General", "Protocol"]) != Protocol.network)
            { Config["General", "Protocol"] = Protocol.network; }
        }
        void Unload()
        {
            SaveData();
        }
        string GetUserTag(BasePlayer player)
        {
            UserInfo p; string tag = "None";
            if (MCData.Users.TryGetValue(player.userID, out p))
            {
                if(p.tCustomTag.Length >= 1) tag = "<color="+ Config["General", "UserTagColor"].ToString()+">"+p.tCustomTag+"</color>";
            }
            return tag;
        }
        bool UserUpdateColor(BasePlayer player, string color)
        {
            UserInfo p;
            if (MCData.Users.TryGetValue(player.userID, out p))
            {
                p.tColor = color;
                return true;
            }
            return false;
        }
        bool UserUpdateTag(BasePlayer player, string tag)
        {
            UserInfo p;
            if (MCData.Users.TryGetValue(player.userID, out p))
            {
                p.tCustomTag = tag;
                return true;
            }
            return false;
        }
        [ChatCommand("chat")]
        private void ChatCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0 || args.Length > 2)
            {
                string default_command = null;
                if (CanUserToggleSteamIcon(player))
                { default_command += "icon "; }
                if (CanUserCustomColor(player))
                { default_command += " | color "; }
                if (CanUserCustomTag(player))
                { default_command += " | tag "; }
                PrintToChat(player, "USAGE: /chat <"+default_command+ " | public>");
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]))
                {
                    PrintToChat(player, "<color=yellow>ADMIN: /chat <clear></color>");
                }
                if (UserDataExists(player))
                {
                    PrintToChat(player, "[ <color=brown>"+player.displayName +"</color> ] Tag: "+ GetUserTag(player) + " [Messages Sent: <color=yellow>"+ MCData.Users[player.userID].iMessagesSent.ToString()+"</color>].");
                }
            }
            else if (args[0] == "public")
            {
               if (UserDataExists(player))
               {
                    if (MCData.Users[player.userID].uShowPublicChat) { MCData.Users[player.userID].uShowPublicChat = false; } else { MCData.Users[player.userID].uShowPublicChat = true; }
                    if (MCData.Users[player.userID].uShowPublicChat) { PrintToChat(player, "You will <color=green>now</color> see public messages."); } else { PrintToChat(player, "You will <color=red>no-longer</color> see public messages."); }
               }
            }
            else if (args[0] == "icon")
            {
                if (CanUserToggleSteamIcon(player))
                {
                    if(MCData.Users[player.userID].uShowIcon) { MCData.Users[player.userID].uShowIcon = false; } else { MCData.Users[player.userID].uShowIcon = true; }
                    if(MCData.Users[player.userID].uShowIcon){PrintToChat(player, "You will now <color=green>display</color> your steam icon.");}else{PrintToChat(player, "You have <color=red>hidden</color> your steam icon.");}
                }
                else
                {
                    PrintToChat(player, "You <color=red>don't</color> have permission to set a custom user color.");
                }
            }
            else if (args[0] == "color")
            {
                if (CanUserCustomColor(player))
                {
                    if (args.Length == 2)
                    {
                        if (args[1].Length >= 1 && args.Length <= Convert.ToInt32(Config["General", "MaxColorLength"]))
                        {
                            if(args[1] == "red" && player.net.connection.authLevel != Convert.ToInt32(Config["Admin", "MaxLevel"])) { PrintToChat("That color is <color=red>reserved.</color>."); return; }
                            if (UserUpdateColor(player, args[1]))
                            {
                                PrintToChat(player, "You have <color=green>successfully</color> updated your custom user color. (<color=" + args[1].ToString() + ">" + args[1].ToString() + "</color>).");
                            }
                        }
                        else
                        {
                            PrintToChat(player, "Please enter a <color=red>valid</color> color.");
                        }

                    }
                    else
                    {
                        if (UserColorToggle(player)) { PrintToChat(player, "You have <color=green>enabled</color> your custom user color."); } else { PrintToChat(player, "You have <color=red>disabled</color> your custom user color."); }
                        PrintToChat(player, "<color=yellow>USAGE:</color> /chat color <new>.");
                    }

                }
                else
                {
                    PrintToChat(player, "You <color=red>don't</color> have permission to set a custom user color.");
                }
            }
            else if (args[0] == "tag")
            {
                if (CanUserCustomTag(player))
                {
                    if (args.Length == 2)
                    {
                        if (args[1].Length >= 1 && args.Length <= Convert.ToInt32(Config["General", "MaxTagLength"]))
                        {
                            if (UserUpdateTag(player, args[1]))
                            {
                                PrintToChat(player, "You have <color=green>successfully</color> updated your custom user tag. (<color="+ Config["General", "UserTagColor"].ToString()+">" + args[1].ToString() + "</color>).");
                            }
                        }
                        else
                        {
                            PrintToChat(player, "Please enter a <color=red>valid</color> tag.");
                        }

                    }
                    else
                    {
                        if(UserTagToggle(player)) { PrintToChat(player, "You have <color=green>enabled</color> your custom title."); } else { PrintToChat(player, "You have <color=red>disabled</color> your custom title."); }
                        PrintToChat(player, "<color=yellow>USAGE:</color> /chat tag <new>");
                    }

                }
                else
                {
                    PrintToChat(player, "You <color=red>don't</color> have permission to set a custom user tag.");
                }
            }
            else if (args[0] == "clear")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MaxLevel"]))
                {
                    MCData.Users.Clear();
                    SaveData();
                    PrintToChat(player, Config["Messages", "DBCleared"].ToString());
                }
                else
                {
                    PrintToChat(player, Config["Messages", "AuthLevel"].ToString());
                }
            }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (!UserDataExists(player)) InitUserData(player);
        }
        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            string text = arg.Args[0];
            if (text.StartsWith(Config["General", "PublicPrefix"].ToString()))
            {
                if (Convert.ToBoolean(Config["Public", "Enabled"]))
                {
                    if (MCData.Users[arg.Connection.userid].uShowPublicChat)
                    {
                        BasePlayer player = BasePlayer.FindByID(arg.Connection.userid);
                        string final_text = text.Remove(0, Config["General", "PublicPrefix"].ToString().Length);
                        if (final_text.Length >= 1 && player != null) UserTextPublic(player, final_text);
                    }
                    else
                    {
                        PrintToChat(BasePlayer.FindByID(arg.Connection.userid), "You <color=red>can't</color> use public chat when you can't even see it. (/chat public)");
                    }
                }
                else
                {
                    PrintToChat(BasePlayer.FindByID(arg.Connection.userid), Config["Messages", "PublicDisabled"].ToString());
                }
            }
            else
            {
                if (Convert.ToBoolean(Config["Local", "Enabled"]))
                {
                    BasePlayer player = BasePlayer.FindByID(arg.Connection.userid);
                    if(text.Length >= 1 && player != null) UserTextRadius(player, Convert.ToDouble(Config["Local", "Radius"]), text, UserNameColor(player));
                }
                else return null;
            }
            return false;
        }
        private void UserTextPublic(BasePlayer player, string text)
        {
            string end_result = null;
            if (player != null && player.IsConnected)
            {
                if (!UserDataExists(player)) { InitUserData(player); }
                if (Convert.ToBoolean(Config["Public", "Enabled"]))
                {
                    UserInfo user = null;
                    if (MCData.Users.TryGetValue(player.userID, out user))
                    {
                        if(user.uPublicMuted)
                        {
                            PrintToChat(player, "You are currently <color=red>muted</color> from <color=yellow>" + Config["Public", "ChatPrefex"].ToString().ToLower() + "</color> chat.");
                            return;
                        }
                        if(user.uCanCustomTag && user.uCustomTagEnabled && user.tCustomTag.Length >= 1)
                        {
                            end_result = "[<color=" + Config["Public", "PrefixColor"].ToString() + ">" + Config["Public", "ChatPrefex"].ToString() + "</color>] [<color=" + Config["General", "UserTagColor"].ToString() + ">" + user.tCustomTag + "</color>] <color=" + UserNameColor(player) + ">" + player.displayName + "</color>: " + text;
                        }
                        else
                        {
                            end_result = "[<color=" + Config["Public", "PrefixColor"].ToString() + ">" + Config["Public", "ChatPrefex"].ToString() + "</color>] <color=" + UserNameColor(player) + ">" + player.displayName + "</color>: " + text;
                        }
                        user.iMessagesSent++;
                        Puts("[" + Config["Public", "ChatPrefex"].ToString() + "] " + player.displayName + ": " + text);
                        foreach (BasePlayer target in BasePlayer.activePlayerList)
                        {
                            if(target != null && target.IsConnected)
                            {
                                if (!UserDataExists(target)) InitUserData(target);
                                if (MCData.Users[target.userID].uShowPublicChat) { if (user.uShowIcon) { rust.SendChatMessage(target, end_result, null, player.userID.ToString()); } else { rust.SendChatMessage(target, end_result, null, Config["General", "IconDisabled"].ToString()); } }
                            }
                        } 
                    }
                }
            }
        }
        private string UserNameColor(BasePlayer i)
        {
            string color = DEFAULT_COLOR;
            if (i != null && i.IsConnected)
            {
                UserInfo user = null;
                if (MCData.Users.TryGetValue(i.userID, out user))
                {
                    if (user.uCanColor)
                    {
                        if (user.uColorEnabled)
                        {
                            if (user.tColor.Length >= 1)
                            { color = user.tColor; }
                            else
                            { user.tColor = color; }
                        }
                        else
                        {
                            if (i.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]))
                            {
                                if (Config["AdminColors", i.net.connection.authLevel.ToString()] != null)
                                { color = Config["AdminColors", i.net.connection.authLevel.ToString()].ToString(); }
                                else
                                {
                                    if (Config["AdminColors", "1"] == null)
                                    { Config["AdminColors", "1"] = DEFAULT_COLOR; color = Config["AdminColors", "1"].ToString(); }
                                    else
                                    { color = Config["AdminColors", "1"].ToString(); }
                                }
                            }
                        }
                    }
                }
            }
            return color;
        }
        private void UserTextRadius(BasePlayer player, double radius, string text, string name_color = "")
        {
            if (!UserDataExists(player))
            {
                InitUserData(player);
            }
            if (player.IsConnected)
            {
                float posx;
                float posy;
                float posz;
                float oldposx = 0.0f, oldposy = 0.0f, oldposz = 0.0f, tempposx = 0.0f, tempposy = 0.0f, tempposz = 0.0f;
                oldposx = player.transform.position.x;
                oldposy = player.transform.position.y;
                oldposz = player.transform.position.z;
                string gradient1 = Config["FadeGradient", "1"].ToString();
                string gradient2 = Config["FadeGradient", "2"].ToString();
                string gradient3 = Config["FadeGradient", "3"].ToString();
                string gradient4 = Config["FadeGradient", "4"].ToString();
                string gradient5 = Config["FadeGradient", "5"].ToString();
                foreach (BasePlayer i in BasePlayer.activePlayerList)
                {
                    if (i.IsConnected)
                    {
                        posx = i.transform.position.x;
                        posy = i.transform.position.y;
                        posz = i.transform.position.z;
                        tempposx = (oldposx - posx);
                        tempposy = (oldposy - posy);
                        tempposz = (oldposz - posz);
                        string end_color = null;
                        if (((tempposx < radius / 16) && (tempposx > -radius / 16)) && ((tempposy < radius / 16) && (tempposy > -radius / 16)) && ((tempposz < radius / 16) && (tempposz > -radius / 16)))
                        {
                            end_color = gradient1;
                        }
                        else if (((tempposx < radius / 8) && (tempposx > -radius / 8)) && ((tempposy < radius / 8) && (tempposy > -radius / 8)) && ((tempposz < radius / 8) && (tempposz > -radius / 8)))
                        {
                            end_color = gradient2;
                        }
                        else if (((tempposx < radius / 4) && (tempposx > -radius / 4)) && ((tempposy < radius / 4) && (tempposy > -radius / 4)) && ((tempposz < radius / 4) && (tempposz > -radius / 4)))
                        {
                            end_color = gradient3;
                        }
                        else if (((tempposx < radius / 2) && (tempposx > -radius / 2)) && ((tempposy < radius / 2) && (tempposy > -radius / 2)) && ((tempposz < radius / 2) && (tempposz > -radius / 2)))
                        {
                            end_color = gradient4;
                        }
                        else if (((tempposx < radius) && (tempposx > -radius)) && ((tempposy < radius) && (tempposy > -radius)) && ((tempposz < radius) && (tempposz > -radius)))
                        {
                            end_color = gradient5;
                        }
                        if (end_color != null)
                        {
                            string return_string = null;
                            UserInfo user = null;
                            if (MCData.Users.TryGetValue(player.userID, out user))
                            {
                                if (user.uLocalMuted)
                                {
                                    PrintToChat(player, "You are currently <color=red>muted</color> from <color=yellow>" + Config["Local", "ChatPrefex"].ToString().ToLower() + "</color> chat.");
                                    return;
                                }
                                if (Convert.ToBoolean(Config["Local", "ShowPlayerTags"]))
                                {
                                    if (user.uCanCustomTag && user.uCustomTagEnabled)
                                    {
                                        return_string = "[<color=" + Config["Local", "PrefixColor"].ToString() + ">" + Config["Local", "ChatPrefex"].ToString() + "</color>] [<color=" + Config["General", "UserTagColor"].ToString() + ">" + user.tCustomTag + "</color>]<color=" + name_color + "> " + player.displayName + "</color>: <color=" + end_color + ">" + text + "</color>";
                                    }
                                    else
                                    {
                                        return_string = "[<color=" + Config["Local", "PrefixColor"].ToString() + ">" + Config["Local", "ChatPrefex"].ToString() + "</color>] <color=" + name_color + "> " + player.displayName + "</color>: <color=" + end_color + ">" + text + "</color>";
                                    }
                                    user.iMessagesSent++;
                                    Puts("[" + Config["Local", "ChatPrefex"].ToString() + "] " + player.displayName + ": " + text);
                                    //Puts(i.displayName + " has sent " + user.iMessagesSent.ToString() + " messages.");
                                }

                            }
                            if (return_string.Length >= 1)
                            {

                                if (!user.uShowIcon && !user.uIconStatus) { user.uShowIcon = true; }
                                if (user.uColorEnabled && !user.uCanColor) { user.uColorEnabled = false; }
                                if (user.uCustomTagEnabled && !user.uCanCustomTag) { user.uCustomTagEnabled = false; }
                                if (user.uShowIcon)
                                {
                                    rust.SendChatMessage(i, return_string, null, player.userID.ToString());
                                }
                                else
                                {
                                    if (user.uIconStatus) rust.SendChatMessage(i, return_string, null, Config["General", "IconDisabled"].ToString());
                                }
                            }
                        }
                    }
                }
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
           if(UserDataExists(player)) { MCData.Users[player.userID].tLastName = player.displayName; MCData.Users[player.userID].iLastSeenTimestamp = UnixTimeStampUTC(); }
        }
        private bool InitUserData(BasePlayer player, bool debug = false)
        {
            if (!UserDataExists(player))
            {
                UserInfo z = new UserInfo();
                z.iLastSeenTimestamp = UnixTimeStampUTC();
                z.iMessagesSent = 0;
                z.iInitTimestamp = UnixTimeStampUTC();
                z.iUserId = player.userID;
                z.iWorld = Convert.ToInt32(Config["UserSettings", "DefaultWorld"]);
                z.tColor = Config["UserSettings", "DefaultColor"].ToString();
                z.tCustomTag = Config["UserSettings", "DefaultTag"].ToString();
                z.uCanColor = Convert.ToBoolean(Config["UserSettings", "DefaultCanColor"]);
                z.uCanCustomTag = Convert.ToBoolean(Config["UserSettings", "DefaultCanTag"]);
                z.uLocalMuted = false;
                z.uPublicMuted = false;
                z.tLastName = player.displayName;
                if(Convert.ToBoolean(Config["General", "VoipEnabled"])) { z.uVoiceMuted = false; } else { z.uVoiceMuted = true; }
                z.uShowIcon = Convert.ToBoolean(Config["General", "ShowUserIcons"]);
                z.uColorEnabled = false;
                z.uIconStatus = Convert.ToBoolean(Config["UserSettings", "AllowIconHide"]);
                z.uCustomTagEnabled = false;
                z.uShowPublicChat = Convert.ToBoolean(Config["UserSettings", "DefaultPublicChat"]);
                MCData.Users.Add(z.iUserId, z);
                Puts("Adding " + z.tLastName + " to the database. [VOIP Muted: " + z.uVoiceMuted.ToString() + "]");
                return true;
            }
            else
            {
                if(debug) { Puts("DEBUG: Resetting " + player.displayName + "'s MagicChat entry."); MCData.Users.Remove(player.userID); InitUserData(player); }
            }
            return false;
        }
        private bool CanUserToggleSteamIcon(BasePlayer player)
        {
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    return item.uIconStatus;
                }
            }
            return false;
        }
        private bool CanUserCustomColor(BasePlayer player)
        {
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    return item.uCanColor;
                }
            }
            return false;
        }
        private bool UserColorToggle(BasePlayer player)
        {
            bool return_b = false;
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    if (item.uColorEnabled)
                    {
                        item.uColorEnabled = false;
                    }
                    else
                    {
                        item.uColorEnabled = true;
                    }
                    return_b = item.uColorEnabled;
                }
            }
            return return_b;
        }
        private bool UserTagToggle(BasePlayer player)
        {
            bool return_b = false;
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    if (item.uCustomTagEnabled)
                    {
                        item.uCustomTagEnabled = false;
                    }
                    else
                    {
                        item.uCustomTagEnabled = true;
                    }
                    return_b = item.uCustomTagEnabled;
                }
            }
            return return_b;
        }
        private bool UserTagEnabled(BasePlayer player)
        {
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    return item.uCustomTagEnabled;
                }
            }
            return false;
        }
        private bool CanUserCustomTag(BasePlayer player)
        {
            if (player.IsConnected && player != null)
            {
                UserInfo item = null;
                if (MCData.Users.TryGetValue(player.userID, out item))
                {
                    return item.uCanCustomTag;
                }
            }
            return false;
        }
        private bool UserDataExists(BasePlayer player)
        {
            UserInfo item = null;
            if (MCData.Users.TryGetValue(player.userID, out item))
            {
                return true;
            }
            return false;
        }
        void SaveData()
        {
            Puts("Saving database...");
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, MCData);
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");

            // --- [ ADMIN ] ---
            Config["Admin", "MinLevel"] = 1;
            Config["Admin", "MaxLevel"] = 2;
            Config["AdminColors", "1"] = "#b4da73";
            
            // --- [ GENERAL SETTINGS ] ---
            Config["General", "Protocol"] = Protocol.network;
            Config["General", "MaxTagLength"] = 15;
            Config["General", "MaxColorLength"] = 10;
            Config["General", "VoipEnabled"] = true;
            Config["General", "ShowUserIcons"] = true;
            Config["General", "UserTagColor"] = "#00FFFF";
            Config["General", "PublicPrefix"] = "@";
            Config["General", "IconDisabled"] = "76561197967728661";

            // --- [ NOTIFICATIONS SETTINGS ] ---
            Config["Notifications", "TimerInterval"] = 60;
            Config["Notifications", "Enabled"] = true;

            // --- [ DEPENDENCIES ] ---
            Config["Dependencies", "PopupNotifications"] = false;
 
            // --- [ USER SETTINGS ] ---
            Config["UserSettings", "DefaultCanTag"] = true;
            Config["UserSettings", "DefaultCanColor"] = true;
            Config["UserSettings", "DefaultWorld"] = 0;
            Config["UserSettings", "DefaultColor"] = DEFAULT_COLOR;
            Config["UserSettings", "AdminColor"] = "#b4da73";
            Config["UserSettings", "DefaultTag"] = "O.G.";
            Config["UserSettings", "AllowIconHide"] = false;
            Config["UserSettings", "DefaultPublicChat"] = true;

            // --- [ LOCAL SETTINGS ] ---
            Config["Local", "Radius"] = 60.00;
            Config["Local", "FadeColors"] = true;
            Config["Local", "ChatPrefex"] = "Local";
            Config["Local", "PrefixColor"] = "#F5A9F2";
            Config["Local", "PrefixEnabled"] = true;
            Config["Local", "ShowPlayerTags"] = true;
            Config["Local", "Enabled"] = true;

            // --- [ PUBLIC SETTINGS ] ---
            Config["Public", "ChatPrefex"] = "Public";
            Config["Public", "PrefixColor"] = "#82FA58";
            Config["Public", "PrefixEnabled"] = true;
            Config["Public", "ShowPlayerTags"] = true;
            Config["Public", "Enabled"] = true;

            // --- [ FADE COLORS ] ---
            Config["FadeGradient", "1"] = "#E6E6E6";
            Config["FadeGradient", "2"] = "#C8C8C8";
            Config["FadeGradient", "3"] = "#AAAAAA";
            Config["FadeGradient", "4"] = "#8C8C8C";
            Config["FadeGradient", "5"] = "#6E6E6E";

            // --- [ MESSAGES ] ---
            Config["Messages", "PublicDisabled"] = "Public chat is currently <color=red>disabled</color>.";
            Config["Messages", "DBCleared"] = "You have <color=green>successfully</color> cleared the " + this.Title + " database.";
            Config["Messages", "AuthLevel"] = "You <color=red>don't</color> have the required auth level.";
        }
    }
}

// --- End of file: MagicChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-radiation-info-panel ---
// --- Original File Path: M/MagicRadiationInfoPanel/MagicRadiationInfoPanel.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Radiation Info Panel", "MJSU", "1.0.4")]
    [Description("Displays how much radiation protection the player has verse how much they need")]
    public class MagicRadiationInfoPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private string _textFormat;

        private readonly Hash<ulong, PlayerRadiationData> _playerRadiation = new Hash<ulong, PlayerRadiationData>();

        private Coroutine _updateRoutine;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.28f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/CLhQHXzQ/hnNhgFj.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.01f, 0.00f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .72f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.01f, 0.01f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0:0}/{1:0}"
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "centerupper",
                Order = config.PanelSettings?.Order ?? 12,
                Width = config.PanelSettings?.Width ?? 0.0525f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerRadiation, 1f, _pluginConfig.UpdateRate);
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _playerRadiation[player.userID] = GetPlayerData(player);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerRadiation.Remove(player.userID);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerRadiation);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }
        #endregion
        
        #region Player Coords Update
        private void UpdatePlayerRadiation()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerRadiation());
        }

        private IEnumerator HandleUpdatePlayerRadiation()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                PlayerRadiationData data = GetPlayerData(player);
                float prevRad = data.RadAmount;
                float prevProc = data.ProtectionAmount;
                UpdatePlayerRadiation(player, data);
                
                yield return null;
                if (prevRad == data.RadAmount && prevProc == data.ProtectionAmount)
                {
                    continue;
                }
                
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                PlayerRadiationData data = GetPlayerData(player);
                float radAmount = data.RadAmount;
                float radProtection = data.ProtectionAmount;

                text.Text = string.Format(_textFormat, radProtection, radAmount);
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods

        private PlayerRadiationData GetPlayerData(BasePlayer player)
        {
            PlayerRadiationData data = _playerRadiation[player.userID];
            if (data == null)
            {
                data = new PlayerRadiationData();
                _playerRadiation[player.userID] = data;
            }

            return data;
        }
        
        
        private void UpdatePlayerRadiation(BasePlayer player, PlayerRadiationData data)
        {
            float radAmount = 0f;
            if (player.triggers != null)
            {
                foreach (TriggerBase trigger in player.triggers)
                {
                    TriggerRadiation radiation = trigger as TriggerRadiation;
                    if (radiation != null)
                    {
                        radAmount = Mathf.Max(radAmount, radiation.GetRadiation(player.transform.position, 0));
                    }
                }
            }

            float radProtection = player.RadiationProtection();

            data.RadAmount = radAmount;
            data.ProtectionAmount = radProtection;
        }
        #endregion
        
        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PlayerRadiationData
        {
            public float RadAmount { get; set; }
            public float ProtectionAmount { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicRadiationInfoPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-economics-panel ---
// --- Original File Path: M/MagicEconomicsPanel/MagicEconomicsPanel.cs ---

﻿using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Magic Economics Panel", "MJSU", "1.0.8")]
[Description("Displays player economics data in MagicPanel")]
public class MagicEconomicsPanel : RustPlugin
{
    #region Class Fields
    [PluginReference] private readonly Plugin MagicPanel, Economics;

    private PluginConfig _pluginConfig; //Plugin Config
    private string _textFormat;

    private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
    #endregion

    #region Setup & Loading
    private void Init()
    {
        _textFormat = _pluginConfig.Panel.Text.Text;
    }

    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
        DynamicConfigFile newConfig = new(path);
        if (!newConfig.Exists())
        {
            LoadDefaultConfig();
            newConfig.Save();
        }
        try
        {
            newConfig.Load();
        }
        catch (Exception ex)
        {
            RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
            return;
        }
            
        newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
        newConfig.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        config.Panel = new Panel
        {
            Image = new PanelImage
            {
                Enabled = config.Panel?.Image?.Enabled ?? true,
                Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                Order = config.Panel?.Image?.Order ?? 0,
                Width = config.Panel?.Image?.Width ?? 0.33f,
                Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/X75TQmWK/nbEeITS.png",
                Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
            },
            Text = new PanelText
            {
                Enabled = config.Panel?.Text?.Enabled ?? true,
                Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                Order = config.Panel?.Text?.Order ?? 1,
                Width = config.Panel?.Text?.Width ?? 0.67f,
                FontSize = config.Panel?.Text?.FontSize ?? 14,
                Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                Text = config.Panel?.Text?.Text ?? "{0:0.00}",
            }
        };
        config.PanelSettings = new PanelRegistration
        {
            BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
            Dock = config.PanelSettings?.Dock ?? "leftmiddle",
            Order = config.PanelSettings?.Order ?? 0,
            Width = config.PanelSettings?.Width ?? 0.07f
        };
        return config;
    }

    private void OnServerInitialized()
    {
        MagicPanelRegisterPanels();
    }

    private void MagicPanelRegisterPanels()
    {
        if (MagicPanel == null)
        {
            PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
            return;
        }
            
        if (Economics == null)
        {
            PrintError("Missing plugin dependency Economics: https://umod.org/plugins/economics");
            return;
        }
        
        MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
    }
    #endregion

    #region Economics Hook
    private void OnEconomicsBalanceUpdated(string playerId, double amount)
    {
        BasePlayer player = BasePlayer.FindAwakeOrSleeping(playerId);
        if (player == null || !player.IsConnected)
        {
            return;
        }
            
        MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
    }
    #endregion

    #region MagicPanel Hook
    private Hash<string, object> GetPanel(BasePlayer player)
    {
        Panel panel = _pluginConfig.Panel;
        PanelText text = panel.Text;
        if (text != null)
        {
            text.Text = string.Format(_textFormat, GetBalance(player.userID));
        }

        return panel.ToHash();
    }
    
    public double GetBalance(ulong userId) => Economics?.Call<object>("Balance", userId) is double value ? value : 0;
    #endregion

    #region Classes
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Panel Settings")]
        public PanelRegistration PanelSettings { get; set; }

        [JsonProperty(PropertyName = "Panel Layout")]
        public Panel Panel { get; set; }
    }

    private class PanelRegistration
    {
        public string Dock { get; set; }
        public float Width { get; set; }
        public int Order { get; set; }
        public string BackgroundColor { get; set; }
    }

    private class Panel
    {
        public PanelImage Image { get; set; }
        public PanelText Text { get; set; }
            
        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Image)] = Image.ToHash(),
                [nameof(Text)] = Text.ToHash()
            };
        }
    }

    private abstract class PanelType
    {
        public bool Enabled { get; set; }
        public string Color { get; set; }
        public int Order { get; set; }
        public float Width { get; set; }
        public TypePadding Padding { get; set; }
            
        public virtual Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Enabled)] = Enabled,
                [nameof(Color)] = Color,
                [nameof(Order)] = Order,
                [nameof(Width)] = Width,
                [nameof(Padding)] = Padding.ToHash(),
            };
        }
    }

    private class PanelImage : PanelType
    {
        public string Url { get; set; }
            
        public override Hash<string, object> ToHash()
        {
            Hash<string, object> hash = base.ToHash();
            hash[nameof(Url)] = Url;
            return hash;
        }
    }

    private class PanelText : PanelType
    {
        public string Text { get; set; }
        public int FontSize { get; set; }

        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor TextAnchor { get; set; }
            
        public override Hash<string, object> ToHash()
        {
            Hash<string, object> hash = base.ToHash();
            hash[nameof(Text)] = Text;
            hash[nameof(FontSize)] = FontSize;
            hash[nameof(TextAnchor)] = TextAnchor;
            return hash;
        }
    }

    private class TypePadding
    {
        public float Left { get; set; }
        public float Right { get; set; }
        public float Top { get; set; }
        public float Bottom { get; set; }

        public TypePadding(float left, float right, float top, float bottom)
        {
            Left = left;
            Right = right;
            Top = top;
            Bottom = bottom;
        }
            
        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Left)] = Left,
                [nameof(Right)] = Right,
                [nameof(Top)] = Top,
                [nameof(Bottom)] = Bottom
            };
        }
    }
    #endregion
}

// --- End of file: MagicEconomicsPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/metabolism ---
// --- Original File Path: M/Metabolism/Metabolism.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Metabolism", "The Friendly Chap", "1.0.2")]
    [Description("Modify or disable player metabolism stats")]
    public class Metabolism : RustPlugin
	
/*	MIT License

	©2024 The Friendly Chap

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/	
	
    {
        #region Oxide Hooks
        
        private void Init()
        {
            foreach (var value in config.permissions.Keys)
            {
                permission.RegisterPermission(value, this);
            }
			// ShowLogo();
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var pair in config.permissions)
            {
                if (permission.UserHasPermission(player.UserIDString, pair.Key))
                {
                    var data = pair.Value;

                    var health = data.health;
                    if (health > 100f)
                    {
                        player._maxHealth = health;
                    }

                    var hydration = data.hydration;
                    if (hydration > 250)
                    {
                        player.metabolism.hydration.max = hydration;
                    }

                    var calories = data.calories;
                    if (calories > 500)
                    {
                        player.metabolism.calories.max = calories;
                    }
                    
                    player.health = health;
                    player.metabolism.hydration.value = hydration;
                    player.metabolism.calories.value = calories;
                    player.SendNetworkUpdate();
                    break;
                }
            }
        }

        #endregion
        
        #region Configuration
        
        private static ConfigData config;
        
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Permission -> Settings")]
            public Dictionary<string, MetabolismSettings> permissions;
        }

        private class MetabolismSettings
        {
            [JsonProperty(PropertyName = "Water on respawn")]
            public float hydration;
            
            [JsonProperty(PropertyName = "Calories on respawn")]
            public float calories;
            
            [JsonProperty(PropertyName = "Health on respawn")]
            public float health;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                permissions = new Dictionary<string, MetabolismSettings>
                {
                    ["metabolism.3"] = new MetabolismSettings
                    {
                        hydration = 5000,
                        calories = 5000,
                        health = 100
                    },
                    ["metabolism.2"] = new MetabolismSettings
                    {
                        hydration = 500,
                        calories = 500,
                        health = 100
                    },
                    ["metabolism.1"] = new MetabolismSettings
                    {
                        hydration = 250,
                        calories = 250,
                        health = 100
                    },
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    		private void ShowLogo()
        {
			Puts(" _______ __               _______        __                 __ __             ______ __           ©2024");
			Puts("|_     _|  |--.-----.    |    ___|.----.|__|.-----.-----.--|  |  |.--.--.    |      |  |--.---.-.-----.");
			Puts("  |   | |     |  -__|    |    ___||   _||  ||  -__|     |  _  |  ||  |  |    |   ---|     |  _  |  _  |");
			Puts("  |___| |__|__|_____|    |___|    |__|  |__||_____|__|__|_____|__||___  |    |______|__|__|___._|   __|");
			Puts("                                Metabolism v1.0.1                 |_____| thefriendlychap.co.za |__|");      
        }
	}
}

// --- End of file: Metabolism.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-crash-panel ---
// --- Original File Path: M/MagicCrashPanel/MagicCrashPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Crash Panel", "MJSU", "1.0.4")]
    [Description("Displays if the plane crash event is active")]
    public class MagicCrashPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, PlaneCrash;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<BaseEntity> _activeCrash = new List<BaseEntity>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        
        private const string CargoPlanePrefab = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private uint _prefabId;
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/cHh0XjN4/ipLC2ww.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.1f, 0.1f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            _prefabId = StringPool.Get(CargoPlanePrefab);
            NextTick(() =>
            {
                _activeCrash = UnityEngine.Object.FindObjectsOfType<BaseEntity>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }

            if (PlaneCrash == null)
            {
                PrintError("Missing plugin dependency PlaneCrash");
                UnsubscribeAll();
                return;
            }

            if (PlaneCrash.Version < new VersionNumber(0, 3, 0))
            {
                PrintError("PlaneCrash version must be >= 0.3.0");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeCrash.Count == 0 || _activeCrash.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(BaseEntity plane)
        {
            if (!_init)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (!CanShowPanel(plane))
                {
                    return;
                }

                _activeCrash.Add(plane);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(BaseEntity plane)
        {
            if (!_activeCrash.Remove(plane))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeCrash.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private bool CanShowPanel(BaseEntity plane)
        {
            if (plane.prefabID != _prefabId || !IsCrashPlane(plane))
            {
                return false;
            }
            
            object result = Interface.Call("MagicPanelCanShow", Name, plane);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }

        private bool IsCrashPlane(BaseEntity plane)
        {
            return PlaneCrash?.Call<bool>("IsCrashPlane", plane) ?? false;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicCrashPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-airdrop-panel ---
// --- Original File Path: M/MagicAirdropPanel/MagicAirdropPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Airdrop Panel", "MJSU", "1.0.2")]
    [Description("Displays if the airdrop event is active")]
    public class MagicAirdropPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, PlaneCrash, Airstrike;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<CargoPlane> _activeAirdrops = new List<CargoPlane>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/D0jShLfB/dble6vf.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 0,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeAirdrops = UnityEngine.Object.FindObjectsOfType<CargoPlane>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
            
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeAirdrops.Count == 0 || _activeAirdrops.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(CargoPlane plane)
        {
            if (!_init)
            {
                return;
            }
        
            NextTick(() =>
            {
                if (!CanShowPanel(plane))
                {
                    return;
                }

                _activeAirdrops.Add(plane);
                CheckEvent();
            });
        }

        private void OnEntityKill(CargoPlane plane)
        {
            _activeAirdrops.Remove(plane);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeAirdrops.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(CargoPlane plane)
        {
            if (IsCrashPlane(plane))
            {
                return false;
            }

            if (IsStrikePlane(plane))
            {
                return false;
            }

            object result = Interface.Call("MagicPanelCanShow", Name, plane);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        
        private bool IsCrashPlane(CargoPlane plane)
        {
            return PlaneCrash?.Call<bool>("IsCrashPlane", plane) ?? false;
        }

        private bool IsStrikePlane(CargoPlane plane)
        {
            return Airstrike?.Call<bool>("isStrikePlane", plane) ?? false;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicAirdropPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/master-key ---
// --- Original File Path: M/MasterKey/MasterKey.cs ---

using System;
using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Master Key", "FastBurst", "0.7.8")]
    [Description("Gain access and/or authorization to any locked object.")]
    public class MasterKey : CovalencePlugin
    {
        [PluginReference] Plugin LockMaster;
        #region Initialization

        private readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("MasterKey");
        private readonly string[] lockableTypes = { "box", "cell", "door", "gate", "hatch", "shop", "cupboard", "locker", "fridge", "hackable", "turret", "coffin", "furnace", "composter", "refinery", "mining", "pumpjack", "hitchtroughcombo", "planter", "mixingtable" };
        private Dictionary<string, bool> playerPrefs = new Dictionary<string, bool>();
        private const string permCom = "masterkey.command";
        private bool logUsage;
        private bool showMessages;

        private new void LoadDefaultConfig()
        {
            Config["Log Usage (true/false)"] = logUsage = GetConfig("Log Usage (true/false)", true);
            Config["Show Messages (true/false)"] = showMessages = GetConfig("Show Messages (true/false)", true);
            SaveConfig();
        }

        private void Init()
        {
            LoadDefaultConfig();
            playerPrefs = dataFile.ReadObject<Dictionary<string, bool>>();

            permission.RegisterPermission(permCom, this);
            foreach (var type in lockableTypes)
                permission.RegisterPermission($"masterkey.{type}", this);
        }

        #endregion Initialization

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MasterKeyDisabled"] = "Master key access is now disabled.",
                ["MasterKeyEnabled"] = "Master key access is now enabled.",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command.",
                ["UnlockedWith"] = "Unlocked {0} with master key!",
                ["LockedWith"] = "Locked {0} with master key!",
                ["OpenWith"] = "Opened {0} with master key!",
                ["LogUnlock"] = "{0} unlocked '{1}' with master key at {2}",
                ["LogLock"] = "{0} locked '{1}' with master key at {2}",
                ["LogOpen"] = "{0} opened '{1}' with master key at {2}",
            }, this);
        }

        #endregion Localization

        #region Chat Command

        [Command("masterkey", "mkey", "mk")]
        private void ChatCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permCom))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (!playerPrefs.ContainsKey(player.Id)) playerPrefs.Add(player.Id, true);
            playerPrefs[player.Id] = !playerPrefs[player.Id];
            dataFile.WriteObject(playerPrefs);

            player.Reply(playerPrefs[player.Id] ? Lang("MasterKeyEnabled", player.Id) : Lang("MasterKeyDisabled"));
        }

        #endregion Chat Command

        #region Lock Access

        private object CanUseLockedEntity(BasePlayer player, BaseLock @lock)
        {
            if (!@lock.IsLocked()) return null;
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            var prefab = @lock.parentEntity.Get(true).ShortPrefabName;
            if (prefab == null) return null;

            foreach (var type in lockableTypes)
            {
                if (!prefab.Contains(type)) continue;
                if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return null;

                if (showMessages) player.ChatMessage(Lang("OpenWith", player.UserIDString, type));
                if (logUsage) Log(Lang("LogOpen", null, PlayerName(player), type, player.transform.position));

                return true;
            }

            return null;
        }

        private object CanUnlock(BasePlayer player, BaseLock @lock)
        {
            if (player == null || @lock == null) return null;
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            var prefab = @lock.parentEntity.Get(true).ShortPrefabName;
            if (prefab == null) return null;

            var codeLock = @lock as CodeLock;

            foreach (var type in lockableTypes)
            {
                if (!prefab.Contains(type)) continue;
                if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return null;

                if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, type));
                if (logUsage) Log(Lang("LogUnlock", null, PlayerName(player), type, player.transform.position));

                if (@lock != null) @lock.SetFlag(BaseEntity.Flags.Locked, false);
                if (player != null && codeLock != null) EffectNetwork.Send(new Effect(codeLock.effectUnlocked.resourcePath, player.transform.position, Vector3.zero));

                return false;
            }

            return null;
        }

        private object CanLock(BasePlayer player, BaseLock @lock)
        {
            if (player == null || @lock == null) return null;
            if (@lock.IsLocked()) return false;
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            var prefab = @lock.parentEntity.Get(true).ShortPrefabName;
            if (prefab == null) return null;

            var codeLock = @lock as CodeLock;

            foreach (var type in lockableTypes)
            {
                if (!prefab.Contains(type)) continue;
                if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return null;

                if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, type));
                if (logUsage) Log(Lang("LogLock", null, PlayerName(player), type, player.transform.position));

                if (@lock != null) @lock.SetFlag(BaseEntity.Flags.Locked, true);
                if (player != null && codeLock != null) EffectNetwork.Send(new Effect(codeLock.effectLocked.resourcePath, player.transform.position, Vector3.zero));

                return false;
            }

            return null;
        }

        private object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null) return null;
            if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return null;

            var prefab = crate.ShortPrefabName;
            if (prefab == null) return null;

            foreach (var type in lockableTypes)
            {
                if (!prefab.Contains(type)) continue;
                if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return null;

                if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, type));
                if (logUsage) Log(Lang("LogUnlock", null, PlayerName(player), type, player.transform.position));

                crate.SetFlag(BaseEntity.Flags.Reserved2, true, false);
                crate.isLootable = true;

                return false;
            }

            return null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null)
                return;

            if (input.current.buttons == 0)
                return;

            if (input.IsDown(BUTTON.USE))
            {
                if (input.IsDown(BUTTON.USE) && !input.WasDown(BUTTON.USE))
                {
                    var entity = GetEntity(player) as AutoTurret;
                    if (entity == null)
                        return;

                    if (playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString]) return;

                    var prefab = entity.ShortPrefabName;
                    foreach (var type in lockableTypes)
                    {
                        if (!prefab.Contains(type)) continue;
                        if (!permission.UserHasPermission(player.UserIDString, $"masterkey.{type}")) return;

                        var client = GrabPlayer(player);
                        if (client == null)
                            return;

                        if (!entity.IsAuthed(player) && entity.IsOnline())
                        {
                            entity.authorizedPlayers.Add(client);

                            if (entity.HasTarget() && entity.target == player)
                                entity.SetTarget(null);

                            entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                            if (showMessages) player.ChatMessage(Lang("UnlockedWith", player.UserIDString, type));
                            if (logUsage) Log(Lang("LogUnlock", null, PlayerName(player), type, player.transform.position));
                        }
                        else if (entity.IsOnline())
                        {
                            entity.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == player.userID);
                            entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                            if (showMessages) player.ChatMessage(Lang("LockedWith", player.UserIDString, type));
                            if (logUsage) Log(Lang("LogLock", null, PlayerName(player), type, player.transform.position));
                        }
                    }
                }
            }
        }

        private PlayerNameID GrabPlayer(BasePlayer player)
        {
            if (player == null)
                return null;

            PlayerNameID playerNameID = new PlayerNameID()
            {
                userid = player.userID,
                username = player.displayName
            };

            return playerNameID;
        }

        #endregion Lock Access

        #region Get Entity

        // Edited borrowed code - Not sure from where
        private BaseEntity GetEntity(BasePlayer player)
        {
            if (player == null || player.IsDead() || player.IsSleeping())
                return null;

            RaycastHit hit;

            var currentRot = Quaternion.Euler(player?.serverInput?.current?.aimAngles ?? Vector3.zero) * Vector3.forward;
            var ray = new Ray(player.eyes.position, currentRot);

            if (UnityEngine.Physics.Raycast(ray, out hit, 2f))
            {
                var entity = hit.GetEntity() ?? null;

                if (entity != null && !entity.IsDestroyed)
                    return entity;
            }
            return null;
        }

        #endregion Get Entity

        #region Helpers

        private string PlayerName(BasePlayer player) => $"{player.displayName}({player.UserIDString})";

        private T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Log(string text) => LogToFile("usage", $"[{DateTime.Now}] {text}", this);

        #endregion Helpers
    }
}

// --- End of file: MasterKey.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mount-computer-station ---
// --- Original File Path: M/MountComputerStation/MountComputerStation.cs ---

﻿using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Mount Computer Station", "YaMang -w-", "1.1.2")]
    [Description("View computer stations with commands!")]
	public class MountComputerStation : RustPlugin
	{
		Dictionary<BasePlayer, Vector3> SetLocation = new Dictionary<BasePlayer, Vector3>();
        Dictionary<BasePlayer, BaseEntity> _station = new Dictionary<BasePlayer, BaseEntity>();
        private string UsePermission = "MountComputerStation.use";
        #region OxideHook
        private void OnServerInitialized()
        {
            permission.RegisterPermission(UsePermission, this);

            for (int i = 0; i < _config.commands.Count; i++)
            {
                cmd.AddChatCommand(_config.commands[i], this, nameof(ChatStation));
                cmd.AddConsoleCommand(_config.commands[i], this, nameof(ConsoleStation));
            }
        }
        private void Unload()
        {
            foreach (var item in _station)
            {
                item.Value.Kill();
            }

            foreach(var baseplayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(baseplayer, "ExitBtn");
            }    
            
        }
        #endregion

        #region Command
        private void ChatStation(BasePlayer player, string command, string[] args) => SetComputerStation(player);

        private void ConsoleStation(ConsoleSystem.Arg arg)
        {
			if(arg.IsRcon)
            {
                if(arg.Args.Length == 0)
                {
                    arg.Reply = Lang("SyntaxError");
                    return;
                }


				BasePlayer findplayer = BasePlayer.FindByID(Convert.ToUInt64(arg.Args[0])) ?? null;
                if(findplayer == null)
                {
                    arg.Reply = Lang("NotFound");
                    return;
                }

				SetComputerStation(findplayer);
			}

            var player = arg.Connection.player as BasePlayer ?? null;
            SetComputerStation(player);

        }
        #endregion

        #region Funtions
        private void SetComputerStation(BasePlayer player)
        {
            if(!permission.UserHasPermission(player.UserIDString, UsePermission))
            {
                Messages(player, Lang("NotAccess", player.UserIDString));
                return;
            }

            
			var station = GameManager.server.CreateEntity("assets/prefabs/deployable/computerstation/computerstation.deployed.prefab", _config.locationStation.PlayerLocation ? player.transform.position : _config.locationStation.location) as ComputerStation;
            if(_config.addcctvs.Count != 0)
            {
                NextFrame(() =>
                {
                    foreach (var item in _config.addcctvs)
                    {
                        if (station.controlBookmarks.Contains(item)) continue;
                        station.controlBookmarks.Add(item);
                    }
                    station.SendNetworkUpdateImmediate();
                });
            }
            station.Spawn();
			station._name += "__ym__";

			station.MountPlayer(player);
            NextTick(() =>
            {
                station.SendControlBookmarks(player);
            });
           
            if(player.isMounted)
            {
                
                if (!SetLocation.ContainsKey(player))
                    SetLocation.Add(player, player.transform.position);

                ExitUI(player);
                _station.Add(player, station);
            }
            else
                station.Kill();
            
		}
        [ConsoleCommand("scsdismount")]
        private void ScsDismount(ConsoleSystem.Arg arg)
        {
            if (arg.IsRcon) return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            
            var entity = player.GetMounted();
            player.DismountObject();
            ScsDestory(entity, player);

            CuiHelper.DestroyUi(player, "ExitBtn");
        }
		private void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null || player == null) return;

            if (entity._name.Contains("__ym__"))
                ScsDestory(entity, player);
        }

        private void ScsDestory(BaseMountable entity, BasePlayer player)
        {
            if (SetLocation.ContainsKey(player))
            {
                timer.Once(0.01f, () =>
                {
                    player.Teleport(SetLocation[player]);
                    SetLocation.Remove(player);
                });
            }

            if (entity._name.Contains("__ym__"))
            {
                _station.Remove(player);
                entity.Kill();
                CuiHelper.DestroyUi(player, "ExitBtn");
            }
        }
        private void Messages(BasePlayer player, string text)
        {
            player.SendConsoleCommand("chat.add", 2, _config.SteamID, $"{_config.Prefix} {text}");
        }
        #endregion

        #region Config        
        private ConfigData _config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Prefix")] public string Prefix { get; set; }
            [JsonProperty(PropertyName = "SteamID")]  public string SteamID { get; set; }
            [JsonProperty(PropertyName = "Commands")] public List<string> commands { get; set; }
            [JsonProperty(PropertyName = "Location Station")] public LocationStation locationStation { get; set; }
            [JsonProperty(PropertyName = "Auto Add Station CCTVs")] public List<string> addcctvs { get; set; }
            [JsonProperty(PropertyName = "UI Settings")] public UISettings uiSettings { get; set; }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
        public class UISettings
        {
            public string oMin { get; set; }
            public string oMax { get; set; }
            public string Color { get; set; }
        }
        public class LocationStation
        {
            [JsonProperty(PropertyName = "Summoned from player position (If false, use location)")]  public bool PlayerLocation;
            public Vector3 location;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigData>();

            if (_config.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultConfig() => _config = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Prefix = "<color=#00ffff>[ Mount Computer Station ] - </color>\n",
                commands = new List<string>
                {
                    "scs"
                },
                locationStation = new LocationStation
                {
                    PlayerLocation = true,
                    location = new Vector3(0f, 100f, 0f)
                },
                uiSettings = new UISettings
                { 
                    oMin = "381.104 239.333",
                    oMax = "542.896 296.667",
                    Color = "0.176 0.72 0.72 1"
                },
                addcctvs = new List<string>
                {
                    
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");
            _config.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {

                { "NotAccess", "<color=red>You cannot use this command.</color>" },
                { "SyntaxError", "Please enter your SteamID" },
                { "NotFound", "Player Not Found" },
                { "Exit", "[ Exit ]" }

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NotAccess", "<color=red>당신은 이 명령어를 사용할수 없습니다.</color>" },
                { "SyntaxError", "고유번호를 입력해주세요." },
                { "NotFound", "플레이어를 찾을 수 없습니다." },
                { "Exit", "[ 닫기 ]" }
            }, this, "ko");
        }

        private string Lang(string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this), args);
        }

        #endregion


        #region UI
        private void ExitUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiButton
            {
                Button = { Color = _config.uiSettings.Color, Command = "scsdismount" },
                Text = { Text = Lang("Exit"), Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = _config.uiSettings.oMin, OffsetMax = _config.uiSettings.oMax }
            }, "Overlay", "ExitBtn");

            CuiHelper.DestroyUi(player, "ExitBtn");
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}


// --- End of file: MountComputerStation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-transit ---
// --- Original File Path: M/MyTransit/MyTransit.cs ---

using Facepunch;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("My Transit", "Lincoln & Unboxing", "1.5.4")]
    [Description("Spawns work carts and makes them go fast")]
    class MyTransit : RustPlugin
    {
        #region Varariables

        private readonly Dictionary<ulong, string> _playerTransit = new Dictionary<ulong, string>();
        //private readonly Hash<string, float> _cooldowns = new Hash<string, float>();

        private const string PermUse = "mytransit.use";
        private const string PermAdmin = "mytransit.admin";
        private const string WorkcartEntity = "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
        private const string TrainEntity = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
        private const string TrainEntity2 = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
        private const string TrainEntity3 = "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab";
        private const string TrainEntity4 = "assets/content/vehicles/trains/caboose/traincaboose.entity.prefab";
        private const int ItemFuelID = -946369541;

        private List<string> allTrains = new List<string>()
        {
            "workcart.entity",
            "workcart_aboveground.entity",
            "workcart_aboveground2.entity",
            "locomotive.entity",
            "traincaboose.entity"
        };


        //private float _cooldownTime = 5f;
        private Timer _speedTimer;

        #endregion

        #region Configuration

        private PluginConfig _config;

        private class PluginConfig
        {
            public int forwardSpeed;
            public int reverseSpeed;
            public bool useFuel;
        }

        private void Init()
        {
            _config = Config.ReadObject<PluginConfig>();

            permission.RegisterPermission(PermUse, this);
            permission.RegisterPermission(PermAdmin, this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                forwardSpeed = 200,
                reverseSpeed = -200,
                useFuel = true
            };
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities.OfType<TrainCar>().ToArray())
            {
                if (entity.OwnerID == 0uL) continue;

                BasePlayer player = BasePlayer.FindByID(entity.OwnerID);
                if (player != null && allTrains.Contains(entity.ShortPrefabName))
                {
                    _playerTransit.Add(player.userID, player.displayName);
                }
            }
        }
        private void OnEntityKill(BaseEntity entity)
        {
            if (!allTrains.Contains(entity.ShortPrefabName)) return;

            BasePlayer player = BasePlayer.FindByID(entity.OwnerID);
            if (player == null) return;

            _playerTransit.Remove(entity.OwnerID);
        }

        private void Unload()
        {
            TrainCar.TRAINCAR_MAX_SPEED = 25f;
        }

        #endregion

        #region Custom Functions

        private void SpawnTransit(BasePlayer player, string command, string[] args)
        {
            TrainCar transit;

            Puts(args[0]);

            if (args[0] == "cart")
            {
                transit = GameManager.server.CreateEntity(WorkcartEntity, player.transform.position) as TrainCar;
            }
            else if (args[0] == "train2")
            {
                transit = GameManager.server.CreateEntity(TrainEntity2, player.transform.position) as TrainCar;
            }
            else if (args[0] == "loco")
            {
                transit = GameManager.server.CreateEntity(TrainEntity3, player.transform.position) as TrainCar;
            }
            else if (args[0] == "caboose")
            {
                transit = GameManager.server.CreateEntity(TrainEntity4, player.transform.position) as TrainCar;
            }
            else
            {
                transit = GameManager.server.CreateEntity(TrainEntity, player.transform.position) as TrainCar;
            }

            if (transit == null) return;

            transit.OwnerID = player.userID;
            _playerTransit.Add(player.userID, player.displayName);
            foreach (KeyValuePair<ulong, string> kvp in _playerTransit) Puts("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
            SendReply(player, GetLang("Spawned", player.UserIDString));

            transit.Spawn();

            //

            if (!_config.useFuel)
            {
                transit.GetFuelSystem().AddFuel(1);
                Puts("Trying to add fuel");
                TrainEngine trainEngine = transit.GetComponent<TrainEngine>();
                //access EntityFuelSystem of transit and get the fuel container and lock it
                StorageContainer transitInventory = (transit.GetFuelSystem() as EntityFuelSystem)?.GetFuelContainer() as StorageContainer;

                if (trainEngine != null)
                {
                    trainEngine.maxFuelPerSec = 0f;
                    trainEngine.idleFuelPerSec = 0f;
                    transitInventory.SetFlag(BaseEntity.Flags.Locked, true);


                    Puts("Set maxFuelPerSec and idleFuelPerSec to 0");
                }
                else
                {
                    Puts("Failed to get TrainEngine component");
                }
            }


            if (player.transform.position == transit.transform.position)
            {
                //transform player position to behind the train
                player.transform.position = transit.transform.position + new Vector3(-5, 0, 0);

            }
            transit.SendNetworkUpdateImmediate();
        }

        private bool PositionIsInWater(Vector3 position)
        {
            List<Collider> colliders = Pool.GetList<Collider>();
            Vis.Colliders(position, 0.5f, colliders);
            bool flag = colliders.Any(x => x.gameObject?.layer == (int)Rust.Layer.Water);
            Pool.FreeList(ref colliders);
            return flag;
        }

        private void RecallTransit(BasePlayer player, BaseEntity entity)
        {
            entity.transform.position = player.transform.position;
            entity.SendNetworkUpdateImmediate();
            entity.UpdateNetworkGroup();
            SendReply(player, GetLang("TransitRecall", player.UserIDString));
        }

        private void ChangeSpeed(BasePlayer player, int currentSpeed)
        {
            TrainCar transit = GetActiveTransit(player);
            _speedTimer?.Destroy();
            _speedTimer = timer.Every(1f, () =>
            {
                if (transit == null) _speedTimer.Destroy();
                //if currentSpeed is less than 0, it is a reverse speed
                if (currentSpeed < 0)
                {
                    transit.completeTrain.trackSpeed = 0;
                    transit.completeTrain.trackSpeed = currentSpeed - 1;
                    //set the trainengine maxfuelpersec to 0
                    TrainCar.TRAINCAR_MAX_SPEED = -(transit.completeTrain.trackSpeed - 1);

                }
                else
                {
                    transit.completeTrain.trackSpeed = 0;
                    transit.completeTrain.trackSpeed = currentSpeed + 1;
                    TrainCar.TRAINCAR_MAX_SPEED = transit.completeTrain.trackSpeed + 1;
                }

            });
        }

        private TrainCar GetActiveTransit(BasePlayer player)
        {
            // Get all transits on the map and check ownership
            foreach (TrainCar train in BaseNetworkable.serverEntities.OfType<TrainCar>().ToArray())
            {
                if (train.OwnerID == player.userID)
                {
                    return train;
                }
            }

            return null;
        }

        public bool TryFindTrackNearby(Vector3 pos, float maxDist, out TrainTrackSpline splineResult, out float distResult)
        {
            splineResult = null;
            distResult = 0f;
            List<Collider> list = Pool.GetList<Collider>();
            GamePhysics.OverlapSphere(pos, maxDist, list, 65536);

            if (list.Count > 0)
            {
                List<TrainTrackSpline> trainTrackSplines = Pool.GetList<TrainTrackSpline>();
                float single;

                foreach (Collider collider in list)
                {
                    collider.GetComponentsInParent(false, trainTrackSplines);
                    if (trainTrackSplines.Count <= 0)
                    {
                        continue;
                    }

                    foreach (TrainTrackSpline trainTrackSpline in trainTrackSplines)
                    {
                        float distance = trainTrackSpline.GetDistance(pos, 1f, out single);
                        if (!(distance >= single))
                        {
                            single = distance;
                            splineResult = trainTrackSpline;
                        }
                    }
                }
                if (splineResult != null)
                {
                    distResult = splineResult.GetDistance(pos, 0.25f, out single);
                }
                Pool.FreeList(ref trainTrackSplines);
            }
            Pool.FreeList(ref list);
            return splineResult != null;
        }

        private bool ValidationChecks(BasePlayer player)
        {
            Vector3 pos = player.transform.position;
            const float maxDist = 2f;
            TrainTrackSpline splineResult;
            float distResult;

            if (player.IsDead()) return true;

            if (!permission.UserHasPermission(player.UserIDString, PermUse))
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return true;
            }

            if (player.IsBuildingBlocked())
            {
                SendReply(player, GetLang("BuildingBlocked", player.UserIDString));
                return true;
            }

            if (player.isMounted)
            {
                SendReply(player, GetLang("Mounted", player.UserIDString));
                return true;
            }

            if (player.IsFlying || !player.IsOnGround())
            {
                SendReply(player, GetLang("Flying", player.UserIDString));
                return true;
            }

            if (player.IsWounded())
            {
                SendReply(player, GetLang("Wounded", player.UserIDString));
                return true;
            }

            if (!TryFindTrackNearby(pos, maxDist, out splineResult, out distResult))
            {
                SendReply(player, GetLang("NotNearTrack", player.UserIDString));
                return true;
            }

            return false;
        }

        #endregion

        #region Commands

        //chat command mtlist
        [ChatCommand("mtlist")]
        private void ListCommand(BasePlayer player, string command, string[] args)
        {
            foreach (KeyValuePair<ulong, string> kvp in _playerTransit) Puts("Key: {0}, Value: {1}", kvp.Key, kvp.Value);
        }

        [ChatCommand("mtcheck")]
        private void CheckCommand(BasePlayer player, string command, string[] args)
        {
            TrainCar transit = GetActiveTransit(player);

            if (transit == null)
            {
                SendReply(player, GetLang("TransitNotOut", player.UserIDString));
                return;
            }

            if (transit.OwnerID == player.userID)
            {
                int speed = (int)transit.completeTrain.trackSpeed;
                SendReply(player, GetLang("TransitSpeed", player.UserIDString), speed);
            }
        }

        [ChatCommand("mtspeed")]
        private void SpeedCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermAdmin))
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return;
            }

            if (args.IsNullOrEmpty() || args[0].Length == 0)
            {
                SendReply(player, GetLang("NoArgs", player.UserIDString));
                return;
            }

            int currentSpeed;
            int.TryParse(args[0], out currentSpeed);

            if (currentSpeed > _config.forwardSpeed || currentSpeed < _config.reverseSpeed || currentSpeed == 0)
            {
                SendReply(player, GetLang("OutOfBounds", player.UserIDString), _config.reverseSpeed, _config.forwardSpeed);
                return;
            }

            if (!_playerTransit.ContainsKey(player.userID))
            {
                SendReply(player, GetLang("TransitNotOut", player.UserIDString));
                return;
            }

            TrainCar transit = GetActiveTransit(player);
            if (transit.GetDriver() == null)
            {
                SendReply(player, GetLang("NotMounted", player.UserIDString));
                return;
            }

            ChangeSpeed(player, currentSpeed);
            SendReply(player, GetLang("TransitSpeedEnabled", player.UserIDString), currentSpeed);
        }

        [ChatCommand("mtspeed.off")]
        private void OffCommand(BasePlayer player, string command, string[] args)
        {
            if (_speedTimer == null) return;

            _speedTimer.Destroy();
            SendReply(player, GetLang("TransitSpeedDisabled", player.UserIDString));
        }

        [ChatCommand("mthelp")]
        private void HelpCommand(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, PermAdmin))
            {
                SendReply(player, GetLang("HelpAdmin", player.UserIDString));
                return;
            }

            SendReply(player, GetLang("Help", player.UserIDString));
        }

        [ChatCommand("mtspawn")]
        private void SpawnCommand(BasePlayer player, string command, string[] args)
        {
            if (args.IsNullOrEmpty() || args[0].Length == 0)
            {
                SendReply(player, GetLang("NoArgsTransit", player.UserIDString));
                return;
            }
            string type = args[0].ToLower();
            if (type != "cart" && type != "train" && type != "train2" && type != "loco" && type != "caboose")
            {
                SendReply(player, GetLang("NoArgsTransit", player.UserIDString));
                return;
            }

            if (_playerTransit.ContainsKey(player.userID))
            {
                SendReply(player, GetLang("TransitExists", player.UserIDString));
                return;
            }

            if (!ValidationChecks(player))
            {
                SpawnTransit(player, command, args);
            }
        }

        [ChatCommand("mtkill")]
        private void KillCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "MyTransit.use"))
            {
                SendReply(player, GetLang("NoPerm", player.UserIDString));
                return;
            }

            if (!_playerTransit.ContainsKey(player.userID))
            {
                SendReply(player, GetLang("TransitNotOut", player.UserIDString));
                return;
            }

            TrainCar transit = GetActiveTransit(player);
            DestroyTransit(player, transit);
            SendReply(player, GetLang("TransitKilled", player.UserIDString));
            //remove player from list
            _playerTransit.Remove(player.userID);
        }

        private void OnEntityTakeDamage(TrainCar trainCar, HitInfo info)
        {
            if (trainCar.OwnerID != 0uL)
            {
                info.damageTypes.ScaleAll(0f);
            }
        }

        private void DestroyTransit(BasePlayer player, TrainCar transit)
        {
            if (player == null || transit == null || transit.OwnerID != player.userID) return;

            _playerTransit.Remove(player.userID);
            transit.Kill();
        }

        #endregion

        #region Localization

        private string GetLang(string langKey, string playerId = null) => lang.GetMessage(langKey, this, playerId);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Spawned"] = "<size=18><color=#ffc34d>MyTransit</color></size>\nYou have spawned your <color=#9999ff>transit</color>.",
                ["BuildingBlocked"] = "<color=#ffc34d>MyTransit</color>: Can't spawn/recall a transit while building blocked.",
                ["Mounted"] = "<color=#ffc34d>MyTransit</color>: Can't spawn/recall a transit while mounted.",
                ["Help"] = "<size=18><color=#ffc34d>MyTransit</color></size>\n<color=#9999ff>/mtspawn</color> to spawn your transit.\n<color=#9999ff>/mtkill</color> to kill your transit.\n<color=#9999ff>/mthelp</color> to open this help menu.",
                ["HelpAdmin"] = "<size=18><color=#ffc34d>MyTransit</color></size>\n<color=#9999ff>/mtspawn</color> to spawn your transit.\n<color=#9999ff>/mtkill</color> to kill your transit.\n<color=#9999ff>/mthelp</color> to open this help menu.\n\n<size=13><color=#ff6666>Admin Commands</color></size>\n<color=#9999ff>/mtspeed</color> to set the speed of your transit.\n</size><color=#9999ff>/mtcheck</color> to check the speed of your transit.",
                ["Flying"] = "<color=#ffc34d>MyTransit</color>: Can't spawn while jumping, flying, or falling",
                ["NoArgs"] = "<color=#ffc34d>MyTransit</color>: Please specify a speed.",
                ["NoArgsTransit"] = "<color=#ffc34d>MyTransit</color>: You must specify a type of transit!\n<color=#ffc34d>/mtspawn cart</color> workcart (without couplings)\n<color=#ffc34d>/mtspawn train</color> above ground train (with couplings)\n<color=#ffc34d>/mtspawn train2</color> above ground covered train (with couplings)\n<color=#ffc34d>/mtspawn loco</color> to spawn a locomotive.\n<color=#ffc34d>/mtspawn caboose</color> to spawn a caboose.",
                ["OutOfBounds"] = "<color=#ffc34d>MyTransit</color>: Speed out of bounds. Please specify a speed between {0} and {1}",
                ["NotMounted"] = "<color=#ffc34d>MyTransit</color>: You need to be seated in the train.",
                ["NotNearTrack"] = "<color=#ffc34d>MyTransit</color>: Please stand next to a track to spawn.",
                ["Cooldown"] = "<color=#ffc34d>MyTransit</color>: You are on a 5 second cooldown.",
                ["TransitKilled"] = "<color=#ffc34d>MyTransit</color>: Your transit has been killed.",
                ["TransitSpeed"] = "<color=#ffc34d>MyTransit</color>: The transit speed is <color=#b0fa66>{0}</color>.",
                ["TransitSpeedDisabled"] = "<color=#ffc34d>MyTransit</color>: Custom speed <color=#ff6666>disabled</color>.",
                ["TransitSpeedEnabled"] = "<color=#ffc34d>MyTransit</color>: Custom speed set to <color=#b0fa66>{0}</color>.",
                ["TransitNotOut"] = "<color=#ffc34d>MyTransit</color>: You do not have a transit out.",
                ["TransitExists"] = "<color=#ffc34d>MyTransit</color>: You already have a transit out. Type <color=#9999ff>/mtkill</color> to kill it. ",
                ["Wounded"] = "<color=#ffc34d>MyTransit</color>: You cannot spawn a transit while wounded.",
                ["NoPerm"] = "<color=#ffc34d>MyTransit</color>: You don't have permission to use that.",
                ["Killed"] = "<color=#ffc34d>MyTransit</color>: You just removed your transit."
            }, this);
        }

        #endregion
    }
}


// --- End of file: MyTransit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-variables ---
// --- Original File Path: M/MagicVariables/MagicVariables.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("MagicVariables", "Norn", 0.1, ResourceId = 1419)]
    [Description("Simple static variable system.")]
    public class MagicVariables : RustPlugin
    {
        public Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
               ? UnixEpoch.AddMilliseconds(unixTimeStamp)
               : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        public class StaticVariables
        {
            public int iResourceID;

            public Dictionary<string, object> Variables = new Dictionary<string, object>();
            public Hash<ulong, Dictionary<string, object>> UserVariables = new Hash<ulong, Dictionary<string, object>>();
            public Dictionary<ulong, PlayersInit> Users = new Dictionary<ulong, PlayersInit>();

            public StaticVariables()
            {
            }
        }
        public class PlayersInit
        {
            public ulong uUserID;
            public string tDisplayName;
            public PlayersInit()
            {
            }
        }
        public class PluginInfo
        {
            public Dictionary<Plugin, StaticVariables> Plugins = new Dictionary<Plugin, StaticVariables>();
            public PluginInfo()
            {
            }
        }
        PluginInfo Data = new PluginInfo();
        private bool PluginExists(Plugin plugin)
        {
            if (Data.Plugins.ContainsKey(plugin))
            {
                return true;
            }
            return false;
        }
        private bool SetStaticVariable(Plugin plugin, string variable, string value, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (!Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    Data.Plugins[plugin].Variables.Add(variable, value);
                    if (debug) Puts(plugin.Title + " : " + variable + " = " + value + " : Initiation.");
                    return true;
                }
                else
                {
                    Data.Plugins[plugin].Variables[variable] = value;
                    if (debug) Puts(plugin.Title + " : " + variable + " = " + value + " : Updating.");
                    return true;
                }
            }
            return false;
        }
        private string GetStaticVariable(Plugin plugin, string variable, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    if (debug) Puts(plugin.Title + " : " + Data.Plugins[plugin].Variables[variable].ToString() + " : Data Returned.");
                    return Data.Plugins[plugin].Variables[variable].ToString();
                }
            }
            return "0";
        }
        private bool RemoveStaticVariable(Plugin plugin, string variable, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Variables.ContainsKey(variable))
                {
                    Data.Plugins[plugin].Variables.Remove(variable);
                    return true;
                }
            }
            return false;
        }
        private bool DestroyPlugin(Plugin plugin, bool debug = false)
        {
            try
            {
                if (PluginExists(plugin))
                {
                    Data.Plugins.Remove(plugin);
                    if (debug) Puts("Removing " + plugin.Title + " from the plugin list.");
                    return true;
                }
            }
            catch
            {
                if (debug) Puts("DEBUG: Failed To Call Hook DestroyPlugin(" + plugin.Title.ToString() + ");");
            }
            return false;
        }
        private bool InitPlugin(Plugin plugin, bool debug = false)
        {
            try
            {
                if (!PluginExists(plugin))
                {
                    StaticVariables d = new StaticVariables();
                    d.iResourceID = plugin.ResourceId;
                    Data.Plugins.Add(plugin, d);
                    SetStaticVariable(plugin, "INIT_TIMESTAMP", UnixTimeStampUTC().ToString());
                    if (debug) Puts("[" + plugin.Title + "] added " + plugin.Title + " [Resource ID: " + Data.Plugins[plugin].iResourceID.ToString() + "].");
                    return true;
                }
            }
            catch
            {
                if (debug) Puts("DEBUG: Failed To Call Hook InitPlugin(" + plugin.Title.ToString() + ");");
            }
            return false;
        }
        void OnServerInitialized()
        {
            int config_protocol = Convert.ToInt32(Config["Protocol"]);
            if (config_protocol != Protocol.network)
            {
                Config["Protocol"] = Protocol.network;
                SaveConfig();
            }
        }
        private bool RemoveStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, bool debug = false)
        {
            if (!PlayerExists(plugin, player)) { return false; }
            if (PlayerHasVariables(plugin, player) == 0) { return false; }
            if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
            {
                if (debug) Puts("[" + plugin.Title + "] Removing static variable " + variable + ":" + Data.Plugins[plugin].UserVariables[player.userID][variable] + ".");
                Data.Plugins[plugin].UserVariables[player.userID].Remove(variable);
                return true;
            }
            return false;
        }
        private string GetStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, bool debug = false)
        {
            string default_return = "0";
            if (!PlayerExists(plugin, player)) { return default_return; }
            if (PlayerHasVariables(plugin, player) == 0) { return default_return; }
            if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
            {
                default_return = Data.Plugins[plugin].UserVariables[player.userID][variable].ToString();
            }
            return default_return;
        }
        private void SetStaticPlayerVariable(Plugin plugin, BasePlayer player, string variable, string value, bool debug = false)
        {
            ulong steamid = player.userID;
            if (!PlayerExists(plugin, player)) { InitPlayer(plugin, player); return; }
            if (Data.Plugins[plugin].UserVariables.ContainsKey(player.userID))
            {
                if (Data.Plugins[plugin].UserVariables[player.userID].ContainsKey(variable))
                {
                    Data.Plugins[plugin].UserVariables[player.userID][variable] = value;
                }
                else
                {
                    Data.Plugins[plugin].UserVariables[player.userID].Add(variable, value);
                }
            }
            else
            {
                Dictionary<string, object> zdata = new Dictionary<string, object>();
                zdata.Add(variable, value);
                Data.Plugins[plugin].UserVariables.Add(player.userID, zdata);
            }
            if (debug) Puts(player.displayName + " : " + player.userID.ToString() + " : " + variable + " : " + Data.Plugins[plugin].UserVariables[player.userID][variable].ToString());
        }
        private int PlayerHasVariables(Plugin plugin, BasePlayer player)
        {
            if (PluginExists(plugin) && PlayerExists(plugin, player))
            {
                if (!Data.Plugins[plugin].UserVariables.ContainsKey(player.userID)) { return 0; }
                return Data.Plugins[plugin].UserVariables[player.userID].Count();
            }
            return 0;
        }
        private bool InitPlayer(Plugin plugin, BasePlayer player, bool debug = false)
        {
            if (!PlayerExists(plugin, player) && PluginExists(plugin))
            {
                PlayersInit data = new PlayersInit();
                data.tDisplayName = player.displayName;
                data.uUserID = player.userID;
                Data.Plugins[plugin].Users.Add(player.userID, data);
                if (debug) Puts("[" + plugin.Title + "] added " + Data.Plugins[plugin].Users[player.userID].tDisplayName + " (" + Data.Plugins[plugin].Users[player.userID].uUserID.ToString() + ") to the user list.");
                return true;
            }
            return false;
        }
        private bool RemovePlayer(Plugin plugin, BasePlayer player, bool debug = false)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Users.ContainsKey(player.userID))
                {
                    if (debug) Puts("[" + plugin.Title + "] Removing " + Data.Plugins[plugin].Users[player.userID].tDisplayName + " [ " + player.userID + " ] ");
                    Data.Plugins[plugin].Users.Remove(player.userID);
                    return true;
                }
            }
            return false;
        }
        private bool PlayerExists(Plugin plugin, BasePlayer player)
        {
            if (PluginExists(plugin))
            {
                if (Data.Plugins[plugin].Users.ContainsKey(player.userID))
                {
                    return true;
                }
            }
            return false;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();
            Config["Protocol"] = Protocol.network;
            SaveConfig();
        }
    }
}

// --- End of file: MagicVariables.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mlrs-wipe-block ---
// --- Original File Path: M/MLRSWipeBlock/MLRSWipeBlock.cs ---

using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
  [Info("MLRS Wipe Block", "Malmo", "1.0.1")]
  [Description("Blocks use of MLRS while wipe block")]
  internal class MLRSWipeBlock : RustPlugin
  {
    #region Dependencies

    [PluginReference]
    private Plugin WipeBlock;

    #endregion

    #region Hooks

    private void OnServerInitialized()
    {
      if (WipeBlock == null || !WipeBlock.IsLoaded)
      {
        PrintWarning("WipeBlock is not loaded, get it at https://umod.org/plugins/wipeblock");
      }
    }

    object CanMountEntity(BasePlayer player, MLRS entity)
    {

      // bypass if admin
      if (player.IsAdmin) return null;

      // bypass if wipeblock is not loaded
      if (WipeBlock == null) return null;

      var timeLeft = GetTimeLeft();
      if (timeLeft > 0)
      {
        ChatMessage(player, "Blocked", GetTimeString(timeLeft));
        return false;
      }

      return null;
    }

    #endregion

    #region Helper Methods

    private int GetTimeLeft()
    {
      var blockedItems = WipeBlock.Call<Dictionary<string, int>>("API_GetTimesLeft");
      if (blockedItems.ContainsKey("mlrs"))
      {
        var timeLeft = blockedItems["mlrs"];

        return timeLeft;
      }

      return 0;
    }

    private string GetTimeString(int time)
    {
      var timeString = string.Empty;
      var days = time / 86400;
      time = time % 86400;
      if (days > 0)
      {
        timeString += days + "d";
      }

      var hours = time / 3600;
      time = time % 3600;
      if (hours > 0)
      {
        if (days > 0)
        {
          timeString += ", ";
        }

        timeString += hours + "h";
      }

      var minutes = time / 60;
      time = time % 60;
      if (minutes > 0)
      {
        if (hours > 0)
        {
          timeString += ", ";
        }

        timeString += minutes + "m";
      }

      var seconds = time;
      if (seconds > 0)
      {
        if (minutes > 0)
        {
          timeString += ", ";
        }

        timeString += seconds + "s";
      }

      return timeString;
    }

    #endregion

    #region Localization

    private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
    player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

    private string GetMessage(IPlayer player, string messageName, params object[] args) =>
        GetMessage(player.Id, messageName, args);

    private string GetMessage(string playerId, string messageName, params object[] args)
    {
      var message = lang.GetMessage(messageName, this, playerId);
      return args.Length > 0 ? string.Format(message, args) : message;
    }

    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        ["Blocked"] = "MLRS is <color=red>wipe blocked</color> for {0}"
      }, this, "en");
    }

    #endregion
  }
}


// --- End of file: MLRSWipeBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-ch47-panel ---
// --- Original File Path: M/MagicCh47Panel/MagicCh47Panel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Ch47 Panel", "MJSU", "1.0.2")]
    [Description("Displays is the Ch47 event is active")]
    public class MagicCh47Panel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<CH47Helicopter> _activeCh47 = new List<CH47Helicopter>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 4,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/YqbM1TzX/89Jm3Lf.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.03f, 0.12f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 2,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeCh47 = UnityEngine.Object.FindObjectsOfType<CH47Helicopter>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeCh47.Count == 0 || _activeCh47.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(CH47Helicopter heli)
        {
            if (!_init)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (!CanShowPanel(heli))
                {
                    return;
                }
            
                _activeCh47.Add(heli);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(CH47Helicopter heli)
        {
            _activeCh47.Remove(heli);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeCh47.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private bool CanShowPanel(CH47Helicopter heli)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, heli);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#ffffff1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicCh47Panel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magazin-booster ---
// --- Original File Path: M/MagazinBoost/MagazinBoost.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Reflection;

namespace Oxide.Plugins
{
	[Info("MagazinBoost", "Fujikura", "1.6.2", ResourceId = 1962)]
	[Description("Can change magazines, ammo and condition for most projectile weapons")]
	public class MagazinBoost : RustPlugin
	{
		bool Changed;

		Dictionary<string, object> weaponContainer = new Dictionary <string, object>();
		Dictionary<string, string> guidToPath;

		#region Config

		string permissionAll;
		string permissionMaxAmmo;
		string permissionPreLoad;
		string permissionMaxCondition;
		string permissionAmmoType;
		bool checkPermission;
		bool removeSkinIfNoRights;

		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			permissionAll = Convert.ToString(GetConfig("Permissions", "permissionAll", "magazinboost.canall"));
			permissionMaxAmmo = Convert.ToString(GetConfig("Permissions", "permissionMaxAmmo", "magazinboost.canmaxammo"));
			permissionPreLoad = Convert.ToString(GetConfig("Permissions", "permissionPreLoad", "magazinboost.canpreload"));
			permissionMaxCondition = Convert.ToString(GetConfig("Permissions", "permissionMaxCondition", "magazinboost.canmaxcondition"));
			permissionAmmoType = Convert.ToString(GetConfig("Permissions", "permissionAmmoType", "magazinboost.canammotype"));
			checkPermission = Convert.ToBoolean(GetConfig("CheckRights", "checkForRightsInBelt", true));
			removeSkinIfNoRights = Convert.ToBoolean(GetConfig("CheckRights", "removeSkinIfNoRights", true));
			weaponContainer = (Dictionary<string, object>)GetConfig("Weapons", "Data", new Dictionary<string, object>());

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}

		#endregion Config

		void GetWeapons()
		{
			weaponContainer = (Dictionary <string, object>)Config["Weapons", "Data"];
			var weapons = ItemManager.GetItemDefinitions().Where(p => p.category == ItemCategory.Weapon && p.GetComponent<ItemModEntity>() != null);

			if (weaponContainer != null && weaponContainer.Count() > 0)
			{
				int countLoadedServerStats = 0;
				foreach (var weapon in weapons)
				{
					if (!guidToPath.ContainsKey(weapon.GetComponent<ItemModEntity>().entityPrefab.guid) || weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>() == null) continue;
					if (weaponContainer.ContainsKey(weapon.shortname))
					{
						Dictionary <string, object> serverDefaults = weaponContainer[weapon.shortname] as Dictionary <string, object>;
						if(!serverDefaults.ContainsKey("givemaxammo"))
						{
							serverDefaults.Add("givemaxammo", serverDefaults["servermaxammo"]);
							serverDefaults.Add("givepreload", serverDefaults["serverpreload"]);
							serverDefaults.Add("giveammotype", serverDefaults["serverammotype"]);
							serverDefaults.Add("givemaxcondition", serverDefaults["servermaxcondition"]);
							serverDefaults.Add("giveskinid", 0);
						}

						if ((bool)serverDefaults["serveractive"])
						{
							ItemDefinition weaponDef = ItemManager.FindItemDefinition(weapon.shortname);
							weaponDef.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize = (int)serverDefaults["servermaxammo"];
							weaponDef.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents = (int)serverDefaults["serverpreload"];
							ItemDefinition ammo = ItemManager.FindItemDefinition((string)serverDefaults["serverammotype"]);
							if (ammo != null)
								weaponDef.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType = ammo;
							weaponDef.condition.max = Convert.ToSingle(serverDefaults["servermaxcondition"]);
							countLoadedServerStats++;
						}
						continue;
					}
					Dictionary <string, object> weaponStats = new Dictionary <string, object>();
					weaponStats.Add("displayname", weapon.displayName.english);
					weaponStats.Add("maxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("preload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("maxcondition", weapon.condition.max);
					weaponStats.Add("ammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("skinid", 0);
					weaponStats.Add("settingactive", true);
					weaponStats.Add("servermaxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("serverpreload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("serverammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("servermaxcondition", weapon.condition.max);
					weaponStats.Add("serveractive", false);
					weaponStats.Add("givemaxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("givepreload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("giveammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("givemaxcondition", weapon.condition.max);
					weaponContainer.Add(weapon.shortname, weaponStats);
					Puts($"Added NEW weapon '{weapon.displayName.english} ({weapon.shortname})' to weapons list");
				}
				if (countLoadedServerStats > 0)
					Puts($"Changed server default values for '{countLoadedServerStats}' weapons");
				Config["Weapons", "Data"] = weaponContainer;
				Config.Save();
				return;
			}
			else
			{
				int counter = 0;
				foreach (var weapon in weapons)
				{
					if (!guidToPath.ContainsKey(weapon.GetComponent<ItemModEntity>().entityPrefab.guid)) continue;
					if (weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>() == null) continue;

					Dictionary <string, object> weaponStats = new Dictionary <string, object>();
					weaponStats.Add("displayname", weapon.displayName.english);
					weaponStats.Add("maxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("preload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("maxcondition", weapon.condition.max);
					weaponStats.Add("ammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("skinid", 0);
					weaponStats.Add("settingactive", true);
					weaponStats.Add("servermaxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("serverpreload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("serverammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("servermaxcondition", weapon.condition.max);
					weaponStats.Add("serveractive", false);
					weaponStats.Add("givemaxammo", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize);
					weaponStats.Add("givepreload", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.contents);
					weaponStats.Add("giveammotype", weapon.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.ammoType.shortname);
					weaponStats.Add("givemaxcondition", weapon.condition.max);
					weaponStats.Add("giveskinid", 0);
					weaponContainer.Add(weapon.shortname, weaponStats);
					counter++;
				}
				Puts($"Created initial weaponlist with '{counter}' projectile weapons.");
				Config["Weapons", "Data"] = weaponContainer;
				Config.Save();
				return;
			}
		}

		bool hasAnyRight(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, permissionAll)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionMaxAmmo)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionPreLoad)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionMaxCondition)) return true;
			if (permission.UserHasPermission(player.UserIDString, permissionAmmoType)) return true;
			return false;
		}

		bool hasRight(BasePlayer player, string perm)
		{
			bool right = false;
			switch (perm)
			{
				case "all":
						if (permission.UserHasPermission(player.UserIDString, permissionAll)) {right = true;}
						break;
				case "maxammo":
						if (permission.UserHasPermission(player.UserIDString, permissionMaxAmmo)) {right = true;}
						break;
				case "preload":
						if (permission.UserHasPermission(player.UserIDString, permissionPreLoad)) {right = true;}
						break;
				case "maxcondition":
						if (permission.UserHasPermission(player.UserIDString, permissionMaxCondition)) {right = true;}
						break;
				case "ammotype":
						if (permission.UserHasPermission(player.UserIDString, permissionAmmoType)) {right = true;}
						break;
				default:
						break;

			}
			return right;
		}

		void OnServerInitialized()
		{
			LoadVariables();
			guidToPath = GameManifest.guidToPath;
			GetWeapons();
			permission.RegisterPermission(permissionAll, this);
			permission.RegisterPermission(permissionMaxAmmo, this);
			permission.RegisterPermission(permissionPreLoad, this);
			permission.RegisterPermission(permissionMaxCondition, this);
			permission.RegisterPermission(permissionAmmoType, this);
		}

		void OnItemCraftFinished(ItemCraftTask task, Item item)
		{
			if(!(item.GetHeldEntity() is BaseProjectile)) return;
			if(!hasAnyRight(task.owner)) return;
			Dictionary <string, object> weaponStats = null;
			if (weaponContainer.ContainsKey(item.info.shortname))
				weaponStats = weaponContainer[item.info.shortname] as Dictionary <string, object>;
			if (!(bool)weaponStats["settingactive"]) return;
			if (hasRight(task.owner,"maxammo") || hasRight(task.owner, "all"))
				(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = (int)weaponStats["maxammo"];
			if (hasRight(task.owner,"preload") || hasRight(task.owner, "all"))
				(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = (int)weaponStats["preload"];
			if (hasRight(task.owner,"ammotype") || hasRight(task.owner, "all"))
			{
				var ammo = ItemManager.FindItemDefinition((string)weaponStats["ammotype"]);
				if (ammo != null)
					(item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ammo;
			}
			if (hasRight(task.owner,"maxcondition") || hasRight(task.owner, "all"))
			{
				item._maxCondition = Convert.ToSingle(weaponStats["maxcondition"]);
				item._condition = Convert.ToSingle(weaponStats["maxcondition"]);
			}
			if((int)weaponStats["skinid"] > 0)
			{
				item.skin = Convert.ToUInt64(weaponStats["skinid"]);
				item.GetHeldEntity().skinID = Convert.ToUInt64(weaponStats["skinid"]);
			}
		}

		private void OnItemAddedToContainer(ItemContainer container, Item item)
		{
			if(!checkPermission) return;
			if(item.GetHeldEntity() is BaseProjectile && container.HasFlag(ItemContainer.Flag.Belt))
			{
				Dictionary <string, object> weaponStats = null;
				object checkStats;
				if (weaponContainer.TryGetValue(item.info.shortname, out checkStats))
				{
					weaponStats = checkStats as Dictionary <string, object>;
					if (!(bool)weaponStats["settingactive"]) return;
				}
				else
					return;
				if ((item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity > item.info.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize && !(hasRight(container.playerOwner, "maxammo") || hasRight(container.playerOwner, "all")))
				{
					(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = item.info.GetComponent<ItemModEntity>().entityPrefab.Get().GetComponent<BaseProjectile>().primaryMagazine.definition.builtInSize;
					if ((item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents > (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity)
						(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity;
				}
				if (item.maxCondition > item.info.condition.max && !(hasRight(container.playerOwner, "maxcondition") || hasRight(container.playerOwner, "all")))
				{
					var newCon = item.condition * (item.info.condition.max / item.maxCondition);
					item._maxCondition = Convert.ToSingle(item.info.condition.max);
					item._condition = Convert.ToSingle(newCon);
				}
				if (removeSkinIfNoRights && !hasAnyRight(container.playerOwner) && item.GetHeldEntity().skinID == Convert.ToUInt64(weaponStats["skinid"]) && item.GetHeldEntity().skinID != 0uL)
				{
					item.skin = 0uL;
					item.GetHeldEntity().skinID = 0uL;
				}
			}
		}

		[ConsoleCommand("mb.giveplayer")]
		void BoostGive(ConsoleSystem.Arg arg)
		{
			if (arg.Connection != null && arg.Connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length < 2)
			{
				SendReply(arg, "Usage: magazinboost.give playername|id weaponshortname (optional: skinid)");
				return;
			}

			ulong skinid = 0;
			if (arg.Args.Length > 2)
			{
				if (!ulong.TryParse(arg.Args[2], out skinid))
				{
					SendReply(arg, "Skin has to be a number");
					return;
				}
				if (arg.Args[2].Length != 9)
				{
					SendReply(arg, "Skin has to be a 9-digit number");
					return;
				}
			}

			BasePlayer target = BasePlayer.Find(arg.Args[0]);
			if (target == null)
			{
				SendReply(arg, $"Player '{arg.Args[0]}' not found");
				return;
			}

			Dictionary <string, object> weaponStats = null;
			object checkStats;
			if (weaponContainer.TryGetValue(arg.Args[1], out checkStats))
				weaponStats = checkStats as Dictionary <string, object>;
			else
			{
				SendReply(arg, "Weapon '{arg.Args[0]}' not included/supported");
				return;
			}

			Item item = ItemManager.Create(ItemManager.FindItemDefinition(arg.Args[1]), 1, skinid);
			if (item == null)
			{
				SendReply(arg, "Weapon for unknown reason not created");
				return;
			}

			(item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = (int)weaponStats["givemaxammo"];
			(item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = (int)weaponStats["givepreload"];
			var ammo = ItemManager.FindItemDefinition((string)weaponStats["giveammotype"]);
			if (ammo != null)
				(item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ammo;
			item._maxCondition = Convert.ToSingle(weaponStats["givemaxcondition"]);
			item._condition = Convert.ToSingle(weaponStats["givemaxcondition"]);

			if (skinid == 0 && Convert.ToUInt64(weaponStats["giveskinid"]) > 0)
			skinid = Convert.ToUInt64(weaponStats["giveskinid"]);

			if(skinid > 0)
			{
				item.skin = Convert.ToUInt64(weaponStats["giveskinid"]);
				item.GetHeldEntity().skinID = Convert.ToUInt64(weaponStats["giveskinid"]);
			}
			target.GiveItem(item);
			SendReply(arg, $"Weapon '{arg.Args[1]}' given to Player '{target.displayName}'");
		}
	}
}

// --- End of file: MagazinBoost.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-bradley-panel ---
// --- Original File Path: M/MagicBradleyPanel/MagicBradleyPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Bradley Panel", "MJSU", "1.0.2")]
    [Description("Displays if the bradley event is active")]
    public class MagicBradleyPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<BradleyAPC> _activeBradlys = new List<BradleyAPC>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 6,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/7YbLhxgH/VrYPrKI.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 0,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeBradlys = UnityEngine.Object.FindObjectsOfType<BradleyAPC>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeBradlys.Count == 0 || _activeBradlys.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(BradleyAPC bradley)
        {
            if (!_init)
            {
                return;
            }
        
            NextTick(() =>
            {
                if (!CanShowPanel(bradley))
                {
                    return;
                }

                _activeBradlys.Add(bradley);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(BradleyAPC bradley)
        {
            if (!_activeBradlys.Remove(bradley))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeBradlys.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods

        private bool CanShowPanel(BradleyAPC bradley)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, bradley);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicBradleyPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mysql-whitelist ---
// --- Original File Path: M/MySQLWhitelist/MySQLWhitelist.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MySQL Whitelist", "Sonny-Boi", "1.0.0")]
    [Description("Restricts server access to only those whitelisted in a database")]
    internal class MySQLWhitelist : RustPlugin
    {
        #region Configuration
        private Configuration config;
        class Configuration
        {
            [JsonProperty("host")]
            public string host;
            [JsonProperty("port")]
            public ulong port;
            [JsonProperty("username")]
            public string username;
            [JsonProperty("password")]
            public string password;
            [JsonProperty("database")]
            public string database;

            public static Configuration DefaultConfig()
            {
                return new Configuration()
                {
                    host = "localhost",
                    port = 3306,
                    username = "root",
                    password = "",
                    database = "rust"
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            config = Configuration.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        private void Init()
        {
            LoadConfig();
        }
        #endregion

        private readonly Core.MySql.Libraries.MySql _mySql = Interface.Oxide.GetLibrary<Core.MySql.Libraries.MySql>();
        private Core.Database.Connection _mySqlConnection;
        public List<string> whitelistedPlayers = new List<string>();

        private const string SelectData = "SELECT * FROM whitelist";
        private const string CreateQuery = "CREATE TABLE IF NOT EXISTS `whitelist` ( `id` INT(11) NOT NULL AUTO_INCREMENT , `steamid` VARCHAR(255) NOT NULL, PRIMARY KEY(`id`))";

        private void OnServerInitialized()
        {
            _mySqlConnection = _mySql.OpenDb(Config["host"].ToString(), Convert.ToInt32(Config["port"]), Config["database"].ToString(), Config["username"].ToString(), Config["password"].ToString(), this);
            var sql = Core.Database.Sql.Builder.Append(CreateQuery);
            _mySql.Insert(sql, _mySqlConnection);
            sql = Core.Database.Sql.Builder.Append(SelectData);
            _mySql.Query(sql, _mySqlConnection, list =>
            {
                if (list.Count > 0)
                {
                    foreach (var entry in list)
                    {
                        whitelistedPlayers.Add(entry["steamid"].ToString());
                    }
                }
                PrintWarning("Updated whitelisted users list, checking if players are whitelisted");
            });
        }

        private bool isWhitelisted(string id)
        {
            if (whitelistedPlayers != null && whitelistedPlayers.Contains(id))
                return true;
            return false;
        }

        private void CheckIfWhitelistedOrKick(BasePlayer player)
        {
            if(!isWhitelisted(player.UserIDString) || whitelistedPlayers == null)
            {
                player.Kick(Lang("NotWhitelisted", player.UserIDString));
            }
        }

        private void OnServerSave()
        {
            List<BasePlayer> currentPlayers = BasePlayer.activePlayerList.ToList();
            OnServerInitialized();
            foreach (BasePlayer player in currentPlayers)
                CheckIfWhitelistedOrKick(player);  
        }

        object CanUserLogin(string name, string id)
        {
            if (isWhitelisted(id))
                return true;
            return Lang("NotWhitelisted");
        }

        #region Localization
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotWhitelisted"] = "You are not whitelisted!"
            }, this);
        }
        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
        #endregion
    }
}


// --- End of file: MySQLWhitelist.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/manage-mini ---
// --- Original File Path: M/ManageMini/ManageMini.cs ---

﻿using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;
using System.Security;
using System.CodeDom.Compiler;

namespace Oxide.Plugins
{
    [Info("Manage Mini", "DMB7", "0.3.3"), Description("Manage, customize and own your minicopter!")]
    class ManageMini : RustPlugin
    {
        #region  Global Variables
        private MiniData miniData;
        private ConfigFile configFile;
        private List<string> miniChatCommands;
        private System.Random rand = new System.Random();
        private int batteryMaxDrain = 25;

        #region Permissions
        // Chat Commands
        private string miniHelpPerm = "ManageMini.miniHelp";
        private string makeMiniPerm = "ManageMini.makeMini";
        private string takeMiniPerm = "ManageMini.takeMini";
        private string getMiniPerm = "ManageMini.getMini";
        private string ownMiniPerm = "ManageMini.ownMini";
        private string authPilotPerm = "ManageMini.authPilot";
        private string unauthPilotPerm = "ManageMini.unauthPilot";
        private string miniDetailsPerm = "ManageMini.miniDetails";
        private string upgradeMiniPerm = "ManageMini.upgradeMini";
        private string upgradeTurretPerm = "ManageMini.upgradeMiniTurret";

        // Fuel Usage Rate
        private string unlimitedFuel = "ManageMini.UnlimitedFuel";
        private string randomFuelRate = "ManageMini.RandomFuelRate";

        #endregion

        #endregion

        #region Hooks
        private void Init()
        {
            // Global Variable Initialization
            configFile = Config.ReadObject<ConfigFile>();
            miniChatCommands = new List<string>();
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("ManageMini"))
            {
                Interface.Oxide.DataFileSystem.GetDatafile("ManageMini").Save();
            }
            miniData = Interface.Oxide.DataFileSystem.ReadObject<MiniData>("ManageMini");

            // Register Permissions            
            registerPerms();

            // Set Chat Commands for the help system
            setChatHelp();
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("ManageMini", miniData);
        }

        void OnServerSave()
        {
            Interface.Oxide.DataFileSystem.WriteObject("ManageMini", miniData);
        }

        void onEntityKill(MiniCopter mini)
        {
            if (mini != null)
            {
                if (!mini.OwnerID.ToString().Equals("0"))
                {
                    miniData.ownerMini.Remove(mini.OwnerID);
                    chatMessage(getPlayer(mini.OwnerID), "Mini_DestroyedNow", null);
                }
            }
        }

        object CanMountEntity(BasePlayer player, BaseMountable mini)
        {
            if (player != null && mini != null)
            {

                if (mini.ShortPrefabName.ToString().Equals("minihelipassenger"))
                {
                    return null;
                }
                else if (mini.ShortPrefabName.ToString().Equals("miniheliseat"))
                {
                    BasePlayer owner = getPlayer(mini.VehicleParent().OwnerID);
                    if (owner == null && !miniData.ownerMini.ContainsKey(owner.userID))
                    {
                        return null;
                    }
                    else if (miniData.ownerMini[owner.userID].getAuthPilots().Contains(player.userID.ToString()))
                    {
                        fixUpgradeMini(owner);
                        if (miniData.ownerMini[owner.userID].hasAutoTurret()
                             && (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity) != null)
                        {
                            disableWire(owner);
                            setTurretRange(owner, 600);
                        }
                        if (miniData.ownerMini[owner.userID].hasElectricEngine()
                             && (BaseNetworkable.serverEntities.Find(getMiniData(player, 4)) as IOEntity) != null)
                        {
                            disableWire(owner);
                            setFuelRate(getMinicopter(owner), miniData.ownerMini[owner.userID].getFuelPerSec());
                            setFuelAmount(getMinicopter(owner) as BaseVehicle, getTotalPower(getBatteries(owner)));
                        }
                        if (miniData.ownerMini[owner.userID].hasBatteries()
                             && (BaseNetworkable.serverEntities.Find(getMiniData(player, 2)) as IOEntity) != null
                              && (BaseNetworkable.serverEntities.Find(getMiniData(player, 3)) as IOEntity) != null)
                        {
                            disableWire(owner);
                        }
                        resetFuelRate(owner, miniData.ownerMini[owner.userID].getFuelPerSec());
                        return null;
                    }
                    else
                    {
                        string[] obj = { player.displayName, owner.displayName };
                        chatMessageArray(player, "Unauth_PilotAttempt", obj);
                        chatMessage(owner, "Owner_AlertMini", player.displayName);
                        return false;
                    }
                }
                else
                {
                    return null;
                }

            }
            else
            {
                return null;
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player != null)
            {
                if (miniData.ownerMini.ContainsKey(player.userID))
                {

                    if (miniData.ownerMini[player.userID].hasElectricEngine())
                    {
                        resetFuelRate(player, miniData.ownerMini[player.userID].getFuelPerSec());
                        getMinicopter(player).fuelGaugeMax = 450f;
                    }
                    else if (checkPermissions(player, unlimitedFuel))
                    {
                        resetFuelRate(player, configFile.fuelPerSecUnlimited);
                    }
                    else if (checkPermissions(player, randomFuelRate))
                    {
                        resetFuelRate(player, (float)Math.Round((0.15 + rand.NextDouble() * 0.50), 2));
                    }
                    else
                    {
                        resetFuelRate(player, configFile.fuelPerSec);
                    }
                    resetBatteriesDrain(player);
                }
            }
        }

        void OnEntityDismounted(BaseMountable mini, BasePlayer player)
        {
            if (player != null && mini != null)
            {
                if (mini.ShortPrefabName.ToString().Equals("miniheliseat"))
                {
                    BasePlayer owner = getPlayer(mini.VehicleParent().OwnerID);
                    if (owner == null)
                    {
                        return;
                    }
                    if (miniData.ownerMini.ContainsKey(owner.userID))
                    {
                        if (miniData.ownerMini[owner.userID].hasElectricEngine())
                        {
                            setTotalPower(owner, getFuelAmount(mini.VehicleParent() as BaseVehicle));
                        }
                    }
                }

            }
        }
        #endregion

        #region Base ManageMini Chat Commands
        [ChatCommand("minihelp")]
        private void miniHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else
            {
                string message = lang.GetMessage("ManageMini_Help", this, player.UserIDString) + "\n";
                foreach (var chatCommand in miniChatCommands)
                {
                    message = message + "\n" + chatCommand + lang.GetMessage(chatCommand, this, player.UserIDString);
                }
                chatMessage(player, message, null);
            }
        }

        [ChatCommand("makemini")]
        private void makeMini(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, makeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "Already_CreatedMini", player.displayName);
            }
            else if (checkWaitList(player))
            {
                // checkWaitList() handles the output to player
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                createMini(player);
                chatMessage(player, "Make_Mini", player.displayName);
            }
            else
            {
                miniData.errorLog.Add(player.userID, "make mini has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        [ChatCommand("takemini")]
        private void takeMini(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, takeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                takeBackMini(player);
            }
            else
            {
                miniData.errorLog.Add(player.userID, "takemini has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        [ChatCommand("getmini")]
        private void getMini(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, getMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                if (setMiniLocation(player))
                {
                    chatMessage(player, "Get_Mini", null);
                }
                else
                {
                    chatMessage(player, "Error_ManageMini", null);
                }
            }
            else
            {
                miniData.errorLog.Add(player.userID, "getMini has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        [ChatCommand("ownMini")]
        private void ownMini(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, ownMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "Already_CreatedMini", player.displayName);
            }
            else if (!player.isMounted)
            {
                chatMessage(player, "Player_NotSeatedMini", null);
            }
            else if (player.isMounted)
            {
                MiniCopter mini = player.GetMountedVehicle() as MiniCopter;
                if (mini == null)
                {
                    chatMessage(player, "Player_NotSeatedMini", null);
                }
                else if (mini.ShortPrefabName == "minicopter.entity")
                {
                    if (mini.OwnerID.ToString() == "0" || mini.OwnerID == player.userID)
                    {
                        mini.OwnerID = player.userID;
                        takeOwnershipMini(player, mini);
                        chatMessage(player, "Took_OwnershipMini", player.displayName);
                    }
                    else
                    {
                        chatMessage(player, "FailedTake_OwnershipMini", getPlayer(mini.OwnerID).displayName);
                    }
                }
                else
                {
                    chatMessage(player, "Player_NotSeatedMini", null);
                }
            }
            else
            {
                miniData.errorLog.Add(player.userID, "getMini has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }


        }

        [ChatCommand("authPilot")]
        private void authPilot(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, makeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                if (args.Length == 0)
                {
                    chatMessage(player, "No_Args", "/authPilot <playerName>");
                }
                else
                {
                    if (addAuthPilot(player, args[0]))
                    {
                        chatMessage(player, "Auth_Pilot", (getPlayer(args[0]).displayName));
                    }
                    else
                    {
                        chatMessage(player, "No_PlayerFound", args[0]);
                    }
                }
            }
            else
            {
                miniData.errorLog.Add(player.userID, "authPilot has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        [ChatCommand("unauthPilot")]
        private void unauthPilot(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, makeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                if (args.Length == 0)
                {
                    chatMessage(player, "No_Args", "/authPilot <playerName");
                }
                else
                {
                    if (removeAuthPilot(player, args[0]))
                    {
                        chatMessage(player, "Unauth_Pilot", getPlayer(args[0]).displayName);
                    }
                    else
                    {
                        chatMessage(player, "No_PlayerFound", args[0]);
                    }
                }
            }
            else
            {
                miniData.errorLog.Add(player.userID, "unauthPilot has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        [ChatCommand("miniDetails")]
        private void miniDetails(BasePlayer player, string command, string[] args)
        {
            if (player == null) { return; }
            else if (!checkPermissions(player, makeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                string message = chatAuthPilotList(player);
                message = message + "\n\n" + string.Format(lang.GetMessage("Mini_FuelRate", this, player.UserIDString), getMinicopter(player).fuelPerSec.ToString());
                message = message + "\n\n" + chatMinicopterAge(player);
                chatMessage(player, null, message);
            }
            else
            {
                miniData.errorLog.Add(player.userID, "miniDetails has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }

        #endregion

        #region Upgrade Mini Chat Commands
        [ChatCommand("upgradeMini")]
        private void upgradeMini(BasePlayer player, string command, string[] args)
        {
            string message =
                "/upgradeMini batteries add \n /upgradeMini batteries remove" +
                "\n\n /upgradeMini eFuel add \n /upgradeMini eFuel remove" +
                "\n\n /upgradeMini turret add \n /upgradeMini turret on \n /upgradeMini turret off \n /upgrademini turret remove" +
            "";
            if (player == null) { return; }
            else if (!checkPermissions(player, upgradeMiniPerm))
            {
                chatMessage(player, "PermissionCheck_failed", player.displayName);
            }
            else if (args.Length < 1 || args.Length > 2)
            {
                chatMessage(player, "No_Args", message);
            }
            else if (!miniData.ownerMini.ContainsKey(player.userID))
            {
                chatMessage(player, "mini_NotFound", player.displayName);
            }
            else if (miniData.ownerMini.ContainsKey(player.userID))
            {
                if (args[0].Equals("batteries", StringComparison.InvariantCultureIgnoreCase))
                {
                    if (args.Length == 1)
                    {
                        chatMessage(player, "No_Args", message);
                    }
                    else if (args[1].Equals("add", StringComparison.InvariantCultureIgnoreCase))
                    {
                        addBatteriesMini(player, getMinicopter(player) as BaseVehicle);
                        chatMessage(player, "Upgrade_Mini", player.displayName);
                    }
                    else if (args[1].Equals("remove", StringComparison.InvariantCultureIgnoreCase)
                        && (BaseNetworkable.serverEntities.Find(getMiniData(player, 2)) as IOEntity) != null
                         && (BaseNetworkable.serverEntities.Find(getMiniData(player, 3)) as IOEntity) != null)
                    {
                        setMiniRotation(getMinicopter(player) as BaseVehicle);
                        removeBatteriesMini(player);
                    }
                    else
                    {
                        chatMessage(player, "No_Args", message);
                    }

                }
                else if (args[0].Equals("eFuel", StringComparison.InvariantCultureIgnoreCase))
                {
                    if (args.Length == 1)
                    {
                        chatMessage(player, "No_Args", message);
                    }
                    else if (args[1].Equals("add", StringComparison.InvariantCultureIgnoreCase))
                    {
                        if (!miniData.ownerMini[player.userID].hasBatteries())
                        {
                            chatMessage(player, "Batteries_NotIncluded", player.displayName);
                        }
                        else
                        {
                            upgradeElectricMini(player, getMinicopter(player) as BaseVehicle);
                            chatMessage(player, "Upgrade_Mini", player.displayName);
                            if (miniData.ownerMini[player.userID].hasAutoTurret())
                            {
                                setFuelRate(getMinicopter(player), 0.20f);
                            }
                            else
                            {
                                setFuelRate(getMinicopter(player), 0.10f);
                            }
                        }
                    }
                    else if (args[1].Equals("remove", StringComparison.InvariantCultureIgnoreCase)
                        && (BaseNetworkable.serverEntities.Find(getMiniData(player, 4)) as IOEntity) != null)
                    {
                        setMiniRotation(getMinicopter(player) as BaseVehicle);
                        setFuelRate(getMinicopter(player), 0.25f);
                        removeElectricMini(player);
                    }
                    else
                    {
                        chatMessage(player, "No_Args", message);
                    }

                }
                else if (args[0].Equals("turret", StringComparison.InvariantCultureIgnoreCase))
                {
                    if (!checkPermissions(player, upgradeTurretPerm))
                    {
                        chatMessage(player, "PermissionCheck_failed", player.displayName);
                    }
                    else if (args.Length == 1)
                    {
                        chatMessage(player, "No_Args", message);
                    }
                    else if (args[1].Equals("add", StringComparison.InvariantCultureIgnoreCase))
                    {
                        if (!miniData.ownerMini[player.userID].hasBatteries())
                        {
                            chatMessage(player, "Batteries_NotIncluded", player.displayName);
                        }
                        else
                        {
                            removeTurretMini(player);
                            setMiniData(player, addTurretMini(getMinicopter(player) as BaseVehicle), 5);
                            setWireScheme(player);
                            setTurretRange(player, 50);
                            chatMessage(player, "Upgrade_Mini", player.displayName);
                            if (miniData.ownerMini[player.userID].hasAutoTurret())
                            {
                                setFuelRate(getMinicopter(player), (float)(getMinicopter(player).fuelPerSec + 0.1f));
                            }
                        }
                    }
                    else if (args[1].Equals("on", StringComparison.InvariantCultureIgnoreCase)
                        && (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity) != null)
                    {
                        if (miniData.ownerMini[player.userID].hasElectricEngine())
                        {

                            setWire((BaseNetworkable.serverEntities.Find(getMiniData(player, 4)) as IOEntity), 0,
                                (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity), 0);
                        }
                        else
                        {
                            setWire((BaseNetworkable.serverEntities.Find(getMiniData(player, 3)) as IOEntity), 0,
                                 (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity), 0);
                        }
                        (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as AutoTurret).InitiateStartup();
                    }
                    else if (args[1].Equals("off", StringComparison.InvariantCultureIgnoreCase)
                        && (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity) != null)
                    {
                        (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as AutoTurret).InitiateShutdown();
                        (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity).ClearConnections();
                    }
                    else if (args[1].Equals("remove", StringComparison.InvariantCultureIgnoreCase)
                        && (BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity) != null)
                    {
                        setMiniRotation(getMinicopter(player) as BaseVehicle);
                        removeTurretMini(player);
                        if (miniData.ownerMini[player.userID].hasElectricEngine())
                        {
                            setFuelRate(getMinicopter(player), (float)(getMinicopter(player).fuelPerSec - 0.1f));
                        }
                    }
                    else
                    {
                        chatMessage(player, "No_Args", message);
                    }
                }
                else
                {
                    chatMessage(player, "No_Args", message);
                }
            }
            else
            {
                miniData.errorLog.Add(player.userID, "upgrademini has failed for unknown reason");
                chatMessage(player, "Error_ManageMini", null);
            }
        }


        #endregion

        #region Base ManageMini Functions
        private void registerPerms()
        {
            // Permission Registration
            permission.RegisterPermission(miniHelpPerm, this);
            permission.RegisterPermission(makeMiniPerm, this);
            permission.RegisterPermission(takeMiniPerm, this);
            permission.RegisterPermission(getMiniPerm, this);
            permission.RegisterPermission(authPilotPerm, this);
            permission.RegisterPermission(ownMiniPerm, this);
            permission.RegisterPermission(unauthPilotPerm, this);
            permission.RegisterPermission(miniDetailsPerm, this);
            permission.RegisterPermission(upgradeTurretPerm, this);
            permission.RegisterPermission(upgradeMiniPerm, this);

            // Fuel Rate Permission Registration
            permission.RegisterPermission(unlimitedFuel, this);
            permission.RegisterPermission(randomFuelRate, this);

        }

        private void registerWaitTimes()
        {
            foreach (var perm in configFile.waitTimes)
            {
                permission.RegisterPermission(perm.Key, this);
            }
        }

        private bool checkPermissions(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        private void setChatHelp()
        {
            miniChatCommands.Add("/miniHelp");
            miniChatCommands.Add("/makeMini");
            miniChatCommands.Add("/takeMini");
            miniChatCommands.Add("/getMini");
            miniChatCommands.Add("/ownMini");
            miniChatCommands.Add("/authPilot");
            miniChatCommands.Add("/unauthPilot");
            miniChatCommands.Add("/miniDetails");
            miniChatCommands.Add("/upgrademini");
        }

        private void createMini(BasePlayer player)
        {
            Vector3 location = new Vector3(player.transform.position.x + (float)(rand.NextDouble() * configFile.miniSpawnDistance), player.transform.position.y + 2f, player.transform.position.z + (float)(rand.NextDouble() * configFile.miniSpawnDistance));
            BaseVehicle mini = (BaseVehicle)GameManager.server.CreateEntity(configFile.assetPrefab, location, new Quaternion());
            if (mini == null)
            {
                miniData.errorLog.Add(player.userID, "create mini has failed to create entity");
                chatMessage(player, "Error_ManageMini", null);
                return;
            }
            mini.OwnerID = player.userID;
            mini.health = configFile.miniStartHealth;
            mini.Spawn();

            if (checkPermissions(player, unlimitedFuel))
            {

                StorageContainer fuelTank = mini.GetFuelSystem().GetFuelContainer();
                ItemManager.CreateByItemID(-946369541, configFile.fuelAmountUnlimited)?.MoveToContainer(fuelTank.inventory);
                fuelTank.SetFlag(BaseEntity.Flags.Locked, true);
                chatMessage(player, "No_FuelRate", null);
                setFuelRate(mini as MiniCopter, configFile.fuelPerSecUnlimited);
            }
            else if (checkPermissions(player, randomFuelRate))
            {
                setFuelRate(mini as MiniCopter, (float)Math.Round((0.10 + rand.NextDouble() * 0.40), 2));
            }
            else
            {
                setFuelRate(mini as MiniCopter, configFile.fuelPerSec);
            }

            takeOwnershipMini(player, mini as MiniCopter);
        }

        private void setFuelRate(MiniCopter mini, float fuelPerSec)
        {
            if (mini != null)
            {
                mini.fuelPerSec = fuelPerSec;
            }
        }

        private void resetFuelRate(BasePlayer player, float fuelPerSec)
        {
            MiniCopter mini = getMinicopter(player);
            if (mini != null)
            {
                setFuelRate(mini, fuelPerSec);
            }
        }

        private void takeOwnershipMini(BasePlayer player, MiniCopter mini)
        {
            OwnerMiniData ownerMiniData = new OwnerMiniData();
            ownerMiniData.setMiniEntityID(mini.net.ID);
            ownerMiniData.setFuelPerSec(mini.fuelPerSec);
            ownerMiniData.setManufactureData(DateTime.Now);
            ownerMiniData.setAuthPilots(new List<string> { player.userID.ToString() });
            miniData.ownerMini.Add(player.userID, ownerMiniData);
        }

        private bool checkWaitList(BasePlayer player)
        {
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                DateTime miniCreatedAt = miniData.ownerMini[player.userID].getManufactureData();

                float timeToWait = 0.0f;

                foreach (var time in configFile.waitTimes)
                {
                    if (checkPermissions(player, time.Key))
                    {
                        timeToWait = time.Value;
                        break;
                    }
                }

                double diff = (miniCreatedAt.AddSeconds(timeToWait) - DateTime.Now).TotalSeconds;
                if (diff > 0)
                {
                    string[] obj = { player.displayName, Math.Round(diff / 60.0, 2).ToString() };
                    chatMessageArray(player, "Mini_WaitList", obj);
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }

        private MiniCopter getMinicopter(BasePlayer player)
        {
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                return BaseNetworkable.serverEntities.Find(miniData.ownerMini[player.userID].getMiniEntityID()) as MiniCopter;
            }
            else
            {
                return null;
            }
        }

        private bool setMiniLocation(BasePlayer player)
        {
            Vector3 dest = new Vector3(player.transform.position.x + 2f, player.transform.position.y + 1.0f, player.transform.position.z + 2f);
            MiniCopter mini = getMinicopter(player);
            if (mini != null)
            {
                mini.transform.position = dest;
                return true;
            }
            else
            {
                return false;
            }
        }

        private void takeBackMini(BasePlayer player)
        {
            // miniData.ownerMini.containsKey(player.userID) verified in chat command region
            BaseNetworkable.serverEntities.Find(miniData.ownerMini[player.userID].getMiniEntityID())?.Kill();
            miniData.ownerMini.Remove(player.userID);
            chatMessage(player, "Take_Mini", null);
        }

        #endregion

        #region get player ulong/string
        private BasePlayer getPlayer(ulong id)
        {
            BasePlayer owner;
            if (BasePlayer.FindByID(id) == null)
            { owner = BasePlayer.FindSleeping(id); }
            else if (BasePlayer.FindSleeping(id) == null)
            { owner = BasePlayer.FindByID(id); }
            else
            { return null; }
            return owner;
        }

        private BasePlayer getPlayer(string name)
        {
            BasePlayer player;
            if (BasePlayer.Find(name) == null)
            { player = BasePlayer.FindSleeping(name); }
            else if (BasePlayer.FindSleeping(name) == null)
            { player = BasePlayer.Find(name); }
            else
            { return null; }
            return player;
        }
        #endregion

        #region chat messages to player
        private void chatMessageArray(BasePlayer player, string msgType, string[] obj)
        {
            if (obj == null)
            {
                player.ChatMessage(lang.GetMessage(msgType, this, player.UserIDString));
            }
            else
            {
                player.ChatMessage(String.Format(lang.GetMessage(msgType, this, player.UserIDString), obj));
            }
        }

        private void chatMessage(BasePlayer player, string msgType, string message)
        {
            string[] obj = { message };
            if (obj == null && msgType != null)
            {
                player.ChatMessage(lang.GetMessage(msgType, this, player.UserIDString));
            }
            else if (msgType == null)
            {
                player.ChatMessage(message);
            }
            else
            {
                player.ChatMessage(String.Format(lang.GetMessage(msgType, this, player.UserIDString), obj));
            }

        }
        private string chatAuthPilotList(BasePlayer player)
        {
            string message = lang.GetMessage("Auth_PilotHeader", this, player.UserIDString);
            List<string> authPilots = getPilotsList(player);
            foreach (var pilot in authPilots)
            {
                message = message + "\n" + getPlayer(pilot).displayName;
            }
            return message;
        }

        private string chatMinicopterAge(BasePlayer player)
        {
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                DateTime miniCreatedAt = miniData.ownerMini[player.userID].getManufactureData();
                return string.Format(lang.GetMessage("MiniCopter_AgeDHMS", this, player.UserIDString), getTimeDHMS((int)Math.Truncate((DateTime.Now - miniCreatedAt).TotalSeconds)));
            }
            else
            {
                return "";
            }
        }

        private string[] getTimeDHMS(double var)
        {
            double totalDays = Math.Truncate(var / 86400.0);
            var = var - totalDays * 86400;
            double extraHours = Math.Truncate(var / 3600.0);
            var = var - extraHours * 3600;
            double extraMinutes = Math.Truncate(var / 60.0);
            var = var - extraMinutes * 60;
            double extraSeconds = var;

            string[] message = { totalDays.ToString(), extraHours.ToString(), extraMinutes.ToString(), extraSeconds.ToString() };
            return message;
        }
        #endregion

        #region Data Management Functions

        #region Set / Get Entity IDs 
        private void setMiniData(BasePlayer player, uint num, int index)
        {
            if (!miniData.ownerMini.ContainsKey(player.userID)) { return; }

            OwnerMiniData ownerMiniData = miniData.ownerMini[player.userID];
            // Entity ID storage
            if (index == 0) { ownerMiniData.setMiniEntityID(num); }
            else if (index == 1) { ownerMiniData.setBranchID(num); }
            else if (index == 2) { ownerMiniData.setBatteryLeftID(num); }
            else if (index == 3) { ownerMiniData.setBatteryRightID(num); }
            else if (index == 4) { ownerMiniData.setBatteryEngineID(num); }
            else if (index == 5) { ownerMiniData.setAutoTurretID(num); }
            else { return; }
            miniData.ownerMini[player.userID] = ownerMiniData;
        }

        private uint getMiniData(BasePlayer player, int index)
        {
            if (!miniData.ownerMini.ContainsKey(player.userID)) { return 0; }

            OwnerMiniData ownerMiniData = miniData.ownerMini[player.userID];
            // Entity ID retrieval
            if (index == 0) { return ownerMiniData.getMiniEntityID(); }
            else if (index == 1) { return ownerMiniData.getBranchID(); }
            else if (index == 2) { return ownerMiniData.getBatteryLeftID(); }
            else if (index == 3) { return ownerMiniData.getBatteryRightID(); }
            else if (index == 4) { return ownerMiniData.getBatteryEngineID(); }
            else if (index == 5) { return ownerMiniData.getAutoTurretID(); }
            else { return 0; }
        }
        #endregion

        #region Authorized Pilot Data Get/ Add/ Remove
        private List<string> getPilotsList(BasePlayer player)
        {
            if (!miniData.ownerMini.ContainsKey(player.userID)) { return null; }
            else { return miniData.ownerMini[player.userID].getAuthPilots(); }
        }

        private bool addAuthPilot(BasePlayer player, string name)
        {
            BasePlayer pilot = getPlayer(name);
            if (!miniData.ownerMini.ContainsKey(player.userID) || (pilot == null)) { return false; }
            else
            {
                OwnerMiniData ownerMiniData = miniData.ownerMini[player.userID];
                List<string> authPilots = ownerMiniData.getAuthPilots();
                if (authPilots.Contains(pilot.userID.ToString())) { return true; }
                authPilots.Add(pilot.userID.ToString());
                ownerMiniData.setAuthPilots(authPilots);
                miniData.ownerMini[player.userID] = ownerMiniData;
                return true;
            }
        }

        private bool removeAuthPilot(BasePlayer player, string name)
        {
            BasePlayer pilot = getPlayer(name);
            if (!miniData.ownerMini.ContainsKey(player.userID) || (pilot == null)) { return false; }
            else
            {
                OwnerMiniData ownerMiniData = miniData.ownerMini[player.userID];
                List<string> authPilots = ownerMiniData.getAuthPilots();
                if (!authPilots.Contains(pilot.userID.ToString())) { return false; }
                authPilots.Remove(pilot.userID.ToString());
                ownerMiniData.setAuthPilots(authPilots);
                miniData.ownerMini[player.userID] = ownerMiniData;
                return true;
            }
        }
        #endregion

        #region  Fuel Rate Storage
        private bool setFuelPerSec(BasePlayer player, float rate)
        {
            if (!miniData.ownerMini.ContainsKey(player.userID)) { return false; }
            else
            {
                OwnerMiniData ownerMiniData = miniData.ownerMini[player.userID];
                ownerMiniData.setFuelPerSec(rate);
                miniData.ownerMini[player.userID] = ownerMiniData;
                return true;
            }
        }
        #endregion

        #endregion

        #region Upgrade Mini Functions
        // TODO: research, plan and implement code to allow player to add more upgrades to their minicopter
        private void upgradeElectricMini(BasePlayer player, BaseVehicle mini)
        {
            if (mini == null)
            {
                return;
            }
            removeElectricMini(player);
            setMiniRotation(mini);
            setMiniData(player, addBatteries(mini, -0.05f, 1.3f, -0.35f, 175f, 180f, 0), 4);
            ElectricBattery bat = (BaseNetworkable.serverEntities.Find(getMiniData(player, 4)) as ElectricBattery);
            if (bat != null)
            {
                setFuelAmount(mini, getTotalPower(getBatteries(player)));
                lockFuelTank(mini.GetFuelSystem().GetFuelContainer(), true);
                bat.maxOutput = (batteryMaxDrain - 10);
                bat.rustWattSeconds = (float)(150 * 60.0);
                setWireScheme(player);
                (mini as MiniCopter).fuelGaugeMax = 450f;
            }
        }

        private void removeElectricMini(BasePlayer player)
        {
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                BaseNetworkable.serverEntities.Find(getMiniData(player, 4))?.Kill();
                setMiniData(player, 0, 4);
                setWireScheme(player);

                if (checkPermissions(player, unlimitedFuel))
                {
                    setFuelAmount(getMinicopter(player) as BaseVehicle, 100);
                    setFuelRate(getMinicopter(player), configFile.fuelPerSecUnlimited);
                    lockFuelTank((getMinicopter(player) as BaseVehicle).GetFuelSystem().GetFuelContainer(), true);
                }
                else
                {
                    setFuelAmount(getMinicopter(player) as BaseVehicle, 0);
                    lockFuelTank((getMinicopter(player) as BaseVehicle).GetFuelSystem().GetFuelContainer(), false);
                }
                getMinicopter(player).fuelGaugeMax = 100f;
            }
        }

        private void addBatteriesMini(BasePlayer player, BaseVehicle mini)
        {
            if (mini == null)
            {
                return;
            }
            removeBatteriesMini(player);
            setMiniRotation(mini);
            setMiniData(player, setElectricInput(mini, -0.75f, 0.43f, -0.75f, 0, 180f, 180f), 1);
            setMiniData(player, addBatteries(mini, -0.7f, 0.62f, -0.55f, 180f, 180f, 0), 2);
            setMiniData(player, addBatteries(mini, 0.7f, 0.62f, -0.55f, 180f, 0, 0), 3);
            ElectricBattery bat = (BaseNetworkable.serverEntities.Find(getMiniData(player, 3)) as ElectricBattery);
            if (bat != null)
            {
                bat.maxOutput = (batteryMaxDrain - 5);
                bat.rustWattSeconds = (float)(75 * 60.0);
            }
            setWireScheme(player);
        }

        private void removeBatteriesMini(BasePlayer player)
        {
            uint num = 0;
            for (int i = 1; i < 4; i++)
            {
                num = getMiniData(player, i);
                if (num != 0)
                {
                    setMiniData(player, 0, i);
                    removeUpgrade(num);
                }
            }
            if (miniData.ownerMini[player.userID].hasElectricEngine())
            {
                removeElectricMini(player);
            }
            setWireScheme(player);
        }

        private void removeTurretMini(BasePlayer player)
        {
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                uint num = getMiniData(player, 5);
                if (num == 0)
                {
                    return;
                }
                removeUpgrade(num);
                setMiniData(player, 0, 5);
                setWireScheme(player);
            }
        }

        private void removeUpgrade(uint num)
        {
            if (BaseNetworkable.serverEntities.Find(num) != null)
            {
                BaseNetworkable.serverEntities.Find(num)?.Kill();
            }
        }

        private uint addBatteries(BaseVehicle mini, float pos_x, float pos_y, float pos_z, float rot_x, float rot_y, float rot_z)
        {
            if (mini == null)
            {
                return 0;
            }
            string prefab = "assets/prefabs/deployable/playerioents/batteries/smallrechargablebattery.deployed.prefab";
            return setItemUpgrade<ElectricBattery>(prefab, mini, mini.transform.position, pos_x, pos_y, pos_z, rot_x, rot_y, rot_z);
        }

        private uint setElectricInput(BaseVehicle mini, float pos_x, float pos_y, float pos_z, float rot_x, float rot_y, float rot_z)
        {
            if (mini == null)
            {
                return 0;
            }
            string prefab = "assets/prefabs/deployable/playerioents/gates/branch/electrical.branch.deployed.prefab";
            return setItemUpgrade<ElectricalBranch>(prefab, mini, mini.transform.position, pos_x, pos_y, pos_z, rot_x, rot_y, rot_z);
        }

        private uint addTurretMini(BaseVehicle mini)
        {
            if (mini == null)
            {
                return 0;
            }
            setMiniRotation(mini);
            string prefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
            return setItemUpgrade<AutoTurret>(prefab, mini, mini.transform.position, 0, 0.17f, 2.285f, 0, 0, 0);
        }

        private void setTurretRange(BasePlayer player, float range)
        {
            if (getMiniData(player, 5) == 0)
            {
                return;
            }
            AutoTurret turret = BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as AutoTurret;
            if (turret != null)
            {
                turret.sightRange = range;
            }
        }

        private void setMiniRotation(BaseVehicle mini)
        {
            if (mini == null)
            {
                return;
            }
            mini.transform.localPosition = new Vector3(mini.transform.position.x, mini.transform.position.y + 0.5f, mini.transform.position.z);
            mini.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
            disableWire(getPlayer(mini.OwnerID));
        }

        private uint setItemUpgrade<Type>(string prefab, BaseVehicle mini, Vector3 location, float pos_x, float pos_y, float pos_z, float rot_x, float rot_y, float rot_z)
            where Type : BaseCombatEntity
        {
            Type item = GameManager.server.CreateEntity(prefab, location, new Quaternion()) as Type;
            if (item == null)
            {
                return 0;
            }
            disableGroundReq(item);
            item.Spawn();
            item.pickup.enabled = false;
            item.SetParent(mini);
            if (prefab.Contains("batteries") && item != null)
            {
                (item as ElectricBattery).maxOutput = batteryMaxDrain;
            }
            item.transform.localPosition = new Vector3(pos_x, pos_y, pos_z);
            item.transform.localRotation = Quaternion.Euler(rot_x, rot_y, rot_z);
            item.OwnerID = mini.OwnerID;
            return item.net.ID;
        }             

        private List<ElectricBattery> getBatteries(BasePlayer player)
        {
            List<ElectricBattery> e_Bat = new List<ElectricBattery>();
            uint num = 0;
            for (int i = 2; i < 5; i++)
            {
                num = getMiniData(player, i);
                if (num != 0)
                {
                    e_Bat.Add(BaseNetworkable.serverEntities.Find(num) as ElectricBattery);
                }
            }
            return e_Bat;
        }

        private int getTotalPower(List<ElectricBattery> batteries)
        {
            if (batteries == null)
            {
                return 0;
            }
            int power = 0;
            foreach (var bat in batteries)
            {
                if (bat != null)
                {
                    power = power + (int)Math.Round(bat.rustWattSeconds / 60, 0);
                }
            }
            return power;
        }

        private void setTotalPower(BasePlayer player, int power)
        {
            List<ElectricBattery> batteries = getBatteries(player);
            for (int bat = (batteries.Count() - 1); bat > -1; bat--)
            {
                if (power >= 150)
                {
                    batteries[bat].rustWattSeconds = (float)(60.0 * 150);
                    power = power - 150;
                }
                else if (power > 0 && power < 150)
                {
                    batteries[bat].rustWattSeconds = (float)(60.0 * power);
                    power = 0;
                }
                else
                {
                    batteries[bat].rustWattSeconds = (float)(0.0 * power);
                }
                batteries[bat].SendNetworkUpdate();
                // chatMessage(player, "No_Args", ("Battery " + batteries[bat].net.ID.ToString() + "   " + (batteries[bat].rustWattSeconds/60.0).ToString()));
            }
            // return null;
        }

        private void setWireScheme(BasePlayer player)
        {
            bool first = true;
            uint j = 0;
            IOEntity prev = new IOEntity();
            for (int i = 1; i < 6; i++)
            {
                j = getMiniData(player, i);
                if (j != 0 && first)
                {
                    prev = BaseNetworkable.serverEntities.Find(j) as IOEntity;
                    first = false;
                }
                else if (j != 0)
                {
                    setWire(prev, 0, BaseNetworkable.serverEntities.Find(j) as IOEntity, 0);
                    prev = BaseNetworkable.serverEntities.Find(j) as IOEntity;
                }
            }
        }

        private void setWire(IOEntity output, int pin_O, IOEntity input, int pin_I)
        {
            if (output == null || input == null)
            {
                return;
            }
            input.inputs[pin_I].connectedTo.Set(output);
            output.outputs[pin_O].connectedTo.Set(input);

            input.inputs[pin_I].connectedToSlot = pin_O;
            output.outputs[pin_O].connectedToSlot = pin_I;

            input.inputs[pin_I].connectedTo.Init();
            output.outputs[pin_O].connectedTo.Init();

            output.MarkDirtyForceUpdateOutputs();

            output.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            input.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        private void disableWire(BasePlayer player)
        {
            uint j = 0;
            IOEntity item = new IOEntity();
            for (int i = 1; i < 6; i++)
            {
                j = getMiniData(player, i);
                if (j != 0)
                {
                    item = (BaseNetworkable.serverEntities.Find(j) as IOEntity);
                    if (item != null)
                    {
                        item.ClearConnections();
                    }
                }
            }
            setWireScheme(player);
        }

        private void disableGroundReq(BaseEntity entity)
        {
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private int getFuelAmount(BaseVehicle mini)
        {
            StorageContainer fuelTank = mini.GetFuelSystem().GetFuelContainer();
            Item slot = fuelTank.inventory.GetSlot(0);
            if (slot != null)
            {
                return slot.amount;
            }
            else
            {
                return 0;
            }
        }

        private void setFuelAmount(BaseVehicle mini, int amount)
        {
            if (mini == null)
            {
                return;
            }
            StorageContainer fuelTank = mini.GetFuelSystem().GetFuelContainer();
            Item slot = fuelTank.inventory.GetSlot(0);
            if (slot != null)
            {
                fuelTank.inventory.Remove(slot);
            }
            if (amount > 0)
            {
                ItemManager.CreateByItemID(-946369541, amount)?.MoveToContainer(fuelTank.inventory);
            }
        }

        private void lockFuelTank(StorageContainer fuelTank, bool state)
        {
            fuelTank.SetFlag(BaseEntity.Flags.Locked, state);
        }

        private void resetBatteriesDrain(BasePlayer player)
        {
            if (player==null) { return; }
            if (miniData.ownerMini.ContainsKey(player.userID))
            {
                uint[] nums = { getMiniData(player, 2), getMiniData(player, 3), getMiniData(player, 4) };
                for (int i = 0; i < nums.Length; i++)
                {
                    if (nums[i] != 0)
                    {
                        ElectricBattery bat = BaseNetworkable.serverEntities.Find(nums[i]) as ElectricBattery;
                        if (bat != null)
                        {
                            bat.maxOutput = (batteryMaxDrain - 5 * i);                             
                        }
                    }                    
                }
                 
            }
        }

        private void fixUpgradeMini(BasePlayer player)
        {
            OwnerMiniData data = miniData.ownerMini[player.userID];
            if (((BaseNetworkable.serverEntities.Find(getMiniData(player, 1)) as IOEntity) == null
                || (BaseNetworkable.serverEntities.Find(getMiniData(player, 2)) as IOEntity) == null
                || (BaseNetworkable.serverEntities.Find(getMiniData(player, 3)) as IOEntity) == null)
                && data.hasBatteries())
            {
                removeBatteriesMini(player);
                setMiniRotation(getMinicopter(player) as BaseVehicle);
                addBatteriesMini(player, getMinicopter(player) as BaseVehicle);
                chatMessage(player, "Attempt_FixMini", "Batteries");
            }
            if ((BaseNetworkable.serverEntities.Find(getMiniData(player, 4)) as IOEntity) == null
                && data.hasElectricEngine())
            {
                setMiniRotation(getMinicopter(player) as BaseVehicle);
                setFuelRate(getMinicopter(player), data.getFuelPerSec());
                removeElectricMini(player);                
                upgradeElectricMini(player, getMinicopter(player) as BaseVehicle);
                if (data.hasAutoTurret())
                {
                    setFuelRate(getMinicopter(player), 0.20f);
                }
                else
                {
                    setFuelRate(getMinicopter(player), 0.10f);
                }                
                chatMessage(player, "Attempt_FixMini", "Efuel");
            }
            if ((BaseNetworkable.serverEntities.Find(getMiniData(player, 5)) as IOEntity) == null
                && data.hasAutoTurret())
            {
                setMiniRotation(getMinicopter(player) as BaseVehicle);
                removeTurretMini(player);
                setMiniData(player, addTurretMini(getMinicopter(player) as BaseVehicle), 5);
                setWireScheme(player);
                setTurretRange(player, 50);
                chatMessage(player, "Attempt_FixMini", "Turret");
            }
        }
        #endregion

        #region Classes
        private class MiniData
        {
            public Dictionary<ulong, OwnerMiniData> ownerMini = new Dictionary<ulong, OwnerMiniData>();
            public Dictionary<ulong, string> errorLog = new Dictionary<ulong, string>();
        }
    
        [Serializable]
        private class OwnerMiniData
        {
            #region class variables
            [JsonProperty]
            private uint miniEntityID = 0;

            [JsonProperty]
            private DateTime manufactureData = new DateTime();

            [JsonProperty]
            private uint batteryLeftID = 0;

            [JsonProperty]
            private uint batteryRightID = 0;

            [JsonProperty]
            private uint batteryEngineID = 0;

            [JsonProperty]
            private uint branchID = 0;

            [JsonProperty]
            private uint autoTurretID = 0;

            [JsonProperty]
            private float fuelPerSec = 0.25f;

            [JsonProperty]
            private List<string> authPilots = new List<string>();
            #endregion

            #region Get Variables Functions
            public uint getMiniEntityID()  { return miniEntityID; }
            public DateTime getManufactureData() { return manufactureData;  }
            public uint getBranchID() { return branchID; }
            public uint getBatteryLeftID() { return batteryLeftID; }
            public uint getBatteryRightID() { return batteryRightID; }
            public uint getBatteryEngineID() { return batteryEngineID; }            
            public uint getAutoTurretID() { return autoTurretID; }
            public float getFuelPerSec() { return fuelPerSec; }
            public List<string> getAuthPilots() { return authPilots; }
            #endregion

            #region Set Variables Functions
            public void setMiniEntityID(uint entityID) { miniEntityID = entityID; }
            public void setManufactureData(DateTime data) { manufactureData = data; }
            public void setBranchID(uint entityID) { branchID = entityID; }
            public void setBatteryLeftID(uint entityID) { batteryLeftID = entityID; }
            public void setBatteryRightID(uint entityID) { batteryRightID = entityID; }
            public void setBatteryEngineID(uint entityID) { batteryEngineID = entityID; }            
            public void setAutoTurretID(uint entityID) { autoTurretID = entityID; }
            public void setFuelPerSec(float rate) { fuelPerSec = rate; }
            public void setAuthPilots(List<string> pilots) { authPilots = pilots; }
            #endregion

            #region check if player has <blank>
            public bool hasMiniCopter() { return (miniEntityID != 0); }
            public bool hasBatteries() { return (batteryLeftID != 0 && batteryRightID != 0); }
            public bool hasElectricEngine() { return (batteryEngineID != 0); }
            public bool hasAutoTurret() { return (autoTurretID != 0); }
            #endregion
        }

        private class ConfigFile
        {
            [JsonProperty("miniSpawnDistance")]
            public float miniSpawnDistance { get; set; }

            [JsonProperty("miniStartHealth")]
            public float miniStartHealth { get; set; }

            [JsonProperty("AssetPrefab")]
            public string assetPrefab { get; set; }

            [JsonProperty("CanSpawnBuildingBlocked")]
            public bool canSpawnBuildingBlocked { get; set; }

            [JsonProperty("WaitTimes")]
            public Dictionary<string, float> waitTimes { get; set; }

            [JsonProperty("FuelRate")]
            public float fuelPerSec { get; set; }

            [JsonProperty("FuelRateUnlimited")]
            public float fuelPerSecUnlimited { get; set; }

            [JsonProperty("FuelAmountUnlimited")]
            public int fuelAmountUnlimited { get; set; }            
        }

        private ConfigFile GetDefaults()
        {
            return new ConfigFile
            {
                miniSpawnDistance = 5f,
                miniStartHealth = 750f,
                assetPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                canSpawnBuildingBlocked = false,
                waitTimes = new Dictionary<string, float>()
                {
                    ["ManageMini.noWT"] = 10f,
                    ["ManageMini.WaitTime2"] = 21600f,
                    ["ManageMini.WaitTime1"] = 43200f,
                    ["ManageMini.defaultWT"] = 86400f
                },
                fuelPerSec = 0.25f,
                fuelPerSecUnlimited = 0.0001f,
                fuelAmountUnlimited = 100
            };
        }
        #endregion

        #region Overides
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaults(), true);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PermissionCheck_failed"] = "Sorry, but you aren't authorized to use this command.  See admin!",
                ["Mini_WaitList"] = "{0}, you have to wait another {1} minutes before you can use that command!",
                ["Unauth_PilotAttempt"] = "{0}, you are forbidden from piloting {1}'s mini. Request authorization from them!",
                ["Owner_AlertMini"] = "{0} attempted to pilot your mini without authorization!",
                ["Mini_DestroyedNow"] = "Your minicopter has been destroyed.  Better luck next time!",
                ["Make_Mini"] = "{0}, here's your minicopter!",
                ["Take_Mini"] = "Your mini has been taken back!",
                ["Get_Mini"] = "Your mini has been teleported to you!",
                ["Took_OwnershipMini"] = "You are now the owner of this mini!",
                ["FailedTake_OwnershipMini"] = "This mini is already owned by {0}!",
                ["Player_NotSeatedMini"] = "Please sit in one of the seats of a Minicopter.",
                ["Auth_Pilot"] = "You have authorized {0} to pilot your mini",
                ["Unauth_Pilot"] = "{0} authorization has been revoked!",
                ["Auth_PilotHeader"] = "Authorized Pilots: ",
                ["Auth_Pilots"] = "{0} can pilot your mini!",
                ["mini_NotFound"] = "I am sorry {0}, I don't think you have created a mini yet! /makeMini",
                ["Already_CreatedMini"] = "You already own a mini.",
                ["No_Args"] = "{0}",
                ["No_PlayerFound"] = "{0} is not an active player on this server.",
                ["No_FuelRate"] = "Your minicopter will never need to stop at the fuel station!",
                ["Mini_FuelRate"] = "Your mini uses {0} low grade per sec.",
                ["MiniCopter_AgeDHMS"] = "Your mini is {0} days {1} hours {2} minutes {3} seconds old.",
                ["Upgrade_Mini"] = "{0}, as you've requested, your minicopter has been upgraded!",
                ["Batteries_NotIncluded"] = "{0}, you must add batteries first",
                ["ManageMini_Help"] = "ManageMini Help",
                ["/miniHelp"] = "  <-- displays this help",
                ["/makeMini"] = "  <-- server creates and spawns a minicopter near player",
                ["/takeMini"] = "  <-- server takes back the minicopter",
                ["/getMini"] = "   <-- transfers the minicopter to you",
                ["/ownMini"] = "   <-- Attempts to take Ownership of a mini",
                ["/authPilot"] = "  <playerName>    <-- Authorizes player to pilot",
                ["/unauthPilot"] = "  <playerName>   <-- revokes player authorization",
                ["/miniDetails"] = "   <-- displays Authorized Pilots, Fuel Rate, Age",
                ["/upgrademini"] = "  <-- Add batteries, convert engine to electric, turret to front, ....",
                ["Attempt_FixMini"] = "{0} Not Found, attempting to fix!",
                ["Error_ManageMini"] = "ManageMini has failed due to an unknown error! Has been logged in the data file"
            }, this, "en");
        }
        #endregion

    }
}
 

// --- End of file: ManageMini.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/max-cupboard-auths ---
// --- Original File Path: M/MaxCupboardAuths/MaxCupboardAuths.cs ---

using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;

#region Changelogs and ToDo
/**********************************************************************
*   2.0.0   :   Complete rewrite to have a better functionality
*               - Removed Chatcommands
*               - New permissions
*               - Restricions now only on each Toolcupboard
*               - No more datafile system
*               - Builded in the checker for TC with independant auths
*               - Added the restrictions for total auths
*   2.0.1   :   - Added extra bypas checks (thx @Yzarul)
*               
**********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("MaxCupboardAuths", "Krungh Crow", "2.0.1")]
    [Description("Limit cupboard max authing")]

    class MaxCupboardAuths : RustPlugin
    {
        #region Variables

        bool debug = false;

        const ulong chaticon = 0;
        const string prefix = "<color=yellow>[M.C.A.]</color> ";

        const string Max_Perm = "maxcupboardauths.restrict";            //  Restricts authing limit for every tc
        const string MaxTC_Perm = "maxcupboardauths.tcrestrict";        //  Restricts players personal max authing limit
        const string MaxTCDef_Perm = "maxcupboardauths.tcdefault";      //  Default perm max TC to auth on
        const string MaxTCVip_Perm = "maxcupboardauths.tcvip";          //  Vip perm max TC to auth on
        const string Bypass_Perm = "maxcupboardauths.bypass";           //  Perm to bypass restrictions

        #endregion

        #region Configuration
        void Init()
        {
            if (!LoadConfigVariables())
            {
            Puts("Config file issue detected. Please delete file, or check syntax and fix.");
            return;
            }
            if (configData.UseDebug)
            {
                debug = true;
            }
            permission.RegisterPermission(Max_Perm, this);
            permission.RegisterPermission(MaxTC_Perm, this);
            permission.RegisterPermission(Bypass_Perm, this);
            permission.RegisterPermission(MaxTCDef_Perm, this);
            permission.RegisterPermission(MaxTCVip_Perm, this);
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Put Debug to console")]
            public bool UseDebug = false;
            [JsonProperty(PropertyName = "Settings ToolCupboard")]
            public SettingsTCAuth TCAuths = new SettingsTCAuth();
            [JsonProperty(PropertyName = "Settings Players")]
            public SettingsPlayerAuth PlayerAuths = new SettingsPlayerAuth();
        }

        class SettingsTCAuth
        {
            [JsonProperty(PropertyName = "Max total Auths for each TC")]
            public int MaxTCAuth = 2;
        }

        class SettingsPlayerAuth
        {
            [JsonProperty(PropertyName = "Max Auths for default Player")]
            public int MaxAuth = 2;
            [JsonProperty(PropertyName = "Max Auths for vip Player")]
            public int MaxAuthVip = 3;
        }

        private bool LoadConfigVariables()
        {
            try
            {
            configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
            return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Denied"] = "You cannot authorise to this cupboard! there are already the maximum amount of people authed to it!",
                ["DeniedPlayer"] = "You reached your personal Tc auth limit",
                ["DeniedPlacement"] = "You cannot place a tc u have reached your limit of Toolcupboards to auth to!",
            }, this);
        }

        #endregion

        #region Methods
        // Added to avoid players placing the tc when allready on max auths (global)
        void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject)
        {
            if (entity.ShortPrefabName.Contains("cupboard.tool"))
            {
                if (entity.OwnerID == null) return;
                BasePlayer player = BasePlayer.FindByID(entity.OwnerID);
                if (debug) Puts($"{player} placed a Toolcupboard");
                if (player == null) return;
                if (player.IsSleeping() == true || player.IsConnected == false) return;
                if (debug) Puts($"sleep|offline check");

                if (permission.UserHasPermission(player.UserIDString, Bypass_Perm))
                {
                    if (debug) Puts($"{player} has bypass privilege and placed a cupboard");
                    return;
                }

                if (permission.UserHasPermission(player.UserIDString, MaxTCVip_Perm))
                {
                    if (TCcount(player) >= configData.PlayerAuths.MaxAuthVip)
                    {
                        Player.Message(player, prefix + string.Format(msg($"DeniedPlacement", player.UserIDString)), chaticon);

                        NextTick(() =>
                        {
                            entity.Kill();
                            var itemtogive = ItemManager.CreateByItemID(-97956382, 1);
                            if (itemtogive != null) player.inventory.GiveItem(itemtogive);
                            entity.SendNetworkUpdate();
                        });
                    }
                }
                else if (permission.UserHasPermission(player.UserIDString, MaxTCDef_Perm))
                {
                    if (TCcount(player) >= configData.PlayerAuths.MaxAuth)
                    {
                        Player.Message(player, prefix + string.Format(msg($"DeniedPlacement", player.UserIDString)), chaticon);

                        NextTick(() =>
                        {
                            entity.Kill();
                            var itemtogive = ItemManager.CreateByItemID(-97956382, 1);
                            if (itemtogive != null) player.inventory.GiveItem(itemtogive);
                            entity.SendNetworkUpdate();
                        });
                    }
                }
            }
            return;
        }

        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            // Restricts authing limit for players personal limits
            if (permission.UserHasPermission(player.UserIDString, Bypass_Perm))
            {
                if (debug) Puts($"{player} has bypass privilege and authed on a cupboard");
                return null;
            }

            if (permission.UserHasPermission(player.UserIDString, MaxTC_Perm))
            {
                if (permission.UserHasPermission(player.UserIDString, MaxTCVip_Perm))
                {
                    if (TCcount(player) >= configData.PlayerAuths.MaxAuthVip)
                    {
                        //int maxauth = configData.PlayerAuths.MaxAuthVip;
                        Player.Message(player, prefix + string.Format(msg($"DeniedPlayer", player.UserIDString)), chaticon);

                        if (debug) Puts($"{player} has allready authed to {TCcount(player)} cupboard(s) and authing was denied");
                        return true;
                    }
                }

                else if (permission.UserHasPermission(player.UserIDString, MaxTCDef_Perm))
                {
                    if (TCcount(player) >= configData.PlayerAuths.MaxAuth)
                    {
                        //int maxauth = configData.PlayerAuths.MaxAuth;
                        Player.Message(player, prefix + string.Format(msg($"DeniedPlayer", player.UserIDString)), chaticon);

                        if (debug) Puts($"{player} has allready authed to {TCcount(player)} cupboard(s) and authing was denied");
                        return true;
                    }
                }
            }

            // Restricts authing limits for each TC
            if (permission.UserHasPermission(player.UserIDString, Max_Perm))
            {
                if (privilege.authorizedPlayers.Count >= configData.TCAuths.MaxTCAuth)
                {
                    Player.Message(player, prefix + string.Format(msg("Denied", player.UserIDString)), chaticon);

                    if (debug)
                    {
                        int Maxauth = configData.TCAuths.MaxTCAuth;
                        Puts($"{player} was denied authing on a cupboard since its limit of {Maxauth} was reached!");
                    }
                    return true;
                }

                if (debug) Puts($"{player} was allowed to auth");
                return null;
            }
                if (debug) Puts($"{player} has no auth restrictions and authed on {TCcount(player)} cupboard(s)");
            return null;
        }

        private int TCcount(BasePlayer player)
        {
            List<BaseEntity> playercups = new List<BaseEntity>();
            int count = 0;
            foreach (var entity in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
            {
                if (entity.ShortPrefabName.Contains("cupboard.tool"))
                {
                    var cupboard = entity.gameObject.GetComponentInParent<BuildingPrivlidge>();
                    foreach (ProtoBuf.PlayerNameID playerNameOrID in cupboard.authorizedPlayers)
                    if (player) playercups.Add(entity);
                }
            }
            if (playercups != null)
            {
                count = playercups.Count();
            }
            return count;
        }
        #endregion

        #region msg helper

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        #endregion
    }
}

// --- End of file: MaxCupboardAuths.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-radiation-panel ---
// --- Original File Path: M/MagicRadiationPanel/MagicRadiationPanel.cs ---

﻿using System;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Radiation Panel", "MJSU", "1.0.3")]
    [Description("Displays if a player is in a radiation zone")]
    public class MagicRadiationPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

       protected override void LoadConfig()
       {
           string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
           DynamicConfigFile newConfig = new DynamicConfigFile(path);
           if (!newConfig.Exists())
           {
               LoadDefaultConfig();
               newConfig.Save();
           }
           try
           {
               newConfig.Load();
           }
           catch (Exception ex)
           {
               RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
               return;
           }
           
           newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
           _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
           newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/0yRsQnWF/owVdFsK.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 7,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region Radiation Zone Hooks
        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            TriggerRadiation rad = trigger as TriggerRadiation;
            BasePlayer player = entity as BasePlayer;

            if (rad == null || player == null || entity.IsNpc)
            {
                return;
            }

            NextTick(() =>
            {
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Image);
            });
        }

        private void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        {
            TriggerRadiation rad = trigger as TriggerRadiation;
            BasePlayer player = entity as BasePlayer;

            if (rad == null || player == null || player.IsDead() || entity.IsNpc)
            {
                return;
            }

            NextTick(() =>
            {
                if (!player.triggers?.OfType<TriggerRadiation>().Any() ?? true)
                {
                    MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Image);
                }
            });
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = player.FindTrigger<TriggerRadiation>() != null ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#FFFF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicRadiationPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-joining-panel ---
// --- Original File Path: M/MagicJoiningPanel/MagicJoiningPanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Joining Panel", "MJSU", "1.0.3")]
    [Description("Displays joining player count in magic panel")]
    public class MagicJoiningPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private int _joiningCount;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/PfYphfzB/l0kKN4c.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.05f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .67f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "lefttop",
                Order = config.PanelSettings?.Order ?? 4,
                Width = config.PanelSettings?.Width ?? 0.045f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _joiningCount = ServerMgr.Instance.connectionQueue.Joining;
            MagicPanelRegisterPanels();

            timer.Every(_pluginConfig.UpdateRate, () =>
            {
                int joining = ServerMgr.Instance.connectionQueue.Joining;
                if (joining != _joiningCount)
                {
                    _joiningCount = joining;
                    UpdatePanel();
                }
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            UpdatePanel();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            UpdatePanel();
        }

        private void UpdatePanel()
        {
            NextTick(() =>
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
            });
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, ServerMgr.Instance.connectionQueue.Joining);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
            
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rates (Seconds)")]
            public float UpdateRate { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicJoiningPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-images-panel ---
// --- Original File Path: M/MagicImagesPanel/MagicImagesPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Images Panel", "MJSU", "1.0.3")]
    [Description("Displays images in Magic Panel")]
    public class MagicImagesPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panels = config.Panels ?? new Hash<string, PanelData>
            {
                [$"{Name}_1"] = new PanelData
                {
                    Panel = new Panel
                    {
                        Image = new PanelImage
                        {
                            Enabled = true,
                            Color = "#FFFFFFFF",
                            Order = 0,
                            Width = 1f,
                            Url = "https://i.postimg.cc/RZsqGW4n/FnVe2Fl.png",
                            Padding = new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                        }
                    },
                    PanelSettings = new PanelRegistration
                    {
                        BackgroundColor = "#FFF2DF00",
                        Dock = "image",
                        Order = 0,
                        Width = 0.09f
                    },
                    Enabled = true
                },
                [$"{Name}_2"] = new PanelData
                {
                    Panel = new Panel
                    {
                        Image = new PanelImage
                        {
                            Enabled = true,
                            Color = "#FFFFFFFF",
                            Order = 0,
                            Width = 1f,
                            Url = "https://i.postimg.cc/RZsqGW4n/FnVe2Fl.png",
                            Padding = new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                        }
                    },
                    PanelSettings = new PanelRegistration
                    {
                        BackgroundColor = "#FFF2DF00",
                        Dock = "image",
                        Order = 0,
                        Width = 0.09f
                    },
                    Enabled = true
                }
            };
            
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            foreach (KeyValuePair<string,PanelData> panel in _pluginConfig.Panels)
            {
                if (!panel.Value.Enabled)
                {
                    continue;
                }
                
                MagicPanel?.Call("RegisterGlobalPanel", this, panel.Key, JsonConvert.SerializeObject(panel.Value.PanelSettings), nameof(GetPanel));
            }
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel(string panelName)
        {
            Panel panel = _pluginConfig.Panels[panelName].Panel;
            return panel.ToHash();
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Image Panels")]
            public Hash<string, PanelData> Panels { get; set; }
        }

        private class PanelData
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicImagesPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-player-settings ---
// --- Original File Path: M/MonumentPlayerSettings/MonumentPlayerSettings.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Monument Player Settings", "YaMang-w-", "1.0.3")]
    [Description("Block certain actions, commands, etc. within the monument. (to teleport)")]
    class MonumentPlayerSettings : RustPlugin
    {
        #region Fleids
        [PluginReference] private Plugin NoEscape;
        private const string OutPostPrefab = "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab";
        private const string BanditTownPrefab = "assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab";
        private const string MainUI = "MonumentContainer";
        private const string UsePermission = "monumentplayersettings.use";
        Dictionary<string, Timer> teleportTimer = new Dictionary<string, Timer>();
        Dictionary<string, Vector3> monumentLists = new Dictionary<string, Vector3>();

        #endregion

        #region Hook

        void OnServerInitialized()
        {
            permission.RegisterPermission(UsePermission, this);

            if (_config.tpMonumentSetting.useBandit || _config.tpMonumentSetting.useOutPost) cmd.AddChatCommand(_config.generalSettings.Commands, this, nameof(MonumentTPCMD));

            if (!_config.monumentSetting.blockInMSpray) Unsubscribe(nameof(OnSprayCreate));

            if (!_config.monumentSetting.blockInMPickup) Unsubscribe(nameof(CanPickupEntity));

            if (_config.monumentSetting.blockInMCommands.Count == 0) Unsubscribe(nameof(OnPlayerCommand));

            if (_config.monumentSetting.blockInMActiveItems.Count == 0) Unsubscribe(nameof(OnActiveItemChanged));

            var outpost = FindMonumentPosition(OutPostPrefab);
            if (outpost == new Vector3()) return;
            monumentLists.Add("outpost", outpost);
            
            var bandit = FindMonumentPosition(BanditTownPrefab);
            if (bandit == new Vector3()) return;
            monumentLists.Add("bandit", bandit);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, MainUI);
            }
        }

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null) return;


            bool find = InMonumentPosition(player);
            if (find)
            {
                var held = player.GetHeldEntity();
                if (held == null) return;
                var item = held.GetItem() ?? null;

                if (!_config.monumentSetting.blockInMActiveItems.Contains(item.info.shortname)) return;
                held.SetHeld(false);
                held.SendNetworkUpdate();
                player.SendNetworkUpdate();
                Messages(player, Lang("ActiveItemsCannot", item.name ?? item.info.displayName.english));
            }
        }

        object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (!_config.monumentSetting.blockInMCommands.Contains(command)) return null;

            bool find = InMonumentPosition(player);
            if (find)
            {
                Messages(player, Lang("CommandsCannot", command));
                return true;
            }

            return null;
        }


        bool CanPickupEntity(BasePlayer player, BaseEntity entity)
        {
            bool find = InMonumentPosition(player);
            if (find)
            {
                Messages(player, Lang("PickupCannot"));
                return false;
            }

            return true;
        }

        private object OnSprayCreate(SprayCan spray, Vector3 position, Quaternion rotation)
        {
            BasePlayer player = spray.GetOwnerPlayer();

            bool find = InMonumentPosition(player);
            if (find)
            {
                Messages(player, Lang("SparayCannot"));
                return false;
            }

            return null;
        }
        #endregion

        #region Commands
        private void MonumentTPCMD(BasePlayer player, string command, string[] args)
        {
            if(!permission.UserHasPermission(player.UserIDString, UsePermission))
            {
                Messages(player, Lang("NoPerm"));
                return;
            }
            MonumentTeleportUI(player);    
        }

        [ConsoleCommand("teleport.monument")]
        private void MonumentTeleport(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;

            if (arg.Args[0] != "close" && arg.Args[0] != "cancel")
            {
                var err = SetFlags(player);
                if (err != null)
                {
                    Messages(player, $"{err}");
                    return;
                }
            }

            Vector3 pos = new Vector3();
            switch (arg.Args[0])
            {
                case "outpost":
                    if (teleportTimer.ContainsKey(player.UserIDString))
                    {
                        Messages(player, Lang("CancelTp"));
                        return;
                    }
                    pos = monumentLists["outpost"];
                    Messages(player, Lang("TryTp", Lang("Outpost"), _config.tpMonumentSetting.cooltimeOutPost));
                    var OutpostTimer = timer.Once(_config.tpMonumentSetting.cooltimeOutPost, () =>
                    {
                        TeleportPlayer(player, pos, Lang("Outpost"));
                    });
                    teleportTimer.Add(player.UserIDString, OutpostTimer);

                    CuiHelper.DestroyUi(player, MainUI);
                    break;

                case "bandit":
                    if (teleportTimer.ContainsKey(player.UserIDString))
                    {
                        Messages(player, Lang("CancelTp"));
                        return;
                    }
                    pos = monumentLists["bandit"];
                    Messages(player, Lang("TryTp", Lang("Bandit"), _config.tpMonumentSetting.cooltimeBandit));
                    var Bandittimer = timer.Once(_config.tpMonumentSetting.cooltimeBandit, () =>
                    {
                        TeleportPlayer(player, pos, Lang("Bandit"));
                    });
                    teleportTimer.Add(player.UserIDString, Bandittimer);

                    CuiHelper.DestroyUi(player, MainUI);
                    break;
                    
                case "close":
                    CuiHelper.DestroyUi(player, MainUI);
                    break;
                case "cancel":
                    if (teleportTimer.ContainsKey(player.UserIDString))
                    {
                        Messages(player, Lang("CancelTp"));
                        teleportTimer[player.UserIDString].Destroy();
                        teleportTimer.Remove(player.UserIDString);
                    }
                    else
                    {
                        Messages(player, "There is nothing to cancel.");
                        CuiHelper.DestroyUi(player, MainUI);
                    }
                    break;
            }
        }
        #endregion

        #region Config
        private ConfigData _config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "General Settings")] public GeneralSettings generalSettings { get; set; }
            [JsonProperty(PropertyName = "Teleport Settings")] public TPMonumentSetting tpMonumentSetting { get; set; }
            [JsonProperty(PropertyName = "Monument Settings")] public MonumentSetting monumentSetting { get; set; }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
        public class GeneralSettings
        {
            [JsonProperty(PropertyName = "Prefix", Order = 1)] public string Prefix { get; set; }
            [JsonProperty(PropertyName = "SteamID", Order = 2)] public ulong SteamID { get; set; }
            [JsonProperty(PropertyName = "Commands", Order = 3)] public string Commands { get; set; }
        }

        public class TPMonumentSetting
        {
            [JsonProperty(PropertyName = "Use teleport Outpost?")] public bool useOutPost { get; set; }
            [JsonProperty(PropertyName = "teleport cooltime Outpost")] public float cooltimeOutPost { get; set; }
            [JsonProperty(PropertyName = "Use teleport Bandit?")] public bool useBandit { get; set; }
            [JsonProperty(PropertyName = "teleport cooltime Bandit")] public float cooltimeBandit { get; set; }
        }

        public class MonumentSetting
        {
            [JsonProperty(PropertyName = "Block commands in monuments")] public List<string> blockInMCommands { get; set; }
            [JsonProperty(PropertyName = "Block Spary in monuments")] public bool blockInMSpray { get; set; }
            [JsonProperty(PropertyName = "Block Active Item in monuments")] public List<string> blockInMActiveItems { get; set; }
            [JsonProperty(PropertyName = "Block Pickup in monuments")] public bool blockInMPickup { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config == null) throw new Exception();
                Puts($"{_config.Version} | {Version}");

                if (_config.Version < Version)
                    UpdateConfigValues();
            }
            catch
            {
                Config.WriteObject(_config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}_BackupError.json");
                PrintError("An error occurred in the config\nFind the CommandsItem_BackupError file.");
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                generalSettings = new GeneralSettings
                {
                    Prefix = "<color=#5892bf>[Monument-Settings]</color>\n",
                    SteamID = 0,
                    Commands = "mtp",
                },
                tpMonumentSetting = new TPMonumentSetting
                {
                    useBandit = true,
                    cooltimeBandit = 15f,
                    useOutPost = true,
                    cooltimeOutPost = 15f
                },
                monumentSetting = new MonumentSetting
                {
                    blockInMSpray = true,
                    blockInMPickup = true,
                    blockInMActiveItems = new List<string>
                    {
                        "fun.trumpet"
                    },
                    blockInMCommands = new List<string>
                    {
                        "remove"
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");
            Config.WriteObject(_config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}_{_config.Version}.json");
            _config.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "SparayCannot", "<color=#red>Spray cannot be use here.</color>" },
                { "CommandsCannot", "<color=red>{0} cannot be use here.</color>" },
                { "PickupCannot", "<color=red>cannot be pickup here.</color>" },
                { "ActiveItemsCannot", "<color=red>{0} cannot be held here.</color>" },
                { "TryTp", "<color=#d0d0d0>Teleport to {0} after {1} seconds</color>" },
                { "CompleteTp", "<color=#d0d0d0>{0} Teleport!</color>" },
                { "PlayerInFlagsTp", "<color=#d0d0d0>{0} Teleporting Canceled | Reason: {1}!</color>" },
                { "CancelTp", "<color=yellow>Canceled Teleport</color>" },
                { "AlreadyTp", "<color=yellow>Already Teleporting / cancel press</color>" },
                { "Outpost", "Outpost"},
                { "Bandit", "Bandit Camp" },
                { "NoPerm", "<color=red>You have not permission</color>" }
            }, this);
        }

        private string Lang(string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this), args);
        }

        #endregion

        #region Helper
        private void Messages(BasePlayer player, string text) => player.SendConsoleCommand("chat.add", 2, _config.generalSettings.SteamID, $"{_config.generalSettings.Prefix} {text}");
        private string SetFlags(BasePlayer player)
        {
            if (player.isMounted)
            {
                return "mounted";
            }
            if (player.IsWounded())
            {
                return "Wounded";
            }
            if (player.IsSwimming())
            {
                return "Swimming";
            }
            if (Convert.ToBoolean(NoEscape?.Call("IsBlocked", player)))
            {
                return "Raid or Combat Blocked";
            }
            if (player.IsDead())
            {
                return "Dead";
            }
            if (player.IsHostile())
            {
                return "It's impossible because you're hostile";
            }
            if (player.IsBuildingBlocked())
            {
                return "Your in a building blocked";
            }
            return null;
        }
        private bool CheckFlags(BasePlayer player)
        {
            if (SetFlags(player) != null)
                return false;
            else
                return true;
        }

        private bool InMonumentPosition(BasePlayer player)
        {
            bool find = false;

            foreach (var item in TerrainMeta.Path.Monuments)
            {

                if (item.name.ToLower() == BanditTownPrefab)
                {
                    find = item.IsInBounds(player.transform.position);
                    if (find)
                        break;
                    else
                        continue;
                }

                if (item.name.ToLower() == OutPostPrefab)
                {
                    find = item.IsInBounds(player.transform.position);
                    if (find)
                        break;
                    else
                        continue;
                }


            }
            return find;
        }

        private Vector3 FindMonumentPosition(string monumentPrefab)
        {

            var monumentPosition = TerrainMeta.Path.Monuments
            .Where(m => m.name.ToLower() == monumentPrefab)
            .FirstOrDefault()?
            .transform
            .position;

            if (null == monumentPosition)
                Puts($"Failed to find a location for Monument: {monumentPrefab}");

            return monumentPosition ?? new Vector3();
        }
        private bool TeleportPlayer(BasePlayer player, Vector3 pos, string text)
        {
            var err = SetFlags(player);
            if (err != null)
            {
                if (teleportTimer.ContainsKey(player.UserIDString))
                {
                    Messages(player, Lang("PlayerInFlagsTp", text, err));
                    teleportTimer[player.UserIDString].Destroy();
                    teleportTimer.Remove(player.UserIDString);
                }
                return false;
            }

            RaycastHit hit;
            if (!Physics.Raycast(new Ray(pos + Vector3.up * 10, Vector3.down), out hit))
            {
                Messages(player, "[ERROR] - Monument not found");
                return false;
            }

            pos = hit.point;
            if (teleportTimer.ContainsKey(player.UserIDString))
            {
                player.Teleport(pos);
                
                teleportTimer[player.UserIDString].Destroy();
                teleportTimer.Remove(player.UserIDString);
            }

            return true;
        }
        private static string HexToCuiColor(string HEX, float Alpha = 100)
        {
            if (string.IsNullOrEmpty(HEX)) HEX = "#FFFFFF";

            var str = HEX.Trim('#');
            if (str.Length != 6) throw new Exception(HEX);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {Alpha / 100f}";
        }
        #endregion

        #region UI
        private void MonumentTeleportUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, MainUI);

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0 0 0 0.3529412", },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-150 -69.992", OffsetMax = "150 70.008" }
            }, "Overlay", MainUI);

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0.1607843 0.6705883 0.5294118 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-150 39.847", OffsetMax = "150 69.847" }
            }, MainUI, "TitlePanel");

            container.Add(new CuiButton
            {
                Button = { Color = "0.41 0.101 0.67 1", Command = "teleport.monument cancel" },
                Text = { Text = "<b>Cancel</b>", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "74.174 -15.154", OffsetMax = "121.038 15.153" }
            }, "TitlePanel", "CancelBtn");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.87", Command = "teleport.monument close" },
                Text = { Text = "<b>X</b>", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "121.037 -15.154", OffsetMax = "150.004 15.153" }
            }, "TitlePanel", "CloseBtn");

            container.Add(new CuiElement
            {
                Name = "Title_Text",
                Parent = "TitlePanel",
                Components = {
                    new CuiTextComponent { Text = $"<b>Monument Teleport - [ {(CheckFlags(player) ? "<b><color=#00ff00>Available</color></b>" : "<b><color=red>Impossible</color></b>")} ]</b>", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-144.735 -10.861", OffsetMax = "74.172 10.861" }
                }
            });
            if(_config.tpMonumentSetting.useBandit)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0.87", Command = "teleport.monument bandit" },
                    Text = { Text = $"<b>Bandit Camp\n\n\n[ {_config.tpMonumentSetting.cooltimeBandit}s ]</b>", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 2 },

                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-150 -70.002", OffsetMax = "0 39.848" }
                }, MainUI, "BanditBtn");
            }
            else
            {
                if (_config.tpMonumentSetting.useOutPost)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0.87", Command = "teleport.monument outpost" },
                        Text = { Text = $"<b>Outpost\n\n\n[ {_config.tpMonumentSetting.cooltimeBandit}s ]</b>", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 2 },

                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-150 -70.002", OffsetMax = "0 39.848" }
                    }, MainUI, "OutpostBtn");
                    return;
                }
            }
            

            if(_config.tpMonumentSetting.useOutPost)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0.87", Command = "teleport.monument outpost" },
                    Text = { Text = $"<b>Outpost\n\n\n[ {_config.tpMonumentSetting.cooltimeBandit}s ]</b>", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 2 },

                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -70.002", OffsetMax = "150 39.848" }
                }, MainUI, "OutpostBtn");
            }
            

            
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}


// --- End of file: MonumentPlayerSettings.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-map-name ---
// --- Original File Path: M/MapNameChanger/MapNameChanger.cs ---

using System;
using System.Runtime.InteropServices;
using Newtonsoft.Json;
using Steamworks;

namespace Oxide.Plugins
{
    [Info("Custom Map Name", "Ryz0r", "1.0.2")]
    [Description("Allows you to edit the Custom Map Name field without using a custom map.")]
    public class CustomMapName : RustPlugin
    {
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();
        private string _cachedMapName;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Map Name Displayed")]
            public string MapNameDisplayed = "Your Map Name";

            [JsonProperty(PropertyName = "Cycle Map Names")]
            public bool CycleMapNames = false;

            [JsonProperty(PropertyName = "Map Names to Cycle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] MapNamesToCycle = {"Map Name 1", "Welcome To Our Server", "Map Name 2"};

            [JsonProperty(PropertyName = "Name Refresh Interval")]
            public float NameRefreshInterval = 5.0f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        private void Init()
        {
            timer.Every(_config.NameRefreshInterval, () =>
            {
                var nameToSet = "";
                if (_config.CycleMapNames)
                {
                    if (NoNames())
                    {
                        PrintError("Cycle Map Names is turned on, but no map names to cycle");
                        return;
                    }
                    
                    var currName = SteamServer.MapName;
                    var newName = _config.MapNamesToCycle[new Random().Next(0, _config.MapNamesToCycle.Length)];
                    if (newName == currName) newName = _config.MapNamesToCycle[new Random().Next(0, _config.MapNamesToCycle.Length)];

                    nameToSet = newName;
                }
                else
                {
                    nameToSet = _config.MapNameDisplayed;
                }

                if (ContainsOfficial(nameToSet))
                {
                    PrintError("Using the word official in your map name can get you blacklisted. We can not allow this to happen.");
                    return;
                }

                if (TooShort(nameToSet))
                {
                    PrintError("Requested map name to be displayed should be at least 1 character long.");
                    return;
                }

                _cachedMapName = nameToSet;
            });
        }

        private void OnServerInformationUpdated()
        {
            if(string.IsNullOrEmpty(_cachedMapName)) return;
            SteamServer.MapName = _cachedMapName;
        }

        private static bool ContainsOfficial(string name) => name.ToLower().Contains("official");
        private static bool TooShort(string name) => name.Length < 1;
        private bool NoNames() => _config.MapNamesToCycle.Length < 1;
    }
}

// --- End of file: MapNameChanger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-npc ---
// --- Original File Path: M/MyNPC/MyNPC.cs ---

using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Rust;

namespace Oxide.Plugins
{
    [Info("My NPC", "Lincoln", "1.1.0")]
    [Description("Spawn your own player NPCs and access their inventories!")]

    class MyNPC : RustPlugin
    {
        #region Variables
        private readonly Hash<string, float> cooldowns = new Hash<string, float>();
        float cooldownTime;
        private const string npcEntity = "assets/rust.ai/agents/npcplayer/npcplayertest.prefab";
        Dictionary<string, ulong> npcList = new Dictionary<string, ulong>();
        private static NPCPlayer baseNPC;
        private const string permUse = "mynpc.use";
        private const string permBypassCooldown = "mynpc.bypasscooldown";
        private const string permMultipleNPC = "mynpc.multiplenpc";
        #endregion

        #region Functions
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permBypassCooldown, this);
            permission.RegisterPermission(permMultipleNPC, this);
            config = Config.ReadObject<PluginConfig>();
            foreach (var npc in BaseNetworkable.serverEntities.OfType<NPCPlayer>().ToArray())
            {
                if (npc == null) continue;
                if (npc.OwnerID == 0) continue;
                var player = BasePlayer.FindByID(npc.OwnerID) ?? null;
                if (player == null) continue;
                player.userID = npc.OwnerID;
                npcList.Add(npc.displayName, npc.OwnerID);
            }
        }

        private void OnPlayerConnected()
        {
            foreach (var npc in BaseNetworkable.serverEntities.OfType<NPCPlayer>().ToArray())
            {
                if (npc == null) continue;
                if (npc.OwnerID == 0) continue;
                var player = BasePlayer.FindByID(npc.OwnerID) ?? null;
                if (player == null) continue;
                npc.EndSleeping();
            }
        }

        private bool hasPermission(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permUse)) return true;
            return false;
        }
        private void Unload()
        {
            baseNPC = null;
        }

        private void DestroyNPC(BasePlayer player, NPCPlayer npc)
        {
            if (player == null || npc == null || npc.OwnerID != player.userID) return;

            npcList.Remove(player.userID.ToString());
            ChatMessage(player, "Killed");
            npc.Kill();
        }
        object GetActiveNPC(BasePlayer player) //Get all NPC on the map and check ownership
        {
            foreach (var npc in BaseNetworkable.serverEntities.OfType<NPCPlayer>().ToArray())
            {
                if (npc.OwnerID == player.userID)
                {
                    Puts(npc.displayName + " is owned by " + player.userID);
                    return baseNPC = npc;
                }
            }
            return null;
        }
        private void SpawnNPC(BasePlayer player)
        {
            var position = player.transform.position;
            BasePlayer npc = GameManager.server.CreateEntity(npcEntity, position).ToPlayer();
            npc.OwnerID = player.userID;
            npc.Spawn();
            npc.Heal(100f);
            npc.OverrideViewAngles(player.eyes.rotation.eulerAngles);
            ChatMessage(player, "Spawned");
            npcList.Add(npc.displayName, player.userID);

        }
        void RecallNPC(BasePlayer player, NPCPlayer npc)
        {
            npc.transform.position = player.transform.position;
            npc.OverrideViewAngles(player.eyes.rotation.eulerAngles);
            npc.SendNetworkUpdateImmediate();
            npc.UpdateNetworkGroup();

            ChatMessage(player, "NPCRecall");
            return;
        }
        void GoToNPC(BasePlayer player, NPCPlayer npc)
        {
            player.transform.position = npc.transform.position;
            npc.SendNetworkUpdateImmediate();
            npc.UpdateNetworkGroup();

            ChatMessage(player, "GoTo");
            return;
        }
        void HealNPC(BasePlayer player, NPCPlayer npc)
        {
            npc.Heal(100f);
            npc.SendNetworkUpdateImmediate();
            npc.UpdateNetworkGroup();

            ChatMessage(player, "Healed");
            return;
        }
        void NPCStatus(BasePlayer player, NPCPlayer npc)
        {
            Vector3 location = npc.transform.position;
            int xPos = (int)location.x;
            int yPos = (int)location.y;
            int zPos = (int)location.z;
            var health = (int)npc.Health();
            ChatMessage(player, "Check", health, xPos, yPos, zPos);
            return;
        }

        bool OnCoolDown(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, permBypassCooldown)) return false;

            if (!cooldowns.ContainsKey(player.UserIDString))
            {
                cooldowns.Add(player.UserIDString, 0f);
            }

            if (cooldownTime > 0 && cooldowns[player.UserIDString] + cooldownTime > Interface.Oxide.Now)
            {
                ChatMessage(player, "Cooldown", config.Cooldown);
                return true;
            }
            cooldowns[player.UserIDString] = Interface.Oxide.Now;
            return false;
        }
        private void ViewInventory(BasePlayer player, BasePlayer targetplayer)
        {

            player.EndLooting();

            LootableCorpse corpse = GameManager.server.CreateEntity(StringPool.Get(2604534927), Vector3.zero) as LootableCorpse;
            corpse.CancelInvoke("RemoveCorpse");
            corpse.syncPosition = false;
            corpse.limitNetworking = true;
            corpse.playerName = targetplayer.displayName;
            corpse.playerSteamID = 0;
            corpse.enableSaving = false;
            corpse.Spawn();
            corpse.SetFlag(BaseEntity.Flags.Locked, true);
            Buoyancy bouyancy;
            if (corpse.TryGetComponent<Buoyancy>(out bouyancy))
            {
                UnityEngine.Object.Destroy(bouyancy);
            }
            Rigidbody ridgidbody;
            if (corpse.TryGetComponent<Rigidbody>(out ridgidbody))
            {
                UnityEngine.Object.Destroy(ridgidbody);
            }
            corpse.SendAsSnapshot(player.Connection);

            timer.Once(0.3f, () =>
            {
                StartLooting(player, targetplayer, corpse);
            });
        }
        private void StartLooting(BasePlayer player, BasePlayer targetplayer, LootableCorpse corpse)
        {
            player.inventory.loot.AddContainer(targetplayer.inventory.containerMain);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerWear);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerBelt);
            player.inventory.loot.entitySource = corpse;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "player_corpse");
        }

        #endregion

        #region Config
        private class PluginConfig
        {
            public int Cooldown;
        }

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                Cooldown = 10
            };
        }
        #endregion

        #region Chat Commands
        //command for debugging NPCs
        [ChatCommand("npc.list")]
        private void ListCommand(BasePlayer player, string command, string[] args)
        {
            string entry = "";

            if (!player.IsAdmin) return;
            if (npcList.Count() == 0)
            {
                ChatMessage(player, "NoNPCOnMap");
                return;
            }
            foreach (var npc in npcList)
            {
                entry = "npcID " + npc.Key + " SteamID " + npc.Value;
            }

            PrintToConsole(entry);
            ChatMessage(player, "Console");
        }
        [ChatCommand("npc")]
        private void NPCCommand(BasePlayer player, string command, string[] args)
        {
            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }
            if (player.IsAdmin)
            {
                ChatMessage(player, "AdminHelp");
                return;
            };

            ChatMessage(player, "Help");
        }
        [ChatCommand("npc.help")]
        private void HelpCommand(BasePlayer player, string command, string[] args)
        {
            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }
            if (player.IsAdmin)
            {
                ChatMessage(player, "AdminHelp");
                return;
            };
            ChatMessage(player, "Help");
        }
        [ChatCommand("npc.add")]
        private void NPCAddCommand(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player) == true)
            {
                return;
            }

            if (permission.UserHasPermission(player.UserIDString, permMultipleNPC))
            {
                SpawnNPC(player);
                return;
            }
            GetActiveNPC(player);
            if (npcList.ContainsValue(player.userID) && baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                SpawnNPC(player);
                return;
            }
            if (npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "Exists");
                return;
            }
            SpawnNPC(player);
        }
        [ChatCommand("npc.kill")]
        private void KillNPCCommand(BasePlayer player, string command, string[] args)
        {
            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }
            GetActiveNPC(player);
            if (baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                ChatMessage(player, "NoNPC");
                return;
            }
            if (!npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "NoNPC");
                return;
            }
            DestroyNPC(player, baseNPC);
        }
        [ChatCommand("npc.heal")]
        private void HealNPCCommand(BasePlayer player, string command, string[] args)
        {
            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }
            GetActiveNPC(player);

            if (baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                ChatMessage(player, "NoNPC");
                return;
            }
            if (!npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "NoNPC");
                return;
            }
            HealNPC(player, baseNPC);
        }
        [ChatCommand("npc.status")]
        private void CheckNPCCommand(BasePlayer player, string command, string[] args)
        {
            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }
            GetActiveNPC(player);

            if (baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                ChatMessage(player, "NoNPC");
                return;
            }

            if (!npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "NoNPC");
                return;
            }
            NPCStatus(player, baseNPC);
        }

        [ChatCommand("npc.inv")]
        private void ViewInvCmd(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;

            if (hasPermission(player) == false)
            {
                ChatMessage(player, "Permission");
                return;
            }

            if (args.Length == 0 || string.IsNullOrEmpty(args[0]))
            {

                RaycastHit hitinfo;

                if (!Physics.Raycast(player.eyes.HeadRay(), out hitinfo, 3f, (int)Layers.Server.Players))
                {
                    ChatMessage(player, "NotFound");
                    return;
                }

                BasePlayer targetplayerhit = hitinfo.GetEntity().ToPlayer();
                if (targetplayerhit == null)
                {
                    ChatMessage(player, "NotFound");
                    return;
                }

                if (targetplayerhit.ShortPrefabName == "npcplayertest" && targetplayerhit.OwnerID == player.userID)
                {
                    ViewInventory(player, targetplayerhit);
                }
                return;
            }
            GetActiveNPC(player);
            NPCPlayer target = baseNPC;

            if (target == null)
            {
                return;
            }
            BasePlayer targetplayer = target as BasePlayer;
            if (targetplayer == null)
            {
                return;
            }
            ViewInventory(player, targetplayer);
        }
        [ChatCommand("npc.recall")]
        private void RecallNPCCommand(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player) == true)
            {
                return;
            }

            cooldownTime = config.Cooldown;

            if (!npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "NoNPC");
                return;
            }
            if (OnCoolDown(player))
            {
                return;
            }
            if (ValidationChecks(player) == true)
            {
                return;
            }

            GetActiveNPC(player);

            if (baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                ChatMessage(player, "NoNPC");
                return;
            }

            RecallNPC(player, baseNPC);

            return;
        }
        [ChatCommand("npc.goto")]
        private void TeleportNPCCommand(BasePlayer player, string command, string[] args)
        {
            if (ValidationChecks(player) == true)
            {
                return;
            }

            cooldownTime = config.Cooldown;

            if (!npcList.ContainsValue(player.userID))
            {
                ChatMessage(player, "NoNPC");
                return;
            }
            if (OnCoolDown(player))
            {
                return;
            }
            if (ValidationChecks(player) == true)
            {
                return;
            }

            GetActiveNPC(player);

            if (baseNPC == null)
            {
                npcList.Remove(player.userID.ToString());
                ChatMessage(player, "NoNPC");
                return;
            }

            GoToNPC(player, baseNPC);

            return;
        }
        #endregion

        #region Hooks
        void OnEntityKill(BaseEntity entity)
        {
            if (entity.ShortPrefabName != "npcplayertest") return;

            NPCPlayer npc = entity as NPCPlayer;
            if (npc.OwnerID == 0) return;
            var player = BasePlayer.FindByID(npc.OwnerID) ?? null;
            npcList.Remove(player.userID.ToString());

        }
        void OnEntityTakeDamage(NPCPlayer npc, HitInfo info)
        {
            if (npc == null || info.InitiatorPlayer == null || npc.OwnerID == 0) return;
            var player = BasePlayer.FindByID(npc.OwnerID);
            var attacker = info.InitiatorPlayer.UserIDString;

            if (npc.ShortPrefabName == "npcplayertest")
            {
                var currentNPCHealth = (int)npc._health;

                if (npc.OwnerID == 0) return;

                if (npc.OwnerID.ToString() != attacker)
                {
                    //Puts("You do not own this NPC. SteamID " + npc.OwnerID + " owns this NPC. Your ID is " + player.OwnerID);
                    info.damageTypes.ScaleAll(0f);
                    ChatMessage(info.InitiatorPlayer, "CantDamage");
                    return;
                }
                //Puts("This is your NPC " + attacker);
                return;
            }

        }
        #endregion

        #region Helpers
        private bool PositionIsInWater(Vector3 position)
        {
            var colliders = Facepunch.Pool.GetList<Collider>();
            Vis.Colliders(position, 0.5f, colliders);
            var flag = colliders.Any(x => x.gameObject?.layer == (int)Rust.Layer.Water);
            Facepunch.Pool.FreeList(ref colliders);
            return flag;
        }
        bool ValidationChecks(BasePlayer player)
        {
            if (player == null || player.IsDead()) return true;

            if (!permission.UserHasPermission(player.UserIDString, permUse))
            {
                ChatMessage(player, "Permission");
                return true;
            }
            if (player.IsHeadUnderwater() || player.IsSwimming() || PositionIsInWater(player.transform.position))
            {
                ChatMessage(player, "WaterBad");
                return true;
            }
            if (player.IsBuildingBlocked())
            {
                ChatMessage(player, "BuildingBlocked");
                return true;
            }
            if (player.isMounted)
            {
                ChatMessage(player, "Mounted");
                return true;
            }
            if (player.IsFlying || !player.IsOnGround())
            {
                ChatMessage(player, "Flying");
                return true;
            }
            if (player.IsWounded())
            {
                ChatMessage(player, "Wounded");
                return true;
            }

            return false;
        }
        #endregion

        #region Localization

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
        player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Help"] = "<size=18><color=#ffc34d>MyNPC</color></size>\n<color=#9999ff>/npc.add</color> to spawn your NPC.\n<color=#9999ff>/npc.recall</color> to recall your NPC.\n<color=#9999ff>/npc.goto</color> teleport to your NPC.\n<color=#9999ff>/npc.kill</color> to kill your NPC.\n<color=#9999ff>/npc.heal</color> to heal your NPC.\n<color=#9999ff>/npc.inv</color> to access your NPC's inventory.\n<color=#9999ff>/npc.status</color> to check the status of your NPC.",
                ["AdminHelp"] = "<size=18><color=#ffc34d>MyNPC</color></size>\n<color=#9999ff>/npc.add</color> to spawn your NPC.\n<color=#9999ff>/npc.recall</color> to recall your NPC.\n<color=#9999ff>/npc.goto</color> teleport to your NPC.\n<color=#9999ff>/npc.kill</color> to kill your NPC.\n<color=#9999ff>/npc.heal</color> to heal your NPC.\n<color=#9999ff>/npc.inv</color> to access your NPC's inventory.\n<color=#9999ff>/npc.status</color> to check the status of your NPC.\n\n<color=#ff6666>(Admin only)</color>\n<color=#9999ff>/npc.list</color> get the count and ownership of NPCs on the map.",
                ["Spawned"] = "<color=#ffc34d>MyNPC</color>: You have spawned an NPC.\nType <color=#9999ff>/npc</color> for more npc commands!",
                ["Healed"] = "<color=#ffc34d>MyNPC</color>: You NPC has been healed to <color=#b0fa66>100%</color>",
                ["Check"] = "<color=#ffc34d>MyNPC</color>: You NPC is <color=#b0fa66>alive</color> with <color=#b0fa66>{0}</color> health at location X:<color=#ffc34d>{1}</color>  Y:<color=#ffc34d>{2}</color> Z:<color=#ffc34d>{3}</color>",
                ["NPCRecall"] = "<color=#ffc34d>MyNPC</color>: You have recalled your NPC.",
                ["GoTo"] = "<color=#ffc34d>MyNPC</color>: You have teleported to your NPC.",
                ["Console"] = "<color=#ffc34d>MyNPC</color>: Check your <color=#ffc34d>console</color> for the results.",
                ["NoNPCOnMap"] = "<color=#ffc34d>MyNPC</color>: There are no player spawned NPCs on the map.",
                ["Killed"] = "<color=#ffc34d>MyNPC</color>: Your NPC has been killed.",
                ["NoNPC"] = "<color=#ffc34d>MyNPC</color>: You don't have an NPC out.",
                ["NotFound"] = "<color=#ffc34d>MyNPC</color>: No owned NPCs found.",
                ["Exists"] = "<color=#ffc34d>MyNPC</color>: You already have an NPC out.",
                ["CantDamage"] = "<color=#ffc34d>MyNPC</color>: You cannot damage an NPC that you don't own.",
                ["Permission"] = "<color=#ffc34d>MyNPC</color>: You don't have an NPC out.",
                ["BuildingBlocked"] = "<color=#ffc34d>MyNPC</color>: Can't spawn/recall/goto an NPC while building blocked.",
                ["Mounted"] = "<color=#ffc34d>MyNPC</color>: Can't spawn/recall/goto an NPC while mounted.",
                ["WaterBad"] = "<color=#ffc34d>MyNPC</color>: NPCs can't swim.",
                ["Flying"] = "<color=#ffc34d>MyNPC</color>: Can't spawn/recall/goto while jumping, flying, or falling",
                ["Cooldown"] = "<color=#ffc34d>MyNPC</color>: You are on a {0} second cooldown.",

            }, this, "en");
        }
        #endregion
    }
}


// --- End of file: MyNPC.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-tools ---
// --- Original File Path: M/MagicTools/MagicTools.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Rust;

#region Changelogs and ToDo
/**********************************************************************
 * 
 * v3.0.0   :   Maintained by Krungh Crow
 *          :   Complete rewrite
 *          :   Converted to covalence
 *          :   Added default/vip permissions
 *          :   Extra resources on bonus hit (perms)
 * 
 **********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Magic Tools", "Krungh Crow", "3.0.0")]
    [Description("Automatically smelts Mined resources and bonuses")]

    class MagicTools : CovalencePlugin
    {

        #region Variables

        const string Use_Perm = "magictools.use";
        const string Default_Perm = "magictools.default";
        const string Vip_Perm = "magictools.vip";

        #endregion

        #region Configuration

        void Init()
        {
            if (!LoadConfigVariables())
            {
            Puts("Config file issue detected. Please delete file, or check syntax and fix.");
            return;
            }

            permission.RegisterPermission(Use_Perm, this);
            permission.RegisterPermission(Default_Perm, this);
            permission.RegisterPermission(Vip_Perm, this);
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Multiplier on Bonus hit (rounded numbers only(ea 1 not 1.2)")]
            public SettingsBonus Settings = new SettingsBonus();
        }

        class SettingsBonus
        {
            [JsonProperty(PropertyName = "Default multiplier on Bonus")]
            public int MultiDefault = 2;
            [JsonProperty(PropertyName = "Vip multiplier on Bonus")]
            public int MultiVip = 3;
        }

        private bool LoadConfigVariables()
        {
            try
            {
            configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
            return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region Hooks

        private object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (permission.UserHasPermission(player.UserIDString, Use_Perm))
            {
                if (dispenser == null || player == null || item == null)
                    return null;

                ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null)
                    return null;

                var cookedItem = ItemManager.Create(cookable.becomeOnCooked, item.amount);
                player.GiveItem(cookedItem, BaseEntity.GiveItemReason.ResourceHarvested);

                return true;
            }
            return null;

        }
        private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (permission.UserHasPermission(player.UserIDString, Use_Perm))
            {
                if (dispenser == null || player == null || item == null)
                    return null;

                ItemModCookable cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable == null)
                    return null;

                if (permission.UserHasPermission(player.UserIDString, Vip_Perm))
                {
                    item.amount = item.amount * configData.Settings.MultiVip;
                }

                else if (permission.UserHasPermission(player.UserIDString, Default_Perm))
                {
                    item.amount = item.amount * configData.Settings.MultiDefault;
                }

                var cookedItem = ItemManager.Create(cookable.becomeOnCooked, item.amount);
                player.GiveItem(cookedItem, BaseEntity.GiveItemReason.ResourceHarvested);
                NextTick(() =>
                {
                    item.DoRemove();
                });
                return true;
            }
            return null;
        }

        #endregion
    }
}

// --- End of file: MagicTools.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mini-copter-eject ---
// --- Original File Path: M/MiniCopterEject/MiniCopterEject.cs ---

﻿﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini Copter Eject", "Ryz0r", "1.0.2")]
    [Description("Allows the pilot to eject the passenger from a MiniCopter.")]
    
    public class MiniCopterEject : RustPlugin
    {
        private const string EjectPerm = "minicoptereject.use";
        
        #region Config/Locale
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Self Eject If No Passenger")]
            public bool SelfEject = false;
            
            [JsonProperty(PropertyName = "Send Messages on Eject")]
            public bool SendOnEject = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotClient"] = "This command is meant to be run from a client, not the console.",
                ["NoPerm"] = "You don't have the permissions to use this command.",
                ["NotMounted"] = "You are not mounted, or not in a MiniCopter and may not use this functionality.",
                ["PlayerEjected"] = "You have been ejected from the MiniCopter by {0}.",
                ["PlayerEject"] = "You have ejected {0} from the MiniCopter.",
                ["NoPlayer"] = "There is no player to eject from the passenger seat.",
                ["SelfEject"] = "You have ejected yourself from the MiniCopter. Yikes!"
            }, this); 
        }
        
        private void Init()
        {
            AddCovalenceCommand("eject", nameof(EjectCommand));
            permission.RegisterPermission(EjectPerm, this);
        }
        #endregion
        #region Hooks
        private void DoEject(BaseVehicle bv, BasePlayer bp, bool selfEject = false)
        {
            BasePlayer mountedPassenger = null;
            mountedPassenger = selfEject ? bv.mountPoints[0].mountable._mounted : bv.mountPoints[1].mountable._mounted;
            
            var dismountPlayer = (BasePlayer.Find(mountedPassenger.UserIDString));

            if (dismountPlayer.IsAdmin || permission.UserHasGroup(dismountPlayer.UserIDString, "admin") ||
                dismountPlayer.net.connection.authLevel >= 1) return;
                mountedPassenger.EnsureDismounted();
                
            if (!_config.SendOnEject) return;
            

            if (selfEject)
            {
                bp.ChatMessage(lang.GetMessage("SelfEject", this, bp.UserIDString));
            }
            else
            {
                bp.ChatMessage(lang.GetMessage("PlayerEject", this, bp.UserIDString).Replace("{0}", dismountPlayer.displayName));
                dismountPlayer.ChatMessage(lang.GetMessage("PlayerEjected", this, dismountPlayer.UserIDString).Replace("{0}", bp.displayName));
            }
        }
        private static void SpawnButton(Component entity)
        {
            var button = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/button/button.prefab", entity.transform.position) as PressButton;
            if (button == null) return;

            button.SetParent(entity.GetComponent<BaseVehicle>());
            var t = button.transform;
            
            t.localPosition = new Vector3(-0.10f, -0.25f, 1f);
            t.localRotation = Quaternion.Euler(new Vector3(0, 180, 0));
            t.localScale += new Vector3(0.1f, 0.1f, 0.1f);
            
            button.Spawn();
        }
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!(entity is MiniCopter)) return;

            SpawnButton((BaseVehicle) entity);
        }
        private object OnButtonPress(BaseNetworkable button, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, EjectPerm))
            {
                player.ChatMessage(lang.GetMessage("NoPerm", this, player.UserIDString));
                return false;
            }
            
            var parent = button.GetParentEntity();
            if (parent == null || !(parent is MiniCopter)) return null;
            
            var mc = parent as MiniCopter;
            if (mc == null) return null;

            if (!mc.mountPoints[1].mountable._mounted)
            {
                if (_config.SelfEject)
                {
                    DoEject(mc, player, true); 
                }
                else
                {
                    player.ChatMessage(lang.GetMessage("NoPlayer", this, player.UserIDString));
                }
            }
            else
            {
                DoEject(mc, player);  
            }
            return null;   
        }
        #endregion
        private void EjectCommand(IPlayer player, string command, string[] args)
        {
            var bp = player.Object as BasePlayer;
            if (bp == null)
            {
                player.Reply(lang.GetMessage("NotClient", this, player.Id));
                return;
            }

            if (!permission.UserHasPermission(player.Id, EjectPerm))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }

            if (bp.isMounted && bp.GetMountedVehicle() is MiniCopter)
            {
                if (bp.GetMountedVehicle().mountPoints[1].mountable._mounted)
                {
                    var bv = bp.GetMountedVehicle();
                    DoEject(bv, bp);
                }
                else
                {
                    var bv = bp.GetMountedVehicle();
                    if (_config.SelfEject)
                    {
                        DoEject(bv, bp, true);
                    }
                    else
                    {
                        bp.ChatMessage(lang.GetMessage("NoPlayer", this, bp.UserIDString));
                    }
                }
            }
            else
            {
                bp.ChatMessage(lang.GetMessage("NotMounted", this, bp.UserIDString));
            }
        } 
    }
}

// --- End of file: MiniCopterEject.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/marker-distance ---
// --- Original File Path: M/MarkerDistance/MarkerDistance.cs ---

﻿using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Marker Distance", "Notchu", "1.2.1")]
[Description("Shows distance to placed marker")]

internal class MarkerDistance : RustPlugin
{
    private class Configuration
    {
        [JsonProperty("Text Color")]
        public string TextColor = "1.0 1.0 1.0 1.0";
        
        [JsonProperty("Font Size")] 
        public int FontSize = 14;

        [JsonProperty("Background Color")] 
        public string BackgroundColor = "0.50 0.50 0.50 0.5";

        [JsonProperty("Anchor Min")]
        public string AnchorMin = "0.47 0.94";

        [JsonProperty("Anchor Max")]
        public string AnchorMax = "0.53 0.96";

        [JsonProperty("Refresh Interval")]
        public float Interval = 1f;

        [JsonProperty("Offset Min")] 
        public string OffsetMin = "0 -15";
        
        [JsonProperty("Offset Max")] 
        public string OffsetMax = "0 -5";
    }
    
        
    private Configuration _config;

    private Timer _distanceTimer = null;
    
    private HashSet<BasePlayer> _users = new HashSet<BasePlayer>();
    
     private readonly Dictionary<int, string> _colorCodes = new Dictionary<int, string>()
        {
            { 0, "0.906 0.918 0.373 0.8" },
            { 1, "0.196 0.49 0.851 0.8" },
            { 2, "0.502 0.71 0.239 0.8" },
            { 3, "0.784 0.231 0.231 0.8" },
            { 4, "0.745 0.376 0.804 0.8" }
        };
    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
        }
    }

    protected override void SaveConfig() => Config.WriteObject(_config);

    protected override void LoadDefaultConfig() => _config = new Configuration();
    
    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"UnitOfMeasure", "{distance} meters" }

        }, this);
    }
    void Init()
    {
        permission.RegisterPermission("markerDistance.use", this);
            
    }
    void Unload()
    {
        if (_users == null) return;
        foreach (var user in _users)
        {
            if (user == null) continue;
            CuiHelper.DestroyUi(user, "markerDistanceBackground");
        }
        _users.Clear();
    }

    void OnPlayerDisconnected(BasePlayer player, string reason)
    {
        CuiHelper.DestroyUi(player, "markerDistanceBackground");
        _users.Remove(player);
        if (_users.Count == 0 && _distanceTimer != null && !_distanceTimer.Destroyed )
        {
            _distanceTimer.Destroy();
        }
    }
    
    void OnMapMarkerAdded(BasePlayer player, MapNote note)
    {
        if (!DoesHavePermission(player.UserIDString)) return;

        if (_distanceTimer == null || _distanceTimer.Destroyed)
        {
            _distanceTimer = timer.Every(_config.Interval, ShowDistance);
        }

        _users.Add(player);
    }
        
    /* object OnMapMarkerRemove(BasePlayer player, MapNote note)
    {
        if (!_users.Contains(player))
        {
            return null;
        }

        if (player.State.pointsOfInterest.Count == 1) 
        {
            if(_users.Remove(player)) CuiHelper.DestroyUi(player, "markerDistanceBackground");
        }

        if (_users.Count == 0 && _distanceTimer != null && !_distanceTimer.Destroyed )
        {
            _distanceTimer.Destroy();
        }

        return null;

    } */
    private void ShowDistance()
    {
        if (_users.Count == 0)
        {
            _distanceTimer.Destroy();
            return;
        }

        var usersToDelete = new List<BasePlayer>();
        foreach (var u in _users)
        {
            if (u.State.pointsOfInterest.Count == 0)
            {
                usersToDelete.Add(u);
                continue;
            }
            var note = u.State.pointsOfInterest[^1];
            
            var distance = (int)(note.worldPosition - u.transform.position).magnitude;
            
            var container = new CuiElementContainer();
            
            var guiBackground = container.Add(new CuiPanel()
            {
                Image =
                {
                    Color = _config.BackgroundColor
                },
                RectTransform =
                {
                    AnchorMin = _config.AnchorMin,
                    AnchorMax = _config.AnchorMax,
                    OffsetMin = _config.OffsetMin,
                    OffsetMax = _config.OffsetMax
                },
                CursorEnabled = false
            }, "Under", "markerDistanceBackground");
            
            container.Add(new CuiLabel()
            {
                Text =
                {
                    Text = lang.GetMessage("UnitOfMeasure", this, u.UserIDString).Replace("{distance}", distance.ToString()),
                    FontSize = _config.FontSize,
                    Color = _config.TextColor,
                    Align = TextAnchor.MiddleCenter
                        
                },
                    
            }, guiBackground);
            container.Add(new CuiPanel()
            {
                Image = { Color = _colorCodes[note.colourIndex] },
                RectTransform =
                {
                    AnchorMin = "0.0 0.99",
                    AnchorMax = "0.99 1.0"
                }
            }, guiBackground);

            CuiHelper.DestroyUi(u, "markerDistanceBackground");
            CuiHelper.AddUi(u, container);
        }

        if (usersToDelete.Count == 0) return;
        
        foreach (var u in usersToDelete)
        {
            CuiHelper.DestroyUi(u, "markerDistanceBackground");
            _users.Remove(u);
        }
    }

    private bool DoesHavePermission(string id)
    {
        return permission.UserHasPermission(id, "markerDistance.use");
    }
    

    
    
    
}

// --- End of file: MarkerDistance.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-fps-panel ---
// --- Original File Path: M/MagicFpsPanel/MagicFpsPanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Fps Panel", "MJSU", "1.0.2")]
    [Description("Displays the server fps in magic panel")]
    public class MagicFpsPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private const string ViewPermission = "magicfpspanel.view";
        private string _fpsText;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _fpsText = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? false,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0f,
                    Url = config.Panel?.Image?.Url ?? "",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 1f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "(S)FPS: {0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#fff2df08",
                Dock = config.PanelSettings?.Dock ?? "leftmiddle",
                Order = config.PanelSettings?.Order ?? 3,
                Width = config.PanelSettings?.Width ?? 0.065f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();

            timer.Every(_pluginConfig.UpdateRate, () =>
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }

            string permName = _pluginConfig.UsePermission ? ViewPermission : string.Empty;
            
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel), permName);
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_fpsText, $"{Performance.report.frameRate}");
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Requires permission to view")]
            public bool UsePermission { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicFpsPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-plus-lite ---
// --- Original File Path: M/MonumentPlus/MonumentPlus.cs ---

using System.Collections.Generic;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System;
using Oxide.Game.Rust.Cui;
using System.Text.RegularExpressions;
using Color = UnityEngine.Color;
using VLB;
using Rust;

namespace Oxide.Plugins
{
    [Info("Monument Plus Lite", "Ts3Hosting", "1.1.0")]
    [Description("Auto spawn prefabs at monuments")]
    public class MonumentPlus : RustPlugin
    {
        public static MonumentPlus _;
        public List<NetworkableId> spawnedEntitys = new List<NetworkableId>();
        private const int DamageTypeMax = (int)DamageType.LAST;

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "<color=#ce422b>You need permishion to use this command.</color>",
                ["info"] = "<color=#ce422b>MonumentName:</color> \"{0}\" \n <color=#ce422b>Position:</color>\n x = \"{1}\"\n y = \"{2}\"\n z = \"{3}\"\n</color>"
            }, this);
        }

        #region Config

        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings settings { get; set; }

            [JsonProperty(PropertyName = "Spawn Addons At")]
            public Entity entity { get; set; }

            public class Settings
            {
                public bool AutoSpawnOnBoot { get; set; }
            }

            public class Entity
            {
                public Dictionary<string, itemSpawning> Information { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }
        protected override void LoadConfig()
        {
            _ = this;
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                settings = new ConfigData.Settings
                {
                    AutoSpawnOnBoot = false,
                },

                entity = new ConfigData.Entity
                {
                    Information = new Dictionary<string, itemSpawning>()
                },

                Version = Version
            };
        }

        class itemSpawning
        {
            public bool enabled;
            public string MonumentName;
            public string prefab;
            public Vector3 pos;
            public float rotate;
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(1, 0, 1))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        private void Init()
        {
            permission.RegisterPermission("monumentplus.info", this);
        }

        private void OnServerInitialized()
        {
            if (configData.entity.Information.Count() <= 0)
            {
                configData.entity.Information.Add("supermarket", new itemSpawning());
                configData.entity.Information["supermarket"].MonumentName = "supermarket";
                configData.entity.Information["supermarket"].prefab = "assets/bundled/prefabs/static/modularcarlift.static.prefab";
                configData.entity.Information["supermarket"].pos = new Vector3(0.2f, 0f, 17.5f);
                configData.entity.Information["supermarket"].rotate = 0.0f;

                configData.entity.Information.Add("gasstation", new itemSpawning());
                configData.entity.Information["gasstation"].MonumentName = "gas_station";
                configData.entity.Information["gasstation"].prefab = "assets/bundled/prefabs/static/modularcarlift.static.prefab";
                configData.entity.Information["gasstation"].pos = new Vector3(4.2f, 3.0f, -0.5f);
                configData.entity.Information["gasstation"].rotate = 0.0f;

                Config.WriteObject(configData, true);
            }

            if (configData.settings.AutoSpawnOnBoot)
                spawningAddons(false);
        }

        private void Unload()
        {
            foreach (NetworkableId entity in spawnedEntitys.ToList())
            {
                var networkable = BaseNetworkable.serverEntities.Find(entity);
                if (networkable != null) networkable?.Kill();
            }
            _ = null;
        }

        [ChatCommand("monumentinfo")]
        private void GetLocations(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "monumentplus.info"))
            {
                SendReply(player, lang.GetMessage("NoPerm", this));
                return;
            }
            float lowestDist = float.MaxValue;
            MonumentInfo closest = null;
            string name = "Unknown";
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (GetMonumentName(monument) == null || GetMonumentName(monument).Contains("substation")) continue;
                float dist = Vector3.Distance(player.transform.position, monument.transform.position);
                if (dist < lowestDist)
                {
                    lowestDist = dist;
                    closest = monument;
                    name = GetMonumentName(monument);
                    if (name.Contains("monument_marker.prefab"))
                        name = "\"" + monument.gameObject?.gameObject?.transform?.parent?.gameObject?.transform?.root?.name + "\"";
                }
            }

            var localPos = closest.transform.InverseTransformPoint(player.transform.position);
            var rotation = player.transform.rotation;
            if (MonumentToName.ContainsKey(name))
                SendReply(player, lang.GetMessage("info", this), MonumentToName[name], localPos.x, localPos.y, localPos.z);
            else SendReply(player, lang.GetMessage("info", this), name, localPos.x, localPos.y, localPos.z);
            //Puts(name + " " + localPos.ToString( "F4" ));
        }

        public string GetMonumentName(MonumentInfo monument)
        {
            var gameObject = monument.gameObject;

            while (gameObject.name.StartsWith("assets/") == false && gameObject.transform.parent != null)
            {
                gameObject = gameObject.transform.parent.gameObject;
            }
            if (gameObject?.name != null && gameObject.name.Contains("monument_marker.prefab"))
                return monument.gameObject?.gameObject?.transform?.parent?.gameObject?.transform?.root?.name;

            return gameObject?.name;
        }

        private void spawningAddons(bool unLoading)
        {
            foreach (var key in configData.entity.Information.ToList())
            {
                if (!key.Value.enabled) continue;
                foreach (var monument in TerrainMeta.Path.Monuments)
                {
                    Vector3 itemsVector = Vector3.zero;
                    if (monument == null) continue;
                    if (!monument.name.ToLower().Contains(key.Value.MonumentName.ToLower())) continue;
                    itemsVector = monument.transform.TransformPoint(key.Value.pos);
                    if (itemsVector == null || itemsVector == Vector3.zero) continue;

                    var itemsEntity = GameManager.server.CreateEntity(key.Value.prefab, itemsVector, Quaternion.Euler(monument.transform.localEulerAngles.x, monument.transform.localEulerAngles.y + key.Value.rotate, monument.transform.localEulerAngles.z));

                    if (itemsEntity != null)
                    {
                        itemsEntity.enableSaving = false;
                        RemoveGroundWatch(itemsEntity);
                        itemsEntity.Spawn();
                        RemoveGroundWatch(itemsEntity);
                        spawnedEntitys.Add(itemsEntity.net.ID);
                    }
                }
            }
        }

        private void RemoveGroundWatch(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity.GetComponent<GroundWatch>() != null)
                UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
            if (entity.GetComponent<DestroyOnGroundMissing>() != null)
                UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
        }

        private void OnEntityTakeDamage(BaseEntity entity, HitInfo hitInfo)
        {
            if (hitInfo != null && entity != null && entity.net != null && spawnedEntitys.Contains(entity.net.ID) && hitInfo.damageTypes != null)
            {
                for (var i = 0; i < DamageTypeMax; i++)
                {
                    hitInfo.damageTypes.Scale((DamageType)i, 0);
                }
            }
        }

        private static Dictionary<string, string> MonumentToName
        {
            get
            {
                return new Dictionary<string, string>()
                {
                { "assets/bundled/prefabs/autospawn/monument/small/warehouse.prefab", "warehouse" },
                { "assets/bundled/prefabs/autospawn/monument/lighthouse/lighthouse.prefab", "lighthouse" },
                { "assets/bundled/prefabs/autospawn/monument/small/satellite_dish.prefab", "satellite_dish" },
                { "assets/bundled/prefabs/autospawn/monument/small/sphere_tank.prefab", "sphere_tank" },
                { "assets/bundled/prefabs/autospawn/monument/harbor/harbor_1.prefab", "harbor_1" },
                { "assets/bundled/prefabs/autospawn/monument/harbor/harbor_2.prefab", "harbor_2" },
                { "assets/bundled/prefabs/autospawn/monument/large/airfield_1.prefab", "airfield" },
                { "assets/bundled/prefabs/autospawn/monument/large/junkyard_1.prefab", "junkyard" },
                { "assets/bundled/prefabs/autospawn/monument/large/launch_site_1.prefab", "launch_site" },
                { "assets/bundled/prefabs/autospawn/monument/large/military_tunnel_1.prefab", "military_tunnel" },
                { "assets/bundled/prefabs/autospawn/monument/large/powerplant_1.prefab", "powerplant" },
                { "assets/bundled/prefabs/autospawn/monument/large/trainyard_1.prefab", "trainyard" },
                { "assets/bundled/prefabs/autospawn/monument/large/water_treatment_plant_1.prefab", "water_treatment_plant" },
                { "assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab", "bandit_town" },
                { "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab", "compound" },
                { "assets/bundled/prefabs/autospawn/monument/medium/radtown_small_3.prefab", "radtown_small_3" },
                { "assets/bundled/prefabs/autospawn/monument/small/gas_station_1.prefab", "gas_station" },
                { "assets/bundled/prefabs/autospawn/monument/roadside/gas_station_1.prefab", "gas_station" },
                { "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_a.prefab", "mining_quarry_a" },
                { "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_b.prefab", "mining_quarry_b" },
                { "assets/bundled/prefabs/autospawn/monument/small/mining_quarry_c.prefab", "mining_quarry_c" },
                { "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_2.prefab", "oilrig_2" },
                { "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_1.prefab", "oilrig_1" },
                };
            }
        }
    }
}

// --- End of file: MonumentPlus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mute-explosions ---
// --- Original File Path: M/MuteExplosions/MuteExplosions.cs ---

﻿using System.Collections.Generic;
using System.ComponentModel;
using Facepunch;
using Network;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mute Explosions", "1AK1/MJSU", "1.0.3")]
    [Description("Mutes explosion sounds for everyone but the initiator")]
    internal class MuteExplosions : CovalencePlugin
    {
        #region Class Fields
        private PluginConfig _pluginConfig;
        
        private const string UsePermission = "muteexplosions.use"; //Players with this permission will have the sound effect changed
        private const string BypassPermission = "muteexplosions.bypass"; //Players with this permission can hear the sound effect normally

        private readonly Hash<uint, string> _explosionEffect = new Hash<uint, string>();
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
            permission.RegisterPermission(BypassPermission, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            return config;
        }
        #endregion

        #region Oxide Hooks
        private void OnEntitySpawned(TimedExplosive explosive)
        {
            BasePlayer player = explosive.creatorEntity as BasePlayer;
            if (player != null && !HasPermission(explosive.creatorEntity as BasePlayer, UsePermission))
            {
                return;
            }
            
            _explosionEffect[explosive.net.ID] = explosive.explosionEffect.resourcePath;
            explosive.explosionEffect.guid = null;
        }

        private void OnEntityKill(TimedExplosive explosive)
        {
            string effectName = _explosionEffect[explosive.net.ID];
            if (string.IsNullOrEmpty(effectName))
            {
                return;
            }

            _explosionEffect.Remove(explosive.net.ID);

            List<Connection> connections = Pool.GetList<Connection>();

            if (_pluginConfig.SendToOwner)
            {
                BasePlayer creator = explosive.creatorEntity as BasePlayer;
                if (creator != null && creator.IsConnected)
                {
                    connections.Add(creator.Connection);
                }
            }

            Vector3 explosivePosition = explosive.PivotPoint();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (HasPermission(player, BypassPermission) || Vector3.Distance(player.transform.position, explosivePosition) < _pluginConfig.SendToRange)
                {
                    connections.Add(player.Connection);
                }
            }
            
            Effect effect = new Effect(effectName, explosivePosition, explosive.explosionUsesForward ? explosive.transform.forward : Vector3.up);
            SendEffect(effect, connections);
            Pool.FreeList(ref connections);
        }
        #endregion
        
        #region Effect Handling
        private void SendEffect(Effect effect, List<Connection> connections)
        {
            effect.pooledstringid = StringPool.Get(effect.pooledString);
            if (effect.pooledstringid == 0U)
            {
                Debug.LogWarning("EffectNetwork.Send - unpooled effect name: " + effect.pooledString);
            }
            else
            {
                Net.sv.write.Start();
                Net.sv.write.PacketID(Message.Type.Effect);
                effect.WriteToStream(Net.sv.write);
                Net.sv.write.Send(new SendInfo(connections));
            }
        }
        #endregion

        #region Helpers
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        #endregion

        #region Classes

        public class PluginConfig
        {
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Send to explosive owner")]
            public bool SendToOwner { get; set; }
            
            [DefaultValue(0)]
            [JsonProperty(PropertyName = "Send to in range (Meters)")]
            public float SendToRange { get; set; }
        }

        #endregion

    }

}

// --- End of file: MuteExplosions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/martyrdom ---
// --- Original File Path: M/Martyrdom/Martyrdom.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Martyrdom", "k1lly0u", "0.2.1")]
    [Description("Much like the Martyrdom perk in COD, allows players with permission to drop various explosives when they are killed")]
    class Martyrdom : RustPlugin
    {
        #region Fields
        private Dictionary<ulong, ExplosiveType> registeredMartyrs;
        private Dictionary<ExplosiveType, ExplosiveInfo> explosiveInfo;
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            registeredMartyrs = new Dictionary<ulong, ExplosiveType>();
            explosiveInfo = new Dictionary<ExplosiveType, ExplosiveInfo>();
            permission.RegisterPermission("martyrdom.grenade", this);
            permission.RegisterPermission("martyrdom.beancan", this);
            permission.RegisterPermission("martyrdom.explosive", this);
            lang.RegisterMessages(messages, this);
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            SetExplosiveInfo();
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity == null)
                return;

            BasePlayer player = entity.ToPlayer();
            if (player != null)
            {
                if (registeredMartyrs.ContainsKey(player.userID))                
                    TryDropExplosive(player);                
            }
        }
        #endregion

        #region Functions
        private void TryDropExplosive(BasePlayer player)
        {
            ExplosiveType type = registeredMartyrs[player.userID];
            if (HasPerm(player, type))
            {
                if (HasEnoughRes(player, explosiveInfo[type].ItemID, 1))
                {
                    TakeResources(player, explosiveInfo[type].ItemID, 1);
                    CreateExplosive(type, player);
                    registeredMartyrs.Remove(player.userID);
                    return;
                }
            }            
        }
        private void CreateExplosive(ExplosiveType type, BasePlayer player)
        {
            ExplosiveInfo info = explosiveInfo[type];
            BaseEntity entity = GameManager.server.CreateEntity(info.PrefabName, player.transform.position + new Vector3(0, 1.5f, 0), new Quaternion(), true);
            entity.OwnerID = player.userID;
            entity.creatorEntity = player;

            TimedExplosive explosive = entity.GetComponent<TimedExplosive>();
            explosive.timerAmountMax = info.Fuse;
            explosive.timerAmountMin = info.Fuse;
            explosive.explosionRadius = info.Radius;
            explosive.damageTypes = new List<Rust.DamageTypeEntry> { new Rust.DamageTypeEntry { amount = info.Damage, type = Rust.DamageType.Explosion } };
            explosive.Spawn();
        }
        #endregion

        #region Helpers
        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;

        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);

        private bool HasPerm(BasePlayer player, ExplosiveType type)
        {
            switch (type)
            {
                case ExplosiveType.Grenade:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.grenade");
                case ExplosiveType.Beancan:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.beancan");
                case ExplosiveType.Explosive:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.explosive");                
            }
            return false;
        }

        private bool HasAnyPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "martyrdom.grenade") || permission.UserHasPermission(player.UserIDString, "martyrdom.beancan") || permission.UserHasPermission(player.UserIDString, "martyrdom.explosive");
        #endregion

        #region Explosive Info       
        private void SetExplosiveInfo()
        {
            if (configData.Beancan.Activated)
                explosiveInfo.Add(ExplosiveType.Beancan, new ExplosiveInfo { ItemID = 384204160, PrefabName = "assets/prefabs/weapons/beancan grenade/grenade.beancan.deployed.prefab", Damage = configData.Beancan.Damage, Fuse = configData.Beancan.Fuse, Radius = configData.Beancan.Radius });
            if (configData.Grenade.Activated)
                explosiveInfo.Add(ExplosiveType.Grenade, new ExplosiveInfo { ItemID = -1308622549, PrefabName = "assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", Damage = configData.Grenade.Damage, Fuse = configData.Grenade.Fuse, Radius = configData.Grenade.Radius });
            if (configData.Explosive.Activated)
                explosiveInfo.Add(ExplosiveType.Explosive, new ExplosiveInfo { ItemID = 498591726, PrefabName = "assets/prefabs/tools/c4/explosive.timed.deployed.prefab", Damage = configData.Explosive.Damage, Fuse = configData.Explosive.Fuse, Radius = configData.Explosive.Radius });
        }

        private class ExplosiveInfo
        {
            public int ItemID;
            public string PrefabName;
            public float Damage;
            public float Radius;
            public float Fuse;
        }

        enum ExplosiveType
        {
            Grenade,
            Beancan,
            Explosive
        }
        #endregion

        #region Chat Commands        
        [ChatCommand("m")]
        private void cmdM(BasePlayer player, string command, string[] args)
        {
            if (!HasAnyPerm(player)) return;
            if (args == null || args.Length == 0)
            {
                if (HasPerm(player, ExplosiveType.Beancan) && configData.Beancan.Activated)
                    SendReply(player, "/m beancan");
                if (HasPerm(player, ExplosiveType.Grenade) && configData.Grenade.Activated)
                    SendReply(player, "/m grenade");
                if (HasPerm(player, ExplosiveType.Explosive) && configData.Explosive.Activated)
                    SendReply(player, "/m explosive");
                SendReply(player, "/m disable");
                return;
            }
            switch (args[0].ToLower())
            {
                case "beancan":
                    if (HasPerm(player, ExplosiveType.Beancan))
                    {
                        if (!registeredMartyrs.ContainsKey(player.userID))
                            registeredMartyrs.Add(player.userID, ExplosiveType.Beancan);
                        else registeredMartyrs[player.userID] = ExplosiveType.Beancan;
                        SendReply(player, msg("beanAct", player.UserIDString));
                    }
                    return;
                case "grenade":
                    if (HasPerm(player, ExplosiveType.Grenade))
                    {
                        if (!registeredMartyrs.ContainsKey(player.userID))
                            registeredMartyrs.Add(player.userID, ExplosiveType.Grenade);
                        else registeredMartyrs[player.userID] = ExplosiveType.Grenade;
                        SendReply(player, msg("grenAct", player.UserIDString));
                    }
                    return;
                case "explosive":
                    if (HasPerm(player, ExplosiveType.Explosive))
                    {
                        if (!registeredMartyrs.ContainsKey(player.userID))
                            registeredMartyrs.Add(player.userID, ExplosiveType.Explosive);
                        else registeredMartyrs[player.userID] = ExplosiveType.Explosive;
                        SendReply(player, msg("expAct", player.UserIDString));
                    }
                    return;
                case "disable":
                    if (registeredMartyrs.ContainsKey(player.userID))
                    {
                        registeredMartyrs.Remove(player.userID);
                        SendReply(player, msg("marDis", player.UserIDString));
                        return;
                    }
                    else SendReply(player, msg("notAct", player.UserIDString));
                    return;
                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;    
        
        private class ConfigData
        {
            public ExpType Grenade { get; set; }
            public ExpType Beancan { get; set; }
            public ExpType Explosive { get; set; }

            public class ExpType
            {
                public bool Activated { get; set; }
                public float Damage { get; set; }
                public float Radius { get; set; }
                public float Fuse { get; set; }
            }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Beancan = new ConfigData.ExpType
                {
                    Activated = true,
                    Damage = 15f,
                    Fuse = 2f,
                    Radius = 4.5f
                },
                Grenade = new ConfigData.ExpType
                {
                    Activated = true,
                    Damage = 40f,
                    Fuse = 2f,
                    Radius = 4.5f
                },
                Explosive = new ConfigData.ExpType
                {
                    Activated = true,
                    Damage = 500,
                    Fuse = 3,
                    Radius = 10f
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"beanAct", "You have activated the beancan Martyr drop" },
            {"grenAct", "You have activated the grenade Martyr drop" },
            {"expAct", "You have activated the explosive Martyr drop" },
            {"marDis", "You have disabled Martyrdom" },
            {"notAct", "You do not have Martyrdom activated" }
        };

        #endregion
    }
}


// --- End of file: Martyrdom.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-direction-panel ---
// --- Original File Path: M/MagicDirectionPanel/MagicDirectionPanel.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Direction Panel", "MJSU", "1.0.1")]
    [Description("Displays players direction in magic panel")]
    public class MagicDirectionPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private string _directionText;

        private readonly Hash<ulong, string> _playerDirection = new Hash<ulong, string>();

        private Coroutine _updateRoutine;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _directionText = _pluginConfig.Panel.Text.Text;
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.North] = "North",
                [LangKeys.Northeast] = "Northeast",
                [LangKeys.East] = "East",
                [LangKeys.Southeast] = "Southeast",
                [LangKeys.South] = "South",
                [LangKeys.Southwest] = "Southwest",
                [LangKeys.West] = "West",
                [LangKeys.Northwest] = "Northwest",
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.2f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/5ydm0Pr1/6xCIe5a.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.01f, 0.00f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .8f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.01f, 0.01f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}"
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftbottom",
                Order = config.PanelSettings?.Order ?? 15,
                Width = config.PanelSettings?.Width ?? 0.11f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerCoords, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerDirection.Remove(player.userID);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerCoords);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }

        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnPlayerDisconnected));
        }
        #endregion

        #region Player Direction Update
        private void UpdatePlayerCoords()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerCoords());
        }

        private IEnumerator HandleUpdatePlayerCoords()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                string direction = GetDirection(player);
                string previous = _playerDirection[player.userID];
               
                yield return null;
                if (direction == previous)
                {
                    continue;
                }
                
                _playerDirection[player.userID] = direction;
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }

        private string GetDirection(BasePlayer player)
        {
            Vector3 direction = player.eyes.rotation.eulerAngles;
            if (_pluginConfig.ShowAngle)
            {
                return $"{direction.y:0.0}\u00B0";
            }

            if (direction.y > 337.5 || direction.y <= 22.5)
                return LangKeys.North;
            
            if (direction.y > 22.5 && direction.y <= 67.5)
                return LangKeys.Northeast;
            
            if (direction.y > 67.5 && direction.y <= 112.5)
                return LangKeys.East;
            
            if (direction.y > 112.5 && direction.y <= 157.5)
                return LangKeys.Southeast;
            
            if (direction.y > 157.5 && direction.y <= 202.5)
                return LangKeys.South;
            
            if (direction.y > 202.5 && direction.y <= 247.5)
                return LangKeys.Southwest;
            
            if (direction.y > 247.5 && direction.y <= 292.5)
                return LangKeys.West;
            
            return LangKeys.Northwest;
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                string direction =  _playerDirection[player.userID] ?? GetDirection(player);
                if (!_pluginConfig.ShowAngle)
                {
                    direction = Lang(direction, player);
                }
                text.Text = string.Format(_directionText, direction);
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods

        private string Lang(string key, BasePlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Show Angle")]
            public bool ShowAngle { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }
        
        private class LangKeys
        {
            public const string North = "North";
            public const string Northeast = "NorthEast";
            public const string East = "East";
            public const string Southeast = "SouthEast";
            public const string South = "South";
            public const string Southwest = "SouthWest";
            public const string West = "West";
            public const string Northwest = "NorthWest";
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicDirectionPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-area ---
// --- Original File Path: M/MagicArea/MagicArea.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("MagicArea", "Norn", "0.2.1", ResourceId = 1551)]
    [Description("Areas to practice building/pvp.")]
    public class MagicArea : RustPlugin
    {
        [PluginReference] Plugin Kits, MagicTeleportation;

        // -------------- [ SAVING VARIABLES ] --------------

        class MA
        {
            public Dictionary<int, AreaInfo> Areas = new Dictionary<int, AreaInfo>();
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
            public Dictionary<uint, AreaEntities> Entities = new Dictionary<uint, AreaEntities>();
            public MA() { }
        }
        public class AreaEntities
        {
            public uint iID;
            public int iAreaID;
            public ulong uCreatorID;
            public int iCreated;
            public int iExpire;
            public AreaEntities() { }
        }
        class PlayerData
        {
            public ulong uUserID;
            public int iInArea;
            public Int32 iInitStamp;
            public PlayerData() { }
        }
        class SpawnInfo
        {
            public float fX;
            public float fY;
            public float fZ;
            public int iEID;
            public SpawnInfo() { }
        }
        class AreaInfo
        {
            public int iID;
            public string tTitle;
            public string tDescription;
            public float fMinX;
            public float fMinY;
            public float fMinZ;
            public float fRadius;
            public bool uEnabled;
            public bool bGod;
            public bool bResetInv;
            public int iCount;
            public string tKit;
            public bool bCanResearch;
            public bool bRemoveEntities;
            public int iEntityExpire;
            public Dictionary<int, SpawnInfo> Spawns = new Dictionary<int, SpawnInfo>();
            public AreaInfo() { }
        }
        MA MAData;

        #region Localization

        private void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"KitReceived", "[<color=green>INFO:</color>] You have been given kit: <color=yellow>{kit_name}</color> to use inside of <color=yellow>{area_title}</color>."},
                {"InventoryReset", "[<color=green>INFO:</color>] Your inventory has been <color=red>reset</color> because you left an area."},
                {"ResearchBlocked", "[<color=yellow>ERROR</color>] Researching is <color=red>blocked</color> in this area."},
                {"AreaCreated", "[<color=green>INFO:</color>] You have successfully created area id: {area_id}."},
                {"TeleportedBack", "[<color=green>INFO</color>] You have been teleported back to <color=yellow>{area_title}</color>." },
                {"EntityExpiry", "[<color=yellow>INFO</color>] This object will expire at: <color=yellow>{expire_time}</color>!\n(Current Time: <color=yellow>{current_time}</color>)" }
            };
            lang.RegisterMessages(messages, this);
        }
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion
        // -----------------------------------------------

        Timer AreaSync;
        private void OnServerInitialized()
        {
            Puts("Loaded " + MAData.Areas.Count.ToString() + " area(s).");

            // --- [ TIMERS ] ---
            int seconds = Convert.ToInt32(Config["Settings", "TimerInterval"]);
            AreaSync = timer.Repeat(seconds, 0, () => AreaTimer());
            LoadDefaultMessages();
        }

        private void AreaTimer()
        {
            // ==================================== [ ENTITY PORTION ] ==========================================
            new List<uint>(MAData.Entities.Keys).ForEach(u =>
            {
                BaseNetworkable ent = BaseNetworkable.serverEntities.Find(u);
                if (ent != null && UnixTimeStampUTC() >= MAData.Entities[u].iExpire)
                {
                    int area_id = MAData.Entities[u].iAreaID;
                    if (area_id != -1 && MagicAreaExists(area_id))
                    {
                        if (MAData.Areas[area_id].bRemoveEntities && MAData.Areas[area_id].iEntityExpire != 0)
                        {
                            MAData.Entities.Remove(u);
                            ent.Kill();
                            if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Removing entity ID: " + u.ToString() + " [EXPIRED]"); }
                        }
                    }
                }
            });
            // ================================== [ PLAYER ] ====================================================
            foreach (BasePlayer connected_player in BasePlayer.activePlayerList)
            {
                bool found = false;
                if (connected_player != null && connected_player.IsConnected)
                {
                    if (!PlayerExists(connected_player)) { InitPlayer(connected_player); }
                    foreach(var area in MAData.Areas.Values)
                    {
                        if (PlayerToPoint(connected_player, area.fRadius, area.fMinX, area.fMinY, area.fMinZ))
                        {
                            if (MAData.PlayerData[connected_player.userID].iInArea != area.iID)
                            {
                                MAData.PlayerData[connected_player.userID].iInArea = area.iID;
                                Interface.Oxide.CallHook("OnPlayerEnterMagicArea", connected_player, MAData.PlayerData[connected_player.userID].iInArea);
                                if (area.tKit.Length >= 1 && area.tKit != null)
                                {
                                    object iskit = Kits?.Call("isKit", area.tKit);
                                    if (iskit is bool && (bool)iskit)
                                    {
                                        connected_player.inventory.Strip();
                                        object successkit = Kits.Call("GiveKit", connected_player, area.tKit);
                                        if (successkit is bool && (bool)successkit)
                                        {
                                            string parsed_config = GetMessage("KitReceived", connected_player.UserIDString);
                                            parsed_config = parsed_config.Replace("{kit_name}", area.tKit);
                                            parsed_config = parsed_config.Replace("{area_title}", area.tTitle);
                                            PrintToChat(connected_player, parsed_config);
                                        }
                                    }
                                }
                            }
                            found = true;
                        }
                    }
                    if (!found && MAData.PlayerData[connected_player.userID].iInArea != -1)
                    {
                        if (MAData.Areas[MAData.PlayerData[connected_player.userID].iInArea].bResetInv)
                        {
                            PrintToChat(connected_player, GetMessage("InventoryReset", connected_player.UserIDString));
                            connected_player.inventory.Strip();
                        }
                        Interface.Oxide.CallHook("OnPlayerExitMagicArea", connected_player, MAData.PlayerData[connected_player.userID].iInArea);
                        MAData.PlayerData[connected_player.userID].iInArea = -1;
                    }
                }
            }
        }

        private void OnPlayerExitMagicArea(BasePlayer player, int area)
        {
            if (MagicAreaExists(area)) {
                if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts(player.displayName + " has left: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); PrintToChat(player, player.displayName + " has left: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); } }
        }

        private void OnPlayerEnterMagicArea(BasePlayer player, int area)
        {
            if (MagicAreaExists(area)) { if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts(player.displayName + " has entered: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); PrintToChat(player, player.displayName + " has entered: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); } }
        }

        private int CreateMagicArea(Vector3 position, float radius, string title = "-1", string description = "-1", bool enabled = true)
        {
            int id = -1;
            if (position != Vector3.zero)
            {
                AreaInfo Area = new AreaInfo();
                Area.iID = GetRandomNumber(0, 25);
                if (title == "-1") { title = "Area" + Area.iID.ToString(); }
                Area.tTitle = title;
                Area.tDescription = description;
                Area.uEnabled = enabled;
                Area.iCount = 0;
                Area.fMinX = position.x;
                Area.fMinY = position.y;
                Area.fMinZ = position.z;
                Area.fRadius = radius;
                Area.bGod = false;
                Area.tKit = "";
                Area.bCanResearch = false;
                Area.bResetInv = true;
                Area.bRemoveEntities = true;
                Area.iEntityExpire = Convert.ToInt32(Config["Settings", "DefaultExpire"]);
                id = Area.iID;
                MAData.Areas.Add(Area.iID, Area);
                SaveData();
            }
            return id;
        }

        private bool MagicAreaExists(int id)
        {
            AreaInfo item = null;
            if (MAData.Areas.TryGetValue(id, out item)) { return true; }
            return false;
        }

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BaseEntity e = gameObject.ToBaseEntity();
            BasePlayer player = planner.GetOwnerPlayer();
            if (!(e is BaseEntity) || player == null)
            {
                return;
            }
            int id = MAData.PlayerData[player.userID].iInArea;
            if (PlayerExists(player) && id != -1 && MagicAreaExists(id))
            {
                if (MAData.Areas[id].bRemoveEntities && MAData.Areas[id].iEntityExpire != 0)
                {
                    AreaEntities Area = new AreaEntities();
                    Area.iAreaID = id;
                    Area.iCreated = UnixTimeStampUTC();
                    Area.iExpire = Area.iCreated + MAData.Areas[id].iEntityExpire;
                    Area.iID = (uint)e.net.ID;
                    Area.uCreatorID = player.userID;
                    MAData.Entities.Add(Area.iID, Area);
                    if (Convert.ToBoolean(Config["Settings", "Debug"]))
                    {
                        string parsed_config = GetMessage("EntityExpiry", player.UserIDString);
                        parsed_config = parsed_config.Replace("{expire_time}", UnixTimeStampToDateTime(Area.iExpire).ToLongTimeString());
                        parsed_config = parsed_config.Replace("{current_time}", UnixTimeStampToDateTime(UnixTimeStampUTC()).ToLongTimeString());
                        PrintToChat(player, parsed_config);
                    }
                }
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (PlayerExists(player))
                {
                    int id = MAData.PlayerData[player.userID].iInArea;
                    if (id != -1 && MagicAreaExists(id)) { MAData.PlayerData[player.userID].iInArea = -1; }
                }
            }
            else
            {
                uint id = entity.net.ID;
                if (MAData.Entities.ContainsKey(id))
                {
                    if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Destroying entity: " + id.ToString() + ". [DEATH]"); }
                    MAData.Entities.Remove(id);
                }
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            uint id = entity.net.ID;
            if (MAData.Entities.ContainsKey(id))
            {
                if (UnixTimeStampUTC() >= MAData.Entities[id].iExpire)
                {
                    if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Destroying entity: " + id.ToString() + ". [EXPIRED]"); }
                    entity.Kill();
                    MAData.Entities.Remove(id);
                }
            }
        }

        private object OnItemResearch(Item item, BasePlayer player)
        {
            if (PlayerExists(player))
            {
                int id = MAData.PlayerData[player.userID].iInArea;
                if (id != -1 && MagicAreaExists(id)) { if (!MAData.Areas[id].bCanResearch) { PrintToChat(player, GetMessage("ResearchBlocked", player.UserIDString)); return false; } }
            }
            return null;
        }

        // --- [ CONSOLE ] ---

        [ConsoleCommand("area.create")]
        private void ccmdCreateArea(ConsoleSystem.Arg arg)
        {
            if (arg.Connection.authLevel >= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                var player = arg.Connection?.player as BasePlayer;
                if (player == null) return;
                int id = CreateMagicArea(player.transform.position, 50);
                Puts(GetMessage("AreaCreated", player.UserIDString).Replace("{area_id}", id.ToString()));
                PrintToChat(player, GetMessage("AreaCreated", player.UserIDString).Replace("{area_id}", id.ToString()));
            }
        }

        // ------------------

        private object OnPlayerRespawned(BasePlayer player)
        {
            int id = MAData.PlayerData[player.userID].iInArea; bool success = false;
            if (PlayerExists(player) && id != -1 && MagicAreaExists(id))
            {
                if (MAData.Areas[id].Spawns.Count == 0)
                {
                    success = Convert.ToBoolean(MagicTeleportation.CallHook("InitTeleport", player, MAData.Areas[id].fMinX, MAData.Areas[id].fMinY, MAData.Areas[id].fMinZ, false, true, MAData.Areas[id].tTitle, null, 1, 3));
                }
                if (success)
                {
                    string parsed_config = GetMessage("TeleportedBack", player.UserIDString);
                    parsed_config = parsed_config.Replace("{area_title}", MAData.Areas[id].tTitle);
                    PrintToChat(player, parsed_config);
                }
                MAData.PlayerData[player.userID].iInArea = -1;
                return false;
            }
            return null;
        }

        private bool PlayerToPoint(BasePlayer player, float radi, float x, float y, float z)
        {
            float oldposx = 0.0f, oldposy = 0.0f, oldposz = 0.0f, tempposx = 0.0f, tempposy = 0.0f, tempposz = 0.0f;
            oldposx = player.transform.position.x;
            oldposy = player.transform.position.y;
            oldposz = player.transform.position.z;
            tempposx = (oldposx - x);
            tempposy = (oldposy - y);
            tempposz = (oldposz - z);
            if (((tempposx < radi) && (tempposx > -radi)) && ((tempposy < radi) && (tempposy > -radi)) && ((tempposz < radi) && (tempposz > -radi)))
            {
                return true;
            }
            return false;
        }

        private void Loaded()
        {
            MAData = Interface.Oxide.DataFileSystem.ReadObject<MA>(this.Title);
        }

        private void Unload()
        {
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, MAData);
        }

        // ======================== [ PLAYER ] ===========================

        private bool PlayerExists(BasePlayer player)
        {
            PlayerData item = null;
            if (MAData.PlayerData.TryGetValue(player.userID, out item))
            {
                return true;
            }
            return false;
        }

        private bool InitPlayer(BasePlayer player)
        {
            if (!PlayerExists(player))
            {
                PlayerData z = new PlayerData();
                z.uUserID = player.userID;
                z.iInArea = -1;
                z.iInitStamp = UnixTimeStampUTC();
                MAData.PlayerData.Add(z.uUserID, z);
                if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Registering " + player.displayName + " [ " + player.userID.ToString() + " ]."); }
                return true;
            }
            return false;
        }

        // ===============================================================

        private bool IsPlayerInArea(BasePlayer player, float MinX, float MinY, float MaxX, float MaxY)
        {
            if (player != null && player.IsConnected)
            { float X = player.transform.position.x; float Y = player.transform.position.y; float Z = player.transform.position.z; if (X >= MinX && X <= MaxX && Y >= MinY && Y <= MaxY) { return true; } }
            return false;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating..."); Config.Clear();
            Config["Settings", "TimerInterval"] = 1;
            Config["Settings", "Debug"] = false;
            Config["Settings", "DefaultExpire"] = 10800; // 3 hours
            Config["Admin", "MaxLevel"] = 2;
        }

        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (PlayerExists(player))
                {
                    int id = MAData.PlayerData[player.userID].iInArea;
                    if (id != -1 && MagicAreaExists(id))
                    {
                        if (MAData.Areas[id].bGod)
                        {
                            hitInfo.damageTypes.ScaleAll(0f);
                            return hitInfo;
                        }
                    }
                }
            }
            return null;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            return null;
        }

        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }

        public static int GetRandomNumber(int min, int max)
        {
            System.Random r = new System.Random();
            int n = r.Next();
            return n;
        }
    }
}

// --- End of file: MagicArea.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/master-lock ---
// --- Original File Path: M/MasterLock/MasterLock.cs ---

﻿/// <summary>
/// Author: S0N_0F_BISCUIT
/// Permissions:
///		masterlock.toggle - Gives players the ability to use the masterlock command
///		masterlock.doorcontrol - Gives player the ability to use open/close doors commands
///	Chat Commands:
///		/masterlock - Toggles master lock on or off
///		/opendoors - Opens all doors linked with the master lock
///		/closedoors - Closes all doors linked with the master lock
/// </summary>
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("MasterLock", "S0N_0F_BISCUIT", "1.0.2")]
	[Description("Control all locks in a base with the tool cupboard.")]
	class MasterLock : RustPlugin
	{
		#region Variables
		[PluginReference]
		Plugin GameTipAPI;
		/// <summary>
		/// Data saved by the plugin
		/// </summary>
		class StoredData
		{
			public uint seed = 0;
			public Dictionary<uint, bool> buildings { get; set; } = new Dictionary<uint, bool>();
		}

		private StoredData data;
		private bool initialized = false;
		#endregion

		#region Localization
		/// <summary>
		/// Load messages relayed to player
		/// </summary>
		private new void LoadDefaultMessages()
		{
			// English
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoBuildingPrivilege"] = "You are not within a building privilege.",
				["NoAuthorization"] = "You are not authorized in this building privilege.",
				["NoCommandPermission"] = "You do not have permission to use this command!",
				["Disabled"] = "Master lock disabled.",
				["Enabled"] = "Master lock enabled.",
				["CodeUpdate"] = "Updated code for {0} locks.",
				["AddAuthorization"] = "Authorized {0} on {1} lock(s).",
				["RemoveAuthorization"] = "Deauthorized {0} on {1} lock(s).",
				["NotEnabled"] = "Master lock is not enabled.",
				["OpenedDoors"] = "Opened {0} doors.",
				["ClosedDoors"] = "Closed {0} doors.",
				["AddLock"] = "Add a code lock to use master lock.",
				["UseCommand"] = "Use /masterlock to enable master lock"
			}, this);
		}
		#endregion

		#region Initialization
		/// <summary>
		/// Plugin initialization
		/// </summary>
		private void Init()
		{
			// Permissions
			permission.RegisterPermission("masterlock.toggle", this);
			permission.RegisterPermission("masterlock.doorcontrol", this);
			// Data
			LoadData();
		}
		/// <summary>
		/// Restore plugin data when server finishes startup
		/// </summary>
		void OnServerInitialized()
		{
			// Restore data
			FindBuildingPrivileges();
			initialized = true;
		}
		#endregion

		#region Config Handling
		/// <summary>
		/// Load default config file
		/// </summary>
		protected override void LoadDefaultConfig()
		{
			Config["Display Tooltips"] = ConfigValue("Display Tooltips");

			SaveConfig();
		}
		/// <summary>
		/// Get stored config value
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		private object ConfigValue(string value)
		{
			switch (value)
			{
				case "Display Tooltips":
					if (Config[value] == null)
						return true;
					else
						return Config[value];
				default:
					return null;
			}
		}
		#endregion

		#region Data Handling
		/// <summary>
		/// Load plugin data
		/// </summary>
		private void LoadData()
		{
			try
			{
				data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("MasterLock");
			}
			catch
			{
				data = new StoredData();
				SaveData();
			}
		}
		/// <summary>
		/// Save plugin data
		/// </summary>
		private void SaveData()
		{
			Interface.Oxide.DataFileSystem.WriteObject("MasterLock", data);
		}
		/// <summary>
		/// Find all building privileges
		/// </summary>
		private void FindBuildingPrivileges()
		{
			List<uint> delete = new List<uint>();
			foreach (uint id in data.buildings.Keys)
			{
				BaseNetworkable networkable = BaseNetworkable.serverEntities.Find(id);

				if (networkable is BuildingPrivlidge)
				{
					if (data.buildings[id])
						InitializeMasterLock(networkable as BuildingPrivlidge);
				}
				else
					delete.Add(id);
			}
			foreach (uint id in delete)
			{
				data.buildings.Remove(id);
			}
			SaveData();
			Puts($"Implemented {data.buildings.Count} saved master locks.");
		}
		#endregion

		#region Chat Commands
		/// <summary>
		/// Toggle master lock on or off
		/// </summary>
		/// <param name="player"></param>
		/// <param name="command"></param>
		/// <param name="args"></param>
		[ChatCommand("masterlock")]
		void ToggleMasterLock(BasePlayer player, string command, string[] args)
		{
			if (!permission.UserHasPermission(player.UserIDString, "masterlock.toggle") && !player.IsAdmin)
			{
				player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
				return;
			}
			BuildingPrivlidge privilege = player.GetBuildingPrivilege();
			if (!privilege)
			{
				player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
				return;
			}
			if (!privilege.IsAuthed(player))
			{
				player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
				return;
			}

			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
				{
					data.buildings[privilege.net.ID] = false;
					player.ChatMessage(Lang("Disabled", player.UserIDString));
				}
				else
				{
					data.buildings[privilege.net.ID] = true;
					InitializeMasterLock(privilege);
					player.ChatMessage(Lang("Enabled", player.UserIDString));
				}
			}
			else
			{
				data.buildings.Add(privilege.net.ID, true);
				InitializeMasterLock(privilege);
				player.ChatMessage(Lang("Enabled", player.UserIDString));
			}
			SaveData();
		}
		/// <summary>
		/// Open linked doors
		/// </summary>
		/// <param name="player"></param>
		/// <param name="command"></param>
		/// <param name="args"></param>
		[ChatCommand("opendoors")]
		void OpenConnectedDoors(BasePlayer player, string command, string[] args)
		{
			if (!permission.UserHasPermission(player.UserIDString, "masterlock.doorcontrol") && !player.IsAdmin)
			{
				player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
				return;
			}
			BuildingPrivlidge privilege = player.GetBuildingPrivilege();
			if (!privilege)
			{
				player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
				return;
			}
			if (!privilege.IsAuthed(player))
			{
				player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
				return;
			}

			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
					OpenDoors(privilege, player);
				else
					player.ChatMessage(Lang("NotEnabled", player.UserIDString));
			}
			else
			{
				player.ChatMessage(Lang("NotEnabled", player.UserIDString));
			}
		}
		/// <summary>
		/// Close linked doors
		/// </summary>
		/// <param name="player"></param>
		/// <param name="command"></param>
		/// <param name="args"></param>
		[ChatCommand("closedoors")]
		void CloseConnectedDoors(BasePlayer player, string command, string[] args)
		{
			if (!permission.UserHasPermission(player.UserIDString, "masterlock.doorcontrol") && !player.IsAdmin)
			{
				player.ChatMessage(Lang("NoCommandPermission", player.UserIDString));
				return;
			}
			BuildingPrivlidge privilege = player.GetBuildingPrivilege();
			if (!privilege)
			{
				player.ChatMessage(Lang("NoBuildingPrivilege", player.UserIDString));
				return;
			}
			if (!privilege.IsAuthed(player))
			{
				player.ChatMessage(Lang("NoAuthorization", player.UserIDString));
				return;
			}

			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
					CloseDoors(privilege, player);
				else
					player.ChatMessage(Lang("NotEnabled", player.UserIDString));
			}
			else
			{
				player.ChatMessage(Lang("NotEnabled", player.UserIDString));
			}
		}
		#endregion

		#region Hooks
		/// <summary>
		/// Set code on new lock in master lock privilege area
		/// </summary>
		/// <param name="entity"></param>
		void OnEntitySpawned(BaseNetworkable entity)
		{
			if (!initialized)
				return;
			if (entity is CodeLock)
			{
				CodeLock codeLock = entity as CodeLock;
				BuildingPrivlidge privilege = codeLock?.GetBuildingPrivilege();
				if (!privilege)
					return;
				if (data.buildings.ContainsKey(privilege.net.ID))
				{
					if (data.buildings[privilege.net.ID])
					{
						BaseEntity lockEntity = privilege.GetSlot(BaseEntity.Slot.Lock);

						if (lockEntity is CodeLock)
						{
							codeLock.code = (lockEntity as CodeLock).code;
							codeLock.SetFlag(BaseEntity.Flags.Locked, true);
							foreach (ProtoBuf.PlayerNameID player in privilege.authorizedPlayers)
								codeLock.whitelistPlayers.Add(player.userid);
							codeLock.SendNetworkUpdateImmediate();
						}
					}
				}
			}
			else if (entity is BuildingPrivlidge && (bool)Config["Display Tooltips"])
			{
				BasePlayer player = BasePlayer.FindByID((entity as BuildingPrivlidge).OwnerID);
				if (player)
					ShowGameTip(player, Lang("AddLock", player.UserIDString));
			}
		}
		/// <summary>
		/// Authorize player on all locks following master lock
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		/// <returns></returns>
		object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
		{
			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
					AddAuthorization(privilege, player, player);
			}
			return null;
		}
		/// <summary>
		/// Clear authorization list on all locks following the master lock
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		/// <returns></returns>
		object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
		{
			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
					ClearAuthorizations(privilege);
			}
			return null;
		}
		/// <summary>
		/// Deauthorize player on all locks following master lock
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		/// <returns></returns>
		object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
		{
			if (data.buildings.ContainsKey(privilege.net.ID))
			{
				if (data.buildings[privilege.net.ID])
					RemoveAuthorization(privilege, player);
			}
			return null;
		}
		/// <summary>
		/// Update the code on all locks following the master lock
		/// </summary>
		/// <param name="codeLock"></param>
		/// <param name="player"></param>
		/// <param name="newCode"></param>
		/// <param name="isGuestCode"></param>
		void CanChangeCode(CodeLock codeLock, BasePlayer player, string newCode, bool isGuestCode)
		{
			if (codeLock.GetParentEntity() is BuildingPrivlidge)
			{
				BuildingPrivlidge privilege = codeLock.GetParentEntity() as BuildingPrivlidge;
				if (data.buildings.ContainsKey(privilege.net.ID))
				{
					if (data.buildings[privilege.net.ID] && !isGuestCode)
					{
						uint count = UpdateCode(privilege, newCode);
						player.ChatMessage(Lang("CodeUpdate", player.UserIDString, count));
					}
					else if (!data.buildings[privilege.net.ID] && !isGuestCode && (bool)Config["Display Tooltips"])
						ShowGameTip(BasePlayer.FindByID(privilege.OwnerID), Lang("UseCommand", player.UserIDString));
				}
				else if ((bool)Config["Display Tooltips"])
					ShowGameTip(BasePlayer.FindByID(privilege.OwnerID), Lang("UseCommand", player.UserIDString));
			}
		}
		#endregion

		#region Helpers
		/// <summary>
		/// Get string and format from lang file
		/// </summary>
		/// <param name="key"></param>
		/// <param name="userId"></param>
		/// <param name="args"></param>
		/// <returns></returns>
		private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);
		/// <summary>
		/// Initialize locks in a building
		/// </summary>
		/// <param name="privilege"></param>
		private void InitializeMasterLock(BuildingPrivlidge privilege)
		{
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				string code = (baseLock as CodeLock).code;

				BuildingManager.Building building = privilege.GetBuilding();
				foreach (BuildingBlock block in building.buildingBlocks)
				{
					if (block.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (block.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (!codeLock.IsLocked())
						{
							codeLock.code = code;
							codeLock.SetFlag(BaseEntity.Flags.Locked, true);
							foreach (ProtoBuf.PlayerNameID player in privilege.authorizedPlayers)
								codeLock.whitelistPlayers.Add(player.userid);
							codeLock.SendNetworkUpdateImmediate();
						}
					}
				}
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (!codeLock.IsLocked())
						{
							codeLock.code = code;
							codeLock.SetFlag(BaseEntity.Flags.Locked, true);
							foreach (ProtoBuf.PlayerNameID player in privilege.authorizedPlayers)
								codeLock.whitelistPlayers.Add(player.userid);
							codeLock.SendNetworkUpdateImmediate();
						}
					}
				}
			}
		}
		/// <summary>
		/// Add player to lock's whitelist
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		void AddAuthorization(BuildingPrivlidge privilege, BasePlayer player, BasePlayer caller)
		{
			uint authCount = 0;
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (BuildingBlock block in building.buildingBlocks)
				{
					if (block.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (block.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Add(player.userID);
							codeLock.SendNetworkUpdateImmediate();
							authCount++;
						}
					}
				}
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Add(player.userID);
							codeLock.SendNetworkUpdateImmediate();
							authCount++;
						}
					}
				}
				if (authCount > 0)
					caller.ChatMessage(Lang("AddAuthorization", caller.UserIDString, player.displayName, authCount));
			}
		}
		/// <summary>
		/// Remove player from lock's whitelist
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		void RemoveAuthorization(BuildingPrivlidge privilege, BasePlayer player)
		{
			uint deauthCount = 0;
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (BuildingBlock block in building.buildingBlocks)
				{
					if (block.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (block.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Remove(player.userID);
							codeLock.SendNetworkUpdateImmediate();
							deauthCount++;
						}
					}
				}
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Remove(player.userID);
							codeLock.SendNetworkUpdateImmediate();
							deauthCount++;
						}
					}
				}
				if (deauthCount > 0)
					player.ChatMessage(Lang("RemoveAuthorization", player.UserIDString, player.displayName, deauthCount));
			}
		}
		/// <summary>
		/// Clear lock's whitelist
		/// </summary>
		/// <param name="privilege"></param>
		void ClearAuthorizations(BuildingPrivlidge privilege)
		{
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (BuildingBlock block in building.buildingBlocks)
				{
					if (block.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (block.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Clear();
							codeLock.SendNetworkUpdateImmediate();
						}
					}
				}
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code)
						{
							codeLock.whitelistPlayers.Clear();
							codeLock.SendNetworkUpdateImmediate();
						}
					}
				}
			}
		}
		/// <summary>
		/// Update all locks following the master lock
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="newCode"></param>
		private uint UpdateCode(BuildingPrivlidge privilege, string newCode)
		{
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);
			uint codeLocks = 0;
			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (BuildingBlock block in building.buildingBlocks)
				{
					if (block.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (block.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code && masterLock != codeLock)
						{
							codeLock.code = newCode;
							codeLock.SendNetworkUpdateImmediate();
							codeLocks++;
						}
					}
				}
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code && masterLock != codeLock)
						{
							codeLock.code = newCode;
							codeLock.SendNetworkUpdateImmediate();
							codeLocks++;
						}
					}
				}
			}
			return codeLocks;
		}
		/// <summary>
		/// Open all linked doors in the building
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		private void OpenDoors(BuildingPrivlidge privilege, BasePlayer player)
		{
			uint doorCount = 0;
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock && entity is Door)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code && masterLock != codeLock)
						{
							if (!(entity as Door).HasFlag(BaseEntity.Flags.Open))
							{
								(entity as Door).SetFlag(BaseEntity.Flags.Open, true);
								(entity as Door).SendNetworkUpdate();
								doorCount++;
							}
						}
					}
				}
				player.ChatMessage(Lang("OpenedDoors", player.UserIDString, doorCount));
			}
		}
		/// <summary>
		/// Close all linked doors in the building
		/// </summary>
		/// <param name="privilege"></param>
		/// <param name="player"></param>
		private void CloseDoors(BuildingPrivlidge privilege, BasePlayer player)
		{
			uint doorCount = 0;
			BaseEntity baseLock = privilege.GetSlot(BaseEntity.Slot.Lock);

			if (baseLock is CodeLock)
			{
				CodeLock masterLock = baseLock as CodeLock;
				BuildingManager.Building building = privilege.GetBuilding();
				foreach (DecayEntity entity in building.decayEntities)
				{
					if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock && entity is Door)
					{
						CodeLock codeLock = (entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock);
						if (masterLock.code == codeLock.code && masterLock != codeLock)
						{
							if ((entity as Door).HasFlag(BaseEntity.Flags.Open))
							{
								(entity as Door).SetFlag(BaseEntity.Flags.Open, false);
								(entity as Door).SendNetworkUpdate();
								doorCount++;
							}
						}
					}
				}
				player.ChatMessage(Lang("ClosedDoors", player.UserIDString, doorCount));
			}
		}
		/// <summary>
		/// Display a game tip to the given player
		/// </summary>
		/// <param name="player"></param>
		/// <param name="tip"></param>
		private void ShowGameTip(BasePlayer player, string tip)
		{
			if (player == null)
				return;

			if (GameTipAPI)
				GameTipAPI.CallHook("ShowGameTip", player, tip, 5f);
			else
			{
				player.SendConsoleCommand("gametip.hidegametip");
				player.SendConsoleCommand("gametip.showgametip", tip);
				timer.Once(5f, () => player?.SendConsoleCommand("gametip.hidegametip"));
			}
		}
		#endregion
	}
}


// --- End of file: MasterLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-grid-panel ---
// --- Original File Path: M/MagicGridPanel/MagicGridPanel.cs ---

﻿using System;
using System.Collections;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins;

[Info("Magic Grid Panel", "MJSU", "1.0.8")]
[Description("Displays players grid position in magic panel")]
public class MagicGridPanel : RustPlugin
{
    #region Class Fields

    [PluginReference] private Plugin MagicPanel;

    private PluginConfig _pluginConfig; //Plugin Config

    private string _gridText;

    private readonly Hash<ulong, Vector2i> _playersGrid = new();
    private readonly Hash<Vector2i, string> _gridToString = new();

    private Coroutine _updateRoutine;

    private enum UpdateEnum
    {
        All = 1,
        Panel = 2,
        Image = 3,
        Text = 4
    }

    #endregion

    #region Setup & Loading

    private void Init()
    {
        _gridText = _pluginConfig.Panel.Text.Text;
    }

    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
        DynamicConfigFile newConfig = new(path);
        if (!newConfig.Exists())
        {
            LoadDefaultConfig();
            newConfig.Save();
        }

        try
        {
            newConfig.Load();
        }
        catch (Exception ex)
        {
            RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
            return;
        }

        newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
        newConfig.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        config.Panel = new Panel
        {
            Image = new PanelImage
            {
                Enabled = config.Panel?.Image?.Enabled ?? true,
                Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                Order = config.Panel?.Image?.Order ?? 0,
                Width = config.Panel?.Image?.Width ?? 0.2f,
                Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/mZXqLRLy/ENHIFZl.png",
                Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.01f, 0.00f, 0.1f, 0.1f)
            },
            Text = new PanelText
            {
                Enabled = config.Panel?.Text?.Enabled ?? true,
                Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",
                Order = config.Panel?.Text?.Order ?? 1,
                Width = config.Panel?.Text?.Width ?? .8f,
                FontSize = config.Panel?.Text?.FontSize ?? 14,
                Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.01f, 0.01f, 0.05f, 0.05f),
                TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                Text = config.Panel?.Text?.Text ?? "{0}"
            }
        };
        config.PanelSettings = new PanelRegistration
        {
            BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
            Dock = config.PanelSettings?.Dock ?? "leftbottom",
            Order = config.PanelSettings?.Order ?? 3,
            Width = config.PanelSettings?.Width ?? 0.05f
        };
        return config;
    }

    private void OnServerInitialized()
    {
        MagicPanelRegisterPanels();
    }

    private void MagicPanelRegisterPanels()
    {
        if (MagicPanel == null)
        {
            PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
            UnsubscribeAll();
            return;
        }

        MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        InvokeHandler.Instance.InvokeRepeating(UpdatePlayerCoords, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
    }

    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
        _playersGrid.Remove(player.userID);
    }

    private void Unload()
    {
        InvokeHandler.Instance.CancelInvoke(UpdatePlayerCoords);
        if (_updateRoutine != null)
        {
            InvokeHandler.Instance.StopCoroutine(_updateRoutine);
        }
    }

    private void UnsubscribeAll()
    {
        Unsubscribe(nameof(OnPlayerDisconnected));
    }

    #endregion

    #region Player Coords Update

    private void UpdatePlayerCoords()
    {
        _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerCoords());
    }

    private IEnumerator HandleUpdatePlayerCoords()
    {
        for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
        {
            BasePlayer player = BasePlayer.activePlayerList[i];
            Vector2i grid = MapHelper.PositionToGrid(player.transform.position);
            Vector2i previous = _playersGrid[player.userID];

            yield return null;
            if (grid == previous)
            {
                continue;
            }

            _playersGrid[player.userID] = grid;
            MagicPanel?.Call("UpdatePanel", player, Name, (int) UpdateEnum.Text);
        }
    }
    #endregion

    #region MagicPanel Hook

    private Hash<string, object> GetPanel(BasePlayer player)
    {
        Panel panel = _pluginConfig.Panel;
        PanelText text = panel.Text;
        if (text != null)
        {
            text.Text = string.Format(_gridText, GetGrid(_playersGrid[player.userID]));
        }

        return panel.ToHash();
    }

    public string GetGrid(Vector2i grid)
    {
        string gridString = _gridToString[grid];
        if (string.IsNullOrEmpty(gridString))
        {
            _gridToString[grid] = gridString = MapHelper.GridToString(grid);
        }

        return gridString;
    }
 
    #endregion

    #region Classes

    private class PluginConfig
    {
        [DefaultValue(5f)]
        [JsonProperty(PropertyName = "Update Rate (Seconds)")]
        public float UpdateRate { get; set; }

        [JsonProperty(PropertyName = "Panel Settings")]
        public PanelRegistration PanelSettings { get; set; }

        [JsonProperty(PropertyName = "Panel Layout")]
        public Panel Panel { get; set; }
    }

    private class PanelRegistration
    {
        public string Dock { get; set; }
        public float Width { get; set; }
        public int Order { get; set; }
        public string BackgroundColor { get; set; }
    }

    private class Panel
    {
        public PanelImage Image { get; set; }
        public PanelText Text { get; set; }

        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Image)] = Image.ToHash(),
                [nameof(Text)] = Text.ToHash()
            };
        }
    }

    private abstract class PanelType
    {
        public bool Enabled { get; set; }
        public string Color { get; set; }
        public int Order { get; set; }
        public float Width { get; set; }
        public TypePadding Padding { get; set; }

        public virtual Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Enabled)] = Enabled,
                [nameof(Color)] = Color,
                [nameof(Order)] = Order,
                [nameof(Width)] = Width,
                [nameof(Padding)] = Padding.ToHash(),
            };
        }
    }

    private class PanelImage : PanelType
    {
        public string Url { get; set; }

        public override Hash<string, object> ToHash()
        {
            Hash<string, object> hash = base.ToHash();
            hash[nameof(Url)] = Url;
            return hash;
        }
    }

    private class PanelText : PanelType
    {
        public string Text { get; set; }
        public int FontSize { get; set; }

        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor TextAnchor { get; set; }

        public override Hash<string, object> ToHash()
        {
            Hash<string, object> hash = base.ToHash();
            hash[nameof(Text)] = Text;
            hash[nameof(FontSize)] = FontSize;
            hash[nameof(TextAnchor)] = TextAnchor;
            return hash;
        }
    }

    private class TypePadding
    {
        public float Left { get; set; }
        public float Right { get; set; }
        public float Top { get; set; }
        public float Bottom { get; set; }

        public TypePadding(float left, float right, float top, float bottom)
        {
            Left = left;
            Right = right;
            Top = top;
            Bottom = bottom;
        }

        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Left)] = Left,
                [nameof(Right)] = Right,
                [nameof(Top)] = Top,
                [nameof(Bottom)] = Bottom
            };
        }
    }

    #endregion
}

// --- End of file: MagicGridPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-snowmobile ---
// --- Original File Path: M/MySnowmobile/MySnowmobile.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("My Snowmobile", "MasterSplinter", "1.0.3")]
    [Description("Let players purchase Tomaha or skin to via command, also allows for Snowmobile to go fast anywhere!")]
    class MySnowmobile : RustPlugin
    {
        private bool debug = false;
        private string debugversion = "0.0.2";

        string Prefix = "My Snowmobile: ";       // CHAT PLUGIN PREFIX
        string PrefixColor = "#FF8552";          // CHAT PLUGIN PREFIX COLOR
        ulong SteamIDIcon = 76561199242793911;   //  STEAMID created for this plugin 76561199133165664

        private readonly string UseSkinPerm = "mysnowmobile.useskin_command";
        private readonly string UseBuyPerm = "mysnowmobile.usebuy_command";
        private List<VehicleCache> vehicles = new List<VehicleCache>();
        private List<BasePlayer> cooldown = new List<BasePlayer>();

        #region DataFile/Classes

        public class VehicleCache
        {
            public BaseEntity entity;
        }

        private class StoredData
        {
            public Dictionary<ulong, int> CurrentFuel = new Dictionary<ulong, int>();

            public StoredData()
            {
            }
        }

        StoredData storedData;

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject($"{this.Name}\\{this.Name}_Data", storedData);

        #endregion

        #region Config

         private class ConfigFile
         {
             [JsonProperty(PropertyName = "Main Settings")]
             public MainSettings Main = new MainSettings();
             [JsonProperty(PropertyName = "Advance Settings")]
             public AdvanceSettings Advance = new AdvanceSettings();

         }

         public class MainSettings
         {
             [JsonProperty("Allow Snowmobile's to goes fast on all terrain types")]
             public bool AllTerrain = false;
             [JsonProperty("Allow Snowmobile's to have more power")]
             public bool IncreasedPower = false;
             [JsonProperty("The amount of power to give in KW (59KW is default)")]
             public int PowerKW = 59;
             [JsonProperty("The amount of Scrap to charge for a Snowmobile")]
             public int BuyCost = 500;
             [JsonProperty("The amount of fuel to give on purchase")]
             public int FuelOnBuy = 50;
            [JsonProperty("The amount of seconds in between purchase (0 = Instant)")]
            public int CooldownTime = 30;
         }

        public class AdvanceSettings
        {
            [JsonProperty("Tomaha Location")]
            public string Tomaha = "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab";
            [JsonProperty("Spray Cloud Location")]
            public string SprayCloudEffect = "assets/prefabs/tools/spraycan/reskineffect.prefab";
            [JsonProperty("Spray Sound Location")]
            public string SpraySoundEffect = "assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab";
        }

        private ConfigFile config;

         protected override void LoadDefaultConfig()
         {
             PrintWarning("Creating new config file");
             config = new ConfigFile();
             SaveConfig();
         }

         #endregion

        #region Setup

        private void OnServerInitialized(bool isStartup) 
        {
            RegisterCommands();
            RegisterPermissions();
            storedData.CurrentFuel.Clear();
            SaveData();
            ProcessExistingSnowmobile();

            if (debug) PrintWarning($"Debug Version: {debugversion}");
        }

        private void RegisterCommands()
        {
            foreach (var command in Commands)
                AddCovalenceCommand(command.Key, command.Value);
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission(UseBuyPerm, this);
            permission.RegisterPermission(UseSkinPerm, this);
        }

        private void Init()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{this.Name}\\{this.Name}_Data");
            config = Config.ReadObject<ConfigFile>();
            NextTick(() => Config.WriteObject(config));
        }

        private void Unload()
        {
            RevertExistingSnowmobile();
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"Not_Enough_Scrap", "[#e0e0e0]You don't have enough scrap to purchase a Tomaha. Cost:[/#]"},
                {"Buy_succes_tomaha", "[#e0e0e0]You have successfully bought a[/#] [#ffe479]Tomaha.[/#]"},
                {"Buy_cooldown_tomaha", "[#e0e0e0]You have to wait before buying another Tomaha. Wait Time:[/#]"},
                {"notlooking_item", "[#e0e0e0]You need to look at a Snowmobile to skin![/#]"},
                {"mysnowmobile_help", "\n[#eeeeee]<size=14>Available Commands:</size>[/#]\n[#ffe479]/skinsnowmobile[/#] [#e0e0e0]- Display Help[/#]\n[#ffe479]/buysnowmobile <Available Skins>[/#] [#e0e0e0]- buy a Snowmobile[/#]\n[#ffe479]/skinsnowmobile <Available Skins>[/#] [#e0e0e0]- Skin a Snowmobile[/#]\n \n[#ffd479]<size=14>Available Skins:</size>[/#]\n[#ffe479]\"tomaha\"[/#] [#e0e0e0]- Tomaha Snowmobile[/#]\n \n[#73c2fa]<size=14>Example:</size>[/#]\n[#ffe479]/skinsnowmobile tomaha[/#] [#e0e0e0]- This will skin to a Tomaha[/#]"},
                {"Skin_succes_tomaha", "[#e0e0e0]You have successfully skinned to a[/#] [#ffe479]Tomaha.[/#]"},
                {"already_tomaha", "[#e0e0e0]This Snowmobile is already skinned to a[/#] [#ffe479]Tomaha![/#]"},
                {"snowmobile_damage", "[#e0e0e0]This Snowmobile is damaged! Repair it to skin[/#]"},
                {"NoPermMsg", "[#e0e0e0]You are not allowed to use this command[/#]"},

            }, this);
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(BaseMountable entity)
        {
            var snowmobile = entity.GetComponentInParent<Snowmobile>() ?? null;

            if (snowmobile == null) return;

            if (snowmobile != null)
            {
                if (config.Main.AllTerrain == true) AllTerrain(snowmobile);

                if (config.Main.IncreasedPower == true) IncreasedPower(snowmobile);
            }
        }

        #endregion

        #region Methods

        #region Fuel

        public int GetFuelAmount(VehicleCache vehicle)
        {
            if (vehicle.entity is Snowmobile)
            {
                return (vehicle.entity as Snowmobile)?.GetFuelSystem()?.GetFuelAmount() ?? 0;
            }

            return 0;
        }

        private void LogFuelAmount(BasePlayer player, VehicleCache vehicle)
        {
            if (player == null) return;

            storedData.CurrentFuel.Add(player.userID, GetFuelAmount(vehicle));
            SaveData();
        }

        private void RemoveLoggedFuel(BasePlayer player, VehicleCache vehicle)
        {
            if (player == null) return;

            timer.Once(1, () =>
            {
                storedData.CurrentFuel.Remove(player.userID);
                SaveData();
            });
        }

        private void AddFuel(Snowmobile snowmobile, string userId)
        {
            if (snowmobile is Snowmobile)
            {
                ulong UserID = Convert.ToUInt64(userId);
                var fuelAmount = storedData.CurrentFuel[UserID];

                StorageContainer fuelContainer = snowmobile.GetFuelSystem().GetFuelContainer();
                if (fuelAmount < 0)
                {
                    fuelAmount = fuelContainer.allowedItem.stackable;
                }
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);

            }
        }

        private void AddFuelOnBuy(Snowmobile snowmobile)
        {
            if (snowmobile is Snowmobile)
            {
                var fuelAmount = config.Main.FuelOnBuy;

                StorageContainer fuelContainer = snowmobile.GetFuelSystem().GetFuelContainer();
                if (fuelAmount < 0)
                {
                    fuelAmount = fuelContainer.allowedItem.stackable;
                }
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);

            }
        }

        #endregion

        #region Skinning / Buying

        private BaseEntity GetLookAtEntity(BasePlayer player, float maxDist = 10f)
        {
            if (player == null || player.IsDead()) return null;
            RaycastHit hit;
            var ray = player.eyes.HeadRay();
            if (Physics.Raycast(ray, out hit, maxDist))
            {
                var ent = hit.GetEntity() ?? null;
                if (ent != null && !(ent?.IsDestroyed ?? true)) return ent;
            }

            return null;
        }

        private void SkinSnowmobile(IPlayer p, VehicleCache vehicle, Vector3 customPosition = default(Vector3), bool useCustomPosition = false)
        {
            BasePlayer player = p.Object as BasePlayer;

            var position = useCustomPosition ? customPosition : GetPosition(player);
            var rotation = useCustomPosition ? Quaternion.identity : GetRotation(player);

            Snowmobile snowmobile = GameManager.server.CreateEntity(config.Advance.Tomaha, position, rotation) as Snowmobile;

            if (snowmobile == null) return;

            snowmobile.Spawn();
            SprayEffect(player);

            AddFuel(snowmobile, player.UserIDString);

            RemoveLoggedFuel(player, vehicle);

            Player.Message(player, $"{lang.GetMessage("Skin_succes_tomaha", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
        }

        private void BuyTomaha(IPlayer p, Vector3 customPosition = default(Vector3), bool useCustomPosition = false)
        {
            BasePlayer player = p.Object as BasePlayer;

            var position = useCustomPosition ? customPosition : GetPosition(player);
            var rotation = useCustomPosition ? Quaternion.identity : GetRotation(player);

            Snowmobile snowmobile = GameManager.server.CreateEntity(config.Advance.Tomaha, position, rotation) as Snowmobile;

            if (snowmobile == null) return;

            snowmobile.Spawn();
            SprayEffect(player);

            AddFuelOnBuy(snowmobile);

            cooldown.Add(player);
            timer.Once(config.Main.CooldownTime, () =>
            {
                cooldown.Remove(player);
            });

            Player.Message(player, $"{lang.GetMessage("Buy_succes_tomaha", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
        }

        void SprayEffect(BasePlayer player, Vector3 customPosition = default(Vector3), bool useCustomPosition = false)
        {
            if (player != null)
            {
                var position = useCustomPosition ? customPosition : GetPosition(player);

                Effect.server.Run(config.Advance.SprayCloudEffect, position, new Vector3());
                Effect.server.Run(config.Advance.SpraySoundEffect, player.transform.position, new Vector3());
            }
        }

        private bool IsDamagedEntity(BaseEntity entity)
        {
            var baseCombatEntity = entity as BaseCombatEntity;
            if (baseCombatEntity == null || !baseCombatEntity.repair.enabled)
            {
                return false;
            }
            if (baseCombatEntity.healthFraction * 100f >= 100)
            {
                return false;
            }
            return true;
        }

        private Vector3 GetPosition(BasePlayer player)
        {
            Vector3 forward = player.GetNetworkRotation() * Vector3.forward;
            forward.y = 0;
            return player.transform.position + forward.normalized * 3f + Vector3.up * 2f;
        }

        private Quaternion GetRotation(BasePlayer player) =>
            Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - 135, 0);

        #endregion

        #region Snowmobile Attributes

        private void IncreasedPower(Snowmobile snowmobile)
        {
            snowmobile.engineKW = config.Main.PowerKW;
        }

        private void AllTerrain(Snowmobile snowmobile)
        {
            Snowmobile.allTerrain = true;
        }

        private void RevertToStock(Snowmobile snowmobile)
        {
            Snowmobile.allTerrain = false;
            snowmobile.engineKW = 59;
        }

        private void ProcessExistingSnowmobile()
        {
            var SnowmobileList = BaseNetworkable.serverEntities.OfType<Snowmobile>();
            foreach (var snowmobile in SnowmobileList)
            {
                if (config.Main.AllTerrain == true) AllTerrain(snowmobile);

                if (config.Main.IncreasedPower == true) IncreasedPower(snowmobile);
            }
        }

        private void RevertExistingSnowmobile()
        {
            var SnowmobileList = BaseNetworkable.serverEntities.OfType<Snowmobile>();
            foreach (var snowmobile in SnowmobileList)
            {
                RevertToStock(snowmobile);
            }
        }

        #endregion

        #endregion

        #region Chat Command

        private Dictionary<string, string> Commands = new Dictionary<string, string>
        {
            { "skinsnowmobile", "SkinSnowmobileCmd" },
            { "buysnowmobile", "BuySnowmobileCmd" }
        };

        private void SkinSnowmobileCmd(IPlayer p, string command, string[] args)
        {
            BasePlayer player = p.Object as BasePlayer;
            BaseEntity hitEnt = GetLookAtEntity(player);
            VehicleCache vehicle = new VehicleCache
            {
                entity = hitEnt,
            };

            if (player == null) return;

            if (p.HasPermission(UseSkinPerm) == false)
            {
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Title}</color>", SteamIDIcon);
                return;
            }

            if (args.Length < 1)
            {
                Player.Message(player, $"{lang.GetMessage("mysnowmobile_help", this, player.UserIDString)}", $"<color={PrefixColor}>{Title}</color>", SteamIDIcon);
                return;
            }

            switch (args[0].ToLower())
            {
                case "tomaha":
                    {
                        if (hitEnt == null)
                        {
                            p.Reply(lang.GetMessage("notlooking", this, p.Id));
                            return;
                        }
                        else if (vehicle.entity.name.Contains("tomaha"))
                        {
                            Player.Message(player, $"{lang.GetMessage("already_tomaha", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }
                        else if (vehicle.entity is Snowmobile && IsDamagedEntity(vehicle.entity))
                        {
                            Player.Message(player, $"{lang.GetMessage("snowmobile_damage", this, player.UserIDString)}", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                        }
                        else if (vehicle.entity is Snowmobile)
                        {
                            vehicles.Add(vehicle);
                            LogFuelAmount(player, vehicle);
                            vehicle.entity.Kill();
                            SkinSnowmobile(p, vehicle);
                        }
                        return;
                    }
            }
        }

        private void BuySnowmobileCmd(IPlayer p, string command, string[] args)
        {
            BasePlayer player = p.Object as BasePlayer;

            if (player == null) return;

            if (p.HasPermission(UseBuyPerm) == false)
            {
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}", $"<color={PrefixColor}>{Title}</color>", SteamIDIcon);
                return;
            }

            if (args.Length < 1)
            {
                Player.Message(player, $"{lang.GetMessage("mysnowmobile_help", this, player.UserIDString)}", $"<color={PrefixColor}>{Title}</color>", SteamIDIcon);
                return;
            }

            switch (args[0].ToLower())
            {
                case "tomaha":
                    {
                        if (player.inventory.GetAmount(-932201673) >= config.Main.BuyCost)
                        {
                            if (cooldown.Contains(player))
                            {
                                Player.Message(player, $"{lang.GetMessage("Buy_cooldown_tomaha", this, player.UserIDString)} <color=#ffe479>{config.Main.CooldownTime}</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                                return;
                            }

                            player.inventory.Take(null, -932201673, config.Main.BuyCost);
                            BuyTomaha(p);
                            return;
                        }
                        else
                        {
                            Player.Message(player, $"{lang.GetMessage("Not_Enough_Scrap", this, player.UserIDString)} <color=#ffe479>{config.Main.BuyCost}</color>", $"<color={PrefixColor}>{Prefix}</color>", SteamIDIcon);
                            return;
                        }
                    }
            }
        }

        #endregion
    }
}


// --- End of file: MySnowmobile.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-addons ---
// --- Original File Path: M/MonumentAddons/MonumentAddons.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins.MonumentAddonsExtensions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using UnityEngine;
using static IOEntity;
using static WireTool;
using Component = UnityEngine.Component;
using HumanNPCGlobal = global::HumanNPC;
using SkullTrophyGlobal = global::SkullTrophy;

using CustomInitializeCallback = System.Func<BasePlayer, string[], object>;
using CustomInitializeCallbackV2 = System.Func<BasePlayer, string[], System.ValueTuple<bool, object>>;
using CustomEditCallback = System.Func<BasePlayer, string[], UnityEngine.Component, Newtonsoft.Json.Linq.JObject, System.ValueTuple<bool, object>>;
using CustomSpawnCallback = System.Func<UnityEngine.Vector3, UnityEngine.Quaternion, Newtonsoft.Json.Linq.JObject, UnityEngine.Component>;
using CustomSpawnCallbackV2 = System.Func<System.Guid, UnityEngine.Component, UnityEngine.Vector3, UnityEngine.Quaternion, Newtonsoft.Json.Linq.JObject, UnityEngine.Component>;
using CustomCheckSpaceCallback = System.Func<UnityEngine.Vector3, UnityEngine.Quaternion, Newtonsoft.Json.Linq.JObject, bool>;
using CustomKillCallback = System.Action<UnityEngine.Component>;
using CustomUnloadCallback = System.Action<UnityEngine.Component>;
using CustomUpdateCallback = System.Action<UnityEngine.Component, Newtonsoft.Json.Linq.JObject>;
using CustomUpdateCallbackV2 = System.Func<UnityEngine.Component, Newtonsoft.Json.Linq.JObject, UnityEngine.Component>;
using CustomDisplayCallback = System.Action<UnityEngine.Component, Newtonsoft.Json.Linq.JObject, System.Text.StringBuilder>;
using CustomDisplayCallbackV2 = System.Action<UnityEngine.Component, Newtonsoft.Json.Linq.JObject, BasePlayer, System.Text.StringBuilder, float>;
using CustomSetDataCallback = System.Action<UnityEngine.Component, object>;

using Tuple1 = System.ValueTuple<object>;
using Tuple2 = System.ValueTuple<object, object>;
using Tuple3 = System.ValueTuple<object, object, object>;
using Tuple4 = System.ValueTuple<object, object, object, object>;

namespace Oxide.Plugins
{
    [Info("Monument Addons", "WhiteThunder", "0.18.4")]
    [Description("Allows adding entities, spawn points and more to monuments.")]
    internal class MonumentAddons : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin CopyPaste, CustomVendingSetup, EntityScaleManager, MonumentFinder, SignArtist;

        private MonumentAddons _plugin;
        private Configuration _config;
        private StoredData _data;
        private ProfileStateData _profileStateData;

        private const float MaxRaycastDistance = 100;
        private const float TerrainProximityTolerance = 0.001f;
        private const float MaxFindDistanceSquared = 4;
        private const float ShowVanillaDuration = 60;

        private const string PermissionAdmin = "monumentaddons.admin";

        private const string WireToolPlugEffect = "assets/prefabs/tools/wire/effects/plugeffect.prefab";

        private const string CargoShipPrefab = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string CargoShipShortName = "cargoshiptest";
        private const string DefaultProfileName = "Default";
        private const string DefaultUrlPattern = "https://github.com/WheteThunger/MonumentAddons/blob/master/Profiles/{0}.json?raw=true";

        private static readonly int HitLayers = Rust.Layers.Solid
            | Rust.Layers.Mask.Water
            | Rust.Layers.Mask.Vehicle_World;

        private static readonly Dictionary<string, string> JsonRequestHeaders = new Dictionary<string, string>
        {
            { "Content-Type", "application/json" }
        };

        private static readonly Dictionary<string, string> OfficialProfileNames = new string[]
            {
                "BarnAirwolf",
                "CargoShipCCTV",
                "FishingVillageAirwolf",
                "MonumentCooking",
                "MonumentLifts",
                "MonumentsRecycler",
                "OilRigSharks",
                "OutpostAirwolf",
                "OutpostExtended",
                "SafeZoneRecyclers",
                "TrainStationCCTV",
            }
            .ToDictionary(name => name, name => name, StringComparer.OrdinalIgnoreCase);

        private readonly HookCollection _dynamicMonumentHooks;
        private readonly ProfileStore _profileStore = new ProfileStore();
        private readonly OriginalProfileStore _originalProfileStore = new OriginalProfileStore();
        private readonly ProfileManager _profileManager;
        private readonly CoroutineManager _coroutineManager = new CoroutineManager();
        private readonly AddonComponentTracker _componentTracker = new AddonComponentTracker();
        private readonly AdapterListenerManager _adapterListenerManager;
        private readonly ControllerFactory _controllerFactory;
        private readonly CustomAddonManager _customAddonManager;
        private readonly CustomMonumentManager _customMonumentManager;
        private readonly UniqueNameRegistry _uniqueNameRegistry = new UniqueNameRegistry();
        private readonly AdapterDisplayManager _adapterDisplayManager;
        private readonly MonumentHelper _monumentHelper;
        private readonly WireToolManager _wireToolManager;
        private readonly IOManager _ioManager = new IOManager();
        private readonly UndoManager _undoManager = new UndoManager();

        private readonly ValueRotator<Color> _colorRotator = new(
            Color.HSVToRGB(0, 1, 1),
            Color.HSVToRGB(0.1f, 1, 1),
            Color.HSVToRGB(0.2f, 1, 1),
            Color.HSVToRGB(0.35f, 1, 1),
            Color.HSVToRGB(0.55f, 1, 1),
            Color.HSVToRGB(0.8f, 1, 1),
            new Color(1, 1, 1)
        );

        private readonly object True = true;
        private readonly object False = false;

        private ItemDefinition _waterDefinition;
        private ProtectionProperties _immortalProtection;
        private ActionDebounced _saveProfileStateDebounced;
        private StringBuilder _sb = new StringBuilder();
        private HashSet<string> _deployablePrefabs = new();
        private BaseEntity[] _entityBuffer = new BaseEntity[32];

        private Coroutine _startupCoroutine;
        private bool _serverInitialized;
        private bool _isLoaded = true;

        public MonumentAddons()
        {
            _profileManager = new ProfileManager(this, _originalProfileStore, _profileStore);
            _adapterDisplayManager = new AdapterDisplayManager(this, _uniqueNameRegistry);
            _adapterListenerManager = new AdapterListenerManager(this);
            _customAddonManager = new CustomAddonManager(this);
            _customMonumentManager = new CustomMonumentManager(this);
            _controllerFactory = new ControllerFactory(this);
            _monumentHelper = new MonumentHelper(this);
            _wireToolManager = new WireToolManager(this, _profileStore);

            _saveProfileStateDebounced = new ActionDebounced(timer, 1, () =>
            {
                if (!_isLoaded)
                    return;

                _profileStateData.Save();
            });

            _dynamicMonumentHooks = new HookCollection(
                this,
                new[] { nameof(OnEntitySpawned) },
                () => _profileManager.HasAnyEnabledDynamicMonuments
            );
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _data = StoredData.Load(_profileStore);
            _profileStateData = ProfileStateData.Load(_data);

            _config.Init();

            // Ensure the profile folder is created to avoid errors.
            _profileStore.EnsureDefaultProfile();

            permission.RegisterPermission(PermissionAdmin, this);

            _dynamicMonumentHooks.Unsubscribe();
            _adapterListenerManager.Init();
        }

        private void OnServerInitialized()
        {
            _waterDefinition = ItemManager.FindItemDefinition("water");

            _immortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            _immortalProtection.name = "MonumentAddonsProtection";
            _immortalProtection.Add(1);

            _uniqueNameRegistry.OnServerInitialized();
            _adapterListenerManager.OnServerInitialized();
            _monumentHelper.OnServerInitialized();
            _ioManager.OnServerInitialized();

            var entitiesToKill = _profileStateData.CleanDisabledProfileState();
            if (entitiesToKill.Count > 0)
            {
                CoroutineManager.StartGlobalCoroutine(KillEntitiesRoutine(entitiesToKill));
            }

            if (CheckDependencies())
            {
                StartupRoutine();
            }

            _deployablePrefabs = DetermineAllDeployablePrefabs();

            _profileManager.ProfileStatusChanged += (_, _, _) => _dynamicMonumentHooks.Refresh();
            _serverInitialized = true;
        }

        private void Unload()
        {
            _coroutineManager.Destroy();
            _profileManager.UnloadAllProfiles();
            _saveProfileStateDebounced.Flush();
            _wireToolManager.Unload();

            UnityEngine.Object.Destroy(_immortalProtection);

            _isLoaded = false;
        }

        private void OnNewSave()
        {
            _profileStateData.Reset();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            // Check whether initialized to detect only late (re)loads.
            // Note: We are not dynamically subscribing to OnPluginLoaded since that interferes with [PluginReference] for some reason.
            if (_serverInitialized && plugin == MonumentFinder)
            {
                StartupRoutine();
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            if (plugin.Name == Name)
                return;

            _customAddonManager.UnregisterAllForPlugin(plugin);
            _customMonumentManager.UnregisterAllForPlugin(plugin);
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (!IsDynamicMonument(entity))
                return;

            var entityForClosure = entity;
            NextTick(() =>
            {
                if (ExposedHooks.OnDynamicMonument(entityForClosure) is false)
                    return;

                var dynamicMonument = new DynamicMonument(entityForClosure);
                _coroutineManager.StartCoroutine(_profileManager.PartialLoadForLateMonumentRoutine(dynamicMonument));
            });
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private object canRemove(BasePlayer player, BaseEntity entity)
        {
            if (_componentTracker.IsAddonComponent(entity))
                return False;

            return null;
        }

        private object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (_componentTracker.IsAddonComponent(block) && !HasAdminPermission(player))
                return False;

            return null;
        }

        private object CanUpdateSign(BasePlayer player, ISignage signage)
        {
            if (_componentTracker.IsAddonComponent(signage as BaseEntity) && !HasAdminPermission(player))
            {
                ChatMessage(player, LangEntry.ErrorNoPermission);
                return False;
            }

            return null;
        }

        private void OnSignUpdated(ISignage signage, BasePlayer player)
        {
            if (!_componentTracker.IsAddonComponent(signage as BaseEntity, out SignController controller))
                return;

            controller.UpdateSign(signage.GetTextureCRCs());
        }

        // This hook is exposed by plugin: Sign Arist (SignArtist).
        private void OnImagePost(BasePlayer player, string url, bool raw, ISignage signage, uint textureIndex = 0)
        {
            if (!_componentTracker.IsAddonComponent(signage as BaseEntity, out SignController controller))
                return;

            if (controller.EntityData.SignArtistImages == null)
            {
                controller.EntityData.SignArtistImages = new SignArtistImage[signage.TextureCount];
            }
            else if (controller.EntityData.SignArtistImages.Length < signage.TextureCount)
            {
                Array.Resize(ref controller.EntityData.SignArtistImages, signage.TextureCount);
            }

            controller.EntityData.SignArtistImages[textureIndex] = new SignArtistImage
            {
                Url = url,
                Raw = raw,
            };
            _profileStore.Save(controller.Profile);
        }

        private object OnSprayRemove(SprayCanSpray spray, BasePlayer player)
        {
            if (_componentTracker.IsAddonComponent(spray))
                return False;

            return null;
        }

        private void OnEntityScaled(BaseEntity entity, float scale)
        {
            if (!_componentTracker.IsAddonComponent(entity, out EntityController controller)
                || controller.EntityData.Scale == scale)
                return;

            controller.EntityData.Scale = scale;
            controller.StartUpdateRoutine();
            _profileStore.Save(controller.Profile);
        }

        // This hook is exposed by plugin: Telekinesis.
        private Component OnTelekinesisFindFailed(BasePlayer player)
        {
            if (!HasAdminPermission(player))
                return null;

            return FindAdapter<TransformAdapter>(player).Adapter?.Component;
        }

        // This hook is exposed by plugin: Telekinesis.
        private Tuple<Component, Component> OnTelekinesisStart(BasePlayer player, BaseEntity entity)
        {
            if (!_componentTracker.IsAddonComponent(entity, out PasteAdapter adapter, out PasteController _))
                return null;

            return new Tuple<Component, Component>(adapter.Component, adapter.Component);
        }

        // This hook is exposed by plugin: Telekinesis.
        private object CanStartTelekinesis(BasePlayer player, Component moveComponent, Component rotateComponent)
        {
            if (IsTransformAddon(moveComponent, out _) && !HasAdminPermission(player))
                return False;

            return null;
        }

        // This hook is exposed by plugin: Telekinesis.
        private void OnTelekinesisStarted(BasePlayer player, Component moveComponent, Component rotateComponent)
        {
            if (!IsTransformAddon(moveComponent, out var adapter, out var controller)
                || controller is not IUpdateableController)
                return;

            if (adapter.Component == moveComponent || adapter.Component == rotateComponent)
            {
                _adapterDisplayManager.SetPlayerMovingAdapter(player, adapter);
            }

            _adapterDisplayManager.ShowAllRepeatedly(player);

            if (moveComponent is BaseEntity moveEntity && IsSpawnPointEntity(moveEntity))
            {
                _adapterDisplayManager.ShowAllRepeatedly(player);

                var spawnedVehicleComponent = moveComponent.GetComponent<SpawnedVehicleComponent>();
                if (spawnedVehicleComponent != null)
                {
                    spawnedVehicleComponent.CancelInvoke(spawnedVehicleComponent.CheckPositionTracked);
                }
            }
        }

        // This hook is exposed by plugin: Telekinesis.
        private void OnTelekinesisStopped(BasePlayer player, Component moveComponent, Component rotateComponent)
        {
            if (!IsTransformAddon(moveComponent, out TransformAdapter transformAdapter, out BaseController controller)
                || controller is not IUpdateableController updateableController)
                return;

            if (player != null)
            {
                _adapterDisplayManager.SetPlayerMovingAdapter(player, null);
            }

            if (!transformAdapter.TryRecordUpdates(moveComponent.transform, rotateComponent.transform))
                return;

            if (moveComponent is CustomSpawnPoint spawnPoint)
            {
                spawnPoint.MoveSpawnedInstances();
            }

            updateableController.StartUpdateRoutine();
            _profileStore.Save(controller.Profile);

            if (player != null)
            {
                _adapterDisplayManager.ShowAllRepeatedly(player);
                ChatMessage(player, LangEntry.SaveSuccess, controller.Adapters.Count, controller.Profile.Name);
            }
        }

        // This hook is exposed by plugin: Custom Vending Setup (CustomVendingSetup).
        private Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine)
        {
            if (!_componentTracker.IsAddonComponent(vendingMachine, out EntityController controller))
                return null;

            var vendingProfile = controller.EntityData.VendingProfile;
            if (vendingProfile == null)
            {
                // Check if there's one to be migrated.
                var migratedVendingProfile = MigrateVendingProfile(vendingMachine);
                if (migratedVendingProfile != null)
                {
                    controller.EntityData.VendingProfile = migratedVendingProfile;
                    _profileStore.Save(controller.Profile);
                    LogWarning($"Successfully migrated vending machine settings from CustomVendingSetup to MonumentAddons profile '{controller.Profile.Name}'.");
                }
            }

            return controller.GetVendingDataProvider();
        }

        #endregion

        #region Dependencies

        private bool CheckDependencies()
        {
            if (MonumentFinder == null)
            {
                LogError("MonumentFinder is not loaded, get it at https://umod.org.");
                return false;
            }

            return true;
        }

        private float GetEntityScale(BaseEntity entity)
        {
            if (EntityScaleManager == null)
                return 1;

            return Convert.ToSingle(EntityScaleManager?.Call("API_GetScale", entity));
        }

        private bool TryScaleEntity(BaseEntity entity, float scale)
        {
            return EntityScaleManager?.Call("API_ScaleEntity", entity, scale) is true;
        }

        private void SkinSign(ISignage signage, SignArtistImage[] signArtistImages)
        {
            if (SignArtist == null)
                return;

            var apiName = signage is Signage
                ? "API_SkinSign"
                : signage is PhotoFrame
                ? "API_SkinPhotoFrame"
                : signage is CarvablePumpkin
                ? "API_SkinPumpkin"
                : null;

            if (apiName == null)
            {
                LogError($"Unrecognized sign type: {signage.GetType()}");
                return;
            }

            for (uint textureIndex = 0; textureIndex < signArtistImages.Length; textureIndex++)
            {
                var imageInfo = signArtistImages[textureIndex];
                if (imageInfo == null)
                    continue;

                SignArtist.Call(apiName, null, signage, imageInfo.Url, imageInfo.Raw, textureIndex);
            }
        }

        private JObject MigrateVendingProfile(NPCVendingMachine vendingMachine)
        {
            return CustomVendingSetup?.Call("API_MigrateVendingProfile", vendingMachine) as JObject;
        }

        private void RefreshVendingProfile(NPCVendingMachine vendingMachine)
        {
            CustomVendingSetup?.Call("API_RefreshDataProvider", vendingMachine);
        }

        private static class PasteUtils
        {
            private static readonly string[] CopyPasteArgs =
            {
                "stability", "false",
                "checkplaced", "false",
            };

            private static VersionNumber _requiredVersion = new VersionNumber(4, 1, 32);

            public static bool IsCopyPasteCompatible(Plugin copyPaste)
            {
                return copyPaste != null && copyPaste.Version >= _requiredVersion;
            }

            public static bool DoesPasteExist(string filename)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile("copypaste/" + filename);
            }

            public static Action PasteWithCancelCallback(Plugin copyPaste, PasteData pasteData, Vector3 position, float yRotation, Action<BaseEntity> onEntityPasted, Action onPasteCompleted)
            {
                if (copyPaste == null)
                    return null;

                var args = CopyPasteArgs;
                if (pasteData.Args is { Length: > 0 })
                {
                    args = args.Concat(pasteData.Args).ToArray();
                }

                var result = copyPaste.Call("TryPasteFromVector3Cancellable", position, yRotation, pasteData.Filename, args, onPasteCompleted, onEntityPasted);
                if (!(result is ValueTuple<object, Action>))
                {
                    LogError($"CopyPaste returned an unexpected response for paste \"{pasteData.Filename}\": {result}. Is CopyPaste up-to-date?");
                    return null;
                }

                var pasteResult = (ValueTuple<object, Action>)result;
                if (!true.Equals(pasteResult.Item1))
                {
                    LogError($"CopyPaste returned an unexpected response for paste \"{pasteData.Filename}\": {pasteResult.Item1}.");
                    return null;
                }

                return pasteResult.Item2;
            }
        }

        #endregion

        #region API

        [HookMethod(nameof(API_IsMonumentEntity))]
        public object API_IsMonumentEntity(BaseEntity entity)
        {
            return ObjectCache.Get(_componentTracker.IsAddonComponent(entity));
        }

        [HookMethod(nameof(API_GetMonumentEntityGuid))]
        public object API_GetMonumentEntityGuid(BaseEntity entity)
        {
            if (!_componentTracker.IsAddonComponent(entity))
                return null;

            var adapter = AddonComponent.GetForComponent(entity).Adapter;
            if (adapter == null)
                return null;

            return ObjectCache.Get(adapter.Data.Id);
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static void OnMonumentAddonsInitialized()
            {
                Interface.CallHook("OnMonumentAddonsInitialized");
            }

            public static void OnMonumentEntitySpawned(BaseEntity entity, Component monument, Guid guid)
            {
                Interface.CallHook("OnMonumentEntitySpawned", entity, monument, ObjectCache.Get(guid));
            }

            public static void OnMonumentPrefabCreated(GameObject gameObject, Component monument, Guid guid)
            {
                Interface.CallHook("OnMonumentPrefabCreated", gameObject, monument, ObjectCache.Get(guid));
            }

            public static object OnDynamicMonument(BaseEntity entity)
            {
                return Interface.CallHook("OnDynamicMonument", entity);
            }
        }

        #endregion

        #region Commands

        private enum PuzzleOption
        {
            PlayersBlockReset,
            PlayerDetectionRadius,
            SecondsBetweenResets,
        }

        private enum SpawnGroupOption
        {
            Name,
            Color,
            MaxPopulation,
            RespawnDelayMin,
            RespawnDelayMax,
            SpawnPerTickMin,
            SpawnPerTickMax,
            InitialSpawn,
            PreventDuplicates,
            PauseScheduleWhileFull,
            RespawnWhenNearestPuzzleResets,
        }

        private enum SpawnPointOption
        {
            Exclusive,
            SnapToGround,
            CheckSpace,
            RandomRotation,
            RandomRadius,
            PlayerDetectionRadius,
        }

        [Command("maspawn")]
        private void CommandSpawn(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyMonumentFinderLoaded(player)
                || !VerifyProfileSelected(player, out var profileController)
                || !VerifyValidEntityPrefabOrDeployable(player, args, out var prefabName, out var addonDefinition, out var skinId)
                || !VerifyLookingAtMonumentPosition(player, out var position, out var monument))
                return;

            DetermineLocalTransformData(position, basePlayer, monument, out var localPosition, out var localRotationAngles, out var isOnTerrain);

            BaseData addonData;

            if (prefabName != null)
            {
                // Found a valid prefab name.
                var shortPrefabName = GetShortName(prefabName);

                if (shortPrefabName == "big_wheel")
                {
                    localRotationAngles.y -= 90;
                    localRotationAngles.z = 270;
                }
                else if (shortPrefabName == "boatspawner")
                {
                    if (position.y == TerrainMeta.WaterMap.GetHeight(position))
                    {
                        // Set the boatspawner to -1.5 like the vanilla ones.
                        localPosition.y -= 1.5f;
                    }
                }
                else if (shortPrefabName == "spray.decal")
                {
                    localRotationAngles.x += 270;
                    localRotationAngles.y -= 90;
                }

                var entityData = new EntityData
                {
                    Id = Guid.NewGuid(),
                    Skin = skinId,
                    PrefabName = prefabName,
                    Position = localPosition,
                    RotationAngles = localRotationAngles,
                    SnapToTerrain = isOnTerrain,
                };

                if (shortPrefabName.StartsWith("generator.static"))
                {
                    entityData.Puzzle = _config.AddonDefaults.Puzzles.ApplyTo(new PuzzleData());
                }

                addonData = entityData;
            }
            else
            {
                // Found a custom addon definition.
                if (!addonDefinition.TryInitialize(basePlayer, args.Skip(1).ToArray(), out var pluginData))
                    return;

                addonData = new CustomAddonData
                {
                    Id = Guid.NewGuid(),
                    AddonName = addonDefinition.AddonName,
                    Position = localPosition,
                    RotationAngles = localRotationAngles,
                    SnapToTerrain = isOnTerrain,
                }.SetData(pluginData);
            }

            var matchingMonuments = GetMonumentsByIdentifier(monument.UniqueName);

            profileController.Profile.AddData(monument.UniqueName, addonData);
            _profileStore.Save(profileController.Profile);
            profileController.SpawnNewData(addonData, matchingMonuments);

            ReplyToPlayer(player, LangEntry.SpawnSuccess, matchingMonuments.Count, profileController.Profile.Name, monument.UniqueDisplayName);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);

            if (addonData is not CustomAddonData && ShouldRecommendSpawnPoints(prefabName))
            {
                ReplyToPlayer(player, LangEntry.WarningRecommendSpawnPoint);
            }
        }

        [Command("maedit")]
        private void CommandEdit(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out CustomAddonAdapter adapter, out CustomAddonController controller, LangEntry.ErrorNoCustomAddonFound))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, LangEntry.EditSynax);
                return;
            }

            var addonDefinition = adapter.AddonDefinition;
            var addonName = addonDefinition.AddonName;
            if (addonName != args[0])
            {
                ReplyToPlayer(player, LangEntry.EditErrorNoMatch, args[0]);
                return;
            }

            if (!addonDefinition.SupportsEditing)
            {
                ReplyToPlayer(player, LangEntry.EditErrorNotEditable, addonName);
                return;
            }

            if (!addonDefinition.TryEdit(basePlayer, args.Skip(1).ToArray(), adapter.Component, adapter.CustomAddonData.GetSerializedData(), out var data))
                return;

            addonDefinition.SetData(_profileStore, controller, data);

            ReplyToPlayer(player, LangEntry.EditSuccess, addonName);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("maprefab")]
        private void CommandPrefab(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyMonumentFinderLoaded(player)
                || !VerifyProfileSelected(player, out var profileController)
                || !VerifyValidModderPrefab(player, args, out var prefabName)
                || !VerifyLookingAtMonumentPosition(player, out var position, out var monument))
                return;

            if (FindPrefabBaseEntity(prefabName) != null)
            {
                ReplyToPlayer(player, LangEntry.PrefabErrorIsEntity, prefabName);
                return;
            }

            DetermineLocalTransformData(position, basePlayer, monument, out var localPosition, out var localRotationAngles, out var isOnTerrain);

            var prefabData = new PrefabData
            {
                Id = Guid.NewGuid(),
                PrefabName = prefabName,
                Position = localPosition,
                RotationAngles = localRotationAngles,
                SnapToTerrain = isOnTerrain,
            };

            var matchingMonuments = GetMonumentsByIdentifier(monument.UniqueName);

            profileController.Profile.AddData(monument.UniqueName, prefabData);
            _profileStore.Save(profileController.Profile);
            profileController.SpawnNewData(prefabData, matchingMonuments);

            ReplyToPlayer(player, LangEntry.PrefabSuccess, matchingMonuments.Count, profileController.Profile.Name, monument.UniqueDisplayName);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("masave")]
        private void CommandSave(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            if (!adapter.TryRecordUpdates())
            {
                ReplyToPlayer(player, LangEntry.SaveNothingToDo);
                return;
            }

            ReplyToPlayer(player, LangEntry.SaveSuccess, controller.Adapters.Count, controller.Profile.Name);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("makill")]
        private void CommandKill(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out TransformAdapter adapter, out BaseController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            // Capture adapter count before killing the controller.
            var numAdapters = controller.Adapters.Count;

            controller.Profile.RemoveData(adapter.Data, out var monumentIdentifier);
            _dynamicMonumentHooks.Refresh();
            var profile = controller.Profile;
            _profileStore.Save(profile);

            var profileController = controller.ProfileController;
            var killRoutine = controller.Kill(adapter.Data);
            if (killRoutine != null)
            {
                profileController.StartCallbackRoutine(killRoutine, profileController.SetupIO);
            }

            if (controller.Data is SpawnGroupData spawnGroupData && adapter.Data is SpawnPointData spawnPointData)
            {
                _undoManager.AddUndo(basePlayer, new UndoKillSpawnPoint(this, profileController, monumentIdentifier, spawnGroupData, spawnPointData));
            }
            else
            {
                _undoManager.AddUndo(basePlayer, new UndoKill(this, profileController, monumentIdentifier, controller.Data));
            }

            ReplyToPlayer(player, LangEntry.KillSuccess, GetAddonName(player, adapter.Data), numAdapters, profile.Name);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("maundo")]
        private void CommandUndo(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (!_undoManager.TryUndo(basePlayer))
            {
                ReplyToPlayer(player, LangEntry.UndoNotFound);
                _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
            }
        }

        [Command("masetid")]
        private void CommandSetId(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (args.Length < 1 || !ComputerStation.IsValidIdentifier(args[0]))
            {
                ReplyToPlayer(player, LangEntry.CCTVSetIdSyntax, cmd);
                return;
            }

            if (!VerifyLookingAtAdapter(player, out CCTVController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            controller.EntityData.CCTV ??= new CCTVInfo();

            var hadIdentifier = !string.IsNullOrEmpty(controller.EntityData.CCTV.RCIdentifier);

            controller.EntityData.CCTV.RCIdentifier = args[0];
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, LangEntry.CCTVSetIdSuccess, args[0], controller.Adapters.Count, controller.Profile.Name);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: hadIdentifier);
        }

        [Command("masetdir")]
        private void CommandSetDirection(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out CCTVEntityAdapter adapter, out CCTVController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            var cctv = adapter.Entity as CCTV_RC;

            var direction = Vector3Ex.Direction(basePlayer.eyes.position, cctv.transform.position);
            direction = cctv.transform.InverseTransformDirection(direction);
            var lookAngles = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);

            controller.EntityData.CCTV ??= new CCTVInfo();
            controller.EntityData.CCTV.Pitch = lookAngles.x;
            controller.EntityData.CCTV.Yaw = lookAngles.y;
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, LangEntry.CCTVSetDirectionSuccess, controller.Adapters.Count, controller.Profile.Name);

            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("maskull")]
        private void CommandSkull(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            var skullTrophy = adapter.Entity as SkullTrophyGlobal;
            if (skullTrophy == null)
            {
                ReplyToPlayer(player, LangEntry.ErrorNoSuitableAddonFound);
                return;
            }

            if (args.Length == 0)
            {
                ReplyToPlayer(player, LangEntry.SkullNameSyntax, cmd);
                return;
            }

            var skullName = args[0];
            var updatedSkullName = controller.EntityData.SkullName != skullName;

            controller.EntityData.SkullName = skullName;
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, LangEntry.SkullNameSetSuccess, skullName, controller.Adapters.Count, controller.Profile.Name);

            _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: !updatedSkullName);
        }

        [Command("matrophy")]
        private void CommandTrophy(IPlayer player, string cmd, string[] args)
        {
            T GetSubEntity<T>(Item item) where T : BaseEntity
            {
                var entityId = item.instanceData?.subEntity ?? new NetworkableId(0);
                if (entityId.Value == 0)
                    return null;

                return BaseNetworkable.serverEntities.Find(entityId) as T;
            }

            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            var huntingTrophy = adapter.Entity as HuntingTrophy;
            if (huntingTrophy == null)
            {
                ReplyToPlayer(player, LangEntry.ErrorNoSuitableAddonFound);
                return;
            }

            var heldItem = basePlayer.GetActiveItem();
            var headEntity = heldItem != null ? GetSubEntity<HeadEntity>(heldItem) : null;
            if (headEntity == null)
            {
                ReplyToPlayer(player, LangEntry.SetHeadNoHeadItem);
                return;
            }

            if (!huntingTrophy.CanSubmitHead(headEntity))
            {
                ReplyToPlayer(player, LangEntry.SetHeadMismatch);
                return;
            }

            controller.EntityData.HeadData = HeadData.FromHeadEntity(headEntity);
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, LangEntry.SetHeadSuccess, controller.Adapters.Count, controller.Profile.Name);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("maskin")]
        private void CommandSkin(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            if (args.Length == 0)
            {
                ReplyToPlayer(player, LangEntry.SkinGet, adapter.Entity.skinID, cmd);
                return;
            }

            if (!ulong.TryParse(args[0], out var skinId))
            {
                ReplyToPlayer(player, LangEntry.SkinSetSyntax, cmd);
                return;
            }

            if (IsRedirectSkin(skinId, out var alternativeShortName))
            {
                ReplyToPlayer(player, LangEntry.SkinErrorRedirect, skinId, alternativeShortName);
                return;
            }

            var updatedExistingSkin = (controller.EntityData.Skin == 0) != (skinId == 0);

            controller.EntityData.Skin = skinId;
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, LangEntry.SkinSetSuccess, skinId, controller.Adapters.Count, controller.Profile.Name);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: !updatedExistingSkin);
        }

        [Command("maflag")]
        private void CommandFlag(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out _)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            if (args.Length == 0)
            {
                var notAplicableMessage = GetMessage(player.Id, LangEntry.NotApplicable);
                var currentFlags = adapter.Entity.flags == 0 ? notAplicableMessage : adapter.Entity.flags.ToString();
                var enabledFlags = adapter.EntityData.EnabledFlags == 0 ? notAplicableMessage : adapter.EntityData.EnabledFlags.ToString();
                var disabledFlags = adapter.EntityData.DisabledFlags == 0 ? notAplicableMessage : adapter.EntityData.DisabledFlags.ToString();

                ReplyToPlayer(player, LangEntry.FlagsGet, currentFlags, enabledFlags, disabledFlags);
                return;
            }

            if (!Enum.TryParse<BaseEntity.Flags>(args[0], ignoreCase: true, result: out var flag))
            {
                ReplyToPlayer(player, LangEntry.FlagsSetSyntax, cmd);
                return;
            }

            var hasFlag = adapter.Entity.HasFlag(flag) ? true : adapter.EntityData.HasFlag(flag);
            hasFlag = hasFlag switch
            {
                true => false,
                false => null,
                null => true
            };

            adapter.EntityData.SetFlag(flag, hasFlag);
            _profileStore.Save(controller.Profile);
            controller.StartUpdateRoutine();

            ReplyToPlayer(player, hasFlag switch
            {
                true => LangEntry.FlagsEnableSuccess,
                false => LangEntry.FlagsDisableSuccess,
                null => LangEntry.FlagsUnsetSuccess
            }, flag);
        }

        private void AddProfileDescription(StringBuilder sb, IPlayer player, ProfileController profileController)
        {
            foreach (var summaryEntry in GetProfileSummary(player, profileController.Profile))
            {
                sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileDescribeItem, summaryEntry.AddonType, summaryEntry.AddonName, summaryEntry.Count, summaryEntry.MonumentName));
            }
        }

        [Command("macardlevel")]
        private void CommandLevel(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound))
                return;

            var cardReader = adapter.Entity as CardReader;
            if ((object)cardReader == null)
            {
                ReplyToPlayer(player, LangEntry.ErrorNoSuitableAddonFound);
                return;
            }

            if (args.Length < 1 || !int.TryParse(args[0], result: out var accessLevel) || accessLevel < 1 || accessLevel > 3)
            {
                ReplyToPlayer(player, LangEntry.CardReaderSetLevelSyntax, cmd);
                return;
            }

            if (cardReader.accessLevel != accessLevel)
            {
                adapter.EntityData.CardReaderLevel = (ushort)accessLevel;
                _profileStore.Save(controller.Profile);
                controller.StartUpdateRoutine();
            }

            ReplyToPlayer(player, LangEntry.CardReaderSetLevelSuccess, adapter.EntityData.CardReaderLevel);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("mapuzzle")]
        private void CommandPuzzle(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (args.Length == 0)
            {
                SubCommandPuzzleHelp(player, cmd);
                return;
            }

            var subCommandLower = args[0].ToLower();
            switch (subCommandLower)
            {
                case "reset":
                {
                    if (!VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController _, LangEntry.ErrorNoSuitableAddonFound))
                        return;

                    var ioEntity = adapter.Entity as IOEntity;
                    var puzzleReset = ioEntity != null ? FindConnectedPuzzleReset(ioEntity) : null;
                    if (puzzleReset == null)
                    {
                        ReplyToPlayer(player, LangEntry.PuzzleNotConnected, _uniqueNameRegistry.GetUniqueShortName(adapter.Entity.PrefabName));
                        return;
                    }

                    puzzleReset.DoReset();
                    puzzleReset.ResetTimer();
                    ReplyToPlayer(player, LangEntry.PuzzleResetSuccess);
                    break;
                }

                case "add":
                case "remove":
                {
                    var isAdd = subCommandLower == "add";
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, isAdd ? LangEntry.PuzzleAddSpawnGroupSyntax : LangEntry.PuzzleRemoveSpawnGroupSyntax, cmd);
                        return;
                    }

                    if (!VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound)
                        || !VerifyEntityComponent(player, adapter.Entity, out PuzzleReset puzzleReset, LangEntry.PuzzleNotPresent))
                        return;

                    if (!VerifySpawnGroupFound(player, args[1], adapter.Monument, out var spawnGroupController))
                        return;

                    var spawnGroupData = spawnGroupController.SpawnGroupData;
                    var spawnGroupId = spawnGroupData.Id;
                    var puzzleData = controller.EntityData.EnsurePuzzleData(puzzleReset);

                    if (!isAdd)
                    {
                        puzzleData.RemoveSpawnGroupId(spawnGroupId);
                    }
                    else if (!puzzleData.HasSpawnGroupId(spawnGroupId))
                    {
                        puzzleData.AddSpawnGroupId(spawnGroupId);
                    }

                    controller.StartUpdateRoutine();
                    _profileStore.Save(controller.Profile);

                    ReplyToPlayer(player, isAdd ? LangEntry.PuzzleAddSpawnGroupSuccess : LangEntry.PuzzleRemoveSpawnGroupSuccess, spawnGroupData.Name);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: false);
                    break;
                }

                case "set":
                {
                    if (args.Length < 3)
                    {
                        _sb.Clear();
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.ErrorSetSyntaxGeneric, cmd, subCommandLower));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleSetHelpMaxPlayersBlockReset));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleSetHelpPlayerDetectionRadius));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleSetHelpSecondsBetweenResets));
                        player.Reply(_sb.ToString());
                        return;
                    }

                    if (!VerifyValidEnumValue(player, args[1], out PuzzleOption puzzleOption))
                        return;

                    if (!VerifyLookingAtAdapter(player, out EntityAdapter adapter, out EntityController controller, LangEntry.ErrorNoSuitableAddonFound)
                        || !VerifyEntityComponent(player, adapter.Entity, out PuzzleReset puzzleReset, LangEntry.PuzzleNotPresent))
                        return;

                    var puzzleData = controller.EntityData.EnsurePuzzleData(puzzleReset);

                    object setValue = args[2];
                    var showImmediate = true;

                    switch (puzzleOption)
                    {
                        case PuzzleOption.PlayersBlockReset:
                        {
                            if (!VerifyValidBool(player, args[2], out var playerBlockReset, LangEntry.ErrorSetSyntax.Bind(cmd, PuzzleOption.PlayersBlockReset)))
                                return;

                            puzzleData.PlayersBlockReset = playerBlockReset;
                            setValue = playerBlockReset;
                            showImmediate = false;
                            break;
                        }

                        case PuzzleOption.PlayerDetectionRadius:
                        {
                            if (!VerifyValidFloat(player, args[2], out var playerDetectionRadius, LangEntry.ErrorSetSyntax.Bind(cmd, PuzzleOption.PlayerDetectionRadius)))
                                return;

                            puzzleData.PlayersBlockReset = true;
                            puzzleData.PlayerDetectionRadius = playerDetectionRadius;
                            setValue = playerDetectionRadius;
                            break;
                        }

                        case PuzzleOption.SecondsBetweenResets:
                        {
                            if (!VerifyValidFloat(player, args[2], out var secondsBetweenResets, LangEntry.ErrorSetSyntax.Bind(cmd, PuzzleOption.SecondsBetweenResets)))
                                return;

                            puzzleData.SecondsBetweenResets = secondsBetweenResets;
                            setValue = secondsBetweenResets;
                            break;
                        }
                    }

                    controller.StartUpdateRoutine();
                    _profileStore.Save(controller.Profile);

                    ReplyToPlayer(player, LangEntry.PuzzleSetSuccess, puzzleOption, setValue);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: showImmediate);
                    break;
                }

                default:
                {
                    SubCommandPuzzleHelp(player, cmd);
                    break;
                }
            }
        }

        private void SubCommandPuzzleHelp(IPlayer player, string cmd)
        {
            _sb.Clear();
            _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleHelpHeader));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleHelpReset, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleHelpSet, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleHelpAdd, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.PuzzleHelpRemove, cmd));
            player.Reply(_sb.ToString());
        }

        [Command("maprofile")]
        private void CommandProfile(IPlayer player, string cmd, string[] args)
        {
            if (!_serverInitialized
                || !VerifyHasPermission(player)
                || !VerifyMonumentFinderLoaded(player))
                return;

            if (args.Length == 0)
            {
                SubCommandProfileHelp(player);
                return;
            }

            var basePlayer = player.Object as BasePlayer;

            switch (args[0].ToLower())
            {
                case "list":
                {
                    var profileList = ProfileInfo.GetList(_data, _profileManager);
                    if (profileList.Count == 0)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileListEmpty);
                        return;
                    }

                    var playerProfileName = player.IsServer ? null : _data.GetSelectedProfileName(player.Id);

                    profileList = profileList
                        .OrderByDescending(profile => profile.Enabled && profile.Name == playerProfileName)
                        .ThenByDescending(profile => profile.Enabled)
                        .ThenBy(profile => profile.Name)
                        .ToList();

                    _sb.Clear();
                    _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileListHeader));
                    foreach (var profile in profileList)
                    {
                        var messageName = profile.Enabled && profile.Name == playerProfileName
                            ? LangEntry.ProfileListItemSelected
                            : profile.Enabled
                            ? LangEntry.ProfileListItemEnabled
                            : LangEntry.ProfileListItemDisabled;

                        _sb.AppendLine(GetMessage(player.Id, messageName, profile.Name, GetAuthorSuffix(player, profile.Profile?.Author)));
                    }
                    player.Reply(_sb.ToString());
                    break;
                }

                case "describe":
                {
                    if (!VerifyProfile(player, args, out var controller, LangEntry.ProfileDescribeSyntax))
                        return;

                    if (controller.Profile.IsEmpty())
                    {
                        ReplyToPlayer(player, LangEntry.ProfileEmpty, controller.Profile.Name);
                        return;
                    }

                    _sb.Clear();
                    _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileDescribeHeader, controller.Profile.Name));
                    AddProfileDescription(_sb, player, controller);

                    player.Reply(_sb.ToString());

                    if (!player.IsServer)
                    {
                        _adapterDisplayManager.SetPlayerProfile(basePlayer, controller);
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }

                    break;
                }

                case "sel":
                case "select":
                {
                    if (player.IsServer)
                        return;

                    ProfileController controller;

                    if (args.Length <= 1)
                    {
                        // Find the adapter where the player is aiming, if they did not specify a profile name.
                        controller = FindAdapter(basePlayer).Controller?.ProfileController;
                        if (controller == null)
                        {
                            ReplyToPlayer(player, LangEntry.ProfileSelectSyntax);
                            return;
                        }
                    }
                    else if (!VerifyProfile(player, args, out controller, LangEntry.ProfileSelectSyntax))
                        return;

                    var profile = controller.Profile;
                    var profileName = profile.Name;

                    _data.SetProfileSelected(player.Id, profileName);
                    var wasEnabled = controller.IsEnabled;
                    if (wasEnabled)
                    {
                        // Only save if the profile is not enabled, since enabling it will already save the main data file.
                        _data.Save();
                    }
                    else
                    {
                        if (!VerifyCanLoadProfile(player, profileName, out var newProfileData))
                            return;

                        controller.Enable(newProfileData);
                    }

                    ReplyToPlayer(player, wasEnabled ? LangEntry.ProfileSelectSuccess : LangEntry.ProfileSelectEnableSuccess, profileName);
                    _adapterDisplayManager.SetPlayerProfile(basePlayer, controller);
                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                case "create":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileCreateSyntax);
                        return;
                    }

                    var newName = DynamicConfigFile.SanitizeName(args[1]);
                    if (string.IsNullOrWhiteSpace(newName))
                    {
                        ReplyToPlayer(player, LangEntry.ProfileCreateSyntax);
                        return;
                    }

                    if (!VerifyProfileNameAvailable(player, newName))
                        return;

                    var controller = _profileManager.CreateProfile(newName, basePlayer?.displayName);

                    if (!player.IsServer)
                    {
                        _data.SetProfileSelected(player.Id, newName);
                    }

                    _data.SetProfileEnabled(newName);

                    ReplyToPlayer(player, LangEntry.ProfileCreateSuccess, controller.Profile.Name);
                    _adapterDisplayManager.SetPlayerProfile(basePlayer, controller);
                    break;
                }

                case "rename":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileRenameSyntax);
                        return;
                    }

                    ProfileController controller;
                    if (args.Length == 2)
                    {
                        controller = player.IsServer ? null : _profileManager.GetPlayerProfileController(player.Id);
                        if (controller == null)
                        {
                            ReplyToPlayer(player, LangEntry.ProfileRenameSyntax);
                            return;
                        }
                    }
                    else if (!VerifyProfileExists(player, args[1], out controller))
                        return;

                    string newName = DynamicConfigFile.SanitizeName(args.Length == 2 ? args[1] : args[2]);
                    if (string.IsNullOrWhiteSpace(newName))
                    {
                        ReplyToPlayer(player, LangEntry.ProfileRenameSyntax);
                        return;
                    }

                    if (!VerifyProfileNameAvailable(player, newName))
                        return;

                    // Cache the actual old name in case it was case-insensitive matched.
                    var actualOldName = controller.Profile.Name;

                    controller.Rename(newName);
                    ReplyToPlayer(player, LangEntry.ProfileRenameSuccess, actualOldName, controller.Profile.Name);
                    if (!player.IsServer)
                    {
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }

                    break;
                }

                case "reload":
                {
                    if (!VerifyProfile(player, args, out var controller, LangEntry.ProfileReloadSyntax))
                        return;

                    if (!controller.IsEnabled)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileNotEnabled, controller.Profile.Name);
                        return;
                    }

                    if (!VerifyCanLoadProfile(player, controller.Profile.Name, out var newProfileData))
                        return;

                    controller.Reload(newProfileData);
                    ReplyToPlayer(player, LangEntry.ProfileReloadSuccess, controller.Profile.Name);
                    if (!player.IsServer)
                    {
                        _adapterDisplayManager.SetPlayerProfile(basePlayer, controller);
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }

                    break;
                }

                case "enable":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileEnableSyntax);
                        return;
                    }

                    if (!VerifyProfileExists(player, args[1], out var controller))
                        return;

                    var profileName = controller.Profile.Name;
                    if (controller.IsEnabled)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileAlreadyEnabled, profileName);
                        return;
                    }

                    if (!VerifyCanLoadProfile(player, controller.Profile.Name, out var newProfileData))
                        return;

                    controller.Enable(newProfileData);
                    ReplyToPlayer(player, LangEntry.ProfileEnableSuccess, profileName);
                    if (!player.IsServer)
                    {
                        _adapterDisplayManager.SetPlayerProfile(basePlayer, controller);
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }

                    break;
                }

                case "disable":
                {
                    if (!VerifyProfile(player, args, out var controller, LangEntry.ProfileDisableSyntax))
                        return;

                    var profileName = controller.Profile.Name;
                    if (!controller.IsEnabled)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileAlreadyDisabled, profileName);
                        return;
                    }

                    _profileManager.DisableProfile(controller);
                    ReplyToPlayer(player, LangEntry.ProfileDisableSuccess, profileName);
                    break;
                }

                case "clear":
                {
                    if (args.Length <= 1)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileClearSyntax);
                        return;
                    }

                    if (!VerifyProfile(player, args, out var controller, LangEntry.ProfileClearSyntax))
                        return;

                    if (!controller.Profile.IsEmpty())
                    {
                        controller.Clear();
                    }

                    ReplyToPlayer(player, LangEntry.ProfileClearSuccess, controller.Profile.Name);
                    break;
                }

                case "delete":
                {
                    if (args.Length <= 1)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileDeleteSyntax);
                        return;
                    }

                    if (!VerifyProfile(player, args, out var controller, LangEntry.ProfileDeleteSyntax))
                        return;

                    var profileName = controller.Profile.Name;
                    if (controller.IsEnabled && !controller.Profile.IsEmpty())
                    {
                        ReplyToPlayer(player, LangEntry.ProfileDeleteBlocked, profileName);
                        return;
                    }

                    _profileManager.DeleteProfile(controller);
                    ReplyToPlayer(player, LangEntry.ProfileDeleteSuccess, profileName);
                    break;
                }

                case "moveto":
                {
                    if (!VerifyLookingAtAdapter(player, out BaseController addonController, LangEntry.ErrorNoSuitableAddonFound))
                        return;

                    if (!VerifyProfile(player, args, out var newProfileController, LangEntry.ProfileMoveToSyntax))
                        return;

                    var oldProfileController = addonController.ProfileController;
                    var newProfile = newProfileController.Profile;
                    var oldProfile = addonController.Profile;

                    var data = addonController.Data;
                    var addonName = GetAddonName(player, data);

                    if (newProfileController == oldProfileController)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileMoveToAlreadyPresent, addonName, oldProfile.Name);
                        return;
                    }

                    if (!oldProfile.RemoveData(data, out var monumentIdentifier))
                    {
                        LogError($"Unexpected error: {data.GetType()} {data.Id} was not found in profile {oldProfile.Name}");
                        return;
                    }

                    _profileStore.Save(oldProfile);
                    var killRoutine = addonController.Kill();
                    if (killRoutine != null)
                    {
                        oldProfileController.StartCallbackRoutine(killRoutine, oldProfileController.SetupIO);
                    }

                    newProfile.AddData(monumentIdentifier, data);
                    _profileStore.Save(newProfile);
                    newProfileController.SpawnNewData(data, GetMonumentsByIdentifier(monumentIdentifier));

                    ReplyToPlayer(player, LangEntry.ProfileMoveToSuccess, addonName, oldProfile.Name, newProfile.Name);
                    if (!player.IsServer)
                    {
                        _adapterDisplayManager.SetPlayerProfile(basePlayer, newProfileController);
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }

                    break;
                }

                case "install":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.ProfileInstallSyntax);
                        return;
                    }

                    SharedCommandInstallProfile(player, args.Skip(1).ToArray());
                    break;
                }

                default:
                {
                    SubCommandProfileHelp(player);
                    break;
                }
            }
        }

        private void SubCommandProfileHelp(IPlayer player)
        {
            _sb.Clear();
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpHeader));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpList));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpDescribe));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpEnable));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpDisable));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpReload));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpSelect));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpCreate));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpRename));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpClear));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpDelete));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpMoveTo));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileHelpInstall));
            player.Reply(_sb.ToString());
        }

        [Command("mainstall")]
        private void CommandInstallProfile(IPlayer player, string cmd, string[] args)
        {
            if (!_serverInitialized
                || !VerifyHasPermission(player)
                || !VerifyMonumentFinderLoaded(player))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, LangEntry.ProfileInstallShorthandSyntax);
                return;
            }

            SharedCommandInstallProfile(player, args);
        }

        private void SharedCommandInstallProfile(IPlayer player, string[] args)
        {
            var url = args[0];

            if (!Uri.TryCreate(url, UriKind.Absolute, out var parsedUri))
            {
                var profileName = OfficialProfileNames.GetValueOrDefault(url, url);
                var fallbackUrl = string.Format(DefaultUrlPattern, profileName);
                if (Uri.TryCreate(fallbackUrl, UriKind.Absolute, out parsedUri))
                {
                    url = fallbackUrl;
                }
                else
                {
                    ReplyToPlayer(player, LangEntry.ProfileUrlInvalid, url);
                    return;
                }
            }

            DownloadProfile(
                player,
                url,
                successCallback: profile =>
                {
                    profile.Name = DynamicConfigFile.SanitizeName(profile.Name);

                    if (string.IsNullOrWhiteSpace(profile.Name))
                    {
                        var urlDerivedProfileName = DynamicConfigFile.SanitizeName(parsedUri.Segments.LastOrDefault().Replace(".json", ""));

                        if (string.IsNullOrEmpty(urlDerivedProfileName))
                        {
                            LogError($"Unable to determine profile name from url: \"{url}\". Please ask the URL owner to supply a \"Name\" in the file.");
                            ReplyToPlayer(player, LangEntry.ProfileInstallError, url);
                            return;
                        }

                        profile.Name = urlDerivedProfileName;
                    }

                    if (OriginalProfileStore.IsOriginalProfile(profile.Name))
                    {
                        LogError($"Profile \"{profile.Name}\" should not end with \"{OriginalProfileStore.OriginalSuffix}\".");
                        ReplyToPlayer(player, LangEntry.ProfileInstallError, url);
                        return;
                    }

                    var profileController = _profileManager.GetProfileController(profile.Name);
                    if (profileController != null && !profileController.Profile.IsEmpty())
                    {
                        ReplyToPlayer(player, LangEntry.ProfileAlreadyExistsNotEmpty, profile.Name);
                        return;
                    }

                    _profileStore.Save(profile);
                    _originalProfileStore.Save(profile);

                    profileController ??= _profileManager.GetProfileController(profile.Name);

                    if (profileController == null)
                    {
                        LogError($"Profile \"{profile.Name}\" could not be found on disk after download from url: \"{url}\"");
                        ReplyToPlayer(player, LangEntry.ProfileInstallError, url);
                        return;
                    }

                    if (profileController.IsEnabled)
                    {
                        profileController.Reload(profile);
                    }
                    else
                    {
                        profileController.Enable(profile);
                    }

                    _sb.Clear();
                    _sb.AppendLine(GetMessage(player.Id, LangEntry.ProfileInstallSuccess, profile.Name, GetAuthorSuffix(player, profile.Author)));
                    AddProfileDescription(_sb, player, profileController);
                    player.Reply(_sb.ToString());

                    if (!player.IsServer)
                    {
                        var basePlayer = player.Object as BasePlayer;
                        _adapterDisplayManager.SetPlayerProfile(basePlayer, profileController);
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    }
                },
                errorCallback: player.Reply
            );
        }

        [Command("mashow")]
        private void CommandShow(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            var duration = _config.DebugDisplaySettings.DefaultDisplayDuration;
            string profileName = null;

            foreach (var arg in args)
            {
                if (int.TryParse(arg, out var argIntValue))
                {
                    duration = argIntValue;
                    continue;
                }

                profileName ??= arg;
            }

            ProfileController profileController = null;
            if (profileName != null)
            {
                profileController = _profileManager.GetProfileController(profileName);
                if (profileController == null)
                {
                    ReplyToPlayer(player, LangEntry.ProfileNotFound, profileName);
                    return;
                }
            }

            _adapterDisplayManager.SetPlayerProfile(basePlayer, profileController);
            _adapterDisplayManager.ShowAllRepeatedly(basePlayer, duration);

            ReplyToPlayer(player, LangEntry.ShowSuccess, FormatTime(duration));
        }

        [Command("maspawngroup", "masg")]
        private void CommandSpawnGroup(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (args.Length < 1)
            {
                SubCommandSpawnGroupHelp(player, cmd);
                return;
            }

            var subCommandLower = args[0].ToLower();
            switch (subCommandLower)
            {
                case "create":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.SpawnGroupCreateSyntax, cmd);
                        return;
                    }

                    var spawnGroupName = args[1];

                    if (!VerifyMonumentFinderLoaded(player)
                        || !VerifyProfileSelected(player, out var profileController)
                        || !VerifyLookingAtMonumentPosition(player, out var position, out var monument)
                        || !VerifySpawnGroupNameAvailable(player, profileController.Profile, monument, spawnGroupName))
                        return;

                    DetermineLocalTransformData(position, basePlayer, monument, out var localPosition, out var localRotationAngles, out var isOnTerrain);

                    var spawnGroupData = _config.AddonDefaults.SpawnGroups.ApplyTo(new SpawnGroupData
                    {
                        Id = Guid.NewGuid(),
                        Name = spawnGroupName,
                        SpawnPoints = new List<SpawnPointData>
                        {
                            _config.AddonDefaults.SpawnPoints.ApplyTo(new SpawnPointData
                            {
                                Id = Guid.NewGuid(),
                                Position = localPosition,
                                RotationAngles = localRotationAngles,
                                SnapToTerrain = isOnTerrain,
                            }),
                        },
                    });

                    var matchingMonuments = GetMonumentsByIdentifier(monument.UniqueName);

                    profileController.Profile.AddData(monument.UniqueName, spawnGroupData);
                    _profileStore.Save(profileController.Profile);
                    profileController.SpawnNewData(spawnGroupData, matchingMonuments);

                    ReplyToPlayer(player, LangEntry.SpawnGroupCreateSucces, spawnGroupName);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                case "set":
                {
                    if (args.Length < 3)
                    {
                        _sb.Clear();
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.ErrorSetSyntaxGeneric, cmd, subCommandLower));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpName));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpColor));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpMaxPopulation));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpRespawnDelayMin));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpRespawnDelayMax));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpSpawnPerTickMin));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpSpawnPerTickMax));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpInitialSpawn));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpPreventDuplicates));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpPauseScheduleWhileFull));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupSetHelpRespawnWhenNearestPuzzleResets));
                        player.Reply(_sb.ToString());
                        return;
                    }

                    if (!VerifyValidEnumValue(player, args[1], out SpawnGroupOption spawnGroupOption))
                        return;

                    if (!VerifyLookingAtAdapter(player, out SpawnPointAdapter spawnPointAdapter, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    var spawnGroupData = spawnGroupController.SpawnGroupData;
                    object setValue = args[2];

                    var showImmediate = true;

                    switch (spawnGroupOption)
                    {
                        case SpawnGroupOption.Name:
                        {
                            if (!VerifySpawnGroupNameAvailable(player, spawnGroupController.Profile, spawnPointAdapter.Monument, args[2], spawnGroupController))
                                return;

                            spawnGroupData.Name = args[2];
                            break;
                        }

                        case SpawnGroupOption.Color:
                        {
                            if (StringUtils.EqualsCaseInsensitive(args[2], "none"))
                            {
                                spawnGroupData.Color = null;
                                break;
                            }
                            else if (ColorUtility.TryParseHtmlString(args[2], out var color))
                            {
                                spawnGroupData.Color = color;
                                break;
                            }

                            ReplyToPlayer(player, LangEntry.ErrorSetSyntax, cmd, SpawnGroupOption.Color);
                            return;
                        }

                        case SpawnGroupOption.MaxPopulation:
                        {
                            if (!VerifyValidInt(player, args[2], out var maxPopulation, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.MaxPopulation)))
                                return;

                            spawnGroupData.MaxPopulation = maxPopulation;
                            break;
                        }

                        case SpawnGroupOption.RespawnDelayMin:
                        {
                            if (!VerifyValidFloat(player, args[2], out var respawnDelayMin, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.RespawnDelayMin)))
                                return;

                            showImmediate = respawnDelayMin == 0 || spawnGroupData.RespawnDelayMax != 0;
                            spawnGroupData.RespawnDelayMin = respawnDelayMin;
                            spawnGroupData.RespawnDelayMax = Math.Max(respawnDelayMin, spawnGroupData.RespawnDelayMax);
                            setValue = respawnDelayMin;
                            break;
                        }

                        case SpawnGroupOption.RespawnDelayMax:
                        {
                            if (!VerifyValidFloat(player, args[2], out var respawnDelayMax, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.RespawnDelayMax)))
                                return;

                            showImmediate = (respawnDelayMax == 0) == (spawnGroupData.RespawnDelayMax == 0);
                            spawnGroupData.RespawnDelayMax = respawnDelayMax;
                            spawnGroupData.RespawnDelayMin = Math.Min(spawnGroupData.RespawnDelayMin, respawnDelayMax);
                            setValue = respawnDelayMax;
                            break;
                        }

                        case SpawnGroupOption.SpawnPerTickMin:
                        {
                            if (!VerifyValidInt(player, args[2], out var spawnPerTickMin, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.SpawnPerTickMin)))
                                return;

                            spawnGroupData.SpawnPerTickMin = spawnPerTickMin;
                            spawnGroupData.SpawnPerTickMax = Math.Max(spawnPerTickMin, spawnGroupData.SpawnPerTickMax);
                            setValue = spawnPerTickMin;
                            break;
                        }

                        case SpawnGroupOption.SpawnPerTickMax:
                        {
                            if (!VerifyValidInt(player, args[2], out var spawnPerTickMax, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.SpawnPerTickMax)))
                                return;

                            spawnGroupData.SpawnPerTickMax = spawnPerTickMax;
                            spawnGroupData.SpawnPerTickMin = Math.Min(spawnGroupData.SpawnPerTickMin, spawnPerTickMax);
                            setValue = spawnPerTickMax;
                            break;
                        }

                        case SpawnGroupOption.InitialSpawn:
                        {
                            if (!VerifyValidBool(player, args[2], out var initialSpawn, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.PreventDuplicates)))
                                return;

                            spawnGroupData.InitialSpawn = initialSpawn;
                            setValue = initialSpawn;
                            showImmediate = false;
                            break;
                        }

                        case SpawnGroupOption.PreventDuplicates:
                        {
                            if (!VerifyValidBool(player, args[2], out var preventDuplicates, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.PreventDuplicates)))
                                return;

                            spawnGroupData.PreventDuplicates = preventDuplicates;
                            setValue = preventDuplicates;
                            showImmediate = false;
                            break;
                        }

                        case SpawnGroupOption.PauseScheduleWhileFull:
                        {
                            if (!VerifyValidBool(player, args[2], out var pauseScheduleWhileFull, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.PauseScheduleWhileFull)))
                                return;

                            spawnGroupData.PauseScheduleWhileFull = pauseScheduleWhileFull;
                            setValue = pauseScheduleWhileFull;
                            showImmediate = false;
                            break;
                        }

                        case SpawnGroupOption.RespawnWhenNearestPuzzleResets:
                        {
                            if (!VerifyValidBool(player, args[2], out var respawnWhenNearestPuzzleResets, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnGroupOption.RespawnWhenNearestPuzzleResets)))
                                return;

                            spawnGroupData.RespawnWhenNearestPuzzleResets = respawnWhenNearestPuzzleResets;
                            setValue = respawnWhenNearestPuzzleResets;
                            showImmediate = false;
                            break;
                        }
                    }

                    spawnGroupController.UpdateSpawnGroups();
                    _profileStore.Save(spawnGroupController.Profile);

                    ReplyToPlayer(player, LangEntry.SpawnGroupSetSuccess, spawnGroupData.Name, spawnGroupOption, setValue);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: showImmediate);
                    break;
                }

                case "add":
                {
                    var weight = 100;
                    if (args.Length < 2 || args.Length >= 3 && !int.TryParse(args[2], out weight))
                    {
                        ReplyToPlayer(player, LangEntry.SpawnGroupAddSyntax, cmd);
                        return;
                    }

                    if (!VerifyValidEntityPrefabOrCustomAddon(player, args[1], out var prefabPath, out var customAddonDefinition))
                        return;

                    if (!VerifyLookingAtAdapter(player, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    var updatedExistingEntry = false;

                    var spawnGroupData = spawnGroupController.SpawnGroupData;
                    var prefabData = customAddonDefinition != null
                        ? spawnGroupData.Prefabs.FirstOrDefault(entry => entry.CustomAddonName == customAddonDefinition?.AddonName)
                        : spawnGroupData.Prefabs.FirstOrDefault(entry => entry.PrefabName == prefabPath);

                    if (prefabData != null)
                    {
                        prefabData.Weight = weight;
                        updatedExistingEntry = true;
                    }
                    else
                    {
                        prefabData = new WeightedPrefabData
                        {
                            PrefabName = prefabPath,
                            CustomAddonName = customAddonDefinition?.AddonName,
                            Weight = weight,
                        };
                        spawnGroupData.Prefabs.Add(prefabData);
                    }

                    spawnGroupController.UpdateSpawnGroups();
                    _profileStore.Save(spawnGroupController.Profile);

                    var displayName = prefabData.CustomAddonName ?? _uniqueNameRegistry.GetUniqueShortName(prefabData.PrefabName);
                    ReplyToPlayer(player, LangEntry.SpawnGroupAddSuccess, displayName, weight, spawnGroupData.Name);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: updatedExistingEntry);
                    break;
                }

                case "remove":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.SpawnGroupRemoveSyntax, cmd);
                        return;
                    }

                    if (!VerifyLookingAtAdapter(player, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    string desiredPrefab = args[1];

                    var spawnGroupData = spawnGroupController.SpawnGroupData;
                    if (!VerifySpawnGroupPrefabOrCustomAddon(player, spawnGroupData, desiredPrefab, out var prefabData))
                    {
                        _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                        return;
                    }

                    spawnGroupData.Prefabs.Remove(prefabData);
                    spawnGroupController.StartKillSpawnedInstancesRoutine(prefabData);
                    spawnGroupController.UpdateSpawnGroups();
                    _profileStore.Save(spawnGroupController.Profile);

                    var displayName = prefabData.CustomAddonName ?? _uniqueNameRegistry.GetUniqueShortName(prefabData.PrefabName);
                    ReplyToPlayer(player, LangEntry.SpawnGroupRemoveSuccess, displayName, spawnGroupData.Name);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer, immediate: false);
                    break;
                }

                case "spawn":
                case "tick":
                {
                    if (!VerifyLookingAtAdapter(player, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    spawnGroupController.StartSpawnRoutine();
                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                case "respawn":
                {
                    if (!VerifyLookingAtAdapter(player, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    spawnGroupController.StartRespawnRoutine();
                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                default:
                {
                    SubCommandSpawnGroupHelp(player, cmd);
                    break;
                }
            }
        }

        private void SubCommandSpawnGroupHelp(IPlayer player, string cmd)
        {
            _sb.Clear();
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpHeader));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpCreate, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpSet, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpAdd, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpRemove, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpSpawn, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnGroupHelpRespawn, cmd));
            player.Reply(_sb.ToString());
        }

        [Command("maspawnpoint", "masp")]
        private void CommandSpawnPoint(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (args.Length < 1)
            {
                SubCommandSpawnPointHelp(player, cmd);
                return;
            }

            var subCommandLower = args[0].ToLower();
            switch (subCommandLower)
            {
                case "create":
                {
                    if (args.Length < 2)
                    {
                        ReplyToPlayer(player, LangEntry.SpawnPointCreateSyntax, cmd);
                        return;
                    }

                    if (!VerifyMonumentFinderLoaded(player)
                        || !VerifyLookingAtMonumentPosition(player, out var position, out var monument))
                        return;

                    if (!VerifySpawnGroupFound(player, args[1], monument, out var spawnGroupController))
                        return;

                    DetermineLocalTransformData(position, basePlayer, monument, out var localPosition, out var localRotationAngles, out var isOnTerrain);

                    var spawnPointData = _config.AddonDefaults.SpawnPoints.ApplyTo(new SpawnPointData
                    {
                        Id = Guid.NewGuid(),
                        Position = localPosition,
                        RotationAngles = localRotationAngles,
                        SnapToTerrain = isOnTerrain,
                    });

                    spawnGroupController.SpawnGroupData.SpawnPoints.Add(spawnPointData);
                    _profileStore.Save(spawnGroupController.Profile);
                    spawnGroupController.CreateSpawnPoint(spawnPointData);

                    ReplyToPlayer(player, LangEntry.SpawnPointCreateSuccess, spawnGroupController.SpawnGroupData.Name);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                case "set":
                case "setall":
                {
                    if (args.Length < 3)
                    {
                        _sb.Clear();
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.ErrorSetSyntaxGeneric, cmd, subCommandLower));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpExclusive));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpSnapToGround));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpCheckSpace));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpRandomRotation));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpRandomRadius));
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointSetHelpPlayerDetectionRadius));
                        player.Reply(_sb.ToString());
                        return;
                    }

                    if (!VerifyValidEnumValue(player, args[1], out SpawnPointOption spawnPointOption))
                        return;

                    if (!VerifyLookingAtAdapter(player, out SpawnPointAdapter spawnPointAdapter, out SpawnGroupController spawnGroupController, LangEntry.ErrorNoSpawnPointFound))
                        return;

                    var spawnPointArgs = new SpawnPointData.Args();
                    object setValue = args[2];

                    switch (spawnPointOption)
                    {
                        case SpawnPointOption.Exclusive:
                        {
                            if (!VerifyValidBool(player, args[2], out var exclusive, LangEntry.SpawnGroupSetSuccess.Bind(LangEntry.ErrorSetSyntax, cmd, SpawnPointOption.Exclusive)))
                                return;

                            spawnPointArgs.Exclusive = exclusive;
                            setValue = exclusive;
                            break;
                        }

                        case SpawnPointOption.SnapToGround:
                        {
                            if (!VerifyValidBool(player, args[2], out var snapToGround, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnPointOption.SnapToGround)))
                                return;

                            spawnPointArgs.SnapToGround = snapToGround;
                            setValue = snapToGround;
                            break;
                        }

                        case SpawnPointOption.CheckSpace:
                        {
                            if (!VerifyValidBool(player, args[2], out var checkSpace, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnPointOption.CheckSpace)))
                                return;

                            spawnPointArgs.CheckSpace = checkSpace;
                            setValue = checkSpace;
                            break;
                        }

                        case SpawnPointOption.RandomRotation:
                        {
                            if (!VerifyValidBool(player, args[2], out var randomRotation, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnPointOption.RandomRotation)))
                                return;

                            spawnPointArgs.RandomRotation = randomRotation;
                            setValue = randomRotation;
                            break;
                        }

                        case SpawnPointOption.RandomRadius:
                        {
                            if (!VerifyValidFloat(player, args[2], out var radius, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnPointOption.RandomRadius)))
                                return;

                            spawnPointArgs.RandomRadius = radius;
                            setValue = radius;
                            break;
                        }

                        case SpawnPointOption.PlayerDetectionRadius:
                        {
                            if (!VerifyValidFloat(player, args[2], out var radius, LangEntry.ErrorSetSyntax.Bind(cmd, SpawnPointOption.PlayerDetectionRadius)))
                                return;

                            spawnPointArgs.PlayerDetectionRadius = radius;
                            setValue = radius;
                            break;
                        }
                    }

                    var doSetAll = subCommandLower == "setall";
                    if (doSetAll)
                    {
                        foreach (var spawnPointData in spawnPointAdapter.SpawnGroupAdapter.SpawnGroupData.SpawnPoints)
                        {
                            spawnPointArgs.ApplyTo(spawnPointData);
                        }
                    }
                    else
                    {
                        spawnPointArgs.ApplyTo(spawnPointAdapter.SpawnPointData);
                    }

                    _profileStore.Save(spawnGroupController.Profile);

                    ReplyToPlayer(player, doSetAll ? LangEntry.SpawnPointSetAllSuccess : LangEntry.SpawnPointSetSuccess, spawnPointOption, setValue);

                    _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
                    break;
                }

                default:
                {
                    SubCommandSpawnPointHelp(player, cmd);
                    break;
                }
            }
        }

        private void SubCommandSpawnPointHelp(IPlayer player, string cmd)
        {
            _sb.Clear();
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointHelpHeader));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointHelpCreate, cmd));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.SpawnPointHelpSet, cmd));
            player.Reply(_sb.ToString());
        }

        [Command("mapaste")]
        private void CommandPaste(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (args.Length < 1)
            {
                ReplyToPlayer(player, LangEntry.PasteSyntax);
                return;
            }

            if (!PasteUtils.IsCopyPasteCompatible(CopyPaste))
            {
                ReplyToPlayer(player, LangEntry.PasteNotCompatible);
                return;
            }

            if (!VerifyMonumentFinderLoaded(player)
                || !VerifyProfileSelected(player, out var profileController)
                || !VerifyLookingAtMonumentPosition(player, out var position, out var monument))
                return;

            var pasteName = args[0];

            if (!PasteUtils.DoesPasteExist(pasteName))
            {
                ReplyToPlayer(player, LangEntry.PasteNotFound, pasteName);
                return;
            }

            DetermineLocalTransformData(position, basePlayer, monument, out var localPosition, out var localRotationAngles, out var isOnTerrain, flipRotation: false);

            var pasteData = new PasteData
            {
                Id = Guid.NewGuid(),
                Position = localPosition,
                RotationAngles = localRotationAngles,
                SnapToTerrain = isOnTerrain,
                Filename = pasteName,
                Args = args.Skip(1).ToArray(),
            };

            var matchingMonuments = GetMonumentsByIdentifier(monument.UniqueName);

            profileController.Profile.AddData(monument.UniqueName, pasteData);
            _profileStore.Save(profileController.Profile);
            profileController.SpawnNewData(pasteData, matchingMonuments);

            ReplyToPlayer(player, LangEntry.PasteSuccess, pasteName, monument.UniqueDisplayName, matchingMonuments.Count, profileController.Profile.Name);

            _adapterDisplayManager.ShowAllRepeatedly(basePlayer);
        }

        private void AddSpawnGroupInfo(IPlayer player, StringBuilder sb, SpawnGroup spawnGroup, int spawnPointCount)
        {
            sb.AppendLine($"<size={AdapterDisplayManager.HeaderSize}>{GetMessage(player.Id, LangEntry.ShowHeaderVanillaSpawnGroup, spawnGroup.name)}</size>");
            sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnPoints, spawnPointCount));

            if ((int)spawnGroup.Tier != -1)
            {
                sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelTiers, string.Join(", ", GetTierList(spawnGroup.Tier))));
            }

            if (spawnGroup.wantsInitialSpawn)
            {
                if (spawnGroup.temporary)
                {
                    sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnWhenParentSpawns));
                }
                else if (spawnGroup.forceInitialSpawn)
                {
                    sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnOnServerStart));
                }
                else
                {
                    sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnOnMapWipe));
                }
            }

            if (spawnGroup.preventDuplicates && spawnGroup.prefabs.Count > 1)
            {
                sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelPreventDuplicates));
            }

            sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelPopulation, spawnGroup.currentPopulation, spawnGroup.maxPopulation));
            sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelRespawnPerTick, spawnGroup.numToSpawnPerTickMin, spawnGroup.numToSpawnPerTickMax));

            if (!spawnGroup.temporary)
            {
                if (!float.IsPositiveInfinity(spawnGroup.respawnDelayMin))
                {
                    sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelRespawnDelay, FormatTime(spawnGroup.respawnDelayMin), FormatTime(spawnGroup.respawnDelayMax)));
                }

                var nextSpawnTime = GetTimeToNextSpawn(spawnGroup);
                if (!float.IsPositiveInfinity(nextSpawnTime) && SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Contains(spawnGroup))
                {
                    sb.AppendLine(GetMessage(
                        player.Id,
                        LangEntry.ShowLabelNextSpawn,
                        nextSpawnTime <= 0
                            ? GetMessage(player.Id, LangEntry.ShowLabelNextSpawnQueued)
                            : FormatTime(Mathf.CeilToInt(nextSpawnTime))
                    ));
                }
            }

            if (spawnGroup.prefabs.Count > 0)
            {
                var totalWeight = 0;
                foreach (var prefab in spawnGroup.prefabs)
                {
                    totalWeight += prefab.weight;
                }

                sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelEntities));
                foreach (var prefabEntry in spawnGroup.prefabs)
                {
                    var relativeChance = (float)prefabEntry.weight / totalWeight;
                    sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelEntityDetail, _uniqueNameRegistry.GetUniqueShortName(prefabEntry.prefab.resourcePath), prefabEntry.weight, relativeChance));
                }
            }
            else
            {
                sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelNoEntities));
            }
        }

        [Command("mashowvanilla")]
        private void CommandShowVanillaSpawns(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            Transform parentObject = null;

            if (TryRaycast(basePlayer, out var hit))
            {
                parentObject = hit.GetEntity()?.transform;
            }

            if (parentObject == null)
            {
                if (!VerifyMonumentFinderLoaded(player)
                    || !VerifyHitPosition(player, out var position)
                    || !VerifyAtMonument(player, position, out var monument))
                    return;

                parentObject = monument.Object.transform;
            }

            var spawnerList = parentObject.GetComponentsInChildren<ISpawnGroup>();
            if (spawnerList.Length == 0)
            {
                var grandParent = parentObject.transform.parent;
                if (grandParent != null && grandParent != parentObject.transform.root)
                {
                    parentObject = grandParent;
                    spawnerList = parentObject.GetComponentsInChildren<ISpawnGroup>();
                }
            }

            if (spawnerList.Length == 0)
            {
                ReplyToPlayer(player, LangEntry.ShowVanillaNoSpawnPoints, parentObject.name);
                return;
            }

            _colorRotator.Reset();

            var playerPosition = basePlayer.transform.position;

            foreach (var spawner in spawnerList)
            {
                var spawnGroup = spawner as SpawnGroup;
                if (spawnGroup != null)
                {
                    var spawnPointList = spawnGroup.spawnPoints;
                    if (spawnPointList == null || spawnPointList.Length == 0)
                    {
                        spawnPointList = spawnGroup.GetComponentsInChildren<BaseSpawnPoint>();
                    }

                    var drawer = new Ddraw(basePlayer, ShowVanillaDuration, _colorRotator.GetNext());
                    var tierMask = (int)spawnGroup.Tier;

                    if (spawnPointList.Length == 0)
                    {
                        _sb.Clear();
                        AddSpawnGroupInfo(player, _sb, spawnGroup, spawnPointList.Length);
                        var spawnGroupPosition = spawnGroup.transform.position;

                        drawer.Sphere(spawnGroupPosition, 0.5f);
                        drawer.Text(spawnGroupPosition + new Vector3(0, tierMask > 0 ? Mathf.Log(tierMask, 2) : 0, 0), _sb.ToString());
                        continue;
                    }

                    BaseSpawnPoint closestSpawnPoint = null;
                    var closestDistanceSquared = float.MaxValue;

                    foreach (var spawnPoint in spawnPointList)
                    {
                        var distanceSquared = (playerPosition - spawnPoint.transform.position).sqrMagnitude;
                        if (distanceSquared < closestDistanceSquared)
                        {
                            closestSpawnPoint = spawnPoint;
                            closestDistanceSquared = distanceSquared;
                        }
                    }

                    var closestSpawnPointPosition = closestSpawnPoint.transform.position;

                    foreach (var spawnPoint in spawnPointList)
                    {
                        _sb.Clear();
                        _sb.AppendLine($"<size={AdapterDisplayManager.HeaderSize}>{GetMessage(player.Id, LangEntry.ShowHeaderVanillaSpawnPoint, spawnGroup.name)}</size>");

                        var booleanProperties = new List<string>();

                        var genericSpawnPoint = spawnPoint as GenericSpawnPoint;
                        if (genericSpawnPoint != null)
                        {
                            booleanProperties.Add(GetMessage(player.Id, LangEntry.ShowLabelSpawnPointExclusive));

                            if (genericSpawnPoint.randomRot)
                            {
                                booleanProperties.Add(GetMessage(player.Id, LangEntry.ShowLabelSpawnPointRandomRotation));
                            }

                            if (genericSpawnPoint.dropToGround)
                            {
                                booleanProperties.Add(GetMessage(player.Id, LangEntry.ShowLabelSpawnPointSnapToGround));
                            }
                        }

                        var spaceCheckingSpawnPoint = spawnPoint as SpaceCheckingSpawnPoint;
                        if (spaceCheckingSpawnPoint != null)
                        {
                            booleanProperties.Add(GetMessage(player.Id, LangEntry.ShowLabelSpawnPointCheckSpace));
                        }

                        if (booleanProperties.Count > 0)
                        {
                            _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelFlags, string.Join(" | ", booleanProperties)));
                        }

                        var radialSpawnPoint = spawnPoint as RadialSpawnPoint;
                        if (radialSpawnPoint != null)
                        {
                            _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnPointRandomRadius, radialSpawnPoint.radius));
                        }

                        if (spawnPoint == closestSpawnPoint)
                        {
                            _sb.AppendLine(AdapterDisplayManager.Divider);
                            AddSpawnGroupInfo(player, _sb, spawnGroup, spawnPointList.Length);
                        }

                        var spawnPointTransform = spawnPoint.transform;
                        var spawnPointPosition = spawnPointTransform.position;
                        drawer.Arrow(spawnPointPosition + AdapterDisplayManager.ArrowVerticalOffeset, spawnPointTransform.rotation, 1, 0.15f);
                        drawer.Sphere(spawnPointPosition, 0.5f);
                        drawer.Text(spawnPointPosition + new Vector3(0, tierMask > 0 ? Mathf.Log(tierMask, 2) : 0, 0), _sb.ToString());

                        if (spawnPoint != closestSpawnPoint)
                        {
                            drawer.Arrow(closestSpawnPointPosition + AdapterDisplayManager.ArrowVerticalOffeset, spawnPointPosition + AdapterDisplayManager.ArrowVerticalOffeset, 0.25f);
                        }
                    }

                    continue;
                }

                var individualSpawner = spawner as IndividualSpawner;
                if (individualSpawner != null)
                {
                    var drawer = new Ddraw(basePlayer, ShowVanillaDuration, _colorRotator.GetNext());

                    _sb.Clear();
                    _sb.AppendLine($"<size={AdapterDisplayManager.HeaderSize}>{GetMessage(player.Id, LangEntry.ShowHeaderVanillaIndividualSpawnPoint, individualSpawner.name)}</size>");
                    _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelFlags, $"{GetMessage(player.Id, LangEntry.ShowLabelSpawnPointExclusive)} | {GetMessage(player.Id, LangEntry.ShowLabelSpawnPointCheckSpace)}"));

                    if (individualSpawner.oneTimeSpawner)
                    {
                        _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelSpawnOnMapWipe));
                    }
                    else
                    {
                        if (!float.IsPositiveInfinity(individualSpawner.respawnDelayMin))
                        {
                            _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowLabelRespawnDelay, FormatTime(individualSpawner.respawnDelayMin), FormatTime(individualSpawner.respawnDelayMax)));
                        }

                        var nextSpawnTime = GetTimeToNextSpawn(individualSpawner);
                        if (!individualSpawner.IsSpawned && !float.IsPositiveInfinity(nextSpawnTime))
                        {
                            _sb.AppendLine(GetMessage(
                                player.Id,
                                LangEntry.ShowLabelNextSpawn,
                                nextSpawnTime <= 0
                                    ? GetMessage(player.Id, LangEntry.ShowLabelNextSpawnQueued)
                                    : FormatTime(Mathf.CeilToInt(nextSpawnTime))
                            ));
                        }
                    }

                    _sb.AppendLine(GetMessage(player.Id, LangEntry.ShowHeaderEntity, _uniqueNameRegistry.GetUniqueShortName(individualSpawner.entityPrefab.resourcePath)));

                    var spawnerTransform = individualSpawner.transform;
                    var spawnPointPosition = spawnerTransform.position;
                    drawer.Arrow(spawnPointPosition + AdapterDisplayManager.ArrowVerticalOffeset, spawnerTransform.rotation, 1f, 0.15f);
                    drawer.Sphere(spawnPointPosition, 0.5f);
                    drawer.Text(spawnPointPosition, _sb.ToString());
                    continue;
                }
            }
        }

        [Command("magenerate")]
        private void CommandGenerateSpawnPointProfile(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer)
                || !VerifyHasPermission(player)
                || !VerifyMonumentFinderLoaded(player)
                || !VerifyHitPosition(player, out var position)
                || !VerifyAtMonument(player, position, out var monument))
                return;

            var parentObject = monument.Object.transform;

            var spawnerList = parentObject.GetComponentsInChildren<ISpawnGroup>();
            if (spawnerList.Length == 0)
            {
                var grandParent = parentObject.transform.parent;
                if (grandParent != null && grandParent != parentObject.transform.root)
                {
                    parentObject = grandParent;
                    spawnerList = parentObject.GetComponentsInChildren<ISpawnGroup>();
                }
            }

            if (spawnerList.Length == 0)
            {
                ReplyToPlayer(player, LangEntry.ShowVanillaNoSpawnPoints, parentObject.name);
                return;
            }

            var monumentTierMask = GetMonumentTierMask(monument.Position);
            var monumentTierList = GetTierList(monumentTierMask);
            var spawnGroupsSpecifyTier = false;

            var spawnGroupDataList = new List<SpawnGroupData>();

            foreach (var spawner in spawnerList)
            {
                var spawnGroup = spawner as SpawnGroup;
                if (spawnGroup != null)
                {
                    if (spawnGroup.spawnPoints.Length == 0)
                        continue;

                    if ((int)spawnGroup.Tier != -1)
                    {
                        spawnGroupsSpecifyTier = true;

                        if ((spawnGroup.Tier & monumentTierMask) == 0)
                        {
                            // Don't add spawn groups with different tiers. This can be improved later.
                            continue;
                        }
                    }

                    var spawnGroupData = new SpawnGroupData
                    {
                        Id = Guid.NewGuid(),
                        Name = spawnGroup.name,
                        MaxPopulation = spawnGroup.maxPopulation,
                        RespawnDelayMin = spawnGroup.respawnDelayMin,
                        RespawnDelayMax = spawnGroup.respawnDelayMax,
                        SpawnPerTickMin = spawnGroup.numToSpawnPerTickMin,
                        SpawnPerTickMax = spawnGroup.numToSpawnPerTickMax,
                        PreventDuplicates = spawnGroup.preventDuplicates,
                    };

                    spawnGroupDataList.Add(spawnGroupData);

                    foreach (var prefabEntry in spawnGroup.prefabs)
                    {
                        spawnGroupData.Prefabs.Add(new WeightedPrefabData
                        {
                            PrefabName = prefabEntry.prefab.resourcePath,
                            Weight = prefabEntry.weight,
                        });
                    }

                    foreach (var spawnPoint in spawnGroup.spawnPoints)
                    {
                        var spawnPointData = new SpawnPointData
                        {
                            Id = Guid.NewGuid(),
                            Position = monument.InverseTransformPoint(spawnPoint.transform.position),
                            RotationAngles = (Quaternion.Inverse(monument.Rotation) * spawnPoint.transform.rotation).eulerAngles,
                        };

                        var genericSpawnPoint = spawnPoint as GenericSpawnPoint;
                        if (genericSpawnPoint != null)
                        {
                            spawnPointData.Exclusive = true;
                            spawnPointData.RandomRotation = genericSpawnPoint.randomRot;
                            spawnPointData.SnapToGround = genericSpawnPoint.dropToGround;
                        }

                        var radialSpawnPoint = spawnPoint as RadialSpawnPoint;
                        if (radialSpawnPoint != null)
                        {
                            spawnPointData.RandomRotation = true;
                            spawnPointData.RandomRadius = radialSpawnPoint.radius;
                        }

                        if (spawnPoint is SpaceCheckingSpawnPoint)
                        {
                            spawnPointData.CheckSpace = true;
                        }

                        spawnGroupData.SpawnPoints.Add(spawnPointData);
                    }

                    continue;
                }
            }

            var tierSuffix = spawnGroupsSpecifyTier && monumentTierList.Count > 0
                ? $"_{string.Join("_", monumentTierList)}"
                : string.Empty;

            var profileName = $"{monument.UniqueDisplayName}{tierSuffix}_vanilla_generated";
            var profile = _profileStore.Create(profileName, basePlayer.displayName);

            foreach (var data in spawnGroupDataList)
            {
                profile.AddData(monument.UniqueName, data);
            }

            _profileStore.Save(profile);

            ReplyToPlayer(player, LangEntry.GenerateSuccess, profileName);
        }

        [Command("mawire")]
        private void CommandWire(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyPlayer(player, out var basePlayer) || !VerifyHasPermission(player))
                return;

            if (_wireToolManager.HasPlayer(basePlayer) && args.Length == 0)
            {
                _wireToolManager.StopSession(basePlayer);
                return;
            }

            WireColour? wireColor;
            if (args.Length > 0)
            {
                if (StringUtils.EqualsCaseInsensitive(args[0], "invisible"))
                {
                    wireColor = null;
                }
                else if (Enum.TryParse(args[0], ignoreCase: true, result: out WireColour parsedWireColor))
                {
                    wireColor = parsedWireColor;
                }
                else
                {
                    ReplyToPlayer(player, LangEntry.WireToolInvalidColor, args[0]);
                    return;
                }
            }
            else
            {
                wireColor = WireColour.Gray;
            }

            var activeItemShortName = basePlayer.GetActiveItem()?.info.shortname;
            if (activeItemShortName != "wiretool" && activeItemShortName != "hosetool")
            {
                ReplyToPlayer(player, LangEntry.WireToolNotEquipped);
                return;
            }

            _wireToolManager.StartOrUpdateSession(basePlayer, wireColor);

            ChatMessage(basePlayer, LangEntry.WireToolActivated, wireColor?.ToString() ?? GetMessage(player.Id, LangEntry.WireToolInvisible));
        }

        [Command("mahelp")]
        private void CommandHelp(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player))
                return;

            _sb.Clear();
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpHeader));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSpawn));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpPrefab));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpKill));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpUndo));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSave));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpFlag));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSkin));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSetId));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSetDir));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSkull));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpTrophy));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpCardReaderLevel));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpPuzzle));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSpawnGroup));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpSpawnPoint));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpPaste));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpEdit));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpShow));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpShowVanilla));
            _sb.AppendLine(GetMessage(player.Id, LangEntry.HelpProfile));
            player.Reply(_sb.ToString());
        }

        #endregion

        #region API

        [HookMethod(nameof(API_RegisterCustomAddon))]
        public Dictionary<string, object> API_RegisterCustomAddon(Plugin plugin, string addonName, Dictionary<string, object> addonSpec)
        {
            var addonDefinition = CustomAddonDefinition.FromDictionary(addonName, plugin, addonSpec);
            if (!addonDefinition.Validate())
                return null;

            if (_customAddonManager.IsRegistered(addonName, out var otherPlugin))
            {
                if (otherPlugin.Name != plugin.Name)
                {
                    LogError($"Unable to register custom addon \"{addonName}\" for plugin {plugin.Name} because it's already been registered by plugin {otherPlugin.Name}.");
                    return null;
                }
            }
            else
            {
                _customAddonManager.RegisterAddon(addonDefinition);
            }

            return addonDefinition.ToApiResult(_profileStore);
        }

        [HookMethod(nameof(API_RegisterCustomMonument))]
        public object API_RegisterCustomMonument(Plugin plugin, string monumentName, Component component, Bounds bounds)
        {
            var objectType = component is BaseEntity ? "entity" : "object";

            if (plugin == null)
            {
                LogError($"A plugin has attempted to register an {objectType} as a custom monument, but the plugin did not identify itself.");
                return False;
            }

            if (String.IsNullOrWhiteSpace(monumentName))
            {
                LogError($"Plugin {plugin.Name} tried to register an {objectType} as a custom monument, but did not provide a valid monument name.");
                return False;
            }

            if (component == null || (component is BaseEntity { IsDestroyed: true }))
            {
                LogError($"Plugin {plugin.Name} tried to register a null or destroyed {objectType} as a custom monument.");
                return False;
            }

            if (bounds == default)
            {
                LogWarning($"Plugin {plugin.Name} tried to register an {objectType} as a custom monument, but did not provide bounds. This was most likely a mistake by the developer of {plugin.Name} ({plugin.Author}).");
            }

            var existingMonument = _customMonumentManager.FindByComponent(component);
            if (existingMonument != null)
            {
                if (existingMonument.OwnerPlugin.Name != plugin.Name)
                {
                    LogError($"Plugin {plugin.Name} tried to register an {objectType} at {component.transform.position} as a custom monument with name '{monumentName}', but that {objectType} was already registered by plugin {existingMonument.OwnerPlugin.Name} with name '{existingMonument.UniqueName}'.");
                    return False;
                }
                else if (existingMonument.UniqueName != monumentName)
                {
                    LogError($"Plugin {plugin.Name} tried to register an {objectType} at {component.transform.position} as a custom monument with name '{monumentName}', but that {objectType} was already registered with name '{existingMonument.UniqueName}'.");
                    return False;
                }
                else if (existingMonument.Bounds != bounds)
                {
                    // Changing the bounds is permitted.
                    existingMonument.Bounds = bounds;
                    return True;
                }
                else
                {
                    LogWarning($"Plugin {plugin.Name} tried to double register a monument '{monumentName}'. This is OK but may be a mistake by the developer of {plugin.Name} ({plugin.Author}).");
                    return True;
                }
            }

            var monument = component is BaseEntity entity
                ? new CustomEntityMonument(plugin, entity, monumentName, bounds)
                : new CustomMonument(plugin, component, monumentName, bounds);

            _customMonumentManager.Register(monument);
            CustomMonumentComponent.AddToMonument(_customMonumentManager, monument);
            _coroutineManager.StartCoroutine(_profileManager.PartialLoadForLateMonumentRoutine(monument));

            LogInfo($"Plugin {plugin.Name} successfully registered an {objectType} at {component.transform.position} as a custom monument with name '{monumentName}'.");
            return True;
        }

        [HookMethod(nameof(API_UnregisterCustomMonument))]
        public object API_UnregisterCustomMonument(Plugin plugin, Component component)
        {
            var objectType = component is BaseEntity ? "entity" : "object";

            if (component == null || (component is BaseEntity { IsDestroyed: true }))
            {
                LogWarning($"Plugin {plugin.Name} tried to unregister a null or destroyed {objectType} as a custom monument. This is not necessary because {Name} automatically detects when custom monuments are destroyed and despawns associated addons. This is OK but may be a mistake by the developer of {plugin.Name} ({plugin.Author}).");
                return True;
            }

            var existingMonument = _customMonumentManager.FindByComponent(component);
            if (existingMonument == null)
            {
                LogError($"Plugin {plugin.Name} tried to unregister an {objectType} at {component.transform.position} as a custom monument, but that {objectType} was not currently registered as a custom monument. Either the {objectType} was unregistered earlier, or the wrong {objectType} was provided. This was most likely a mistake by the developer of {plugin.Name} ({plugin.Author}).");
                return True;
            }

            if (existingMonument.OwnerPlugin.Name != plugin.Name)
            {
                LogError($"Plugin {plugin.Name} tried to unregister an {objectType} at {component.transform.position} as a custom monument, but that {objectType} was registered as a custom monument by plugin {existingMonument.OwnerPlugin.Name}, so this was not allowed.");
                return False;
            }

            _customMonumentManager.Unregister(existingMonument);
            LogInfo($"Plugin {plugin.Name} successfully unregistered an {objectType} at {component.transform.position} as a custom monument with name '{existingMonument.UniqueName}'.");
            return True;
        }

        #endregion

        #region Utilities

        private static class ObjectCache
        {
            private static readonly object True = true;
            private static readonly object False = false;

            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new();

                public static object Get(T value)
                {
                    if (!_cacheByValue.TryGetValue(value, out var cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }
                    return cachedObject;
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static object Get(bool value)
            {
                return value ? True : False;
            }
        }

        #region Helper Methods - Command Checks

        private bool VerifyPlayer(IPlayer player, out BasePlayer basePlayer)
        {
            if (player.IsServer)
            {
                basePlayer = null;
                return false;
            }

            basePlayer = player.Object as BasePlayer;
            return true;
        }

        private bool VerifyHasPermission(IPlayer player, string perm = PermissionAdmin)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, LangEntry.ErrorNoPermission);
            return false;
        }

        private bool VerifyValidInt<T>(IPlayer player, string arg, out int value, T errorFormatter) where T : IMessageFormatter
        {
            if (int.TryParse(arg, out value))
                return true;

            ReplyToPlayer(player, errorFormatter);
            return false;
        }

        private bool VerifyValidFloat<T>(IPlayer player, string arg, out float value, T errorFormatter) where T : IMessageFormatter
        {
            if (float.TryParse(arg, out value))
                return true;

            ReplyToPlayer(player, errorFormatter);
            return false;
        }

        private bool VerifyValidBool<T>(IPlayer player, string arg, out bool value, T errorFormatter) where T : IMessageFormatter
        {
            if (BooleanParser.TryParse(arg, out value))
                return true;

            ReplyToPlayer(player, errorFormatter);
            return false;
        }

        private bool VerifyValidEnumValue<T>(IPlayer player, string arg, out T enumValue) where T : struct
        {
            if (TryParseEnum(arg, out enumValue))
                return true;

            ReplyToPlayer(player, LangEntry.ErrorSetUnknownOption, arg);
            return false;
        }

        private bool VerifyMonumentFinderLoaded(IPlayer player)
        {
            if (MonumentFinder != null)
                return true;

            ReplyToPlayer(player, LangEntry.ErrorMonumentFinderNotLoaded);
            return false;
        }

        private bool VerifyProfileSelected(IPlayer player, out ProfileController profileController)
        {
            profileController = _profileManager.GetPlayerProfileControllerOrDefault(player.Id);
            if (profileController != null)
                return true;

            ReplyToPlayer(player, LangEntry.SpawnErrorNoProfileSelected);
            return false;
        }

        private bool VerifyHitPosition(IPlayer player, out Vector3 position)
        {
            if (TryGetHitPosition(player.Object as BasePlayer, out position))
                return true;

            ReplyToPlayer(player, LangEntry.ErrorNoSurface);
            return false;
        }

        private bool VerifyAtMonument(IPlayer player, Vector3 position, out BaseMonument closestMonument)
        {
            closestMonument = GetClosestMonument(player.Object as BasePlayer, position);
            if (closestMonument == null)
            {
                ReplyToPlayer(player, LangEntry.ErrorNoMonuments);
                return false;
            }

            if (!closestMonument.IsInBounds(position))
            {
                var closestPoint = closestMonument.ClosestPointOnBounds(position);
                var distance = (position - closestPoint).magnitude;
                ReplyToPlayer(player, LangEntry.ErrorNotAtMonument, closestMonument.UniqueDisplayName, distance.ToString("f1"));
                return false;
            }

            return true;
        }

        private bool VerifyLookingAtMonumentPosition(IPlayer player, out Vector3 position, out BaseMonument closestMonument)
        {
            if (!TryRaycast(player.Object as BasePlayer, out var hit))
            {
                ReplyToPlayer(player, LangEntry.ErrorNoSurface);
                position = Vector3.zero;
                closestMonument = null;
                return false;
            }

            position = hit.point;

            var entity = hit.GetEntity();
            if (entity != null && IsDynamicMonument(entity))
            {
                closestMonument = new DynamicMonument(entity);
                return true;
            }

            return VerifyAtMonument(player, position, out closestMonument);
        }

        private bool VerifyValidModderPrefab(IPlayer player, string[] args, out string prefabPath)
        {
            prefabPath = null;

            var prefabArg = args.FirstOrDefault();
            if (string.IsNullOrWhiteSpace(prefabArg) || IsKeyBindArg(prefabArg))
            {
                ReplyToPlayer(player, LangEntry.PrefabErrorSyntax);
                return false;
            }

            var prefabMatches = SearchUtils.FindModderPrefabMatches(prefabArg);
            if (prefabMatches.Count == 1)
            {
                prefabPath = prefabMatches.First().ToLower();
                return true;
            }

            if (prefabMatches.Count == 0)
            {
                ReplyToPlayer(player, LangEntry.PrefabErrorNotFound, prefabArg);
                return false;
            }

            // Multiple matches were found, so print them all to the player.
            var replyMessage = GetMessage(player.Id, LangEntry.SpawnErrorMultipleMatches);
            foreach (var matchingPrefabPath in prefabMatches)
            {
                replyMessage += $"\n{matchingPrefabPath}";
            }

            player.Reply(replyMessage);
            return false;
        }

        private bool VerifyValidEntityPrefab(IPlayer player, string prefabArg, out string prefabPath)
        {
            prefabPath = null;

            var prefabMatches = SearchUtils.FindEntityPrefabMatches(prefabArg, _uniqueNameRegistry);
            if (prefabMatches.Count == 1)
            {
                prefabPath = prefabMatches.First().ToLower();
                return true;
            }

            if (prefabMatches.Count == 0)
            {
                ReplyToPlayer(player, LangEntry.SpawnErrorEntityNotFound, prefabArg);
                return false;
            }

            // Multiple matches were found, so print them all to the player.
            var replyMessage = GetMessage(player.Id, LangEntry.SpawnErrorMultipleMatches);
            foreach (var matchingPrefabPath in prefabMatches)
            {
                replyMessage += $"\n{_uniqueNameRegistry.GetUniqueShortName(matchingPrefabPath)}";
            }

            player.Reply(replyMessage);
            return false;
        }

        private bool VerifyValidEntityPrefabOrCustomAddon(IPlayer player, string prefabArg, out string prefabPath, out CustomAddonDefinition addonDefinition)
        {
            prefabPath = null;
            addonDefinition = null;

            var prefabMatches = SearchUtils.FindEntityPrefabMatches(prefabArg, _uniqueNameRegistry);
            var customAddonMatches = SearchUtils.FindCustomAddonMatches(prefabArg, _customAddonManager.GetAllAddons());

            var matchCount = prefabMatches.Count + customAddonMatches.Count;
            if (matchCount == 0)
            {
                ReplyToPlayer(player, LangEntry.SpawnErrorEntityOrAddonNotFound, prefabArg);
                return false;
            }

            if (matchCount == 1)
            {
                if (prefabMatches.Count == 1)
                {
                    prefabPath = prefabMatches.First().ToLower();
                }
                else
                {
                    addonDefinition = customAddonMatches.First();
                }

                return true;
            }

            // Multiple matches were found, so print them all to the player.
            var replyMessage = GetMessage(player.Id, LangEntry.SpawnErrorMultipleMatches);
            foreach (var matchingPrefabPath in prefabMatches)
            {
                replyMessage += $"\n{_uniqueNameRegistry.GetUniqueShortName(matchingPrefabPath)}";
            }
            foreach (var matchingAddonDefinition in customAddonMatches)
            {
                replyMessage += $"\n{matchingAddonDefinition.AddonName}";
            }

            player.Reply(replyMessage);
            return false;
        }

        private bool VerifyValidEntityPrefabOrDeployable(IPlayer player, string[] args, out string prefabPath, out CustomAddonDefinition addonDefinition, out ulong skinId)
        {
            var prefabArg = args.FirstOrDefault();
            skinId = 0;

            if (!string.IsNullOrWhiteSpace(prefabArg) && !IsKeyBindArg(prefabArg))
                return VerifyValidEntityPrefabOrCustomAddon(player, prefabArg, out prefabPath, out addonDefinition);

            addonDefinition = null;

            var basePlayer = player.Object as BasePlayer;
            var deployablePrefab = DeterminePrefabFromPlayerActiveDeployable(basePlayer, out skinId);
            if (!string.IsNullOrEmpty(deployablePrefab))
            {
                prefabPath = deployablePrefab;
                return true;
            }

            prefabPath = null;
            ReplyToPlayer(player, LangEntry.SpawnErrorSyntax);
            return false;
        }

        private bool VerifySpawnGroupPrefabOrCustomAddon(IPlayer player, SpawnGroupData spawnGroupData, string prefabArg, out WeightedPrefabData weightedPrefabData)
        {
            var customAddonMatches = spawnGroupData.FindCustomAddonMatches(prefabArg);
            if (customAddonMatches.Count == 1)
            {
                weightedPrefabData = customAddonMatches.First();
                return true;
            }

            var prefabMatches = spawnGroupData.FindPrefabMatches(prefabArg, _uniqueNameRegistry);
            if (prefabMatches.Count == 1)
            {
                weightedPrefabData = prefabMatches.First();
                return true;
            }

            var matchCount = prefabMatches.Count + customAddonMatches.Count;
            if (matchCount == 0)
            {
                ReplyToPlayer(player, LangEntry.SpawnGroupRemoveNoMatch, spawnGroupData.Name, prefabArg);
                weightedPrefabData = null;
                return false;
            }

            ReplyToPlayer(player, LangEntry.SpawnGroupRemoveMultipleMatches, spawnGroupData.Name, prefabArg);
            weightedPrefabData = null;
            return false;
        }

        private bool VerifyLookingAtAdapter<TAdapter, TController, TFormatter>(IPlayer player, out AdapterFindResult<TAdapter, TController> findResult, TFormatter errorFormatter)
            where TAdapter : TransformAdapter
            where TController : BaseController
            where TFormatter : IMessageFormatter
        {
            var basePlayer = player.Object as BasePlayer;

            var hitResult = FindHitAdapter<TAdapter, TController>(basePlayer, out var hit);
            if (hitResult.Controller != null)
            {
                // Found a suitable entity via direct hit.
                findResult = hitResult;
                return true;
            }

            var nearbyResult = FindClosestNearbyAdapter<TAdapter, TController>(hit.point);
            if (nearbyResult.Controller != null)
            {
                // Found a suitable nearby entity.
                findResult = nearbyResult;
                return true;
            }

            if (hitResult.Entity != null && hitResult.Component == null)
            {
                // Found an entity via direct hit, but it does not belong to Monument Addons.
                ReplyToPlayer(player, LangEntry.ErrorEntityNotEligible);
            }
            else
            {
                // Maybe found an entity, but it did not match the adapter/controller type.
                ReplyToPlayer(player, errorFormatter);
            }

            findResult = default(AdapterFindResult<TAdapter, TController>);
            return false;
        }

        private bool VerifyLookingAtAdapter<TAdapter, TController, TFormatter>(IPlayer player, out TAdapter adapter, out TController controller, TFormatter errorFormatter)
            where TAdapter : TransformAdapter
            where TController : BaseController
            where TFormatter : IMessageFormatter
        {
            var result = VerifyLookingAtAdapter(player, out AdapterFindResult<TAdapter, TController> findResult, errorFormatter);
            adapter = findResult.Adapter;
            controller = findResult.Controller;
            return result;
        }

        // Convenient method that does not require an adapter type.
        private bool VerifyLookingAtAdapter<TController, TFormatter>(IPlayer player, out TController controller, TFormatter errorFormatter)
            where TController : BaseController
            where TFormatter : IMessageFormatter
        {
            var result = VerifyLookingAtAdapter(player, out AdapterFindResult<TransformAdapter, TController> findResult, errorFormatter);
            controller = findResult.Controller;
            return result;
        }

        private bool VerifySpawnGroupFound(IPlayer player, string partialGroupName, BaseMonument monument, out SpawnGroupController spawnGroupController)
        {
            var matches = FindSpawnGroups(partialGroupName, monument.UniqueName, partialMatch: true).ToList();

            spawnGroupController = matches.FirstOrDefault();

            if (matches.Count == 1)
                return true;

            if (matches.Count == 0)
            {
                ReplyToPlayer(player, LangEntry.SpawnGroupNotFound, partialGroupName);
                return false;
            }

            var playerProfileController = _profileManager.GetPlayerProfileControllerOrDefault(player.Id);

            // Multiple matches found, try to narrow it down.
            for (var i = matches.Count - 1; i >= 0; i--)
            {
                var match = matches[i];
                if (match.ProfileController != playerProfileController)
                {
                    // Remove any controllers that don't match the player's selected profile.
                    matches.Remove(match);
                }
            }

            if (matches.Count == 1)
            {
                spawnGroupController = matches[0];
                return true;
            }

            ReplyToPlayer(player, LangEntry.SpawnGroupMultipeMatches, partialGroupName);
            return false;
        }

        private bool VerifyProfileNameAvailable(IPlayer player, string profileName)
        {
            if (!_profileManager.ProfileExists(profileName))
                return true;

            ReplyToPlayer(player, LangEntry.ProfileAlreadyExists, profileName);
            return false;
        }

        private bool VerifyProfileExists(IPlayer player, string profileName, out ProfileController controller)
        {
            try
            {
                controller = _profileManager.GetProfileController(profileName);
                if (controller != null)
                    return true;
            }
            catch (JsonReaderException ex)
            {
                controller = null;
                player.Reply("{0}", string.Empty, ex.Message);
                return false;
            }

            ReplyToPlayer(player, LangEntry.ProfileNotFound, profileName);
            return false;
        }

        private bool VerifyProfile(IPlayer player, string[] args, out ProfileController controller, LangEntry0 syntaxLangEntry)
        {
            if (args.Length <= 1)
            {
                controller = player.IsServer ? null : _profileManager.GetPlayerProfileControllerOrDefault(player.Id);
                if (controller != null)
                    return true;

                ReplyToPlayer(player, syntaxLangEntry);
                return false;
            }

            return VerifyProfileExists(player, args[1], out controller);
        }

        private bool VerifySpawnGroupNameAvailable(IPlayer player, Profile profile, BaseMonument monument, string spawnGroupName, SpawnGroupController spawnGroupController = null)
        {
            var matches = FindSpawnGroups(spawnGroupName, monument.UniqueName, profile).ToList();
            if (matches.Count == 0)
                return true;

            // Allow renaming a spawn group with different case.
            if (spawnGroupController != null && matches.Count == 1 && matches[0] == spawnGroupController)
                return true;

            ReplyToPlayer(player, LangEntry.SpawnGroupCreateNameInUse, spawnGroupName, monument.UniqueName, profile.Name);
            return false;
        }

        private bool VerifyEntityComponent<T>(IPlayer player, BaseEntity entity, out T component, LangEntry0 errorLangEntry) where T : Component
        {
            if (entity.gameObject.TryGetComponent(out component))
                return true;

            ReplyToPlayer(player, errorLangEntry);
            return false;
        }

        private bool VerifyCanLoadProfile(IPlayer player, string profileName, out Profile profile)
        {
            if (!_profileStore.TryLoad(profileName, out profile, out var errorMessage))
            {
                player.Reply("{0}", string.Empty, errorMessage);
            }

            return true;
        }

        #endregion

        #region Helper Methods - Finding Adapters

        private struct AdapterFindResult<TAdapter, TController>
            where TAdapter : TransformAdapter
            where TController : BaseController
        {
            public BaseEntity Entity;
            public IAddonComponent Component;
            public TAdapter Adapter;
            public TController Controller;

            public AdapterFindResult(BaseEntity entity)
            {
                Entity = entity;
                Component = entity.GetComponent<IAddonComponent>();
                Adapter = Component?.Adapter as TAdapter;
                Controller = Adapter?.Controller as TController;
            }

            public AdapterFindResult(TAdapter adapter, TController controller)
            {
                Entity = null;
                Component = null;
                Adapter = adapter;
                Controller = controller;
            }
        }

        private AdapterFindResult<TAdapter, TController> FindHitAdapter<TAdapter, TController>(BasePlayer basePlayer, out RaycastHit hit)
            where TAdapter : TransformAdapter
            where TController : BaseController
        {
            if (!TryRaycast(basePlayer, out hit))
                return default(AdapterFindResult<TAdapter, TController>);

            var entity = hit.GetEntity();
            if (entity == null)
                return default(AdapterFindResult<TAdapter, TController>);

            if (IsSpawnPointEntity(entity, out var spawnPointAdapter) && spawnPointAdapter is TAdapter spawnAdapter)
                return new AdapterFindResult<TAdapter, TController>(spawnAdapter, spawnAdapter.Controller as TController);

            return new AdapterFindResult<TAdapter, TController>(entity);
        }

        private AdapterFindResult<TAdapter, TController> FindClosestNearbyAdapter<TAdapter, TController>(Vector3 position)
            where TAdapter : TransformAdapter
            where TController : BaseController
        {
            TAdapter closestNearbyAdapter = null;
            TController associatedController = null;
            var closestDistanceSquared = float.MaxValue;

            foreach (var adapter in _profileManager.GetEnabledAdapters<TAdapter>())
            {
                if (!adapter.IsValid || adapter.Controller is not TController controllerOfType)
                    continue;

                var adapterDistanceSquared = (adapter.Position - position).sqrMagnitude;
                if (adapterDistanceSquared <= MaxFindDistanceSquared && adapterDistanceSquared < closestDistanceSquared)
                {
                    closestNearbyAdapter = adapter;
                    associatedController = controllerOfType;
                    closestDistanceSquared = adapterDistanceSquared;
                }
            }

            return closestNearbyAdapter != null
                ? new AdapterFindResult<TAdapter, TController>(closestNearbyAdapter, associatedController)
                : default;
        }

        private AdapterFindResult<TAdapter, TController> FindAdapter<TAdapter, TController>(BasePlayer basePlayer)
            where TAdapter : TransformAdapter
            where TController : BaseController
        {
            var hitResult = FindHitAdapter<TAdapter, TController>(basePlayer, out var hit);
            if (hitResult.Controller != null)
                return hitResult;

            return FindClosestNearbyAdapter<TAdapter, TController>(hit.point);
        }

        // Convenient method that does not require a controller type.
        private AdapterFindResult<TAdapter, BaseController> FindAdapter<TAdapter>(BasePlayer basePlayer)
            where TAdapter : TransformAdapter
        {
            return FindAdapter<TAdapter, BaseController>(basePlayer);
        }

        // Convenient method that does not require an adapter or controller type.
        private AdapterFindResult<TransformAdapter, BaseController> FindAdapter(BasePlayer basePlayer)
        {
            return FindAdapter<TransformAdapter, BaseController>(basePlayer);
        }

        private IEnumerable<SpawnGroupController> FindSpawnGroups(string partialGroupName, string monumentIdentifier, Profile profile = null, bool partialMatch = false)
        {
            foreach (var spawnGroupController in _profileManager.GetEnabledControllers<SpawnGroupController>())
            {
                if (profile != null && spawnGroupController.Profile != profile)
                    continue;

                var spawnGroupName = spawnGroupController.SpawnGroupData.Name;

                if (partialMatch)
                {
                    if (spawnGroupName.IndexOf(partialGroupName, StringComparison.InvariantCultureIgnoreCase) == -1)
                        continue;
                }
                else if (!spawnGroupName.Equals(partialGroupName, StringComparison.InvariantCultureIgnoreCase))
                    continue;

                // Can only select a spawn group for the same monument.
                // This a slightly hacky way to check this, since data and controllers aren't directly aware of monuments.
                if (spawnGroupController.Adapters.FirstOrDefault()?.Monument.UniqueName != monumentIdentifier)
                    continue;

                yield return spawnGroupController;
            }
        }

        private PuzzleReset FindConnectedPuzzleReset(IOSlot[] slotList, HashSet<IOEntity> visited)
        {
            foreach (var slot in slotList)
            {
                var otherEntity = slot.connectedTo.Get();
                if (otherEntity == null)
                    continue;

                var puzzleReset = FindConnectedPuzzleReset(otherEntity, visited);
                if (puzzleReset != null)
                    return puzzleReset;
            }

            return null;
        }

        private PuzzleReset FindConnectedPuzzleReset(IOEntity ioEntity, HashSet<IOEntity> visited = null)
        {
            var puzzleReset = ioEntity.GetComponent<PuzzleReset>();
            if (puzzleReset != null)
                return puzzleReset;

            visited ??= new HashSet<IOEntity>();

            if (!visited.Add(ioEntity))
                return null;

            return FindConnectedPuzzleReset(ioEntity.inputs, visited)
                ?? FindConnectedPuzzleReset(ioEntity.outputs, visited);
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Monument Addons] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Monument Addons] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Monument Addons] {message}");

        private static bool RenameDictKey<TValue>(Dictionary<string, TValue> dict, string oldName, string newName)
        {
            if (dict.TryGetValue(oldName, out var monumentState))
            {
                dict[newName] = monumentState;
                dict.Remove(oldName);
                return true;
            }

            return false;
        }

        private static HashSet<string> DetermineAllDeployablePrefabs()
        {
            var prefabList = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);

            foreach (var itemDefinition in ItemManager.itemList)
            {
                var deployablePrefab = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (deployablePrefab == null)
                    continue;

                prefabList.Add(deployablePrefab);
            }

            return prefabList;
        }

        private static bool IsKeyBindArg(string arg)
        {
            return arg == "True";
        }

        private static bool TryRaycast(BasePlayer player, out RaycastHit hit, float maxDistance = MaxRaycastDistance)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out hit, maxDistance, HitLayers, QueryTriggerInteraction.Ignore);
        }

        private static bool TrySphereCast(BasePlayer player, out RaycastHit hit, int layerMask, float radius, float maxDistance = MaxRaycastDistance)
        {
            return Physics.SphereCast(player.eyes.HeadRay(), radius, out hit, maxDistance, layerMask, QueryTriggerInteraction.Ignore);
        }

        private static bool TryGetHitPosition(BasePlayer player, out Vector3 position)
        {
            if (TryRaycast(player, out var hit))
            {
                position = hit.point;
                return true;
            }

            position = Vector3.zero;
            return false;
        }

        public static T GetLookEntitySphereCast<T>(BasePlayer player, int layerMask, float radius, float maxDistance = MaxRaycastDistance) where T : BaseEntity
        {
            return TrySphereCast(player, out var hit, layerMask, radius, maxDistance)
                ? hit.GetEntity() as T
                : null;
        }

        private static void SendEffect(BasePlayer player, string effectPrefab)
        {
            var effect = new Effect(effectPrefab, player, 0, Vector3.zero, Vector3.forward);
            EffectNetwork.Send(effect, player.net.connection);
        }

        private static bool IsOnTerrain(Vector3 position)
        {
            return Math.Abs(position.y - TerrainMeta.HeightMap.GetHeight(position)) <= TerrainProximityTolerance;
        }

        private static string GetShortName(string prefabName)
        {
            var slashIndex = prefabName.LastIndexOf("/", StringComparison.Ordinal);
            var baseName = (slashIndex == -1) ? prefabName : prefabName.Substring(slashIndex + 1);
            return baseName.Replace(".prefab", string.Empty);
        }

        private static void DetermineLocalTransformData(Vector3 position, BasePlayer basePlayer, BaseMonument monument, out Vector3 localPosition, out Vector3 localRotationAngles, out bool isOnTerrain, bool flipRotation = true)
        {
            localPosition = monument.InverseTransformPoint(position);

            var localRotationAngle = basePlayer.HasParent()
                ? basePlayer.viewAngles.y
                : basePlayer.viewAngles.y - monument.Rotation.eulerAngles.y;

            if (flipRotation)
            {
                localRotationAngle += 180;
            }

            localRotationAngles = new Vector3(0, (localRotationAngle + 360) % 360, 0);
            isOnTerrain = IsOnTerrain(position);
        }

        private static void DestroyProblemComponents(BaseEntity entity)
        {
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static bool HasRigidBody(BaseEntity entity)
        {
            return entity.GetComponentInParent<Rigidbody>() != null;
        }

        private static bool IsRedirectSkin(ulong skinId, out string alternativeShortName)
        {
            alternativeShortName = null;

            if (skinId > int.MaxValue)
                return false;

            var skinIdInt = Convert.ToInt32(skinId);

            foreach (var skin in ItemSkinDirectory.Instance.skins)
            {
                var itemSkin = skin.invItem as ItemSkin;
                if (itemSkin == null || itemSkin.id != skinIdInt)
                    continue;

                var redirect = itemSkin.Redirect;
                if (redirect == null)
                    return false;

                var modDeployable = redirect.GetComponent<ItemModDeployable>();
                if (modDeployable != null)
                {
                    alternativeShortName = GetShortName(modDeployable.entityPrefab.resourcePath);
                }

                return true;
            }

            return false;
        }

        private static T FindPrefabComponent<T>(string prefabName) where T : Component
        {
            return GameManager.server.FindPrefab(prefabName)?.GetComponent<T>();
        }

        private static BaseEntity FindPrefabBaseEntity(string prefabName)
        {
            return FindPrefabComponent<BaseEntity>(prefabName);
        }

        private static string FormatTime(double seconds)
        {
            return TimeSpan.FromSeconds(seconds).ToString("g");
        }

        private static void BroadcastEntityTransformChange(BaseEntity entity)
        {
            if (entity is StabilityEntity)
            {
                entity.TerminateOnClient(BaseNetworkable.DestroyMode.None);
                entity.SendNetworkUpdateImmediate();
                return;
            }

            var wasSyncPosition = entity.syncPosition;
            entity.syncPosition = true;
            entity.TransformChanged();
            entity.syncPosition = wasSyncPosition;

            entity.transform.hasChanged = false;
        }

        private static void EnableSavingRecursive(BaseEntity entity, bool enableSaving)
        {
            entity.EnableSaving(enableSaving);

            foreach (var child in entity.children)
            {
                EnableSavingRecursive(child, enableSaving);
            }
        }

        private static IEnumerator WaitWhileWithTimeout(Func<bool> predicate, float timeoutSeconds)
        {
            var timeoutAt = UnityEngine.Time.time + timeoutSeconds;

            while (predicate() && UnityEngine.Time.time < timeoutAt)
            {
                yield return null;
            }
        }

        private static bool TryParseEnum<T>(string arg, out T enumValue) where T : struct
        {
            foreach (var value in Enum.GetValues(typeof(T)))
            {
                if (value.ToString().IndexOf(arg, StringComparison.InvariantCultureIgnoreCase) >= 0)
                {
                    enumValue = (T)value;
                    return true;
                }
            }

            enumValue = default(T);
            return false;
        }

        private static float GetTimeToNextSpawn(SpawnGroup spawnGroup)
        {
            var events = spawnGroup.spawnClock.events;

            if (events.Count == 0 || float.IsNaN(events.First().time))
                return float.PositiveInfinity;

            return events.First().time - UnityEngine.Time.time;
        }

        private static float GetTimeToNextSpawn(IndividualSpawner spawner)
        {
            if (spawner.nextSpawnTime == -1)
                return float.PositiveInfinity;

            return spawner.nextSpawnTime - UnityEngine.Time.time;
        }

        private static List<MonumentTier> GetTierList(MonumentTier tier)
        {
            var tierList = new List<MonumentTier>();

            if ((tier & MonumentTier.Tier0) != 0)
            {
                tierList.Add(MonumentTier.Tier0);
            }

            if ((tier & MonumentTier.Tier1) != 0)
            {
                tierList.Add(MonumentTier.Tier1);
            }

            if ((tier & MonumentTier.Tier2) != 0)
            {
                tierList.Add(MonumentTier.Tier2);
            }

            return tierList;
        }

        private static MonumentTier GetMonumentTierMask(Vector3 position)
        {
            var topologyMask = TerrainMeta.TopologyMap.GetTopology(position);

            var mask = (MonumentTier)0;

            if ((TerrainTopology.TIER0 & topologyMask) != 0)
            {
                mask |= MonumentTier.Tier0;
            }

            if ((TerrainTopology.TIER1 & topologyMask) != 0)
            {
                mask |= MonumentTier.Tier1;
            }

            if ((TerrainTopology.TIER2 & topologyMask) != 0)
            {
                mask |= MonumentTier.Tier2;
            }

            return mask;
        }

        private static BaseEntity FindValidEntity(ulong entityId)
        {
            var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(entityId)) as BaseEntity;
            return entity != null && !entity.IsDestroyed
                ? entity
                : null;
        }

        private static IEnumerator KillEntitiesRoutine(ICollection<BaseEntity> entityList)
        {
            foreach (var entity in entityList)
            {
                entity.Kill();
                yield return null;
            }
        }

        private static CustomSpawnPoint GetSpawnPoint(BaseEntity entity)
        {
            var spawnPointInstance = entity.GetComponent<SpawnPointInstance>();
            if (spawnPointInstance == null)
                return null;

            return spawnPointInstance.parentSpawnPoint as CustomSpawnPoint;
        }

        private static bool IsSpawnPointEntity(BaseEntity entity, out SpawnPointAdapter adapter)
        {
            adapter = null;

            var spawnPoint = GetSpawnPoint(entity);
            if (spawnPoint == null)
                return false;

            adapter = spawnPoint.Adapter as SpawnPointAdapter;
            return adapter != null;
        }

        private static bool IsSpawnPointEntity(BaseEntity entity)
        {
            return IsSpawnPointEntity(entity, out _);
        }

        private bool IsTransformAddon(Component component, out TransformAdapter adapter, out BaseController controller)
        {
            if (_componentTracker.IsAddonComponent(component, out adapter, out controller))
                return true;

            adapter = null;
            controller = null;

            if (component is IAddonComponent addonComponent)
            {
                adapter = addonComponent.Adapter;
            }
            else
            {
                if (component is not BaseEntity entity)
                    return false;

                if (!IsSpawnPointEntity(entity, out var spawnPointAdapter))
                    return false;

                adapter = spawnPointAdapter;
            }

            controller = adapter?.Controller;
            return controller != null;
        }

        private bool IsTransformAddon(Component component, out BaseController controller)
        {
            return IsTransformAddon(component, out _, out controller);
        }

        private bool HasAdminPermission(string userId)
        {
            return permission.UserHasPermission(userId, PermissionAdmin);
        }

        private bool HasAdminPermission(BasePlayer player)
        {
            return HasAdminPermission(player.UserIDString);
        }

        private bool IsDynamicMonument(BaseEntity entity)
        {
            return _config.DynamicMonuments.IsConfiguredAsDynamicMonument(entity)
                || _profileManager.HasDynamicMonument(entity);
        }

        private bool IsPlayerParentedToDynamicMonument(BasePlayer player, Vector3 position, out BaseMonument monument)
        {
            monument = null;

            var parentEntity = player.GetParentEntity();
            if (parentEntity == null || !IsDynamicMonument(parentEntity))
                return false;

            monument = new DynamicMonument(parentEntity, isMobile: true);
            return monument.IsInBounds(position);
        }

        private BaseMonument GetClosestMonument(BasePlayer player, Vector3 position)
        {
            if (IsPlayerParentedToDynamicMonument(player, position, out var dynamicMonument))
                return dynamicMonument;

            var monument = _customMonumentManager.FindByPosition(position);
            if (monument != null)
                return monument;

            return _monumentHelper.GetClosestMonumentAdapter(position);
        }

        private List<BaseMonument> GetDynamicMonumentInstances(uint prefabId)
        {
            var entityList = (List<BaseMonument>)null;

            foreach (var networkable in BaseNetworkable.serverEntities)
            {
                if (networkable is BaseEntity entity
                    && entity.prefabID == prefabId
                    && ExposedHooks.OnDynamicMonument(entity) is not false)
                {
                    entityList ??= new List<BaseMonument>();
                    entityList.Add(new DynamicMonument(entity));
                }
            }

            return entityList;
        }

        private List<BaseMonument> GetMonumentsByIdentifier(string monumentIdentifier)
        {
            if (monumentIdentifier.StartsWith("assets/"))
            {
                var baseEntity = FindPrefabBaseEntity(monumentIdentifier);
                if (baseEntity != null && IsDynamicMonument(baseEntity))
                    return GetDynamicMonumentInstances(baseEntity.prefabID);
            }

            var customMonuments = _customMonumentManager.FindMonumentsByName(monumentIdentifier);
            if (customMonuments?.Count > 0)
                return customMonuments;

            var monuments = _monumentHelper.FindMonumentsByAlias(monumentIdentifier);
            if (monuments.Count > 0)
                return monuments;

            return _monumentHelper.FindMonumentsByShortName(monumentIdentifier);
        }

        private IEnumerator SpawnAllProfilesRoutine()
        {
            // Delay one frame to allow Monument Finder to finish loading.
            yield return null;
            yield return _profileManager.LoadAllProfilesRoutine();

            ExposedHooks.OnMonumentAddonsInitialized();
        }

        private void StartupRoutine()
        {
            // Don't spawn entities if that's already been done.
            if (_startupCoroutine != null)
                return;

            _startupCoroutine = _coroutineManager.StartCoroutine(SpawnAllProfilesRoutine());
        }

        private void DownloadProfile(IPlayer player, string url, Action<Profile> successCallback, Action<string> errorCallback)
        {
            webrequest.Enqueue(
                url: url,
                body: null,
                callback: (statusCode, responseBody) =>
                {
                    if (!IsLoaded)
                    {
                        // Ignore the response because the plugin was unloaded.
                        return;
                    }

                    if (statusCode != 200)
                    {
                        errorCallback(GetMessage(player.Id, LangEntry.ProfileDownloadError, url, statusCode));
                        return;
                    }

                    Profile profile;
                    try
                    {
                        profile = JsonConvert.DeserializeObject<Profile>(responseBody);
                    }
                    catch (Exception ex)
                    {
                        errorCallback(GetMessage(player.Id, LangEntry.ProfileParseError, url, ex.Message));
                        return;
                    }

                    ProfileDataMigration<Profile>.MigrateToLatest(profile);

                    profile.Url = url;
                    successCallback(profile);
                },
                owner: this,
                method: RequestMethod.GET,
                headers: JsonRequestHeaders,
                timeout: 5000
            );
        }

        private string DeterminePrefabFromPlayerActiveDeployable(BasePlayer basePlayer, out ulong skinId)
        {
            skinId = 0;

            var activeItem = basePlayer.GetActiveItem();
            if (activeItem == null)
                return null;

            skinId = activeItem.skin;

            if (_config.DeployableOverrides.TryGetValue(activeItem.info.shortname, out var overridePrefabPath))
                return overridePrefabPath;

            var itemModDeployable = activeItem.info.GetComponent<ItemModDeployable>();
            if (itemModDeployable == null)
                return null;

            return itemModDeployable.entityPrefab.resourcePath;
        }

        // This is a best-effort attempt to flag as many possible entities as possible without false positives.
        // Hopefully this will help users learn they are using the wrong command before they open a support thread.
        private bool ShouldRecommendSpawnPoints(string prefabName)
        {
            var entity = FindPrefabBaseEntity(prefabName);

            if (entity is BaseNpc or BradleyAPC or PatrolHelicopter or SimpleShark)
                return true;

            if (entity is LootContainer && !_deployablePrefabs.Contains(prefabName))
                return true;

            if (entity is NPCPlayer and not NPCShopKeeper and not BanditGuard)
                return true;

            if (entity is BaseBoat or BaseHelicopter or BaseRidableAnimal or BaseSubmarine or BasicCar or GroundVehicle or HotAirBalloon or Sled or TrainCar)
                return true;

            return false;
        }

        #endregion

        #region Helper Classes

        private static class StringUtils
        {
            public static bool EqualsCaseInsensitive(string a, string b)
            {
                return string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
            }

            public static bool Contains(string haystack, string needle)
            {
                return haystack?.Contains(needle, CompareOptions.IgnoreCase) ?? false;
            }
        }

        private static class SearchUtils
        {
            public static List<string> FindModderPrefabMatches(string partialName)
            {
                return FindMatches(
                    GameManifest.Current.pooledStrings.Select(pooledString => pooledString.str)
                        .Where(str => str.StartsWith("assets/bundled/prefabs/modding", StringComparison.OrdinalIgnoreCase)),
                    prefabPath => StringUtils.Contains(prefabPath, partialName),
                    prefabPath => StringUtils.EqualsCaseInsensitive(prefabPath, partialName)
                );
            }

            public static List<T> FindPrefabMatches<T>(IEnumerable<T> sourceList, Func<T, string> selector, string partialName, UniqueNameRegistry uniqueNameRegistry)
            {
                return SearchUtils.FindMatches(
                    sourceList,
                    prefabPath => StringUtils.Contains(selector(prefabPath), partialName),
                    prefabPath => StringUtils.EqualsCaseInsensitive(selector(prefabPath), partialName),
                    prefabPath => StringUtils.Contains(uniqueNameRegistry.GetUniqueShortName(selector(prefabPath)), partialName),
                    prefabPath => StringUtils.EqualsCaseInsensitive(uniqueNameRegistry.GetUniqueShortName(selector(prefabPath)), partialName)
                );
            }

            public static List<string> FindEntityPrefabMatches(string partialName, UniqueNameRegistry uniqueNameRegistry)
            {
                return FindMatches(
                    GameManifest.Current.entities,
                    prefabPath => StringUtils.Contains(prefabPath, partialName) && FindPrefabBaseEntity(prefabPath) != null,
                    prefabPath => StringUtils.EqualsCaseInsensitive(prefabPath, partialName),
                    prefabPath => StringUtils.Contains(uniqueNameRegistry.GetUniqueShortName(prefabPath), partialName),
                    prefabPath => StringUtils.EqualsCaseInsensitive(uniqueNameRegistry.GetUniqueShortName(prefabPath), partialName)
                );
            }

            public static List<T> FindCustomAddonMatches<T>(IEnumerable<T> sourceList, Func<T, string> selector, string partialName)
            {
                return FindMatches(
                    sourceList,
                    addonDefinition => StringUtils.Contains(selector(addonDefinition), partialName),
                    addonDefinition => StringUtils.EqualsCaseInsensitive(selector(addonDefinition), partialName)
                );
            }

            public static List<CustomAddonDefinition> FindCustomAddonMatches(string partialName, IEnumerable<CustomAddonDefinition> customAddons)
            {
                return FindCustomAddonMatches(customAddons, customAddonDefinition => customAddonDefinition.AddonName, partialName);
            }

            public static List<T> FindMatches<T>(IEnumerable<T> sourceList, params Func<T, bool>[] predicateList)
            {
                List<T> results = null;

                foreach (var predicate in predicateList)
                {
                    if (results == null)
                    {
                        results = sourceList.Where(predicate).ToList();
                        continue;
                    }

                    var newResults = results.Where(predicate).ToList();
                    if (newResults.Count == 0)
                    {
                        // No matches found after filtering, so ignore the results and then try a different filter.
                        continue;
                    }

                    if (newResults.Count == 1)
                    {
                        // Only a single match after filtering, so return new results.
                        return newResults;
                    }

                    // Multiple matches found, so proceed with further filtering.
                    results = newResults;
                }

                return results;
            }
        }

        private struct Ddraw
        {
            private const float DefaultBoxSphereRadius = 0.5f;

            public static void Sphere(BasePlayer player, float duration, Color color, Vector3 origin, float radius)
            {
                player.SendConsoleCommand("ddraw.sphere", duration, color, origin, radius);
            }

            public static void Line(BasePlayer player, float duration, Color color, Vector3 origin, Vector3 target)
            {
                player.SendConsoleCommand("ddraw.line", duration, color, origin, target);
            }

            public static void Arrow(BasePlayer player, float duration, Color color, Vector3 origin, Vector3 target, float headSize)
            {
                player.SendConsoleCommand("ddraw.arrow", duration, color, origin, target, headSize);
            }

            public static void Arrow(BasePlayer player, float duration, Color color, Vector3 center, Quaternion rotation, float length, float headSize)
            {
                var origin = center - rotation * Vector3.forward * length;
                var target = center + rotation * Vector3.forward * length;
                Arrow(player, duration, color, origin, target, headSize);
            }

            public static void Text(BasePlayer player, float duration, Color color, Vector3 origin, string text)
            {
                player.SendConsoleCommand("ddraw.text", duration, color, origin, text);
            }

            public static void Box(BasePlayer player, float duration, Color color, Vector3 center, Quaternion rotation, Vector3 extents, float sphereRadius = 0.5f)
            {
                var forwardUpperLeft = center + rotation * extents.WithX(-extents.x);
                var forwardUpperRight = center + rotation * extents;
                var forwardLowerLeft = center + rotation * extents.WithX(-extents.x).WithY(-extents.y);
                var forwardLowerRight = center + rotation * extents.WithY(-extents.y);

                var backLowerRight = center + rotation * -extents.WithX(-extents.x);
                var backLowerLeft = center + rotation * -extents;
                var backUpperRight = center + rotation * -extents.WithX(-extents.x).WithY(-extents.y);
                var backUpperLeft = center + rotation * -extents.WithY(-extents.y);

                Sphere(player, duration, color, forwardUpperLeft, sphereRadius);
                Sphere(player, duration, color, forwardUpperRight, sphereRadius);
                Sphere(player, duration, color, forwardLowerLeft, sphereRadius);
                Sphere(player, duration, color, forwardLowerRight, sphereRadius);

                Sphere(player, duration, color, backLowerRight, sphereRadius);
                Sphere(player, duration, color, backLowerLeft, sphereRadius);
                Sphere(player, duration, color, backUpperRight, sphereRadius);
                Sphere(player, duration, color, backUpperLeft, sphereRadius);

                Line(player, duration, color, forwardUpperLeft, forwardUpperRight);
                Line(player, duration, color, forwardLowerLeft, forwardLowerRight);
                Line(player, duration, color, forwardUpperLeft, forwardLowerLeft);
                Line(player, duration, color, forwardUpperRight, forwardLowerRight);

                Line(player, duration, color, backUpperLeft, backUpperRight);
                Line(player, duration, color, backLowerLeft, backLowerRight);
                Line(player, duration, color, backUpperLeft, backLowerLeft);
                Line(player, duration, color, backUpperRight, backLowerRight);

                Line(player, duration, color, forwardUpperLeft, backUpperLeft);
                Line(player, duration, color, forwardLowerLeft, backLowerLeft);
                Line(player, duration, color, forwardUpperRight, backUpperRight);
                Line(player, duration, color, forwardLowerRight, backLowerRight);
            }

            public static void Box(BasePlayer player, float duration, Color color, OBB obb, float sphereRadius)
            {
                Box(player, duration, color, obb.position, obb.rotation, obb.extents, sphereRadius);
            }

            private BasePlayer _player;
            private Color _color;
            public float Duration { get; }

            public Ddraw(BasePlayer player, float duration, Color? color = null)
            {
                _player = player;
                _color = color ?? Color.white;
                Duration = duration;
            }

            public void Sphere(Vector3 position, float radius, float? duration = null, Color? color = null)
            {
                Sphere(_player, duration ?? Duration, color ?? _color, position, radius);
            }

            public void Line(Vector3 origin, Vector3 target, float? duration = null, Color? color = null)
            {
                Line(_player, duration ?? Duration, color ?? _color, origin, target);
            }

            public void Arrow(Vector3 origin, Vector3 target, float headSize, float? duration = null, Color? color = null)
            {
                Arrow(_player, duration ?? Duration, color ?? _color, origin, target, headSize);
            }

            public void Arrow(Vector3 center, Quaternion rotation, float length, float headSize, float? duration = null, Color? color = null)
            {
                Arrow(_player, duration ?? Duration, color ?? _color, center, rotation, length, headSize);
            }

            public void Text(Vector3 position, string text, float? duration = null, Color? color = null)
            {
                Text(_player, duration ?? Duration, color ?? _color, position, text);
            }

            public void Box(Vector3 center, Quaternion rotation, Vector3 extents, float sphereRadius = DefaultBoxSphereRadius, float? duration = null, Color? color = null)
            {
                Box(_player, duration ?? Duration, color ?? _color, center, rotation, extents, sphereRadius);
            }

            public void Box(OBB obb, float sphereRadius = DefaultBoxSphereRadius, float? duration = null, Color? color = null)
            {
                Box(_player, duration ?? Duration, color ?? _color, obb, sphereRadius);
            }
        }

        private static class EntityUtils
        {
            public static T GetNearbyEntity<T>(BaseEntity originEntity, float maxDistance, int layerMask = -1, string filterShortPrefabName = null) where T : BaseEntity
            {
                var entityList = new List<T>();
                Vis.Entities(originEntity.transform.position, maxDistance, entityList, layerMask, QueryTriggerInteraction.Ignore);
                foreach (var entity in entityList)
                {
                    if (filterShortPrefabName == null || entity.ShortPrefabName == filterShortPrefabName)
                        return entity;
                }

                return null;
            }

            public static T GetClosestNearbyEntity<T>(Vector3 position, float maxDistance, int layerMask = -1, Func<T, bool> predicate = null) where T : BaseEntity
            {
                var entityList = Pool.GetList<T>();
                Vis.Entities(position, maxDistance, entityList, layerMask, QueryTriggerInteraction.Ignore);
                try
                {
                    return GetClosestComponent(position, entityList, predicate);
                }
                finally
                {
                    Pool.FreeList(ref entityList);
                }
            }

            public static T GetClosestNearbyComponent<T>(Vector3 position, float maxDistance, int layerMask = -1, Func<T, bool> predicate = null) where T : Component
            {
                var componentList = Pool.GetList<T>();
                Vis.Components(position, maxDistance, componentList, layerMask, QueryTriggerInteraction.Ignore);
                try
                {
                    return GetClosestComponent(position, componentList, predicate);
                }
                finally
                {
                    Pool.FreeList(ref componentList);
                }
            }

            public static void ConnectNearbyVehicleSpawner(VehicleVendor vehicleVendor)
            {
                if (vehicleVendor.GetVehicleSpawner() != null)
                    return;

                var vehicleSpawner = vehicleVendor.ShortPrefabName == "bandit_conversationalist"
                    ? GetNearbyEntity<VehicleSpawner>(vehicleVendor, 40, Rust.Layers.Mask.Deployed, "airwolfspawner")
                    : vehicleVendor.ShortPrefabName == "boat_shopkeeper"
                    ? GetNearbyEntity<VehicleSpawner>(vehicleVendor, 20, Rust.Layers.Mask.Deployed, "boatspawner")
                    : null;

                if (vehicleSpawner == null)
                    return;

                vehicleVendor.spawnerRef.Set(vehicleSpawner);
            }

            public static void ConnectNearbyVehicleVendor(VehicleSpawner vehicleSpawner)
            {
                var vehicleVendor = vehicleSpawner.ShortPrefabName == "airwolfspawner"
                    ? GetNearbyEntity<VehicleVendor>(vehicleSpawner, 40, Rust.Layers.Mask.Player_Server, "bandit_conversationalist")
                    : vehicleSpawner.ShortPrefabName == "boatspawner"
                    ? GetNearbyEntity<VehicleVendor>(vehicleSpawner, 20, Rust.Layers.Mask.Player_Server, "boat_shopkeeper")
                    : null;

                if (vehicleVendor == null)
                    return;

                vehicleVendor.spawnerRef.Set(vehicleSpawner);
            }

            public static void ConnectNearbyDoor(DoorManipulator doorManipulator)
            {
                // The door manipulator normally checks on layer 21, but use layerMask -1 to allow finding arctic garage doors.
                var door = GetClosestNearbyEntity<Door>(doorManipulator.transform.position, 3);
                if (door == null || door.IsDestroyed)
                    return;

                doorManipulator.SetTargetDoor(door);
                door.SetFlag(BaseEntity.Flags.Locked, true);
            }

            private static T GetClosestComponent<T>(Vector3 position, List<T> componentList, Func<T, bool> predicate = null) where T : Component
            {
                T closestComponent = null;
                float closestDistanceSquared = float.MaxValue;

                foreach (var component in componentList)
                {
                    if (predicate?.Invoke(component) == false)
                        continue;

                    var distance = (component.transform.position - position).sqrMagnitude;
                    if (distance < closestDistanceSquared)
                    {
                        closestDistanceSquared = distance;
                        closestComponent = component;
                    }
                }

                return closestComponent;
            }
        }

        private static class EntitySetupUtils
        {
            public static bool ShouldBeImmortal(BaseEntity entity)
            {
                var samSite = entity as SamSite;
                if (samSite != null && samSite.staticRespawn)
                    return false;

                return true;
            }

            public static void PreSpawnShared(BaseEntity entity)
            {
                var combatEntity = entity as BaseCombatEntity;
                if (combatEntity != null)
                {
                    combatEntity.pickup.enabled = false;
                }

                var stabilityEntity = entity as StabilityEntity;
                if (stabilityEntity != null)
                {
                    stabilityEntity.grounded = true;
                    stabilityEntity.canBeDemolished = false;
                }

                DestroyProblemComponents(entity);
            }

            public static void PostSpawnShared(MonumentAddons plugin, BaseEntity entity, bool enableSaving)
            {
                // Enable/Disable saving after spawn to account for children that spawn late (e.g., Lift).
                EnableSavingRecursive(entity, enableSaving);

                var combatEntity = entity as BaseCombatEntity;
                if (combatEntity != null)
                {
                    if (ShouldBeImmortal(entity))
                    {
                        var basePlayer = entity as BasePlayer;
                        if (basePlayer != null)
                        {
                            // Don't share common protection properties with BasePlayer instances since they get destroyed on kill.
                            combatEntity.baseProtection.Clear();
                            combatEntity.baseProtection.Add(1);
                        }
                        else
                        {
                            // Must set after spawn for building blocks.
                            combatEntity.baseProtection = plugin._immortalProtection;
                        }
                    }
                }

                var decayEntity = entity as DecayEntity;
                if (decayEntity != null)
                {
                    decayEntity.decay = null;

                    var buildingBlock = entity as BuildingBlock;
                    if (buildingBlock != null)
                    {
                        // Must be done after spawn for some reason.
                        if (buildingBlock.HasFlag(BuildingBlock.BlockFlags.CanRotate)
                            || buildingBlock.HasFlag(StabilityEntity.DemolishFlag))
                        {
                            buildingBlock.SetFlag(BuildingBlock.BlockFlags.CanRotate, false, recursive: false, networkupdate: false);
                            buildingBlock.SetFlag(StabilityEntity.DemolishFlag, false, recursive: false, networkupdate: false);
                            buildingBlock.CancelInvoke(buildingBlock.StopBeingRotatable);
                            buildingBlock.CancelInvoke(buildingBlock.StopBeingDemolishable);
                            buildingBlock.SendNetworkUpdate_Flags();
                        }
                    }
                }
            }
        }

        private static class BooleanParser
        {
            private static string[] _booleanYesValues = new string[] { "true", "yes", "on", "1" };
            private static string[] _booleanNoValues = new string[] { "false", "no", "off", "0" };

            public static bool TryParse(string arg, out bool value)
            {
                if (_booleanYesValues.Contains(arg, StringComparer.InvariantCultureIgnoreCase))
                {
                    value = true;
                    return true;
                }

                if (_booleanNoValues.Contains(arg, StringComparer.InvariantCultureIgnoreCase))
                {
                    value = false;
                    return true;
                }

                value = false;
                return false;
            }
        }

        private class ValueRotator<T>
        {
            private T[] _values;
            private int _index;

            public ValueRotator(params T[] values)
            {
                _values = values;
            }

            public T GetNext()
            {
                var color = _values[_index++];
                if (_index >= _values.Length)
                {
                    _index = 0;
                }

                return color;
            }

            public void Reset()
            {
                _index = 0;
            }
        }

        private class HookCollection
        {
            private MonumentAddons _plugin;
            private string[] _hookNames;
            private Func<bool> _shouldSubscribe;
            private bool _isSubscribed;

            public HookCollection(MonumentAddons plugin, string[] hookNames, Func<bool> shouldSubscribe = null)
            {
                _plugin = plugin;
                _hookNames = hookNames;
                _shouldSubscribe = shouldSubscribe ?? (() => true);
            }

            public void Refresh()
            {
                if (_shouldSubscribe())
                {
                    if (!_isSubscribed)
                    {
                        Subscribe();
                    }
                }
                else if (_isSubscribed)
                {
                    Unsubscribe();
                }
            }

            public void Subscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }

                _isSubscribed = true;
            }

            public void Unsubscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }

                _isSubscribed = false;
            }
        }

        private class UniqueNameRegistry
        {
            private Dictionary<string, string> _uniqueNameByPrefabPath = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);

            public void OnServerInitialized()
            {
                BuildIndex();
            }

            public string GetUniqueShortName(string prefabPath)
            {
                if (!_uniqueNameByPrefabPath.TryGetValue(prefabPath, out var uniqueName))
                {
                    // Unique names are only stored initially if different from short name.
                    // To avoid frequent heap allocations, also cache other short names that are accessed.
                    uniqueName = GetShortName(prefabPath);
                    _uniqueNameByPrefabPath[prefabPath] = uniqueName.ToLower();
                }

                return uniqueName;
            }

            private string[] GetSegments(string prefabPath)
            {
                return prefabPath.Split('/');
            }

            private string GetPartialPath(string[] segments, int numSegments)
            {
                numSegments = Math.Min(numSegments, segments.Length);
                var arraySegment = new ArraySegment<string>(segments, segments.Length - numSegments, numSegments);
                return string.Join("/", arraySegment);
            }

            private void BuildIndex()
            {
                var remainingPrefabPaths = GameManifest.Current.entities.ToList();
                var numSegmentsFromEnd = 1;

                var iterations = 0;
                var maxIterations = 1;

                while (remainingPrefabPaths.Count > 0 && iterations++ < maxIterations)
                {
                    var countByPartialPath = new Dictionary<string, int>();

                    foreach (var prefabPath in remainingPrefabPaths)
                    {
                        var segments = GetSegments(prefabPath);
                        maxIterations = Math.Max(maxIterations, segments.Length);

                        var partialPath = GetPartialPath(segments, numSegmentsFromEnd);

                        if (!countByPartialPath.TryGetValue(partialPath, out var segmentCount))
                        {
                            segmentCount = 0;
                        }

                        countByPartialPath[partialPath] = segmentCount + 1;
                    }

                    for (var i = remainingPrefabPaths.Count - 1; i >= 0; i--)
                    {
                        var prefabPath = remainingPrefabPaths[i];
                        var partialPath = GetPartialPath(GetSegments(prefabPath), numSegmentsFromEnd);

                        if (countByPartialPath[partialPath] == 1)
                        {
                            // Only cache the unique name if different than short name.
                            if (numSegmentsFromEnd > 1)
                            {
                                _uniqueNameByPrefabPath[prefabPath] = partialPath.ToLower().Replace(".prefab", string.Empty);
                            }

                            remainingPrefabPaths.RemoveAt(i);
                        }
                    }

                    numSegmentsFromEnd++;
                }
            }
        }

        private class EmptyMonoBehavior : MonoBehaviour {}

        private class CoroutineManager
        {
            public static Coroutine StartGlobalCoroutine(IEnumerator enumerator)
            {
                return ServerMgr.Instance?.StartCoroutine(enumerator);
            }

            private static IEnumerator CallbackRoutine(Coroutine dependency, Action action)
            {
                yield return dependency;
                action();
            }

            // Object for tracking all coroutines for spawning or updating entities.
            // This allows easily stopping all those coroutines by simply destroying the game object.
            private MonoBehaviour _coroutineComponent;

            public Coroutine StartCoroutine(IEnumerator enumerator)
            {
                if (_coroutineComponent == null)
                {
                    _coroutineComponent = new GameObject().AddComponent<EmptyMonoBehavior>();
                }

                return _coroutineComponent.StartCoroutine(enumerator);
            }

            public Coroutine StartCallbackRoutine(Coroutine coroutine, Action callback)
            {
                return StartCoroutine(CallbackRoutine(coroutine, callback));
            }

            public void StopAll()
            {
                if (_coroutineComponent == null)
                    return;

                _coroutineComponent.StopAllCoroutines();
            }

            public void Destroy()
            {
                if (_coroutineComponent == null)
                    return;

                UnityEngine.Object.DestroyImmediate(_coroutineComponent?.gameObject);
            }
        }

        private class WireToolManager
        {
            private const float DrawDuration = 3;
            private const float DrawSlotRadius = 0.04f;
            private const float PreviewDotRadius = 0.01f;
            private const float InputCooldown = 0.25f;
            private const float HoldToClearDuration = 0.5f;

            private const float DrawIntervalDuration = 0.01f;
            private const float DrawIntervalWithBuffer = DrawIntervalDuration + 0.05f;
            private const float MinAngleDot = 0.999f;

            private class WireSession
            {
                public BasePlayer Player { get; }
                public WireColour? WireColor;
                public IOType WireType;
                public EntityAdapter Adapter;
                public IOSlot StartSlot;
                public int StartSlotIndex;
                public bool IsSource;
                public float LastInput;
                public float SecondaryPressedTime = float.MaxValue;
                public float LastDrawTime;

                public List<Vector3> Points = new List<Vector3>();

                public WireSession(BasePlayer player)
                {
                    Player = player;
                }

                public void Reset(bool refreshPoints = false)
                {
                    Points.Clear();
                    if (refreshPoints)
                    {
                        RefreshPoints();
                    }

                    Adapter = null;
                    SecondaryPressedTime = float.MaxValue;
                }

                public void StartConnection(EntityAdapter adapter, IOSlot startSlot, int slotIndex, bool isSource)
                {
                    WireType = startSlot.type;
                    Adapter = adapter;
                    StartSlot = startSlot;
                    StartSlotIndex = slotIndex;
                    IsSource = isSource;
                    startSlot.wireColour = WireColor ?? WireColour.Gray;
                }

                public void AddPoint(Vector3 position)
                {
                    Points.Add(position);
                    RefreshPoints();
                }

                public void RemoveLast()
                {
                    if (Points.Count > 0)
                    {
                        Points.RemoveAt(Points.Count - 1);
                        RefreshPoints();
                    }
                    else
                    {
                        Reset(refreshPoints: true);
                    }
                }

                public bool IsOnInputCooldown()
                {
                    return LastInput + InputCooldown > UnityEngine.Time.time;
                }

                public bool IsOnDrawCooldown()
                {
                    return LastDrawTime + DrawIntervalDuration > UnityEngine.Time.time;
                }

                public void RefreshPoints()
                {
                    var ioEntity = Adapter?.Entity as IOEntity;
                    if (ioEntity == null)
                        return;

                    var slot = IsSource
                        ? ioEntity.outputs[StartSlotIndex]
                        : ioEntity.inputs[StartSlotIndex];

                    if (slot.type == IOType.Kinetic)
                    {
                        // Don't attempt to render wires for kinetic slots since that will kick the player.
                        return;
                    }

                    slot.linePoints = new Vector3[Points.Count + 1];

                    if (IsSource)
                    {
                        slot.linePoints[0] = slot.handlePosition;
                        for (var i = 0; i < Points.Count; i++)
                        {
                            slot.linePoints[i + 1] = ioEntity.transform.InverseTransformPoint(Points[i]);
                        }
                    }
                    else
                    {
                        // TODO: Implement a temporary entity to show a line from destination input
                    }

                    ioEntity.SendNetworkUpdate();
                }
            }

            private MonumentAddons _plugin;
            private ProfileStore _profileStore;
            private AddonComponentTracker _componentTracker => _plugin._componentTracker;
            private List<WireSession> _playerSessions = new List<WireSession>();
            private Timer _timer;

            public WireToolManager(MonumentAddons plugin, ProfileStore profileStore)
            {
                _plugin = plugin;
                _profileStore = profileStore;
            }

            public bool HasPlayer(BasePlayer player)
            {
                return GetPlayerSession(player) != null;
            }

            public void StartOrUpdateSession(BasePlayer player, WireColour? wireColor)
            {
                var session = GetPlayerSession(player, out _);
                if (session == null)
                {
                    session = new WireSession(player);
                    _playerSessions.Add(session);
                }

                session.WireColor = wireColor;

                if (_timer == null || _timer.Destroyed)
                {
                    _timer = _plugin.timer.Every(0, ProcessPlayers);
                }
            }

            public void StopSession(BasePlayer player)
            {
                var session = GetPlayerSession(player, out var sessionIndex);
                if (session == null)
                    return;

                DestroySession(session, sessionIndex);
            }

            public void Unload()
            {
                for (var i = _playerSessions.Count - 1; i >= 0; i--)
                {
                    DestroySession(_playerSessions[i], i);
                }
            }

            private WireSession GetPlayerSession(BasePlayer player, out int index)
            {
                for (var i = 0; i < _playerSessions.Count; i++)
                {
                    var session = _playerSessions[i];
                    if (session.Player == player)
                    {
                        index = i;
                        return session;
                    }
                }

                index = 0;
                return null;
            }

            private WireSession GetPlayerSession(BasePlayer player)
            {
                return GetPlayerSession(player, out _);
            }

            private void DestroySession(WireSession session, int index)
            {
                session.Reset(refreshPoints: true);
                _playerSessions.RemoveAt(index);

                if (_playerSessions.Count == 0 && _timer != null)
                {
                    _timer.Destroy();
                    _timer = null;
                }

                _plugin.ChatMessage(session.Player, LangEntry.WireToolDeactivated);
            }

            private EntityAdapter GetLookIOAdapter(BasePlayer player, out IOEntity ioEntity)
            {
                ioEntity = GetLookEntitySphereCast<IOEntity>(player, Rust.Layers.Solid, 0.1f, 6);
                if (ioEntity == null)
                    return null;

                if (!_componentTracker.IsAddonComponent(ioEntity, out EntityAdapter adapter, out EntityController _))
                {
                    _plugin.ChatMessage(player, LangEntry.ErrorEntityNotEligible);
                    return null;
                }

                if (adapter == null)
                {
                    _plugin.ChatMessage(player, LangEntry.ErrorNoSuitableAddonFound);
                    return null;
                }

                return adapter;
            }

            private IOSlot GetClosestIOSlot(IOEntity ioEntity, Ray ray, float minDot, out int index, out float highestDot, bool wantsSourceSlot, bool? wantsOccupiedSlots = false)
            {
                IOSlot closestSlot = null;
                index = 0;
                highestDot = -1f;

                var transform = ioEntity.transform;
                var slotList = wantsSourceSlot ? ioEntity.outputs : ioEntity.inputs;

                for (var slotIndex = 0; slotIndex < slotList.Length; slotIndex++)
                {
                    var slot = slotList[slotIndex];
                    if (wantsOccupiedSlots.HasValue && wantsOccupiedSlots.Value == (slot.connectedTo.Get() == null))
                        continue;

                    var slotPosition = transform.TransformPoint(slot.handlePosition);

                    var dot = Vector3.Dot(ray.direction, (slotPosition - ray.origin).normalized);
                    if (dot > minDot && dot > highestDot)
                    {
                        closestSlot = slot;
                        index = slotIndex;
                        highestDot = dot;
                    }
                }

                return closestSlot;
            }

            private IOSlot GetClosestIOSlot(IOEntity ioEntity, Ray ray, float minDot, out int index, out bool isSourceSlot, bool? wantsOccupiedSlots = null)
            {
                index = 0;
                isSourceSlot = false;

                var sourceSlot = GetClosestIOSlot(
                    ioEntity,
                    ray,
                    minDot,
                    out var sourceSlotIndex,
                    out var sourceDot,
                    wantsSourceSlot: true,
                    wantsOccupiedSlots: wantsOccupiedSlots
                );

                var destinationSlot = GetClosestIOSlot(
                    ioEntity,
                    ray, minDot, out var destinationSlotIndex,
                    out var destinationDot,
                    wantsSourceSlot: false,
                    wantsOccupiedSlots: wantsOccupiedSlots
                );

                if (sourceSlot == null && destinationSlot == null)
                    return null;

                if (sourceSlot != null && destinationSlot != null)
                {
                    if (sourceDot >= destinationDot)
                    {
                        isSourceSlot = true;
                        index = sourceSlotIndex;
                        return sourceSlot;
                    }

                    index = destinationSlotIndex;
                    return destinationSlot;
                }

                if (sourceSlot != null)
                {
                    isSourceSlot = true;
                    index = sourceSlotIndex;
                    return sourceSlot;
                }

                index = destinationSlotIndex;
                return destinationSlot;
            }

            private bool CanPlayerUseTool(BasePlayer player)
            {
                if (player == null || player.IsDestroyed || !player.IsConnected || player.IsDead())
                    return false;

                var activeItemShortName = player.GetActiveItem()?.info.shortname;
                if (activeItemShortName == null)
                    return false;

                return activeItemShortName == "wiretool" || activeItemShortName == "hosetool";
            }

            private Color DetermineSlotColor(IOSlot slot)
            {
                if (slot.connectedTo.Get() != null)
                    return Color.red;

                if (slot.type == IOType.Fluidic)
                    return Color.cyan;

                if (slot.type == IOType.Kinetic)
                    return new Color(1, 0.5f, 0);

                return Color.yellow;
            }

            private void ShowSlots(BasePlayer player, IOEntity ioEntity, bool showSourceSlots)
            {
                var transform = ioEntity.transform;
                var slotList = showSourceSlots ? ioEntity.outputs : ioEntity.inputs;

                foreach (var slot in slotList)
                {
                    var color = DetermineSlotColor(slot);
                    var drawer = new Ddraw(player, DrawDuration, color);
                    var position = transform.TransformPoint(slot.handlePosition);

                    drawer.Sphere(position, DrawSlotRadius);
                    drawer.Text(position, showSourceSlots ? "OUT" : "IN");
                }
            }

            private void DrawSessionState(WireSession session)
            {
                if (session.Adapter == null || session.IsOnDrawCooldown())
                    return;

                var player = session.Player;
                session.LastDrawTime = UnityEngine.Time.time;

                var ioEntity = session.Adapter.Entity as IOEntity;
                var startPosition = ioEntity.transform.TransformPoint(session.StartSlot.handlePosition);
                var drawer = new Ddraw(player, DrawDuration, Color.green);
                drawer.Sphere(startPosition, DrawSlotRadius);

                if (TryGetHitPosition(player, out var hitPosition))
                {
                    var lastPoint = session.Points.Count == 0
                        ? session.StartSlot.handlePosition
                        : session.StartSlot.linePoints.LastOrDefault();

                    var lineDrawer = new Ddraw(player, DrawIntervalWithBuffer, Color.green);
                    lineDrawer.Sphere(hitPosition, PreviewDotRadius);
                    lineDrawer.Line(ioEntity.transform.TransformPoint(lastPoint), hitPosition);
                }
            }

            private void MaybeStartWire(WireSession session, EntityAdapter adapter)
            {
                var player = session.Player;
                var ioEntity = adapter.Entity as IOEntity;
                var drawer = new Ddraw(player, DrawDuration);

                var slot = GetClosestIOSlot(ioEntity, player.eyes.HeadRay(), MinAngleDot, out var slotIndex, out var isSourceSlot, wantsOccupiedSlots: false);
                if (slot == null)
                {
                    ShowSlots(player, ioEntity, showSourceSlots: true);
                    ShowSlots(player, ioEntity, showSourceSlots: false);
                    return;
                }

                if (slot.connectedTo.Get() != null)
                {
                    drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius, color: Color.red);
                    return;
                }

                session.StartConnection(adapter, slot, slotIndex, isSource: isSourceSlot);
                drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius, color: Color.green);
                SendEffect(player, WireToolPlugEffect);
            }

            private void MaybeEndWire(WireSession session, EntityAdapter adapter)
            {
                var player = session.Player;
                var ioEntity = adapter.Entity as IOEntity;
                var drawer = new Ddraw(player, DrawDuration, Color.red);

                var headRay = player.eyes.HeadRay();
                var slot = GetClosestIOSlot(ioEntity, headRay, MinAngleDot, out var slotIndex, out var distanceSquared, wantsSourceSlot: !session.IsSource);
                if (slot == null)
                {
                    slot = GetClosestIOSlot(ioEntity, headRay, MinAngleDot, out slotIndex, out distanceSquared, wantsSourceSlot: session.IsSource);
                    if (slot != null)
                    {
                        drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius);
                    }

                    ShowSlots(player, ioEntity, showSourceSlots: !session.IsSource);
                    return;
                }

                if (slot.connectedTo.Get() != null)
                {
                    drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius);
                    return;
                }

                var adapterProfile = adapter.Controller.Profile;
                var sessionProfile = session.Adapter.Controller.Profile;
                if (adapterProfile != sessionProfile)
                {
                    drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius);
                    _plugin.ChatMessage(player, LangEntry.WireToolProfileMismatch, sessionProfile, adapterProfile.Name);
                    return;
                }

                if (!adapter.Monument.IsEquivalentTo(session.Adapter.Monument))
                {
                    drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius);
                    _plugin.ChatMessage(player, LangEntry.WireToolMonumentMismatch);
                    return;
                }

                if (slot.type != session.WireType)
                {
                    drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius);
                    _plugin.ChatMessage(player, LangEntry.WireToolTypeMismatch, session.WireType, slot.type);
                    return;
                }

                var sourceAdapter = session.IsSource ? session.Adapter : adapter;
                var destinationAdapter = session.IsSource ? adapter : session.Adapter;

                var points = session.Points.Select(adapter.Monument.InverseTransformPoint);
                if (!session.IsSource)
                {
                    points = points.Reverse();
                }

                var connectionData = new IOConnectionData
                {
                    ConnectedToId = destinationAdapter.EntityData.Id,
                    Slot = session.IsSource ? session.StartSlotIndex : slotIndex,
                    ConnectedToSlot = session.IsSource ? slotIndex : session.StartSlotIndex,
                    Points = points.ToArray(),
                    ShowWire = session.WireColor.HasValue,
                    Color = session.WireColor ?? WireColour.Gray,
                };

                sourceAdapter.EntityData.AddIOConnection(connectionData);
                _profileStore.Save(sourceAdapter.Controller.Profile);

                (sourceAdapter.Controller as EntityController).StartUpdateRoutine();
                session.Reset();

                drawer.Sphere(adapter.Transform.TransformPoint(slot.handlePosition), DrawSlotRadius, color: Color.green);
                SendEffect(player, WireToolPlugEffect);
            }

            private void MaybeClearWire(WireSession session)
            {
                var player = session.Player;
                session.SecondaryPressedTime = float.MaxValue;

                var adapter = GetLookIOAdapter(player, out var ioEntity);
                if (adapter == null)
                    return;

                var slot = GetClosestIOSlot(ioEntity, player.eyes.HeadRay(), MinAngleDot, out var slotIndex, out var isSourceSlot, wantsOccupiedSlots: true);
                if (slot == null)
                    return;

                EntityAdapter sourceAdapter;
                EntityAdapter destinationAdapter;
                int sourceSlotIndex;

                if (isSourceSlot)
                {
                    sourceAdapter = adapter;
                    sourceSlotIndex = slotIndex;

                    var destinationEntity = slot.connectedTo.Get();

                    if (!_componentTracker.IsAddonComponent(destinationEntity, out destinationAdapter, out EntityController _))
                        return;
                }
                else
                {
                    destinationAdapter = adapter;

                    var sourceEntity = slot.connectedTo.Get();

                    if (!_componentTracker.IsAddonComponent(sourceEntity, out sourceAdapter, out EntityController _))
                        return;

                    sourceSlotIndex = slot.connectedToSlot;
                }

                sourceAdapter.EntityData.RemoveIOConnection(sourceSlotIndex);
                _profileStore.Save(sourceAdapter.Controller.Profile);
                var handleChangesRoutine = (sourceAdapter.Controller as EntityController).StartUpdateRoutine();
                destinationAdapter.ProfileController.StartCallbackRoutine(handleChangesRoutine,
                    () => (destinationAdapter.Controller as EntityController).StartUpdateRoutine());
            }

            private void ProcessPlayers()
            {
                for (var i = _playerSessions.Count - 1; i >= 0; i--)
                {
                    var session = _playerSessions[i];
                    var player = session.Player;

                    if (!CanPlayerUseTool(player))
                    {
                        DestroySession(session, i);
                        continue;
                    }

                    if (session.Adapter != null && (session.Adapter == null || session.Adapter.IsDestroyed))
                    {
                        session.Reset();
                    }

                    var secondaryJustPressed = player.serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY);
                    var secondaryJustReleased = player.serverInput.WasJustReleased(BUTTON.FIRE_SECONDARY);
                    var now = UnityEngine.Time.time;
                    var secondaryPressedDuration = 0f;

                    if (secondaryJustPressed)
                    {
                        session.SecondaryPressedTime = now;
                    }
                    else if (secondaryJustReleased)
                    {
                        session.SecondaryPressedTime = float.MaxValue;
                    }
                    else if (session.SecondaryPressedTime != float.MaxValue)
                    {
                        secondaryPressedDuration = now - session.SecondaryPressedTime;
                    }

                    DrawSessionState(session);

                    if (session.IsOnInputCooldown())
                        continue;

                    if (player.serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY))
                    {
                        session.LastInput = now;

                        var adapter = GetLookIOAdapter(player, out _);
                        if (adapter != null)
                        {
                            if (session.Adapter == null)
                            {
                                MaybeStartWire(session, adapter);
                                continue;
                            }

                            MaybeEndWire(session, adapter);
                            continue;
                        }

                        if (session.Adapter != null)
                        {
                            if (session.WireType == IOType.Kinetic)
                            {
                                // Placing wires with kinetic slots will kick the player.
                                continue;
                            }

                            if (session.WireColor.HasValue && TryGetHitPosition(player, out var position))
                            {
                                session.AddPoint(position);
                                SendEffect(player, WireToolPlugEffect);
                            }
                        }

                        continue;
                    }

                    if (session.Adapter != null && secondaryJustPressed)
                    {
                        // Remove the most recently placed wire.
                        session.LastInput = now;
                        session.RemoveLast();
                    }

                    if (session.Adapter == null
                        && session.SecondaryPressedTime != float.MaxValue
                        && secondaryPressedDuration >= HoldToClearDuration)
                    {
                        MaybeClearWire(session);
                    }
                }

                if (_playerSessions.Count == 0 && _timer is { Destroyed: true })
                {
                    _timer.Destroy();
                    _timer = null;
                }
            }
        }

        private abstract class DictionaryKeyConverter<TKey, TValue> : JsonConverter
        {
            public virtual string KeyToString(TKey key)
            {
                return key.ToString();
            }

            public abstract TKey KeyFromString(string key);

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Dictionary<TKey, TValue>);
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var obj = serializer.Deserialize(reader) as JObject;
                if (existingValue is not Dictionary<TKey, TValue> dict)
                    return null;

                foreach (var entry in obj)
                {
                    dict[KeyFromString(entry.Key)] = entry.Value.ToObject<TValue>();
                }

                return dict;
            }

            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                if (value is not Dictionary<TKey, TValue> dict)
                {
                    writer.WriteStartObject();
                    writer.WriteEndObject();
                    return;
                }

                writer.WriteStartObject();

                foreach (var entry in dict)
                {
                    writer.WritePropertyName(KeyToString(entry.Key));
                    serializer.Serialize(writer, entry.Value);
                }

                writer.WriteEndObject();
            }
        }

        private class HtmlColorConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                if (value == null)
                {
                    writer.WriteNull();
                    return;
                }

                Color color = (Color)value;
                writer.WriteValue(Mathf.Approximately(color.a, 1f)
                    ? $"#{ColorUtility.ToHtmlStringRGB(color)}"
                    : $"#{ColorUtility.ToHtmlStringRGBA(color)}");
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Color);
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.Null)
                    return default(Color);

                if (reader.Value is not string colorString || !ColorUtility.TryParseHtmlString(colorString, out var color))
                    throw new JsonException($"Invalid RGB color string: {reader.Value}");

                return color;
            }
        }

        private class ActionDebounced
        {
            private PluginTimers _pluginTimers;
            private float _seconds;
            private Action _action;
            private Timer _timer;

            public ActionDebounced(PluginTimers pluginTimers, float seconds, Action action)
            {
                _pluginTimers = pluginTimers;
                _seconds = seconds;
                _action = action;
            }

            public void Schedule()
            {
                if (_timer == null || _timer.Destroyed)
                {
                    _timer = _pluginTimers.Once(_seconds, _action);
                    return;
                }

                // Restart the existing timer.
                _timer.Reset();
            }

            public void Flush()
            {
                if (_timer == null || _timer.Destroyed)
                    return;

                _timer.Destroy();
                _action();
            }
        }

        private interface IDeepCollection
        {
            bool HasItems();
        }

        private static bool HasDeepItems<TKey, TValue>(Dictionary<TKey, TValue> dict) where TValue : IDeepCollection
        {
            if (dict.Count == 0)
                return false;

            foreach (var value in dict.Values)
            {
                if (value.HasItems())
                    return true;
            }

            return false;
        }

        private class MonumentHelper
        {
            private MonumentAddons _plugin;
            private Plugin _monumentFinder => _plugin.MonumentFinder;
            private Dictionary<DungeonGridInfo, MonumentInfo> _entranceToMonument = new Dictionary<DungeonGridInfo, MonumentInfo>();

            public MonumentHelper(MonumentAddons plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                foreach (var monumentInfo in TerrainMeta.Path.Monuments)
                {
                    if (monumentInfo.DungeonEntrance != null)
                    {
                        _entranceToMonument[monumentInfo.DungeonEntrance] = monumentInfo;
                    }
                }
            }

            public List<BaseMonument> FindMonumentsByAlias(string alias)
            {
                return WrapFindMonumentResults(_monumentFinder.Call("API_FindByAlias", alias) as List<Dictionary<string, object>>);
            }

            public List<BaseMonument> FindMonumentsByShortName(string shortName)
            {
                return WrapFindMonumentResults(_monumentFinder.Call("API_FindByShortName", shortName) as List<Dictionary<string, object>>);
            }

            public MonumentAdapter GetClosestMonumentAdapter(Vector3 position)
            {
                if (_monumentFinder.Call("API_GetClosest", position) is not Dictionary<string, object> dictResult)
                    return null;

                return new MonumentAdapter(dictResult);
            }

            public bool IsMonumentUnique(string shortName)
            {
                var monuments = FindMonumentsByShortName(shortName);
                return monuments == null || monuments.Count <= 1;
            }

            private List<BaseMonument> WrapFindMonumentResults(List<Dictionary<string, object>> dictList)
            {
                if (dictList == null)
                    return null;

                var monumentList = new List<BaseMonument>();
                foreach (var dict in dictList)
                {
                    monumentList.Add(new MonumentAdapter(dict));
                }

                return monumentList;
            }

            public MonumentInfo GetMonumentFromTunnel(DungeonGridCell dungeonGridCell)
            {
                var entrance = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonGridEntrances, dungeonGridCell.transform.position);
                if (entrance == null)
                    return null;

                return GetMonumentFromEntrance(entrance);
            }

            private MonumentInfo GetMonumentFromEntrance(DungeonGridInfo dungeonGridInfo)
            {
                return _entranceToMonument.TryGetValue(dungeonGridInfo, out var monumentInfo)
                    ? monumentInfo
                    : null;
            }
        }

        private static class PhoneUtils
        {
            public const string Tunnel = "FTL";
            public const string UnderwaterLab = "Underwater Lab";
            public const string CargoShip = "Cargo Ship";

            private static readonly Regex SplitCamelCaseRegex = new Regex("([a-z])([A-Z])", RegexOptions.Compiled);

            private static readonly string[] PolymorphicMonumentVariants =
            {
                "fishing_village_b",
                "fishing_village_c",
                "harbor_1",
                "harbor_2",
                "power_sub_big_1",
                "power_sub_big_2",
                "power_sub_small_1",
                "power_sub_small_2",
                "water_well_a",
                "water_well_b",
                "water_well_c",
                "water_well_d",
                "water_well_e",
                "entrance_bunker_a",
                "entrance_bunker_b",
                "entrance_bunker_c",
                "entrance_bunker_d",
            };

            public static void NameTelephone(Telephone telephone, BaseMonument monument, Vector3 position, MonumentHelper monumentHelper)
            {
                string phoneName = null;

                var monumentInfo = monument.Object as MonumentInfo;
                if (monumentInfo != null && !string.IsNullOrEmpty(monumentInfo.displayPhrase.translated))
                {
                    phoneName = monumentInfo.displayPhrase.translated;

                    if (ShouldAppendCoordinate(monument.ShortName, monumentHelper))
                    {
                        phoneName += $" {MapHelper.PositionToString(position)}";
                    }
                }

                var dungeonGridCell = monument.Object as DungeonGridCell;
                if (dungeonGridCell != null && !string.IsNullOrEmpty(monument.Alias))
                {
                    phoneName = GetFTLPhoneName(monument.Alias, dungeonGridCell, monument, position, monumentHelper);
                }

                var dungeonBaseLink = monument.Object as DungeonBaseLink;
                if (dungeonBaseLink != null)
                {
                    phoneName = GetUnderwaterLabPhoneName(dungeonBaseLink, position);
                }

                if (monument is DynamicMonument dynamicMonument)
                {
                    phoneName = GetDynamicMonumentPhoneName(dynamicMonument, telephone);
                }

                telephone.Controller.PhoneName = !string.IsNullOrEmpty(phoneName)
                    ? phoneName
                    : $"{telephone.GetDisplayName()} {MapHelper.PositionToString(position)}";

                TelephoneManager.RegisterTelephone(telephone.Controller);
            }

            private static string GetFTLCorridorPhoneName(string tunnelName, Vector3 position)
            {
                return $"{Tunnel} {tunnelName} {MapHelper.PositionToString(position)}";
            }

            private static string GetFTLPhoneName(string tunnelAlias, DungeonGridCell dungeonGridCell, BaseMonument monument, Vector3 position, MonumentHelper monumentHelper)
            {
                var tunnelName = SplitCamelCase(tunnelAlias);
                var phoneName = GetFTLCorridorPhoneName(tunnelName, position);

                if (monument.UniqueName == "TrainStation")
                {
                    var attachedMonument = monumentHelper.GetMonumentFromTunnel(dungeonGridCell);
                    if (attachedMonument != null && !attachedMonument.name.Contains("tunnel-entrance/entrance_bunker"))
                    {
                        phoneName = GetFTLTrainStationPhoneName(attachedMonument, tunnelName, position, monumentHelper);
                    }
                }

                return phoneName;
            }

            private static string GetFTLTrainStationPhoneName(MonumentInfo attachedMonument, string tunnelName, Vector3 position, MonumentHelper monumentHelper)
            {
                var phoneName = string.IsNullOrEmpty(attachedMonument.displayPhrase.translated)
                    ? $"{Tunnel} {tunnelName}"
                    : $"{Tunnel} {attachedMonument.displayPhrase.translated} {tunnelName}";

                var shortname = GetShortName(attachedMonument.name);

                if (ShouldAppendCoordinate(shortname, monumentHelper))
                {
                    phoneName += $" {MapHelper.PositionToString(position)}";
                }

                return phoneName;
            }

            private static string GetUnderwaterLabPhoneName(DungeonBaseLink link, Vector3 position)
            {
                var floors = link.Dungeon.Floors;
                var gridCoordinate = MapHelper.GridToString(MapHelper.PositionToGrid(position));

                for (int i = 0; i < floors.Count; i++)
                {
                    if (floors[i].Links.Contains(link))
                    {
                        var roomLevel = $"L{1 + i}";
                        var roomType = link.Type.ToString();
                        var roomNumber = 1 + floors[i].Links.IndexOf(link);
                        var roomName = $"{roomLevel} {roomType} {roomNumber}";

                        return $"{UnderwaterLab} {gridCoordinate} {roomName}";
                    }
                }

                return $"{UnderwaterLab} {gridCoordinate}";
            }

            private static string GetDynamicMonumentPhoneName(DynamicMonument monument, Telephone phone)
            {
                if (monument.RootEntity is CargoShip)
                    return $"{CargoShip} {monument.EntityId}";

                return $"{phone.GetDisplayName()} {monument.EntityId}";
            }

            private static bool ShouldAppendCoordinate(string monumentShortName, MonumentHelper monumentHelper)
            {
                if (PolymorphicMonumentVariants.Contains(monumentShortName))
                    return true;

                return !monumentHelper.IsMonumentUnique(monumentShortName);
            }

            private static string SplitCamelCase(string camelCase)
            {
                return SplitCamelCaseRegex.Replace(camelCase, "$1 $2");
            }
        }

        #endregion

        #endregion

        #region Monuments

        private abstract class BaseMonument
        {
            public Component Object { get; }
            public virtual string PrefabName => Object.name;
            public virtual string ShortName => GetShortName(PrefabName);
            public virtual string Alias => null;
            public virtual string UniqueDisplayName => Alias ?? ShortName;
            public virtual string UniqueName => UniqueDisplayName;
            public virtual Vector3 Position => Object.transform.position;
            public virtual Quaternion Rotation => Object.transform.rotation;
            public virtual bool IsValid => Object != null;

            protected BaseMonument(Component component)
            {
                Object = component;
            }

            public virtual Vector3 TransformPoint(Vector3 localPosition)
            {
                return Object.transform.TransformPoint(localPosition);
            }

            public virtual Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return Object.transform.InverseTransformPoint(worldPosition);
            }

            public abstract Vector3 ClosestPointOnBounds(Vector3 position);
            public abstract bool IsInBounds(Vector3 position);

            public virtual bool IsEquivalentTo(BaseMonument other)
            {
                return PrefabName == other.PrefabName
                    && Position == other.Position;
            }
        }

        private class MonumentAdapter : BaseMonument
        {
            public override string PrefabName => (string)_monumentInfo["PrefabName"];
            public override string ShortName => (string)_monumentInfo["ShortName"];
            public override string Alias => (string)_monumentInfo["Alias"];
            public override string UniqueDisplayName => Alias ?? ShortName;
            public override Vector3 Position => (Vector3)_monumentInfo["Position"];
            public override Quaternion Rotation => (Quaternion)_monumentInfo["Rotation"];

            private Dictionary<string, object> _monumentInfo;

            public MonumentAdapter(Dictionary<string, object> monumentInfo) : base((MonoBehaviour)monumentInfo["Object"])
            {
                _monumentInfo = monumentInfo;
            }

            public override Vector3 TransformPoint(Vector3 localPosition)
            {
                return ((Func<Vector3, Vector3>)_monumentInfo["TransformPoint"]).Invoke(localPosition);
            }

            public override Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return ((Func<Vector3, Vector3>)_monumentInfo["InverseTransformPoint"]).Invoke(worldPosition);
            }

            public override Vector3 ClosestPointOnBounds(Vector3 position)
            {
                return ((Func<Vector3, Vector3>)_monumentInfo["ClosestPointOnBounds"]).Invoke(position);
            }

            public override bool IsInBounds(Vector3 position)
            {
                return ((Func<Vector3, bool>)_monumentInfo["IsInBounds"]).Invoke(position);
            }
        }

        private interface IDynamicMonument {}

        private interface IEntityMonument
        {
            BaseEntity RootEntity { get; }
            NetworkableId EntityId { get; }
            bool IsMobile { get; }
            bool IsValid { get; }
        }

        private class DynamicMonument : BaseMonument, IDynamicMonument, IEntityMonument
        {
            public BaseEntity RootEntity { get; }
            public bool IsMobile { get; }
            public override string PrefabName => RootEntity.PrefabName;
            public override string ShortName => RootEntity.ShortPrefabName;
            public override string UniqueName => PrefabName;
            public override string UniqueDisplayName => ShortName;
            public override bool IsValid => base.IsValid && !RootEntity.IsDestroyed;
            public NetworkableId EntityId { get; }

            protected OBB BoundingBox => RootEntity.WorldSpaceBounds();

            public DynamicMonument(BaseEntity entity, bool isMobile) : base(entity)
            {
                RootEntity = entity;
                // Cache the entity ID in case the entity gets killed, since the ID used in the state file.
                EntityId = entity.net?.ID ?? new NetworkableId();
                IsMobile = isMobile;
            }

            public DynamicMonument(BaseEntity entity) : this(entity, HasRigidBody(entity)) { }

            public override Vector3 ClosestPointOnBounds(Vector3 position)
            {
                return BoundingBox.ClosestPoint(position);
            }

            public override bool IsInBounds(Vector3 position)
            {
                return BoundingBox.Contains(position);
            }

            public override bool IsEquivalentTo(BaseMonument other)
            {
                return other is DynamicMonument otherDynamocMonument
                    && otherDynamocMonument.RootEntity == RootEntity;
            }
        }

        private class CustomMonument : BaseMonument
        {
            public readonly Plugin OwnerPlugin;
            public readonly Component Component;
            public Bounds Bounds;

            private readonly string _monumentName;
            private Vector3 _position;

            public override string PrefabName => _monumentName;
            public override string ShortName => _monumentName;
            public override string UniqueName => _monumentName;
            public override string UniqueDisplayName => _monumentName;
            public override Vector3 Position => _position;

            public OBB BoundingBox => new OBB(Component.transform, Bounds);

            public CustomMonument(Plugin ownerPlugin, Component component, string monumentName, Bounds bounds) : base(component)
            {
                OwnerPlugin = ownerPlugin;
                Component = component;
                _monumentName = monumentName;
                // Cache the position in case the monument gets killed, since the position is used in the state file.
                _position = component.transform.position;
                Bounds = bounds;
            }

            public override Vector3 ClosestPointOnBounds(Vector3 position)
            {
                return BoundingBox.ClosestPoint(position);
            }

            public override bool IsInBounds(Vector3 position)
            {
                return BoundingBox.Contains(position);
            }

            public override bool IsEquivalentTo(BaseMonument other)
            {
                return other is CustomMonument otherCustomMonument
                    && otherCustomMonument.Component == Component;
            }
        }

        private class CustomEntityMonument : CustomMonument, IEntityMonument
        {
            public BaseEntity RootEntity { get; }
            public NetworkableId EntityId { get; }
            public bool IsMobile { get; }

            public CustomEntityMonument(Plugin ownerPlugin, BaseEntity entity, string monumentName, Bounds bounds)
                : base(ownerPlugin, entity, monumentName, bounds)
            {
                RootEntity = entity;
                EntityId = entity.net?.ID ?? new NetworkableId();
                IsMobile = HasRigidBody(entity);
            }
        }

        private class CustomMonumentComponent : FacepunchBehaviour
        {
            public static CustomMonumentComponent AddToMonument(CustomMonumentManager manager, CustomMonument monument)
            {
                var component = monument.Component.gameObject.AddComponent<CustomMonumentComponent>();
                component.Monument = monument;
                component._manager = manager;
                return component;
            }

            public CustomMonument Monument { get; private set; }
            private CustomMonumentManager _manager;

            private void OnDestroy()
            {
                _manager.Unregister(Monument);
            }
        }

        private class CustomMonumentManager
        {
            private readonly MonumentAddons _plugin;
            public readonly List<CustomMonument> MonumentList = new();

            public CustomMonumentManager(MonumentAddons plugin)
            {
                _plugin = plugin;
            }

            public void Register(CustomMonument monument)
            {
                if (FindByComponent(monument.Component) != null)
                    return;

                MonumentList.Add(monument);
            }

            public void Unregister(CustomMonument monument)
            {
                if (!MonumentList.Remove(monument))
                    return;

                _plugin._coroutineManager.StartCoroutine(KillRoutine(
                    _plugin._profileManager.GetEnabledAdaptersForMonument<BaseAdapter>(monument).ToList()));
            }

            public void UnregisterAllForPlugin(Plugin plugin)
            {
                if (MonumentList.Count == 0)
                    return;

                foreach (var monument in MonumentList.ToArray())
                {
                    if (monument.OwnerPlugin.Name != plugin.Name)
                        continue;

                    Unregister(monument);
                }
            }

            public CustomMonument FindByComponent(Component component)
            {
                foreach (var monument in MonumentList)
                {
                    if (monument.Component == component)
                        return monument;
                }

                return null;
            }

            public CustomMonument FindByPosition(Vector3 position)
            {
                foreach (var monument in MonumentList)
                {
                    if (monument.IsInBounds(position))
                        return monument;
                }

                return null;
            }

            public int CountMonumentByName(string name)
            {
                var count = 0;

                foreach (var monument in MonumentList)
                {
                    if (monument.UniqueName != name)
                        continue;

                    count++;
                }

                return count;
            }

            public List<BaseMonument> FindMonumentsByName(string name)
            {
                List<BaseMonument> matchingMonuments = null;

                foreach (var monument in MonumentList)
                {
                    if (monument.UniqueName != name)
                        continue;

                    matchingMonuments ??= new List<BaseMonument>();
                    matchingMonuments.Add(monument);
                }

                return matchingMonuments;
            }

            private IEnumerator KillRoutine(List<BaseAdapter> adapterList)
            {
                foreach (var adapter in adapterList)
                {
                    _plugin.TrackStart();
                    adapter.Kill();
                    _plugin.TrackEnd();
                    yield return adapter.WaitInstruction;
                }
            }
        }

        #endregion

        #region Undo Manager

        private abstract class BaseUndo
        {
            private const float ExpireAfterSeconds = 300;

            public virtual bool IsValid => !IsExpired && ProfileExists;

            protected readonly MonumentAddons _plugin;
            protected readonly ProfileController _profileController;
            protected readonly string _monumentIdentifier;
            private readonly float _undoTime;

            protected Profile Profile => _profileController.Profile;
            private bool IsExpired => _undoTime + ExpireAfterSeconds < UnityEngine.Time.realtimeSinceStartup;
            private bool ProfileExists => _plugin._profileStore.Exists(Profile.Name);

            protected BaseUndo(MonumentAddons plugin, ProfileController profileController, string monumentIdentifier)
            {
                _plugin = plugin;
                _undoTime = UnityEngine.Time.realtimeSinceStartup;
                _profileController = profileController;
                _monumentIdentifier = monumentIdentifier;
            }

            public abstract void Undo(BasePlayer player);
        }

        private class UndoKill : BaseUndo
        {
            protected readonly BaseData _data;

            public UndoKill(MonumentAddons plugin, ProfileController profileController, string monumentIdentifier, BaseData data)
                : base(plugin, profileController, monumentIdentifier)
            {
                _data = data;
            }

            public override void Undo(BasePlayer player)
            {
                Profile.AddData(_monumentIdentifier, _data);
                _plugin._profileStore.Save(Profile);

                if (_profileController.IsEnabled)
                {
                    var matchingMonuments = _plugin.GetMonumentsByIdentifier(_monumentIdentifier);
                    if (matchingMonuments?.Count > 0)
                    {
                        _profileController.SpawnNewData(_data, matchingMonuments);
                    }
                }

                var iPlayer = player.IPlayer;
                _plugin.ReplyToPlayer(iPlayer, LangEntry.UndoKillSuccess, _plugin.GetAddonName(iPlayer, _data), _monumentIdentifier, Profile.Name);
            }
        }

        private class UndoKillSpawnPoint : UndoKill
        {
            private readonly SpawnGroupData _spawnGroupData;
            private readonly SpawnPointData _spawnPointData;

            public UndoKillSpawnPoint(MonumentAddons plugin, ProfileController profileController, string monumentIdentifier, SpawnGroupData spawnGroupData, SpawnPointData spawnPointData)
                : base(plugin, profileController, monumentIdentifier, spawnGroupData)
            {
                _spawnGroupData = spawnGroupData;
                _spawnPointData = spawnPointData;
            }

            public override void Undo(BasePlayer player)
            {
                if (!Profile.HasSpawnGroup(_monumentIdentifier, _spawnGroupData.Id))
                {
                    base.Undo(player);
                    return;
                }

                _spawnGroupData.SpawnPoints.Add(_spawnPointData);
                _plugin._profileStore.Save(Profile);

                if (_profileController.IsEnabled)
                {
                    (_profileController.FindControllerById(_spawnGroupData.Id) as SpawnGroupController)?.CreateSpawnPoint(_spawnPointData);
                }

                var iPlayer = player.IPlayer;
                _plugin.ReplyToPlayer(iPlayer, LangEntry.UndoKillSuccess, _plugin.GetAddonName(iPlayer, _spawnPointData), _monumentIdentifier, Profile.Name);
            }
        }

        private class UndoManager
        {
            private static void CleanStack(Stack<BaseUndo> stack)
            {
                while (stack.TryPeek(out var undoAction) && !undoAction.IsValid)
                {
                    stack.Pop();
                }
            }

            private readonly Dictionary<ulong, Stack<BaseUndo>> _undoStackByPlayer = new Dictionary<ulong, Stack<BaseUndo>>();

            public bool TryUndo(BasePlayer player)
            {
                var undoStack = GetUndoStack(player);
                if (undoStack == null)
                    return false;

                if (!undoStack.TryPop(out var undoAction))
                    return false;

                undoAction.Undo(player);
                return true;
            }

            public void AddUndo(BasePlayer player, BaseUndo undoAction)
            {
                EnsureUndoStack(player).Push(undoAction);
            }

            private Stack<BaseUndo> EnsureUndoStack(BasePlayer player)
            {
                var undoStack = GetUndoStack(player);
                if (undoStack == null)
                {
                    undoStack = new Stack<BaseUndo>();
                    _undoStackByPlayer[player.userID] = undoStack;
                }

                return undoStack;
            }

            private Stack<BaseUndo> GetUndoStack(BasePlayer player)
            {
                if (!_undoStackByPlayer.TryGetValue(player.userID, out var stack))
                    return null;

                CleanStack(stack);
                return stack;
            }
        }

        #endregion

        #region Adapters/Controllers

        #region Addon Component

        private interface IAddonComponent
        {
            TransformAdapter Adapter { get; }
        }

        private class AddonComponent : FacepunchBehaviour, IAddonComponent
        {
            public static AddonComponent AddToComponent(AddonComponentTracker componentTracker, Component hostComponent, TransformAdapter adapter)
            {
                var component = hostComponent.gameObject.AddComponent<AddonComponent>();
                component.Adapter = adapter;
                component._componentTracker = componentTracker;
                component._hostComponent = hostComponent;

                componentTracker.RegisterComponent(hostComponent);

                if (hostComponent is BaseEntity entity && entity.GetParentEntity() is SphereEntity parentSphere)
                {
                    AddonComponent.AddToComponent(componentTracker, parentSphere, adapter);
                }

                return component;
            }

            public static void RemoveFromComponent(Component component)
            {
                DestroyImmediate(component.GetComponent<AddonComponent>());

                if (component is BaseEntity entity && entity.GetParentEntity() is SphereEntity parentSphere)
                {
                    RemoveFromComponent(parentSphere);
                }
            }

            public static AddonComponent GetForComponent(BaseEntity entity)
            {
                return entity.GetComponent<AddonComponent>();
            }

            public TransformAdapter Adapter { get; private set; }
            private Component _hostComponent;
            private AddonComponentTracker _componentTracker;

            private void OnDestroy()
            {
                _componentTracker.UnregisterComponent(_hostComponent);
                Adapter.OnComponentDestroyed(_hostComponent);
            }
        }

        private class AddonComponentTracker
        {
            private static bool IsComponentValid(Component component)
            {
                return component != null
                    && component is not BaseEntity { IsDestroyed: true };
            }

            private HashSet<Component> _trackedComponents = new();

            public void RegisterComponent(Component component)
            {
                _trackedComponents.Add(component);
            }

            public void UnregisterComponent(Component component)
            {
                _trackedComponents.Remove(component);
            }

            public bool IsAddonComponent(Component component)
            {
                return IsComponentValid(component) && _trackedComponents.Contains(component);
            }

            public bool IsAddonComponent<TAdapter, TController>(Component component, out TAdapter adapter, out TController controller)
                where TAdapter : BaseAdapter
                where TController : BaseController
            {
                adapter = null;
                controller = null;

                if (!IsAddonComponent(component))
                    return false;

                var addonComponent = component.GetComponent<IAddonComponent>();
                if (addonComponent == null)
                    return false;

                adapter = addonComponent.Adapter as TAdapter;
                controller = adapter?.Controller as TController;
                return controller != null;
            }

            public bool IsAddonComponent<TController>(Component component, out TController controller)
                where TController : BaseController
            {
                return IsAddonComponent<BaseAdapter, TController>(component, out _, out controller);
            }
        }

        #endregion

        #region Adapter/Controller - Base

        private interface IUpdateableController
        {
            Coroutine StartUpdateRoutine();
        }

        // Represents a single entity, spawn group, or spawn point at a single monument.
        private abstract class BaseAdapter
        {
            public abstract bool IsValid { get; }

            public BaseData Data { get; }
            public BaseController Controller { get; }
            public BaseMonument Monument { get; }

            public MonumentAddons Plugin => Controller.Plugin;
            public ProfileController ProfileController => Controller.ProfileController;
            public Profile Profile => Controller.Profile;

            protected Configuration _config => Plugin._config;
            protected ProfileStateData _profileStateData => Plugin._profileStateData;
            protected IOManager _ioManager => Plugin._ioManager;

            // Subclasses can override this to wait more than one frame for spawn/kill operations.
            public IEnumerator WaitInstruction { get; protected set; }

            protected BaseAdapter(BaseData data, BaseController controller, BaseMonument monument)
            {
                Data = data;
                Controller = controller;
                Monument = monument;
            }

            // Creates all GameObjects/Component that make up the addon.
            public abstract void Spawn();

            // Destroys all GameObjects/Components that make up the addon.
            public abstract void Kill();

            // Called when a component associated with the adapter is destroyed.
            public abstract void OnComponentDestroyed(Component component);

            // Detaches entities that should be saved/persisted across restarts/reloads.
            public virtual void DetachSavedEntities() {}

            // Called when the addon is scheduled to be killed or unregistered.
            public virtual void PreUnload() {}
        }

        // Represents a single entity or spawn point at a single monument.
        private abstract class TransformAdapter : BaseAdapter
        {
            public BaseTransformData TransformData { get; }

            public abstract Component Component { get; }
            public abstract Transform Transform { get; }
            public abstract Vector3 Position { get; }
            public abstract Quaternion Rotation { get; }

            public Vector3 LocalPosition => Monument.InverseTransformPoint(Position);
            public Quaternion LocalRotation => Quaternion.Inverse(Monument.Rotation) * Rotation;

            public Vector3 IntendedPosition
            {
                get
                {
                    var intendedPosition = Monument.TransformPoint(TransformData.Position);

                    if (TransformData.SnapToTerrain)
                        intendedPosition.y = TerrainMeta.HeightMap.GetHeight(intendedPosition);

                    return intendedPosition;
                }
            }

            public Quaternion IntendedRotation => Monument.Rotation * Quaternion.Euler(TransformData.RotationAngles);

            public virtual bool IsAtIntendedPosition => Position == IntendedPosition && Rotation == IntendedRotation;

            protected TransformAdapter(BaseTransformData transformData, BaseController controller, BaseMonument monument) : base(transformData, controller, monument)
            {
                TransformData = transformData;
            }

            public virtual bool TryRecordUpdates(Transform moveTransform = null, Transform rotateTransform = null)
            {
                if (IsAtIntendedPosition)
                    return false;

                TransformData.Position = LocalPosition;
                TransformData.RotationAngles = LocalRotation.eulerAngles;
                TransformData.SnapToTerrain = IsOnTerrain(Position);
                return true;
            }
        }

        // Represents an entity or spawn point across one or more identical monuments.
        private abstract class BaseController
        {
            public ProfileController ProfileController { get; }
            public BaseData Data { get; }
            public List<BaseAdapter> Adapters { get; } = new List<BaseAdapter>();

            public MonumentAddons Plugin => ProfileController.Plugin;
            public Profile Profile => ProfileController.Profile;

            private bool _enabled = true;

            protected BaseController(ProfileController profileController, BaseData data)
            {
                ProfileController = profileController;
                Data = data;
            }

            public abstract BaseAdapter CreateAdapter(BaseMonument monument);

            public virtual void OnAdapterSpawned(BaseAdapter adapter) {}

            public virtual void OnAdapterKilled(BaseAdapter adapter)
            {
                Adapters.Remove(adapter);

                if (Adapters.Count == 0)
                {
                    ProfileController.OnControllerKilled(this);
                }
            }

            public virtual BaseAdapter SpawnAtMonument(BaseMonument monument)
            {
                var adapter = CreateAdapter(monument);
                Adapters.Add(adapter);
                adapter.Spawn();
                OnAdapterSpawned(adapter);
                return adapter;
            }

            public virtual IEnumerator SpawnAtMonumentsRoutine(IEnumerable<BaseMonument> monumentList)
            {
                foreach (var monument in monumentList)
                {
                    if (!_enabled)
                        yield break;

                    if (!monument.IsValid)
                        continue;

                    BaseAdapter adapter = null;
                    Plugin.TrackStart();
                    try
                    {
                        adapter = SpawnAtMonument(monument);
                    }
                    catch (Exception ex)
                    {
                        LogError($"Caught exception when spawning addon {Data.Id}.\n{ex}");
                    }

                    Plugin.TrackEnd();
                    yield return adapter?.WaitInstruction;
                }
            }

            // Subclasses can override this if they need to kill child data (e.g., spawn point data).
            public virtual Coroutine Kill(BaseData data)
            {
                PreUnload();

                Coroutine coroutine = null;

                if (Adapters.Count > 0)
                {
                    coroutine = CoroutineManager.StartGlobalCoroutine(KillRoutine());
                }

                ProfileController.OnControllerKilled(this);
                return coroutine;
            }

            public bool HasAdapterForMonument(BaseMonument monument)
            {
                foreach (var adapter in Adapters)
                {
                    if (adapter.Monument.IsEquivalentTo(monument))
                        return true;
                }

                return false;
            }

            public Coroutine Kill()
            {
                return Kill(Data);
            }

            public void PreUnload()
            {
                // Stop the controller from spawning more adapters.
                _enabled = false;

                for (var i = Adapters.Count - 1; i >= 0; i--)
                {
                    Adapters[i].PreUnload();
                }
            }

            public IEnumerator KillRoutine()
            {
                for (var i = Adapters.Count - 1; i >= 0; i--)
                {
                    Plugin.TrackStart();
                    var adapter = Adapters[i];
                    adapter.Kill();
                    Plugin.TrackEnd();
                    yield return adapter.WaitInstruction;
                }
            }

            public void DetachSavedEntities()
            {
                for (var i = Adapters.Count - 1; i >= 0; i--)
                {
                    Plugin.TrackStart();
                    Adapters[i].DetachSavedEntities();
                    Plugin.TrackEnd();
                }
            }

            public BaseAdapter FindAdapterForMonument(BaseMonument monument)
            {
                foreach (var adapter in Adapters)
                {
                    if (adapter.Monument.IsEquivalentTo(monument))
                        return adapter;
                }

                return null;
            }
        }

        #endregion

        #region Adapter/Controller - Prefab

        private class PrefabAdapter : TransformAdapter
        {
            public GameObject GameObject { get; private set; }
            public PrefabData PrefabData { get; }
            public override Component Component => _transform;
            public override Transform Transform => _transform;
            public override Vector3 Position => Transform.position;
            public override Quaternion Rotation => Transform.rotation;
            public override bool IsValid => GameObject != null;
            private Transform _transform;

            public PrefabAdapter(BaseController controller, PrefabData prefabData, BaseMonument monument)
                : base(prefabData, controller, monument)
            {
                PrefabData = prefabData;
            }

            public override void Spawn()
            {
                GameObject = GameManager.server.CreatePrefab(PrefabData.PrefabName, IntendedPosition, IntendedRotation);
                _transform = GameObject.transform;
                AddonComponent.AddToComponent(Plugin._componentTracker, _transform, this);
                ExposedHooks.OnMonumentPrefabCreated(GameObject, Monument.Object, Data.Id);
            }

            public override void Kill()
            {
                UnityEngine.Object.Destroy(GameObject);
            }

            public void HandleChanges()
            {
                if (IsAtIntendedPosition)
                    return;

                Transform.SetPositionAndRotation(IntendedPosition, IntendedRotation);
            }

            public override void OnComponentDestroyed(Component component)
            {
                Controller.OnAdapterKilled(this);
            }
        }

        private class PrefabController : BaseController, IUpdateableController
        {
            public PrefabData PrefabData { get; }

            public PrefabController(ProfileController profileController, PrefabData prefabData)
                : base(profileController, prefabData)
            {
                PrefabData = prefabData;
            }

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new PrefabAdapter(this, PrefabData, monument);
            }

            public Coroutine StartUpdateRoutine()
            {
                return ProfileController.StartCoroutine(UpdateRoutine());
            }

            private IEnumerator UpdateRoutine()
            {
                foreach (var adapter in Adapters.ToList())
                {
                    var prefabAdapter = adapter as PrefabAdapter;
                    if (prefabAdapter is not { IsValid: true })
                        continue;

                    prefabAdapter.HandleChanges();
                    yield return null;
                }
            }
        }

        #endregion

        #region Entity Adapter/Controller

        private class EntityAdapter : TransformAdapter
        {
            private class IOEntityOverrideInfo
            {
                public Dictionary<int, Vector3> Inputs = new Dictionary<int, Vector3>();
                public Dictionary<int, Vector3> Outputs = new Dictionary<int, Vector3>();
            }

            private static readonly Dictionary<string, IOEntityOverrideInfo> IOOverridesByEntity = new Dictionary<string, IOEntityOverrideInfo>
            {
                ["assets/prefabs/io/electric/switches/doormanipulator.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 0.9f, 0),
                        [1] = new Vector3(0, 0.85f, 0),
                    },
                },
                ["assets/prefabs/io/electric/switches/simpleswitch/simpleswitch.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 0.78f, 0.03f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.22f, 0.03f),
                    },
                },
                ["assets/prefabs/io/electric/switches/timerswitch.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 0.795f, 0.03f),
                        [1] = new Vector3(-0.15f, 1.04f, 0.03f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.295f, 0.025f),
                    },
                },
                ["assets/prefabs/io/electric/switches/orswitch.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.035f, 0.82f, -0.125f),
                        [1] = new Vector3(-0.035f, 0.82f, -0.175f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [1] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [2] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [3] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [4] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [5] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [6] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [7] = new Vector3(-0.035f, 1.3f, -0.15f),
                    },
                },
                ["assets/prefabs/io/electric/switches/andswitch.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.035f, 0.82f, -0.125f),
                        [1] = new Vector3(-0.035f, 0.82f, -0.175f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [1] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [2] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [3] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [4] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [5] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [6] = new Vector3(-0.035f, 1.3f, -0.15f),
                        [7] = new Vector3(-0.035f, 1.3f, -0.15f),
                    },
                },
                ["assets/prefabs/io/electric/switches/cardreader.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.014f, 1.18f, 0.03f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.014f, 1.55f, 0.03f),
                    },
                },
                ["assets/prefabs/io/electric/switches/pressbutton/pressbutton.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.1f, 0.025f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.38f, 0.025f),
                    },
                },
                ["assets/prefabs/io/kinetic/wheelswitch.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.1f, 0, 0),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0.1f, 0, 0),
                    },
                },
                ["assets/content/structures/interactive_garage_door/sliding_blast_door.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0.1f, 0, 0),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.1f, 0, 0),
                    },
                },
                ["assets/prefabs/io/electric/switches/fusebox/fusebox.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.06f, 0.06f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 1.565f, 0.06f),
                        [1] = new Vector3(0, 1.565f, 0.06f),
                        [2] = new Vector3(0, 1.565f, 0.06f),
                        [3] = new Vector3(0, 1.565f, 0.06f),
                        [4] = new Vector3(0, 1.565f, 0.06f),
                        [5] = new Vector3(0, 1.565f, 0.06f),
                        [6] = new Vector3(0, 1.565f, 0.06f),
                        [7] = new Vector3(0, 1.565f, 0.06f),
                    },
                },
                ["assets/prefabs/io/electric/generators/generator.static.prefab"] = new IOEntityOverrideInfo
                {
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(0, 0.75f, -0.5f),
                        [1] = new Vector3(0, 0.75f, -0.3f),
                        [2] = new Vector3(0, 0.75f, -0.1f),
                        [3] = new Vector3(0, 0.75f, 0.1f),
                        [4] = new Vector3(0, 0.75f, 0.3f),
                        [5] = new Vector3(0, 0.75f, 0.5f),
                    },
                },
                ["assets/prefabs/io/electric/switches/splitter.prefab"] = new IOEntityOverrideInfo
                {
                    Inputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.03f, 1.44f, 0f),
                    },
                    Outputs = new Dictionary<int, Vector3>
                    {
                        [0] = new Vector3(-0.03f, 0.8f,0.108f),
                        [1] = new Vector3(-0.03f, 0.8f, 0),
                        [2] = new Vector3(-0.03f, 0.8f, -0.112f),
                    },
                },
            };

            public BaseEntity Entity { get; private set; }
            public EntityData EntityData { get; }
            public virtual bool IsDestroyed => Entity == null || Entity.IsDestroyed;
            public override Component Component => Entity;
            public override Transform Transform => _transform;
            public override Vector3 Position => Transform.position;
            public override Quaternion Rotation => Transform.rotation;
            public override bool IsValid => !IsDestroyed;

            private Transform _transform;
            private PuzzleResetHandler _puzzleResetHandler;

            private BuildingGrade.Enum IntendedBuildingGrade
            {
                get
                {
                    var buildingBlock = Entity as BuildingBlock;
                    var desiredGrade = EntityData.BuildingBlock?.Grade;

                    return desiredGrade != null && desiredGrade != BuildingGrade.Enum.None
                        ? desiredGrade.Value
                        : buildingBlock.blockDefinition.defaultGrade.gradeBase.type;
                }
            }

            public EntityAdapter(BaseController controller, EntityData entityData, BaseMonument monument)
                : base(entityData, controller, monument)
            {
                EntityData = entityData;
            }

            public override void Spawn()
            {
                var existingEntity = _profileStateData.FindEntity(Profile.Name, Monument, Data.Id);
                var foundDuplicateEntity = FindAndCleanupDuplicateEntities(existingEntity);
                if (foundDuplicateEntity != null)
                {
                    existingEntity = foundDuplicateEntity;
                }

                if (existingEntity != null)
                {
                    FindAndCleanupDuplicateEntities(existingEntity);

                    if (existingEntity.PrefabName != EntityData.PrefabName)
                    {
                        existingEntity.Kill();
                    }
                    else
                    {
                        Entity = existingEntity;
                        _transform = Entity.transform;

                        PreEntitySpawn();
                        PostEntitySpawn();
                        HandleChanges();
                        AddonComponent.AddToComponent(Plugin._componentTracker, Entity, this);

                        var vendingMachine = Entity as NPCVendingMachine;
                        if (vendingMachine != null)
                        {
                            Plugin.RefreshVendingProfile(vendingMachine);
                        }

                        var mountable = Entity as BaseMountable;
                        if (mountable != null)
                        {
                            if (Monument is IEntityMonument { IsMobile: true })
                            {
                                mountable.isMobile = true;
                                if (!BaseMountable.AllMountables.Contains(mountable))
                                {
                                    BaseMountable.AllMountables.Add(mountable);
                                }
                            }
                        }

                        ExposedHooks.OnMonumentEntitySpawned(Entity, Monument.Object, Data.Id);

                        if (!ShouldEnableSaving(Entity))
                        {
                            // If saving is no longer enabled, remove the entity from the data file.
                            // This prevents a bug where a subsequent reload would discover the entity before it is destroyed.
                            _profileStateData.RemoveEntity(Profile.Name, Monument, Data.Id);
                            Plugin._saveProfileStateDebounced.Schedule();
                        }

                        return;
                    }
                }

                Entity = CreateEntity(IntendedPosition, IntendedRotation);
                _transform = Entity.transform;

                PreEntitySpawn();
                Entity.Spawn();
                PostEntitySpawn();
                ExposedHooks.OnMonumentEntitySpawned(Entity, Monument.Object, Data.Id);

                if (ShouldEnableSaving(Entity) && Entity != existingEntity)
                {
                    _profileStateData.AddEntity(Profile.Name, Monument, Data.Id, Entity.net.ID);
                    Plugin._saveProfileStateDebounced.Schedule();
                }
            }

            public override void Kill()
            {
                if (IsDestroyed)
                    return;

                PreEntityKill();
                Entity.Kill();
            }

            public override void OnComponentDestroyed(Component component)
            {
                Plugin.TrackStart();

                // Only consider the adapter destroyed if the main entity was destroyed.
                // For example, the scaled sphere parent may be killed if resized to default scale.
                if (component == Entity)
                {
                    // Only remove the state record of the entity if it's actually destroyed.
                    // If saving is enabled, the component may have been detached and called this method.
                    if (Entity == null || Entity.IsDestroyed)
                    {
                        if (_profileStateData.RemoveEntity(Profile.Name, Monument, Data.Id))
                        {
                            Plugin._saveProfileStateDebounced.Schedule();
                        }
                    }

                    Controller.OnAdapterKilled(this);
                }

                Plugin.TrackEnd();
            }

            public void UpdateScale()
            {
                if (Plugin.TryScaleEntity(Entity, EntityData.Scale))
                {
                    var parentSphere = Entity.GetParentEntity() as SphereEntity;
                    if (parentSphere == null)
                        return;

                    if (Plugin._componentTracker.IsAddonComponent(parentSphere))
                        return;

                    AddonComponent.AddToComponent(Plugin._componentTracker, parentSphere, this);
                }
            }

            public void UpdateSkin()
            {
                if (Entity.skinID == EntityData.Skin
                    || EntityData.Skin == 0 && Entity is NPCVendingMachine)
                    return;

                Entity.skinID = EntityData.Skin;

                if (Entity.IsFullySpawned())
                {
                    Entity.SendNetworkUpdate();
                }
            }

            public override bool TryRecordUpdates(Transform moveTransform = null, Transform rotateTransform = null)
            {
                var hasChanged = base.TryRecordUpdates(moveTransform, rotateTransform);

                var buildingBlock = Entity as BuildingBlock;
                if (buildingBlock != null && buildingBlock.grade != IntendedBuildingGrade)
                {
                    EntityData.BuildingBlock ??= new BuildingBlockInfo();
                    EntityData.BuildingBlock.Grade = buildingBlock.grade;
                    hasChanged = true;
                }

                if (hasChanged)
                {
                    var singleEntityController = Controller as EntityController;
                    singleEntityController.StartUpdateRoutine();
                    Plugin._profileStore.Save(singleEntityController.Profile);
                }

                return hasChanged;
            }

            public virtual void HandleChanges()
            {
                DisableFlags();
                UpdatePosition();
                UpdateSkin();
                UpdateScale();
                UpdateBuildingGrade();
                UpdateSkullName();
                UpdateHuntingTrophy();
                UpdatePuzzle();
                UpdateCardReaderLevel();
                UpdateIOConnections();
                MaybeProvidePower();
                EnableFlags();
            }

            public void UpdateSkullName()
            {
                var skullName = EntityData.SkullName;
                if (skullName == null)
                    return;

                var skullTrophy = Entity as SkullTrophyGlobal;
                if (skullTrophy == null)
                    return;

                if (skullTrophy.inventory == null)
                    return;

                if (skullTrophy.inventory.itemList.Count == 1)
                {
                    var item = skullTrophy.inventory.itemList[0];
                    item.RemoveFromContainer();
                    item.Remove();
                }

                var skullItem = ItemManager.CreateByPartialName("skull.human");
                skullItem.name = HumanBodyResourceDispenser.CreateSkullName(skullName);
                if (!skullItem.MoveToContainer(skullTrophy.inventory))
                {
                    skullItem.Remove();
                }

                // Setting flag here so vanilla functionality is preserved for trophies without name set
                skullTrophy.SetFlag(BaseEntity.Flags.Busy, true);
            }

            public void UpdateHuntingTrophy()
            {
                var headData = EntityData.HeadData;
                if (headData == null)
                    return;

                var huntingTrophy = Entity as HuntingTrophy;
                if (huntingTrophy == null)
                    return;

                headData.ApplyToHuntingTrophy(huntingTrophy);
                huntingTrophy.SendNetworkUpdate();

                // Setting flag here so vanilla functionality is preserved for trophies without head set
                huntingTrophy.SetFlag(BaseEntity.Flags.Busy, true);
            }

            public void UpdateIOConnections()
            {
                var ioEntityData = EntityData.IOEntityData;
                if (ioEntityData == null)
                    return;

                var ioEntity = Entity as IOEntity;
                if (ioEntity == null)
                    return;

                var hasChanged = false;

                for (var outputSlotIndex = 0; outputSlotIndex < ioEntity.outputs.Length; outputSlotIndex++)
                {
                    var sourceSlot = ioEntity.outputs[outputSlotIndex];
                    var destinationEntity = sourceSlot.connectedTo.Get();
                    var destinationSlot = destinationEntity?.inputs.ElementAtOrDefault(sourceSlot.connectedToSlot);

                    var connectionData = ioEntityData.FindConnection(outputSlotIndex);
                    if (connectionData != null)
                    {
                        var intendedDestinationEntity = Controller.ProfileController.FindEntity<IOEntity>(connectionData.ConnectedToId, Monument);
                        var intendedDestinationSlot = intendedDestinationEntity?.inputs.ElementAtOrDefault(connectionData.ConnectedToSlot);

                        if (destinationSlot != intendedDestinationSlot)
                        {
                            // Existing destination entity or slot is incorrect.
                            if (destinationSlot != null)
                            {
                                ClearIOSlot(destinationEntity, destinationSlot);
                            }

                            destinationEntity = intendedDestinationEntity;
                            destinationSlot = intendedDestinationSlot;

                            sourceSlot.Clear();
                            hasChanged = true;
                        }

                        if (destinationEntity == null)
                        {
                            // The destination entity cannot be found. Maybe it was destroyed.
                            continue;
                        }

                        if (destinationSlot == null)
                        {
                            // The destination slot cannot be found. Maybe the index was out of range (bad data).
                            continue;
                        }

                        SetupIOSlot(sourceSlot, destinationEntity, connectionData.ConnectedToSlot, connectionData.Color);

                        if (connectionData.ShowWire)
                        {
                            if (sourceSlot.type != IOType.Kinetic && destinationSlot.type != IOType.Kinetic)
                            {
                                var numPoints = connectionData.Points?.Length ?? 0;

                                sourceSlot.linePoints = new Vector3[numPoints + 2];
                                sourceSlot.linePoints[0] = sourceSlot.handlePosition;
                                sourceSlot.linePoints[numPoints + 1] = Transform.InverseTransformPoint(destinationEntity.transform.TransformPoint(destinationSlot.handlePosition));

                                for (var pointIndex = 0; pointIndex < numPoints; pointIndex++)
                                {
                                    sourceSlot.linePoints[pointIndex + 1] = Transform.InverseTransformPoint(Monument.TransformPoint(connectionData.Points[pointIndex]));
                                }
                            }
                        }
                        else
                        {
                            sourceSlot.linePoints = Array.Empty<Vector3>();
                        }

                        SetupIOSlot(destinationSlot, ioEntity, connectionData.Slot, connectionData.Color);
                        destinationEntity.SendNetworkUpdate();

                        continue;
                    }

                    if (destinationSlot != null)
                    {
                        // No connection data saved, so clear existing connection.
                        ClearIOSlot(destinationEntity, destinationSlot);

                        sourceSlot.Clear();
                        hasChanged = true;
                    }
                }

                if (hasChanged)
                {
                    ioEntity.MarkDirtyForceUpdateOutputs();
                    ioEntity.SendNetworkUpdate();
                    ioEntity.SendChangedToRoot(forceUpdate: true);
                }
            }

            public void MaybeProvidePower()
            {
                var ioEntity = Entity as IOEntity;
                if ((object)ioEntity == null)
                    return;

                _ioManager.MaybeProvidePower(ioEntity);
            }

            public override void PreUnload()
            {
                if (_puzzleResetHandler != null)
                {
                    _puzzleResetHandler.Destroy();
                }

                var targetDoor = (Entity as DoorManipulator)?.targetDoor;
                if (targetDoor != null)
                {
                    targetDoor.SetFlag(BaseEntity.Flags.Locked, false);
                }
            }

            public void HandlePuzzleReset()
            {
                var spawnGroupIdList = EntityData.Puzzle?.SpawnGroupIds;
                if (spawnGroupIdList == null)
                    return;

                foreach (var spawnGroupId in spawnGroupIdList)
                {
                    (ProfileController.FindAdapter(spawnGroupId, Monument) as SpawnGroupAdapter)?.SpawnGroup.OnPuzzleReset();
                }
            }

            protected virtual void PreEntitySpawn()
            {
                UpdateSkin();
                UpdateCardReaderLevel();

                EntitySetupUtils.PreSpawnShared(Entity);

                var buildingBlock = Entity as BuildingBlock;
                if (buildingBlock != null)
                {
                    buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
                    if (buildingBlock.blockDefinition != null)
                    {
                        buildingBlock.SetGrade(IntendedBuildingGrade);

                        var maxHealth = buildingBlock.currentGrade.maxHealth;
                        buildingBlock.InitializeHealth(maxHealth, maxHealth);
                        buildingBlock.ResetLifeStateOnSpawn = false;
                    }
                }

                var ioEntity = Entity as IOEntity;
                if (ioEntity != null)
                {
                    UpdateIOEntitySlotPositions(ioEntity);
                }
            }

            protected virtual void PostEntitySpawn()
            {
                EntitySetupUtils.PostSpawnShared(Plugin, Entity, ShouldEnableSaving(Entity));

                UpdatePuzzle();
                DisableFlags();

                // NPCVendingMachine needs its skin updated after spawn because vanilla sets it to 861142659.
                UpdateSkin();

                var computerStation = Entity as ComputerStation;
                if (computerStation != null && computerStation.isStatic)
                {
                    var computerStation2 = computerStation;
                    computerStation.CancelInvoke(computerStation.GatherStaticCameras);
                    computerStation.Invoke(() =>
                    {
                        Plugin.TrackStart();
                        GatherStaticCameras(computerStation2);
                        Plugin.TrackEnd();
                    }, 1);
                }

                var paddlingPool = Entity as PaddlingPool;
                if (paddlingPool != null)
                {
                    paddlingPool.inventory.AddItem(Plugin._waterDefinition, paddlingPool.inventory.maxStackSize);

                    // Disallow adding or removing water.
                    paddlingPool.SetFlag(BaseEntity.Flags.Busy, true);
                }

                var vehicleSpawner = Entity as VehicleSpawner;
                if (vehicleSpawner != null)
                {
                    var vehicleSpawner2 = vehicleSpawner;
                    vehicleSpawner.Invoke(() =>
                    {
                        Plugin.TrackStart();
                        EntityUtils.ConnectNearbyVehicleVendor(vehicleSpawner2);
                        Plugin.TrackEnd();
                    }, 1);
                }

                var vehicleVendor = Entity as VehicleVendor;
                if (vehicleVendor != null)
                {
                    // Use a slightly longer delay than the vendor check since this can short-circuit as an optimization.
                    var vehicleVendor2 = vehicleVendor;
                    vehicleVendor.Invoke(() =>
                    {
                        Plugin.TrackStart();
                        EntityUtils.ConnectNearbyVehicleSpawner(vehicleVendor2);
                        Plugin.TrackEnd();
                    }, 2);
                }

                var candle = Entity as Candle;
                if (candle != null)
                {
                    candle.SetFlag(BaseEntity.Flags.On, true);
                    candle.CancelInvoke(candle.Burn);

                    // Disallow extinguishing.
                    candle.SetFlag(BaseEntity.Flags.Busy, true);
                }

                var fogMachine = Entity as FogMachine;
                if (fogMachine != null)
                {
                    var fogMachine2 = fogMachine;
                    fogMachine.SetFlag(BaseEntity.Flags.On, true);
                    fogMachine.InvokeRepeating(() =>
                    {
                        fogMachine2.SetFlag(FogMachine.Emitting, true);
                        fogMachine2.Invoke(fogMachine2.EnableFogField, 1f);
                        fogMachine2.Invoke(fogMachine2.DisableNozzle, fogMachine2.nozzleBlastDuration);
                        fogMachine2.Invoke(fogMachine2.FinishFogging, fogMachine2.fogLength);
                    },
                    UnityEngine.Random.Range(0f, 5f),
                    fogMachine.fogLength - 1);

                    // Disallow interaction.
                    fogMachine.SetFlag(BaseEntity.Flags.Busy, true);
                }

                var oven = Entity as BaseOven;
                if (oven != null)
                {
                    // Lanterns
                    if (oven is BaseFuelLightSource)
                    {
                        oven.SetFlag(BaseEntity.Flags.On, true);
                        oven.SetFlag(BaseEntity.Flags.Busy, true);
                    }

                    // jackolantern.angry or jackolantern.happy
                    else if (oven.prefabID == 1889323056 || oven.prefabID == 630866573)
                    {
                        oven.SetFlag(BaseEntity.Flags.On, true);
                        oven.SetFlag(BaseEntity.Flags.Busy, true);
                    }
                }

                var spooker = Entity as SpookySpeaker;
                if (spooker != null)
                {
                    spooker.SetFlag(BaseEntity.Flags.On, true);
                    spooker.InvokeRandomized(
                        spooker.SendPlaySound,
                        spooker.soundSpacing,
                        spooker.soundSpacing,
                        spooker.soundSpacingRand);

                    spooker.SetFlag(BaseEntity.Flags.Busy, true);
                }

                var door = Entity as Door;
                if (door != null)
                {
                    door.canTakeLock = false;
                }

                var doorManipulator = Entity as DoorManipulator;
                if (doorManipulator != null)
                {
                    if (doorManipulator.targetDoor != null)
                    {
                        doorManipulator.targetDoor.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                    else
                    {
                        var doorManipulator2 = doorManipulator;
                        doorManipulator.Invoke(() =>
                        {
                            Plugin.TrackStart();
                            EntityUtils.ConnectNearbyDoor(doorManipulator2);
                            Plugin.TrackEnd();
                        }, 1);
                    }
                }

                var spray = Entity as SprayCanSpray;
                if (spray != null)
                {
                    spray.CancelInvoke(spray.RainCheck);
                    #if !CARBON
                    spray.splashThreshold = int.MaxValue;
                    #endif
                }

                var telephone = Entity as Telephone;
                if (telephone != null && telephone.prefabID == 1009655496)
                {
                    PhoneUtils.NameTelephone(telephone, Monument, Position, Plugin._monumentHelper);
                }

                var microphoneStand = Entity as MicrophoneStand;
                if ((object)microphoneStand != null)
                {
                    var microphoneStand2 = microphoneStand;
                    microphoneStand.Invoke(() =>
                    {
                        Plugin.TrackStart();
                        microphoneStand2.PostMapEntitySpawn();
                        Plugin.TrackEnd();
                    }, 1);
                }

                var storageContainer = Entity as StorageContainer;
                if ((object)storageContainer != null)
                {
                    storageContainer.isLockable = false;
                    storageContainer.isMonitorable = false;
                }

                var christmasTree = Entity as ChristmasTree;
                if ((object)christmasTree != null)
                {
                    foreach (var itemShortName in _config.XmasTreeDecorations)
                    {
                        var item = ItemManager.CreateByName(itemShortName);
                        if (item == null)
                            continue;

                        if (!item.MoveToContainer(christmasTree.inventory))
                        {
                            item.Remove();
                        }
                    }

                    christmasTree.inventory.SetLocked(true);
                }

                if (EntityData.Scale != 1 || Entity.GetParentEntity() is SphereEntity)
                {
                    UpdateScale();
                }

                var skullTrophy = Entity as SkullTrophyGlobal;
                if (skullTrophy != null)
                {
                    UpdateSkullName();
                }

                var huntingTrophy = Entity as HuntingTrophy;
                if (huntingTrophy != null)
                {
                    UpdateHuntingTrophy();
                }

                EnableFlags();
            }

            protected virtual void PreEntityKill() {}

            public override void DetachSavedEntities()
            {
                if (IsDestroyed)
                    return;

                // Only unregister the adapter if it has saving enabled.
                if (!ShouldEnableSaving(Entity))
                    return;

                // Don't unregister the entity if the profile no longer declares it.
                // Entity should be killed along with the adapter.
                if (!Profile.HasEntity(Monument.UniqueName, EntityData))
                    return;

                // Don't unregister the entity if it's not tracked in the profile state.
                // Entity should be killed along with the adapter.
                if (!_profileStateData.HasEntity(Profile.Name, Monument, Data.Id, Entity.net.ID))
                    return;

                // Unregister the adapter to prevent the entity from being killed when the adapter is killed.
                // The primary use case is to persist the entity while the plugin is unloaded.
                AddonComponent.RemoveFromComponent(Entity);
            }

            protected BaseEntity CreateEntity(Vector3 position, Quaternion rotation)
            {
                var entity = GameManager.server.CreateEntity(EntityData.PrefabName, position, rotation);
                if (entity == null)
                    return null;

                EnableSavingRecursive(entity, enableSaving: ShouldEnableSaving(entity));

                if (Monument is IEntityMonument entityMonument)
                {
                    entity.SetParent(entityMonument.RootEntity, worldPositionStays: true);

                    if (entityMonument.IsMobile)
                    {
                        var mountable = entity as BaseMountable;
                        if (mountable != null)
                        {
                            // Setting isMobile prior to spawn will automatically update the position of mounted players.
                            mountable.isMobile = true;
                        }
                    }
                }

                AddonComponent.AddToComponent(Plugin._componentTracker, entity, this);

                return entity;
            }

            private bool ShouldEnableSaving(BaseEntity entity)
            {
                return _config.EntitySaveSettings.ShouldEnableSaving(entity);
            }

            private void UpdatePosition()
            {
                if (IsAtIntendedPosition)
                    return;

                var entityToMove = GetEntityToMove();
                var entityToRotate = Entity;

                entityToMove.transform.position = IntendedPosition;

                var intendedRotation = IntendedRotation;
                entityToRotate.transform.rotation = intendedRotation;
                if (entityToRotate is BasePlayer playerToRotate)
                {
                    playerToRotate.viewAngles = intendedRotation.eulerAngles;

                    if (playerToRotate is NPCShopKeeper shopKeeper)
                    {
                        shopKeeper.initialFacingDir = intendedRotation * Vector3.forward;
                    }
                }

                BroadcastEntityTransformChange(entityToMove);

                if (entityToRotate != entityToMove)
                {
                    BroadcastEntityTransformChange(entityToRotate);
                }
            }

            private BaseEntity FindAndCleanupDuplicateEntities(BaseEntity ignoreEntity = null)
            {
                var intendedPosition = IntendedPosition;
                var entityBuffer = Plugin._entityBuffer;
                var keepOne = ignoreEntity == null;

                var numFound = BaseEntity.Query.Server.GetInSphereFast(intendedPosition, 0.1f, entityBuffer, entity =>
                {
                    if (entity == null || entity.IsDestroyed)
                        return false;

                    if (entity == ignoreEntity)
                        return false;

                    if (!entity.enableSaving)
                        return false;

                    if (entity.PrefabName != EntityData.PrefabName)
                        return false;

                    var transform = entity.transform;
                    if (transform.position != intendedPosition)
                        return false;

                    return true;
                });

                if (numFound == 0)
                    return null;

                for (var i = keepOne ? 1 : 0; i < numFound; i++)
                {
                    var entity = entityBuffer[i];
                    entity.Kill();
                    LogWarning($"Found and killed likely duplicate entity [{entity.ShortPrefabName}] at {intendedPosition}");
                }

                return keepOne ? entityBuffer[0] : null;
            }

            private List<CCTV_RC> GetNearbyStaticCameras()
            {
                if (Monument is IEntityMonument { IsMobile: true } entityMonument
                    && entityMonument.RootEntity == Entity.GetParentEntity())
                {
                    var cargoCameraList = new List<CCTV_RC>();
                    foreach (var child in entityMonument.RootEntity.children)
                    {
                        var cctv = child as CCTV_RC;
                        if (cctv != null && cctv.isStatic)
                        {
                            cargoCameraList.Add(cctv);
                        }
                    }

                    return cargoCameraList;
                }

                var entityList = new List<BaseEntity>();
                Vis.Entities(Entity.transform.position, 100, entityList, Rust.Layers.Mask.Deployed, QueryTriggerInteraction.Ignore);
                if (entityList.Count == 0)
                    return null;

                var cameraList = new List<CCTV_RC>();
                foreach (var entity in entityList)
                {
                    var cctv = entity as CCTV_RC;
                    if (cctv != null && !cctv.IsDestroyed && cctv.isStatic)
                    {
                        cameraList.Add(cctv);
                    }
                }

                return cameraList;
            }

            private void GatherStaticCameras(ComputerStation computerStation)
            {
                var cameraList = GetNearbyStaticCameras();
                if (cameraList == null)
                    return;

                foreach (var cctv in cameraList)
                {
                    computerStation.ForceAddBookmark(cctv.rcIdentifier);
                }
            }

            private BaseEntity GetEntityToMove()
            {
                if (EntityData.Scale != 1 && Plugin.GetEntityScale(Entity) != 1)
                {
                    var parentSphere = Entity.GetParentEntity() as SphereEntity;
                    if (parentSphere != null)
                        return parentSphere;
                }

                return Entity;
            }

            private void UpdateBuildingGrade()
            {
                var buildingBlock = Entity as BuildingBlock;
                if (buildingBlock == null)
                    return;

                var intendedBuildingGrade = IntendedBuildingGrade;
                if (buildingBlock.grade == intendedBuildingGrade)
                    return;

                buildingBlock.SetGrade(intendedBuildingGrade);
                buildingBlock.SetHealthToMax();
                buildingBlock.SendNetworkUpdate();
                buildingBlock.baseProtection = Plugin._immortalProtection;
            }

            private void UpdatePuzzle()
            {
                if (EntityData.Puzzle == null)
                    return;

                var puzzleReset = (Entity as IOEntity)?.GetComponent<PuzzleReset>();
                if (puzzleReset == null)
                    return;

                puzzleReset.playersBlockReset = EntityData.Puzzle.PlayersBlockReset;
                puzzleReset.playerDetectionRadius = EntityData.Puzzle.PlayerDetectionRadius;
                puzzleReset.timeBetweenResets = EntityData.Puzzle.SecondsBetweenResets;

                if (EntityData.Puzzle.SpawnGroupIds?.Count > 0)
                {
                    if (_puzzleResetHandler == null)
                    {
                        _puzzleResetHandler = PuzzleResetHandler.Create(this, puzzleReset);
                    }
                }
            }

            private void UpdateCardReaderLevel()
            {
                var cardReader = Entity as CardReader;
                if ((object)cardReader == null)
                    return;

                var accessLevel = EntityData.CardReaderLevel;
                if (EntityData.CardReaderLevel == 0 || accessLevel == cardReader.accessLevel)
                    return;

                cardReader.accessLevel = accessLevel;
                cardReader.SetFlag(cardReader.AccessLevel1, accessLevel == 1);
                cardReader.SetFlag(cardReader.AccessLevel2, accessLevel == 2);
                cardReader.SetFlag(cardReader.AccessLevel3, accessLevel == 3);
            }

            private void DisableFlags()
            {
                Entity.SetFlag(EntityData.DisabledFlags, false);
            }

            private void EnableFlags()
            {
                Entity.SetFlag(EntityData.EnabledFlags, true);
            }

            private void UpdateIOEntitySlotPositions(IOEntity ioEntity)
            {
                if (!IOOverridesByEntity.TryGetValue(ioEntity.PrefabName, out var overrideInfo))
                    return;

                for (var i = 0; i < ioEntity.inputs.Length; i++)
                {
                    if (overrideInfo.Inputs.TryGetValue(i, out var overridePosition))
                    {
                        ioEntity.inputs[i].handlePosition = overridePosition;
                    }
                }

                for (var i = 0; i < ioEntity.outputs.Length; i++)
                {
                    if (overrideInfo.Outputs.TryGetValue(i, out var overridePosition))
                    {
                        ioEntity.outputs[i].handlePosition = overridePosition;
                    }
                }
            }

            private void SetupIOSlot(IOSlot slot, IOEntity otherEntity, int otherSlotIndex, WireColour color)
            {
                slot.connectedTo.Set(otherEntity);
                slot.connectedToSlot = otherSlotIndex;
                slot.wireColour = color;
                slot.connectedTo.Init();
            }

            private void ClearIOSlot(IOEntity ioEntity, IOSlot slot)
            {
                slot.Clear();

                ioEntity.MarkDirtyForceUpdateOutputs();
                ioEntity.SendNetworkUpdate();
            }
        }

        private class EntityController : BaseController, IUpdateableController
        {
            public EntityData EntityData { get; }

            private Dictionary<string, object> _vendingDataProvider;

            public EntityController(ProfileController profileController, EntityData entityData)
                : base(profileController, entityData)
            {
                EntityData = entityData;
            }

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new EntityAdapter(this, EntityData, monument);
            }

            public override void OnAdapterSpawned(BaseAdapter adapter)
            {
                base.OnAdapterSpawned(adapter);
                Plugin._adapterListenerManager.OnAdapterSpawned(adapter);
            }

            public override void OnAdapterKilled(BaseAdapter adapter)
            {
                base.OnAdapterKilled(adapter);
                Plugin._adapterListenerManager.OnAdapterKilled(adapter);
            }

            public Coroutine StartUpdateRoutine()
            {
                return ProfileController.StartCoroutine(HandleChangesRoutine());
            }

            public Dictionary<string, object> GetVendingDataProvider()
            {
                return _vendingDataProvider ??= new Dictionary<string, object>
                {
                    ["Plugin"] = Plugin,
                    ["GetData"] = new Func<JObject>(() => EntityData.VendingProfile as JObject),
                    ["SaveData"] = new Action<JObject>(vendingProfile =>
                    {
                        if (!Plugin._isLoaded)
                            return;

                        EntityData.VendingProfile = vendingProfile;
                        Plugin._profileStore.Save(Profile);
                    }),
                    ["GetSkin"] = new Func<ulong>(() => EntityData.Skin),
                    ["SetSkin"] = new Action<ulong>(skinId => EntityData.Skin = skinId),
                };
            }

            private IEnumerator HandleChangesRoutine()
            {
                foreach (var adapter in Adapters.ToList())
                {
                    var singleAdapter = adapter as EntityAdapter;
                    if (singleAdapter.IsDestroyed)
                        continue;

                    singleAdapter.HandleChanges();
                    yield return null;
                }
            }
        }

        #endregion

        #region Entity Adapter/Controller - Signs

        private class SignAdapter : EntityAdapter
        {
            public SignAdapter(BaseController controller, EntityData entityData, BaseMonument monument)
                : base(controller, entityData, monument) {}

            public override void PreUnload()
            {
                if (!Entity.IsDestroyed && !Entity.enableSaving)
                {
                    // Delete sign files immediately, since the entities may not be explicitly killed on server shutdown.
                    DeleteSignFiles();
                }

                base.PreUnload();
            }

            public uint[] GetTextureIds()
            {
                return (Entity as ISignage)?.GetTextureCRCs();
            }

            public void SetTextureIds(uint[] textureIds)
            {
                var sign = Entity as ISignage;
                if (textureIds == null || textureIds.Equals(sign.GetTextureCRCs()))
                    return;

                sign.SetTextureCRCs(textureIds);
            }

            public void SkinSign()
            {
                if (EntityData.SignArtistImages == null)
                    return;

                Plugin.SkinSign(Entity as ISignage, EntityData.SignArtistImages);
            }

            protected override void PreEntitySpawn()
            {
                base.PreEntitySpawn();

                (Entity as Signage)?.EnsureInitialized();

                var carvablePumpkin = Entity as CarvablePumpkin;
                if (carvablePumpkin != null)
                {
                    carvablePumpkin.EnsureInitialized();
                    carvablePumpkin.SetFlag(BaseEntity.Flags.On, true);
                }

                Entity.SetFlag(BaseEntity.Flags.Locked, true);
            }

            protected override void PreEntityKill()
            {
                // Sign files are removed by vanilla only during Die(), so we have to explicitly delete them.
                DeleteSignFiles();
            }

            private void DeleteSignFiles()
            {
                FileStorage.server.RemoveAllByEntity(Entity.net.ID);

                var signage = Entity as Signage;
                if (signage != null)
                {
                    if (signage.textureIDs != null)
                    {
                        Array.Clear(signage.textureIDs, 0, signage.textureIDs.Length);
                    }

                    return;
                }

                var photoFrame = Entity as PhotoFrame;
                if (photoFrame != null)
                {
                    photoFrame._overlayTextureCrc = 0u;
                    return;
                }

                var carvablePumpkin = Entity as CarvablePumpkin;
                if (carvablePumpkin != null)
                {
                    if (carvablePumpkin.textureIDs != null)
                    {
                        Array.Clear(carvablePumpkin.textureIDs, 0, carvablePumpkin.textureIDs.Length);
                    }

                    return;
                }
            }
        }

        private class SignController : EntityController
        {
            public SignController(ProfileController profileController, EntityData data)
                : base(profileController, data) {}

            // Sign artist will only be called for the primary adapter.
            // Texture ids are copied to the others.
            protected SignAdapter _primaryAdapter;

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new SignAdapter(this, EntityData, monument);
            }

            public override void OnAdapterSpawned(BaseAdapter adapter)
            {
                base.OnAdapterSpawned(adapter);

                var signEntityAdapter = adapter as SignAdapter;

                if (_primaryAdapter != null)
                {
                    var textureIds = _primaryAdapter.GetTextureIds();
                    if (textureIds != null)
                    {
                        signEntityAdapter.SetTextureIds(textureIds);
                    }
                }
                else
                {
                    _primaryAdapter = signEntityAdapter;
                    _primaryAdapter.SkinSign();
                }
            }

            public override void OnAdapterKilled(BaseAdapter adapter)
            {
                base.OnAdapterKilled(adapter);

                if (adapter == _primaryAdapter)
                {
                    _primaryAdapter = Adapters.FirstOrDefault() as SignAdapter;
                }
            }

            public void UpdateSign(uint[] textureIds)
            {
                foreach (var adapter in Adapters)
                {
                    (adapter as SignAdapter).SetTextureIds(textureIds);
                }
            }
        }

        #endregion

        #region Entity Adapter/Controller - CCTV

        private class CCTVEntityAdapter : EntityAdapter
        {
            private int _idSuffix;
            private string _cachedIdentifier;
            private string _savedIdentifier => EntityData.CCTV?.RCIdentifier;

            public CCTVEntityAdapter(BaseController controller, EntityData entityData, BaseMonument monument, int idSuffix) : base(controller, entityData, monument)
            {
                _idSuffix = idSuffix;
            }

            // Ensure the RC identifiers are freed up as soon as possible to avoid conflicts when reloading.
            public override void PreUnload()
            {
                SetIdentifier(string.Empty);

                base.PreUnload();
            }

            protected override void PreEntitySpawn()
            {
                base.PreEntitySpawn();

                UpdateIdentifier();
                UpdateDirection();
            }

            protected override void PostEntitySpawn()
            {
                base.PostEntitySpawn();

                if (_cachedIdentifier != null)
                {
                    var computerStationList = GetNearbyStaticComputerStations();
                    if (computerStationList != null)
                    {
                        foreach (var computerStation in computerStationList)
                        {
                            computerStation.ForceAddBookmark(_cachedIdentifier);
                        }
                    }
                }
            }

            public override void OnComponentDestroyed(Component component)
            {
                base.OnComponentDestroyed(component);

                if (component != Entity)
                    return;

                Plugin.TrackStart();

                if (_cachedIdentifier != null)
                {
                    var computerStationList = GetNearbyStaticComputerStations();
                    if (computerStationList != null)
                    {
                        foreach (var computerStation in computerStationList)
                        {
                            computerStation.controlBookmarks.Remove(_cachedIdentifier);
                        }
                    }
                }

                Plugin.TrackEnd();
            }

            public override void HandleChanges()
            {
                base.HandleChanges();

                UpdateIdentifier();
                UpdateDirection();
            }

            public void UpdateIdentifier()
            {
                if (_savedIdentifier == null)
                {
                    SetIdentifier(string.Empty);
                    return;
                }

                var newIdentifier = $"{_savedIdentifier}{_idSuffix}";
                if (newIdentifier == _cachedIdentifier)
                    return;

                if (RemoteControlEntity.IDInUse(newIdentifier))
                {
                    LogWarning($"CCTV ID in use: {newIdentifier}");
                    return;
                }

                SetIdentifier(newIdentifier);

                if (Entity.IsFullySpawned())
                {
                    Entity.SendNetworkUpdate();

                    var computerStationList = GetNearbyStaticComputerStations();
                    if (computerStationList != null)
                    {
                        foreach (var computerStation in computerStationList)
                        {
                            if (_cachedIdentifier != null)
                                computerStation.controlBookmarks.Remove(_cachedIdentifier);

                            computerStation.ForceAddBookmark(newIdentifier);
                        }
                    }
                }

                _cachedIdentifier = newIdentifier;
            }

            public void UpdateDirection()
            {
                var cctvInfo = EntityData.CCTV;
                if (cctvInfo == null)
                    return;

                var cctv = Entity as CCTV_RC;
                cctv.pitchAmount = cctvInfo.Pitch;
                cctv.yawAmount = cctvInfo.Yaw;

                cctv.pitchAmount = Mathf.Clamp(cctv.pitchAmount, cctv.pitchClamp.x, cctv.pitchClamp.y);
                cctv.yawAmount = Mathf.Clamp(cctv.yawAmount, cctv.yawClamp.x, cctv.yawClamp.y);

                cctv.pitch.transform.localRotation = Quaternion.Euler(cctv.pitchAmount, 0f, 0f);
                cctv.yaw.transform.localRotation = Quaternion.Euler(0f, cctv.yawAmount, 0f);

                if (Entity.IsFullySpawned())
                {
                    Entity.SendNetworkUpdate();
                }
            }

            public string GetIdentifier()
            {
                return (Entity as CCTV_RC).rcIdentifier;
            }

            private void SetIdentifier(string id)
            {
                (Entity as CCTV_RC).rcIdentifier = id;
            }

            private List<ComputerStation> GetNearbyStaticComputerStations()
            {
                if (Monument is IEntityMonument { IsMobile: true } entityMonument
                    && entityMonument.RootEntity == Entity.GetParentEntity())
                {
                    var cargoComputerStationList = new List<ComputerStation>();
                    foreach (var child in entityMonument.RootEntity.children)
                    {
                        var computerStation = child as ComputerStation;
                        if (computerStation != null && computerStation.isStatic)
                        {
                            cargoComputerStationList.Add(computerStation);
                        }
                    }

                    return cargoComputerStationList;
                }

                var entityList = new List<BaseEntity>();
                Vis.Entities(Entity.transform.position, 100, entityList, Rust.Layers.Mask.Deployed, QueryTriggerInteraction.Ignore);
                if (entityList.Count == 0)
                    return null;

                var computerStationList = new List<ComputerStation>();
                foreach (var entity in entityList)
                {
                    var computerStation = entity as ComputerStation;
                    if (computerStation != null && !computerStation.IsDestroyed && computerStation.isStatic)
                    {
                        computerStationList.Add(computerStation);
                    }
                }

                return computerStationList;
            }
        }

        private class CCTVController : EntityController
        {
            private int _nextId = 1;

            public CCTVController(ProfileController profileController, EntityData data)
                : base(profileController, data) {}

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new CCTVEntityAdapter(this, EntityData, monument, _nextId++);
            }
        }

        #endregion

        #region Entity Listeners

        private abstract class AdapterListenerBase
        {
            public virtual void Init() {}
            public virtual void OnServerInitialized() {}
            public abstract bool InterestedInAdapter(BaseAdapter adapter);
            public abstract void OnAdapterSpawned(BaseAdapter adapter);
            public abstract void OnAdapterKilled(BaseAdapter adapter);

            protected static bool IsEntityAdapter<T>(BaseAdapter adapter)
            {
                if (adapter.Data is not EntityData entityData)
                    return false;

                return FindPrefabBaseEntity(entityData.PrefabName) is T;
            }
        }

        private abstract class DynamicHookListener : AdapterListenerBase
        {
            private MonumentAddons _plugin;
            protected string[] _dynamicHookNames;

            private HashSet<BaseAdapter> _adapters = new HashSet<BaseAdapter>();

            protected DynamicHookListener(MonumentAddons plugin)
            {
                _plugin = plugin;
            }

            public override void Init()
            {
                UnsubscribeHooks();
            }

            public override void OnAdapterSpawned(BaseAdapter adapter)
            {
                _adapters.Add(adapter);

                if (_adapters.Count == 1)
                {
                    SubscribeHooks();
                }
            }

            public override void OnAdapterKilled(BaseAdapter adapter)
            {
                _adapters.Remove(adapter);

                if (_adapters.Count == 0)
                {
                    UnsubscribeHooks();
                }
            }

            private void SubscribeHooks()
            {
                if (_dynamicHookNames == null || !_plugin._isLoaded)
                    return;

                foreach (var hookName in _dynamicHookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            private void UnsubscribeHooks()
            {
                if (_dynamicHookNames == null || !_plugin._isLoaded)
                    return;

                foreach (var hookName in _dynamicHookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        private class SignEntityListener : DynamicHookListener
        {
            public SignEntityListener(MonumentAddons plugin) : base(plugin)
            {
                _dynamicHookNames = new[]
                {
                    nameof(CanUpdateSign),
                    nameof(OnSignUpdated),
                    nameof(OnImagePost),
                };
            }

            public override bool InterestedInAdapter(BaseAdapter adapter)
            {
                return IsEntityAdapter<ISignage>(adapter);
            }
        }

        private class BuildingBlockEntityListener : DynamicHookListener
        {
            public BuildingBlockEntityListener(MonumentAddons plugin) : base(plugin)
            {
                _dynamicHookNames = new[]
                {
                    nameof(CanChangeGrade),
                };
            }

            public override bool InterestedInAdapter(BaseAdapter adapter)
            {
                return IsEntityAdapter<BuildingBlock>(adapter);
            }
        }

        private class SprayDecalListener : DynamicHookListener
        {
            public SprayDecalListener(MonumentAddons plugin) : base(plugin)
            {
                _dynamicHookNames = new[]
                {
                    nameof(OnSprayRemove),
                };
            }

            public override bool InterestedInAdapter(BaseAdapter adapter)
            {
                return IsEntityAdapter<SprayCanSpray>(adapter);
            }
        }

        private class AdapterListenerManager
        {
            private AdapterListenerBase[] _listeners;

            public AdapterListenerManager(MonumentAddons plugin)
            {
                _listeners = new AdapterListenerBase[]
                {
                    new SignEntityListener(plugin),
                    new BuildingBlockEntityListener(plugin),
                    new SprayDecalListener(plugin),
                };
            }

            public void Init()
            {
                foreach (var listener in _listeners)
                {
                    listener.Init();
                }
            }

            public void OnServerInitialized()
            {
                foreach (var listener in _listeners)
                {
                    listener.OnServerInitialized();
                }
            }

            public void OnAdapterSpawned(BaseAdapter entityAdapter)
            {
                foreach (var listener in _listeners)
                {
                    if (listener.InterestedInAdapter(entityAdapter))
                    {
                        listener.OnAdapterSpawned(entityAdapter);
                    }
                }
            }

            public void OnAdapterKilled(BaseAdapter entityAdapter)
            {
                foreach (var listener in _listeners)
                {
                    if (listener.InterestedInAdapter(entityAdapter))
                    {
                        listener.OnAdapterKilled(entityAdapter);
                    }
                }
            }
        }

        #endregion

        #region SpawnGroup Adapter/Controller

        private class PuzzleResetHandler : FacepunchBehaviour
        {
            public static PuzzleResetHandler Create(EntityAdapter adapter, PuzzleReset puzzleReset)
            {
                var gameObject = new GameObject();
                gameObject.transform.SetParent(puzzleReset.transform);
                var component = gameObject.AddComponent<PuzzleResetHandler>();
                component._adapter = adapter;
                puzzleReset.resetObjects = new[] { gameObject };
                return component;
            }

            private EntityAdapter _adapter;

            // Called by Rust via Unity SendMessage.
            private void OnPuzzleReset()
            {
                _adapter.HandlePuzzleReset();
            }

            public void Destroy()
            {
                Destroy(gameObject);
            }
        }

        private class SpawnedVehicleComponent : FacepunchBehaviour
        {
            public static void AddToVehicle(MonumentAddons plugin, GameObject gameObject)
            {
                var newComponent = gameObject.AddComponent<SpawnedVehicleComponent>();
                newComponent._plugin = plugin;
            }

            private const float MaxDistanceSquared = 1;

            private MonumentAddons _plugin;
            private Vector3 _originalPosition;
            private Transform _transform;

            public void Awake()
            {
                _transform = transform;
                _originalPosition = _transform.position;

                InvokeRandomized(CheckPositionTracked, 10, 10, 1);
            }

            public void CheckPositionTracked()
            {
                _plugin.TrackStart();
                CheckPosition();
                _plugin.TrackEnd();
            }

            private void CheckPosition()
            {
                if ((_transform.position - _originalPosition).sqrMagnitude < MaxDistanceSquared)
                    return;

                // Vehicle has moved from its spawn point, so unregister it and re-enable saving.
                var vehicle = GetComponent<BaseEntity>();
                if (vehicle != null && !vehicle.IsDestroyed)
                {
                    EnableSavingRecursive(vehicle, true);

                    var workcart = vehicle as TrainEngine;
                    if (workcart != null && !workcart.IsInvoking(workcart.DecayTick))
                    {
                        workcart.InvokeRandomized(workcart.DecayTick, UnityEngine.Random.Range(20f, 40f), workcart.decayTickSpacing, workcart.decayTickSpacing * 0.1f);
                    }
                }

                Destroy(GetComponent<SpawnPointInstance>());
                Destroy(this);
            }
        }

        private class CustomAddonSpawnPointInstance : SpawnPointInstance
        {
            public static CustomAddonSpawnPointInstance AddToComponent(AddonComponentTracker componentTracker, Component hostComponent, CustomAddonDefinition customAddonDefinition)
            {
                var spawnPointInstance = hostComponent.gameObject.AddComponent<CustomAddonSpawnPointInstance>();
                spawnPointInstance.CustomAddonDefinition = customAddonDefinition;
                spawnPointInstance._hostComponent = hostComponent;
                spawnPointInstance._componentTracker = componentTracker;
                componentTracker.RegisterComponent(hostComponent);
                customAddonDefinition.SpawnPointInstances.Add(spawnPointInstance);
                return spawnPointInstance;
            }

            public CustomAddonDefinition CustomAddonDefinition { get; private set; }
            private Component _hostComponent;
            private AddonComponentTracker _componentTracker;

            public void Kill()
            {
                CustomAddonDefinition.Kill(_hostComponent);
            }

            public new void OnDestroy()
            {
                _componentTracker.UnregisterComponent(_hostComponent);
                CustomAddonDefinition.SpawnPointInstances.Remove(this);

                if (!Rust.Application.isQuitting)
                {
                    Retire();
                }
            }
        }

        private class CustomSpawnPoint : BaseSpawnPoint, IAddonComponent
        {
            private const int TrainCarLayerMask = Rust.Layers.Mask.AI
                | Rust.Layers.Mask.Vehicle_World
                | Rust.Layers.Mask.Player_Server
                | Rust.Layers.Mask.Construction;

            // When CheckSpace is enabled, override the layer mask for certain entity prefabs.
            private static readonly Dictionary<string, int> CustomBoundsCheckMask = new Dictionary<string, int>
            {
                ["assets/content/vehicles/trains/locomotive/locomotive.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/sedan_a/sedanrail.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/workcart/workcart.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagona.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagonunloadablefuel.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagonunloadableloot.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/wagons/trainwagonunloadable.entity.prefab"] = TrainCarLayerMask,
                ["assets/content/vehicles/trains/caboose/traincaboose.entity.prefab"] = TrainCarLayerMask,
            };

            public static CustomSpawnPoint AddToGameObject(AddonComponentTracker componentTracker, GameObject gameObject, SpawnPointAdapter adapter, SpawnPointData spawnPointData)
            {
                var component = gameObject.AddComponent<CustomSpawnPoint>();
                component._spawnPointAdapter = adapter;
                component._spawnPointData = spawnPointData;
                component._componentTracker = componentTracker;
                componentTracker.RegisterComponent(component);
                return component;
            }

            public TransformAdapter Adapter => _spawnPointAdapter;
            private AddonComponentTracker _componentTracker;
            private SpawnPointAdapter _spawnPointAdapter;
            private SpawnPointData _spawnPointData;
            private Transform _transform;
            private BaseEntity _parentEntity;
            private List<SpawnPointInstance> _instances = new List<SpawnPointInstance>();

            public void PreUnload()
            {
                KillSpawnedInstances();
                gameObject.SetActive(false);
            }

            private void Awake()
            {
                _transform = transform;
                _parentEntity = _transform.parent?.ToBaseEntity();
            }

            public override void GetLocation(out Vector3 position, out Quaternion rotation)
            {
                position = _transform.position;
                rotation = _transform.rotation;

                if (_spawnPointData.RandomRadius > 0)
                {
                    Vector2 vector = UnityEngine.Random.insideUnitCircle * _spawnPointData.RandomRadius;
                    position += new Vector3(vector.x, 0f, vector.y);
                }

                if (_spawnPointData.RandomRotation)
                {
                    rotation *= Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
                }

                if (_spawnPointData.SnapToGround)
                {
                    DropToGround(ref position, ref rotation);
                }
            }

            public override void ObjectSpawned(SpawnPointInstance instance)
            {
                _instances.Add(instance);

                var entity = instance.GetComponent<BaseEntity>();

                // Parent the entity to the monument only if the monument is mobile.
                // This might not be the best behavior for all situations, may need to be revisited.
                // In particular, vehicles should not be parented to entities that don't have a parent trigger,
                // since that would cause the vehicle to be destroyed when the parent is, even if the vehicle has left.
                if (Adapter.Monument is IEntityMonument { IsValid: true, IsMobile: true } entityMonument
                    && _parentEntity == entityMonument.RootEntity
                    && !entity.HasParent())
                {
                    entity.SetParent(_parentEntity, worldPositionStays: true);
                }

                if (IsVehicle(entity))
                {
                    SpawnedVehicleComponent.AddToVehicle(Adapter.Plugin, instance.gameObject);
                    entity.Invoke(() => DisableVehicleDecay(entity), 5);
                }

                var hackableCrate = entity as HackableLockedCrate;
                if ((object)hackableCrate != null && hackableCrate.shouldDecay)
                {
                    hackableCrate.shouldDecay = false;
                    hackableCrate.CancelInvoke(hackableCrate.DelayedDestroy);
                }
            }

            public override void ObjectRetired(SpawnPointInstance instance)
            {
                _instances.Remove(instance);

                _spawnPointAdapter.SpawnGroupAdapter.SpawnGroup.HandleObjectRetired();
            }

            public bool IsAvailableTo(CustomSpawnGroup.SpawnEntry spawnEntry)
            {
                if (_spawnPointData.Exclusive && _instances.Count > 0)
                    return false;

                if (spawnEntry.CustomAddonDefinition != null)
                {
                    if (_spawnPointData.CheckSpace)
                        // Pass null data for now since data isn't supported for custom addons with spawn points.
                        return spawnEntry.CustomAddonDefinition.CheckSpace?.Invoke(_transform.position, _transform.rotation, null) ?? true;

                    return true;
                }

                return IsAvailableTo(spawnEntry.Prefab.Get());
            }

            public override bool IsAvailableTo(GameObject prefab)
            {
                if (!base.IsAvailableTo(prefab))
                    return false;

                if (_spawnPointData.CheckSpace)
                {
                    if (CustomBoundsCheckMask.TryGetValue(prefab.name, out var customBoundsCheckMask))
                        return SpawnHandler.CheckBounds(prefab, _transform.position, _transform.rotation, Vector3.one, customBoundsCheckMask);

                    return SingletonComponent<SpawnHandler>.Instance.CheckBounds(prefab, _transform.position, _transform.rotation, Vector3.one);
                }

                return true;
            }

            public override bool HasPlayersIntersecting()
            {
                var detectionRadius = _spawnPointData.PlayerDetectionRadius > 0
                    ? _spawnPointData.PlayerDetectionRadius
                    : _spawnPointData.RandomRadius > 0
                        ? _spawnPointData.RandomRadius + 1
                        : 0;

                return detectionRadius > 0
                    ? BaseNetworkable.HasCloseConnections(transform.position, detectionRadius)
                    : base.HasPlayersIntersecting();
            }

            public void KillSpawnedInstances(WeightedPrefabData weightedPrefabData = null)
            {
                for (var i = _instances.Count - 1; i >= 0; i--)
                {
                    var spawnPointInstance = _instances[i];
                    if (spawnPointInstance is CustomAddonSpawnPointInstance customAddonSpawnPointInstance)
                    {
                        if (weightedPrefabData == null || weightedPrefabData.CustomAddonName == customAddonSpawnPointInstance.CustomAddonDefinition.AddonName)
                        {
                            customAddonSpawnPointInstance.Kill();
                        }

                        continue;
                    }

                    var entity = spawnPointInstance.GetComponent<BaseEntity>();
                    if ((weightedPrefabData == null || entity.PrefabName == weightedPrefabData.PrefabName)
                        && entity != null && !entity.IsDestroyed)
                    {
                        entity.Kill();
                    }
                }
            }

            private bool IsVehicle(BaseEntity entity)
            {
                return entity is HotAirBalloon || entity is BaseVehicle;
            }

            private void DisableVehicleDecay(BaseEntity vehicle)
            {
                switch (vehicle)
                {
                    case BaseSubmarine sub:
                        sub.timeSinceLastUsed = float.MinValue;
                        break;
                    case Bike bike:
                        bike.timeSinceLastUsed = float.MinValue;
                        break;
                    case HotAirBalloon hab:
                        hab.sinceLastBlast = float.MaxValue;
                        break;
                    case Kayak kayak:
                        kayak.timeSinceLastUsed = float.MinValue;
                        break;
                    case ModularCar car:
                        car.lastEngineOnTime = float.MaxValue;
                        break;
                    case MotorRowboat boat:
                        boat.timeSinceLastUsedFuel = float.MinValue;
                        break;
                    case PlayerHelicopter heli:
                        heli.lastEngineOnTime = float.MaxValue;
                        break;
                    case RidableHorse horse:
                        horse.lastInputTime = float.MaxValue;
                        break;
                    case Snowmobile snowmobile:
                        snowmobile.timeSinceLastUsed = float.MinValue;
                        break;
                    case TrainCar trainCar:
                        trainCar.CancelInvoke(trainCar.DecayTick);
                        break;
                }
            }

            public void MoveSpawnedInstances()
            {
                for (var i = _instances.Count - 1; i >= 0; i--)
                {
                    var entity = _instances[i].GetComponent<BaseEntity>();
                    if (entity == null || entity.IsDestroyed)
                        continue;

                    GetLocation(out var position, out var rotation);

                    if (position != entity.transform.position || rotation != entity.transform.rotation)
                    {
                        if (IsVehicle(entity))
                        {
                            var spawnedVehicleComponent = entity.GetComponent<SpawnedVehicleComponent>();
                            if (spawnedVehicleComponent != null)
                            {
                                spawnedVehicleComponent.CancelInvoke(spawnedVehicleComponent.CheckPositionTracked);
                            }

                            Adapter.Plugin.NextTick(() => spawnedVehicleComponent.Awake());
                        }

                        entity.transform.SetPositionAndRotation(position, rotation);
                        BroadcastEntityTransformChange(entity);
                    }
                }
            }

            private void OnDestroy()
            {
                KillSpawnedInstances();
                _spawnPointAdapter.OnComponentDestroyed(this);
                _componentTracker.UnregisterComponent(this);
            }
        }

        private class CustomSpawnGroup : SpawnGroup
        {
            public new class SpawnEntry
            {
                public readonly CustomAddonDefinition CustomAddonDefinition;
                public readonly GameObjectRef Prefab;
                public int Weight;

                public bool IsValid => CustomAddonDefinition?.IsValid ?? !string.IsNullOrEmpty(Prefab.guid);

                public SpawnEntry(CustomAddonDefinition customAddonDefinition, int weight)
                {
                    CustomAddonDefinition = customAddonDefinition;
                    Weight = weight;
                }

                public SpawnEntry(GameObjectRef prefab, int weight)
                {
                    Prefab = prefab;
                    Weight = weight;
                }
            }

            private static AIInformationZone FindVirtualInfoZone(Vector3 position)
            {
                foreach (var zone in AIInformationZone.zones)
                {
                    if (zone.Virtual && zone.PointInside(position))
                        return zone;
                }

                return null;
            }

            public SpawnGroupAdapter SpawnGroupAdapter { get; private set; }
            public List<SpawnEntry> SpawnEntries { get; } = new();
            private AIInformationZone _cachedInfoZone;
            private bool _didLookForInfoZone;

            private SpawnGroupData SpawnGroupData => SpawnGroupAdapter.SpawnGroupData;

            public void Init(SpawnGroupAdapter spawnGroupAdapter)
            {
                SpawnGroupAdapter = spawnGroupAdapter;
            }

            public void UpdateSpawnClock()
            {
                if (!WantsTimedSpawn())
                {
                    spawnClock.events.Clear();
                    return;
                }

                if (spawnClock.events.Count == 0)
                {
                    spawnClock.Add(GetSpawnDelta(), GetSpawnVariance(), Spawn);
                }
                else
                {
                    var clockEvent = spawnClock.events[0];
                    var timeUntilSpawn = clockEvent.time - UnityEngine.Time.time;

                    if (timeUntilSpawn > SpawnGroupData.RespawnDelayMax)
                    {
                        clockEvent.time = UnityEngine.Time.time + SpawnGroupData.RespawnDelayMax;
                        spawnClock.events[0] = clockEvent;
                    }
                }
            }

            public void HandleObjectRetired()
            {
                // Add one to current population because it was just decremented.
                if (SpawnGroupData.PauseScheduleWhileFull && currentPopulation + 1 >= maxPopulation)
                {
                    ResetSpawnClock();
                }
            }

            // Called by Rust via Unity SendMessage, when associating with a vanilla puzzle reset.
            public void OnPuzzleReset()
            {
                Clear();
                DelayedSpawn();
            }

            #if OXIDE_PUBLICIZED
            public override void Spawn(int numToSpawn)
            #else
            protected override void Spawn(int numToSpawn)
            #endif
            {
                numToSpawn = Mathf.Min(numToSpawn, maxPopulation - currentPopulation);

                for (int i = 0; i < numToSpawn; i++)
                {
                    var spawnEntry = GetRandomSpawnEntry();
                    if (spawnEntry is not { IsValid: true })
                        continue;

                    var spawnPoint = GetRandomSpawnPoint(spawnEntry, out var position, out var rotation);
                    if (spawnPoint == null)
                        continue;

                    SpawnPointInstance spawnPointInstance = null;

                    if (spawnEntry.CustomAddonDefinition != null)
                    {
                        // TODO: Figure out how to associate data with addons spawned this via spawn points.
                        var component = spawnEntry.CustomAddonDefinition.DoSpawn(SpawnGroupData.Id, SpawnGroupAdapter.Monument.Object, position, rotation, null);
                        if (component != null)
                        {
                            spawnPointInstance = CustomAddonSpawnPointInstance.AddToComponent(SpawnGroupAdapter.Plugin._componentTracker, component, spawnEntry.CustomAddonDefinition);
                        }
                    }
                    else
                    {
                        var entity = GameManager.server.CreateEntity(spawnEntry.Prefab.resourcePath, position, rotation, startActive: false);
                        if (entity != null)
                        {
                            entity.gameObject.AwakeFromInstantiate();
                            entity.Spawn();
                            PostSpawnProcess(entity, spawnPoint);
                            spawnPointInstance = entity.gameObject.AddComponent<SpawnPointInstance>();
                        }
                    }

                    if (spawnPointInstance is not null)
                    {
                        spawnPointInstance.parentSpawnPointUser = this;
                        spawnPointInstance.parentSpawnPoint = spawnPoint;
                        spawnPointInstance.Notify();
                    }
                }
            }

            #if OXIDE_PUBLICIZED
            public override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
            #else
            protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
            #endif
            {
                base.PostSpawnProcess(entity, spawnPoint);

                EnableSavingRecursive(entity, false);

                var npcPlayer = entity as NPCPlayer;
                if (npcPlayer != null)
                {
                    var virtualInfoZone = GetVirtualInfoZone();
                    if (virtualInfoZone != null)
                    {
                        npcPlayer.VirtualInfoZone = virtualInfoZone;
                    }

                    var humanNpc = npcPlayer as HumanNPCGlobal;
                    if (humanNpc != null)
                    {
                        virtualInfoZone?.RegisterSleepableEntity(humanNpc.Brain);

                        var agent = npcPlayer.NavAgent;
                        agent.agentTypeID = -1372625422;
                        agent.areaMask = 1;
                        agent.autoTraverseOffMeshLink = true;
                        agent.autoRepath = true;

                        var brain = humanNpc.Brain;
                        humanNpc.Invoke(() =>
                        {
                            var navigator = brain.Navigator;
                            if (navigator == null)
                                return;

                            navigator.DefaultArea = "Walkable";
                            navigator.Init(humanNpc, agent);
                            navigator.PlaceOnNavMesh(0);
                        }, 0);
                    }
                }
            }

            private bool HasSpawned(SpawnEntry spawnEntry)
            {
                foreach (var spawnInstance in spawnInstances)
                {
                    if (spawnInstance is CustomAddonSpawnPointInstance customAddonSpawnPointInstance)
                    {
                        if (spawnEntry.CustomAddonDefinition == customAddonSpawnPointInstance.CustomAddonDefinition)
                            return true;

                        continue;
                    }

                    var entity = spawnInstance.gameObject.ToBaseEntity();
                    if (entity != null && entity.prefabID == spawnEntry.Prefab.resourceID)
                        return true;
                }

                return false;
            }

            private BaseSpawnPoint GetRandomSpawnPoint(SpawnEntry spawnEntry, out Vector3 position, out Quaternion rotation)
            {
                BaseSpawnPoint baseSpawnPoint = null;
                position = Vector3.zero;
                rotation = Quaternion.identity;

                var randomIndex = UnityEngine.Random.Range(0, spawnPoints.Length);

                for (int i = 0; i < spawnPoints.Length; i++)
                {
                    var spawnPoint = spawnPoints[(randomIndex + i) % spawnPoints.Length] as CustomSpawnPoint;
                    if (spawnPoint != null
                        && spawnPoint.IsAvailableTo(spawnEntry)
                        && !spawnPoint.HasPlayersIntersecting())
                    {
                        baseSpawnPoint = spawnPoint;
                        break;
                    }
                }

                if (baseSpawnPoint != null)
                {
                    baseSpawnPoint.GetLocation(out position, out rotation);
                }

                return baseSpawnPoint;
            }

            private float DetermineSpawnEntryWeight(SpawnEntry spawnEntry)
            {
                if (spawnEntry.CustomAddonDefinition is { IsValid: false })
                    return 0;

                return preventDuplicates && HasSpawned(spawnEntry) ? 0 : spawnEntry.Weight;
            }

            private SpawnEntry GetRandomSpawnEntry()
            {
                var totalWeight = SpawnEntries.Sum(DetermineSpawnEntryWeight);
                if (totalWeight == 0)
                    return null;

                var randomWeight = UnityEngine.Random.Range(0f, totalWeight);

                foreach (var spawnEntry in SpawnEntries)
                {
                    var weight = DetermineSpawnEntryWeight(spawnEntry);
                    if ((randomWeight -= weight) <= 0f)
                        return spawnEntry;
                }

                return SpawnEntries[^1];
            }

            private AIInformationZone GetVirtualInfoZone()
            {
                if (!_didLookForInfoZone)
                {
                    _cachedInfoZone = FindVirtualInfoZone(transform.position);
                    _didLookForInfoZone = true;
                }

                return _cachedInfoZone;
            }

            private void ResetSpawnClock()
            {
                if (spawnClock.events.Count == 0)
                    return;

                var clockEvent = spawnClock.events[0];
                clockEvent.delta = GetSpawnDelta();
                var variance = GetSpawnVariance();
                clockEvent.variance = variance;
                clockEvent.time = UnityEngine.Time.time + clockEvent.delta + UnityEngine.Random.Range(-variance, variance);
                spawnClock.events[0] = clockEvent;
            }

            private new void OnDestroy()
            {
                SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove(this);
                SpawnGroupAdapter.OnSpawnGroupKilled();
            }
        }

        private class SpawnPointAdapter : TransformAdapter
        {
            public SpawnPointData SpawnPointData { get; }
            public SpawnGroupAdapter SpawnGroupAdapter { get; }
            public Cus