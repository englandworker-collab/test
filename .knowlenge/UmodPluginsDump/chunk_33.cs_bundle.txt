tomSpawnPoint SpawnPoint { get; private set; }
            public override Component Component => SpawnPoint;
            public override Transform Transform => _transform;
            public override Vector3 Position => _transform.position;
            public override Quaternion Rotation => _transform.rotation;
            public override bool IsValid => SpawnPoint != null;

            private Transform _transform;

            public SpawnPointAdapter(SpawnPointData spawnPointData, SpawnGroupAdapter spawnGroupAdapter, BaseController controller, BaseMonument monument) : base(spawnPointData, controller, monument)
            {
                SpawnPointData = spawnPointData;
                SpawnGroupAdapter = spawnGroupAdapter;
            }

            public override void Spawn()
            {
                var gameObject = new GameObject();
                _transform = gameObject.transform;
                _transform.SetPositionAndRotation(IntendedPosition, IntendedRotation);

                if (Monument is IEntityMonument entityMonument)
                {
                    _transform.SetParent(entityMonument.RootEntity.transform, worldPositionStays: true);
                }

                SpawnPoint = CustomSpawnPoint.AddToGameObject(SpawnGroupAdapter.Plugin._componentTracker, gameObject, this, SpawnPointData);
            }

            public override void Kill()
            {
                UnityEngine.Object.Destroy(SpawnPoint?.gameObject);
            }

            public override void OnComponentDestroyed(Component component)
            {
                SpawnGroupAdapter.OnSpawnPointAdapterKilled(this);
            }

            public override void PreUnload()
            {
                SpawnPoint.PreUnload();
            }

            public void KillSpawnedInstances(WeightedPrefabData weightedPrefabData)
            {
                SpawnPoint.KillSpawnedInstances(weightedPrefabData);
            }

            public void UpdatePosition()
            {
                if (!IsAtIntendedPosition)
                {
                    _transform.SetPositionAndRotation(IntendedPosition, IntendedRotation);
                    SpawnPoint.MoveSpawnedInstances();
                }
            }

            public override bool TryRecordUpdates(Transform moveTransform = null, Transform rotateTransform = null)
            {
                // Only check if at intended position if the moved/rotated transform is the spawn point itself.
                if (moveTransform == _transform && rotateTransform == _transform && IsAtIntendedPosition)
                    return false;

                moveTransform ??= _transform;
                rotateTransform ??= _transform;

                var moveEntityPosition = moveTransform.position;
                SpawnPointData.Position = Monument.InverseTransformPoint(moveEntityPosition);
                SpawnPointData.RotationAngles = (Quaternion.Inverse(Monument.Rotation) * rotateTransform.rotation).eulerAngles;
                SpawnPointData.SnapToTerrain = IsOnTerrain(moveEntityPosition);
                return true;
            }
        }

        private class SpawnGroupAdapter : BaseAdapter
        {
            public SpawnGroupData SpawnGroupData { get; }
            public List<SpawnPointAdapter> SpawnPointAdapters { get; } = new List<SpawnPointAdapter>();
            public CustomSpawnGroup SpawnGroup { get; private set; }
            public PuzzleReset AssociatedPuzzleReset { get; private set; }
            public override bool IsValid => SpawnGroup != null;

            public SpawnGroupAdapter(SpawnGroupData spawnGroupData, BaseController controller, BaseMonument monument) : base(spawnGroupData, controller, monument)
            {
                SpawnGroupData = spawnGroupData;
            }

            public override void Spawn()
            {
                var spawnGroupGameObject = new GameObject();
                spawnGroupGameObject.transform.SetPositionAndRotation(Monument.Position, Monument.Rotation);
                spawnGroupGameObject.SetActive(false);

                // Configure the spawn group and create spawn points before enabling the group.
                // This allows the vanilla Awake() method to perform initial spawn and schedule spawns.
                SpawnGroup = spawnGroupGameObject.AddComponent<CustomSpawnGroup>();
                SpawnGroup.Init(this);

                SpawnGroup.prefabs ??= new List<SpawnGroup.SpawnEntry>();

                UpdateProperties();
                UpdatePrefabEntries();

                // This will call Awake() on the CustomSpawnGroup component.
                spawnGroupGameObject.SetActive(true);

                foreach (var spawnPointData in SpawnGroupData.SpawnPoints)
                {
                    CreateSpawnPoint(spawnPointData);
                }

                UpdateSpawnPointReferences();
                UpdatePuzzleResetAssociation();

                if (SpawnGroupData.InitialSpawn)
                {
                    SpawnGroup.Spawn();
                }
            }

            public override void Kill()
            {
                UnityEngine.Object.Destroy(SpawnGroup?.gameObject);
            }

            public override void OnComponentDestroyed(Component component)
            {
                Kill();
            }

            public override void PreUnload()
            {
                foreach (var adapter in SpawnPointAdapters)
                {
                    adapter.PreUnload();
                }
            }

            public void OnSpawnPointAdapterKilled(SpawnPointAdapter spawnPointAdapter)
            {
                SpawnPointAdapters.Remove(spawnPointAdapter);

                if (SpawnGroup != null)
                {
                    UpdateSpawnPointReferences();
                }

                if (SpawnPointAdapters.Count == 0)
                {
                    Controller.OnAdapterKilled(this);
                }
            }

            public void OnSpawnGroupKilled()
            {
                if (AssociatedPuzzleReset != null)
                {
                    UnregisterWithPuzzleReset(AssociatedPuzzleReset);
                }

                foreach (var spawnPointAdapter in SpawnPointAdapters.ToList())
                {
                    spawnPointAdapter.Kill();
                }
            }

            public void UpdateCustomAddons(CustomAddonDefinition customAddonDefinition)
            {
                foreach (var prefabData in SpawnGroupData.Prefabs)
                {
                    if (prefabData.CustomAddonName != null
                        && prefabData.CustomAddonName == customAddonDefinition.AddonName)
                    {
                        // Clear and recreate the prefab entries since an entry may have been skipped for an invalid custom addon.
                        SpawnGroup.SpawnEntries.Clear();
                        UpdatePrefabEntries();
                        break;
                    }
                }
            }

            private Vector3 GetMidpoint()
            {
                var min = Vector3.positiveInfinity;
                var max = Vector3.negativeInfinity;

                foreach (var spawnPointAdapter in SpawnPointAdapters)
                {
                    var position = spawnPointAdapter.Position;
                    min = Vector3.Min(min, position);
                    max = Vector3.Max(max, position);
                }

                return (min + max) / 2f;
            }

            private PuzzleReset FindClosestVanillaPuzzleReset(float maxDistance = 60)
            {
                return EntityUtils.GetClosestNearbyComponent<PuzzleReset>(GetMidpoint(), maxDistance, Rust.Layers.Mask.World, puzzleReset =>
                {
                    var entity = puzzleReset.GetComponent<BaseEntity>();
                    return entity != null && !Plugin._componentTracker.IsAddonComponent(entity);
                });
            }

            private void RegisterWithPuzzleReset(PuzzleReset puzzleReset)
            {
                if (IsRegisteredWithPuzzleReset(puzzleReset))
                    return;

                if (puzzleReset.resetObjects == null)
                {
                    puzzleReset.resetObjects = new[] { SpawnGroup.gameObject };
                    return;
                }

                var originalLength = puzzleReset.resetObjects.Length;
                Array.Resize(ref puzzleReset.resetObjects, originalLength + 1);
                puzzleReset.resetObjects[originalLength] = SpawnGroup.gameObject;
            }

            private void UnregisterWithPuzzleReset(PuzzleReset puzzleReset)
            {
                if (!IsRegisteredWithPuzzleReset(puzzleReset))
                    return;

                puzzleReset.resetObjects = puzzleReset.resetObjects.Where(obj => obj != SpawnGroup.gameObject).ToArray();
            }

            private bool IsRegisteredWithPuzzleReset(PuzzleReset puzzleReset)
            {
                return puzzleReset.resetObjects?.Contains(SpawnGroup.gameObject) == true;
            }

            private void UpdateProperties()
            {
                SpawnGroup.preventDuplicates = SpawnGroupData.PreventDuplicates;
                SpawnGroup.maxPopulation = SpawnGroupData.MaxPopulation;
                SpawnGroup.numToSpawnPerTickMin = SpawnGroupData.SpawnPerTickMin;
                SpawnGroup.numToSpawnPerTickMax = SpawnGroupData.SpawnPerTickMax;

                var respawnDelayMin = SpawnGroupData.RespawnDelayMin;
                var respawnDelayMax = Mathf.Max(respawnDelayMin, SpawnGroupData.RespawnDelayMax > 0 ? SpawnGroupData.RespawnDelayMax : float.PositiveInfinity);

                var respawnDelayMinChanged = !Mathf.Approximately(SpawnGroup.respawnDelayMin, respawnDelayMin);
                var respawnDelayMaxChanged = !Mathf.Approximately(SpawnGroup.respawnDelayMax, respawnDelayMax);

                SpawnGroup.respawnDelayMin = respawnDelayMin;
                SpawnGroup.respawnDelayMax = respawnDelayMax;

                if (SpawnGroup.gameObject.activeSelf && (respawnDelayMinChanged || respawnDelayMaxChanged))
                {
                    SpawnGroup.UpdateSpawnClock();
                }
            }

            private void UpdatePrefabEntries()
            {
                if (SpawnGroup.SpawnEntries.Count == SpawnGroupData.Prefabs.Count)
                {
                    for (var i = 0; i < SpawnGroup.SpawnEntries.Count; i++)
                    {
                        SpawnGroup.SpawnEntries[i].Weight = SpawnGroupData.Prefabs[i].Weight;
                    }

                    return;
                }

                SpawnGroup.SpawnEntries.Clear();

                foreach (var prefabEntry in SpawnGroupData.Prefabs)
                {
                    if (prefabEntry.CustomAddonName != null)
                    {
                        var customAddonDefinition = Plugin._customAddonManager.GetAddon(prefabEntry.CustomAddonName);
                        if (customAddonDefinition != null)
                        {
                            SpawnGroup.SpawnEntries.Add(new CustomSpawnGroup.SpawnEntry(customAddonDefinition, prefabEntry.Weight));
                        }

                        continue;
                    }

                    if (prefabEntry.PrefabName != null && GameManifest.pathToGuid.TryGetValue(prefabEntry.PrefabName, out var guid))
                    {
                        SpawnGroup.SpawnEntries.Add(new CustomSpawnGroup.SpawnEntry(new GameObjectRef { guid = guid }, prefabEntry.Weight));
                    }
                }
            }

            private void UpdateSpawnPointReferences()
            {
                if (!SpawnGroup.gameObject.activeSelf || SpawnGroup.spawnPoints.Length == SpawnPointAdapters.Count)
                    return;

                SpawnGroup.spawnPoints = new BaseSpawnPoint[SpawnPointAdapters.Count];

                for (var i = 0; i < SpawnPointAdapters.Count; i++)
                {
                    SpawnGroup.spawnPoints[i] = SpawnPointAdapters[i].SpawnPoint;
                }
            }

            private void UpdateSpawnPointPositions()
            {
                foreach (var adapter in SpawnPointAdapters)
                {
                    if (!adapter.IsAtIntendedPosition)
                    {
                        adapter.UpdatePosition();
                    }
                }
            }

            private void UpdatePuzzleResetAssociation()
            {
                if (!SpawnGroup.gameObject.activeSelf)
                    return;

                if (SpawnGroupData.RespawnWhenNearestPuzzleResets)
                {
                    var closestPuzzleReset = FindClosestVanillaPuzzleReset();

                    // Re-evaluate current association since the midpoint and other circumstances can change.
                    if (AssociatedPuzzleReset != null && AssociatedPuzzleReset != closestPuzzleReset)
                    {
                        UnregisterWithPuzzleReset(AssociatedPuzzleReset);
                    }

                    AssociatedPuzzleReset = closestPuzzleReset;
                    if (closestPuzzleReset != null)
                    {
                        RegisterWithPuzzleReset(closestPuzzleReset);
                    }
                }
                else if (AssociatedPuzzleReset != null)
                {
                    UnregisterWithPuzzleReset(AssociatedPuzzleReset);
                }
            }

            public void UpdateSpawnGroup()
            {
                UpdateProperties();
                UpdatePrefabEntries();
                UpdateSpawnPointReferences();
                UpdateSpawnPointPositions();
                UpdatePuzzleResetAssociation();
            }

            public void SpawnTick()
            {
                SpawnGroup.Spawn();
            }

            public void KillSpawnedInstances(WeightedPrefabData weightedPrefabData)
            {
                foreach (var spawnPointAdapter in SpawnPointAdapters)
                {
                    spawnPointAdapter.KillSpawnedInstances(weightedPrefabData);
                }
            }

            public void CreateSpawnPoint(SpawnPointData spawnPointData)
            {
                var spawnPointAdapter = new SpawnPointAdapter(spawnPointData, this, Controller, Monument);
                SpawnPointAdapters.Add(spawnPointAdapter);
                spawnPointAdapter.Spawn();

                if (SpawnGroup.gameObject.activeSelf)
                {
                    UpdateSpawnPointReferences();
                }
            }

            public void KillSpawnPoint(SpawnPointData spawnPointData)
            {
                FindSpawnPoint(spawnPointData)?.Kill();
            }

            private SpawnPointAdapter FindSpawnPoint(SpawnPointData spawnPointData)
            {
                foreach (var spawnPointAdapter in SpawnPointAdapters)
                {
                    if (spawnPointAdapter.SpawnPointData == spawnPointData)
                        return spawnPointAdapter;
                }

                return null;
            }
        }

        private class SpawnGroupController : BaseController, IUpdateableController
        {
            public SpawnGroupData SpawnGroupData { get; }
            public IEnumerable<SpawnGroupAdapter> SpawnGroupAdapters { get; }

            public SpawnGroupController(ProfileController profileController, SpawnGroupData spawnGroupData) : base(profileController, spawnGroupData)
            {
                SpawnGroupData = spawnGroupData;
                SpawnGroupAdapters = Adapters.Cast<SpawnGroupAdapter>();
            }

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new SpawnGroupAdapter(SpawnGroupData, this, monument);
            }

            public override Coroutine Kill(BaseData data)
            {
                if (data == Data)
                    return base.Kill(data);

                if (data is SpawnPointData spawnPointData)
                {
                    KillSpawnPoint(spawnPointData);
                    return null;
                }

                LogError($"{nameof(SpawnGroupController)}.{nameof(Kill)} not implemented for type {data.GetType()}. Killing {nameof(SpawnGroupController)}.");
                return null;
            }

            public void CreateSpawnPoint(SpawnPointData spawnPointData)
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters)
                {
                    spawnGroupAdapter.CreateSpawnPoint(spawnPointData);
                }
            }

            public void KillSpawnPoint(SpawnPointData spawnPointData)
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters)
                {
                    spawnGroupAdapter.KillSpawnPoint(spawnPointData);
                }
            }

            public void UpdateSpawnGroups()
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters)
                {
                    spawnGroupAdapter.UpdateSpawnGroup();
                }
            }

            public Coroutine StartUpdateRoutine()
            {
                return ProfileController.StartCoroutine(UpdateRoutine());
            }

            public void StartSpawnRoutine()
            {
                ProfileController.StartCoroutine(SpawnTickRoutine());
            }

            public void StartKillSpawnedInstancesRoutine(WeightedPrefabData weightedPrefabData)
            {
                ProfileController.StartCoroutine(KillSpawnedInstancesRoutine(weightedPrefabData));
            }

            public void StartRespawnRoutine()
            {
                ProfileController.StartCoroutine(RespawnRoutine());
            }

            private IEnumerator UpdateRoutine()
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters)
                {
                    spawnGroupAdapter.UpdateSpawnGroup();
                    yield return null;
                }
            }

            private IEnumerator SpawnTickRoutine()
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters.ToList())
                {
                    spawnGroupAdapter.SpawnTick();
                    yield return null;
                }
            }

            private IEnumerator KillSpawnedInstancesRoutine(WeightedPrefabData weightedPrefabData = null)
            {
                foreach (var spawnGroupAdapter in SpawnGroupAdapters.ToList())
                {
                    spawnGroupAdapter.KillSpawnedInstances(weightedPrefabData);
                    yield return null;
                }
            }

            private IEnumerator RespawnRoutine()
            {
                yield return KillSpawnedInstancesRoutine();
                yield return SpawnTickRoutine();
            }
        }

        #endregion

        #region Paste Adapter/Controller

        private class PasteAdapter : TransformAdapter
        {
            private const float CopyPasteMagicRotationNumber = 57.2958f;
            private const float MaxWaitSeconds = 5;
            private const float KillBatchSize = 5;

            public PasteData PasteData { get; }
            public OBB Bounds => new OBB(Position + Rotation * _bounds.center, _bounds.size, Rotation);
            public override Component Component => _transform;
            public override Transform Transform => _transform;
            public override Vector3 Position => _transform.position;
            public override Quaternion Rotation => _transform.rotation;
            public override bool IsValid => _transform != null;
            public override bool IsAtIntendedPosition => _spawnedPosition == Position && _spawnedRotation == Rotation;

            private Transform _transform;
            private Vector3 _spawnedPosition;
            private Quaternion _spawnedRotation;
            private Bounds _bounds;
            private bool _isWorking;
            private Action _cancelPaste;
            private List<BaseEntity> _pastedEntities = new List<BaseEntity>();

            public PasteAdapter(PasteData pasteData, BaseController controller, BaseMonument monument) : base(pasteData, controller, monument)
            {
                PasteData = pasteData;
            }

            public override void Spawn()
            {
                var position = IntendedPosition;
                var rotation = IntendedRotation;

                _transform = new GameObject().transform;
                _transform.SetPositionAndRotation(position, rotation);
                AddonComponent.AddToComponent(Plugin._componentTracker, _transform, this);

                if (Monument is IEntityMonument entityMonument)
                {
                    _transform.SetParent(entityMonument.RootEntity.transform);
                }

                SpawnPaste(position, rotation);
            }

            public override void Kill()
            {
                if (_transform != null)
                {
                    UnityEngine.Object.Destroy(_transform.gameObject);
                }

                KillPaste();
                Controller.OnAdapterKilled(this);
            }

            public override void OnComponentDestroyed(Component component)
            {
                if (component is not BaseEntity entity)
                {
                    Kill();
                    return;
                }

                _pastedEntities.Remove(entity);
            }

            public void HandleChanges()
            {
                if (IsAtIntendedPosition)
                    return;

                var position = IntendedPosition;
                var rotation = IntendedRotation;
                Transform.SetPositionAndRotation(position, rotation);
                ProfileController.StartCoroutine(RespawnPasteRoutine(position, rotation));
            }

            private void SpawnPaste(Vector3 position, Quaternion rotation)
            {
                _spawnedPosition = position;
                _spawnedRotation = rotation;
                _cancelPaste = PasteUtils.PasteWithCancelCallback(Plugin.CopyPaste, PasteData, position, rotation.eulerAngles.y / CopyPasteMagicRotationNumber, OnEntityPasted, OnPasteComplete);

                if (_cancelPaste != null)
                {
                    _isWorking = true;
                    WaitInstruction = WaitWhileWithTimeout(() => _isWorking, MaxWaitSeconds);
                }
                else
                {
                    _isWorking = false;
                    WaitInstruction = null;
                }
            }

            private IEnumerator SpawnPasteRoutine(Vector3 position, Quaternion rotation)
            {
                SpawnPaste(position, rotation);
                yield return WaitInstruction;
            }

            private IEnumerator RespawnPasteRoutine(Vector3 position, Quaternion rotation)
            {
                yield return KillPaste();
                yield return SpawnPasteRoutine(position, rotation);
            }

            private Coroutine KillPaste()
            {
                _cancelPaste?.Invoke();
                _isWorking = true;
                WaitInstruction = WaitWhileWithTimeout(() => _isWorking, MaxWaitSeconds);
                return CoroutineManager.StartGlobalCoroutine(KillRoutine());
            }

            private IEnumerator KillRoutine()
            {
                var pastedEntities = _pastedEntities.ToList();
                var killedInCurrentBatch = 0;

                // Remove the entities in reverse order. Hopefully this makes the top of the building get removed first.
                for (var i = pastedEntities.Count - 1; i >= 0; i--)
                {
                    var entity = pastedEntities[i];
                    if (entity != null && !entity.IsDestroyed)
                    {
                        Plugin.TrackStart();
                        entity.Kill();
                        Plugin.TrackEnd();

                        if (killedInCurrentBatch++ >= KillBatchSize)
                        {
                            killedInCurrentBatch = 0;
                            yield return null;
                        }
                    }
                }

                _isWorking = false;
            }

            private void OnEntityPasted(BaseEntity entity)
            {
                EntitySetupUtils.PreSpawnShared(entity);
                EntitySetupUtils.PostSpawnShared(Plugin, entity, enableSaving: false);

                AddonComponent.AddToComponent(Plugin._componentTracker, entity, this);
                _pastedEntities.Add(entity);
            }

            private void OnPasteComplete()
            {
                _isWorking = false;
                _bounds = GetBounds();
            }

            private Bounds GetBounds()
            {
                var bounds = new Bounds();
                var pastePosition = Position;
                var pasteInverseRotation = Quaternion.Inverse(Rotation);

                foreach (var entity in _pastedEntities)
                {
                    if (entity == null || entity.IsDestroyed)
                        continue;

                    var transform = entity.transform;
                    var relativePosition = pasteInverseRotation * (transform.position - pastePosition);
                    var relativeRotation = pasteInverseRotation * transform.rotation;
                    var obb = new OBB(relativePosition, transform.lossyScale, relativeRotation, entity.bounds);
                    bounds.Encapsulate(obb.ToBounds());
                }

                return bounds;
            }
        }

        private class PasteController : BaseController, IUpdateableController
        {
            public PasteData PasteData { get; }

            public PasteController(ProfileController profileController, PasteData pasteData) : base(profileController, pasteData)
            {
                PasteData = pasteData;
            }

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new PasteAdapter(PasteData, this, monument);
            }

            public override IEnumerator SpawnAtMonumentsRoutine(IEnumerable<BaseMonument> monumentList)
            {
                if (!PasteUtils.IsCopyPasteCompatible(Plugin.CopyPaste))
                {
                    LogError($"Unable to paste \"{PasteData.Filename}\" for profile \"{Profile.Name}\" because CopyPaste is not loaded or its version is incompatible.");
                    yield break;
                }

                if (!PasteUtils.DoesPasteExist(PasteData.Filename))
                {
                    LogError($"Unable to paste \"{PasteData.Filename}\" for profile \"{Profile.Name}\" because the file does not exist.");
                    yield break;
                }

                yield return base.SpawnAtMonumentsRoutine(monumentList);
            }

            public Coroutine StartUpdateRoutine()
            {
                return ProfileController.StartCoroutine(UpdateRoutine());
            }

            private IEnumerator UpdateRoutine()
            {
                foreach (var adapter in Adapters.ToList())
                {
                    var pasteAdapter = adapter as PasteAdapter;
                    if (pasteAdapter is not { IsValid: true })
                        continue;

                    pasteAdapter.HandleChanges();
                    yield return pasteAdapter.WaitInstruction;
                }
            }
        }

        #endregion

        #region Custom Addon Adapter/Controller

        private class CustomAddonDefinition
        {
            public static CustomAddonDefinition FromDictionary(string addonName, Plugin plugin, Dictionary<string, object> addonSpec)
            {
                var addonDefinition = new CustomAddonDefinition
                {
                    AddonName = addonName,
                    OwnerPlugin = plugin,
                };

                if (addonSpec.TryGetValue("Initialize", out var initializeCallback))
                {
                    addonDefinition.Initialize = initializeCallback as CustomInitializeCallback;
                    addonDefinition.InitializeV2 = initializeCallback as CustomInitializeCallbackV2;
                }

                if (addonSpec.TryGetValue("Edit", out var editCallback))
                {
                    addonDefinition.Edit = editCallback as CustomEditCallback;
                }

                if (addonSpec.TryGetValue("Spawn", out var spawnCallback))
                {
                    addonDefinition.Spawn = spawnCallback as CustomSpawnCallback;
                    addonDefinition.SpawnV2 = spawnCallback as CustomSpawnCallbackV2;
                }

                if (addonSpec.TryGetValue("CheckSpace", out var checkSpaceCallback))
                {
                    addonDefinition.CheckSpace = checkSpaceCallback as CustomCheckSpaceCallback;
                }

                if (addonSpec.TryGetValue("Kill", out var killCallback))
                {
                    addonDefinition.Kill = killCallback as CustomKillCallback;
                }

                if (addonSpec.TryGetValue("Unload", out var unloadCallback))
                {
                    addonDefinition.Unload = unloadCallback as CustomUnloadCallback;
                }

                if (addonSpec.TryGetValue("Update", out var updateCallback))
                {
                    addonDefinition.Update = updateCallback as CustomUpdateCallback;
                    addonDefinition.UpdateV2 = updateCallback as CustomUpdateCallbackV2;
                }

                if (addonSpec.TryGetValue("AddDisplayInfo", out var addDisplayInfoCallback))
                {
                    addonDefinition.Display = addDisplayInfoCallback as CustomDisplayCallback;
                }

                if (addonSpec.TryGetValue("Display", out var displayCallback))
                {
                    addonDefinition.DisplayV2 = displayCallback as CustomDisplayCallbackV2;
                }

                return addonDefinition;
            }

            public string AddonName;
            public Plugin OwnerPlugin;
            private CustomInitializeCallback Initialize;
            private CustomInitializeCallbackV2 InitializeV2;
            private CustomEditCallback Edit;
            private CustomSpawnCallback Spawn;
            private CustomSpawnCallbackV2 SpawnV2;
            public CustomCheckSpaceCallback CheckSpace;
            public CustomKillCallback Kill;
            public CustomUnloadCallback Unload;
            private CustomUpdateCallback Update;
            private CustomUpdateCallbackV2 UpdateV2;
            private CustomDisplayCallback Display;
            private CustomDisplayCallbackV2 DisplayV2;
            public bool IsValid = true;

            public List<CustomAddonAdapter> AdapterUsers = new();
            public List<CustomAddonSpawnPointInstance> SpawnPointInstances = new();

            public bool SupportsEditing => Edit != null && (Update != null || UpdateV2 != null);

            public Dictionary<string, object> ToApiResult(ProfileStore profileStore)
            {
                return new Dictionary<string, object>
                {
                    ["SetData"] = new CustomSetDataCallback((component, data) => SetData(profileStore, component, data)),
                };
            }

            public bool Validate()
            {
                if (Spawn == null && SpawnV2 == null)
                {
                    LogError($"Unable to register custom addon \"{AddonName}\" for plugin {OwnerPlugin.Name} due to missing Spawn method.");
                    return false;
                }

                if (Kill == null)
                {
                    LogError($"Unable to register custom addon \"{AddonName}\" for plugin {OwnerPlugin.Name} due to missing Kill method.");
                    return false;
                }

                return true;
            }

            public bool TryInitialize(BasePlayer player, string[] args, out object data)
            {
                try
                {
                    if (Initialize != null)
                    {
                        try
                        {
                            data = Initialize.Invoke(player, args);
                            return true;
                        }
                        catch (ArgumentException)
                        {
                            // Don't log argument exception, assume that the addon plugin threw this intentionally.
                            data = null;
                            return false;
                        }
                    }

                    if (InitializeV2 != null)
                    {
                        (var success, data) = InitializeV2.Invoke(player, args);
                        return success;
                    }
                }
                catch (Exception ex)
                {
                    data = null;
                    LogError($"Caught exception when calling plugin '{OwnerPlugin}' to initialize custom addon '{AddonName}': {ex}");
                    return false;
                }

                data = null;
                return true;
            }

            public bool TryEdit(BasePlayer player, string[] args, Component component, JObject data, out object newData)
            {
                try
                {
                    (var success, newData) = Edit(player, args, component, data);
                    return success;
                }
                catch (Exception ex)
                {
                    LogError($"Caught exception when calling plugin '{OwnerPlugin}' to initialize custom addon '{AddonName}': {ex}");
                    newData = null;
                    return false;
                }
            }

            public Component DoSpawn(Guid guid, Component monument, Vector3 position, Quaternion rotation, JObject jObject)
            {
                return Spawn?.Invoke(position, rotation, jObject)
                    ?? SpawnV2?.Invoke(guid, monument, position, rotation, jObject);
            }

            public Component DoUpdate(Component component, JObject data)
            {
                if (Update != null)
                {
                    Update(component, data);
                    return component;
                }

                if (UpdateV2 != null)
                    return UpdateV2(component, data);

                // This should not happen.
                return component;
            }

            public void SetData(ProfileStore profileStore, CustomAddonController controller, object data)
            {
                controller.CustomAddonData.SetData(data);
                profileStore.Save(controller.Profile);

                controller.StartUpdateRoutine();
            }

            public void SetData(ProfileStore profileStore, Component component, object data)
            {
                if (Update == null && UpdateV2 == null)
                {
                    LogError($"Unable to set data for custom addon \"{AddonName}\" due to missing Update method.");
                    return;
                }

                var matchingAdapter = AdapterUsers.FirstOrDefault(adapter => adapter.Component == component);
                if (matchingAdapter == null)
                {
                    LogError($"Unable to set data for custom addon \"{AddonName}\" because it has no spawned instances.");
                    return;
                }

                if (matchingAdapter.Controller is not CustomAddonController controller)
                    return;

                SetData(profileStore, controller, data);
            }

            public void DoDisplay(Component component, JObject data, BasePlayer player, StringBuilder sb, float duration)
            {
                Display?.Invoke(component, data, sb);
                DisplayV2?.Invoke(component, data, player, sb, duration);
            }
        }

        private class CustomAddonManager
        {
            private MonumentAddons _plugin;
            private Dictionary<string, CustomAddonDefinition> _customAddonsByName = new Dictionary<string, CustomAddonDefinition>();
            private Dictionary<string, List<CustomAddonDefinition>> _customAddonsByPlugin = new Dictionary<string, List<CustomAddonDefinition>>();

            public IEnumerable<CustomAddonDefinition> GetAllAddons()
            {
                return _customAddonsByName.Values;
            }

            public CustomAddonManager(MonumentAddons plugin)
            {
                _plugin = plugin;
            }

            public bool IsRegistered(string addonName, out Plugin otherPlugin)
            {
                otherPlugin = null;
                if (_customAddonsByName.TryGetValue(addonName, out var existingAddon))
                {
                    otherPlugin = existingAddon.OwnerPlugin;
                    return true;
                }

                return false;
            }

            public void RegisterAddon(CustomAddonDefinition addonDefinition)
            {
                _customAddonsByName[addonDefinition.AddonName] = addonDefinition;

                var addonsForPlugin = GetAddonsForPlugin(addonDefinition.OwnerPlugin);
                if (addonsForPlugin == null)
                {
                    addonsForPlugin = new List<CustomAddonDefinition>();
                    _customAddonsByPlugin[addonDefinition.OwnerPlugin.Name] = addonsForPlugin;
                }

                addonsForPlugin.Add(addonDefinition);

                if (_plugin._serverInitialized)
                {
                    foreach (var profileController in _plugin._profileManager.GetEnabledProfileControllers())
                    {
                        foreach (var spawnGroupAdapter in profileController.GetAdapters<SpawnGroupAdapter>())
                        {
                            spawnGroupAdapter.UpdateCustomAddons(addonDefinition);
                        }

                        foreach (var monumentEntry in profileController.Profile.MonumentDataMap)
                        {
                            var monumentName = monumentEntry.Key;
                            var monumentData = monumentEntry.Value;

                            foreach (var customAddonData in monumentData.CustomAddons)
                            {
                                if (customAddonData.AddonName == addonDefinition.AddonName)
                                {
                                    profileController.SpawnNewData(customAddonData, _plugin.GetMonumentsByIdentifier(monumentName));
                                }
                            }
                        }
                    }
                }
            }

            public void UnregisterAllForPlugin(Plugin plugin)
            {
                if (_customAddonsByName.Count == 0)
                    return;

                var addonsForPlugin = GetAddonsForPlugin(plugin);
                if (addonsForPlugin == null)
                    return;

                var controllerList = new HashSet<CustomAddonController>();

                foreach (var addonDefinition in addonsForPlugin)
                {
                    addonDefinition.IsValid = false;

                    foreach (var adapter in addonDefinition.AdapterUsers)
                    {
                        controllerList.Add(adapter.Controller as CustomAddonController);

                        // Remove the controller from the profile,
                        // since we may need to respawn it immediately after as part of the other plugin reloading.
                        adapter.Controller.ProfileController.OnControllerKilled(adapter.Controller);
                    }

                    foreach (var spawnPointInstance in addonDefinition.SpawnPointInstances)
                    {
                        spawnPointInstance.Kill();
                    }

                    _customAddonsByName.Remove(addonDefinition.AddonName);
                }

                foreach (var controller in controllerList)
                {
                    controller.PreUnload();
                }

                CoroutineManager.StartGlobalCoroutine(DestroyControllersRoutine(controllerList));

                _customAddonsByPlugin.Remove(plugin.Name);
            }

            public CustomAddonDefinition GetAddon(string addonName)
            {
                return _customAddonsByName.GetValueOrDefault(addonName);
            }

            private List<CustomAddonDefinition> GetAddonsForPlugin(Plugin plugin)
            {
                return _customAddonsByPlugin.GetValueOrDefault(plugin.Name);
            }

            private IEnumerator DestroyControllersRoutine(ICollection<CustomAddonController> controllerList)
            {
                foreach (var controller in controllerList)
                {
                    yield return controller.KillRoutine();
                }
            }
        }

        private class CustomAddonAdapter : TransformAdapter
        {
            public CustomAddonData CustomAddonData { get; }
            public CustomAddonDefinition AddonDefinition { get; }

            public override Component Component => _component;
            public override Transform Transform => _transform;
            public override Vector3 Position => _transform.position;
            public override Quaternion Rotation => _transform.rotation;
            public override bool IsValid => Component != null && (Component is not BaseEntity { IsDestroyed: true });

            private Component _component;
            private Transform _transform;
            private bool _wasKilled;

            public CustomAddonAdapter(CustomAddonData customAddonData, BaseController controller, BaseMonument monument, CustomAddonDefinition addonDefinition) : base(customAddonData, controller, monument)
            {
                CustomAddonData = customAddonData;
                AddonDefinition = addonDefinition;
            }

            public override void Spawn()
            {
                var component = AddonDefinition.DoSpawn(CustomAddonData.Id, Monument.Object, IntendedPosition, IntendedRotation, CustomAddonData.GetSerializedData());
                AddonDefinition.AdapterUsers.Add(this);
                SetupComponent(component);
            }

            public override void PreUnload()
            {
                AddonDefinition.Unload?.Invoke(Component);
            }

            public override void Kill()
            {
                if (_wasKilled)
                    return;

                _wasKilled = true;
                AddonDefinition.Kill(_component);
            }

            public override void OnComponentDestroyed(Component component)
            {
                // Don't kill the addon if the component was replaced.
                if (component != _component)
                    return;

                // In case it's a multi-part addon, call Kill() to ensure the whole addon is removed.
                Kill();

                AddonDefinition.AdapterUsers.Remove(this);
                Controller.OnAdapterKilled(this);
            }

            public void SetupComponent(Component component)
            {
                _component = component;
                _transform = component.transform;
                AddonComponent.AddToComponent(Plugin._componentTracker, component, this);
            }

            public void HandleChanges()
            {
                UpdatePosition();
                UpdateViaOwnerPlugin();
            }

            private void UpdateViaOwnerPlugin()
            {
                if (!AddonDefinition.SupportsEditing)
                    return;

                var newComponent = AddonDefinition.DoUpdate(_component, CustomAddonData.GetSerializedData());
                if (newComponent != _component)
                {
                    SetupComponent(newComponent);
                }
            }

            private void UpdatePosition()
            {
                if (IsAtIntendedPosition)
                    return;

                _component.transform.SetPositionAndRotation(IntendedPosition, IntendedRotation);

                if (_component is BaseEntity entity)
                {
                    BroadcastEntityTransformChange(entity);
                }
            }
        }

        private class CustomAddonController : BaseController, IUpdateableController
        {
            public CustomAddonData CustomAddonData { get; }

            private CustomAddonDefinition _addonDefinition;

            public CustomAddonController(ProfileController profileController, CustomAddonData customAddonData, CustomAddonDefinition addonDefinition) : base(profileController, customAddonData)
            {
                CustomAddonData = customAddonData;
                _addonDefinition = addonDefinition;
            }

            public override BaseAdapter CreateAdapter(BaseMonument monument)
            {
                return new CustomAddonAdapter(CustomAddonData, this, monument, _addonDefinition);
            }

            public Coroutine StartUpdateRoutine()
            {
                return ProfileController.StartCoroutine(UpdateRoutine());
            }

            private IEnumerator UpdateRoutine()
            {
                foreach (var adapter in Adapters.ToList())
                {
                    if (!_addonDefinition.IsValid)
                        yield break;

                    var customAddonAdapter = adapter as CustomAddonAdapter;
                    if (customAddonAdapter is not { IsValid: true })
                        continue;

                    customAddonAdapter.HandleChanges();
                    yield return null;
                }
            }
        }

        #endregion

        #region Controller Factories

        private class EntityControllerFactory
        {
            public virtual bool AppliesToEntity(BaseEntity entity)
            {
                return true;
            }

            public virtual EntityController CreateController(ProfileController controller, EntityData entityData)
            {
                return new EntityController(controller, entityData);
            }
        }

        private class SignControllerFactory : EntityControllerFactory
        {
            public override bool AppliesToEntity(BaseEntity entity)
            {
                return entity is ISignage;
            }

            public override EntityController CreateController(ProfileController controller, EntityData entityData)
            {
                return new SignController(controller, entityData);
            }
        }

        private class CCTVControllerFactory : EntityControllerFactory
        {
            public override bool AppliesToEntity(BaseEntity entity)
            {
                return entity is CCTV_RC;
            }

            public override EntityController CreateController(ProfileController controller, EntityData entityData)
            {
                return new CCTVController(controller, entityData);
            }
        }

        private class ControllerFactory
        {
            private MonumentAddons _plugin;

            public ControllerFactory(MonumentAddons plugin)
            {
                _plugin = plugin;
            }

            private EntityControllerFactory[] _entityFactories =
            {
                // The first that matches will be used.
                new CCTVControllerFactory(),
                new SignControllerFactory(),
                new EntityControllerFactory(),
            };

            public BaseController CreateController(ProfileController profileController, BaseData data)
            {
                if (data is SpawnGroupData spawnGroupData)
                    return new SpawnGroupController(profileController, spawnGroupData);

                if (data is PasteData pasteData)
                    return new PasteController(profileController, pasteData);

                if (data is CustomAddonData customAddonData)
                {
                    var addonDefinition = _plugin._customAddonManager.GetAddon(customAddonData.AddonName);
                    return addonDefinition != null
                        ? new CustomAddonController(profileController, customAddonData, addonDefinition)
                        : null;
                }

                if (data is EntityData entityData)
                    return ResolveEntityFactory(entityData)?.CreateController(profileController, entityData);

                if (data is PrefabData prefabData)
                    return new PrefabController(profileController, prefabData);

                return null;
            }

            private EntityControllerFactory ResolveEntityFactory(EntityData entityData)
            {
                var baseEntity = FindPrefabBaseEntity(entityData.PrefabName);
                if (baseEntity == null)
                    return null;

                foreach (var controllerFactory in _entityFactories)
                {
                    if (controllerFactory.AppliesToEntity(baseEntity))
                        return controllerFactory;
                }

                return null;
            }
        }

        #endregion

        #endregion

        #region IO Manager

        private class IOManager
        {
            private const int FreePowerAmount = 1000;

            private static bool HasInput(IOEntity ioEntity, IOType ioType)
            {
                foreach (var input in ioEntity.inputs)
                {
                    if (input.type == ioType)
                        return true;
                }

                return false;
            }

            private static bool HasConnectedInput(IOEntity ioEntity, int inputSlot)
            {
                return inputSlot < ioEntity.inputs.Length
                    && ioEntity.inputs[inputSlot].connectedTo.Get() != null;
            }

            private readonly int[] _defaultInputSlots = { 0 };

            private readonly Type[] _dontPowerPrefabsOfType =
            {
                typeof(ANDSwitch),
                typeof(CustomDoorManipulator),
                typeof(DoorManipulator),
                typeof(ORSwitch),
                typeof(RFBroadcaster),
                typeof(TeslaCoil),
                typeof(XORSwitch),

                // Has inputs to move the lift but does not consume power.
                typeof(Elevator),

                // Has inputs to toggle on/off but does not consume power.
                typeof(FuelGenerator),

                // Has audio input only.
                typeof(AudioVisualisationEntityLight),
                typeof(ConnectedSpeaker),

                // Has no power input.
                typeof(FogMachine),
                typeof(SnowMachine),
                typeof(StrobeLight),
            };

            private readonly Dictionary<string, int[]> _inputSlotsByPrefabName = new Dictionary<string, int[]>
            {
                ["assets/prefabs/deployable/playerioents/gates/combiner/electrical.combiner.deployed.prefab"] = new[] { 0, 1 },
                ["assets/prefabs/deployable/playerioents/fluidswitch/fluidswitch.prefab"] = new[] { 2 },
                ["assets/prefabs/deployable/playerioents/industrialconveyor/industrialconveyor.deployed.prefab"] = new[] { 1 },
                ["assets/prefabs/deployable/playerioents/industrialcrafter/industrialcrafter.deployed.prefab"] = new[] { 1 },
                ["assets/prefabs/deployable/playerioents/poweredwaterpurifier/poweredwaterpurifier.deployed.prefab"] = new[] { 1 },
            };

            private readonly Dictionary<uint, int[]> _inputSlotsByPrefabId = new Dictionary<uint, int[]>();

            private List<uint> _dontPowerPrefabIds = new List<uint>();

            public void OnServerInitialized()
            {
                foreach (var prefabPath in GameManifest.Current.entities)
                {
                    var ioEntity = FindPrefabComponent<IOEntity>(prefabPath);
                    if (ioEntity == null || !HasInput(ioEntity, IOType.Electric))
                        continue;

                    if (_dontPowerPrefabsOfType.Contains(ioEntity.GetType()))
                    {
                        _dontPowerPrefabIds.Add(ioEntity.prefabID);
                    }
                }

                foreach (var entry in _inputSlotsByPrefabName)
                {
                    var ioEntity = FindPrefabComponent<IOEntity>(entry.Key);
                    if (ioEntity == null)
                        continue;

                    _inputSlotsByPrefabId[ioEntity.prefabID] = entry.Value;
                }
            }

            public bool MaybeProvidePower(IOEntity ioEntity)
            {
                if (_dontPowerPrefabIds.Contains(ioEntity.prefabID))
                    return false;

                var providedPower = false;

                var inputSlotList = DeterminePowerInputSlots(ioEntity);

                foreach (var inputSlot in inputSlotList)
                {
                    if (inputSlot >= ioEntity.inputs.Length
                        || HasConnectedInput(ioEntity, inputSlot))
                        continue;

                    if (ioEntity.inputs[inputSlot].type != IOType.Electric)
                        continue;

                    ioEntity.UpdateFromInput(FreePowerAmount, inputSlot);
                    providedPower = true;
                }

                return providedPower;
            }

            private int[] DeterminePowerInputSlots(IOEntity ioEntity)
            {
                return _inputSlotsByPrefabId.TryGetValue(ioEntity.prefabID, out var inputSlots)
                    ? inputSlots
                    : _defaultInputSlots;
            }
        }

        #endregion

        #region Adapter Display Manager

        private class AdapterDisplayManager
        {
            private MonumentAddons _plugin;
            private UniqueNameRegistry _uniqueNameRegistry;
            private Configuration _config => _plugin._config;

            public const int HeaderSize = 25;
            public static readonly string Divider = $"<size={HeaderSize}>------------------------------</size>";
            public static readonly Vector3 ArrowVerticalOffeset = new Vector3(0, 0.5f, 0);

            private const float DisplayIntervalDurationFast = 0.01f;
            private const float DisplayIntervalDuration = 2;

            private class PlayerInfo
            {
                public Timer Timer;
                public ProfileController ProfileController;
                public TransformAdapter MovingAdapter;
                public CustomMonument MovingCustomMonument;
                public RealTimeSince RealTimeSinceShown;

                public float DisplayDurationSlow => DisplayIntervalDuration * 1.1f;
                public float DisplayDurationFast => Performance.report.frameTime / 1000f + 0.01f;

                public float GetDisplayDuration(BaseAdapter adapter)
                {
                    return MovingAdapter == adapter ? DisplayDurationFast : DisplayDurationSlow;
                }

                public float GetDisplayDuration(CustomMonument monument)
                {
                    return monument == MovingCustomMonument ? DisplayDurationFast : DisplayDurationSlow;
                }
            }

            private float DefaultDisplayDuration => _config.DebugDisplaySettings.DefaultDisplayDuration;
            private float DisplayDistanceSquared => Mathf.Pow(_config.DebugDisplaySettings.DisplayDistance, 2);
            private float DisplayDistanceAbbreviatedSquared => Mathf.Pow(_config.DebugDisplaySettings.DisplayDistanceAbbreviated, 2);

            private StringBuilder _sb = new StringBuilder(200);
            private Dictionary<ulong, PlayerInfo> _playerInfo = new Dictionary<ulong, PlayerInfo>();

            public AdapterDisplayManager(MonumentAddons plugin, UniqueNameRegistry uniqueNameRegistry)
            {
                _plugin = plugin;
                _uniqueNameRegistry = uniqueNameRegistry;
            }

            public void SetPlayerProfile(BasePlayer player, ProfileController profileController)
            {
                GetOrCreatePlayerInfo(player).ProfileController = profileController;
            }

            public void SetPlayerMovingAdapter(BasePlayer player, TransformAdapter adapter)
            {
                var playerInfo = GetOrCreatePlayerInfo(player);
                playerInfo.MovingAdapter = adapter;
                playerInfo.MovingCustomMonument = adapter is CustomAddonAdapter { IsValid: true } customAddonAdapter
                    ? customAddonAdapter.Component.GetComponent<CustomMonumentComponent>()?.Monument
                    : null;
            }

            public void ShowAllRepeatedly(BasePlayer player, float? duration = null, bool immediate = true)
            {
                var playerInfo = GetOrCreatePlayerInfo(player);

                if (immediate || playerInfo.Timer == null || playerInfo.Timer.Destroyed)
                {
                    playerInfo.RealTimeSinceShown = float.MaxValue;
                    ShowNearbyAdapters(player, player.transform.position, playerInfo);
                }

                if (playerInfo.Timer is { Destroyed: false })
                {
                    if (duration == 0)
                    {
                        playerInfo.Timer.Destroy();
                    }
                    else
                    {
                        var remainingTime = playerInfo.Timer.Repetitions * DisplayIntervalDurationFast;
                        var newDuration = duration > 0 ? duration.Value : Math.Max(remainingTime, DefaultDisplayDuration);
                        var newRepetitions = Math.Max(Mathf.CeilToInt(newDuration / DisplayIntervalDurationFast), 1);
                        playerInfo.Timer.Reset(delay: -1, repetitions: newRepetitions);
                    }
                    return;
                }

                duration ??= DefaultDisplayDuration;

                // Ensure repetitions is not 0 since that would result in infintire repetitions.
                var repetitions = Math.Max(Mathf.CeilToInt(duration.Value / DisplayIntervalDurationFast), 1);

                playerInfo.Timer = _plugin.timer.Repeat(DisplayIntervalDurationFast, repetitions, () =>
                {
                    if (player == null || player.IsDestroyed || !player.IsConnected)
                    {
                        playerInfo.Timer.Destroy();
                        _playerInfo.Remove(player.userID);
                        return;
                    }

                    ShowNearbyAdapters(player, player.transform.position, playerInfo);
                });
            }

            private Color DetermineColor(BaseAdapter adapter, PlayerInfo playerInfo, ProfileController profileController)
            {
                if (playerInfo.ProfileController != null && playerInfo.ProfileController != profileController)
                    return _config.DebugDisplaySettings.InactiveProfileColor;

                if (adapter is SpawnPointAdapter spawnPointAdapter)
                    return spawnPointAdapter.SpawnGroupAdapter.SpawnGroupData.Color ?? _config.DebugDisplaySettings.SpawnPointColor;

                if (adapter is SpawnGroupAdapter spawnGroupAdapter)
                    return spawnGroupAdapter.SpawnGroupData.Color ?? _config.DebugDisplaySettings.SpawnPointColor;

                if (adapter is PasteAdapter)
                    return _config.DebugDisplaySettings.PasteColor;

                if (adapter is CustomAddonAdapter)
                    return _config.DebugDisplaySettings.CustomAddonColor;

                return _config.DebugDisplaySettings.EntityColor;
            }

            private void AddCommonInfo(BasePlayer player, ProfileController profileController, BaseController controller, BaseAdapter adapter)
            {
                _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelProfile, profileController.Profile.Name));

                var monumentTierList = adapter.Monument.IsValid ? GetTierList(GetMonumentTierMask(adapter.Monument.Position)) : null;
                _sb.AppendLine(adapter.Monument is not IDynamicMonument && monumentTierList?.Count > 0
                    ? _plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelMonumentWithTier, adapter.Monument.UniqueDisplayName, controller.Adapters.Count, string.Join(", ", monumentTierList))
                    : _plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelMonument, adapter.Monument.UniqueDisplayName, controller.Adapters.Count));
            }

            private void ShowPuzzleInfo(BasePlayer player, EntityAdapter entityAdapter, PuzzleReset puzzleReset, Vector3 playerPosition, PlayerInfo playerInfo)
            {
                _sb.AppendLine($"<size=25>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderPuzzle)}</size>");
                _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPuzzlePlayersBlockReset, puzzleReset.playersBlockReset));

                if (puzzleReset.playersBlockReset)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlayerDetectionRadius, puzzleReset.playerDetectionRadius));
                    if (PuzzleReset.AnyPlayersWithinDistance(puzzleReset.playerDetectionOrigin, puzzleReset.playerDetectionRadius))
                    {
                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlayerDetectedInRadius));
                    }
                }

                _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPuzzleTimeBetweenResets, FormatTime(puzzleReset.timeBetweenResets)));

                var resetTimeElapsedField = typeof(PuzzleReset).GetField("resetTimeElapsed", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (resetTimeElapsedField != null)
                {
                    var resetTimeElapsed = (float)resetTimeElapsedField.GetValue(puzzleReset);
                    var timeRemaining = puzzleReset.GetResetSpacing() - resetTimeElapsed;
                    var nextResetMessage = timeRemaining > 0
                        ? FormatTime(timeRemaining)
                        : _plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPuzzleNextResetOverdue);

                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPuzzleNextReset, nextResetMessage));
                }

                if (entityAdapter != null)
                {
                    var profileController = entityAdapter.ProfileController;

                    var spawnGroupIdList = entityAdapter.EntityData.Puzzle?.SpawnGroupIds;
                    if (spawnGroupIdList != null)
                    {
                        List<string> spawnGroupNameList = null;

                        foreach (var spawnGroupId in spawnGroupIdList)
                        {
                            if (profileController.FindAdapter(spawnGroupId, entityAdapter.Monument) is not SpawnGroupAdapter spawnGroupAdapter)
                                continue;

                            spawnGroupNameList ??= Pool.GetList<string>();
                            spawnGroupNameList.Add(spawnGroupAdapter.SpawnGroupData.Name);

                            var spawnPointAdapter = FindClosestSpawnPointAdapter(spawnGroupAdapter, playerPosition);
                            if (spawnPointAdapter != null)
                            {
                                new Ddraw(player, playerInfo.GetDisplayDuration(spawnPointAdapter), DetermineColor(spawnPointAdapter, playerInfo, profileController))
                                    .Arrow(entityAdapter.Position + ArrowVerticalOffeset, spawnPointAdapter.Position + ArrowVerticalOffeset, 0.25f);
                            }
                        }

                        if (spawnGroupNameList != null)
                        {
                            _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPuzzleSpawnGroups, string.Join(", ", spawnGroupNameList)));
                            Pool.FreeList(ref spawnGroupNameList);
                        }
                    }
                }
            }

            private Ddraw CreateDrawer(BasePlayer player, BaseAdapter adapter, PlayerInfo playerInfo)
            {
                return new Ddraw(player, playerInfo.GetDisplayDuration(adapter), DetermineColor(adapter, playerInfo, adapter.ProfileController));
            }

            private void ShowEntityInfo(ref Ddraw drawer, BasePlayer player, EntityAdapter adapter, Vector3 playerPosition, PlayerInfo playerInfo)
            {
                var entityData = adapter.EntityData;
                var controller = adapter.Controller;
                var profileController = controller.ProfileController;

                var uniqueEntityName = _uniqueNameRegistry.GetUniqueShortName(entityData.PrefabName);

                _sb.Clear();
                _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderEntity, uniqueEntityName)}</size>");
                AddCommonInfo(player, profileController, controller, adapter);

                if (entityData.Skin != 0)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSkin, entityData.Skin));
                }

                if (entityData.Scale != 1)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelScale, entityData.Scale));
                }

                var vehicleVendor = adapter.Entity as VehicleVendor;
                if (vehicleVendor != null)
                {
                    var vehicleSpawner = vehicleVendor.GetVehicleSpawner();
                    if (vehicleSpawner != null)
                    {
                        drawer.Arrow(adapter.Position + new Vector3(0, 1.5f, 0), vehicleSpawner.transform.position, 0.25f);
                    }
                }

                var doorManipulator = adapter.Entity as DoorManipulator;
                if (doorManipulator != null && doorManipulator.targetDoor != null)
                {
                    drawer.Arrow(adapter.Position, doorManipulator.targetDoor.transform.position, 0.2f);
                }

                var cctvIdentifier = entityData.CCTV?.RCIdentifier;
                if (cctvIdentifier != null)
                {
                    var identifier = (adapter as CCTVEntityAdapter)?.GetIdentifier();
                    if (identifier != null)
                    {
                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelRCIdentifier, identifier));
                    }
                }

                var puzzleReset = (adapter.Entity as IOEntity)?.GetComponent<PuzzleReset>();
                if (puzzleReset != null)
                {
                    _sb.AppendLine(Divider);
                    ShowPuzzleInfo(player, adapter, puzzleReset, playerPosition, playerInfo);
                }

                drawer.Text(adapter.Position, _sb.ToString());
            }

            private void ShowPrefabInfo(ref Ddraw drawer, BasePlayer player, PrefabAdapter adapter, PlayerInfo playerInfo)
            {
                var prefabData = adapter.PrefabData;
                var controller = adapter.Controller;
                var profileController = controller.ProfileController;

                var uniqueEntityName = _uniqueNameRegistry.GetUniqueShortName(prefabData.PrefabName);

                _sb.Clear();
                _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderPrefab, uniqueEntityName)}</size>");
                AddCommonInfo(player, profileController, controller, adapter);

                var position = adapter.Position;
                drawer.Sphere(position, 0.25f);
                drawer.Text(position, _sb.ToString());
            }

            private void ShowSpawnPointInfo(BasePlayer player, SpawnPointAdapter adapter, SpawnGroupAdapter spawnGroupAdapter, PlayerInfo playerInfo, bool showGroupInfo)
            {
                var spawnPointData = adapter.SpawnPointData;
                var controller = adapter.Controller;
                var profileController = controller.ProfileController;
                var color = DetermineColor(adapter, playerInfo, profileController);
                var drawer = new Ddraw(player, playerInfo.GetDisplayDuration(adapter), color);

                var spawnGroupData = spawnGroupAdapter.SpawnGroupData;

                _sb.Clear();
                _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderSpawnPoint, spawnGroupData.Name)}</size>");
                AddCommonInfo(player, profileController, controller, adapter);

                var booleanProperties = new List<string>();

                if (spawnPointData.Exclusive)
                {
                    booleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPointExclusive));
                }

                if (spawnPointData.RandomRotation)
                {
                    booleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPointRandomRotation));
                }

                if (spawnPointData.SnapToGround)
                {
                    booleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPointSnapToGround));
                }

                if (spawnPointData.CheckSpace)
                {
                    booleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPointCheckSpace));
                }

                if (booleanProperties.Count > 0)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelFlags, string.Join(" | ", booleanProperties)));
                }

                if (spawnPointData.RandomRadius > 0)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPointRandomRadius, spawnPointData.RandomRadius));
                }

                if (spawnPointData.PlayerDetectionRadius > 0)
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlayerDetectionRadius, spawnPointData.PlayerDetectionRadius));
                }

                if (adapter.SpawnPoint.HasPlayersIntersecting())
                {
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlayerDetectedInRadius));
                }

                if (showGroupInfo)
                {
                    _sb.AppendLine(Divider);
                    _sb.AppendLine($"<size=25>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderSpawnGroup, spawnGroupData.Name)}</size>");

                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelSpawnPoints, spawnGroupData.SpawnPoints.Count));

                    var groupBooleanProperties = new List<string>();

                    if (spawnGroupData.InitialSpawn)
                    {
                        groupBooleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelInitialSpawn));
                    }

                    if (spawnGroupData.PreventDuplicates)
                    {
                        groupBooleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPreventDuplicates));
                    }

                    if (spawnGroupData.PauseScheduleWhileFull)
                    {
                        groupBooleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPauseScheduleWhileFull));
                    }

                    if (spawnGroupData.RespawnWhenNearestPuzzleResets)
                    {
                        groupBooleanProperties.Add(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelRespawnWhenNearestPuzzleResets) + (spawnGroupAdapter.AssociatedPuzzleReset == null ? " (!)" : ""));
                    }

                    if (groupBooleanProperties.Count > 0)
                    {
                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelFlags, string.Join(" | ", groupBooleanProperties)));
                    }

                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPopulation, spawnGroupAdapter.SpawnGroup.currentPopulation, spawnGroupData.MaxPopulation));
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelRespawnPerTick, spawnGroupData.SpawnPerTickMin, spawnGroupData.SpawnPerTickMax));

                    var spawnGroup = spawnGroupAdapter.SpawnGroup;
                    if (spawnGroup.WantsTimedSpawn())
                    {
                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelRespawnDelay, FormatTime(spawnGroup.respawnDelayMin), FormatTime(spawnGroup.respawnDelayMax)));

                        var nextSpawnTime = GetTimeToNextSpawn(spawnGroup);
                        if (!float.IsPositiveInfinity(nextSpawnTime))
                        {
                            var nextSpawnMessage = spawnGroupData.PauseScheduleWhileFull && spawnGroup.currentPopulation >= spawnGroup.maxPopulation
                                ? _plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelNextSpawnPaused)
                                : nextSpawnTime <= 0
                                    ? _plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelNextSpawnQueued)
                                    : FormatTime(Mathf.CeilToInt(nextSpawnTime));

                            _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelNextSpawn, nextSpawnMessage));
                        }
                    }

                    if (spawnGroupData.Prefabs.Count > 0)
                    {
                        var totalWeight = spawnGroupData.TotalWeight;

                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelEntities));
                        foreach (var prefabEntry in spawnGroupData.Prefabs)
                        {
                            var relativeChance = (float)prefabEntry.Weight / totalWeight;
                            var displayName = prefabEntry.CustomAddonName ?? _uniqueNameRegistry.GetUniqueShortName(prefabEntry.PrefabName);
                            if (prefabEntry.CustomAddonName != null && _plugin._customAddonManager.GetAddon(prefabEntry.CustomAddonName) == null)
                            {
                                displayName += " (!)";
                            }
                            _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelEntityDetail, displayName, prefabEntry.Weight, relativeChance));
                        }
                    }
                    else
                    {
                        _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelNoEntities));
                    }

                    foreach (var otherAdapter in spawnGroupAdapter.SpawnPointAdapters)
                    {
                        drawer.Arrow(otherAdapter.Position + ArrowVerticalOffeset, adapter.Position + ArrowVerticalOffeset, 0.25f);
                    }
                }

                drawer.Arrow(adapter.Position + ArrowVerticalOffeset, adapter.Rotation, 1f, 0.15f);
                drawer.Sphere(adapter.Position, 0.5f);
                drawer.Text(adapter.Position, _sb.ToString());

                if (spawnGroupData.RespawnWhenNearestPuzzleResets)
                {
                    _sb.Clear();

                    var puzzleReset = spawnGroupAdapter.AssociatedPuzzleReset;
                    if (puzzleReset != null)
                    {
                        ShowPuzzleInfo(player, null, spawnGroupAdapter.AssociatedPuzzleReset, player.transform.position, playerInfo);
                        var position = puzzleReset.transform.position;
                        drawer.Arrow(position + ArrowVerticalOffeset, adapter.Position + ArrowVerticalOffeset, 0.25f, color: DetermineColor(adapter, playerInfo, profileController));
                        drawer.Text(position, _sb.ToString());
                    }
                }
            }

            private void ShowPasteInfo(ref Ddraw drawer, BasePlayer player, PasteAdapter adapter)
            {
                var pasteData = adapter.PasteData;
                var controller = adapter.Controller;
                var profileController = controller.ProfileController;

                _sb.Clear();
                _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderPaste, pasteData.Filename)}</size>");
                AddCommonInfo(player, profileController, controller, adapter);
                if (pasteData.Args is { Length: > 0 })
                {
                    _sb.AppendLine(string.Join(" ", pasteData.Args));
                }

                drawer.Box(adapter.Bounds, 0.25f);
                drawer.Text(adapter.Position, _sb.ToString());
            }

            private void ShowCustomAddonInfo(ref Ddraw drawer, BasePlayer player, CustomAddonAdapter adapter)
            {
                var customAddonData = adapter.CustomAddonData;
                var controller = adapter.Controller;
                var profileController = controller.ProfileController;

                var addonDefinition = adapter.AddonDefinition;

                _sb.Clear();
                _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowHeaderCustom, customAddonData.AddonName)}</size>");
                _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlugin, addonDefinition.OwnerPlugin.Name));
                AddCommonInfo(player, profileController, controller, adapter);

                addonDefinition.DoDisplay(adapter.Component, customAddonData.GetSerializedData(), player, _sb, drawer.Duration);

                drawer.Text(adapter.Position, _sb.ToString());
            }

            private SpawnPointAdapter FindClosestSpawnPointAdapter(SpawnGroupAdapter spawnGroupAdapter, Vector3 origin)
            {
                SpawnPointAdapter closestSpawnPointAdapter = null;
                var closestDistanceSquared = float.MaxValue;

                foreach (var spawnPointAdapter in spawnGroupAdapter.SpawnPointAdapters)
                {
                    var adapterDistanceSquared = (spawnPointAdapter.Position - origin).sqrMagnitude;
                    if (adapterDistanceSquared < closestDistanceSquared)
                    {
                        closestSpawnPointAdapter = spawnPointAdapter;
                        closestDistanceSquared = adapterDistanceSquared;
                    }
                }

                return closestSpawnPointAdapter;
            }

            private SpawnPointAdapter FindClosestSpawnPointAdapterToRay(SpawnGroupAdapter spawnGroupAdapter, Ray ray)
            {
                SpawnPointAdapter closestSpawnPointAdapter = null;
                var highestDot = float.MinValue;

                foreach (var spawnPointAdapter in spawnGroupAdapter.SpawnPointAdapters)
                {
                    var dot = Vector3.Dot(ray.direction, (spawnPointAdapter.Position - ray.origin).normalized);
                    if (dot > highestDot)
                    {
                        closestSpawnPointAdapter = spawnPointAdapter;
                        highestDot = dot;
                    }
                }

                return closestSpawnPointAdapter;
            }

            private Vector3 GetClosestAdapterPosition(BaseAdapter adapter, Ray ray, out BaseAdapter closestAdapter)
            {
                if (adapter is TransformAdapter transformAdapter)
                {
                    closestAdapter = adapter;
                    return transformAdapter.Position;
                }

                if (adapter is SpawnGroupAdapter spawnGroupAdapter)
                {
                    var spawnPointAdapter = FindClosestSpawnPointAdapterToRay(spawnGroupAdapter, ray);
                    closestAdapter = spawnPointAdapter;
                    return spawnPointAdapter.Position;
                }

                closestAdapter = null;
                return Vector3.positiveInfinity;
            }

            private static bool IsWithinDistanceSquared(Vector3 position1, Vector3 position2, float distanceSquared)
            {
                return (position1 - position2).sqrMagnitude <= distanceSquared;
            }

            private static bool IsWithinDistanceSquared(TransformAdapter adapter, Vector3 position, float distanceSquared)
            {
                return IsWithinDistanceSquared(position, adapter.Position, distanceSquared);
            }

            private static void DrawAbbreviation(ref Ddraw drawer, TransformAdapter adapter)
            {
                drawer.Text(adapter.Position, "<size=25>*</size>");
            }

            private void DisplayMonument(BasePlayer player, PlayerInfo playerInfo, CustomMonument monument)
            {
                var drawer = new Ddraw(player, playerInfo.GetDisplayDuration(monument), _config.DebugDisplaySettings.CustomMonumentColor);

                // If an object is both a custom monument and an addon (perhaps even a custom addon),
                // don't show debug test since it will overlap.
                if (!_plugin._componentTracker.IsAddonComponent(monument.Object))
                {
                    _sb.Clear();
                    var monumentCount = _plugin._customMonumentManager.CountMonumentByName(monument.UniqueName);
                    _sb.AppendLine($"<size={HeaderSize}>{_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelCustomMonument, monument.UniqueDisplayName, monumentCount)}</size>");
                    _sb.AppendLine(_plugin.GetMessage(player.UserIDString, LangEntry.ShowLabelPlugin, monument.OwnerPlugin.Name));
                    drawer.Text(monument.Position, _sb.ToString());
                }

                drawer.Box(monument.BoundingBox);
            }

            private void ShowNearbyCustomMonuments(BasePlayer player, Vector3 playerPosition, PlayerInfo playerInfo)
            {
                foreach (var monument in _plugin._customMonumentManager.MonumentList)
                {
                    if (monument == playerInfo.MovingCustomMonument)
                        continue;

                    if (!monument.IsInBounds(playerPosition)
                        && (playerPosition - monument.ClosestPointOnBounds(playerPosition)).sqrMagnitude > DisplayDistanceSquared)
                        continue;

                    DisplayMonument(player, playerInfo, monument);
                }
            }

            private void DisplayAdapter(BasePlayer player, Vector3 playerPosition, PlayerInfo playerInfo,
                BaseAdapter adapter, BaseAdapter closestAdapter, float distanceSquared, ref int remainingToShow)
            {
                var drawer = CreateDrawer(player, adapter, playerInfo);

                switch (adapter)
                {
                    case EntityAdapter entityAdapter:
                    {
                        if (remainingToShow-- > 0 && distanceSquared <= DisplayDistanceSquared)
                        {
                            ShowEntityInfo(ref drawer, player, entityAdapter, playerPosition, playerInfo);
                        }
                        else
                        {
                            DrawAbbreviation(ref drawer, entityAdapter);
                        }

                        return;
                    }
                    case PrefabAdapter prefabAdapter:
                    {
                        if (remainingToShow-- > 0 && distanceSquared <= DisplayDistanceSquared)
                        {
                            ShowPrefabInfo(ref drawer, player, prefabAdapter, playerInfo);
                        }
                        else
                        {
                            DrawAbbreviation(ref drawer, prefabAdapter);
                        }

                        return;
                    }
                    case SpawnPointAdapter spawnPointAdapter:
                    {
                        // This case only occurs when calling for the adapter being moved.
                        ShowSpawnPointInfo(player, spawnPointAdapter, spawnPointAdapter.SpawnGroupAdapter, playerInfo, showGroupInfo: true);
                        return;
                    }
                    case SpawnGroupAdapter spawnGroupAdapter:
                    {
                        var closestSpawnPointAdapter = closestAdapter as SpawnPointAdapter;
                        if (closestAdapter == null)
                            return;

                        if (remainingToShow-- > 0 && distanceSquared <= DisplayDistanceSquared)
                        {
                            ShowSpawnPointInfo(player, closestSpawnPointAdapter, spawnGroupAdapter, playerInfo, showGroupInfo: true);
                        }
                        else
                        {
                            DrawAbbreviation(ref drawer, closestSpawnPointAdapter);
                        }

                        foreach (var spawnPointAdapter in spawnGroupAdapter.SpawnPointAdapters)
                        {
                            if (IsWithinDistanceSquared(spawnPointAdapter, playerPosition, DisplayDistanceAbbreviatedSquared))
                            {
                                if (spawnPointAdapter == closestSpawnPointAdapter)
                                    continue;

                                DrawAbbreviation(ref drawer, spawnPointAdapter);
                            }
                        }

                        return;
                    }
                    case PasteAdapter pasteAdapter:
                    {
                        if (remainingToShow-- > 0 && distanceSquared <= DisplayDistanceSquared)
                        {
                            ShowPasteInfo(ref drawer, player, pasteAdapter);
                        }
                        else
                        {
                            DrawAbbreviation(ref drawer, pasteAdapter);
                        }

                        return;
                    }
                    case CustomAddonAdapter customAddonAdapter:
                    {
                        if (remainingToShow-- > 0 && distanceSquared <= DisplayDistanceSquared)
                        {
                            ShowCustomAddonInfo(ref drawer, player, customAddonAdapter);
                        }
                        else
                        {
                            DrawAbbreviation(ref drawer, customAddonAdapter);
                        }

                        return;
                    }
                }
            }

            private void ShowNearbyAdapters(BasePlayer player, Vector3 playerPosition, PlayerInfo playerInfo)
            {
                var remainingToShow = _config.DebugDisplaySettings.MaxAddonsToShowUnabbreviated;

                var movingAdapter = playerInfo.MovingAdapter;
                if (movingAdapter != null)
                {
                    if (movingAdapter.IsValid)
                    {
                        DisplayAdapter(player, playerPosition, playerInfo, movingAdapter, movingAdapter, 0, ref remainingToShow);

                        var movingMonument = playerInfo.MovingCustomMonument;
                        if (movingMonument != null)
                        {
                            DisplayMonument(player, playerInfo, movingMonument);
                        }
                    }
                    else
                    {
                        playerInfo.MovingAdapter = null;
                        playerInfo.MovingCustomMonument = null;
                    }
                }

                if (playerInfo.RealTimeSinceShown < DisplayIntervalDuration)
                    return;

                playerInfo.RealTimeSinceShown = 0;

                var isAdmin = player.IsAdmin;
                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                ShowNearbyCustomMonuments(player, playerPosition, playerInfo);

                var headRay = player.eyes.HeadRay();

                foreach (var (adapter, closestAdapter, distanceSquared, _) in _plugin._profileManager.GetEnabledAdapters<BaseAdapter>()
                             .Where(adapter => adapter.IsValid)
                             .Select(adapter =>
                             {
                                 var position = GetClosestAdapterPosition(adapter, headRay, out var closestAdapter);
                                 var distanceSquared = (position - playerPosition).sqrMagnitude;
                                 return (adapter, closestAdapter, distanceSquared, position);
                             })
                             .Where(tuple => tuple.Item3 <= DisplayDistanceAbbreviatedSquared)
                             .OrderByDescending(tuple =>
                             {
                                 var dot = Vector3.Dot(headRay.direction, (tuple.Item4 - headRay.origin).normalized);
                                 if (tuple.Item3 > DisplayDistanceSquared)
                                 {
                                     dot -= 2;
                                 }
                                 return dot;
                             })
                         )
                {
                    if (adapter == playerInfo.MovingAdapter)
                        continue;

                    DisplayAdapter(player, playerPosition, playerInfo, adapter, closestAdapter, distanceSquared, ref remainingToShow);
                }

                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private PlayerInfo GetOrCreatePlayerInfo(BasePlayer player)
            {
                if (!_playerInfo.TryGetValue(player.userID, out var playerInfo))
                {
                    playerInfo = new PlayerInfo();
                    _playerInfo[player.userID] = playerInfo;
                }

                return playerInfo;
            }
        }

        #endregion

        #region Profile Management

        private enum ProfileStatus { Loading, Loaded, Unloading, Unloaded }

        private struct SpawnQueueItem
        {
            public BaseData Data;
            public BaseMonument Monument;
            public ICollection<BaseMonument> MonumentList;

            public SpawnQueueItem(BaseData data, ICollection<BaseMonument> monumentList)
            {
                Data = data;
                Monument = null;
                MonumentList = monumentList;
            }

            public SpawnQueueItem(BaseData data, BaseMonument monument)
            {
                Data = data;
                Monument = monument;
                MonumentList = null;
            }
        }

        private class ProfileController
        {
            public MonumentAddons Plugin { get; }
            public Profile Profile { get; private set; }
            public ProfileStatus ProfileStatus { get; private set; } = ProfileStatus.Unloaded;
            public WaitUntil WaitUntilLoaded;
            public WaitUntil WaitUntilUnloaded;

            private Configuration _config => Plugin._config;
            private StoredData _pluginData => Plugin._data;
            private ProfileManager _profileManager => Plugin._profileManager;
            private ProfileStateData _profileStateData => Plugin._profileStateData;

            private CoroutineManager _coroutineManager = new CoroutineManager();
            private Dictionary<BaseData, BaseController> _controllersByData = new Dictionary<BaseData, BaseController>();
            private Queue<SpawnQueueItem> _spawnQueue = new Queue<SpawnQueueItem>();

            public bool IsEnabled => _pluginData.IsProfileEnabled(Profile.Name);

            public ProfileController(MonumentAddons plugin, Profile profile, bool startLoaded = false)
            {
                Plugin = plugin;
                Profile = profile;
                WaitUntilLoaded = new WaitUntil(() => ProfileStatus == ProfileStatus.Loaded);
                WaitUntilUnloaded = new WaitUntil(() => ProfileStatus == ProfileStatus.Unloaded);

                if (startLoaded)
                {
                    SetProfileStatus(ProfileStatus.Loaded);
                }
            }

            public void OnControllerKilled(BaseController controller)
            {
                _controllersByData.Remove(controller.Data);
            }

            public Coroutine StartCoroutine(IEnumerator enumerator)
            {
                return _coroutineManager.StartCoroutine(enumerator);
            }

            public Coroutine StartCallbackRoutine(Coroutine coroutine, Action callback)
            {
                return _coroutineManager.StartCallbackRoutine(coroutine, callback);
            }

            public IEnumerable<T> GetControllers<T>() where T : BaseController
            {
                return _controllersByData.Values.OfType<T>();
            }

            public IEnumerable<T> GetAdapters<T>() where T : BaseAdapter
            {
                foreach (var controller in _controllersByData.Values)
                {
                    foreach (var adapter in controller.Adapters)
                    {
                        if (adapter is T adapterOfType)
                        {
                            yield return adapterOfType;
                            continue;
                        }

                        if (adapter is SpawnGroupAdapter spawnGroupAdapter)
                        {
                            foreach (var childAdapter in spawnGroupAdapter.SpawnPointAdapters.OfType<T>())
                            {
                                yield return childAdapter;
                            }
                        }
                    }
                }
            }

            public void Load(ProfileCounts profileCounts = null)
            {
                if (ProfileStatus == ProfileStatus.Loading || ProfileStatus == ProfileStatus.Loaded)
                    return;

                CleanOrphanedEntities();
                EnqueueAll(profileCounts);

                if (_spawnQueue.Count == 0)
                {
                    SetProfileStatus(ProfileStatus.Loaded);
                }
            }

            public void PreUnload()
            {
                _coroutineManager.Destroy();

                foreach (var controller in _controllersByData.Values.ToList())
                {
                    controller.PreUnload();
                }
            }

            public void DetachSavedEntities()
            {
                if (_controllersByData.Count == 0)
                    return;

                foreach (var controller in _controllersByData.Values.ToList())
                {
                    controller.DetachSavedEntities();
                }
            }

            public void Unload(IEnumerator cleanupRoutine = null)
            {
                if (ProfileStatus == ProfileStatus.Unloading || ProfileStatus == ProfileStatus.Unloaded)
                    return;

                SetProfileStatus(ProfileStatus.Unloading);
                CoroutineManager.StartGlobalCoroutine(UnloadRoutine(cleanupRoutine));
            }

            public void Reload(Profile newProfileData)
            {
                Interrupt();
                PreUnload();
                DetachSavedEntities();

                StartCoroutine(ReloadRoutine(newProfileData));
            }

            public IEnumerator PartialLoadForLateMonument(ICollection<BaseData> dataList, BaseMonument monument)
            {
                foreach (var data in dataList)
                {
                    Enqueue(new SpawnQueueItem(data, monument));
                }

                yield return WaitUntilLoaded;
            }

            public void SpawnNewData(BaseData data, ICollection<BaseMonument> monumentList)
            {
                if (ProfileStatus == ProfileStatus.Unloading || ProfileStatus == ProfileStatus.Unloaded)
                    return;

                Enqueue(new SpawnQueueItem(data, monumentList));
            }

            public void Rename(string newName)
            {
                _pluginData.RenameProfileReferences(Profile.Name, newName);
                Plugin._originalProfileStore.MoveTo(Profile, newName);
                Plugin._profileStore.MoveTo(Profile, newName);
            }

            public void Enable(Profile newProfileData)
            {
                if (IsEnabled)
                    return;

                Profile = newProfileData;
                _pluginData.SetProfileEnabled(Profile.Name);
                Load();
            }

            public void Disable()
            {
                Interrupt();
                PreUnload();

                IEnumerator cleanupRoutine = null;

                DetachSavedEntities();

                var entitiesToKill = _profileStateData.FindAndRemoveValidEntities(Profile.Name);
                if (entitiesToKill is { Count: > 0 })
                {
                    Plugin._saveProfileStateDebounced.Schedule();
                    cleanupRoutine = KillEntitiesRoutine(entitiesToKill);
                }

                Unload(cleanupRoutine);
            }

            public void Clear()
            {
                if (!IsEnabled)
                {
                    Profile.MonumentDataMap.Clear();
                    Plugin._profileStore.Save(Profile);
                    return;
                }

                Interrupt();
                StartCoroutine(ClearRoutine());
            }

            public BaseController FindControllerById(Guid guid)
            {
                foreach (var entry in _controllersByData)
                {
                    if (entry.Key.Id == guid)
                        return entry.Value;
                }

                return null;
            }

            public BaseAdapter FindAdapter(Guid guid, BaseMonument monument)
            {
                return FindControllerById(guid)?.FindAdapterForMonument(monument);
            }

            public T FindEntity<T>(Guid guid, BaseMonument monument) where T : BaseEntity
            {
                return _profileStateData.FindEntity(Profile.Name, monument, guid) as T
                    ?? (FindAdapter(guid, monument) as EntityAdapter)?.Entity as T;
            }

            public void SetupIO()
            {
                // Setup connections first.
                foreach (var entry in _controllersByData)
                {
                    var data = entry.Key;
                    var controller = entry.Value;

                    var entityData = data as EntityData;
                    if (entityData?.IOEntityData == null)
                        continue;

                    if (controller is not EntityController entityController)
                        continue;

                    foreach (var adapter in entityController.Adapters)
                    {
                        (adapter as EntityAdapter)?.UpdateIOConnections();
                    }
                }

                // Provide free power to unconnected entities.
                foreach (var entry in _controllersByData)
                {
                    if (entry.Value is not EntityController singleEntityController)
                        continue;

                    foreach (var adapter in singleEntityController.Adapters)
                    {
                        (adapter as EntityAdapter)?.MaybeProvidePower();
                    }
                }
            }

            private void Interrupt()
            {
                _coroutineManager.StopAll();
                _spawnQueue.Clear();
            }

            private BaseController GetController(BaseData data)
            {
                return _controllersByData.TryGetValue(data, out var controller)
                    ? controller
                    : null;
            }

            private BaseController EnsureController(BaseData data)
            {
                var controller = GetController(data);
                if (controller == null)
                {
                    controller = Plugin._controllerFactory.CreateController(this, data);
                    if (controller != null)
                    {
                        _controllersByData[data] = controller;
                    }
                }

                return controller;
            }

            private void Enqueue(SpawnQueueItem queueItem)
            {
                _spawnQueue.Enqueue(queueItem);

                // If there are more items in the queue, we can assume there's already a coroutine processing them.
                if (_spawnQueue.Count == 1)
                {
                    SetProfileStatus(ProfileStatus.Loading);
                    StartCoroutine(ProcessSpawnQueue());
                }
            }

            private void EnqueueAll(ProfileCounts profileCounts)
            {
                foreach (var entry in Profile.MonumentDataMap)
                {
                    var monumentData = entry.Value;
                    if (monumentData.NumSpawnables == 0)
                        continue;

                    var monumentIdentifier = entry.Key;
                    var matchingMonuments = Plugin.GetMonumentsByIdentifier(monumentIdentifier);
                    if (matchingMonuments == null)
                        continue;

                    if (profileCounts != null)
                    {
                        profileCounts.EntityCount += matchingMonuments.Count * monumentData.Entities.Count;
                        profileCounts.SpawnPointCount += matchingMonuments.Count * monumentData.NumSpawnPoints;
                        profileCounts.PasteCount += matchingMonuments.Count * monumentData.Pastes.Count;
                        profileCounts.PrefabCount += matchingMonuments.Count * monumentData.Prefabs.Count;
                    }

                    foreach (var data in monumentData.GetSpawnablesLazy())
                    {
                        Enqueue(new SpawnQueueItem(data, matchingMonuments));
                    }
                }
            }

            private void SetProfileStatus(ProfileStatus newStatus, bool broadcast = true)
            {
                var previousStatus = ProfileStatus;
                ProfileStatus = newStatus;
                if (broadcast)
                {
                    _profileManager.BroadcastProfileStateChanged(this, ProfileStatus, previousStatus);
                }
            }

            private IEnumerator ProcessSpawnQueue()
            {
                // Wait one frame to ensure the queue has time to be populated.
                yield return null;

                while (_spawnQueue.TryDequeue(out var queueItem))
                {
                    Plugin.TrackStart();
                    var controller = EnsureController(queueItem.Data);
                    Plugin.TrackEnd();

                    if (controller == null)
                    {
                        // The controller factory may not have been implemented for this data type,
                        // or the custom addon owner plugin may not be loaded.
                        continue;
                    }

                    if (queueItem.Monument != null)
                    {
                        // Check for null in case the monument is dynamic and was destroyed (e.g., cargo ship).
                        if (queueItem.Monument.IsValid)
                        {
                            // Prevent double spawning addons (e.g., if a dynamic monument spawns while a profile is loading).
                            if (controller.HasAdapterForMonument(queueItem.Monument))
                            {
                                LogWarning("Prevented double spawn");
                                continue;
                            }

                            try
                            {
                                controller.SpawnAtMonument(queueItem.Monument);
                            }
                            catch (Exception ex)
                            {
                                LogError($"Caught exception when spawning addon {queueItem.Data.Id}.\n{ex}");
                            }

                            yield return null;
                        }
                    }
                    else
                    {
                        yield return controller.SpawnAtMonumentsRoutine(queueItem.MonumentList);
                    }
                }

                SetProfileStatus(ProfileStatus.Loaded);
                SetupIO();
            }

            private IEnumerator UnloadRoutine(IEnumerator cleanupRoutine)
            {
                foreach (var controller in _controllersByData.Values.ToList())
                {
                    yield return controller.KillRoutine();
                }

                if (cleanupRoutine != null)
                    yield return cleanupRoutine;

                SetProfileStatus(ProfileStatus.Unloaded);
            }

            private IEnumerator ReloadRoutine(Profile newProfileData)
            {
                Unload();
                yield return WaitUntilUnloaded;

                Profile = newProfileData;

                Load();
                yield return WaitUntilLoaded;
            }

            private IEnumerator ClearRoutine()
            {
                Unload();
                yield return WaitUntilUnloaded;

                Profile.MonumentDataMap.Clear();
                Plugin._profileStore.Save(Profile);
                SetProfileStatus(ProfileStatus.Loaded);
            }

            private IEnumerator CleanEntitiesRoutine(ProfileState profileState, List<BaseEntity> entitiesToKill)
            {
                yield return KillEntitiesRoutine(entitiesToKill);

                if (profileState.CleanStaleEntityRecords() > 0)
                {
                    Plugin._saveProfileStateDebounced.Schedule();
                }
            }

            private void CleanOrphanedEntities()
            {
                var profileState = _profileStateData.GetProfileState(Profile.Name);
                if (profileState == null)
                    return;

                List<BaseEntity> entitiesToKill = null;

                foreach (var entityEntry in profileState.FindValidEntities())
                {
                    if (!Profile.HasEntity(entityEntry.MonumentUniqueName, entityEntry.Guid))
                    {
                        entitiesToKill ??= new List<BaseEntity>();
                        entitiesToKill.Add(entityEntry.Entity);
                    }
                }

                if (entitiesToKill is { Count: > 0 })
                {
                    CoroutineManager.StartGlobalCoroutine(CleanEntitiesRoutine(profileState, entitiesToKill));
                }
                else if (profileState.CleanStaleEntityRecords() > 0)
                {
                    Plugin._saveProfileStateDebounced.Schedule();
                }
            }
        }

        private class ProfileCounts
        {
            public int EntityCount;
            public int PrefabCount;
            public int SpawnPointCount;
            public int PasteCount;
        }

        private class ProfileInfo
        {
            public static List<ProfileInfo> GetList(StoredData pluginData, ProfileManager profileManager)
            {
                var profileNameList = ProfileStore.GetProfileNames();
                var profileInfoList = new List<ProfileInfo>(profileNameList.Length);

                foreach (var profileName in profileNameList)
                {
                    if (OriginalProfileStore.IsOriginalProfile(profileName))
                        continue;

                    profileInfoList.Add(new ProfileInfo
                    {
                        Name = profileName,
                        Enabled = pluginData.EnabledProfiles.Contains(profileName),
                        Profile = profileManager.GetCachedProfileController(profileName)?.Profile
                    });
                }

                return profileInfoList;
            }

            public string Name;
            public bool Enabled;
            public Profile Profile;
        }

        private class ProfileManager
        {
            private readonly MonumentAddons _plugin;
            private OriginalProfileStore _originalProfileStore;
            private readonly ProfileStore _profileStore;
            private List<ProfileController> _profileControllers = new List<ProfileController>();

            private Configuration _config => _plugin._config;
            private StoredData _pluginData => _plugin._data;

            public event Action<ProfileController, ProfileStatus, ProfileStatus> ProfileStatusChanged;

            public bool HasAnyEnabledDynamicMonuments
            {
                get
                {
                    foreach (var profileController in _profileControllers)
                    {
                        if (profileController is { IsEnabled: true, Profile.HasAnyDynamicMonuments: true })
                            return true;
                    }

                    return false;
                }
            }

            public ProfileManager(MonumentAddons plugin, OriginalProfileStore originalProfileStore, ProfileStore profileStore)
            {
                _plugin = plugin;
                _originalProfileStore = originalProfileStore;
                _profileStore = profileStore;
            }

            public void BroadcastProfileStateChanged(ProfileController profileController, ProfileStatus status, ProfileStatus previousStatus)
            {
                ProfileStatusChanged?.Invoke(profileController, status, previousStatus);
            }

            public bool HasDynamicMonument(BaseEntity entity)
            {
                foreach (var profileController in _profileControllers)
                {
                    if (profileController.Profile.HasDynamicMonument(entity))
                        return true;
                }

                return false;
            }

            public IEnumerator LoadAllProfilesRoutine()
            {
                foreach (var profileName in _pluginData.EnabledProfiles.ToList())
                {
                    ProfileController controller;
                    try
                    {
                        controller = GetProfileController(profileName);
                    }
                    catch (Exception ex)
                    {
                        _pluginData.SetProfileDisabled(profileName);
                        LogError($"Disabled profile {profileName} due to error: {ex.Message}");
                        continue;
                    }

                    if (controller == null)
                    {
                        _pluginData.SetProfileDisabled(profileName);
                        LogWarning($"Disabled profile {profileName} because its data file was not found.");
                        continue;
                    }

                    var profileCounts = new ProfileCounts();

                    controller.Load(profileCounts);
                    yield return controller.WaitUntilLoaded;

                    var profile = controller.Profile;
                    var byAuthor = !string.IsNullOrWhiteSpace(profile.Author) ? $" by {profile.Author}" : string.Empty;

                    var spawnablesSummaryList = new List<string>();
                    if (profileCounts.EntityCount > 0)
                    {
                        spawnablesSummaryList.Add($"{profileCounts.EntityCount} entities");
                    }

                    if (profileCounts.PrefabCount > 0)
                    {
                        spawnablesSummaryList.Add($"{profileCounts.PrefabCount} prefabs");
                    }

                    if (profileCounts.SpawnPointCount > 0)
                    {
                        spawnablesSummaryList.Add($"{profileCounts.SpawnPointCount} spawn points");
                    }

                    if (profileCounts.PasteCount > 0)
                    {
                        spawnablesSummaryList.Add($"{profileCounts.PasteCount} pastes");
                    }

                    var spawnablesSummary = spawnablesSummaryList.Count > 0
                        ? string.Join(", ", spawnablesSummaryList)
                        : "No addons spawned";

                    LogInfo($"Loaded profile {profile.Name}{byAuthor} ({spawnablesSummary}).");
                }
            }

            public void UnloadAllProfiles()
            {
                foreach (var profileController in _profileControllers)
                {
                    profileController.PreUnload();
                    profileController.DetachSavedEntities();
                }

                CoroutineManager.StartGlobalCoroutine(UnloadAllProfilesRoutine());
            }

            public IEnumerator PartialLoadForLateMonumentRoutine(BaseMonument monument)
            {
                foreach (var controller in _profileControllers.ToArray())
                {
                    if (!controller.IsEnabled)
                        continue;

                    if (!controller.Profile.MonumentDataMap.TryGetValue(monument.UniqueName, out var monumentData))
                        continue;

                    if (monumentData.NumSpawnables == 0)
                        continue;

                    yield return controller.PartialLoadForLateMonument(monumentData.GetSpawnables(), monument);
                }
            }

            public ProfileController GetCachedProfileController(string profileName)
            {
                var profileNameLower = profileName.ToLower();

                foreach (var cachedController in _profileControllers)
                {
                    if (cachedController.Profile.Name.ToLower() == profileNameLower)
                        return cachedController;
                }

                return null;
            }

            public ProfileController GetProfileController(string profileName)
            {
                var profileController = GetCachedProfileController(profileName);
                if (profileController != null)
                    return profileController;

                var profile = _profileStore.LoadIfExists(profileName);
                if (profile != null)
                {
                    var controller = new ProfileController(_plugin, profile);
                    _profileControllers.Add(controller);
                    return controller;
                }

                return null;
            }

            public ProfileController GetPlayerProfileController(string userId)
            {
                return _pluginData.SelectedProfiles.TryGetValue(userId, out var profileName)
                    ? GetProfileController(profileName)
                    : null;
            }

            public ProfileController GetPlayerProfileControllerOrDefault(string userId)
            {
                var controller = GetPlayerProfileController(userId);
                if (controller != null)
                    return controller;

                controller = GetProfileController(DefaultProfileName);
                return controller is { IsEnabled: true }
                    ? controller
                    : null;
            }

            public bool ProfileExists(string profileName)
            {
                var profileNameLower = profileName.ToLower();

                foreach (var cachedController in _profileControllers)
                {
                    if (cachedController.Profile.Name.ToLower() == profileNameLower)
                        return true;
                }

                return _profileStore.Exists(profileName);
            }

            public ProfileController CreateProfile(string profileName, string authorName)
            {
                var profile = _profileStore.Create(profileName, authorName);
                var controller = new ProfileController(_plugin, profile, startLoaded: true);
                _profileControllers.Add(controller);
                return controller;
            }

            public void DisableProfile(ProfileController profileController)
            {
                _pluginData.SetProfileDisabled(profileController.Profile.Name);
                profileController.Disable();
            }

            public void DeleteProfile(ProfileController profileController)
            {
                if (profileController.IsEnabled)
                {
                    DisableProfile(profileController);
                }

                _profileControllers.Remove(profileController);
                _originalProfileStore.Delete(profileController.Profile.Name);
                _profileStore.Delete(profileController.Profile.Name);
            }

            public IEnumerable<ProfileController> GetEnabledProfileControllers()
            {
                foreach (var profileControler in _profileControllers)
                {
                    if (profileControler.IsEnabled)
                        yield return profileControler;
                }
            }

            public IEnumerable<T> GetEnabledControllers<T>() where T : BaseController
            {
                foreach (var profileController in GetEnabledProfileControllers())
                {
                    foreach (var controller in profileController.GetControllers<T>())
                    {
                        yield return controller;
                    }
                }
            }

            public IEnumerable<T> GetEnabledAdapters<T>() where T : BaseAdapter
            {
                foreach (var profileControler in GetEnabledProfileControllers())
                {
                    foreach (var adapter in profileControler.GetAdapters<T>())
                    {
                        yield return adapter;
                    }
                }
            }

            public IEnumerable<T> GetEnabledAdaptersForMonument<T>(BaseMonument monument) where T : BaseAdapter
            {
                return GetEnabledAdapters<T>().Where(adapter => adapter.Monument.IsEquivalentTo(monument));
            }

            private IEnumerator UnloadAllProfilesRoutine()
            {
                foreach (var controller in _profileControllers)
                {
                    controller.Unload();
                    yield return controller.WaitUntilUnloaded;
                }
            }
        }

        #endregion

        #region Data

        #region Base Data

        private abstract class BaseData
        {
            [JsonProperty("Id", Order = -10)]
            public Guid Id;
        }

        private abstract class BaseTransformData : BaseData
        {
            [JsonProperty("SnapToTerrain", Order = -4, DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool SnapToTerrain;

            [JsonProperty("Position", Order = -3)]
            public Vector3 Position;

            // Kept for backwards compatibility.
            [JsonProperty("RotationAngle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float DeprecatedRotationAngle { set => RotationAngles = new Vector3(0, value, 0); }

            [JsonProperty("RotationAngles", Order = -2, DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 RotationAngles;

            [JsonProperty("OnTerrain")]
            public bool DepredcatedOnTerrain { set => SnapToTerrain = value; }
        }

        #endregion

        #region Prefab Data

        private class PrefabData : BaseTransformData
        {
            [JsonProperty("PrefabName", Order = -5)]
            public string PrefabName;
        }

        #endregion

        #region Entity Data

        private class BuildingBlockInfo
        {
            [JsonProperty("Grade")]
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(BuildingGrade.Enum.None)]
            public BuildingGrade.Enum Grade = BuildingGrade.Enum.None;
        }

        private class CCTVInfo
        {
            [JsonProperty("RCIdentifier", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string RCIdentifier;

            [JsonProperty("Pitch", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float Pitch;

            [JsonProperty("Yaw", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float Yaw;
        }

        private class SignArtistImage
        {
            [JsonProperty("Url")]
            public string Url;

            [JsonProperty("Raw", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Raw;
        }

        private class IOConnectionData
        {
            [JsonProperty("ConnectedToId")]
            public Guid ConnectedToId;

            [JsonProperty("Slot")]
            public int Slot;

            [JsonProperty("ConnectedToSlot")]
            public int ConnectedToSlot;

            [JsonProperty("ShowWire")]
            public bool ShowWire = true;

            [JsonProperty("Color", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(StringEnumConverter))]
            public WireColour Color;

            [JsonProperty("Points")]
            public Vector3[] Points;
        }

        private class IOEntityData
        {
            [JsonProperty("Outputs")]
            public List<IOConnectionData> Outputs = new List<IOConnectionData>();

            public IOConnectionData FindConnection(int slot)
            {
                foreach (var connectionData in Outputs)
                {
                    if (connectionData.Slot == slot)
                        return connectionData;
                }

                return null;
            }
        }

        private class PuzzleData
        {
            [JsonProperty("PlayersBlockReset")]
            public bool PlayersBlockReset;

            [JsonProperty("PlayerDetectionRadius")]
            public float PlayerDetectionRadius;

            [JsonProperty("SecondsBetweenResets")]
            public float SecondsBetweenResets;

            [JsonProperty("SpawnGroupIds", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<Guid> SpawnGroupIds;

            public bool ShouldSerializeSpawnGroupIds() => SpawnGroupIds?.Count > 0;

            public bool HasSpawnGroupId(Guid spawnGroupId)
            {
                return SpawnGroupIds?.Contains(spawnGroupId) ?? false;
            }

            public void AddSpawnGroupId(Guid spawnGroupId)
            {
                SpawnGroupIds ??= new List<Guid>();
                SpawnGroupIds.Add(spawnGroupId);
            }

            public void RemoveSpawnGroupId(Guid spawnGroupId)
            {
                SpawnGroupIds?.Remove(spawnGroupId);
            }
        }

        private class HeadData
        {
            private FieldInfo CurrentTrophyDataField = typeof(HuntingTrophy).GetField("CurrentTrophyData", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            public static HeadData FromHeadEntity(HeadEntity headEntity)
            {
                var trophyData = headEntity.CurrentTrophyData;

                var headData = new HeadData
                {
                    EntitySource = trophyData.entitySource,
                    HorseBreed = trophyData.horseBreed,
                    PlayerId = trophyData.playerId,
                    PlayerName = !string.IsNullOrEmpty(trophyData.playerName) ? trophyData.playerName : null,
                };

                if (trophyData.clothing?.Count > 0)
                {
                    headData.Clothing = trophyData.clothing.Select(itemId => new BasicItemData(itemId)).ToArray();
                }

                return headData;
            }

            public class BasicItemData
            {
                public readonly int ItemId;

                public BasicItemData(int itemId)
                {
                    ItemId = itemId;
                }
            }

            [JsonProperty("EntitySource")]
            public uint EntitySource;

            [JsonProperty("HorseBreed", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int HorseBreed;

            [JsonProperty("PlayerId", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong PlayerId;

            [JsonProperty("PlayerName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PlayerName;

            [JsonProperty("Clothing", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BasicItemData[] Clothing;

            public void ApplyToHuntingTrophy(HuntingTrophy huntingTrophy)
            {
                if (CurrentTrophyDataField == null)
                    return;

                if (CurrentTrophyDataField.GetValue(huntingTrophy) is not ProtoBuf.HeadData headData)
                {
                    headData = Pool.Get<ProtoBuf.HeadData>();
                    CurrentTrophyDataField.SetValue(huntingTrophy, headData);
                }

                headData.entitySource = EntitySource;
                headData.horseBreed = HorseBreed;
                headData.playerId = PlayerId;
                headData.playerName = PlayerName;
                headData.count = 1;

                if (Clothing?.Length > 0)
                {
                    headData.clothing = Pool.GetList<int>();
                    foreach (var itemData in Clothing)
                    {
                        headData.clothing.Add(itemData.ItemId);
                    }
                }
                else if (headData.clothing != null)
                {
                    Pool.FreeList(ref headData.clothing);
                }
            }
        }

        private class EntityData : BaseTransformData
        {
            [JsonProperty("PrefabName", Order = -5)]
            public string PrefabName;

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong Skin;

            [JsonProperty("EnabledFlags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BaseEntity.Flags EnabledFlags;

            [JsonProperty("DisabledFlags", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BaseEntity.Flags DisabledFlags;

            [JsonProperty("Puzzle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public PuzzleData Puzzle;

            [JsonProperty("Scale", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(1f)]
            public float Scale = 1;

            [JsonProperty("CardReaderLevel", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ushort CardReaderLevel;

            [JsonProperty("BuildingBlock", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public BuildingBlockInfo BuildingBlock;

            [JsonProperty("CCTV", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public CCTVInfo CCTV;

            [JsonProperty("SignArtistImages", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public SignArtistImage[] SignArtistImages;

            [JsonProperty("VendingProfile", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public object VendingProfile;

            [JsonProperty("IOEntity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public IOEntityData IOEntityData;

            [JsonProperty("SkullName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string SkullName;

            [JsonProperty("HeadData", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public HeadData HeadData;

            public void SetFlag(BaseEntity.Flags flag, bool? value)
            {
                switch (value)
                {
                    case true:
                        EnabledFlags |= flag;
                        DisabledFlags &= ~flag;
                        break;

                    case false:
                        EnabledFlags &= ~flag;
                        DisabledFlags |= flag;
                        break;

                    case null:
                        EnabledFlags &= ~flag;
                        DisabledFlags &= ~flag;
                        break;
                }
            }

            public bool? HasFlag(BaseEntity.Flags flag)
            {
                if (EnabledFlags.HasFlag(flag))
                    return true;

                if (DisabledFlags.HasFlag(flag))
                    return false;

                return null;
            }

            public void RemoveIOConnection(int slot)
            {
                if (IOEntityData == null)
                    return;

                for (var i = IOEntityData.Outputs.Count - 1; i >= 0; i--)
                {
                    if (IOEntityData.Outputs[i].Slot == slot)
                    {
                        IOEntityData.Outputs.RemoveAt(i);
                        break;
                    }
                }
            }

            public void AddIOConnection(IOConnectionData connectionData)
            {
                if (IOEntityData == null)
                {
                    IOEntityData = new IOEntityData();
                }

                RemoveIOConnection(connectionData.Slot);
                IOEntityData.Outputs.Add(connectionData);
            }

            public PuzzleData EnsurePuzzleData(PuzzleReset puzzleReset)
            {
                return Puzzle ??= new PuzzleData
                {
                    PlayersBlockReset = puzzleReset.playersBlockReset,
                    PlayerDetectionRadius = puzzleReset.playerDetectionRadius,
                    SecondsBetweenResets = puzzleReset.timeBetweenResets,
                };
            }
        }

        #endregion

        #region Spawn Group Data

        private class SpawnPointData : BaseTransformData
        {
            public struct Args
            {
                public bool? Exclusive;
                public bool? SnapToGround;
                public bool? CheckSpace;
                public bool? RandomRotation;
                public float? RandomRadius;
                public float? PlayerDetectionRadius;

                public void ApplyTo(SpawnPointData spawnPointData)
                {
                    spawnPointData.Exclusive = Exclusive ?? spawnPointData.Exclusive;
                    spawnPointData.SnapToGround = SnapToGround ?? spawnPointData.SnapToGround;
                    spawnPointData.CheckSpace = CheckSpace ?? spawnPointData.CheckSpace;
                    spawnPointData.RandomRotation = RandomRotation ?? spawnPointData.RandomRotation;
                    spawnPointData.RandomRadius = RandomRadius ?? spawnPointData.RandomRadius;
                    spawnPointData.PlayerDetectionRadius = PlayerDetectionRadius ?? spawnPointData.PlayerDetectionRadius;
                }
            }

            [JsonProperty("Exclusive", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Exclusive;

            [JsonProperty("SnapToGround", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool SnapToGround;

            [JsonProperty("DropToGround")]
            public bool DeprecatedDropToGround { set => SnapToGround = value; }

            [JsonProperty("CheckSpace", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool CheckSpace;

            [JsonProperty("RandomRotation", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool RandomRotation;

            [JsonProperty("RandomRadius", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float RandomRadius;

            [JsonProperty("PlayerDetectionRadius", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float PlayerDetectionRadius;
        }

        private class WeightedPrefabData
        {
            [JsonProperty("PrefabName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PrefabName;

            [JsonProperty("CustomAddonName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string CustomAddonName;

            [JsonProperty("Weight")]
            public int Weight = 1;
        }

        private class SpawnGroupData : BaseData
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Color", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color? Color;

            [JsonProperty("MaxPopulation")]
            public int MaxPopulation = 1;

            [JsonProperty("SpawnPerTickMin")]
            public int SpawnPerTickMin = 1;

            [JsonProperty("SpawnPerTickMax")]
            public int SpawnPerTickMax = 2;

            [JsonProperty("RespawnDelayMin")]
            public float RespawnDelayMin = 1500;

            [JsonProperty("RespawnDelayMax")]
            public float RespawnDelayMax = 2100;

            // Default to true for backwards compatibility.
            [JsonProperty("InitialSpawn")]
            public bool InitialSpawn = true;

            [JsonProperty("PreventDuplicates", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool PreventDuplicates;

            [JsonProperty("PauseScheduleWhileFull", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool PauseScheduleWhileFull;

            [JsonProperty("RespawnWhenNearestPuzzleResets", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool RespawnWhenNearestPuzzleResets;

            [JsonProperty("Prefabs")]
            public List<WeightedPrefabData> Prefabs = new List<WeightedPrefabData>();

            [JsonProperty("SpawnPoints")]
            public List<SpawnPointData> SpawnPoints = new List<SpawnPointData>();

            [JsonIgnore]
            public int TotalWeight
            {
                get
                {
                    var total = 0;
                    foreach (var prefabEntry in Prefabs)
                    {
                        total += prefabEntry.Weight;
                    }

                    return total;
                }
            }

            public List<WeightedPrefabData> FindCustomAddonMatches(string partialName)
            {
                return SearchUtils.FindCustomAddonMatches(Prefabs, prefabData => prefabData.CustomAddonName, partialName);
            }

            public List<WeightedPrefabData> FindPrefabMatches(string partialName, UniqueNameRegistry uniqueNameRegistry)
            {
                return SearchUtils.FindPrefabMatches(Prefabs, prefabData => prefabData.PrefabName, partialName, uniqueNameRegistry);
            }
        }

        #endregion

        #region Paste Data

        private class PasteData : BaseTransformData
        {
            [JsonProperty("Filename")]
            public string Filename;

            [JsonProperty("Args")]
            public string[] Args;
        }

        #endregion

        #region Custom Addon Data

        private class CustomAddonData : BaseTransformData
        {
            [JsonProperty("AddonName")]
            public string AddonName;

            [JsonProperty("PluginData", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private object PluginData;

            public JObject GetSerializedData()
            {
                return PluginData as JObject;
            }

            public CustomAddonData SetData(object data)
            {
                PluginData = data as JObject ?? (data != null ? JObject.FromObject(data) : null);
                return this;
            }
        }

        #endregion

        #region Profile Data

        private class ProfileSummaryEntry
        {
            public string MonumentName;
            public string AddonType;
            public string AddonName;
            public int Count;
        }

        private List<ProfileSummaryEntry> GetProfileSummary(IPlayer player, Profile profile)
        {
            var summary = new List<ProfileSummaryEntry>();

            var addonTypeEntity = GetMessage(player.Id, LangEntry.AddonTypeEntity);
            var addonTypePrefab = GetMessage(player.Id, LangEntry.AddonTypePrefab);
            var addonTypePaste = GetMessage(player.Id, LangEntry.AddonTypePaste);
            var addonTypeSpawnPoint = GetMessage(player.Id, LangEntry.AddonTypeSpawnPoint);
            var addonTypeCustom = GetMessage(player.Id, LangEntry.AddonTypeCustom);

            foreach (var monumentEntry in profile.MonumentDataMap)
            {
                var monumentName = monumentEntry.Key;
                var monumentData = monumentEntry.Value;

                var entryMap = new Dictionary<string, ProfileSummaryEntry>();

                foreach (var entityData in monumentData.Entities)
                {
                    var entityUniqueName = _uniqueNameRegistry.GetUniqueShortName(entityData.PrefabName);

                    if (!entryMap.TryGetValue(entityUniqueName, out var summaryEntry))
                    {
                        summaryEntry = new ProfileSummaryEntry
                        {
                            MonumentName = monumentName,
                            AddonType = addonTypeEntity,
                            AddonName = entityUniqueName,
                        };
                        entryMap[entityUniqueName] = summaryEntry;
                    }

                    summaryEntry.Count++;
                }

                foreach (var prefabData in monumentData.Prefabs)
                {
                    var uniqueName = _uniqueNameRegistry.GetUniqueShortName(prefabData.PrefabName);

                    if (!entryMap.TryGetValue(uniqueName, out var summaryEntry))
                    {
                        summaryEntry = new ProfileSummaryEntry
                        {
                            MonumentName = monumentName,
                            AddonType = addonTypePrefab,
                            AddonName = uniqueName,
                        };
                        entryMap[uniqueName] = summaryEntry;
                    }

                    summaryEntry.Count++;
                }

                foreach (var spawnGroupData in monumentData.SpawnGroups)
                {
                    if (spawnGroupData.SpawnPoints.Count == 0)
                        continue;

                    // Add directly to the summary since different spawn groups could have the same name.
                    summary.Add(new ProfileSummaryEntry
                    {
                        MonumentName = monumentName,
                        AddonType = addonTypeSpawnPoint,
                        AddonName = spawnGroupData.Name,
                        Count = spawnGroupData.SpawnPoints.Count,
                    });
                }

                foreach (var pasteData in monumentData.Pastes)
                {
                    if (!entryMap.TryGetValue(pasteData.Filename, out var summaryEntry))
                    {
                        summaryEntry = new ProfileSummaryEntry
                        {
                            MonumentName = monumentName,
                            AddonType = addonTypePaste,
                            AddonName = pasteData.Filename,
                        };
                        entryMap[pasteData.Filename] = summaryEntry;
                    }

                    summaryEntry.Count++;
                }

                foreach (var customAddonData in monumentData.CustomAddons)
                {
                    if (!entryMap.TryGetValue(customAddonData.AddonName, out var summaryEntry))
                    {
                        summaryEntry = new ProfileSummaryEntry
                        {
                            MonumentName = monumentName,
                            AddonType = addonTypeCustom,
                            AddonName = customAddonData.AddonName,
                        };
                        entryMap[customAddonData.AddonName] = summaryEntry;
                    }

                    summaryEntry.Count++;
                }

                summary.AddRange(entryMap.Values);
            }

            return summary;
        }

        private class MonumentData
        {
            [JsonProperty("Entities")]
            public List<EntityData> Entities = new List<EntityData>();

            public bool ShouldSerializeEntities() => Entities.Count > 0;

            [JsonProperty("Prefabs")]
            public List<PrefabData> Prefabs = new List<PrefabData>();

            public bool ShouldSerializePrefabs() => Prefabs.Count > 0;

            [JsonProperty("SpawnGroups")]
            public List<SpawnGroupData> SpawnGroups = new List<SpawnGroupData>();

            public bool ShouldSerializeSpawnGroups() => SpawnGroups.Count > 0;

            [JsonProperty("Pastes")]
            public List<PasteData> Pastes = new List<PasteData>();

            public bool ShouldSerializePastes() => Pastes.Count > 0;

            [JsonProperty("CustomAddons")]
            public List<CustomAddonData> CustomAddons = new List<CustomAddonData>();

            public bool ShouldSerializeCustomAddons() => CustomAddons.Count > 0;

            [JsonIgnore]
            public int NumSpawnables =>
                Entities.Count
                + Prefabs.Count
                + SpawnGroups.Count
                + Pastes.Count
                + CustomAddons.Count;

            [JsonIgnore]
            public int NumSpawnPoints
            {
                get
                {
                    var count = 0;
                    foreach (var spawnGroup in SpawnGroups)
                    {
                        count += spawnGroup.SpawnPoints.Count;
                    }

                    return count;
                }
            }

            public IEnumerable<BaseData> GetSpawnablesLazy()
            {
                foreach (var entityData in Entities)
                    yield return entityData;

                foreach (var prefabData in Prefabs)
                    yield return prefabData;

                foreach (var spawnGroupData in SpawnGroups)
                    yield return spawnGroupData;

                foreach (var pasteData in Pastes)
                    yield return pasteData;

                foreach (var customAddonData in CustomAddons)
                    yield return customAddonData;
            }

            public ICollection<BaseData> GetSpawnables()
            {
                var list = new List<BaseData>(NumSpawnables);
                foreach (var spawnable in GetSpawnablesLazy())
                {
                    list.Add(spawnable);
                }
                return list;
            }

            public bool HasEntity(Guid guid)
            {
                foreach (var entityData in Entities)
                {
                    if (entityData.Id == guid)
                        return true;
                }

                return false;
            }

            public bool HasSpawnGroup(Guid guid)
            {
                foreach (var spawnGroupData in SpawnGroups)
                {
                    if (spawnGroupData.Id == guid)
                        return true;
                }

                return false;
            }

            public void AddData(BaseData data)
            {
                if (data is EntityData entityData)
                {
                    Entities.Add(entityData);
                    return;
                }

                if (data is PrefabData prefabData)
                {
                    Prefabs.Add(prefabData);
                    return;
                }

                if (data is SpawnGroupData spawnGroupData)
                {
                    SpawnGroups.Add(spawnGroupData);
                    return;
                }

                if (data is PasteData pasteData)
                {
                    Pastes.Add(pasteData);
                    return;
                }

                if (data is CustomAddonData customAddonData)
                {
                    CustomAddons.Add(customAddonData);
                    return;
                }

                LogError($"AddData not implemented for type: {data.GetType()}");
            }

            public bool RemoveData(BaseData data)
            {
                if (data is EntityData entityData)
                    return Entities.Remove(entityData);

                if (data is PrefabData prefabData)
                    return Prefabs.Remove(prefabData);

                if (data is SpawnGroupData spawnGroupData)
                    return SpawnGroups.Remove(spawnGroupData);

                if (data is SpawnPointData spawnPointData)
                {
                    foreach (var parentSpawnGroupData in SpawnGroups)
                    {
                        var index = parentSpawnGroupData.SpawnPoints.IndexOf(spawnPointData);
                        if (index == -1)
                            continue;

                        // If removing the spawn group, don't remove the spawn point, so it's easier to undo.
                        if (parentSpawnGroupData.SpawnPoints.Count == 1)
                        {
                            SpawnGroups.Remove(parentSpawnGroupData);
                            CleanSpawnGroupReferences(parentSpawnGroupData.Id);
                        }
                        else
                        {
                            parentSpawnGroupData.SpawnPoints.RemoveAt(index);
                        }

                        return true;
                    }

                    return false;
                }

                if (data is PasteData pasteData)
                    return Pastes.Remove(pasteData);

                if (data is CustomAddonData customAddonData)
                    return CustomAddons.Remove(customAddonData);

                LogError($"RemoveData not implemented for type: {data.GetType()}");
                return false;
            }

            private void CleanSpawnGroupReferences(Guid id)
            {
                foreach (var entityData in Entities)
                {
                    entityData.Puzzle?.SpawnGroupIds?.Remove(id);
                }
            }
        }

        private static class ProfileDataMigration<T> where T : Profile
        {
            private static readonly Dictionary<string, string> _monumentNameCorrections = new Dictionary<string, string>
            {
                ["OilrigAI"] = "oilrig_2",
                ["OilrigAI2"] = "oilrig_1",
            };

            private static readonly Dictionary<string, string> _prefabCorrections = new Dictionary<string, string>
            {
                ["assets/content/vehicles/locomotive/locomotive.entity.prefab"] = "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab",
                ["assets/content/vehicles/workcart/workcart.entity.prefab"] = "assets/content/vehicles/trains/workcart/workcart.entity.prefab",
                ["assets/content/vehicles/workcart/workcart_aboveground.entity.prefab"] = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab",
                ["assets/content/vehicles/workcart/workcart_aboveground2.entity.prefab"] = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab",
                ["assets/content/vehicles/train/trainwagona.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagona.entity.prefab",
                ["assets/content/vehicles/train/trainwagonb.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab",
                ["assets/content/vehicles/train/trainwagonc.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab",
                ["assets/content/vehicles/train/trainwagonunloadablefuel.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagonunloadablefuel.entity.prefab",
                ["assets/content/vehicles/train/trainwagonunloadableloot.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagonunloadableloot.entity.prefab",
                ["assets/content/vehicles/train/trainwagonunloadable.entity.prefab"] = "assets/content/vehicles/trains/wagons/trainwagonunloadable.entity.prefab",
            };

            private static string GetPrefabCorrectionIfExists(string prefabName)
            {
                return _prefabCorrections.TryGetValue(prefabName, out var correctedPrefabName)
                    ? correctedPrefabName
                    : prefabName;
            }

            public static bool MigrateToLatest(T data)
            {
                // Using single | to avoid short-circuiting.
                return MigrateV0ToV1(data)
                    | MigrateV1ToV2(data)
                    | MigrateIncorrectPrefabs(data)
                    | MigrateIncorrectMonuments(data);
            }

            public static bool MigrateV0ToV1(T data)
            {
                if (data.SchemaVersion != 0)
                    return false;

                data.SchemaVersion++;

                var contentChanged = false;

                if (data.DeprecatedMonumentMap != null)
                {
                    foreach (var entityDataList in data.DeprecatedMonumentMap.Values)
                    {
                        if (entityDataList == null)
                            continue;

                        foreach (var entityData in entityDataList)
                        {
                            if (GetShortName(entityData.PrefabName) == "big_wheel"
                                && entityData.RotationAngles.x != 90)
                            {
                                // The plugin used to coerce the x component to 90.
                                entityData.RotationAngles.x = 90;
                                contentChanged = true;
                            }
                        }
                    }
                }

                return contentChanged;
            }

            public static bool MigrateV1ToV2(T data)
            {
                if (data.SchemaVersion != 1)
                    return false;

                data.SchemaVersion++;

                var contentChanged = false;

                if (data.DeprecatedMonumentMap != null)
                {
                    foreach (var entry in data.DeprecatedMonumentMap)
                    {
                        var entityDataList = entry.Value;
                        if (entityDataList == null || entityDataList.Count == 0)
                            continue;

                        data.MonumentDataMap[entry.Key] = new MonumentData
                        {
                            Entities = entityDataList,
                        };
                        contentChanged = true;
                    }

                    data.DeprecatedMonumentMap = null;
                }

                return contentChanged;
            }

            public static bool MigrateIncorrectPrefabs(T data)
            {
                var contentChanged = false;

                foreach (var monumentData in data.MonumentDataMap.Values)
                {
                    foreach (var entityData in monumentData.Entities)
                    {
                        var correctedPrefabName = GetPrefabCorrectionIfExists(entityData.PrefabName);
                        if (correctedPrefabName != entityData.PrefabName)
                        {
                            entityData.PrefabName = correctedPrefabName;
                            contentChanged = true;
                        }
                    }

                    foreach (var spawnGroupData in monumentData.SpawnGroups)
                    {
                        foreach (var prefabData in spawnGroupData.Prefabs)
                        {
                            // Custom addons won't have prefab name.
                            if (prefabData.PrefabName == null)
                                continue;

                            var correctedPrefabName = GetPrefabCorrectionIfExists(prefabData.PrefabName);
                            if (correctedPrefabName != prefabData.PrefabName)
                            {
                                prefabData.PrefabName = correctedPrefabName;
                                contentChanged = true;
                            }
                        }
                    }
                }

                return contentChanged;
            }

            public static bool MigrateIncorrectMonuments(T data)
            {
                var contentChanged = false;

                foreach (var entry in _monumentNameCorrections)
                {
                    if (!data.MonumentDataMap.TryGetValue(entry.Key, out var monumentData))
                        continue;

                    data.MonumentDataMap[entry.Value] = monumentData;
                    data.MonumentDataMap.Remove(entry.Key);
                    contentChanged = true;
                }

                return contentChanged;
            }
        }

        private class FileStore<T> where T : class, new()
        {
            protected string _directoryPath;

            public FileStore(string directoryPath)
            {
                _directoryPath = directoryPath + "/";
            }

            public virtual bool Exists(string filename)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(GetFilepath(filename));
            }

            public virtual T Load(string filename)
            {
                return Interface.Oxide.DataFileSystem.ReadObject<T>(GetFilepath(filename)) ?? new T();
            }

            public T LoadIfExists(string filename)
            {
                return Exists(filename)
                    ? Load(filename)
                    : default(T);
            }

            public void Save(string filename, T data)
            {
                Interface.Oxide.DataFileSystem.WriteObject(GetFilepath(filename), data);
            }

            public void Delete(string filename)
            {
                Interface.Oxide.DataFileSystem.DeleteDataFile(GetFilepath(filename));
            }

            protected virtual string GetFilepath(string filename)
            {
                return $"{_directoryPath}{filename}";
            }
        }

        private class OriginalProfileStore : FileStore<Profile>
        {
            public const string OriginalSuffix = "_original";

            public static bool IsOriginalProfile(string profileName)
            {
                return profileName.EndsWith(OriginalSuffix);
            }

            public OriginalProfileStore() : base(nameof(MonumentAddons)) {}

            protected override string GetFilepath(string profileName)
            {
                return base.GetFilepath(profileName + OriginalSuffix);
            }

            public void Save(Profile profile)
            {
                base.Save(profile.Name, profile);
            }

            public void MoveTo(Profile profile, string newName)
            {
                var original = LoadIfExists(profile.Name);
                if (original == null)
                    return;

                var oldName = original.Name;
                original.Name = newName;
                Save(original);
                Delete(oldName);
            }
        }

        private class ProfileStore : FileStore<Profile>
        {
            public static string[] GetProfileNames()
            {
                var filenameList = Interface.Oxide.DataFileSystem.GetFiles(nameof(MonumentAddons));

                for (var i = 0; i < filenameList.Length; i++)
                {
                    var filename = filenameList[i];
                    var start = filename.LastIndexOf(System.IO.Path.DirectorySeparatorChar) + 1;
                    var end = filename.LastIndexOf(".", StringComparison.Ordinal);
                    filenameList[i] = filename.Substring(start, end - start);
                }

                return filenameList;
            }

            public ProfileStore() : base(nameof(MonumentAddons)) {}

            public override bool Exists(string profileName)
            {
                return !OriginalProfileStore.IsOriginalProfile(profileName) && base.Exists(profileName);
            }

            public override Profile Load(string profileName)
            {
                if (OriginalProfileStore.IsOriginalProfile(profileName))
                    return null;

                var profile = base.Load(profileName);
                profile.Name = GetCaseSensitiveFileName(profileName);

                var migrated = ProfileDataMigration<Profile>.MigrateToLatest(profile);
                if (migrated)
                {
                    LogWarning($"Profile {profile.Name} has been automatically migrated.");
                }

                // Backfill ids if missing.
                foreach (var monumentData in profile.MonumentDataMap.Values)
                {
                    foreach (var entityData in monumentData.Entities)
                    {
                        if (entityData.Id == Guid.Empty)
                        {
                            entityData.Id = Guid.NewGuid();
                        }
                    }
                }

                if (migrated)
                {
                    Save(profile.Name, profile);
                }

                return profile;
            }

            public bool TryLoad(string profileName, out Profile profile, out string errorMessage)
            {
                try
                {
                    profile = Load(profileName);
                    errorMessage = null;
                    return true;
                }
                catch (JsonReaderException ex)
                {
                    profile = null;
                    errorMessage = ex.Message;
                    return false;
                }
            }

            public void Save(Profile profile)
            {
                base.Save(profile.Name, profile);
            }

            public Profile Create(string profileName, string authorName)
            {
                var profile = new Profile
                {
                    Name = profileName,
                    Author = authorName,
                };
                ProfileDataMigration<Profile>.MigrateToLatest(profile);
                Save(profile);
                return profile;
            }

            public void MoveTo(Profile profile, string newName)
            {
                var oldName = profile.Name;
                profile.Name = newName;
                Save(profile);
                Delete(oldName);
            }

            public void EnsureDefaultProfile()
            {
                Load(DefaultProfileName);
            }

            private string GetCaseSensitiveFileName(string profileName)
            {
                foreach (var name in GetProfileNames())
                {
                    if (StringUtils.EqualsCaseInsensitive(name, profileName))
                        return name;
                }

                return profileName;
            }
        }

        private class Profile
        {
            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Author", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Author;

            [JsonProperty("SchemaVersion", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float SchemaVersion;

            [JsonProperty("Url", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Url;

            [JsonProperty("Monuments", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, List<EntityData>> DeprecatedMonumentMap;

            [JsonProperty("MonumentData")]
            public Dictionary<string, MonumentData> MonumentDataMap = new Dictionary<string, MonumentData>();

            private HashSet<uint> _dynamicMonumentPrefabIds = new();
            private bool _hasDeterminedDynamicMonuments;

            [JsonIgnore]
            public bool HasAnyDynamicMonuments
            {
                get
                {
                    if (!_hasDeterminedDynamicMonuments)
                    {
                        DetermineDynamicMonuments();
                    }

                    return _dynamicMonumentPrefabIds.Count > 0;
                }
            }

            [OnDeserialized]
            private void OnDeserialized(StreamingContext context)
            {
                RenameDictKey(MonumentDataMap, CargoShipShortName, CargoShipPrefab);
            }

            public bool IsEmpty()
            {
                if (MonumentDataMap == null || MonumentDataMap.IsEmpty())
                    return true;

                foreach (var monumentData in MonumentDataMap.Values)
                {
                    if (monumentData.NumSpawnables > 0)
                        return false;
                }

                return true;
            }

            public bool HasEntity(string monumentUniqueName, Guid guid)
            {
                return MonumentDataMap.GetValueOrDefault(monumentUniqueName)?.HasEntity(guid) ?? false;
            }

            public bool HasEntity(string monumentUniqueName, EntityData entityData)
            {
                return MonumentDataMap.GetValueOrDefault(monumentUniqueName)?.Entities.Contains(entityData) ?? false;
            }

            public bool HasSpawnGroup(string monumentUniqueName, Guid guid)
            {
                return MonumentDataMap.GetValueOrDefault(monumentUniqueName)?.HasSpawnGroup(guid) ?? false;
            }

            public void AddData(string monumentUniqueName, BaseData data)
            {
                EnsureMonumentData(monumentUniqueName).AddData(data);
                DetermineDynamicMonuments();
            }

            public bool RemoveData(BaseData data, out string monumentUniqueName)
            {
                foreach (var entry in MonumentDataMap)
                {
                    if (entry.Value.RemoveData(data))
                    {
                        monumentUniqueName = entry.Key;
                        DetermineDynamicMonuments();
                        return true;
                    }
                }

                monumentUniqueName = null;
                return false;
            }

            public bool HasDynamicMonument(BaseEntity entity)
            {
                if (!_hasDeterminedDynamicMonuments)
                {
                    DetermineDynamicMonuments();
                }

                return _dynamicMonumentPrefabIds.Contains(entity.prefabID);
            }

            private MonumentData EnsureMonumentData(string monumentUniqueName)
            {
                if (!MonumentDataMap.TryGetValue(monumentUniqueName, out var monumentData))
                {
                    monumentData = new MonumentData();
                    MonumentDataMap[monumentUniqueName] = monumentData;
                }

                return monumentData;
            }

            private void DetermineDynamicMonuments()
            {
                _dynamicMonumentPrefabIds.Clear();

                foreach (var (monumentUniqueName, monumentData) in MonumentDataMap)
                {
                    if (monumentData.NumSpawnables == 0)
                        continue;

                    if (!monumentUniqueName.StartsWith("assets/"))
                        continue;

                    var baseEntity = FindPrefabBaseEntity(monumentUniqueName);
                    if (baseEntity != null)
                    {
                        _dynamicMonumentPrefabIds.Add(baseEntity.prefabID);
                    }
                }

                _hasDeterminedDynamicMonuments = true;
            }
        }

        #endregion

        #region Data File Utils

        private static class DataFileUtils
        {
            public static bool Exists(string filepath)
            {
                return Interface.Oxide.DataFileSystem.ExistsDatafile(filepath);
            }

            public static T Load<T>(string filepath) where T : class, new()
            {
                return Interface.Oxide.DataFileSystem.ReadObject<T>(filepath) ?? new T();
            }

            public static T LoadIfExists<T>(string filepath) where T : class, new()
            {
                return Exists(filepath) ? Load<T>(filepath) : null;
            }

            public static T LoadOrNew<T>(string filepath) where T : class, new()
            {
                return LoadIfExists<T>(filepath) ?? new T();
            }

            public static void Save<T>(string filepath, T data)
            {
                Interface.Oxide.DataFileSystem.WriteObject<T>(filepath, data);
            }
        }

        private class BaseDataFile
        {
            private string _filepath;

            public BaseDataFile(string filepath)
            {
                _filepath = filepath;
            }

            public void Save()
            {
                DataFileUtils.Save(_filepath, this);
            }
        }

        #endregion

        #region Profile State

        private struct MonumentEntityEntry
        {
            public string MonumentUniqueName;
            public Guid Guid;
            public BaseEntity Entity;

            public MonumentEntityEntry(string monumentUniqueName, Guid guid, BaseEntity entity)
            {
                MonumentUniqueName = monumentUniqueName;
                Guid = guid;
                Entity = entity;
            }
        }

        private class MonumentState : IDeepCollection
        {
            [JsonProperty("Entities")]
            public Dictionary<Guid, ulong> Entities = new Dictionary<Guid, ulong>();

            public bool HasItems()
            {
                return Entities.Count > 0;
            }

            public bool HasEntity(Guid guid, NetworkableId entityId)
            {
                return Entities.GetValueOrDefault(guid) == entityId.Value;
            }

            public BaseEntity FindEntity(Guid guid)
            {
                if (!Entities.TryGetValue(guid, out var entityId))
                    return null;

                var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(entityId)) as BaseEntity;
                if (entity == null || entity.IsDestroyed)
                    return null;

                return entity;
            }

            public void AddEntity(Guid guid, NetworkableId entityId)
            {
                Entities[guid] = entityId.Value;
            }

            public bool RemoveEntity(Guid guid)
            {
                return Entities.Remove(guid);
            }

            public IEnumerable<ValueTuple<Guid, BaseEntity>> FindValidEntities()
            {
                if (Entities.Count == 0)
                    yield break;

                foreach (var entry in Entities)
                {
                    var entity = FindValidEntity(entry.Value);
                    if (entity == null)
                        continue;

                    yield return new ValueTuple<Guid, BaseEntity>(entry.Key, entity);
                }
            }

            public int CleanStaleEntityRecords()
            {
                if (Entities.Count == 0)
                    return 0;

                var cleanedCount = 0;

                foreach (var entry in Entities.ToList())
                {
                    if (FindValidEntity(entry.Value) == null)
                    {
                        Entities.Remove(entry.Key);
                        cleanedCount++;
                    }
                }

                return cleanedCount;
            }
        }

        private class MonumentStateMapConverter : DictionaryKeyConverter<Vector3, MonumentState>
        {
            public override string KeyToString(Vector3 v)
            {
                return $"{v.x:g9},{v.y:g9},{v.z:g9}";
            }

            public override Vector3 KeyFromString(string key)
            {
                var parts = key.Split(',');
                return new Vector3(float.Parse(parts[0]), float.Parse(parts[1]), float.Parse(parts[2]));
            }
        }

        private class Vector3EqualityComparer : IEqualityComparer<Vector3>
        {
            public bool Equals(Vector3 a, Vector3 b)
            {
                return a == b;
            }

            public int GetHashCode(Vector3 vector)
            {
                return vector.GetHashCode();
            }
        }

        private class MonumentStateMap : IDeepCollection
        {
            [JsonProperty("ByLocation")]
            [JsonConverter(typeof(MonumentStateMapConverter))]
            private Dictionary<Vector3, MonumentState> ByLocation = new Dictionary<Vector3, MonumentState>(new Vector3EqualityComparer());

            public bool ShouldSerializeByLocation()
            {
                return HasDeepItems(ByLocation);
            }

            [JsonProperty("ByEntity")]
            private Dictionary<ulong, MonumentState> ByEntity = new Dictionary<ulong, MonumentState>();

            public bool ShouldSerializeByEntity()
            {
                return HasDeepItems(ByEntity);
            }

            public bool HasItems()
            {
                return HasDeepItems(ByLocation) || HasDeepItems(ByEntity);
            }

            public IEnumerable<ValueTuple<Guid, BaseEntity>> FindValidEntities()
            {
                foreach (var monumentState in ByLocation.Values)
                {
                    foreach (var entityEntry in monumentState.FindValidEntities())
                    {
                        yield return entityEntry;
                    }
                }

                foreach (var monumentEntry in ByEntity)
                {
                    var monumentEntityId = monumentEntry.Key;
                    if (FindValidEntity(monumentEntityId) == null)
                        continue;

                    foreach (var entityEntry in monumentEntry.Value.FindValidEntities())
                    {
                        yield return entityEntry;
                    }
                }
            }

            public int CleanStaleEntityRecords()
            {
                var cleanedCount = 0;

                if (ByLocation.Count > 0)
                {
                    foreach (var monumentState in ByLocation.Values)
                    {
                        cleanedCount += monumentState.CleanStaleEntityRecords();
                    }
                }

                if (ByEntity.Count > 0)
                {
                    foreach (var monumentEntry in ByEntity.ToList())
                    {
                        if (FindValidEntity(monumentEntry.Key) == null)
                        {
                            ByEntity.Remove(monumentEntry.Key);
                            continue;
                        }

                        cleanedCount += monumentEntry.Value.CleanStaleEntityRecords();
                    }
                }

                return cleanedCount;
            }

            public MonumentState GetMonumentState(BaseMonument monument)
            {
                if (monument is IEntityMonument entityMonument)
                    return ByEntity.GetValueOrDefault(entityMonument.EntityId.Value);

                return ByLocation.GetValueOrDefault(monument.Position);
            }

            public MonumentState GetOrCreateMonumentState(BaseMonument monument)
            {
                if (monument is IEntityMonument entityMonument)
                    return ByEntity.GetOrCreate(entityMonument.EntityId.Value);

                return ByLocation.GetOrCreate(monument.Position);
            }
        }

        private class ProfileState : Dictionary<string, MonumentStateMap>, IDeepCollection
        {
            [OnDeserialized]
            private void OnDeserialized(StreamingContext context)
            {
                RenameDictKey(this, CargoShipShortName, CargoShipPrefab);
            }

            public bool HasItems()
            {
                return HasDeepItems(this);
            }

            public int CleanStaleEntityRecords()
            {
                var cleanedCount = 0;

                foreach (var monumentStateMap in Values)
                {
                    cleanedCount += monumentStateMap.CleanStaleEntityRecords();
                }

                return cleanedCount;
            }

            public IEnumerable<MonumentEntityEntry> FindValidEntities()
            {
                if (Count == 0)
                    yield break;

                foreach (var (monumentIdentifier, monumentStateMap) in this)
                {
                    if (!monumentStateMap.HasItems())
                        continue;

                    foreach (var entityEntry in monumentStateMap.FindValidEntities())
                    {
                        yield return new MonumentEntityEntry(monumentIdentifier, entityEntry.Item1, entityEntry.Item2);
                    }
                }
            }
        }

        private class ProfileStateMap : Dictionary<string, ProfileState>, IDeepCollection
        {
            public ProfileStateMap() : base(StringComparer.InvariantCultureIgnoreCase) {}

            public bool HasItems()
            {
                return HasDeepItems(this);
            }
        }

        private class ProfileStateData : BaseDataFile
        {
            private static string Filepath => $"{nameof(MonumentAddons)}_State";

            public static ProfileStateData Load(StoredData pluginData)
            {
                var data = DataFileUtils.LoadOrNew<ProfileStateData>(Filepath);
                data._pluginData = pluginData;
                return data;
            }

            private StoredData _pluginData;

            public ProfileStateData() : base(Filepath) {}

            [JsonProperty("ProfileState", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private ProfileStateMap ProfileStateMap = new ProfileStateMap();

            public bool ShouldSerializeProfileStateMap()
            {
                return ProfileStateMap.HasItems();
            }

            public ProfileState GetProfileState(string profileName)
            {
                return ProfileStateMap.GetValueOrDefault(profileName);
            }

            public bool HasEntity(string profileName, BaseMonument monument, Guid guid, NetworkableId entityId)
            {
                return GetProfileState(profileName)
                    ?.GetValueOrDefault(monument.UniqueName)
                    ?.GetMonumentState(monument)
                    ?.HasEntity(guid, entityId) ?? false;
            }

            public BaseEntity FindEntity(string profileName, BaseMonument monument, Guid guid)
            {
                return GetProfileState(profileName)
                    ?.GetValueOrDefault(monument.UniqueName)
                    ?.GetMonumentState(monument)
                    ?.FindEntity(guid);
            }

            public void AddEntity(string profileName, BaseMonument monument, Guid guid, NetworkableId entityId)
            {
                ProfileStateMap.GetOrCreate(profileName)
                    .GetOrCreate(monument.UniqueName)
                    .GetOrCreateMonumentState(monument)
                    .AddEntity(guid, entityId);
            }

            public bool RemoveEntity(string profileName, BaseMonument monument, Guid guid)
            {
                return GetProfileState(profileName)
                    ?.GetValueOrDefault(monument.UniqueName)
                    ?.GetMonumentState(monument)
                    ?.RemoveEntity(guid) ?? false;
            }

            public List<BaseEntity> FindAndRemoveValidEntities(string profileName)
            {
                var profileState = ProfileStateMap.GetValueOrDefault(profileName);
                if (profileState == null)
                    return null;

                List<BaseEntity> entityList = null;

                foreach (var entityEntry in profileState.FindValidEntities())
                {
                    entityList ??= new List<BaseEntity>();
                    entityList.Add(entityEntry.Entity);
                }

                ProfileStateMap.Remove(profileName);

                return entityList;
            }

            public List<BaseEntity> CleanDisabledProfileState()
            {
                var entitiesToKill = new List<BaseEntity>();

                if (ProfileStateMap.Count == 0)
                    return entitiesToKill;

                var cleanedCount = 0;

                foreach (var entry in ProfileStateMap.ToList())
                {
                    var profileName = entry.Key;
                    var monumentStateMap = entry.Value;

                    if (_pluginData.IsProfileEnabled(profileName))
                        continue;

                    // Delete entities previously spawned for profiles which are now disabled.
                    // This addresses the use case where the plugin is unloaded with entity persistence enabled,
                    // then the data file is manually edited to disable a profile.
                    foreach (var entityEntry in monumentStateMap.FindValidEntities())
                    {
                        entitiesToKill.Add(entityEntry.Entity);
                    }

                    ProfileStateMap.Remove(profileName);
                    cleanedCount++;
                }

                if (cleanedCount > 0)
                {
                    Save();
                }

                return entitiesToKill;
            }

            public void Reset()
            {
                if (!ProfileStateMap.HasItems())
                    return;

                ProfileStateMap.Clear();
                Save();
            }
        }

        #endregion

        #region Plugin Data

        private static class StoredDataMigration
        {
            private static readonly Dictionary<string, string> MigrateMonumentNames = new Dictionary<string, string>
            {
                ["TRAIN_STATION"] = "TrainStation",
                ["BARRICADE_TUNNEL"] = "BarricadeTunnel",
                ["LOOT_TUNNEL"] = "LootTunnel",
                ["3_WAY_INTERSECTION"] = "Intersection",
                ["4_WAY_INTERSECTION"] = "LargeIntersection",
            };

            public static bool MigrateToLatest(ProfileStore profileStore, StoredData data)
            {
                // Using single | to avoid short-circuiting.
                return MigrateV0ToV1(data)
                    | MigrateV1ToV2(profileStore, data);
            }

            public static bool MigrateV0ToV1(StoredData data)
            {
                if (data.DataFileVersion != 0)
                    return false;

                data.DataFileVersion++;

                var contentChanged = false;

                if (data.DeprecatedMonumentMap != null)
                {
                    foreach (var monumentEntry in data.DeprecatedMonumentMap.ToList())
                    {
                        var alias = monumentEntry.Key;
                        var entityList = monumentEntry.Value;

                        if (MigrateMonumentNames.TryGetValue(alias, out var newAlias))
                        {
                            data.DeprecatedMonumentMap[newAlias] = entityList;
                            data.DeprecatedMonumentMap.Remove(alias);
                            alias = newAlias;
                        }

                        foreach (var entityData in entityList)
                        {
                            if (alias == "LootTunnel" || alias == "BarricadeTunnel")
                            {
                                // Migrate from the original rotations to the rotations used by MonumentFinder.
                                entityData.DeprecatedRotationAngle = (entityData.RotationAngles.y + 180) % 360;
                                entityData.Position = Quaternion.Euler(0, 180, 0) * entityData.Position;
                            }

                            // Migrate from the backwards rotations to the correct ones.
                            var newAngle = (720 - entityData.RotationAngles.y) % 360;
                            entityData.DeprecatedRotationAngle = newAngle;
                            contentChanged = true;
                        }
                    }
                }

                return contentChanged;
            }

            public static bool MigrateV1ToV2(ProfileStore profileStore, StoredData data)
            {
                if (data.DataFileVersion != 1)
                    return false;

                data.DataFileVersion++;

                var profile = new Profile
                {
                    Name = DefaultProfileName,
                };

                if (data.DeprecatedMonumentMap != null)
                {
                    profile.DeprecatedMonumentMap = data.DeprecatedMonumentMap;
                }

                profileStore.Save(profile);

                data.DeprecatedMonumentMap = null;
                data.EnabledProfiles.Add(DefaultProfileName);

                return true;
            }
        }

        private class StoredData
        {
            public static StoredData Load(ProfileStore profileStore)
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(nameof(MonumentAddons)) ?? new StoredData();

                var originalDataFileVersion = data.DataFileVersion;

                if (StoredDataMigration.MigrateToLatest(profileStore, data))
                {
                    LogWarning("Data file has been automatically migrated.");
                }

                if (data.DataFileVersion != originalDataFileVersion)
                {
                    data.Save();
                }

                return data;
            }

            [JsonProperty("DataFileVersion", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float DataFileVersion;

            [JsonProperty("EnabledProfiles")]
            public HashSet<string> EnabledProfiles = new HashSet<string>();

            [JsonProperty("SelectedProfiles")]
            public Dictionary<string, string> SelectedProfiles = new Dictionary<string, string>();

            [JsonProperty("Monuments", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Dictionary<string, List<EntityData>> DeprecatedMonumentMap;

            public void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(nameof(MonumentAddons), this);
            }

            public bool IsProfileEnabled(string profileName)
            {
                return EnabledProfiles.Contains(profileName);
            }

            public void SetProfileEnabled(string profileName)
            {
                EnabledProfiles.Add(profileName);
                Save();
            }

            public void SetProfileDisabled(string profileName)
            {
                if (!EnabledProfiles.Remove(profileName))
                    return;

                foreach (var entry in SelectedProfiles.ToList())
                {
                    if (entry.Value == profileName)
                    {
                        SelectedProfiles.Remove(entry.Key);
                    }
                }

                Save();
            }

            public void RenameProfileReferences(string oldName, string newName)
            {
                foreach (var entry in SelectedProfiles.ToList())
                {
                    if (entry.Value == oldName)
                    {
                        SelectedProfiles[entry.Key] = newName;
                    }
                }

                if (EnabledProfiles.Remove(oldName))
                {
                    EnabledProfiles.Add(newName);
                }

                Save();
            }

            public string GetSelectedProfileName(string userId)
            {
                if (SelectedProfiles.TryGetValue(userId, out var profileName))
                    return profileName;

                if (EnabledProfiles.Contains(DefaultProfileName))
                    return DefaultProfileName;

                return null;
            }

            public void SetProfileSelected(string userId, string profileName)
            {
                SelectedProfiles[userId] = profileName;
            }
        }

        #endregion

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class DebugDisplaySettings
        {
            [JsonProperty("Default display duration (seconds)")]
            public float DefaultDisplayDuration = 60;

            [JsonProperty("Display distance")]
            public float DisplayDistance = 100;

            [JsonProperty("Display distance abbreviated")]
            public float DisplayDistanceAbbreviated = 200;

            [JsonProperty("Max addons to show unabbreviated")]
            public int MaxAddonsToShowUnabbreviated = 1;

            [JsonProperty("Entity color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color EntityColor = Color.magenta;

            [JsonProperty("Spawn point color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color SpawnPointColor = new Color(1, 0.5f, 0);

            [JsonProperty("Paste color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color PasteColor = Color.cyan;

            [JsonProperty("Custom addon color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color CustomAddonColor = Color.green;

            [JsonProperty("Custom monument color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color CustomMonumentColor = Color.green;

            [JsonProperty("Inactive profile color")]
            [JsonConverter(typeof(HtmlColorConverter))]
            public Color InactiveProfileColor = Color.grey;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class EntitySaveSettings
        {
            [JsonProperty("Enable saving for storage entities")]
            public bool EnabledForStorageEntities;

            [JsonProperty("Enable saving for non-storage entities")]
            public bool EnabledForNonStorageEntities;

            [JsonProperty("Override saving enabled by prefab")]
            private Dictionary<string, bool> OverrideEnabledByPrefab = new();

            private Dictionary<uint, bool> _overrideEnabledByPrefabId = new();

            public void Init()
            {
                foreach (var (prefabPath, enabled) in OverrideEnabledByPrefab)
                {
                    var entity = FindPrefabBaseEntity(prefabPath);
                    if (entity == null)
                    {
                        LogError($"Invalid entity prefab in config: {prefabPath}");
                        continue;
                    }

                    _overrideEnabledByPrefabId[entity.prefabID] = enabled;
                }
            }

            public bool ShouldEnableSaving(BaseEntity entity)
            {
                if (_overrideEnabledByPrefabId.TryGetValue(entity.prefabID, out var enabled))
                    return enabled;

                if (entity is IItemContainerEntity or MiningQuarry)
                    return EnabledForStorageEntities;

                return EnabledForNonStorageEntities;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class DynamicMonumentSettings
        {
            [JsonProperty("Entity prefabs to consider as monuments")]
            public string[] DynamicMonumentPrefabs = { CargoShipPrefab };

            [JsonIgnore]
            private uint[] _dynamicMonumentPrefabIds;

            public void Init()
            {
                var prefabIds = new List<uint>();

                foreach (var prefabPath in DynamicMonumentPrefabs)
                {
                    var baseEntity = FindPrefabBaseEntity(prefabPath);
                    if (baseEntity == null)
                    {
                        LogError($"Invalid prefab path in configuration: {prefabPath}");
                        continue;
                    }

                    prefabIds.Add(baseEntity.prefabID);
                }

                _dynamicMonumentPrefabIds = prefabIds.ToArray();
            }

            public bool IsConfiguredAsDynamicMonument(BaseEntity entity)
            {
                return _dynamicMonumentPrefabIds.Contains(entity.prefabID);
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SpawnGroupDefaults
        {
            [JsonProperty(nameof(SpawnGroupOption.MaxPopulation))]
            private int MaxPopulation = 1;

            [JsonProperty(nameof(SpawnGroupOption.SpawnPerTickMin))]
            private int SpawnPerTickMin = 1;

            [JsonProperty(nameof(SpawnGroupOption.SpawnPerTickMax))]
            private int SpawnPerTickMax = 2;

            [JsonProperty(nameof(SpawnGroupOption.RespawnDelayMin))]
            private float RespawnDelayMin = 1500;

            [JsonProperty(nameof(SpawnGroupOption.RespawnDelayMax))]
            private float RespawnDelayMax = 2100;

            [JsonProperty(nameof(SpawnGroupOption.InitialSpawn))]
            private bool InitialSpawn = true;

            [JsonProperty(nameof(SpawnGroupOption.PreventDuplicates))]
            private bool PreventDuplicates;

            [JsonProperty(nameof(SpawnGroupOption.PauseScheduleWhileFull))]
            private bool PauseScheduleWhileFull;

            [JsonProperty(nameof(SpawnGroupOption.RespawnWhenNearestPuzzleResets))]
            private bool RespawnWhenNearestPuzzleResets;

            public SpawnGroupData ApplyTo(SpawnGroupData spawnGroupData)
            {
                spawnGroupData.MaxPopulation = MaxPopulation;
                spawnGroupData.SpawnPerTickMin = SpawnPerTickMin;
                spawnGroupData.SpawnPerTickMax = SpawnPerTickMax;
                spawnGroupData.RespawnDelayMin = RespawnDelayMin;
                spawnGroupData.RespawnDelayMax = RespawnDelayMax;
                spawnGroupData.InitialSpawn = InitialSpawn;
                spawnGroupData.PreventDuplicates = PreventDuplicates;
                spawnGroupData.PauseScheduleWhileFull = PauseScheduleWhileFull;
                spawnGroupData.RespawnWhenNearestPuzzleResets = RespawnWhenNearestPuzzleResets;
                return spawnGroupData;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SpawnPointDefaults
        {
            [JsonProperty(nameof(SpawnPointOption.Exclusive))]
            private bool Exclusive = true;

            [JsonProperty(nameof(SpawnPointOption.SnapToGround))]
            private bool SnapToGround = true;

            [JsonProperty(nameof(SpawnPointOption.CheckSpace))]
            private bool CheckSpace;

            [JsonProperty(nameof(SpawnPointOption.RandomRotation))]
            private bool RandomRotation;

            [JsonProperty(nameof(SpawnPointOption.RandomRadius))]
            private float RandomRadius;

            [JsonProperty(nameof(SpawnPointOption.PlayerDetectionRadius))]
            private float PlayerDetectionRadius;

            public SpawnPointData ApplyTo(SpawnPointData spawnPointData)
            {
                spawnPointData.Exclusive = Exclusive;
                spawnPointData.SnapToGround = SnapToGround;
                spawnPointData.CheckSpace = CheckSpace;
                spawnPointData.RandomRotation = RandomRotation;
                spawnPointData.RandomRadius = RandomRadius;
                spawnPointData.PlayerDetectionRadius = PlayerDetectionRadius;
                return spawnPointData;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PuzzleDefaults
        {
            [JsonProperty(nameof(PuzzleOption.PlayersBlockReset))]
            public bool PlayersBlockReset = true;

            [JsonProperty(nameof(PuzzleOption.PlayerDetectionRadius))]
            public float PlayerDetectionRadius = 30f;

            [JsonProperty(nameof(PuzzleOption.SecondsBetweenResets))]
            public float SecondsBetweenResets = 1800f;

            public PuzzleData ApplyTo(PuzzleData puzzleData)
            {
                puzzleData.PlayersBlockReset = PlayersBlockReset;
                puzzleData.PlayerDetectionRadius = PlayerDetectionRadius;
                puzzleData.SecondsBetweenResets = SecondsBetweenResets;
                return puzzleData;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class AddonDefaults
        {
            [JsonProperty("Spawn group defaults")]
            public SpawnGroupDefaults SpawnGroups = new();

            [JsonProperty("Spawn point defaults")]
            public SpawnPointDefaults SpawnPoints = new();

            [JsonProperty("Puzzle defaults")]
            public PuzzleDefaults Puzzles = new();
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Debug", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Debug = false;

            [JsonProperty("Debug display settings")]
            public DebugDisplaySettings DebugDisplaySettings = new();

            [JsonProperty("Debug display distance")]
            private float DeprecatedDebugDisplayDistance
            {
                set
                {
                    DebugDisplaySettings.DisplayDistance = value;
                    DebugDisplaySettings.DisplayDistanceAbbreviated = value * 2;
                }
            }

            [JsonProperty("Save entities between restarts/reloads to preserve their state throughout a wipe")]
            public EntitySaveSettings EntitySaveSettings = new();

            [JsonProperty("Persist entities while the plugin is unloaded")]
            private bool DeprecatedEnableEntitySaving
            {
                set
                {
                    EntitySaveSettings.EnabledForStorageEntities = value;
                    EntitySaveSettings.EnabledForNonStorageEntities = value;
                }
            }

            [JsonProperty("Dynamic monuments")]
            public DynamicMonumentSettings DynamicMonuments = new();

            [JsonProperty("Addon defaults")]
            public AddonDefaults AddonDefaults = new();

            [JsonProperty("Deployable overrides")]
            public Dictionary<string, string> DeployableOverrides = new Dictionary<string, string>
            {
                ["arcade.machine.chippy"] = "assets/bundled/prefabs/static/chippyarcademachine.static.prefab",
                ["autoturret"] = "assets/content/props/sentry_scientists/sentry.bandit.static.prefab",
                ["bbq"] = "assets/bundled/prefabs/static/bbq.static.prefab",
                ["boombox"] = "assets/prefabs/voiceaudio/boombox/boombox.static.prefab",
                ["box.repair.bench"] = "assets/bundled/prefabs/static/repairbench_static.prefab",
                ["cctv.camera"] = "assets/prefabs/deployable/cctvcamera/cctv.static.prefab",
                ["chair"] = "assets/bundled/prefabs/static/chair.static.prefab",
                ["computerstation"] = "assets/prefabs/deployable/computerstation/computerstation.static.prefab",
                ["connected.speaker"] = "assets/prefabs/voiceaudio/hornspeaker/connectedspeaker.deployed.static.prefab",
                ["hobobarrel"] = "assets/bundled/prefabs/static/hobobarrel_static.prefab",
                ["microphonestand"] = "assets/prefabs/voiceaudio/microphonestand/microphonestand.deployed.static.prefab",
                ["modularcarlift"] = "assets/bundled/prefabs/static/modularcarlift.static.prefab",
                ["research.table"] = "assets/bundled/prefabs/static/researchtable_static.prefab",
                ["samsite"] = "assets/prefabs/npc/sam_site_turret/sam_static.prefab",
                ["small.oil.refinery"] = "assets/bundled/prefabs/static/small_refinery_static.prefab",
                ["telephone"] = "assets/bundled/prefabs/autospawn/phonebooth/phonebooth.static.prefab",
                ["vending.machine"] = "assets/prefabs/deployable/vendingmachine/npcvendingmachine.prefab",
                ["wall.frame.shopfront.metal"] = "assets/bundled/prefabs/static/wall.frame.shopfront.metal.static.prefab",
                ["workbench1"] = "assets/bundled/prefabs/static/workbench1.static.prefab",
                ["workbench2"] = "assets/bundled/prefabs/static/workbench2.static.prefab",
            };

            [JsonProperty("Xmas tree decorations (item shortnames)")]
            public string[] XmasTreeDecorations =
            {
                "xmas.decoration.baubels",
                "xmas.decoration.candycanes",
                "xmas.decoration.gingerbreadmen",
                "xmas.decoration.lights",
                "xmas.decoration.pinecone",
                "xmas.decoration.star",
                "xmas.decoration.tinsel",
            };

            public void Init()
            {
                EntitySaveSettings.Init();
                DynamicMonuments.Init();

                if (XmasTreeDecorations != null)
                {
                    foreach (var itemShortName in XmasTreeDecorations)
                    {
                        var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                        if (itemDefinition == null)
                        {
                            LogError(($"Invalid item short name in config: {itemShortName}"));
                            continue;
                        }

                        if (itemDefinition.GetComponent<ItemModXMasTreeDecoration>() == null)
                        {
                            LogError(($"Item is not an Xmas tree decoration: {itemShortName}"));
                            continue;
                        }
                    }
                }
            }
        }

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public Dictionary<string, object> ToDictionary()
            {
                return JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
            }
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json)
            {
                return ToObject(JToken.Parse(json));
            }

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static List<LangEntry> AllLangEntries = new List<LangEntry>();

            public static readonly LangEntry0 NotApplicable = new("NotApplicable", "N/A");
            public static readonly LangEntry0 ErrorNoPermission = new("Error.NoPermission", "You don't have permission to do that.");
            public static readonly LangEntry0 ErrorMonumentFinderNotLoaded = new("Error.MonumentFinderNotLoaded", "Error: Monument Finder is not loaded.");
            public static readonly LangEntry0 ErrorNoMonuments = new("Error.NoMonuments", "Error: No monuments found.");
            public static readonly LangEntry2 ErrorNotAtMonument = new("Error.NotAtMonument", "Error: Not at a monument. Nearest is <color=#fd4>{0}</color> with distance <color=#fd4>{1}</color>");
            public static readonly LangEntry0 ErrorNoSuitableAddonFound = new("Error.NoSuitableAddonFound", "Error: No suitable addon found.");
            public static readonly LangEntry0 ErrorNoCustomAddonFound = new("Error.NoCustomAddonFound", "Error: No custom addon found.");
            public static readonly LangEntry0 ErrorEntityNotEligible = new("Error.EntityNotEligible", "Error: That entity is not managed by Monument Addons.");
            public static readonly LangEntry0 ErrorNoSpawnPointFound = new("Error.NoSpawnPointFound", "Error: No spawn point found.");
            public static readonly LangEntry2 ErrorSetSyntaxGeneric = new("Error.Set.Syntax.Generic2", "Syntax: <color=#fd4>{0} {1} <option> <value></color>");
            public static readonly LangEntry2 ErrorSetSyntax = new("Error.Set.Syntax", "Syntax: <color=#fd4>{0} set {1} <value></color>");
            public static readonly LangEntry1 ErrorSetUnknownOption = new("Error.Set.UnknownOption", "Unrecognized option: <color=#fd4>{0}</color>");

            public static readonly LangEntry0 WarningRecommendSpawnPoint = new("Warning.RecommandSpawnPoints", "<color=#fd4>Warning: It is not recommended to use /maspawn to place temporary entities such as NPCs, loot containers, and vehicles. Consider creating a spawn point for that entity instead.</color>");

            public static readonly LangEntry0 SpawnErrorSyntax = new("Spawn.Error.Syntax", "Syntax: <color=#fd4>maspawn <entity></color>");
            public static readonly LangEntry0 SpawnErrorNoProfileSelected = new("Spawn.Error.NoProfileSelected", "Error: No profile selected. Run <color=#fd4>maprofile help</color> for help.");
            public static readonly LangEntry1 SpawnErrorEntityNotFound = new("Spawn.Error.EntityNotFound2", "Error: No entity found matching name <color=#fd4>{0}</color>.");
            public static readonly LangEntry1 SpawnErrorEntityOrAddonNotFound = new("Spawn.Error.EntityOrCustomNotFound", "Error: No entity or custom addon found matching name <color=#fd4>{0}</color>.");
            public static readonly LangEntry0 SpawnErrorMultipleMatches = new("Spawn.Error.MultipleMatches", "Multiple matches:\n");
            public static readonly LangEntry0 ErrorNoSurface = new("Error.NoSurface", "Error: No valid surface found.");
            public static readonly LangEntry3 SpawnSuccess = new("Spawn.Success2", "Spawned entity at <color=#fd4>{0}</color> matching monument(s) and saved to <color=#fd4>{1}</color> profile for monument <color=#fd4>{2}</color>.");
            public static readonly LangEntry3 KillSuccess = new("Kill.Success4", "Killed <color=#fd4>{0}</color> at <color=#fd4>{1}</color> matching monument(s) and removed from profile <color=#fd4>{2}</color>. Run <color=#fd4>maundo</color> to restore it.");
            public static readonly LangEntry0 SaveNothingToDo = new("Save.NothingToDo", "No changes detected for that entity.");
            public static readonly LangEntry2 SaveSuccess = new("Save.Success", "Updated entity at <color=#fd4>{0}</color> matching monument(s) and saved to profile <color=#fd4>{1}</color>.");

            public static readonly LangEntry0 PrefabErrorSyntax = new("Prefab.Error.Syntax", "Syntax: <color=#fd4>maprefab <prefab></color>");
            public static readonly LangEntry1 PrefabErrorIsEntity = new("Prefab.Error.IsEntity", "Error: <color=#fd4>{0}</color> is an entity prefab. Use <color=#fd4>maspawn</color> instead of <color=#fd4>maprefab</color>.");
            public static readonly LangEntry1 PrefabErrorNotFound = new("Prefab.Error.NotFound", "Error: No allowed prefab found matching name <color=#fd4>{0}</color>.");
            public static readonly LangEntry3 PrefabSuccess = new("Prefab.Success", "Created prefab instance at <color=#fd4>{0}</color> matching monument(s) and saved to <color=#fd4>{1}</color> profile for monument <color=#fd4>{2}</color>.");

            public static readonly LangEntry0 UndoNotFound = new("Undo.NotFound", "No recent action to undo.");
            public static readonly LangEntry3 UndoKillSuccess = new("Undo.Kill.Success", "Successfully restored <color=#fd4>{0}</color> at monument <color=#fd4>{1}</color> in profile <color=#fd4>{2}</color>.");

            public static readonly LangEntry0 EditSynax = new("Edit.Syntax", "Syntax: <color=#fd4>maedit <addon-name> <arg1> <arg2> ...</color>");
            public static readonly LangEntry1 EditErrorNoMatch = new("Edit.Error.NoMatch", "Error: That custom addon does not have name <color=#fd4>{0}</color>.");
            public static readonly LangEntry1 EditErrorNotEditable = new("Edit.Error.NotEditable", "Error: The custom addon <color=#fd4>{0}</color> does not support editing.");
            public static readonly LangEntry1 EditSuccess = new("Edit.Success", "Successfully edited custom addon <color=#fd4>{0}</color>.");

            public static readonly LangEntry0 PasteNotCompatible = new("Paste.NotCompatible", "CopyPaste is not loaded or its version is incompatible.");
            public static readonly LangEntry0 PasteSyntax = new("Paste.Syntax2", "Syntax: <color=#fd4>mapaste <file> <arg1> <arg2> ...</color>");
            public static readonly LangEntry1 PasteNotFound = new("Paste.NotFound", "File <color=#fd4>{0}</color> does not exist.");
            public static readonly LangEntry4 PasteSuccess = new("Paste.Success", "Pasted <color=#fd4>{0}</color> at <color=#fd4>{1}</color> (x<color=#fd4>{2}</color>) and saved to profile <color=#fd4>{3}</color>.");

            public static readonly LangEntry0 AddonTypeUnknown = new("AddonType.Unknown", "Addon");
            public static readonly LangEntry0 AddonTypeEntity = new("AddonType.Entity", "Entity");
            public static readonly LangEntry0 AddonTypePrefab = new("AddonType.Prefab", "Prefab");
            public static readonly LangEntry0 AddonTypeSpawnPoint = new("AddonType.SpawnPoint", "Spawn point");
            public static readonly LangEntry0 AddonTypePaste = new("AddonType.Paste", "Paste");
            public static readonly LangEntry0 AddonTypeCustom = new("AddonType.Custom", "Custom");

            public static readonly LangEntry1 SpawnGroupCreateSyntax = new("SpawnGroup.Create.Syntax", "Syntax: <color=#fd4>{0} create <name></color>");
            public static readonly LangEntry3 SpawnGroupCreateNameInUse = new("SpawnGroup.Create.NameInUse", "There is already a spawn group named <color=#fd4>{0}</color> at monument <color=#fd4>{1}</color> in profile <color=#fd4>{2}</color>. Please use a different name.");
            public static readonly LangEntry1 SpawnGroupCreateSucces = new("SpawnGroup.Create.Success", "Successfully created spawn group <color=#fd4>{0}</color>.");
            public static readonly LangEntry3 SpawnGroupSetSuccess = new("SpawnGroup.Set.Success", "Successfully updated spawn group <color=#fd4>{0}</color> with option <color=#fd4>{1}</color>: <color=#fd4>{2}</color>.");
            public static readonly LangEntry1 SpawnGroupAddSyntax = new("SpawnGroup.Add.Syntax", "Syntax: <color=#fd4>{0} add <entity> <weight></color>");
            public static readonly LangEntry3 SpawnGroupAddSuccess = new("SpawnGroup.Add.Success", "Successfully added entity <color=#fd4>{0}</color> with weight <color=#fd4>{1}</color> to spawn group <color=#fd4>{2}</color>.");
            public static readonly LangEntry1 SpawnGroupRemoveSyntax = new("SpawnGroup.Remove.Syntax2", "Syntax: <color=#fd4>{0} remove <entity></color>");
            public static readonly LangEntry2 SpawnGroupRemoveMultipleMatches = new("SpawnGroup.Remove.MultipleMatches", "Multiple entities in spawn group <color=#fd4>{0}</color> found matching: <color=#fd4>{1}</color>. Please be more specific.");
            public static readonly LangEntry2 SpawnGroupRemoveNoMatch = new("SpawnGroup.Remove.NoMatch", "No entity found in spawn group <color=#fd4>{0}</color> matching <color=#fd4>{1}</color>");
            public static readonly LangEntry2 SpawnGroupRemoveSuccess = new("SpawnGroup.Remove.Success", "Successfully removed entity <color=#fd4>{0}</color> from spawn group <color=#fd4>{1}</color>.");

            public static readonly LangEntry1 SpawnGroupNotFound = new("SpawnGroup.NotFound", "No spawn group found with name: <color=#fd4>{0}</color>");
            public static readonly LangEntry1 SpawnGroupMultipeMatches = new("SpawnGroup.MultipeMatches2", "Multiple spawn groups found matching name: <color=#fd4>{0}</color>");
            public static readonly LangEntry1 SpawnPointCreateSyntax = new("SpawnPoint.Create.Syntax", "Syntax: <color=#fd4>{0} create <group_name></color>");
            public static readonly LangEntry1 SpawnPointCreateSuccess = new("SpawnPoint.Create.Success", "Successfully added spawn point to spawn group <color=#fd4>{0}</color>.");
            public static readonly LangEntry2 SpawnPointSetSuccess = new("SpawnPoint.Set.Success", "Successfully updated spawn point with option <color=#fd4>{0}</color>: <color=#fd4>{1}</color>.");
            public static readonly LangEntry2 SpawnPointSetAllSuccess = new("SpawnPoint.SetAll.Success", "Successfully updated all spawn points in that spawn group with option <color=#fd4>{0}</color>: <color=#fd4>{1}</color>.");

            public static readonly LangEntry0 SpawnGroupHelpHeader = new("SpawnGroup.Help.Header", "<size=18>Monument Addons Spawn Group Commands</size>");
            public static readonly LangEntry1 SpawnGroupHelpCreate = new("SpawnGroup.Help.Create", "<color=#fd4>{0} create <name></color> - Create a spawn group with a spawn point");
            public static readonly LangEntry1 SpawnGroupHelpSet = new("SpawnGroup.Help.Set", "<color=#fd4>{0} set <option> <value></color> - Set a property of a spawn group");
            public static readonly LangEntry1 SpawnGroupHelpAdd = new("SpawnGroup.Help.Add", "<color=#fd4>{0} add <entity> <weight></color> - Add an entity prefab to a spawn group");
            public static readonly LangEntry1 SpawnGroupHelpRemove = new("SpawnGroup.Help.Remove", "<color=#fd4>{0} remove <entity> <weight></color> - Remove an entity prefab from a spawn group");
            public static readonly LangEntry1 SpawnGroupHelpSpawn = new("SpawnGroup.Help.Spawn", "<color=#fd4>{0} spawn</color> - Run one spawn tick for a spawn group");
            public static readonly LangEntry1 SpawnGroupHelpRespawn = new("SpawnGroup.Help.Respawn", "<color=#fd4>{0} respawn</color> - Despawn entities for a spawn group and run one spawn tick");

            public static readonly LangEntry0 SpawnPointHelpHeader = new("SpawnPoint.Help.Header", "<size=18>Monument Addons Spawn Point Commands</size>");
            public static readonly LangEntry1 SpawnPointHelpCreate = new("SpawnPoint.Help.Create", "<color=#fd4>{0} create <group_name></color> - Create a spawn point");
            public static readonly LangEntry1 SpawnPointHelpSet = new("SpawnPoint.Help.Set", "<color=#fd4>{0} set <option> <value></color> - Set a property of a spawn point");

            public static readonly LangEntry0 SpawnGroupSetHelpName = new("SpawnGroup.Set.Help.Name", "<color=#fd4>Name</color>: string");
            public static readonly LangEntry0 SpawnGroupSetHelpColor = new("SpawnGroup.Set.Help.Color", "<color=#fd4>Color</color>: string");
            public static readonly LangEntry0 SpawnGroupSetHelpMaxPopulation = new("SpawnGroup.Set.Help.MaxPopulation", "<color=#fd4>MaxPopulation</color>: number");
            public static readonly LangEntry0 SpawnGroupSetHelpRespawnDelayMin = new("SpawnGroup.Set.Help.RespawnDelayMin", "<color=#fd4>RespawnDelayMin</color>: number");
            public static readonly LangEntry0 SpawnGroupSetHelpRespawnDelayMax = new("SpawnGroup.Set.Help.RespawnDelayMax", "<color=#fd4>RespawnDelayMax</color>: number");
            public static readonly LangEntry0 SpawnGroupSetHelpSpawnPerTickMin = new("SpawnGroup.Set.Help.SpawnPerTickMin", "<color=#fd4>SpawnPerTickMin</color>: number");
            public static readonly LangEntry0 SpawnGroupSetHelpSpawnPerTickMax = new("SpawnGroup.Set.Help.SpawnPerTickMax", "<color=#fd4>SpawnPerTickMax</color>: number");
            public static readonly LangEntry0 SpawnGroupSetHelpInitialSpawn = new("SpawnGroup.Set.Help.InitialSpawn", "<color=#fd4>InitialSpawn</color>: true | false");
            public static readonly LangEntry0 SpawnGroupSetHelpPreventDuplicates = new("SpawnGroup.Set.Help.PreventDuplicates", "<color=#fd4>PreventDuplicates</color>: true | false");
            public static readonly LangEntry0 SpawnGroupSetHelpPauseScheduleWhileFull = new("SpawnGroup.Set.Help.PauseScheduleWhileFull","<color=#fd4>PauseScheduleWhileFull</color>: true | false");
            public static readonly LangEntry0 SpawnGroupSetHelpRespawnWhenNearestPuzzleResets = new("SpawnGroup.Set.Help.RespawnWhenNearestPuzzleResets","<color=#fd4>RespawnWhenNearestPuzzleResets</color>: true | false");

            public static readonly LangEntry0 SpawnPointSetHelpExclusive = new("SpawnPoint.Set.Help.Exclusive", "<color=#fd4>Exclusive</color>: true | false");
            public static readonly LangEntry0 SpawnPointSetHelpSnapToGround = new("SpawnPoint.Set.Help.SnapToGround", "<color=#fd4>SnapToGround</color>: true | false");
            public static readonly LangEntry0 SpawnPointSetHelpCheckSpace = new("SpawnPoint.Set.Help.CheckSpace", "<color=#fd4>CheckSpace</color>: true | false");
            public static readonly LangEntry0 SpawnPointSetHelpRandomRotation = new("SpawnPoint.Set.Help.RandomRotation", "<color=#fd4>RandomRotation</color>: true | false");
            public static readonly LangEntry0 SpawnPointSetHelpRandomRadius = new("SpawnPoint.Set.Help.RandomRadius", "<color=#fd4>RandomRadius</color>: number");
            public static readonly LangEntry0 SpawnPointSetHelpPlayerDetectionRadius = new("SpawnPoint.Set.Help.PlayerDetectionRadius", "<color=#fd4>PlayerDetectionRadius</color>: number");

            public static readonly LangEntry1 PuzzleAddSpawnGroupSyntax = new("Puzzle.AddSpawnGroup.Syntax", "Syntax: <color=#fd4>{0} add <group_name></color>");
            public static readonly LangEntry1 PuzzleAddSpawnGroupSuccess = new("Puzzle.AddSpawnGroup.Success", "Successfully added spawn group <color=#fd4>{0}</color> to puzzle.");
            public static readonly LangEntry1 PuzzleRemoveSpawnGroupSyntax = new("Puzzle.RemoveSpawnGroup.Syntax", "Syntax: <color=#fd4>{0} remove <group_name></color>");
            public static readonly LangEntry1 PuzzleRemoveSpawnGroupSuccess = new("Puzzle.RemoveSpawnGroup.Success", "Successfully removed spawn group <color=#fd4>{0}</color> from puzzle.");
            public static readonly LangEntry0 PuzzleNotPresent = new("Puzzle.Error.NotPresent", "That is not a puzzle entity.");
            public static readonly LangEntry1 PuzzleNotConnected = new("Puzzle.Error.NotConnected", "Entity <color=#fd4>{0}</color> is not connected to a puzzle.");
            public static readonly LangEntry0 PuzzleResetSuccess = new("Puzzle.Reset.Success", "Puzzle successfully reset.");
            public static readonly LangEntry2 PuzzleSetSuccess = new("Puzzle.Set.Success", "Successfully updated puzzle with option <color=#fd4>{0}</color>: <color=#fd4>{1}</color>.");

            public static readonly LangEntry0 PuzzleHelpHeader = new("Puzzle.Help.Header", "<size=18>Monument Addons Puzzle Commands</size>");
            public static readonly LangEntry1 PuzzleHelpReset = new("Puzzle.Help.Reset", "<color=#fd4>{0} reset</color> - Reset the puzzle connected to the entity you are looking at");
            public static readonly LangEntry1 PuzzleHelpSet = new("Puzzle.Help.Set", "<color=#fd4>{0} set <option> <value></color> - Set a property of a puzzle");
            public static readonly LangEntry1 PuzzleHelpAdd = new("Puzzle.Help.Add", "<color=#fd4>{0} add <group_name></color> - Associate a spawn group with a puzzle");
            public static readonly LangEntry1 PuzzleHelpRemove = new("Puzzle.Help.Remove", "<color=#fd4>{0} remove <group_name></color> - Disassociate a spawn group with a puzzle");

            public static readonly LangEntry0 PuzzleSetHelpMaxPlayersBlockReset = new("Puzzle.Set.Help.MaxPlayersBlockReset", "<color=#fd4>PlayersBlockReset</color>: true | false");
            public static readonly LangEntry0 PuzzleSetHelpPlayerDetectionRadius = new("Puzzle.Set.Help.PlayerDetectionRadius", "<color=#fd4>PlayerDetectionRadius</color>: number");
            public static readonly LangEntry0 PuzzleSetHelpSecondsBetweenResets = new("Puzzle.Set.Help.SecondsBetweenResets", "<color=#fd4>SecondsBetweenResets</color>: number");

            public static readonly LangEntry1 ShowVanillaNoSpawnPoints = new("Show.Vanilla.NoSpawnPoints", "No spawn points found in <color=#fd4>{0}</color>.");
            public static readonly LangEntry1 GenerateSuccess = new("Generate.Success", "Successfully generated profile <color=#fd4>{0}</color>.");

            public static readonly LangEntry1 ShowSuccess = new("Show.Success", "Showing nearby Monument Addons for <color=#fd4>{0}</color>.");
            public static readonly LangEntry1 ShowLabelPlugin = new("Show.Label.Plugin", "Plugin: {0}");
            public static readonly LangEntry1 ShowLabelProfile = new("Show.Label.Profile", "Profile: {0}");
            public static readonly LangEntry2 ShowLabelCustomMonument = new("Show.Label.CustomMonument", "Custom Monument: {0} (x{1})");
            public static readonly LangEntry2 ShowLabelMonument = new("Show.Label.Monument", "Monument: {0} (x{1})");
            public static readonly LangEntry3 ShowLabelMonumentWithTier = new("Show.Label.MonumentWithTier", "Monument: {0} (x{1} | {2})");
            public static readonly LangEntry1 ShowLabelSkin = new("Show.Label.Skin", "Skin: {0}");
            public static readonly LangEntry1 ShowLabelScale = new("Show.Label.Scale", "Scale: {0}");
            public static readonly LangEntry1 ShowLabelRCIdentifier = new("Show.Label.RCIdentifier", "RC Identifier: {0}");

            public static readonly LangEntry1 ShowHeaderEntity = new("Show.Header.Entity", "Entity: {0}");
            public static readonly LangEntry1 ShowHeaderPrefab = new("Show.Header.Prefab", "Prefab: {0}");
            public static readonly LangEntry0 ShowHeaderPuzzle = new("Show.Header.Puzzle", "Puzzle");
            public static readonly LangEntry1 ShowHeaderSpawnGroup = new("Show.Header.SpawnGroup", "Spawn Group: {0}");
            public static readonly LangEntry1 ShowHeaderVanillaSpawnGroup = new("Show.Header.Vanilla.SpawnGroup", "Vanilla Spawn Group: {0}");
            public static readonly LangEntry1 ShowHeaderSpawnPoint = new("Show.Header.SpawnPoint", "Spawn Point ({0})");
            public static readonly LangEntry1 ShowHeaderVanillaSpawnPoint = new("Show.Header.Vanilla.SpawnPoint", "Vanilla Spawn Point ({0})");
            public static readonly LangEntry1 ShowHeaderVanillaIndividualSpawnPoint = new("Show.Header.Vanilla.IndividualSpawnPoint", "Vanilla Individual Spawn Point: {0}");
            public static readonly LangEntry1 ShowHeaderPaste = new("Show.Header.Paste", "Paste: {0}");
            public static readonly LangEntry1 ShowHeaderCustom = new("Show.Header.Custom", "Custom Addon: {0}");

            public static readonly LangEntry1 ShowLabelFlags = new("Show.Label.SpawnPoint.Flags", "Flags: {0}");
            public static readonly LangEntry0 ShowLabelSpawnPointExclusive = new("Show.Label.SpawnPoint.Exclusive", "Exclusive");
            public static readonly LangEntry0 ShowLabelSpawnPointRandomRotation = new("Show.Label.SpawnPoint.RandomRotation2", "RandomRotation");
            public static readonly LangEntry0 ShowLabelSpawnPointSnapToGround = new("Show.Label.SpawnPoint.SnapToGround", "SnapToGround");
            public static readonly LangEntry0 ShowLabelSpawnPointCheckSpace = new("Show.Label.SpawnPoint.CheckSpace", "CheckSpace");
            public static readonly LangEntry1 ShowLabelSpawnPointRandomRadius = new("Show.Label.SpawnPoint.RandomRadius", "Random spawn radius: {0:f1}");

            public static readonly LangEntry1 ShowLabelSpawnPoints = new("Show.Label.Points", "Spawn points: {0}");
            public static readonly LangEntry1 ShowLabelTiers = new("Show.Label.Tiers", "Tiers: {0}");
            public static readonly LangEntry0 ShowLabelSpawnWhenParentSpawns = new("Show.Label.SpawnWhenParentSpawns", "Spawn when parent spawns");
            public static readonly LangEntry0 ShowLabelSpawnOnServerStart = new("Show.Label.SpawnOnServerStart", "Spawn on server start");
            public static readonly LangEntry0 ShowLabelSpawnOnMapWipe = new("Show.Label.SpawnOnMapWipe", "Spawn on map wipe");
            public static readonly LangEntry0 ShowLabelInitialSpawn = new("Show.Label.InitialSpawn", "InitialSpawn");
            public static readonly LangEntry0 ShowLabelPreventDuplicates = new("Show.Label.PreventDuplicates2", "PreventDuplicates");
            public static readonly LangEntry0 ShowLabelPauseScheduleWhileFull = new("Show.Label.PauseScheduleWhileFull", "PauseScheduleWhileFull");
            public static readonly LangEntry0 ShowLabelRespawnWhenNearestPuzzleResets = new("Show.Label.RespawnWhenNearestPuzzleResets", "RespawnWhenNearestPuzzleResets");
            public static readonly LangEntry2 ShowLabelPopulation = new("Show.Label.Population", "Population: {0} / {1}");
            public static readonly LangEntry2 ShowLabelRespawnPerTick = new("Show.Label.RespawnPerTick", "Spawn per tick: {0} - {1}");
            public static readonly LangEntry2 ShowLabelRespawnDelay = new("Show.Label.RespawnDelay", "Respawn delay: {0} - {1}");
            public static readonly LangEntry1 ShowLabelNextSpawn = new("Show.Label.NextSpawn", "Next spawn: {0}");
            public static readonly LangEntry0 ShowLabelNextSpawnQueued = new("Show.Label.NextSpawn.Queued", "Queued");
            public static readonly LangEntry0 ShowLabelNextSpawnPaused = new("Show.Label.NextSpawn.Paused", "Paused");
            public static readonly LangEntry0 ShowLabelEntities = new("Show.Label.Entities", "Entities:");
            public static readonly LangEntry3 ShowLabelEntityDetail = new("Show.Label.Entities.Detail2", "{0} | weight: {1} ({2:P1})");
            public static readonly LangEntry0 ShowLabelNoEntities = new("Show.Label.NoEntities", "No entities configured. Run /maspawngroup add <entity> <weight>");
            public static readonly LangEntry1 ShowLabelPlayerDetectionRadius = new("Show.Label.PlayerDetectionRadius", "Player detection radius: {0:f1}");
            public static readonly LangEntry0 ShowLabelPlayerDetectedInRadius = new("Show.Label.PlayerDetectedInRadius", "(!) Player detected in radius (!)");

            public static readonly LangEntry1 ShowLabelPuzzlePlayersBlockReset = new("Show.Label.Puzzle.PlayersBlockReset", "Players block reset progress: {0}");
            public static readonly LangEntry1 ShowLabelPuzzleTimeBetweenResets = new("Show.Label.Puzzle.TimeBetweenResets", "Time between resets: {0}");
            public static readonly LangEntry1 ShowLabelPuzzleNextReset = new("Show.Label.Puzzle.NextReset", "Time until next reset: {0}");
            public static readonly LangEntry0 ShowLabelPuzzleNextResetOverdue = new("Show.Label.Puzzle.NextReset.Overdue", "Any moment now");
            public static readonly LangEntry1 ShowLabelPuzzleSpawnGroups = new("Show.Label.Puzzle.SpawnGroups", "Resets spawn groups: {0}");

            public static readonly LangEntry2 SkinGet = new("Skin.Get", "Skin ID: <color=#fd4>{0}</color>. Run <color=#fd4>{1} <skin id></color> to change it.");
            public static readonly LangEntry1 SkinSetSyntax = new("Skin.Set.Syntax", "Syntax: <color=#fd4>{0} <skin id></color>");
            public static readonly LangEntry3 SkinSetSuccess = new("Skin.Set.Success2", "Updated skin ID to <color=#fd4>{0}</color> at <color=#fd4>{1}</color> matching monument(s) and saved to profile <color=#fd4>{2}</color>.");
            public static readonly LangEntry2 SkinErrorRedirect = new("Skin.Error.Redirect", "Error: Skin <color=#fd4>{0}</color> is a redirect skin and cannot be set directly. Instead, spawn the entity as <color=#fd4>{1}</color>.");

            public static readonly LangEntry3 FlagsGet = new("Flags.Get", "Current flags: <color=#fd4>{0}</color>\nEnabled flags: <color=#fd4>{1}</color>\nDisabled flags: <color=#fd4>{2}</color>");
            public static readonly LangEntry1 FlagsSetSyntax = new("Flags.Syntax", "Syntax: <color=#fd4>{0} <flag></color>");
            public static readonly LangEntry1 FlagsEnableSuccess = new("Flags.Enable.Success", "Overrode flag <color=#fd4>{0}</color> to enabled");
            public static readonly LangEntry1 FlagsDisableSuccess = new("Flags.Disable.Success", "Overrode flag <color=#fd4>{0}</color> to disabled");
            public static readonly LangEntry1 FlagsUnsetSuccess = new("Flags.Unset.Success", "Removed override for flag <color=#fd4>{0}</color>");

            public static readonly LangEntry1 CCTVSetIdSyntax = new("CCTV.SetId.Error.Syntax", "Syntax: <color=#fd4>{0} <id></color>");
            public static readonly LangEntry3 CCTVSetIdSuccess = new("CCTV.SetId.Success2", "Updated CCTV id to <color=#fd4>{0}</color> at <color=#fd4>{1}</color> matching monument(s) and saved to profile <color=#fd4>{2}</color>.");
            public static readonly LangEntry2 CCTVSetDirectionSuccess = new("CCTV.SetDirection.Success2", "Updated CCTV direction at <color=#fd4>{0}</color> matching monument(s) and saved to profile <color=#fd4>{1}</color>.");

            public static readonly LangEntry1 SkullNameSyntax = new("SkullName.Syntax", "Syntax: <color=#fd4>{0} <name></color>");
            public static readonly LangEntry3 SkullNameSetSuccess = new("SkullName.Set.Success", "Updated skull name to <color=#fd4>{0}</color> at <color=#fd4>{1}</color> matching monument(s) and saved to profile <color=#fd4>{2}</color>.");

            public static readonly LangEntry0 SetHeadNoHeadItem = new("Head.Set.NoHeadItem", "Error: You must be holding a head bag item to do that.");
            public static readonly LangEntry0 SetHeadMismatch = new("Head.Set.Mismatch", "Error: That is the wrong type of head for that trophy.");
            public static readonly LangEntry2 SetHeadSuccess = new("Head.Set.Success", "Updated head trophy according to your equipped item at <color=#fd4>{0}</color> matching monument(s) and saved to profile <color=#fd4>{1}</color>.");

            public static readonly LangEntry1 CardReaderSetLevelSyntax = new("CardReader.SetLevel.Error.Syntax", "Syntax: <color=#fd4>{0} <1-3></color>");
            public static readonly LangEntry1 CardReaderSetLevelSuccess = new("CardReader.SetLevel.Success", "Updated card reader access level to <color=#fd4>{0}</color>.");

            public static readonly LangEntry0 ProfileListEmpty = new("Profile.List.Empty", "You have no profiles. Create one with <color=#fd4>maprofile create <name></maprofile>");
            public static readonly LangEntry0 ProfileListHeader = new("Profile.List.Header", "<size=18>Monument Addons Profiles</size>");
            public static readonly LangEntry2 ProfileListItemEnabled = new("Profile.List.Item.Enabled2", "<color=#fd4>{0}</color>{1} - <color=#6e6>ENABLED</color>");
            public static readonly LangEntry2 ProfileListItemDisabled = new("Profile.List.Item.Disabled2", "<color=#fd4>{0}</color>{1} - <color=#ccc>DISABLED</color>");
            public static readonly LangEntry2 ProfileListItemSelected = new("Profile.List.Item.Selected2", "<color=#fd4>{0}</color>{1} - <color=#6cf>SELECTED</color>");
            public static readonly LangEntry1 ProfileByAuthor = new("Profile.ByAuthor", " by {0}");

            public static readonly LangEntry0 ProfileInstallSyntax = new("Profile.Install.Syntax", "Syntax: <color=#fd4>maprofile install <url></color>");
            public static readonly LangEntry0 ProfileInstallShorthandSyntax = new("Profile.Install.Shorthand.Syntax", "Syntax: <color=#fd4>mainstall <url></color>");
            public static readonly LangEntry1 ProfileUrlInvalid = new("Profile.Url.Invalid", "Invalid URL: {0}");
            public static readonly LangEntry1 ProfileAlreadyExistsNotEmpty = new("Profile.Error.AlreadyExists.NotEmpty", "Error: Profile <color=#fd4>{0}</color> already exists and is not empty.");
            public static readonly LangEntry2 ProfileInstallSuccess = new("Profile.Install.Success2", "Successfully installed and <color=#6e6>ENABLED</color> profile <color=#fd4>{0}</color>{1}.");
            public static readonly LangEntry1 ProfileInstallError = new("Profile.Install.Error", "Error installing profile from url {0}. See the error logs for more details.");
            public static readonly LangEntry2 ProfileDownloadError = new("Profile.Download.Error", "Error downloading profile from url {0}\nStatus code: {1}");
            public static readonly LangEntry2 ProfileParseError = new("Profile.Parse.Error", "Error parsing profile from url {0}\n{1}");

            public static readonly LangEntry0 ProfileDescribeSyntax = new("Profile.Describe.Syntax", "Syntax: <color=#fd4>maprofile describe <name></color>");
            public static readonly LangEntry1 ProfileNotFound = new("Profile.Error.NotFound", "Error: Profile <color=#fd4>{0}</color> not found.");
            public static readonly LangEntry1 ProfileEmpty = new("Profile.Empty", "Profile <color=#fd4>{0}</color> is empty.");
            public static readonly LangEntry1 ProfileDescribeHeader = new("Profile.Describe.Header", "Describing profile <color=#fd4>{0}</color>.");
            public static readonly LangEntry4 ProfileDescribeItem = new("Profile.Describe.Item2", "{0}: <color=#fd4>{1}</color> x{2} @ {3}");
            public static readonly LangEntry0 ProfileSelectSyntax = new("Profile.Select.Syntax", "Syntax: <color=#fd4>maprofile select <name></color>");
            public static readonly LangEntry1 ProfileSelectSuccess = new("Profile.Select.Success2", "Successfully <color=#6cf>SELECTED</color> profile <color=#fd4>{0}</color>.");
            public static readonly LangEntry1 ProfileSelectEnableSuccess = new("Profile.Select.Enable.Success", "Successfully <color=#6cf>SELECTED</color> and <color=#6e6>ENABLED</color> profile <color=#fd4>{0}</color>.");

            public static readonly LangEntry0 ProfileEnableSyntax = new("Profile.Enable.Syntax", "Syntax: <color=#fd4>maprofile enable <name></color>");
            public static readonly LangEntry1 ProfileAlreadyEnabled = new("Profile.AlreadyEnabled", "Profile <color=#fd4>{0}</color> is already <color=#6e6>ENABLED</color>.");
            public static readonly LangEntry1 ProfileEnableSuccess = new("Profile.Enable.Success", "Profile <color=#fd4>{0}</color> is now: <color=#6e6>ENABLED</color>.");
            public static readonly LangEntry0 ProfileDisableSyntax = new("Profile.Disable.Syntax", "Syntax: <color=#fd4>maprofile disable <name></color>");
            public static readonly LangEntry1 ProfileAlreadyDisabled = new("Profile.AlreadyDisabled2", "Profile <color=#fd4>{0}</color> is already <color=#ccc>DISABLED</color>.");
            public static readonly LangEntry1 ProfileDisableSuccess = new("Profile.Disable.Success2", "Profile <color=#fd4>{0}</color> is now: <color=#ccc>DISABLED</color>.");
            public static readonly LangEntry0 ProfileReloadSyntax = new("Profile.Reload.Syntax", "Syntax: <color=#fd4>maprofile reload <name></color>");
            public static readonly LangEntry1 ProfileNotEnabled = new("Profile.NotEnabled", "Error: Profile <color=#fd4>{0}</color> is not enabled.");
            public static readonly LangEntry1 ProfileReloadSuccess = new("Profile.Reload.Success", "Reloaded profile <color=#fd4>{0}</color>.");

            public static readonly LangEntry0 ProfileCreateSyntax = new("Profile.Create.Syntax", "Syntax: <color=#fd4>maprofile create <name></color>");
            public static readonly LangEntry1 ProfileAlreadyExists = new("Profile.Error.AlreadyExists", "Error: Profile <color=#fd4>{0}</color> already exists.");
            public static readonly LangEntry1 ProfileCreateSuccess = new("Profile.Create.Success", "Successfully created and <color=#6cf>SELECTED</color> profile <color=#fd4>{0}</color>.");
            public static readonly LangEntry0 ProfileRenameSyntax = new("Profile.Rename.Syntax", "Syntax: <color=#fd4>maprofile rename <old name> <new name></color>");
            public static readonly LangEntry2 ProfileRenameSuccess = new("Profile.Rename.Success2", "Successfully renamed profile <color=#fd4>{0}</color> to <color=#fd4>{1}</color>");
            public static readonly LangEntry0 ProfileClearSyntax = new("Profile.Clear.Syntax", "Syntax: <color=#fd4>maprofile clear <name></color>");
            public static readonly LangEntry1 ProfileClearSuccess = new("Profile.Clear.Success", "Successfully cleared profile <color=#fd4>{0}</color>.");
            public static readonly LangEntry0 ProfileDeleteSyntax = new("Profile.Delete.Syntax", "Syntax: <color=#fd4>maprofile delete <name></color>");
            public static readonly LangEntry1 ProfileDeleteBlocked = new("Profile.Delete.Blocked", "Profile <color=#fd4>{0}</color> must be empty or disabled before it can be deleted.");
            public static readonly LangEntry1 ProfileDeleteSuccess = new("Profile.Delete.Success", "Successfully deleted profile <color=#fd4>{0}</color>.");

            public static readonly LangEntry0 ProfileMoveToSyntax = new("Profile.MoveTo.Syntax", "Syntax: <color=#fd4>maprofile moveto <name></color>");
            public static readonly LangEntry2 ProfileMoveToAlreadyPresent = new("Profile.MoveTo.AlreadyPresent", "Error: <color=#fd4>{0}</color> is already part of profile <color=#fd4>{1}</color>.");
            public static readonly LangEntry3 ProfileMoveToSuccess = new("Profile.MoveTo.Success", "Successfully moved <color=#fd4>{0}</color> from profile <color=#fd4>{1}</color> to <color=#fd4>{2}</color>.");

            public static readonly LangEntry0 ProfileHelpHeader = new("Profile.Help.Header", "<size=18>Monument Addons Profile Commands</size>");
            public static readonly LangEntry0 ProfileHelpList = new("Profile.Help.List", "<color=#fd4>maprofile list</color> - List all profiles");
            public static readonly LangEntry0 ProfileHelpDescribe = new("Profile.Help.Describe", "<color=#fd4>maprofile describe <name></color> - Describe profile contents");
            public static readonly LangEntry0 ProfileHelpEnable = new("Profile.Help.Enable", "<color=#fd4>maprofile enable <name></color> - Enable a profile");
            public static readonly LangEntry0 ProfileHelpDisable = new("Profile.Help.Disable", "<color=#fd4>maprofile disable <name></color> - Disable a profile");
            public static readonly LangEntry0 ProfileHelpReload = new("Profile.Help.Reload", "<color=#fd4>maprofile reload <name></color> - Reload a profile from disk");
            public static readonly LangEntry0 ProfileHelpSelect = new("Profile.Help.Select", "<color=#fd4>maprofile select <name></color> - Select a profile");
            public static readonly LangEntry0 ProfileHelpCreate = new("Profile.Help.Create", "<color=#fd4>maprofile create <name></color> - Create a new profile");
            public static readonly LangEntry0 ProfileHelpRename = new("Profile.Help.Rename", "<color=#fd4>maprofile rename <name> <new name></color> - Rename a profile");
            public static readonly LangEntry0 ProfileHelpClear = new("Profile.Help.Clear2", "<color=#fd4>maprofile clear <name></color> - Clear a profile");
            public static readonly LangEntry0 ProfileHelpDelete = new("Profile.Help.Delete", "<color=#fd4>maprofile delete <name></color> - Delete a profile");
            public static readonly LangEntry0 ProfileHelpMoveTo = new("Profile.Help.MoveTo2", "<color=#fd4>maprofile moveto <name></color> - Move an entity to a profile");
            public static readonly LangEntry0 ProfileHelpInstall = new("Profile.Help.Install", "<color=#fd4>maprofile install <url></color> - Install a profile from a URL");

            public static readonly LangEntry0 WireToolInvisible = new("WireTool.Invisible", "Invisible");
            public static readonly LangEntry1 WireToolInvalidColor = new("WireTool.Error.InvalidColor", "Invalid wire color: <color=#fd4>{0}</color>.");
            public static readonly LangEntry0 WireToolNotEquipped = new("WireTool.Error.NotEquipped", "Error: No Wire Tool or Hose Tool equipped.");
            public static readonly LangEntry1 WireToolActivated = new("WireTool.Activated", "Monument Addons Wire Tool activated with color <color=#fd4>{0}</color>.");
            public static readonly LangEntry0 WireToolDeactivated = new("WireTool.Deactivated", "Monument Addons Wire Tool deactivated.");
            public static readonly LangEntry2 WireToolTypeMismatch = new("WireTool.TypeMismatch", "Error: You can only connect slots of the same type. Looking for <color=#fd4>{0}</color>, but found <color=#fd4>{1}</color>.");
            public static readonly LangEntry2 WireToolProfileMismatch = new("WireTool.ProfileMismatch", "Error: You can only connect entities in the same profile. Looking for <color=#fd4>{0}</color>, but found <color=#fd4>{1}</color>.");
            public static readonly LangEntry0 WireToolMonumentMismatch = new("WireTool.MonumentMismatch", "Error: You can only connect entities at the same monument.");

            public static readonly LangEntry0 HelpHeader = new("Help.Header", "<size=18>Monument Addons Help</size>");
            public static readonly LangEntry0 HelpSpawn = new("Help.Spawn", "<color=#fd4>maspawn <entity></color> - Spawn an entity");
            public static readonly LangEntry0 HelpPrefab = new("Help.Prefab", "<color=#fd4>maprefab <prefab></color> - Create a non-entity prefab instance");
            public static readonly LangEntry0 HelpKill = new("Help.Kill", "<color=#fd4>makill</color> - Delete an entity or other addon");
            public static readonly LangEntry0 HelpUndo = new("Help.Undo", "<color=#fd4>maundo</color> - Undo a recent <color=#fd4>makill</color> action");
            public static readonly LangEntry0 HelpSave = new("Help.Save", "<color=#fd4>masave</color> - Save an entity's updated position");
            public static readonly LangEntry0 HelpFlag = new("Help.Flag", "<color=#fd4>maflag <flag></color> - Toggle a flag of an entity");
            public static readonly LangEntry0 HelpSkin = new("Help.Skin", "<color=#fd4>maskin <skin id></color> - Change the skin of an entity");
            public static readonly LangEntry0 HelpSetId = new("Help.SetId", "<color=#fd4>masetid <id></color> - Set the id of a CCTV");
            public static readonly LangEntry0 HelpSetDir = new("Help.SetDir", "<color=#fd4>masetdir</color> - Set the direction of a CCTV");
            public static readonly LangEntry0 HelpSkull = new("Help.Skull", "<color=#fd4>maskull <name></color> - Set skull trophy display name");
            public static readonly LangEntry0 HelpTrophy = new("Help.Trophy", "<color=#fd4>matrophy <name></color> - Update a hunting trophy");
            public static readonly LangEntry0 HelpCardReaderLevel = new("Help.CardReaderLevel", "<color=#fd4>macardlevel <1-3></color> - Set a card reader's access level");
            public static readonly LangEntry0 HelpPuzzle = new("Help.Puzzle", "<color=#fd4>mapuzzle</color> - Print puzzle help");
            public static readonly LangEntry0 HelpSpawnGroup = new("Help.SpawnGroup", "<color=#fd4>maspawngroup</color> - Print spawn group help");
            public static readonly LangEntry0 HelpSpawnPoint = new("Help.SpawnPoint", "<color=#fd4>maspawnpoint</color> - Print spawn point help");
            public static readonly LangEntry0 HelpPaste = new("Help.Paste", "<color=#fd4>mapaste <file></color> - Paste a building");
            public static readonly LangEntry0 HelpEdit = new("Help.Edit", "<color=#fd4>maedit <addon-name> <arg1> <arg2> ...</color> - Edit a custom addon");
            public static readonly LangEntry0 HelpShow = new("Help.Show", "<color=#fd4>mashow</color> - Show nearby addons");
            public static readonly LangEntry0 HelpShowVanilla = new("Help.ShowVanilla", "<color=#fd4>mashowvanilla</color> - Show vanilla spawn points");
            public static readonly LangEntry0 HelpProfile = new("Help.Profile", "<color=#fd4>maprofile</color> - Print profile help");

            public string Name;
            public string English;

            protected LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }

        private struct TemplateProvider
        {
            private MonumentAddons _plugin;
            private string _playerId;

            public TemplateProvider(MonumentAddons plugin, string playerId)
            {
                _plugin = plugin;
                _playerId = playerId;
            }

            public string Get(string templateName)
            {
                return _plugin.lang.GetMessage(templateName, _plugin, _playerId);
            }
        }

        private interface IMessageFormatter
        {
            string Format(TemplateProvider templateProvider);
        }

        private class LangEntry0 : LangEntry, IMessageFormatter
        {
            public LangEntry0(string name, string english) : base(name, english) {}

            public string Format(TemplateProvider templateProvider)
            {
                return templateProvider.Get(Name);
            }
        }

        private class LangEntry1 : LangEntry
        {
            public struct Formatter : IMessageFormatter
            {
                private string _langKey;
                private Tuple1 _args;

                public Formatter(LangEntry1 langEntry, Tuple1 args)
                {
                    _langKey = langEntry.Name;
                    _args = args;
                }

                public string Format(TemplateProvider templateProvider)
                {
                    return string.Format(templateProvider.Get(_langKey), _args.Item1);
                }
            }

            public LangEntry1(string name, string english) : base(name, english) {}

            public Formatter Bind(Tuple1 args) => new(this, args);
            public Formatter Bind(object arg1) => Bind(new Tuple1(arg1));
        }

        private class LangEntry2 : LangEntry
        {
            public struct Formatter : IMessageFormatter
            {
                private string _langKey;
                private Tuple2 _args;

                public Formatter(LangEntry2 langEntry, Tuple2 args)
                {
                    _langKey = langEntry.Name;
                    _args = args;
                }

                public string Format(TemplateProvider templateProvider)
                {
                    return string.Format(templateProvider.Get(_langKey), _args.Item1, _args.Item2);
                }
            }

            public LangEntry2(string name, string english) : base(name, english) {}

            public Formatter Bind(Tuple2 args) => new(this, args);
            public Formatter Bind(object arg1, object arg2) => Bind(new Tuple2(arg1, arg2));
        }

        private class LangEntry3 : LangEntry
        {
            public struct Formatter : IMessageFormatter
            {
                private string _langKey;
                private Tuple3 _args;

                public Formatter(LangEntry3 langEntry, Tuple3 args)
                {
                    _langKey = langEntry.Name;
                    _args = args;
                }

                public string Format(TemplateProvider templateProvider)
                {
                    return string.Format(templateProvider.Get(_langKey), _args.Item1, _args.Item2, _args.Item3);
                }
            }

            public LangEntry3(string name, string english) : base(name, english) {}

            public Formatter Bind(Tuple3 args) => new(this, args);
            public Formatter Bind(object arg1, object arg2, object arg3) => Bind(new Tuple3(arg1, arg2, arg3));
        }

        private class LangEntry4 : LangEntry
        {
            public struct Formatter : IMessageFormatter
            {
                private string _langKey;
                private Tuple4 _args;

                public Formatter(LangEntry4 langEntry, Tuple4 args)
                {
                    _langKey = langEntry.Name;
                    _args = args;
                }

                public string Format(TemplateProvider templateProvider)
                {
                    return string.Format(templateProvider.Get(_langKey), _args.Item1, _args.Item2, _args.Item3, _args.Item4);
                }
            }

            public LangEntry4(string name, string english) : base(name, english) {}

            public Formatter Bind(Tuple4 args) => new(this, args);
            public Formatter Bind(object arg1, object arg2, object arg3, object arg4) => Bind(new Tuple4(arg1, arg2, arg3, arg4));
        }

        private string GetMessage<T>(string playerId, T formatter) where T : IMessageFormatter
        {
            return formatter.Format(new TemplateProvider(this, playerId));
        }

        private string GetMessage(string playerId, LangEntry1 langEntry, object arg1)
        {
            return GetMessage(playerId, langEntry.Bind(arg1));
        }

        private string GetMessage(string playerId, LangEntry2 langEntry, object arg1, object arg2)
        {
            return GetMessage(playerId, langEntry.Bind(arg1, arg2));
        }

        private string GetMessage(string playerId, LangEntry3 langEntry, object arg1, object arg2, object arg3)
        {
            return GetMessage(playerId, langEntry.Bind(arg1, arg2, arg3));
        }

        private string GetMessage(string playerId, LangEntry4 langEntry, object arg1, object arg2, object arg3, object arg4)
        {
            return GetMessage(playerId, langEntry.Bind(arg1, arg2, arg3, arg4));
        }


        private void ReplyToPlayer<T>(IPlayer player, T formatter) where T : IMessageFormatter
        {
            player.Reply(GetMessage(player.Id, formatter));
        }

        private void ReplyToPlayer(IPlayer player, LangEntry1 langEntry, object arg1)
        {
            ReplyToPlayer(player, langEntry.Bind(arg1));
        }

        private void ReplyToPlayer(IPlayer player, LangEntry2 langEntry, object arg1, object arg2)
        {
            ReplyToPlayer(player, langEntry.Bind(arg1, arg2));
        }

        private void ReplyToPlayer(IPlayer player, LangEntry3 langEntry, object arg1, object arg2, object arg3)
        {
            ReplyToPlayer(player, langEntry.Bind(arg1, arg2, arg3));
        }

        private void ReplyToPlayer(IPlayer player, LangEntry4 langEntry, object arg1, object arg2, object arg3, object arg4)
        {
            ReplyToPlayer(player, langEntry.Bind(arg1, arg2, arg3, arg4));
        }


        private void ChatMessage<T>(BasePlayer player, T formatter) where T : IMessageFormatter
        {
            player.ChatMessage(formatter.Format(new TemplateProvider(this, player.UserIDString)));
        }

        private void ChatMessage(BasePlayer player, LangEntry1 langEntry, object arg1)
        {
            ChatMessage(player, langEntry.Bind(arg1));
        }

        private void ChatMessage(BasePlayer player, LangEntry2 langEntry, object arg1, object arg2)
        {
            ChatMessage(player, langEntry.Bind(arg1, arg2));
        }

        private void ChatMessage(BasePlayer player, LangEntry3 langEntry, object arg1, object arg2, object arg3)
        {
            ChatMessage(player, langEntry.Bind(arg1, arg2, arg3));
        }

        private void ChatMessage(BasePlayer player, LangEntry4 langEntry, object arg1, object arg2, object arg3, object arg4)
        {
            ChatMessage(player, langEntry.Bind(arg1, arg2, arg3, arg4));
        }


        private string GetAuthorSuffix(IPlayer player, string author)
        {
            return !string.IsNullOrWhiteSpace(author)
                ? GetMessage(player.Id, LangEntry.ProfileByAuthor, author)
                : string.Empty;
        }

        private string GetAddonName(IPlayer player, BaseData data)
        {
            if (data is EntityData entityData)
                return _uniqueNameRegistry.GetUniqueShortName(entityData.PrefabName);

            if (data is PrefabData prefabData)
                return _uniqueNameRegistry.GetUniqueShortName(prefabData.PrefabName);

            if (data is SpawnPointData || data is SpawnGroupData)
                return GetMessage(player.Id, LangEntry.AddonTypeSpawnPoint);

            if (data is PasteData pasteData)
                return pasteData.Filename;

            return GetMessage(player.Id, LangEntry.AddonTypeUnknown);
        }

        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this);
        }

        #endregion
    }
}

#region Extension Methods

namespace Oxide.Plugins.MonumentAddonsExtensions
{
    public static class DictionaryExtensions
    {
        public static TValue GetOrCreate<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key) where TValue : new()
        {
            var value = dict.GetValueOrDefault(key);
            if (value == null)
            {
                value = new TValue();
                dict[key] = value;
            }

            return value;
        }
    }
}

#endregion


// --- End of file: MonumentAddons.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mlrs-rocket-tracker ---
// --- Original File Path: M/MlrsRocketTracker/MlrsRocketTracker.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("MLRS Rocket Tracker", "MadKingCraig", "1.1.0")]
    [Description("Track where the MLRS is fired at")]
    class MlrsRocketTracker : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin DiscordMessages;

        #endregion Fields

        #region Hooks

        private void Init()
        {
            _config = Config.ReadObject<PluginConfig>();
        }

        private void OnMlrsFired(MLRS mlrs, BasePlayer player)
        {
            var lastSentTargetHitPos = CalculateGridPosition(mlrs.lastSentTargetHitPos);
            var lastSentTrueHitPos = CalculateGridPosition(mlrs.lastSentTrueHitPos);

            if (_config.LogToConsole)
                Puts(lang.GetMessage("FiredMessage", this, player.UserIDString), player.displayName, lastSentTargetHitPos, lastSentTrueHitPos);

            if (_config.UseDiscord)
                SendDiscordMessage(player.displayName, player.UserIDString, string.Format(lang.GetMessage("DiscordMessage", this, player.UserIDString), lastSentTargetHitPos, lastSentTrueHitPos));
        }

        #endregion Hooks

        #region Functions

        private string CalculateGridPosition(Vector3 position)
        {
            int maxGridSize = Mathf.FloorToInt(World.Size / 146.3f) - 1;
            int xGrid = Mathf.Clamp(Mathf.FloorToInt((position.x + (World.Size / 2f)) / 146.3f), 0, maxGridSize);
            string extraA = string.Empty;
            if (xGrid > 26) extraA = $"{(char)('A' + (xGrid / 26 - 1))}";
            return $"{extraA}{(char)('A' + xGrid % 26)}{Mathf.Clamp(maxGridSize - Mathf.FloorToInt((position.z + (World.Size / 2f)) / 146.3f), 0, maxGridSize).ToString()}";
        }

        private void SendDiscordMessage(string name, string playerId, string text)
        {
            object fields = new object[]
            {
                new
                {
                    name = "Player", value = $"[{name}](https://steamcommunity.com/profiles/{playerId})", inline = true
                },
                new
                {
                    name = "MLRS Info", value = text, inline = false
                }
            };
            string json = JsonConvert.SerializeObject(fields);
            DiscordMessages?.Call("API_SendFancyMessage", _config.WebhookUrl, "MLRS Rocket Tracker", 1, json);
        }

        #endregion Functions

        #region Config
        private PluginConfig _config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                LogToConsole = true,
                UseDiscord = false,
                WebhookUrl = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks"
            };
        }

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Log to Console")]
            public bool LogToConsole;
            [JsonProperty(PropertyName = "Use Discord Webhook")]
            public bool UseDiscord;
            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string WebhookUrl;
        }

        #endregion Config

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FiredMessage"] = "{0} fired the MLRS at {1} and missiles hit {2}!",
                ["DiscordMessage"] = "MLRS fired at {0} and hit {1}"
            }, this);
        }

        #endregion Lang
    }
}


// --- End of file: MlrsRocketTracker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-wipe-panel ---
// --- Original File Path: M/MagicWipePanel/MagicWipePanel.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Wipe Panel", "MJSU", "1.0.5")]
    [Description("Displays days to wipe in magic panel")]
    public class MagicWipePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel, WipeInfoApi;
        private PluginConfig _pluginConfig; //Plugin Config
        private int _daysTillWipe;
        
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Today] = "Today",
                [LangKeys.OneDay] = "1 Day",
                [LangKeys.Days] = "{0} Days"
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? false,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0f,
                    Url = config.Panel?.Image?.Url ?? "",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 1f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "Wipe: {0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "centerupper",
                Order = config.PanelSettings?.Order ?? 10,
                Width = config.PanelSettings?.Width ?? 0.08f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
            
            if (WipeInfoApi == null)
            {
                PrintError("Missing plugin dependency WipeInfoApi: https://umod.org/plugins/wipe-info-api");
                return;
            }
            
            MagicPanelRegisterPanels();
            OnWipeCalculated();
        }
        
        private void OnWipeCalculated()
        {
            if (WipeInfoApi == null || MagicPanel == null)
            {
                return;
            }
            
            _daysTillWipe = WipeInfoApi.Call<int>("GetDaysTillWipe");
            MagicPanel.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
        }

        private void MagicPanelRegisterPanels()
        {
            MagicPanel.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                string message;
                if (_daysTillWipe <= 0)
                {
                    message = Lang(LangKeys.Today);
                }
                else if (_daysTillWipe == 1)
                {
                    message = Lang(LangKeys.OneDay);
                }
                else
                {
                    message = Lang(LangKeys.Days, _daysTillWipe);
                }

                text.Text = string.Format(_textFormat, message);
            }

            return panel.ToHash();
        }
        
        private string Lang(string key, params object[] args) => string.Format(lang.GetMessage(key, this), args);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }
        
        private class LangKeys
        {
            public const string Today = "Today";
            public const string OneDay = "OneDay";
            public const string Days = "Days";
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicWipePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/money-time ---
// --- Original File Path: M/MoneyTime/MoneyTime.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
/*
 * Fixed payouts on re-spawns always being negative values.
 * Fixed save data bug not being saved on unload.
 * Rewrote code to make more performant & work correctly.
 * Added config toggle StackMultipliers
 * Updated deposit hook.
 * Fixed base payout from config addition.
 */
namespace Oxide.Plugins
{
    [Info("Money Time", "Wulf", "2.3.0")]
    [Description("Pays players with Economics money for playing")]
    public class MoneyTime : CovalencePlugin
    {
        #region Configuration

        private const string Perm = "moneytime.";
        private Configuration _config;

        public class Configuration
        {
            // TODO: Add option for daily/weekly login bonuses

            [JsonProperty("Enable Economics as default currency")]
            public bool Economics = true;

            [JsonProperty("Enable Server Rewards as default currency")]
            public bool ServerRewards = false;

            [JsonProperty("Enable AFK API plugin support")]
            public bool AfkApi = false;

            [JsonProperty("Base payout amount")]
            public int BasePayout = 100;

            [JsonProperty("Payout interval (seconds)")]
            public int PayoutInterval = 600;

            [JsonProperty("Time alive bonus")]
            public bool TimeAliveBonus = false;

            [JsonProperty("Time alive multiplier")]
            public float TimeAliveMultiplier = 0f;

            [JsonProperty("Allow Permission-based Multipliers to stack")]
            public bool StackMultipliers = false;

            [JsonProperty("New player welcome bonus")]
            public float WelcomeBonus = 500f;

            [JsonProperty("Permission-based mulitipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public SortedDictionary<string, float> PermissionMulitipliers = new SortedDictionary<string, float>
            {
                ["vip"] = 5f,
                ["donor"] = 2.5f
            };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MissedPayout"] = "You have been inactive and have missed this payout",
                ["ReceivedForPlaying"] = "You have received $payout.amount for actively playing",
                ["ReceivedForTimeAlive"] = "You have received $payout.amount for staying alive for $time.alive",
                ["ReceivedWelcomeBonus"] = "You have received $payout.amount as a welcome bonus"
            }, this);
        }

        #endregion Localization

        #region Data Storage

        private StoredData _storedData;

        private class StoredData
        {
            public Dictionary<string, PlayerInfo> Players = new Dictionary<string, PlayerInfo>();

            public StoredData()
            {
            }
        }

        private class PlayerInfo
        {
            public DateTime LastTimeAlive;
            public bool WelcomeBonus;

            public PlayerInfo()
            {
                LastTimeAlive = DateTime.Now;
                WelcomeBonus = true;
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void OnServerSave() => SaveData();

        #endregion Data Storage

        #region Initialization

        [PluginReference]
        private Plugin Economics, ServerRewards, AFKAPI;

        // ID | Amount | Time
        private Dictionary<string, Values> _payOut = new Dictionary<string, Values>();
        private Dictionary<string, double> _perms = new Dictionary<string, double>();

        private class Values
        {
            public double amount;
            public float time;
        }

        private void Init()
        {
            foreach (KeyValuePair<string, float> perm in _config.PermissionMulitipliers)
            {
                string p = Perm + perm.Key;
                _perms.Add(p, perm.Value);
                permission.RegisterPermission(p, this);
                Log($"Registered permission '{p}'; multiplier {perm.Value}");
            }

            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            if (!_config.TimeAliveBonus)
                Unsubscribe(nameof(OnUserRespawn));
        }

        private void InitializePlayer(IPlayer player, float current)
        {
            string id = player.Id;
            if (!_storedData.Players.ContainsKey(id))
                _storedData.Players.Add(id, new PlayerInfo());

            double amt = _config.BasePayout;
            double multi = 0;
            if (_config.StackMultipliers)
            {
                foreach (var perm in _perms)
                    if (player.HasPermission($"{perm.Key}"))
                        multi += amt * perm.Value;

                if (multi != 0) 
                    amt = multi;
            }
            else
            {
                foreach (var perm in _perms)
                    if (player.HasPermission($"{perm.Key}") && perm.Value > multi)
                        multi = perm.Value;

                if (multi != 0)
                    amt *= multi;
            }

            if (!_payOut.ContainsKey(id))
                _payOut.Add(id, new Values { amount = amt, time = current });
            else
                _payOut[id].amount = amt;
        }

        private void OnServerInitialized()
        {
            var current = Time.realtimeSinceStartup + _config.PayoutInterval;
            foreach (IPlayer player in players.Connected)
                if (player.Id.IsSteamId()) 
                    InitializePlayer(player, current);

            timer.Every(_config.PayoutInterval, () =>
            {
                var newTime = Time.realtimeSinceStartup;
                foreach (IPlayer player in players.Connected)
                {
                    string id = player.Id;
                    if (!_payOut.ContainsKey(id)) continue;
                    var dingus = _payOut[id];
                    if (dingus.time <= newTime)
                    {
                        Payout(player, dingus.amount, GetLang("ReceivedForPlaying", id));
                        dingus.time = newTime + _config.PayoutInterval;
                    }
                }
            });
        }

        private void Unload()
        {
            SaveData();
            _perms.Clear();
            _payOut.Clear();
        }

        #endregion Initialization

        #region On Perms Updated

        private void OnGroupPermissionGranted(string name, string perm) => Edit(true, _perms.ContainsKey(perm));

        private void OnGroupPermissionRevoked(string name, string perm) => Edit(true, _perms.ContainsKey(perm));

        private void OnUserPermissionGranted(string id, string perm) => Edit(false, _perms.ContainsKey(perm), id);

        private void OnUserPermissionRevoked(string id, string perm) => Edit(false, _perms.ContainsKey(perm), id);

        private void Edit(bool all, bool mine, string user = "")
        {
            if (!mine) return;
            var current = Time.realtimeSinceStartup + _config.PayoutInterval;
            if (all)
            { 
                foreach (IPlayer player in players.Connected)
                    if (player.Id.IsSteamId()) 
                        InitializePlayer(player, current);
            }
            else
            {
                IPlayer dingus = players.FindPlayerById(user);
                InitializePlayer(dingus, current);
            }
        }

        #endregion

        #region Payout Handling

        private void Payout(IPlayer player, double amount, string message)
        {
            if (_config.AfkApi && AFKAPI != null && AFKAPI.IsLoaded)
            {
                bool isAfk = AFKAPI.Call<bool>("IsPlayerAFK", ulong.Parse(player.Id));
                if (isAfk)
                {
                    Message(player, "MissedPayout");
                    return;
                }
            }

            if (_config.Economics && Economics != null && Economics.IsLoaded)
            {
                Economics.Call("Deposit", player.Id, amount);
                Message(player, message.Replace("$payout.amount", amount.ToString()));
            }
            else if (_config.ServerRewards && ServerRewards != null && ServerRewards.IsLoaded)
            {
                ServerRewards.Call("AddPoints", player, (int)amount);
                Message(player, message.Replace("$payout.amount",amount.ToString()));
            }
        }

        private void OnUserConnected(IPlayer player)
        {
            var current = Time.realtimeSinceStartup + _config.PayoutInterval;
            InitializePlayer(player, current);

            if (_config.WelcomeBonus > 0f && !_storedData.Players[player.Id].WelcomeBonus)
                Payout(player, _config.WelcomeBonus, GetLang("ReceivedWelcomeBonus", player.Id));
        }

        private void OnUserDisconnected(IPlayer player) => _payOut.Remove(player.Id);

        private void OnUserRespawn(IPlayer player)
        {
            if (!player.Id.IsSteamId()) return;

            if (!_storedData.Players.ContainsKey(player.Id))
                InitializePlayer(player, Time.realtimeSinceStartup + _config.PayoutInterval);

            double secondsAlive = (DateTime.Now - _storedData.Players[player.Id].LastTimeAlive).TotalSeconds;
            TimeSpan timeSpan = TimeSpan.FromSeconds(secondsAlive);

            double amount = (secondsAlive / _config.BasePayout) * _config.TimeAliveMultiplier;
            string timeAlive = $"{timeSpan.TotalHours:00}h {timeSpan.Minutes:00}m {timeSpan.Seconds:00}s".TrimStart(' ', 'd', 'h', 'm', 's', '0');

            Payout(player, amount, GetLang("ReceivedForTimeAlive", player.Id).Replace("$time.alive", timeAlive));
            _storedData.Players[player.Id].LastTimeAlive = DateTime.Now;
        }

        #endregion Payout Handling

        #region Helpers

        private string GetLang(string langKey, string playerId = null) => lang.GetMessage(langKey, this, playerId);

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (!player.IsConnected) return;
            string message = GetLang(textOrLang, player.Id);
            player.Reply(message != textOrLang ? message : textOrLang);
        }

        #endregion Helpers
    }
}

// --- End of file: MoneyTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-paratroopers-panel ---
// --- Original File Path: M/MagicParatroopersPanel/MagicParatroopersPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Component = UnityEngine.Component;

namespace Oxide.Plugins
{
    [Info("Magic Paratroopers Panel", "MJSU", "1.0.1")]
    [Description("Displays if the paratroopers event is active")]
    public class MagicParatroopersPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<CargoPlane> _activePlanes = new List<CargoPlane>();
        private bool _init;

        private const string ComponentName = "ParatrooperPlane";
        
        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/P5zNsLtx/yGEJXN5.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.0f, 0.0f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 20,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activePlanes = UnityEngine.Object.FindObjectsOfType<CargoPlane>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activePlanes.Count == 0 || _activePlanes.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(CargoPlane plane)
        {
            if (!_init)
            {
                return;
            }
        
            NextTick(() =>
            {
                if (!CanShowPanel(plane))
                {
                    return;
                }
            
                _activePlanes.Add(plane);
                CheckEvent();
            });
        }

        private void OnEntityKill(CargoPlane plane)
        {
            if (!_activePlanes.Remove(plane))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activePlanes.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private bool CanShowPanel(CargoPlane plane)
        {
            return HasComponent(plane, ComponentName);
        }

        private bool? MagicPanelCanShow(string name, CargoPlane plane)
        {
            if (HasComponent(plane, ComponentName))
            {
                return false;
            }

            return null;
        }
        
        private bool HasComponent(BaseEntity entity, string name)
        {
            return entity.GetComponents<Component>().Any(component => component.GetType().Name == name);
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#DE8732FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicParatroopersPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mass-genocide ---
// --- Original File Path: M/MassGenocide/MassGenocide.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Mass Genocide", "Ryz0r", "1.0.2")]
    [Description("Allows players with permission to kill all players at once.")]
    public class MassGenocide : RustPlugin
    {
        private const string NoKillPerm = "massgenocide.nokill";
        private const string UsePerm = "massgenocide.use";

        private void Init()
        {
            permission.RegisterPermission(NoKillPerm, this);
            permission.RegisterPermission(UsePerm, this);
            AddCovalenceCommand("genocide", nameof(GenocideCommand));
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GenocideComing"] = "The <color=red>genocide</color> is coming...",
                ["NoPerm"] = "You do not have the required permissions to use this command.",
                ["ConsoleStarts"] = "You have initiated the Genocide...",
                ["CountdownMessage"] = "The genocide is happening in {0} seconds!",
                ["NowHappening"] = "The mass genocide is now happening!"
            }, this);
        }

        private void GenocideCommand(IPlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.Id, UsePerm) || player.IsAdmin)
            {
                player.Message(lang.GetMessage("ConsoleStarts", this), "[Mass Genocide]");

                var countdown = 5;
                timer.Repeat(1f, countdown, () =>
                {
                    player.Message(string.Format(lang.GetMessage("CountdownMessage", this), countdown), "[Mass Genocide]");
                    countdown--;
                    if (countdown != 0) return;
                    Server.Broadcast(lang.GetMessage("GenocideComing", this, player.Id));
                    player.Message(lang.GetMessage("NowHappening", this),"[Mass Genocide]");
                    foreach (var b in BasePlayer.activePlayerList)
                    {
                        if (permission.UserHasPermission(b.UserIDString, NoKillPerm)) continue;
                        b.Die();
                    }
                });
            }
            else
            {
                player.Message(lang.GetMessage("NoPerm", this, player.Id));
            }
        }
    }
}

// --- End of file: MassGenocide.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-gather-panel ---
// --- Original File Path: M/MagicGatherPanel/MagicGatherPanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Gather Panel", "MJSU", "1.0.2")]
    [Description("Displays gather rate in magic panel")]
    public class MagicGatherPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _gatherFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _gatherFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/nzzPfwDL/gV9P0cK.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.67f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0:0.00}x",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "lefttop",
                Order = config.PanelSettings?.Order ?? 0,
                Width = config.PanelSettings?.Width ?? 0.055f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region Gather Update Hook
        private void OnGlobalGatherUpdated()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }
        
        private void OnPlayerGatherUpdated(BasePlayer player)
        {
            MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                object globalGather = Interface.Call("GetGlobalGather");
                if (globalGather is float)
                {
                    text.Text = string.Format(_gatherFormat, (float)globalGather);
                }
                else
                {
                    object playerGather = Interface.Call("GetGatherForPlayer", player);
                    if (playerGather is float)
                    {
                        text.Text = string.Format(_gatherFormat, (float)playerGather);
                    }
                    else
                    {
                        text.Text = string.Format(_gatherFormat, _pluginConfig.DefaultGather);
                    }
                }
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(1f)]
            [JsonProperty(PropertyName = "Default Gather")]
            public float DefaultGather { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; } 
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicGatherPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-server-time-panel ---
// --- Original File Path: M/MagicServerTimePanel/MagicServerTimePanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Server Time Panel", "MJSU", "1.0.6")]
    [Description("Displays the servers local time in magic panel")]
    public class MagicServerTimePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private string _textFormat;
        private string _previousTime;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.28f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/TYF0K3Wf/cGisDjH.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.72f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0:hh:mm tt}"
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftbottom",
                Order = config.PanelSettings?.Order ?? 2,
                Width = config.PanelSettings?.Width ?? 0.075f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
            UpdateTime();
            timer.Every(_pluginConfig.UpdateRate, UpdateTime);
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void UpdateTime()
        {
            string current = string.Format(_textFormat, DateTime.Now + TimeSpan.FromMinutes(_pluginConfig.MinuteOffset));
            if (current == _previousTime)
            {
                return;
            }

            _previousTime = current;
            MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, _previousTime);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(60f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(0)]
            [JsonProperty(PropertyName = "Offset time (Minutes)")]
            public int MinuteOffset { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicServerTimePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mlrs-hellfire ---
// --- Original File Path: M/MLRSHellfire/MLRSHellfire.cs ---

﻿using UnityEngine;
using System.Linq;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Text;
using System;

namespace Oxide.Plugins
{
    [Info("MLRS Hellfire", "Timm3D", "1.0.8")]
    [Description("Manage MLRS and/or call MLRS missiles to a specific point, in different ways.")]
    internal class MLRSHellfire : RustPlugin
    {
        #region Permissions

        //Master Permission -> Let u do everything. DON'T GIVE THIS PERMISSION NORMAL PLAYERS!
        private const string MLRSHellfire_Admin = "mlrshellfire.admin";

        private const string MLRSHellfire_MLRSMountBypass = "mlrshellfire.mlrsmountbypass";
        private const string MLRSHellfire_UseRemoteMLRS = "mlrshellfire.useremotemlrs";
        private const string MLRSHellfire_RemoteMLRS_AllowTargetingPlayer = "mlrshellfire.allowtargetingplayer";
        private const string MLRSHellfire_RemoteMLRS_MLRSBrokenBypass = "mlrshellfire.mlrsbrokenbypass";

        #endregion

        #region Oxide Stuff

        private PluginConfig mConfig;

        private void Init()
        {
            permission.RegisterPermission(MLRSHellfire_Admin, this);

            permission.RegisterPermission(MLRSHellfire_MLRSMountBypass, this);
            permission.RegisterPermission(MLRSHellfire_UseRemoteMLRS, this);
            permission.RegisterPermission(MLRSHellfire_RemoteMLRS_AllowTargetingPlayer, this);
            permission.RegisterPermission(MLRSHellfire_RemoteMLRS_MLRSBrokenBypass, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                mConfig = Config.ReadObject<PluginConfig>();

                if (mConfig == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }

                if (mConfig.HellfireFireInterval <= 0.0f)
                    mConfig.HellfireFireInterval = 0.1f;

                if (mConfig.MLRSFireInterval <= 0.0f)
                    mConfig.MLRSFireInterval = 0.1f;

                if (mConfig.RemoteMLRSFireInterval <= 0f)
                    mConfig.RemoteMLRSFireInterval = 0.1f;
            }
            catch
            {
                LoadDefaultConfig();
                SaveConfig();
                return;
            }
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                PluginPicture = 76561198838421574,
                PluginPrefix = "<color=#191A28>[</color><color=#CC3B28>MLRS Hellfire</color><color=#191A28>]</color> ",
                HellfireRocketDamageModifier = 1.0f,
                HellfireRocketExplosiveRadiusModifier = 1.0f,
                HellfireFireInterval = 0.3f,
                MLRSFireInterval = 1.0f,
                RemoteMLRSFireInterval = 1.0f,
                AllowUsingOfMLRSForAllPlayers = true,
                HellFireMaxRocketAmountToSpawn = 50,
            };
        }

        protected override void LoadDefaultConfig()
        {
            mConfig = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(mConfig, true);
        }

        class PluginConfig
        {
            [JsonProperty]
            public ulong PluginPicture { get; set; }

            [JsonProperty]
            public string PluginPrefix { get; set; }

            [JsonProperty]
            public float HellfireRocketDamageModifier { get; set; }

            [JsonProperty]
            public float HellfireRocketExplosiveRadiusModifier { get; set; }

            [JsonProperty("MLRSFireInterval in seconds")]
            public float MLRSFireInterval { get; set; }

            [JsonProperty("RemoteMLRSFireInterval in seconds")]
            public float RemoteMLRSFireInterval { get; set; }

            [JsonProperty("HellfireFireInterval in seconds")]
            public float HellfireFireInterval { get; set; }

            [JsonProperty("Allow using of MLRS for all players like in vanilla rust")]
            public bool AllowUsingOfMLRSForAllPlayers { get; set; }

            [JsonProperty("Max amount of rockets which can spawn when using hellfire command with custom missle amount")]
            public uint HellFireMaxRocketAmountToSpawn { get; set; }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Note_MLRS_StartedAttack"] = Note_MLRS_StartedAttack,
                ["Note_MLRS_FiringIn10Sec"] = Note_MLRS_FiringIn10Sec,
                ["Note_MLRS_Fixed"] = Note_MLRS_Fixed,
                ["Note_All_MLRS_Fixed"] = Note_All_MLRS_Fixed,
                ["Note_MLRS_Enabled"] = Note_MLRS_Enabled,
                ["Note_MLRS_Disabled"] = Note_MLRS_Disabled,
                ["Note_MLRS_Status_Enabled"] = Note_MLRS_Status_Enabled,
                ["Note_MLRS_Status_Disabled"] = Note_MLRS_Status_Disabled,

                ["Error_MLRS_NoMLRS"] = Error_MLRS_NoMLRS,
                ["Error_MLRS_CantFindPlayer"] = Error_MLRS_CantFindPlayer,
                ["Error_MLRS_NoMapMark"] = Error_MLRS_NoMapMark,
                ["Error_MLRS_Disabled"] = Error_MLRS_Disabled,
                ["Error_MLRS_IsBusy"] = Error_MLRS_IsBusy,

                ["Error_FoundMultiplePlayer"] = Error_FoundMultiplePlayer,

                ["Note_HellFire_StartedAttack"] = Note_HellFire_StartedAttack,

                ["Error_HellFire_NoMapMark"] = Error_HellFire_NoMapMark,
                ["Error_HellFire_InvalidAmount"] = Error_HellFire_InvalidAmount,
                ["Error_HellFire_CantFindPlayer"] = Error_HellFire_CantFindPlayer,

                ["Error_RemoteMLRS_NoMissles"] = Error_RemoteMLRS_NoMissles,
                ["Error_RemoteMLRS_InvalidAmount"] = Error_RemoteMLRS_InvalidAmount,
                ["Error_RemoteMLRS_NoMapMark"] = Error_RemoteMLRS_NoMapMark,
                ["Error_RemoteMLRS_MRLSBroken"] = Error_RemoteMLRS_MRLSBroken,

                ["Error_NoPermission"] = Error_NoPermission,

                ["Syntax_MLRS"] = Syntax_MLRS,
                ["Syntax_HellFire"] = Syntax_HellFire,
                ["Syntax_RemoteMLRS"] = Syntax_RemoteMLRS
            }, this, "en");
        }

        #endregion

        #region Default Chat Messages

        private const string Note_MLRS_StartedAttack = "<color=#F75B00>MLRS started to attack the target.</color>";
        private const string Note_MLRS_FiringIn10Sec = "MLRS will start firing in 10 seconds!";
        private const string Note_MLRS_Fixed = "Main MLRS has been fixed.";
        private const string Note_All_MLRS_Fixed = "All found MLRS has been fixed.";
        private const string Note_MLRS_Enabled = "The using of MLRS has been </color><color=#48B11E>enabled</color> for all players.";
        private const string Note_MLRS_Disabled = "The using of MLRS has been </color><color=#F70000>disabled</color> for all players.";
        private const string Note_MLRS_Status_Enabled = "MLRS is </color><color=#48B11E>enabled</color> for all players on the server.";
        private const string Note_MLRS_Status_Disabled = "MLRS is </color><color=#F70000>disabled</color> for all players on the server.";

        private const string Error_MLRS_NoMLRS = "</color><color=#F70000>No MRLS was found on the server.</color>";
        private const string Error_MLRS_CantFindPlayer = "</color><color=#F70000>Couldn't find this player!</color>\n" +
            "Type <color=#E9AC3C>/mlrs</color> for help.";
        private const string Error_MLRS_NoMapMark = "</color><color=#F70000>No map mark set. Please create a map marker on the map with the name \"MLRSTARGET\" to attack.</color>\n" +
            "Type <color=#E9AC3C>/mlrs</color> for help.";
        private const string Error_MLRS_Disabled = "</color><color=#F70000>MLRS has been disabled on this server.</color>\n";
        private const string Error_MLRS_IsBusy = "</color><color=#F70000>MLRS is currently busy. Try it again later.</color>\n";

        private const string Note_HellFire_StartedAttack = "<color=#F75B00>Started hellfire attack to the target.</color>";

        private const string Error_HellFire_NoMapMark = "</color><color=#F70000>No map mark set. Please mark a point on the map to attack.</color>\n" +
            "Type <color=#E9AC3C>/hellfire</color> for help.";
        private const string Error_HellFire_InvalidAmount = "</color><color=#F70000>Invalid amount of rockets.</color>\n" +
            "Type <color=#E9AC3C>/hellfire</color> for help.";
        private const string Error_HellFire_CantFindPlayer = "</color><color=#F70000>Couldn't find this player!</color>\n" +
            "Type <color=#E9AC3C>/hellfire</color> for help.";

        private const string Error_FoundMultiplePlayer = "</color><color=#ffff00>Found multiple target players, you have to specify it more:</color> ";

        private const string Error_RemoteMLRS_NoMissles = "</color><color=#F70000>You don't have any MLRS missles in your inventory!</color>\n" +
            "Type <color=#E9AC3C>/remotemlrs</color> for help.";
        private const string Error_RemoteMLRS_InvalidAmount = "</color><color=#F70000>Invalid amount of rockets.</color>\n" +
            "Type <color=#E9AC3C>/remotemlrs</color> for help.";
        private const string Error_RemoteMLRS_NoMapMark = "</color><color=#F70000>No map mark set. Please mark a point on the map to attack.</color>\n" +
            "Type <color=#E9AC3C>/remotemlrs</color> for help.";
        private const string Error_RemoteMLRS_MRLSBroken = "</color><color=#F70000>MLRS is currently broken! Try it again later.</color>";

        private const string Error_NoPermission = "</color><color=#F70000>You don't have the permission to use this plugin command!</color>";

        private const string Syntax_MLRS = "<color=#4BF0FF>MLRS Commands:</color>\n" +
            "<color=#D97E29>/mlrsfire map</color> => MLRS will start to attack the marked spot on the map.\n" +
            "<color=#D97E29>/mlrsfire map</color> <color=#2990D9>(amount)</color> => MLRS will start to attack the marked spot on the map with the entered amount of rockets.\n" +
            "<color=#D97E29>/mlrsfire p {playername}</color> => MLRS will start to attack the target players spot.\n" +
            "<color=#D97E29>/mlrsfire p {playername}</color> <color=#2990D9>(amount)</color> => MLRS will start to attack the target players spot with the entered amount of rockets.\n" +
            "<color=#D97E29>/mlrsfireall map</color> => All found MLRS start to attack the marked spot on the map.\n" +
            "<color=#D97E29>/mlrsfireall map</color> <color=#2990D9>(amount)</color> => All found MLRS on this server start to attack the marked spot on the map with the entered amount of rockets.\n" +
            "<color=#D97E29>/mlrsfireall p {playername}</color> => All found MLRS will start to attack the target players spot.\n" +
            "<color=#D97E29>/mlrsfireall p {playername}</color> <color=#2990D9>(amount)</color> => All found MLRS will start to attack the target players spot with the entered amount of rockets.\n" +
            "<color=#D97E29>/mlrsfix</color> => Repears the active MLRS on the server.\n" +
            "<color=#D97E29>/mlrsfixall</color> => Repears all found MLRS on the server.\n" +
            "<color=#D97E29>/mlrs enable</color> => Allows all players to use MLRS like in vanilla rust.\n" +
            "<color=#D97E29>/mlrs disable</color> => Prevent all players to mount/use the MLRS on the server (can be bypassed with perm).\n" +
            "<color=#D97E29>/mlrs status</color> => Shows you if MLRS is enabled or disabled on this server.";

        private const string Syntax_HellFire = "<color=#4BF0FF>HellFire Commands:</color>\n" +
            "<color=#D97E29>/hellfire p {playername}</color> => MLRS rocket spawns and start to attack the target players spot.\n" +
            "<color=#D97E29>/hellfire p {playername}</color> <color=#2990D9>(amount)</color> => x MLRS rockets spawning and start to attack the target players spot.\n" +
            "<color=#D97E29>/hellfire map</color> => MLRS Rocket spawns and start to attack the marked spot on the map.\n" +
            "<color=#D97E29>/hellfire map</color> <color=#2990D9>(amount)</color> => x MLRS Rocket spawning and start to attack the marked spot on the map.";

        private const string Syntax_RemoteMLRS = "<color=#4BF0FF>RemoteMLRS Commands:</color>\n" +
            "<color=#FFED47>Info:</color> You need MLRS Rockets to call a remote MLRS attack.\n" +
            "<color=#D97E29>/remotemlrs p {playername}</color> => Calls MLRS attack to target players spot. Takes up to 12 MLRS rockets. (need extra perms)\n" +
            "<color=#D97E29>/remotemlrs p {playername}</color> <color=#2990D9>(amount)</color> => MLRS will start to attack the target players spot. Takes x (max 12) MLRS rockets (need extra perms)\n" +
            "<color=#D97E29>/remotemlrs map</color> => MLRS will start to attack the marked spot on the map. Takes up to 12 MLRS rockets.\n" +
            "<color=#D97E29>/remotemlrs map</color> <color=#2990D9>(amount)</color> => MLRS will start to attack the marked spot on the map. Takes x (max 12) MLRS rockets.\n";

        #endregion

        #region Used Hooks

        object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            if (!(entity is MLRS) || mConfig.AllowUsingOfMLRSForAllPlayers)
                return null;

            if (!(player.IPlayer.HasPermission(MLRSHellfire_Admin)
                || player.IPlayer.HasPermission(MLRSHellfire_MLRSMountBypass)))
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_Disabled", this, player.UserIDString));
                return false;
            }

            if (mainMLRS.isBusy)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_IsBusy", this, player.UserIDString));
                return false;
            }

            return null;
        }

        #endregion

        #region Chat

        private void ChatReply(BasePlayer player, string message) =>
            Player.Reply(player, mConfig.PluginPrefix + message, mConfig.PluginPicture);

        #endregion

        #region Fields/Constants

        /// <summary>
        /// Path to MLRS missle prefab.
        /// </summary>
        private const string MLRSRocketPrefab = "assets/content/vehicles/mlrs/rocket_mlrs.prefab";

        /// <summary>
        /// Saves all active MLRS on the server.
        /// </summary>
        private static List<CustomMLRS> allActiveMRLSOnServer = GetAllActiveMLRS();

        /// <summary>
        /// This is used to save the damage of MLRS rockets.
        /// </summary>
        private static TimedExplosive mlrsRocketTimedExplosive;

        /// <summary>
        /// This is your main MLRS on your server.
        /// </summary>
        private static CustomMLRS mainMLRS = GetActiveMainMLRS();

        private const string MapNoteTargetName = "MLRSTARGET";

        #endregion

        #region Plugin Logic

        #region MLRS

        [ChatCommand("mlrs")]
        private void Mlrs(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length != 1)
            {
                ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "enable":
                    {
                        mConfig.AllowUsingOfMLRSForAllPlayers = true;
                        SaveConfig();
                        ChatReply(player, lang.GetMessage("Note_MLRS_Enabled", this, player.UserIDString));
                        break;
                    }
                case "disable":
                    {
                        mConfig.AllowUsingOfMLRSForAllPlayers = false;
                        SaveConfig();
                        ChatReply(player, lang.GetMessage("Note_MLRS_Disabled", this, player.UserIDString));
                        break;
                    }
                case "status":
                    {
                        if (mConfig.AllowUsingOfMLRSForAllPlayers)
                            ChatReply(player, lang.GetMessage("Note_MLRS_Status_Enabled", this, player.UserIDString));
                        else
                            ChatReply(player, lang.GetMessage("Note_MLRS_Status_Disabled", this, player.UserIDString));
                        break;
                    }
                default:
                    {
                        ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                        return;
                    }
            }
        }

        [ChatCommand("mlrsfire")]
        private void MlrsFire(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            var mlrs = GetActiveMainMLRS();

            if (mlrs == null)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_NoMLRS", this, player.UserIDString));
                return;
            }

            if (args.Length < 1 || args.Length > 3)
            {
                ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                return;
            }

            if (mainMLRS.isBusy)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_IsBusy", this, player.UserIDString));
                return;
            }

            Vector3 targetPosition;
            int rocketsToSpawn = 0;

            switch (args[0].ToLower())
            {
                case "p":
                    {
                        if (args.Length < 2 || args.Length > 3)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                            return;
                        }

                        var targetPlayer = SearchAndGetTargetPlayer(args[1], player);

                        if (targetPlayer != null)
                        {
                            targetPosition = targetPlayer.ServerPosition;
                        }
                        else
                        {
                            return;
                        }

                        if (args.Length == 3)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[2], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                case "map":
                    {
                        if (args.Length < 1 || args.Length > 2)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                            return;
                        }

                        var worldPosition = GetTargetMapNotePosition(player);

                        if (worldPosition == Vector3.zero)
                        {
                            ChatReply(player, lang.GetMessage("Error_MLRS_NoMapMark", this, player.UserIDString));
                            return;
                        }

                        targetPosition = worldPosition;

                        if (args.Length == 2)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[1], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                default:
                    {
                        ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                        return;
                    }
            }

            mainMLRS.isBusy = true;

            if (rocketsToSpawn == 0)
                rocketsToSpawn = 12;

            mlrs.instance.SetRepaired();

            var rocketContainer = mlrs.instance.GetRocketContainer();
            var mlrsRocket = rocketContainer.allowedItem;

            if (rocketsToSpawn > 12)
            {
                rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn);
                rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn - 12);
            }
            else
                rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn);

            mlrs.instance.RocketAmmoCount = rocketsToSpawn;
            mlrs.instance.nextRocketIndex = rocketsToSpawn - 1;

            mlrs.instance.SetUserTargetHitPos(targetPosition);

            ChatReply(player, lang.GetMessage("Note_MLRS_FiringIn10Sec", this, player.UserIDString));

            timer.Once(10f, () =>
            {
                mlrs.instance.SetFlag(BaseEntity.Flags.Reserved8, b: true);
                mlrs.instance.nextRocketIndex = Mathf.Min(mlrs.instance.RocketAmmoCount - 1, mlrs.instance.rocketTubes.Length - 1);
                mlrs.instance.radiusModIndex = 0;
                mlrs.instance.InvokeRepeating(mlrs.instance.FireNextRocket, 0f, mConfig.MLRSFireInterval);

                ChatReply(player, lang.GetMessage("Note_MLRS_StartedAttack", this, player.UserIDString));
            });

            timer.Once((rocketsToSpawn * mConfig.MLRSFireInterval) + 11f, () =>
            {
                mainMLRS.isBusy = false;
            });
        }

        [ChatCommand("mlrsfireall")]
        private void MlrsFireAll(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length < 1 || args.Length > 3)
            {
                ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                return;
            }

            var allMLRS = GetAllActiveMLRS();

            if (allMLRS.Count == 0)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_NoMLRS", this, player.UserIDString));
                return;
            }

            Vector3 targetPosition;
            int rocketsToSpawn = 0;

            switch (args[0].ToLower())
            {
                case "p":
                    {
                        if (args.Length < 2 || args.Length > 3)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                            return;
                        }

                        var targetPlayer = SearchAndGetTargetPlayer(args[1], player);

                        if (targetPlayer != null)
                        {
                            targetPosition = targetPlayer.ServerPosition;
                        }
                        else
                        {
                            return;
                        }

                        if (args.Length == 3)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[2], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                case "map":
                    {
                        if (args.Length < 1 || args.Length > 2)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                            return;
                        }

                        var worldPosition = GetTargetMapNotePosition(player);

                        if (worldPosition == Vector3.zero)
                        {
                            ChatReply(player, lang.GetMessage("Error_MLRS_NoMapMark", this, player.UserIDString));
                            return;
                        }

                        targetPosition = worldPosition;

                        if (args.Length == 2)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[1], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                default:
                    {
                        ChatReply(player, lang.GetMessage("Syntax_MLRS", this, player.UserIDString));
                        return;
                    }
            }

            if (rocketsToSpawn == 0)
                rocketsToSpawn = 12;

            int busyMLRSCounter = 0;
            int removedMLRSCounter = 0;

            foreach (var mlrs in allMLRS)
            {
                if (mlrs.instance == null)
                {
                    removedMLRSCounter++;
                    continue;
                }

                bool isMainMLRS = mlrs.mlrsId == mainMLRS.mlrsId;

                if (isMainMLRS && mainMLRS.isBusy)
                {
                    busyMLRSCounter++;
                    continue;
                }

                if (mlrs.isBusy)
                {
                    busyMLRSCounter++;
                    continue;
                }

                if (isMainMLRS)
                    mainMLRS.isBusy = true;

                mlrs.isBusy = true;

                mlrs.instance.SetRepaired();

                var rocketContainer = mlrs.instance.GetRocketContainer();
                var mlrsRocket = rocketContainer.allowedItem;

                if (rocketsToSpawn > 12)
                {
                    rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn);
                    rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn - 12);
                }
                else
                    rocketContainer.inventory.AddItem(mlrsRocket, rocketsToSpawn);

                mlrs.instance.RocketAmmoCount = rocketsToSpawn;
                mlrs.instance.nextRocketIndex = rocketsToSpawn - 1;

                mlrs.instance.SetUserTargetHitPos(targetPosition);

                timer.Once(10f, () =>
                {
                    mlrs.instance.SetFlag(BaseEntity.Flags.Reserved8, b: true);
                    mlrs.instance.nextRocketIndex = Mathf.Min(mlrs.instance.RocketAmmoCount - 1, mlrs.instance.rocketTubes.Length - 1);
                    mlrs.instance.radiusModIndex = 0;
                    mlrs.instance.InvokeRepeating(mlrs.instance.FireNextRocket, 0f, mConfig.MLRSFireInterval);
                });

                timer.Once((rocketsToSpawn * mConfig.MLRSFireInterval) + 11f, () =>
                {
                    if (isMainMLRS)
                        mainMLRS.isBusy = false;

                    mlrs.isBusy = false;
                });
            }

            if (busyMLRSCounter + removedMLRSCounter != allMLRS.Count)
            {
                ChatReply(player, lang.GetMessage("Note_MLRS_FiringIn10Sec", this, player.UserIDString));

                timer.Once(10f, () =>
                {
                    ChatReply(player, lang.GetMessage("Note_MLRS_StartedAttack", this, player.UserIDString));
                });
            }

            if (busyMLRSCounter != 0) // Neue Note
                ChatReply(player, $"<color=#F75B00>{busyMLRSCounter}</color> of <color=#2990D9>{allMLRS.Count}</color> MLRS are currently busy and will be skipped for this operation.");

            if (removedMLRSCounter != 0) // Neute Note
                ChatReply(player, $"<color=#F75B00>{removedMLRSCounter}</color> of <color=#2990D9>{allMLRS.Count}</color> MLRS aren't there anymore.");
        }

        [ChatCommand("mlrsfix")]
        private void MLRSFix(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            var mlrs = GetActiveMainMLRS();

            if (mlrs == null)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_NoMLRS", this, player.UserIDString));
                return;
            }

            mlrs.instance.SetRepaired();

            ChatReply(player, lang.GetMessage("Note_MLRS_Fixed", this, player.UserIDString));
        }

        [ChatCommand("mlrsfixall")]
        private void MLRSFixAll(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            var allMlrs = GetAllActiveMLRS();

            if (allMlrs == null)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_NoMLRS", this, player.UserIDString));
                return;
            }

            foreach (var mlrs in allMlrs)
                mlrs.instance.SetRepaired();

            ChatReply(player, lang.GetMessage("Note_All_MLRS_Fixed", this, player.UserIDString));
        }

        #endregion

        #region Remote MLRS

        [ChatCommand("remotemlrs")]
        private void RemoteMlrs(BasePlayer player, string command, string[] args)
        {
            if (!(player.IPlayer.HasPermission(MLRSHellfire_Admin)
                || player.IPlayer.HasPermission(MLRSHellfire_UseRemoteMLRS)))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            var mlrs = GetActiveMainMLRS();

            if (mlrs == null)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_NoMLRS", this, player.UserIDString));
                return;
            }

            if (mainMLRS.isBusy)
            {
                ChatReply(player, lang.GetMessage("Error_MLRS_IsBusy", this, player.UserIDString));
                return;
            }

            if (mlrs.instance.IsBroken())
            {
                if (!(player.IPlayer.HasPermission(MLRSHellfire_Admin)
                || player.IPlayer.HasPermission(MLRSHellfire_RemoteMLRS_MLRSBrokenBypass)))
                {
                    ChatReply(player, lang.GetMessage("Error_RemoteMLRS_MRLSBroken", this, player.UserIDString));
                    return;
                }
            }

            if (args.Length < 1 || args.Length > 3)
            {
                ChatReply(player, lang.GetMessage("Syntax_RemoteMLRS", this, player.UserIDString));
                return;
            }

            var mlrsMissleContainer = player.inventory.AllItems()
                .Where(item => item.HasAmmo(Rust.AmmoTypes.MLRS_ROCKET)).ToArray();

            if (mlrsMissleContainer.Length == 0)
            {
                ChatReply(player, lang.GetMessage("Error_RemoteMLRS_NoMissles", this, player.UserIDString));
                return;
            }

            Vector3 targetPosition;
            int rocketsToSpawn = 0;

            switch (args[0].ToLower())
            {
                case "p":
                    {
                        if (!(player.IPlayer.HasPermission(MLRSHellfire_Admin)
                            || player.IPlayer.HasPermission(MLRSHellfire_RemoteMLRS_AllowTargetingPlayer)))
                        {
                            ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                            return;
                        }

                        if (args.Length < 2 || args.Length > 3)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_RemoteMLRS", this, player.UserIDString));
                            return;
                        }

                        var targetPlayer = SearchAndGetTargetPlayer(args[1], player);

                        if (targetPlayer != null)
                        {
                            targetPosition = targetPlayer.ServerPosition;
                        }
                        else
                        {
                            return;
                        }

                        if (args.Length == 3)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[2], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                case "map":
                    {
                        if (args.Length < 1 || args.Length > 2)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_RemoteMLRS", this, player.UserIDString));
                            return;
                        }

                        var worldPosition = GetTargetMapNotePosition(player);

                        if (worldPosition == Vector3.zero)
                        {
                            ChatReply(player, lang.GetMessage("Error_MLRS_NoMapMark", this, player.UserIDString));
                            return;
                        }

                        targetPosition = worldPosition;

                        if (args.Length == 2)
                        {
                            int tmpAmount;

                            if (IsValidMLRSMissleAmount(args[1], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                default:
                    {
                        ChatReply(player, lang.GetMessage("Syntax_RemoteMLRS", this, player.UserIDString));
                        return;
                    }
            }

            mainMLRS.isBusy = true;

            if (rocketsToSpawn == 0)
                rocketsToSpawn = 12;

            int missleAmount = 0;

            foreach (var itemRocketContainer in mlrsMissleContainer)
            {
                if (itemRocketContainer.amount <= 0)
                    continue;

                if (itemRocketContainer.amount >= rocketsToSpawn)
                {
                    missleAmount = rocketsToSpawn;

                    if ((itemRocketContainer.amount - rocketsToSpawn) > 0)
                        itemRocketContainer.amount -= rocketsToSpawn;
                    else
                        itemRocketContainer.DoRemove();

                    break;
                }
                else
                {
                    if ((missleAmount + itemRocketContainer.amount) > rocketsToSpawn)
                    {
                        while (missleAmount != rocketsToSpawn)
                        {
                            missleAmount++;
                            itemRocketContainer.amount--;
                        }

                        break;
                    }
                    else
                    {
                        missleAmount += itemRocketContainer.amount;
                        itemRocketContainer.DoRemove();
                    }
                }
            }

            mlrs.instance.SetRepaired();

            var rocketContainer = mlrs.instance.GetRocketContainer();
            var mlrsRocket = rocketContainer.allowedItem;

            rocketContainer.inventory.AddItem(mlrsRocket, missleAmount);

            mlrs.instance.RocketAmmoCount = missleAmount;
            mlrs.instance.nextRocketIndex = missleAmount - 1;

            mlrs.instance.rocketOwnerRef.Set(player);

            mlrs.instance.SetUserTargetHitPos(targetPosition);

            ChatReply(player, lang.GetMessage("Note_MLRS_FiringIn10Sec", this, player.UserIDString));

            timer.Once(10f, () =>
            {
                mlrs.instance.SetFlag(BaseEntity.Flags.Reserved8, b: true);
                mlrs.instance.nextRocketIndex = Mathf.Min(mlrs.instance.RocketAmmoCount - 1, mlrs.instance.rocketTubes.Length - 1);
                mlrs.instance.radiusModIndex = 0;
                mlrs.instance.InvokeRepeating(mlrs.instance.FireNextRocket, 0f, mConfig.RemoteMLRSFireInterval);

                ChatReply(player, lang.GetMessage("Note_MLRS_StartedAttack", this, player.UserIDString));
            });

            timer.Once((missleAmount * mConfig.RemoteMLRSFireInterval) + 11f, () =>
            {
                mainMLRS.isBusy = false;
            });
        }

        #endregion

        #region Hellfire

        [ChatCommand("hellfire")]
        private void Hellfire(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(MLRSHellfire_Admin))
            {
                ChatReply(player, lang.GetMessage("Error_NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length < 1 || args.Length > 3)
            {
                ChatReply(player, lang.GetMessage("Syntax_HellFire", this, player.UserIDString));
                return;
            }

            Vector3 targetPosition;
            int rocketsToSpawn = 1;

            switch (args[0].ToLower())
            {
                case "p":
                    {
                        if (args.Length < 2 || args.Length > 3)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_HellFire", this, player.UserIDString));
                            return;
                        }

                        var targetPlayer = SearchAndGetTargetPlayer(args[1], player);

                        if (targetPlayer != null)
                        {
                            targetPosition = targetPlayer.ServerPosition;
                        }
                        else
                        {
                            return;
                        }

                        if (args.Length == 3)
                        {
                            int tmpAmount;

                            if (IsValidHellfireMissleAmount(args[2], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                case "map":
                    {
                        if (args.Length < 1 || args.Length > 2)
                        {
                            ChatReply(player, lang.GetMessage("Syntax_HellFire", this, player.UserIDString));
                            return;
                        }

                        var worldPosition = GetTargetMapNotePosition(player);

                        if (worldPosition == Vector3.zero)
                        {
                            ChatReply(player, lang.GetMessage("Error_MLRS_NoMapMark", this, player.UserIDString));
                            return;
                        }

                        targetPosition = worldPosition;

                        if (args.Length == 2)
                        {
                            int tmpAmount;

                            if (IsValidHellfireMissleAmount(args[1], out tmpAmount))
                                rocketsToSpawn = tmpAmount;
                            else
                            {
                                ChatReply(player, lang.GetMessage("Error_HellFire_InvalidAmount", this, player.UserIDString));
                                return;
                            }
                        }

                        break;
                    }
                default:
                    {
                        ChatReply(player, lang.GetMessage("Syntax_HellFire", this, player.UserIDString));
                        return;
                    }
            }

            if (rocketsToSpawn != 1)
            {
                timer.Repeat(mConfig.HellfireFireInterval, rocketsToSpawn, () =>
                {
                    ExecuteFireOperation(player, targetPosition);
                });
            }
            else
                ExecuteFireOperation(player, targetPosition);

            ChatReply(player, lang.GetMessage("Note_HellFire_StartedAttack", this, player.UserIDString));
        }

        #endregion

        #region Missle Methods

        private void ExecuteFireOperation(BasePlayer player, Vector3 targetPosition)
        {
            float baseGravity;
            Vector3 aimToTarget = GetAimToTarget(player.ServerPosition, targetPosition, out baseGravity);

            var startPoint = player.ServerPosition;
            startPoint.y += 15f;

            ServerProjectile projectile;

            if (CreateAndSpawnRocket(startPoint, aimToTarget, out projectile) == false)
                return;

            projectile.gravityModifier = baseGravity / (0f - Physics.gravity.y);
        }

        private Vector3 GetAimToTarget(Vector3 startPosition, Vector3 targetPos, out float baseGravity)
        {
            Vector3 vector = targetPos - startPosition;

            float num = 90f;
            float num2 = vector.Magnitude2D();
            float y = vector.y;
            float num5 = 40f;

            baseGravity = ProjectileDistToGravity(Mathf.Max(num2, 50f), y, num5, num);

            vector.Normalize();
            vector.y = 0f;

            Vector3 axis = Vector3.Cross(vector, Vector3.up);

            vector = Quaternion.AngleAxis(num5, axis) * vector;

            return vector;
        }

        private bool CreateAndSpawnRocket(Vector3 firingPos, Vector3 firingDir,
            out ServerProjectile mlrsRocketProjectile)
        {
            RaycastHit hitInfo;

            float launchOffset = 0f;

            if (Physics.Raycast(firingPos, firingDir, out hitInfo, launchOffset, 1236478737))
                launchOffset = hitInfo.distance - 0.1f;

            var mlrsRocketEntity = GameManager.server.CreateEntity(MLRSRocketPrefab, firingPos + firingDir * launchOffset);

            if (mlrsRocketEntity == null)
            {
                mlrsRocketProjectile = null;
                return false;
            }

            mlrsRocketProjectile = mlrsRocketEntity.GetComponent<ServerProjectile>();

            var velocityVector = mlrsRocketProjectile.initialVelocity + firingDir * mlrsRocketProjectile.speed;

            mlrsRocketProjectile.InitializeVelocity(velocityVector);

            var mlrsRocket = mlrsRocketEntity as MLRSRocket;

            if (mlrsRocket == null)
                return false;

            ApplyMLRSRocketModfications(ref mlrsRocket);

            mlrsRocket.Spawn();

            return true;
        }

        #endregion

        #region Helper Methods

        private float ProjectileDistToGravity(float x, float y, float θ, float v)
        {
            float num = θ * ((float)Math.PI / 180f);
            float num2 = (v * v * x * Mathf.Sin(2f * num) - 2f * v * v * y * Mathf.Cos(num) * Mathf.Cos(num)) / (x * x);
            if (float.IsNaN(num2) || num2 < 0.01f)
            {
                num2 = 0f - Physics.gravity.y;
            }

            return num2;
        }

        private void ApplyMLRSRocketModfications(ref MLRSRocket mlrsRocket)
        {
            mlrsRocket.explosionRadius *= mConfig.HellfireRocketExplosiveRadiusModifier;
            mlrsRocket.damageTypes = GetDamageOfHellfireRocket(mlrsRocket).damageTypes;
        }

        private BasePlayer SearchAndGetTargetPlayer(string targetPlayername, BasePlayer callingPlayer)
        {
            var targetPlayer = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(targetPlayername.ToLower())).ToArray();

            var possibleAmountOfTargetPlayer = targetPlayer.Count();

            if (possibleAmountOfTargetPlayer == 1)
            {
                return targetPlayer[0];
            }

            if (!targetPlayer.Any())
            {
                ChatReply(callingPlayer, lang.GetMessage("Error_MLRS_CantFindPlayer", this, callingPlayer.UserIDString));
                return null;
            }

            if (possibleAmountOfTargetPlayer > 1)
            {
                var possibleTargets = string.Empty;

                var allTargets = targetPlayer.Select(x => x.displayName).ToArray();

                for (int i = 0; i < allTargets.Length; i++)
                {
                    if (i + 1 != allTargets.Length)
                    {
                        possibleTargets += $"</color><color=#005fff>{allTargets[i]}</color>, ";
                        continue;
                    }
                    else
                    {
                        possibleTargets += $"</color><color=#005fff>{allTargets[i]}</color>";
                    }
                }

                ChatReply(callingPlayer, lang.GetMessage("Error_FoundMultiplePlayer", this, callingPlayer.UserIDString) + possibleTargets);

                return null;
            }

            return null;
        }

        private bool IsValidHellfireMissleAmount(string amount, out int rocketsToSpawn)
        {
            uint tmpAmount;
            rocketsToSpawn = 0;

            if (uint.TryParse(amount, out tmpAmount))
            {
                if (tmpAmount > mConfig.HellFireMaxRocketAmountToSpawn)
                    rocketsToSpawn = (int)mConfig.HellFireMaxRocketAmountToSpawn;
                else
                    rocketsToSpawn = (int)tmpAmount;

                return true;
            }

            return false;
        }

        private bool IsValidMLRSMissleAmount(string amount, out int rocketsToSpawn)
        {
            uint tmpAmount;
            rocketsToSpawn = 0;

            if (uint.TryParse(amount, out tmpAmount))
            {
                if (tmpAmount > 12)
                    rocketsToSpawn = 12;
                else
                    rocketsToSpawn = (int)tmpAmount;

                return true;
            }

            return false;
        }

        private static CustomMLRS GetActiveMainMLRS()
        {
            if (mainMLRS != null)
                return mainMLRS;

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is MLRS)
                {
                    mainMLRS = new CustomMLRS((MLRS)entity);
                    return mainMLRS;
                }
            }

            return null;
        }

        private static List<CustomMLRS> GetAllActiveMLRS()
        {
            var allMLRS = _GetAllActiveMLRS();

            if (allActiveMRLSOnServer != null)
                if (allMLRS.Count == allActiveMRLSOnServer.Count) // Bei löschen und neuspawnen eines MLRS, kann das neue nicht angesteuert werden, da dies nicht bemerkt wurde.
                    return allActiveMRLSOnServer; // Einfach HashCode zusätzlich abgleichen und Yalla

            allActiveMRLSOnServer = allMLRS;
            return allActiveMRLSOnServer;
        }

        private static List<CustomMLRS> _GetAllActiveMLRS()
        {
            var allFoundMLRS = new List<CustomMLRS>();

            foreach (var entity in BaseNetworkable.serverEntities)
                if (entity is MLRS)
                    allFoundMLRS.Add(new CustomMLRS((MLRS)entity));

            return allFoundMLRS;
        }

        private TimedExplosive GetDamageOfHellfireRocket(MLRSRocket mlrsRocket)
        {
            if (mlrsRocketTimedExplosive != null)
                return mlrsRocketTimedExplosive;

            foreach (var damage in mlrsRocket.damageTypes)
                damage.amount *= mConfig.HellfireRocketDamageModifier;

            mlrsRocketTimedExplosive = new TimedExplosive
            {
                damageTypes = mlrsRocket.damageTypes
            };

            return mlrsRocketTimedExplosive;
        }

        private Vector3 GetTargetMapNotePosition(BasePlayer player)
        {
            var target = player.State.pointsOfInterest.Where(p => p.label == MapNoteTargetName).ToList();

            if (!target.Any())
            {
                return Vector3.zero;
            }

            return target.First().worldPosition;
        }

        #endregion

        #region Custom MLRS

        class CustomMLRS
        {
            public CustomMLRS(MLRS mlrs)
            {
                instance = mlrs;
                mlrsId = mlrs.GetHashCode();
            }

            public readonly MLRS instance;

            public bool isBusy = false;

            public readonly int mlrsId;
        }

        #endregion

        #endregion
    }
}

// --- End of file: MLRSHellfire.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-radiation ---
// --- Original File Path: M/MonumentRadiation/MonumentRadiation.cs ---

﻿using System.Collections.Generic;
using Network;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("MonumentRadiation", "k1lly0u", "0.2.58")]
    [Description("Create radiation zones at designated monuments")]
    class MonumentRadiation : RustPlugin
    {
        private static MonumentRadiation Instance { get; set; }

        private List<RadiationZone> radiationZones = new List<RadiationZone>();

        private bool radsOn;
        private int offTimer;
        private int onTimer;

        private const int PLAYER_MASK = 131072;

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this);

            Instance = this;
            if (!ConVar.Server.radiation)
            {
                radsOn = false;
                ConVar.Server.radiation = true;
            }
            else radsOn = true;
                        
            FindMonuments();           
        }

        private void Unload()
        {
            for (int i = 0; i < radiationZones.Count; i++)            
                UnityEngine.Object.Destroy(radiationZones[i]); 
            
            radiationZones.Clear();

            DestroyAllComponents();

            if (!radsOn)
                ConVar.Server.radiation = false;

            Instance = null;
        }
        #endregion
      
        #region Functions
        private void DestroyAllComponents()
        {
            RadiationZone[] components = UnityEngine.Object.FindObjectsOfType<RadiationZone>();
            if (components != null)
            {
                for (int i = 0; i < components.Length; i++)
                {
                    UnityEngine.Object.Destroy(components[i]);
                }
            }
        }

        private void FindMonuments()
        {
            if (configData.Settings.IsHapis)
            {
                CreateHapis();
                return;
            }

            GameObject[] allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                GameObject gobject = allobjects[i];

                if (gobject.name.Contains("autospawn/monument"))
                {
                    Vector3 pos = gobject.transform.position;

                    if (gobject.name.Contains("lighthouse"))
                    {
                        if (configData.Zones.Lighthouse.Activate)
                            CreateZone(configData.Zones.Lighthouse, pos);
                        continue;
                    }

                    if (gobject.name.Contains("powerplant_1"))
                    {
                        if (configData.Zones.Powerplant.Activate)
                            CreateZone(configData.Zones.Powerplant, pos);
                        continue;
                    }

                    if (gobject.name.Contains("military_tunnel_1"))
                    {
                        if (configData.Zones.Tunnels.Activate)
                            CreateZone(configData.Zones.Tunnels, pos);
                        continue;
                    }

                    if (gobject.name.Contains("harbor_1"))
                    {
                        if (configData.Zones.LargeHarbor.Activate)
                            CreateZone(configData.Zones.LargeHarbor, pos);
                        continue;
                    }

                    if (gobject.name.Contains("harbor_2"))
                    {
                        if (configData.Zones.SmallHarbor.Activate)
                            CreateZone(configData.Zones.SmallHarbor, pos);
                        continue;
                    }

                    if (gobject.name.Contains("airfield_1"))
                    {
                        if (configData.Zones.Airfield.Activate)
                            CreateZone(configData.Zones.Airfield, pos);
                        continue;
                    }

                    if (gobject.name.Contains("trainyard_1"))
                    {
                        if (configData.Zones.Trainyard.Activate)
                            CreateZone(configData.Zones.Trainyard, pos);
                        continue;
                    }

                    if (gobject.name.Contains("water_treatment_plant_1"))
                    {
                        if (configData.Zones.WaterTreatment.Activate)
                            CreateZone(configData.Zones.WaterTreatment, pos);
                        continue;
                    }

                    if (gobject.name.Contains("warehouse"))
                    {
                        if (configData.Zones.Warehouse.Activate)
                            CreateZone(configData.Zones.Warehouse, pos);
                        continue;
                    }

                    if (gobject.name.Contains("satellite_dish"))
                    {

                        if (configData.Zones.Satellite.Activate)
                            CreateZone(configData.Zones.Satellite, pos);
                        continue;
                    }

                    if (gobject.name.Contains("sphere_tank"))
                    {
                        if (configData.Zones.Dome.Activate)
                            CreateZone(configData.Zones.Dome, pos);
                        continue;
                    }

                    if (gobject.name.Contains("radtown_small_3"))
                    {
                        if (configData.Zones.Radtown.Activate)
                            CreateZone(configData.Zones.Radtown, pos);
                        continue;
                    }

                    if (gobject.name.Contains("launch_site_1"))
                    {
                        if (configData.Zones.RocketFactory.Activate)
                        {
                            CreateZone(configData.Zones.RocketFactory, pos + -(gobject.transform.right * 80));
                            CreateZone(configData.Zones.RocketFactory, pos + gobject.transform.right * 150);
                        }
                        continue;
                    }

                    if (gobject.name.Contains("gas_station_1"))
                    {
                        if (configData.Zones.GasStation.Activate)
                            CreateZone(configData.Zones.GasStation, pos);
                        continue;
                    }

                    if (gobject.name.Contains("supermarket_1"))
                    {
                        if (configData.Zones.Supermarket.Activate)
                            CreateZone(configData.Zones.Supermarket, pos);
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_c"))
                    {
                        if (configData.Zones.Quarry_HQM.Activate)
                            CreateZone(configData.Zones.Quarry_HQM, pos);                       
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_a"))
                    {
                        if (configData.Zones.Quarry_Sulfur.Activate)
                            CreateZone(configData.Zones.Quarry_Sulfur, pos);
                        continue;
                    }

                    if (gobject.name.Contains("mining_quarry_b"))
                    {
                        if (configData.Zones.Quarry_Stone.Activate)
                            CreateZone(configData.Zones.Quarry_Stone, pos);
                        continue;
                    }

                    if (gobject.name.Contains("junkyard_1"))
                    {
                        if (configData.Zones.Junkyard.Activate)
                            CreateZone(configData.Zones.Junkyard, pos);
                        continue;
                    }
                }                
            }
            ConfirmCreation();
        }

        private void CreateHapis()
        {
            if (configData.Zones.Lighthouse.Activate)
            {
                CreateZone(new ConfigData.RadZones.MonumentSettings() { Name = "Lighthouse", Radiation = configData.Zones.Lighthouse.Radiation, Radius = HIMon["lighthouse_1"].Radius }, HIMon["lighthouse_1"].Position);
                CreateZone(new ConfigData.RadZones.MonumentSettings() { Name = "Lighthouse", Radiation = configData.Zones.Lighthouse.Radiation, Radius = HIMon["lighthouse_2"].Radius }, HIMon["lighthouse_2"].Position);
            }

            if (configData.Zones.WaterTreatment.Activate)
                CreateZone(new ConfigData.RadZones.MonumentSettings() { Name = "WaterTreatment", Radiation = configData.Zones.WaterTreatment.Radiation, Radius = HIMon["water"].Radius }, HIMon["water"].Position);

            if (configData.Zones.Tunnels.Activate)
                CreateZone(new ConfigData.RadZones.MonumentSettings() { Name = "Tunnels", Radiation = configData.Zones.Tunnels.Radiation, Radius = HIMon["tunnels"].Radius }, HIMon["tunnels"].Position);

            if (configData.Zones.Satellite.Activate)
                CreateZone(new ConfigData.RadZones.MonumentSettings() { Name = "Satellite", Radiation = configData.Zones.Satellite.Radiation, Radius = HIMon["satellite"].Radius }, HIMon["satellite"].Position);

            ConfirmCreation();
        }

        private void ConfirmCreation()
        {
            if (radiationZones.Count > 0)
            {
                if (configData.Settings.UseTimers) StartRadTimers();
                Puts("Created " + radiationZones.Count + " monument radiation zones");
                if (!ConVar.Server.radiation)
                {
                    radsOn = false;
                    ConVar.Server.radiation = true;
                }
            }
        }

        private void CreateZone(ConfigData.RadZones.MonumentSettings zone, Vector3 pos)
        {
            RadiationZone newZone = new GameObject().AddComponent<RadiationZone>();
            newZone.InitializeRadiationZone(zone.Name, pos, zone.Radius, zone.Radiation);
            radiationZones.Add(newZone);
        }      
        
        private void StartRadTimers()
        {
            int ontime = configData.Timers.StaticOn;
            int offtime = configData.Timers.StaticOff;
            if (configData.Settings.UseRandomTimers)
            {
                ontime = GetRandom(configData.Timers.ROnMin, configData.Timers.ROnmax);
                offtime = GetRandom(configData.Timers.ROffMin, configData.Timers.ROffMax);
            }

            onTimer = ontime * 60;
            timer.Repeat(1, onTimer, () =>
            {
                onTimer--;
                if (onTimer == 0)
                {
                    for (int i = 0; i < radiationZones.Count; i++)                    
                        radiationZones[i].Deactivate();
                    
                    if (configData.Settings.Infopanel)
                        ConVar.Server.radiation = false;

                    if (configData.Settings.ShowTimers)                    
                        PrintToChat(string.Format(msg("RadiationDisabled"), offtime));
                    
                    offTimer = offtime * 60;
                    timer.Repeat(1, offTimer, () =>
                    {
                        offTimer--;
                        if (offTimer == 0)
                        {
                            foreach (RadiationZone zone in radiationZones)
                                zone.Reactivate();

                            if (configData.Settings.Infopanel)
                                ConVar.Server.radiation = true;

                            if (configData.Settings.ShowTimers)
                                PrintToChat(string.Format(msg("RadiationEnabled"), ontime));
                            
                            StartRadTimers();
                        }
                    });
                }
            });
        }

        private int GetRandom(int min, int max) => UnityEngine.Random.Range(min, max);

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }
        #endregion

        #region Commands   
        private bool IsAdmin(BasePlayer player)
        {
            if (!player.IsAdmin)
            {
                SendReply(player, msg("Title", player.userID) + msg("NoPermission", player.userID));
                return false;
            }
            return true;
        }

        private bool IsAuthed(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 1)
                {
                    SendReply(arg, "You have insufficient permission to use this command");
                    return false;
                }
            }
            return true;
        }                

        [ConsoleCommand("mr_list")]
        private void ccmdRadZoneList(ConsoleSystem.Arg arg)
        {
            if (!IsAuthed(arg))
                return;

            if (radiationZones.Count == 0)
            {
                SendReply(arg, "There are no radiation zones setup");
                return;
            }

            for (int i = 0; i < radiationZones.Count; i++)
            {
                if (i == 0)
                    SendReply(arg, $"---- MonumentRadiation Zone List ----");

                RadiationZone zone = radiationZones[i];
                SendReply(arg, $"{zone.name} || Location: {zone.transform.position} || Radius: {zone.radius} || Radiation Amount: {zone.amount}");
            }
        }

        [ChatCommand("mr_list")]
        private void cmdRadZoneList(BasePlayer player, string command, string[] args)
        {
            if (!IsAdmin(player))
                return;

            if (radiationZones.Count == 0)
            {
                SendReply(player, msg("NoRadiationZones", player.userID));
                return;
            }

            for (int i = 0; i < radiationZones.Count; i++)
            {
                if (i == 0)
                    SendEchoConsole(player.net.connection, $"---- MonumentRadiation Zone List ----");

                RadiationZone zone = radiationZones[i];
                SendEchoConsole(player.net.connection, $"{zone.name} || Location: {zone.transform.position} || Radius: {zone.radius} || Radiation Amount: {zone.amount}");
            } 
            SendReply(player, msg("Title", player.userID) + msg("InfoToConsole", player.userID));
        }

        [ChatCommand("mr")]
        private void cmdCheckTimers(BasePlayer player, string command, string[] args)
        {
            if (onTimer != 0)
            {
                float timeOn = onTimer / 60 < 1 ? onTimer : onTimer / 60;
                string type = onTimer / 60 < 1 ? msg("Seconds") : msg("Minutes");
                
                SendReply(player, string.Format(msg("RadiationDownIn", player.userID), timeOn, type));
            }
            else if (offTimer != 0)
            {
                float timeOff = offTimer / 60 < 1 ? offTimer : offTimer / 60;
                string type = offTimer / 60 < 1 ? msg("Seconds") : msg("Minutes");
               
                SendReply(player, string.Format(msg("RadiationUpIn", player.userID), timeOff, type));
            }
        }

        [ChatCommand("mr_show")]
        private void cmdShowZones(BasePlayer player, string command, string[] args)
        {
            if (!IsAdmin(player)) return;
            foreach(RadiationZone zone in radiationZones)            
                player.SendConsoleCommand("ddraw.sphere", 20f, Color.blue, zone.transform.position, zone.radius);            
        }
        #endregion

        #region Classes        
        private class RadiationZone : MonoBehaviour
        {
            private TriggerRadiation triggerRadiation;
            public float radius;
            public float amount;

            private void Awake()
            {
                gameObject.layer = (int)Rust.Layer.Reserved1;
                enabled = false;
            }

            private void OnDestroy() => Destroy(gameObject);
            
            private void OnTriggerEnter(Collider obj)
            {
                BasePlayer player = obj?.GetComponentInParent<BasePlayer>();
                if (player != null)
                {
                    if (Instance.configData.Messages.Enter && ConVar.Server.radiation)  
                        player.ChatMessage(Instance.msg("EnterRadiation", player.userID));                    
                }
            }

            private void OnTriggerExit(Collider obj)
            {
                BasePlayer player = obj?.GetComponentInParent<BasePlayer>();
                if (player != null)
                {
                    if (Instance.configData.Messages.Exit && ConVar.Server.radiation)                                            
                        player.ChatMessage(Instance.msg("LeaveRadiation", player.userID));                    
                }
            }

            public void InitializeRadiationZone(string type, Vector3 position, float radius, float amount)
            {
                this.radius = radius;
                this.amount = amount;

                gameObject.name = type;
                transform.position = position;
                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>() ?? gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = radius;

                triggerRadiation = gameObject.GetComponent<TriggerRadiation>() ?? gameObject.AddComponent<TriggerRadiation>();
                triggerRadiation.RadiationAmountOverride = amount;
                triggerRadiation.interestLayers = PLAYER_MASK;
                triggerRadiation.enabled = true;
            }

            public void Deactivate() => triggerRadiation?.gameObject.SetActive(false);

            public void Reactivate() => triggerRadiation?.gameObject.SetActive(true);
        }

        private struct HapisIslandMonuments
        {
            public Vector3 Position;
            public float Radius;
        }

        private Dictionary<string, HapisIslandMonuments> HIMon = new Dictionary<string, HapisIslandMonuments>
        {
            {"lighthouse_1", new HapisIslandMonuments {Position = new Vector3(1562.30981f, 45.05141f, 1140.29382f), Radius = 15 } },
            {"lighthouse_2", new HapisIslandMonuments {Position = new Vector3(-1526.65112f, 45.3333473f, -280.0514f), Radius = 15 } },
            {"water", new HapisIslandMonuments {Position = new Vector3(-1065.191f, 125.3655f, 439.2279f), Radius = 100 } },
            {"tunnels", new HapisIslandMonuments {Position = new Vector3(-854.7694f, 72.34925f, -241.692f), Radius = 100 } },
            {"satellite", new HapisIslandMonuments {Position = new Vector3(205.2501f, 247.8247f, 252.5204f), Radius = 80 } }
        };
        #endregion

        #region Config      
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Messaging Settings")]
            public Messaging Messages { get; set; }
            public RadiationTimers Timers { get; set; }
            public Options Settings { get; set; }
            [JsonProperty(PropertyName = "Zone Settings")]
            public RadZones Zones { get; set; }

            public class Messaging
            {
                [JsonProperty(PropertyName = "Display message to player when they enter a radiation zone")]
                public bool Enter { get; set; }
                [JsonProperty(PropertyName = "Display message to player when they leave a radiation zone")]
                public bool Exit { get; set; }
            }
            public class RadiationTimers
            {
                [JsonProperty(PropertyName = "Random on time (minimum minutes)")]
                public int ROnMin { get; set; }
                [JsonProperty(PropertyName = "Random on time (maximum minutes)")]
                public int ROnmax { get; set; }
                [JsonProperty(PropertyName = "Random off time (minimum minutes)")]
                public int ROffMin { get; set; }
                [JsonProperty(PropertyName = "Random off time (maximum minutes)")]
                public int ROffMax { get; set; }
                [JsonProperty(PropertyName = "Forced off time (minutes)")]
                public int StaticOff { get; set; }
                [JsonProperty(PropertyName = "Forced on time (minutes)")]
                public int StaticOn { get; set; }
            }
            public class RadZones
            {
                public MonumentSettings Airfield { get; set; }
                public MonumentSettings Dome { get; set; }
                public MonumentSettings Junkyard { get; set; }
                public MonumentSettings Lighthouse { get; set; }
                public MonumentSettings LargeHarbor { get; set; }
                public MonumentSettings GasStation { get; set; }
                public MonumentSettings Powerplant { get; set; }
                [JsonProperty(PropertyName = "Stone Quarry")]
                public MonumentSettings Quarry_Stone { get; set; }
                [JsonProperty(PropertyName = "Sulfur Quarry")]
                public MonumentSettings Quarry_Sulfur { get; set; }
                [JsonProperty(PropertyName = "HQM Quarry")]
                public MonumentSettings Quarry_HQM { get; set; }
                public MonumentSettings Radtown { get; set; }
                public MonumentSettings RocketFactory { get; set; }
                public MonumentSettings Satellite { get; set; }
                public MonumentSettings SmallHarbor { get; set; }
                public MonumentSettings Supermarket { get; set; }
                public MonumentSettings Trainyard { get; set; }
                public MonumentSettings Tunnels { get; set; }
                public MonumentSettings Warehouse { get; set; }
                public MonumentSettings WaterTreatment { get; set; }

                public class MonumentSettings
                {
                    [JsonProperty(PropertyName = "Enable radiation at this monument")]
                    public bool Activate;
                    [JsonProperty(PropertyName = "Monument name (internal use)")]
                    public string Name;
                    [JsonProperty(PropertyName = "Radius of radiation")]
                    public float Radius;
                    [JsonProperty(PropertyName = "Radiation amount")]
                    public float Radiation;
                }
            }
            public class Options
            {
                [JsonProperty(PropertyName = "Broadcast radiation status changes")]
                public bool ShowTimers { get; set; }
                [JsonProperty(PropertyName = "Using Hapis Island map")]
                public bool IsHapis { get; set; }
                [JsonProperty(PropertyName = "Enable InfoPanel integration")]
                public bool Infopanel { get; set; }
                [JsonProperty(PropertyName = "Use radiation toggle timers")]
                public bool UseTimers { get; set; }
                [JsonProperty(PropertyName = "Randomise radiation timers")]
                public bool UseRandomTimers { get; set; }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Messages = new ConfigData.Messaging
                {
                    Enter = true,
                    Exit = false
                },
                Timers = new ConfigData.RadiationTimers
                {
                    ROffMax = 60,
                    ROffMin = 25,
                    ROnmax = 30,
                    ROnMin = 5,
                    StaticOff = 15,
                    StaticOn = 45
                },
                Settings = new ConfigData.Options
                {
                    ShowTimers = true,
                    UseRandomTimers = false,
                    UseTimers = true,
                    IsHapis = false,
                    Infopanel = false
                },
                Zones = new ConfigData.RadZones
                {
                    Airfield = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Airfield",
                        Radiation = 10,
                        Radius = 85
                    },
                    Dome = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Dome",
                        Radiation = 10,
                        Radius = 50
                    },
                    Junkyard = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Junkyard",
                        Radiation = 10,
                        Radius = 50
                    },
                    GasStation = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "GasStation",
                        Radiation = 10,
                        Radius = 15
                    },
                    LargeHarbor = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Large Harbor",
                        Radiation = 10,
                        Radius = 120
                    },
                    Lighthouse = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Lighthouse",
                        Radiation = 10,
                        Radius = 15
                    },
                    Powerplant = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Powerplant",
                        Radiation = 10,
                        Radius = 120
                    },
                    Quarry_HQM = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Quarry_HQM",
                        Radiation = 10,
                        Radius = 15
                    },
                    Quarry_Stone = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Quarry_Stone",
                        Radiation = 10,
                        Radius = 15
                    },
                    Quarry_Sulfur = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Quarry_Sulfur",
                        Radiation = 10,
                        Radius = 15
                    },
                    Radtown = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = true,
                        Name = "Radtown",
                        Radiation = 10,
                        Radius = 85
                    },
                    RocketFactory = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = true,
                        Name = "Rocket Factory",
                        Radiation = 10,
                        Radius = 140
                    },
                    Satellite = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Satellite",
                        Radiation = 10,
                        Radius = 60
                    },
                    SmallHarbor = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = true,
                        Name = "Small Harbor",
                        Radiation = 10,
                        Radius = 85
                    },
                    Supermarket = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Supermarket",
                        Radiation = 10,
                        Radius = 20
                    },
                    Trainyard = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Trainyard",
                        Radiation = 10,
                        Radius = 100
                    },
                    Tunnels = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Tunnels",
                        Radiation = 10,
                        Radius = 90
                    },
                    Warehouse = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "Warehouse",
                        Radiation = 10,
                        Radius = 15
                    },
                    WaterTreatment = new ConfigData.RadZones.MonumentSettings
                    {
                        Activate = false,
                        Name = "WaterTreatment",
                        Radiation = 10,
                        Radius = 120
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(0, 1, 50))
            {
                configData.Zones.Junkyard = baseConfig.Zones.Junkyard;
                configData.Zones.Quarry_HQM = baseConfig.Zones.Quarry_HQM;
                configData.Zones.Quarry_Stone = baseConfig.Zones.Quarry_Stone;
                configData.Zones.Quarry_Sulfur = baseConfig.Zones.Quarry_Sulfur;
            }
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization      
        private string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        private Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            ["InfoToConsole"] = "<color=#B6B6B6>Check your ingame console for more information!</color>",
            ["Title"] = "<color=#B6B6B6><color=#ce422b>Monument Radiation</color> : </color>",
            ["NoRadiationZones"] = "<color=#B6B6B6>There are no radiation zones setup</color>",
            ["Minutes"] = "minutes",
            ["Seconds"] = "seconds",
            ["RadiationDownIn"] = "<color=#B6B6B6>Monument radiation levels will be down in <color=#00FF00>{0} {1}</color>!</color>",
            ["RadiationUpIn"] = "<color=#B6B6B6>Monument radiation levels will be back up in <color=#00FF00>{0} {1}</color>!</color>",
            ["RadiationEnabled"] = "<color=#B6B6B6>Monument radiation levels are back up for <color=#00FF00>{0} minutes</color>!</color>",
            ["RadiationDisabled"] = "<color=#B6B6B6>Monument radiation levels are down for <color=#00FF00>{0} minutes</color>!</color>",
            ["EnterRadiation"] = "<color=#ce422b>WARNING: </color><color=#B6B6B6>You are entering a irradiated area!</color>",
            ["LeaveRadiation"] = "<color=#ce422b>CAUTION: </color><color=#B6B6B6>You are leaving a irradiated area! </color>",
            ["NoPermission"] = "<color=#B6B6B6>You have insufficient permission to use this command</color>",
        };
        #endregion


    }
}


// --- End of file: MonumentRadiation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-ping-panel ---
// --- Original File Path: M/MagicPingPanel/MagicPingPanel.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Ping Panel", "MJSU", "1.0.5")]
    [Description("Displays players ping in magic panel")]
    public class MagicPingPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private readonly Hash<ulong, int> _playerPing = new Hash<ulong, int>();
        private string _defaultColor;

        private Coroutine _updateRoutine;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        
        private string _text;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _text = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? false,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0f,
                    Url = config.Panel?.Image?.Url ?? "",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.05f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 1,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config?.Panel?.Text?.Text ?? "Ping: {0}ms",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftmiddle",
                Order = config.PanelSettings?.Order ?? 5,
                Width = config.PanelSettings?.Width ?? 0.055f
            };

            config.PingColors = new Hash<int, string>
            {
                [0] = "#00ff00",
                [50] = "#ffff00",
                [100] = "#ffa500",
                [150] = "#ff0000",
                [200] = "#000000"
            };
            
            return config;
        }

        private void OnServerInitialized()
        {
            _defaultColor = _pluginConfig.Panel.Text.Color;
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerPing, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _playerPing[player.userID] = CheckPing(player);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerPing.Remove(player.userID);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerPing);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }
        #endregion
        
        #region Player Ping Update
        private void UpdatePlayerPing()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerPing());
        }

        private IEnumerator HandleUpdatePlayerPing()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                int ping = CheckPing(player);
                int lastPing = _playerPing[player.userID];
                
                yield return null;
                if (ping == lastPing)
                {
                    continue;
                }

                _playerPing[player.userID] = ping;
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                float ping = _playerPing[player.userID];
                string color = _defaultColor;
                if (_pluginConfig.EnablePingColors)
                {
                    foreach (KeyValuePair<int,string> pingColor in _pluginConfig.PingColors.OrderByDescending(p => p.Key))
                    {
                        if (pingColor.Key < ping)
                        {
                            color = pingColor.Value;
                            break;
                        }
                    }
                }

                
                text.Text = string.Format(_text, $"<color={color}>{ping}</color>");
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods
        private int CheckPing(BasePlayer player)
        {
            return Net.sv.GetAveragePing(player.net.connection);
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable ping colors")]
            public bool EnablePingColors { get; set; }
            
            [JsonProperty(PropertyName = "Ping Colors")]
            public Hash<int, string> PingColors { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicPingPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/maze-gen ---
// --- Original File Path: M/MazeGen/MazeGen.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MazeGen", "Default/Razor", "0.2.7")]
    [Description("Creates mazes of various sizes for your players to solve.")]
    class MazeGen : RustPlugin
    {
        /*
        Credits to Pant for creating this original plugin. I have simply worked on it, to add better stability throughout, and soon more features.
        TODO
        Finish implementation of loot and NPC's in maze.
        Custom gamemode (Maybe?)

        */
        private System.Random random;
        private const string gen = "mazegen.gen";
        private static MazeGen instance = null;

        private List<Block> Grid;

        private float BlockSize = 3f;
        private float FoundationSize = 1f;
        private float BuldingHeight = 1f;
        private Vector3 RealGoal;
        private bool MakeRoof;

        

        private void Init()
        {
            instance = this;
            permission.RegisterPermission(gen, this);
            LoadMessages();
        }
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You don't have permission to use this command.",
            }, this);
        }

        [ChatCommand("maze.delete")]
        void dmaze(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, gen))
            {
                PrintToChat(player, lang.GetMessage("No Permission", this, player.UserIDString));
                return;
            }

            if (permission.UserHasPermission(player.UserIDString, gen))
            {
                if (Grid != null)
                {
                    foreach (Block block in Grid)
                    {
                        block.Destroye();
                    }
                }
            }
            
        }

        [ChatCommand("maze")]
        void GenerateMaze(BasePlayer player, string command, string[] args)
        {
            MakeRoof = true;

            if (!permission.UserHasPermission(player.UserIDString, gen))
            {
                PrintToChat(player, lang.GetMessage("No Permission", this, player.UserIDString));
                return;
            }

            if (permission.UserHasPermission(player.UserIDString, gen))
            {
                long seed = long.Parse(DateTime.Now.ToString("yyyyMMddHHmmss"));
                random = new System.Random((int)(seed / 100));

                BasePlayer Player = player;
                Grid = new List<Block>();

                try
                {
                    FoundationSize = float.Parse(args[0]);
                    if(FoundationSize > 30)
                    {
                        SendReply(player, "Maze too big");
                        return;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Size is not a valid number");
                }

                try
                {
                    BuldingHeight = float.Parse(args[1]);
                }
                catch (Exception e)
                {
                    SendReply(player, "Height is not a valid number");
                }

                try
                {
                    if(args[2] == "false")
                    {
                        MakeRoof = false;
                    }
                }
                catch (Exception e)
                {
                    SendReply(player, "Building roof is set to true");
                }

                RealGoal = new Vector3(FoundationSize - 1, BuldingHeight - 1, FoundationSize - 1);

                BuildGrid(player);
            }
            
        }

        private void BuildGrid(BasePlayer player)
        {
            for (float x = 0; x < FoundationSize; x++)
            {
                for (float y = 0; y < FoundationSize; y++)
                {
                    for (int z = 0; z < BuldingHeight; z++)
                    {
                        Prefab prefab;

                        if (z > 0)
                        {
                            prefab = Prefab.Floor;
                        }
                        else
                        {
                            prefab = Prefab.Foundation;
                        }

                        Block block = new Block(new Vector3(x * BlockSize, z * BlockSize, y * BlockSize) + player.GetNetworkPosition(), new Vector3(x, z, y), new Quaternion(), FoundationSize, BuldingHeight, prefab, random.Next(0, int.Parse(FoundationSize.ToString())), MakeRoof);
                        Grid.Add(block);
                    }
                }
            }

            SpawnMaze();
        }

        private void GeneratePath()
        {
            foreach (Block block in Grid)
            {

            }
        }

        private void SpawnMaze()
        {
            while ((from block in Grid where !block.visited select block).ToList().Count > 0)
            {
                Block block = (from foundation in Grid where !foundation.visited select foundation).FirstOrDefault();
                FindNext(block, true, RealGoal);
            }

            foreach (Block block in Grid)
            {
                block.SpawnEntitys();
            }
        }

        private void FindNext(Block block, bool New, Vector3 Goal, int RougCounter = 0)
        {
            block.visited = true;

            List<Block> Neighbours = GetNeighbours(block);
            float BestNeighbour = -1;
            Block BestNeighbourBlock = null;

            foreach (Block neighbours in Neighbours)
            {
                float distance = ManhattanDistance(neighbours.BasePosition, Goal, block.BasePosition) + neighbours.Weight;
                if (distance < BestNeighbour || BestNeighbour == -1)
                {
                    BestNeighbour = distance;
                    BestNeighbourBlock = neighbours;
                }
            }

            if (New)
            {
                Block OldNeighbour = GetNeighbours(block, true).FirstOrDefault();
                if (OldNeighbour != null)
                {
                    OpenWall(block, OldNeighbour);
                }
            }

            if (random.Next(0, 6) == 5 && Goal == RealGoal)
            {
                RougCounter = 10;
                Goal = new Vector3(random.Next(0, int.Parse(FoundationSize.ToString())), random.Next(0, int.Parse(BuldingHeight.ToString())), random.Next(0, int.Parse(FoundationSize.ToString())));
            }

            if (Goal != RealGoal)
            {
                if (!block.IsTheEnd(Goal))
                {
                    if (BestNeighbourBlock != null)
                    {
                        OpenWall(block, BestNeighbourBlock);
                        RougCounter--;

                        FindNext(BestNeighbourBlock, false, Goal, RougCounter);
                    }
                }
            }
            else
            {
                if (!block.IsTheEnd(Goal))
                {
                    if (BestNeighbourBlock != null)
                    {
                        LastVisited.Add(block);
                        OpenWall(block, BestNeighbourBlock);
                        FindNext(BestNeighbourBlock, false, RealGoal);
                    }
                    else
                    {
                        Block lastItem = LastVisited.LastOrDefault();
                        if (lastItem != null)
                        {
                            Vector3 goal = Goal == RealGoal ? RealGoal : Goal;
                            LastVisited.Remove(lastItem);
                            FindNext(lastItem, false, goal);
                        }
                    }
                }
            }
        }

        List<Block> LastVisited = new List<Block>();

        private void OpenWall(Block from, Block to)
        {
            if (from.BasePosition == to.BasePosition + new Vector3(0, 0, +1))
            {
                to.Walls[0].DisplayBlock = false;
            }
            if (from.BasePosition == to.BasePosition + new Vector3(+1, 0, 0))
            {
                from.Walls[1].DisplayBlock = false;
            }
            if (from.BasePosition == to.BasePosition + new Vector3(0, 0, -1))
            {
                from.Walls[0].DisplayBlock = false;
            }
            if (from.BasePosition == to.BasePosition + new Vector3(-1, 0, 0))
            {
                to.Walls[1].DisplayBlock = false;
            }
            if (from.BasePosition == to.BasePosition + new Vector3(0, -1, 0))
            {
                to.DisplayBlock = false;
                to.AddStair();
            }
            if (from.BasePosition == to.BasePosition + new Vector3(0, 1, 0))
            {
                from.DisplayBlock = false;
                from.AddStair();
            }
        }

        private float ManhattanDistance(Vector3 ToPosition, Vector3 Goal, Vector3 FromPosition)
        {
            float xd = ToPosition.x - Goal.x;
            float zd = ToPosition.z - Goal.z;
            float yd = ToPosition.y - Goal.y;

            if (ToPosition.y - FromPosition.y != 0)
            {
                yd += ((FoundationSize * BuldingHeight));
            }

            return Math.Abs(xd) + Math.Abs(zd) + Math.Abs(yd);
        }

        private List<Block> GetNeighbours(Block block, bool IsVisited = false)
        {
            List<Block> Neighbours = new List<Block>();

            Block block1 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x + 1, block.BasePosition.y, block.BasePosition.z) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block1 != null)
            {
                Neighbours.Add(block1);
            }
            Block block2 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x, block.BasePosition.y, block.BasePosition.z + 1) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block2 != null)
            {
                Neighbours.Add(block2);
            }
            Block block3 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x - 1, block.BasePosition.y, block.BasePosition.z) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block3 != null)
            {
                Neighbours.Add(block3);
            }
            Block block4 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x, block.BasePosition.y, block.BasePosition.z - 1) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block4 != null)
            {
                Neighbours.Add(block4);
            }
            Block block5 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x, block.BasePosition.y + 1, block.BasePosition.z) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block5 != null)
            {
                Neighbours.Add(block5);
            }
            Block block6 = (from foundation in Grid where foundation.BasePosition == new Vector3(block.BasePosition.x, block.BasePosition.y - 1, block.BasePosition.z) && ((!foundation.visited && !IsVisited) || (IsVisited && foundation.visited)) select foundation).FirstOrDefault();
            if (block6 != null)
            {
                Neighbours.Add(block6);
            }
            return Neighbours;
        }

		public enum Prefab
		{
			Wall,
			Foundation,
			Floor,
			StairUshape,
			FloorFrame,
			LadderHatch
		}

		public class Block
		{
			public Vector3 Position { get; set; }
			public Vector3 BasePosition { get; set; }
			public Quaternion Rotation { get; set; }

			public BaseEntity Entity { get; set; }
			public int EntityId { get; set; }
			public List<Block> Walls { get; set; }
			public Block Roof { get; set; }
			public Block Stair { get; set; }
			public Block FloorFrame { get; set; }
			public Block LadderHatch { get; set; }
			public int Weight { get; set; }
			public float foundationSize { get; set; }
			public float buildingHeight { get; set; }
			public bool DisplayBlock { get; set; }
			public bool visited { get; set; }

			public Block(Vector3 posion, Vector3 basePosition, Quaternion rotation, float FoundationSize, float BuildingHeight, Prefab prefab, int randomNumber, bool MakeRoof = false)
			{
				visited = false;
				Walls = new List<Block>();
				DisplayBlock = true;

				Position = posion;
				BasePosition = basePosition;
				Rotation = rotation;

				foundationSize = FoundationSize;
				buildingHeight = BuildingHeight;

				if ((prefab == Prefab.Foundation || prefab == Prefab.Floor) && basePosition.y + 1 == BuildingHeight && MakeRoof)
				{
					Roof = new Block(new Vector3(0f, 3f, 0f) + Position, BasePosition + new Vector3(0f, 1f, 0f), rotation, foundationSize, buildingHeight, Prefab.Floor, 0);
				}

				Weight = randomNumber;

				CreateEntity(prefab);

				if (prefab == Prefab.Foundation || (prefab == Prefab.Floor && BasePosition.y < BuildingHeight))
				{
					AddWalls();
				}
			}

			public bool IsTheEnd(Vector3 Goal)
			{
				if (BasePosition.x == Goal.x && BasePosition.z == Goal.z && BasePosition.y == Goal.y)
				{
					return true;
				}
				else
				{
					return false;
				}
			}

			public void Destroye()
			{
				if (DisplayBlock)
				{
					//BuildingBlock block = Entity.GetComponent<BuildingBlock>();
					Entity.Kill();
				}
				if (Stair != null)
				{
					Stair.Destroye();
				}
				if (FloorFrame != null)
				{
					FloorFrame.Destroye();
				}
				if (LadderHatch != null)
				{
					LadderHatch.Destroye();
				}
				if (Roof != null)
				{
					Roof.Destroye();
				}
				foreach (Block wall in Walls)
				{
					wall.Destroye();
				}
			}

			public void SpawnEntitys()
			{
				if (DisplayBlock)
				{
					BuildingBlock block = Entity.GetComponent<BuildingBlock>();
					if (block != null)
					{

					}
					Entity.Spawn();
					if (block != null)
					{
						block.SetGrade(BuildingGrade.Enum.TopTier);
						block.SetHealthToMax();
						block.cachedStability = 100;
					}
				}
				if (Stair != null)
				{
					Stair.SpawnEntitys();
				}
				if (FloorFrame != null)
				{
					FloorFrame.SpawnEntitys();
				}
				if (LadderHatch != null)
				{
					LadderHatch.SpawnEntitys();
				}
				if (Roof != null)
				{
					Roof.SpawnEntitys();
				}
				foreach (Block wall in Walls)
				{
					wall.SpawnEntitys();
				}
			}

			public void AddStair()
			{
				FloorFrame = new Block(Position, BasePosition, Rotation, foundationSize, buildingHeight, Prefab.FloorFrame, 0);
				LadderHatch = new Block(Position - new Vector3(0f, 0.1f, 0f), BasePosition, Rotation, foundationSize, buildingHeight, Prefab.LadderHatch, 0);
			}

			private void AddWalls()
			{
				Block wall1 = new Block(new Vector3(0f, 0f, 1.5f) + Position, BasePosition, new Quaternion(0f, -0.7071068f, 0f, 0.7071068f), foundationSize, buildingHeight, Prefab.Wall, 0);
				Walls.Add(wall1);

				Block wall2 = new Block(new Vector3(-1.5f, 0f, 0f) + Position, BasePosition, new Quaternion(0f, 1f, 0f, 0f), foundationSize, buildingHeight, Prefab.Wall, 0);
				Walls.Add(wall2);

				if (BasePosition.z == 0)
				{
					Block wall3 = new Block(new Vector3(0f, 0f, -1.5f) + Position, BasePosition, new Quaternion(0f, -0.7071068f, 0f, 0.7071068f), foundationSize, buildingHeight, Prefab.Wall, 0);
					Walls.Add(wall3);
				}

				if (BasePosition.x + 1 == foundationSize)
				{
					Block wall4 = new Block(new Vector3(1.5f, 0f, 0f) + Position, BasePosition, new Quaternion(0f, 1f, 0f, 0f), foundationSize, buildingHeight, Prefab.Wall, 0);
					Walls.Add(wall4);
				}
			}

			private void CreateEntity(Prefab prefab)
			{
				BaseEntity entity = null;
				switch (prefab)
				{
					case Prefab.Wall:
						entity = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", Position, Rotation, true);
						break;
					case Prefab.Floor:
						entity = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", Position, Rotation, true);
						break;
					case Prefab.Foundation:
						entity = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", Position, Rotation, true);
						break;
					case Prefab.StairUshape:
						entity = GameManager.server.CreateEntity("assets/prefabs/building/floor.ladder/floor.ladder.hatch.prefab", Position, Rotation, true);
						break;
					case Prefab.LadderHatch:
						entity = GameManager.server.CreateEntity("assets/prefabs/building/floor.ladder.hatch/floor.ladder.hatch.prefab", Position, Rotation, true);
						break;
					case Prefab.FloorFrame:
						entity = GameManager.server.CreateEntity("assets/prefabs/building core/floor.frame/floor.frame.prefab", Position, Rotation, true);
						break;
				}
				AddEntity(entity);
			}

			private void AddEntity(BaseEntity entity)
			{
				if (entity != null)
				{
					Entity = entity;
					EntityId = entity.GetInstanceID();
				}
			}
		}
    }
}

// --- End of file: MazeGen.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-heli-panel ---
// --- Original File Path: M/MagicHeliPanel/MagicHeliPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Heli Panel", "MJSU", "1.0.4")]
    [Description("Displays if the patrol helicopter event is active")]
    public class MagicHeliPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<PatrolHelicopter> _activeHelis = new List<PatrolHelicopter>();

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            UnsubscribeAll();
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/MpJJPnC7/hTTyTTx.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.1f, 0.1f, 0.1f, 0.1f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 3,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            NextTick(() =>
            {
                _activeHelis = BaseNetworkable.serverEntities.OfType<PatrolHelicopter>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }

            SubscribeAll();
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeHelis.Count == 0 || _activeHelis.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void SubscribeAll()
        {
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityKill));
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(PatrolHelicopter heli)
        {
            //Need double for HeliRefuel panel
            NextTick(() =>
            {
                NextTick(() =>
                {
                    if (!CanShowPanel(heli))
                    {
                        return;
                    }

                    _activeHelis.Add(heli);
                    CheckEvent();
                });
            });
        }
        
        private void OnEntityKill(PatrolHelicopter heli)
        {
            _activeHelis.Remove(heli);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeHelis.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods

        private bool CanShowPanel(PatrolHelicopter heli)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, heli);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#B33333FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicHeliPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-players-panel ---
// --- Original File Path: M/MagicPlayersPanel/MagicPlayersPanel.cs ---

﻿using System;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Players Panel", "MJSU", "1.0.3")]
    [Description("Displays connected players in magic panel")]
    public class MagicPlayersPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/pTHKD92M/TP01GYf.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .67f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}/{1}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "lefttop",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.0525f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            UpdatePanel();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            UpdatePanel();
        }

        private void UpdatePanel()
        {
            NextTick(() =>
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
            });
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, 
                    BasePlayer.activePlayerList.Count(p => !_pluginConfig.ExcludeAdmins || !p.IsAdmin), 
                    ConVar.Server.maxplayers);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Exclude Admins")]
            public bool ExcludeAdmins { get; set; }
        
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicPlayersPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-carpet ---
// --- Original File Path: M/MagicCarpet/MagicCarpet.cs ---

﻿using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Carpet", "redBDGR", "1.0.1")]
    [Description("Take a magic carpet ride")]
    class MagicCarpet : RustPlugin
    {
        private const string permissionName = "magiccarpet.use";
        public static LayerMask collLayers = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "Resource", "World", "Water", "Default", "AI");
        private Dictionary<string, BaseEntity> users = new Dictionary<string, BaseEntity>();

        private void Init()
        {
            permission.RegisterPermission(permissionName, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["No Permission"] = "You are not allowed to use this command!",
                ["MC start"] = "You have summoned a magic carpet!",
                ["MC End"] = "Your magic carpet has disappeared"
            }, this);
        }

        private void Unload()
        {
            foreach(var entry in users)
                entry.Value.Kill();
        }

        private void OnEntityMounted(BaseMountable mountable, BasePlayer player)
        {
            _MagicCarpet mc = mountable.GetComponent<_MagicCarpet>();
            if (!mc)
                return;
            mc.player = player;
        }

        private void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
        {
            _MagicCarpet mc = mountable.GetComponent<_MagicCarpet>();
            if (!mc)
                return;
            mc.player = null;
        }

        [ChatCommand("mc")]
        void attachCMD(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                player.ChatMessage(msg("No Permission", player.UserIDString));
                return;
            }

            if (users.ContainsKey(player.UserIDString))
            {
                player.ChatMessage(msg("MC End", player.UserIDString));
                Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab", player.transform.position);
                _MagicCarpet carpet = users[player.UserIDString].GetComponent<_MagicCarpet>();
                if (carpet)
                    carpet.Destroy();
                BaseEntity ent = users[player.UserIDString];
                if (ent)
                {
                    users.Remove(player.UserIDString);
                    ent.Kill();
                }
            }
            else
            {
                player.ChatMessage(msg("MC start", player.UserIDString));
                Vector3 pos = player.transform.position + -player.transform.forward * 3f + new Vector3(0, 1f, 0);
                Effect.server.Run("assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab", pos);
                BaseEntity ent = GameManager.server.CreateEntity("assets/prefabs/deployable/chair/chair.deployed.prefab", pos);
                if (ent)
                {
                    ent.Spawn();
                    ent.gameObject.AddComponent<_MagicCarpet>().player = player;
                    users.Add(player.UserIDString, ent);
                }
            }
        }

        private class _MagicCarpet : MonoBehaviour
        {
            public BasePlayer player;
            private BaseEntity ent;
            private BaseEntity chair;
            private BaseMountable mountable;

            private void Awake()
            {
                chair = gameObject.GetComponent<BaseEntity>();
                ent = GameManager.server.CreateEntity("assets/prefabs/deployable/rug/rug.deployed.prefab", chair.transform.position);
                ent.Spawn();
                mountable = chair.GetComponent<BaseMountable>();
                mountable.isMobile = true;
                ent.SetParent(chair);
                ent.transform.localPosition = new Vector3(0, 0.4f, 0);
                ent.transform.localRotation = new Quaternion(0, 0, 0, 0);
                chair.transform.localRotation = new Quaternion(0, 0, 0, 0);
            }

            private void Update()
            {
                if (!mountable.IsMounted())
                    return;
                transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(player.eyes.HeadForward()), UnityEngine.Time.deltaTime);
                if (player.serverInput.IsDown(BUTTON.FORWARD))
                    transform.position = Vector3.MoveTowards(transform.position, player.eyes.HeadForward(), UnityEngine.Time.deltaTime * 0.1f);
                chair.SendNetworkUpdateImmediate();
                ent.SendNetworkUpdateImmediate();
            }

            private Vector3 GetMovementPosition()
            {
                Vector3 nextPos = transform.position;
                if (player.serverInput.IsDown(BUTTON.FIRE_PRIMARY))
                    return transform.position + transform.forward * 0.01f;
                if (player.serverInput.IsDown(BUTTON.LEFT))
                    return transform.position + -transform.right * 0.01f;
                if (player.serverInput.IsDown(BUTTON.RIGHT))
                    return transform.position + transform.right * 0.01f;
                if (player.serverInput.IsDown(BUTTON.BACKWARD))
                    return transform.position + -transform.forward * 0.01f;
                return nextPos;
            }

            public void Destroy()
            {
                Destroy(this);
            }
        }

        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}


// --- End of file: MagicCarpet.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-easter-panel ---
// --- Original File Path: M/MagicEasterPanel/MagicEasterPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Easter Panel", "MJSU", "1.0.3")]
    [Description("Displays if the easter event is active")]
    public class MagicEasterPanel : RustPlugin
    {
        #region Class Fields

        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<EggHuntEvent> _eggEvents = new List<EggHuntEvent>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/7h2QtGFP/pTpHnl2.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 12,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _eggEvents = UnityEngine.Object.FindObjectsOfType<EggHuntEvent>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }

            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        
        private void CheckEvent()
        {
            if (_eggEvents.Count == 0 || _eggEvents.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks
        private void OnEntitySpawned(EggHuntEvent egg)
        {
            if (!_init)
            {
                return;
            }
        
            NextTick(() =>
            {
                if (!CanShowPanel(egg))
                {
                    return;
                }

                _eggEvents.Add(egg);
                CheckEvent();
            });
        }

        private void OnEntityKill(EggHuntEvent egg)
        {
            _eggEvents.Remove(egg);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _eggEvents.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(EggHuntEvent egg)
        {
            if (egg is HalloweenHunt)
            {
                return false;
            }
            
            object result = Interface.Call("MagicPanelCanShow", Name, egg);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#00FF00FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicEasterPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-coordinates-panel ---
// --- Original File Path: M/MagicCoordinatesPanel/MagicCoordinatesPanel.cs ---

﻿using System;
using System.Collections;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Magic Coordinates Panel", "MJSU", "1.0.4")]
    [Description("Displays players coordinates in magic panel")]
    public class MagicCoordinatesPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private string _coordText;

        private readonly Hash<ulong, Vector3> _playerPositions = new Hash<ulong, Vector3>();

        private Coroutine _updateRoutine;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _coordText = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.2f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/MHwfjgm6/jeTMOyo.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.01f, 0.00f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .8f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.01f, 0.01f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "X: {0:0} | Z: {2:0}"
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftbottom",
                Order = config.PanelSettings?.Order ?? 3,
                Width = config.PanelSettings?.Width ?? 0.11f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            InvokeHandler.Instance.InvokeRepeating(UpdatePlayerCoords, Random.Range(0, _pluginConfig.UpdateRate), _pluginConfig.UpdateRate);
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _playerPositions[player.userID] = player.transform.position;
        }
        
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            _playerPositions.Remove(player.userID);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdatePlayerCoords);
            if (_updateRoutine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_updateRoutine);
            }
        }

        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }
        #endregion

        #region Player Coords Update
        private void UpdatePlayerCoords()
        {
            _updateRoutine = InvokeHandler.Instance.StartCoroutine(HandleUpdatePlayerCoords());
        }

        private IEnumerator HandleUpdatePlayerCoords()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                Vector3 pos = player.transform.position;
                Vector3 previous = _playerPositions[player.userID];
               
                yield return null;
                if (pos == previous)
                {
                    continue;
                }
                
                _playerPositions[player.userID] = pos;
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            }
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                Vector3 pos =  _playerPositions[player.userID];
                text.Text = string.Format(_coordText, pos.x, pos.y, pos.z);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicCoordinatesPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-hostile-panel ---
// --- Original File Path: M/MagicHostilePanel/MagicHostilePanel.cs ---

﻿using System;
using System.ComponentModel;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Hostile Panel", "MJSU", "1.0.10")]
    [Description("Displays how much longer a player is considered hostile")]
    public class MagicHostilePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _panelText;
        
        private readonly Hash<ulong, Timer> _hostileTimer = new Hash<ulong, Timer>();

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _panelText = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.3f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/JzWfmntW/v5sdNHg.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.15f, 0.15f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.7f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}m {1:00}s",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#fff2df08",
                Dock = config.PanelSettings?.Dock ?? "centerupper",
                Order = config.PanelSettings?.Order ?? 14,
                Width = config.PanelSettings?.Width ?? 0.0725f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterPlayerPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
            timer.In(1f, () =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    SetupHostile(player);
                }
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            
            SetupHostile(player);
        }
        #endregion

        #region uMod Hooks
        private void OnEntityMarkHostile(BasePlayer player)
        {
            if (player == null || player.IsNpc)
            {
                return;
            }
            
            NextTick(() =>
            {
               SetupHostile(player);
            });
        }

        private void SetupHostile(BasePlayer player)
        {
            if (player.State.unHostileTimestamp < TimeEx.currentTimestamp)
            {
                HidePanel(player);
                return;
            }

            if (!(_hostileTimer[player.userID]?.Destroyed ?? true))
            {
                return;
            }
            
            ShowPanel(player);
            UpdatePanel(player);
            _hostileTimer[player.userID]?.Destroy();
            _hostileTimer[player.userID] = timer.Every(_pluginConfig.UpdateRate, () =>
            {
                UpdatePanel(player);

                if (player.State.unHostileTimestamp < TimeEx.currentTimestamp)
                {
                    _hostileTimer[player.userID]?.Destroy();
                    _hostileTimer[player.userID] = null;
                    HidePanel(player);
                }
            });
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel(BasePlayer player)
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            int minutes = 0;
            int seconds = 0;
            if (text != null)
            {
                if (player.State.unHostileTimestamp > TimeEx.currentTimestamp)
                {
                    TimeSpan remainingTime = TimeSpan.FromSeconds(player.State.unHostileTimestamp - TimeEx.currentTimestamp);
                    minutes = remainingTime.Minutes;
                    seconds = remainingTime.Seconds;
                }
                
                text.Color = minutes == 0 && seconds == 0 ? _pluginConfig.InactiveColor : _pluginConfig.ActiveColor;
                text.Text = string.Format(_panelText, minutes, seconds);
            }

            PanelImage image = panel.Image;
            if (image != null && _pluginConfig.ChangeIconColor)
            {
                image.Color = minutes == 0 && seconds == 0 ? _pluginConfig.InactiveColor : _pluginConfig.ActiveColor;
            }

            return panel.ToHash();
        }
        #endregion

        #region Helper Methods

        private void HidePanel(BasePlayer player)
        {
            if (!_pluginConfig.ShowHide)
            {
                return;
            }
            
            MagicPanel?.Call("HidePanel", player, Name);
        }
        
        private void ShowPanel(BasePlayer player)
        {
            if (!_pluginConfig.ShowHide)
            {
                return;
            }
            
            MagicPanel?.Call("ShowPanel", player, Name);
        }

        private void UpdatePanel(BasePlayer player)
        {
            MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Text);
            if (_pluginConfig.ChangeIconColor)
            {
                MagicPanel?.Call("UpdatePanel", player, Name, (int)UpdateEnum.Image);
            }
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Show/Hide panel")]
            public bool ShowHide { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Change Icon Color")]
            public bool ChangeIconColor { get; set; }
            
            [DefaultValue("#4EE44EFF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#B33333FF")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }
            
            [DefaultValue(1.0f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
            
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicHostilePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mini-copter-dc-protect ---
// --- Original File Path: M/MinicopterDCProtect/MinicopterDCProtect.cs ---

﻿using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini Copter DC Protect", "NooBlet", "0.1.9")]
    [Description("Protects player minicopters from crashing if they disconnect")]
    public class MinicopterDCProtect : CovalencePlugin
    {

        private static int _layerMask = LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World");

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!player.isMounted) return;
            if (player.GetMountedVehicle() is PlayerHelicopter)
                TPplayerandCopter(player, player.GetMountedVehicle() as PlayerHelicopter);
            if (player.GetMountedVehicle() is ScrapTransportHelicopter)
                TPplayerandCopter(player, player.GetMountedVehicle() as ScrapTransportHelicopter);
        }

        #endregion Hooks

        #region Methods
        private void TPplayerandCopter(BasePlayer player, BaseHelicopter copter)
        {
            var playergroundloc = FindLowestTpPoint(player.transform.position);
            if (copter.mountPoints[1].mountable.AnyMounted())
            {
                var pas = copter.mountPoints[1].mountable._mounted;
                Teleport(pas, playergroundloc);
            }
            Teleport(player, playergroundloc);
            var heligroundloc = new Vector3(player.transform.position.x + 1f, player.transform.position.y + 2f, player.transform.position.z + 1f);            
            copter.transform.position = FindclosestLand(heligroundloc);
        }

        private void Teleport(BasePlayer player, Vector3 target)
        {
            float currenthealth = player.health;
            player.health = 10000f;
            player.Teleport(target);
            player.health = currenthealth;
        }

        private Vector3 FindLowestTpPoint(Vector3 loc)
        {
            Vector3 location = loc;
            RaycastHit hit = new RaycastHit();

            if (UnityEngine.Physics.Raycast(loc, Vector3.down, out hit, float.MaxValue, _layerMask))
            {
                location = hit.point;
                if (TerrainMeta.HeightMap.GetHeight(location)<0)
                {
                    location = FindclosestLand(location);
                }

            }
            var locfinal = new Vector3(location.x, location.y + 1f, location.z);
            return locfinal;
        }

        Vector3 FindclosestLand(Vector3 loc)
        {
            for (int i = 0; i < 500; i++)
            {
                if (loc.x < 0) { loc.x += 4f; } else { loc.x -= 4f; }
                if (loc.z < 0) { loc.z += 4f; } else { loc.z -= 4f; }
                if (TerrainMeta.HeightMap.GetHeight(loc)<0)
                {
                    if (loc.x < 0) { loc.x += 2f; } else { loc.x -= 2f; }
                    if (loc.z < 0) { loc.z += 2f; } else { loc.z -= 2f; }
                    break;
                }
            }
            return loc;
        }

        #endregion Methods
    }
}

// --- End of file: MinicopterDCProtect.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-hot-air-balloon ---
// --- Original File Path: M/MyHotAirBalloon/MyHotAirBalloon.cs ---

using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System;
//using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("My Hot Air Balloon", "BuzZ[PHOQUE]", "0.1.3")]
    [Description("Spawn a Hot Air Balloon")]

/*======================================================================================================================= 
*   12th november 2018
*   chat commands : /balloon    /noballoon
*
*   0.0.2   20181112    configfile + langfile + permission + only one balloon by player + health info
*   0.0.3   20181115    no damage
*   0.0.4   20181115    added 4x christmas lights
*   0.0.5   20181116    code optimization
*   0.0.8   20181118    optimz + tp + 4socks
*   0.0.9   20181123    NRE kill/damage entity balloontimer   permission.god.fuel   HUD bar prepared for lock   upboost speed+/-
*   0.1.0   20181123    bar bottom in config file
*   0.1.1   20181124    permission for tp (myhotairballoon.tp)
*   0.1.2   20181209    navigation system on permission.navigate + change how spawn + console commands (spawn/despawn playerID)
*   0.1.3               work around console commands
*                       new perm needed on despawn + HUD back on plugin reload + HUD back on reconnect
*                       + new perm bomb + bomb HUD + bomb drop/explosion + null balloon to player damage
*
*   notes for later :
*       population (float)
*       currentWindVec (vector3)
*       liftAmount (float)
*       outsidedecayminutes (float)
*       public virtual bool UseFuel(float32 seconds)
*       public virtual bool HasFuel([Optional, DefaultParameterValue(False)] bool forceCheck)
*       public void DecayTick()
*       public override void Save(.SaveInfo info)
*       public bool WaterLogged()
*       public UnityEngine.Transform buoyancyPoint;
*       public UnityEngine.Transform[] windFlags;
*       public float32 windForce;
*       add option/config -> if bool godballoon true 0 damage; else chat message with health/max
*=======================================================================================================================*/

    public class MyHotAirBalloon : RustPlugin
    {
        bool debug = false;
        private string DaBalloonBar;
		private string DaBalloonBarHealth;
        private string DaBalloonBarWind;
        private string DaBalloonBarInflation;
        private string DaBalloonBarLift;
        private string DaBalloonBarFuel;
        private string DaBalloonBarLock;
        private string DaBalloonBarupboost;
        private string DaBalloonNavigatorBar;
        private string DaBalloonNavigatorBarWest;
        private string DaBalloonNavigatorBarEast;
        private string DaBalloonNavigatorBarNorth;
        private string DaBalloonNavigatorBarSouth;
        private string DaBalloonBombBar;
        string Prefix = "[My Balloon] ";
        string PrefixColor = "#008000";
        string ChatColor = "#a5d9ff"; 
        ulong SteamIDIcon = 76561198387807862;
        float fuelrate = 0.25f;
        double barbottom = 0.12;

////// maximum bombs/player
////////// perm for unlimited bombs
////////// player timer to refill bombs quantity
////// true/false to remove all balloons with no owners

        const string prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab";
        string lightprefab = "assets/prefabs/misc/xmas/christmas_lights/xmas.lightstring.deployed.prefab";
        string stockprefab = "assets/prefabs/misc/xmas/stockings/stocking_large_deployed.prefab";

        private bool ConfigChanged;
        const string Ballooner = "myhotairballoon.player"; 
        const string UnBallooner = "myhotairballoon.despawn"; 
        const string GodBalloon = "myhotairballoon.god"; 
        const string FuelRateBalloon = "myhotairballoon.fuel"; 
        const string BalloonTP = "myhotairballoon.tp";
        const string Navigator = "myhotairballoon.navigate";
        const string Bomber = "myhotairballoon.bomb";

        //public Dictionary<HotAirBalloon, bool > balloonlock = new Dictionary<HotAirBalloon, bool>();    // FOR FUTURE USE
        public Dictionary<BasePlayer, HotAirBalloon > baseplayerballoon = new Dictionary<BasePlayer, HotAirBalloon>();
        public Dictionary<HotAirBalloon, Timer > balloontimer = new Dictionary<HotAirBalloon, Timer>();
        //public Dictionary<HotAirBalloon, Timer > balloontimernavigate = new Dictionary<HotAirBalloon, Timer>();

        public List<BasePlayer> NavigateMode = new List<BasePlayer>();
        public Dictionary<HotAirBalloon, Vector3 > balloonposition = new Dictionary<HotAirBalloon, Vector3>();
        public List<BasePlayer> BalloonWest = new List<BasePlayer>();
        public List<BasePlayer> BalloonEast = new List<BasePlayer>();
        public List<BasePlayer> BalloonNorth = new List<BasePlayer>();
        public List<BasePlayer> BalloonSouth = new List<BasePlayer>();
//        public List<BasePlayer> PlayerInBalloon = new List<BasePlayer>();

    class StoredData
    {
        public Dictionary<ulong, uint> playerballoon = new Dictionary<ulong, uint>();

        public StoredData()
        {
        }
    }
        private StoredData storedData;

        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(Ballooner, this);
            permission.RegisterPermission(GodBalloon, this);
            permission.RegisterPermission(FuelRateBalloon, this);
            permission.RegisterPermission(BalloonTP, this);
            permission.RegisterPermission(Navigator, this);
            permission.RegisterPermission(Bomber, this);
            permission.RegisterPermission(UnBallooner, this);

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); 
        }

        void OnServerInitialized()
        {
////////////// after reload - get back balloon uint to class hotairballoon
            PluginReload();
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                CuiHelper.DestroyUi(player, DaBalloonBar);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBar);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarWest);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarEast);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarNorth);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarSouth);
                CuiHelper.DestroyUi(player, DaBalloonBombBar);
            }        
        }
#region BackOnTimer
        void PluginReload()
        {
           foreach (var Balloon in UnityEngine.Object.FindObjectsOfType<HotAirBalloon>())
            {
                if (debug) Puts("ONE Balloon found");
                BaseEntity Loloon = Balloon as BaseEntity;
                if (Loloon == null)
                {
                    if (debug) Puts("Loloon NULL !!");
                    return;
                }
                if (debug) Puts($"Loloon.OwnerID {Loloon.OwnerID}");
                if (Loloon.OwnerID == 0)
                {
                    if (debug) Puts("RELOAD EACH - HAB Owner is null");
                }
                else
                {
                    //playerballoonreload.Add(Loloon.OwnerID, Loloon.net.ID);
                    foreach(BasePlayer player in BasePlayer.activePlayerList.ToList())
                    {
                        if (player.userID == Loloon.OwnerID)
                        {
                            baseplayerballoon.Remove(player);
                            baseplayerballoon.Add(player, Balloon);
                            BalloonBar(player);
                            BalloonTimer(Balloon, Loloon, player);
                            //BalloonBarButtons(player, Balloon.fuelPerSec, Balloon.inflationLevel, Balloon.liftAmount, Balloon.windForce, 0);
//                            BalloonBarButtons(player, Balloon.fuelPerSec, Balloon.inflationLevel, Balloon.liftAmount, Balloon.windForce, Loloon.Health());

                            if (debug) Puts("RELOAD - ONE HAB BACK for online player");
                        }
                    }
                }
            }
        }

////////////// ON PLAYER RESPAWN - get back HUD etc.
        void OnPlayerSleepEnded(BasePlayer player)
        {
           foreach (var Balloon in UnityEngine.Object.FindObjectsOfType<HotAirBalloon>())
            {
                BaseEntity Loloon = Balloon as BaseEntity;
                if (Loloon.OwnerID == null)
                {
                    if (debug) Puts("SLEEPENDED EACH - HAB Owner is null");
                }
                else
                {
                    if (player.userID == Loloon.OwnerID)
                    {
                        baseplayerballoon.Remove(player);
                        baseplayerballoon.Add(player, Balloon);
                        BalloonBar(player);
                        BalloonTimer(Balloon, Loloon, player);
                        if (debug) Puts("SLEEPENDED - ONE HAB BACK for player");
                    }
                }
            }
        }
#endregion
#region MESSAGES

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AlreadyMsg", "You already have a Hot Air Balloon.\nuse command '/noballoon' to remove it."},
                {"SpawnedMsg", "Your Hot Air Balloon has spawned !\nuse command '/noballoon' to remove it and its HUD."},
                {"HealthMsg", "Your Balloon' Health is now"},
                {"KilledMsg", "Your Balloon has been removed/killed."},
                {"NoPermMsg", "You are not allowed to do this."},
                {"healthinfoMsg", "Health :"},
                {"windforceMsg", "Speed :"},
                {"liftMsg", "Lift :"},
                {"inflationMsg", "Inflation :"},
                {"lockMsg", "Lock :"},
                {"fuelMsg", "Fuel/sec :"},
                {"NavButtonMsg", "Please Toggle NAV MODE to ON"},
                {"NoSpeedMsg", "NAV MODE is ON. Speed is automatic only."},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AlreadyMsg", "Vous avez déjà une Montgolfière.\nutilisez la commande '/noballoon' pour la supprimer."},
                {"SpawnedMsg", "Votre Montgolfière est arrivée !\nutilisez la commande '/noballoon' pour la supprimer ainsi que son interface."},
                {"HealthMsg", "La santé de votre Montgolfière est de"},
                {"KilledMsg", "Votre Montgolfière a disparu du monde."},
                {"NoPermMsg", "Vous n'êtes pas autorisé."},
                {"healthinfoMsg", "Vie :"},
                {"windforceMsg", "Vitesse :"},
                {"liftMsg", "Lift :"},
                {"inflationMsg", "Inflation :"},
                {"lockMsg", "Lock :"},
                {"fuelMsg", "Fuel/sec :"},
                {"NavButtonMsg", "Activez d'abord le MODE NAV"},
                {"NoSpeedMsg", "Le MODE NAV est activé. La vitesse n'est pas modifiable."},

            }, this, "fr");
        }

#endregion
#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[My Balloon] "));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#008000"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#a5d9ff"));                    // CHAT MESSAGE COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561198387807862"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NONE YET /
            fuelrate = Convert.ToSingle(GetConfig("Fuel per second", "0.25 by default", "0.25"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NONE YET /
            barbottom = Convert.ToDouble(GetConfig("HUD position - bar bottom", "0.12 by default", "0.12"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion
#region EntitySpawn

/////////// PLAYER SPAWNS HIS BALLOON //////////////

            BaseEntity SpawnEntity(string prefab, bool active, int angx, int angy, int angz, float posx, float posy, float posz, BaseEntity parent, ulong skinid)
            {
                    BaseEntity entity = GameManager.server.CreateEntity(prefab, new Vector3(), new Quaternion(), active);
                    if (entity == null) return null;
                    entity.transform.localEulerAngles = new Vector3(angx, angy, angz);
                    entity.transform.localPosition = new Vector3(posx, posy, posz);
                    if (parent == null) return null;                    
                    entity.SetParent(parent, 0);
                    entity.skinID = skinid;
                    entity?.Spawn();
                    RefreshPosition(entity);
                    return entity;
            }

            void RefreshPosition(BaseEntity entity)
            {
                var stability = entity.GetComponent<StabilityEntity>();
                if(stability != null){stability.grounded = true;}
                var mountable = entity.GetComponent<BaseMountable>();
                if(mountable != null){mountable.isMobile = true;}
            }

#endregion
#region Teleport

        [ChatCommand("balloon_tp")]         
        private void TeleportTo(BasePlayer player, string command, string[] args)
        {
            bool isballooner = permission.UserHasPermission(player.UserIDString, Ballooner);
            bool balloontp = permission.UserHasPermission(player.UserIDString, BalloonTP);

            if (isballooner == false || balloontp == false)
            {
                Player.Message(player, $"<color={ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            if (storedData.playerballoon.ContainsKey(player.userID) == true)
            {
                uint deluint;
                storedData.playerballoon.TryGetValue(player.userID, out deluint);
                var balloonposition = BaseNetworkable.serverEntities.Find(deluint);
                if (balloonposition == null)return;
                Vector3 WhereBalloonIs = new Vector3(balloonposition.transform.position.x,balloonposition.transform.position.y+0.5f,balloonposition.transform.position.z);

                player.Teleport(WhereBalloonIs);
            }
        }

#endregion

        [ChatCommand("balloon_invite")]         
        private void InviteAFriend(BasePlayer player, string command, string[] args)
        {
            /*bool isballooner = permission.UserHasPermission(player.UserIDString, Ballooner);
            if (isballooner == false)
            {
                Player.Message(player, $"<color={ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }*/
        }

        [ChatCommand("balloon_lock")]         
        private void LockMyBalloon(BasePlayer player, string command, string[] args)
        {



        }

#region Bomber

        void MyBallonBombHUD(HotAirBalloon Balloon, BaseEntity Loloon, BasePlayer player)
        {
			var CuiElement = new CuiElementContainer();
			DaBalloonBombBar = CuiElement.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.0"},RectTransform ={AnchorMin = $"0.685 {barbottom+0.10}",AnchorMax = $"0.715 {barbottom+0.13}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });
            string bombbuttoncolor = "1.0 0.7 0.2 0.8";
            Vector3 pouzichon = Balloon.transform.position;
            float height = TerrainMeta.HeightMap.GetHeight(pouzichon);
            float meters = Balloon.transform.position.y - height;
            if (debug) Puts($"meters {meters}");
            if (meters>20)
            {
                bombbuttoncolor = "0.5 1.0 0.0 0.8";
            }
            var BombButton = CuiElement.Add(new CuiButton
                {Button ={Command = $"DropABombFromMyBalloon",Color = bombbuttoncolor},Text ={Text = $"BOMB",Color = "0.0 0.0 0.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonBombBar);

			CuiHelper.AddUi(player, CuiElement);
        }

        [ConsoleCommand("DropABombFromMyBalloon")]
        private void MyBallonBombDrop(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            HotAirBalloon Balloon = new HotAirBalloon();
            if (debug) Puts("BOMB Commanded !!!");
            foreach (var item in baseplayerballoon)
            {
                if (item.Key == player)
                {
                    if (debug) Puts("BOMB Command - found balloon");
                    Balloon = item.Value;
                    Vector3 daboom = new Vector3(Balloon.transform.position.x,Balloon.transform.position.y - 3,Balloon.transform.position.z);
                    BaseEntity BombJack = ItemManager.CreateByName("jackolantern.angry", 1).Drop(daboom, Vector3.up);

                    if (BombJack == null)
                    {
                        if (debug) Puts("BombJack == null");
                        return;
                    }
                    if (debug) Puts("BOMB DROP !!!");
                    timer.Once(3f, () =>
                    {
                        daboom = BombJack.transform.position;
                        BombJack?.Kill();
                        BaseEntity GrenadeF1 = GameManager.server.CreateEntity("assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", daboom, new Quaternion(), true);
                        TimedExplosive boom = new TimedExplosive();
                        boom = GrenadeF1.GetComponent<TimedExplosive>();
                        boom?.Explode();

                    });
                }
            }
        }

#endregion
#region Navigator
/////////////////////////
// NAVIGATION HUD/SYSTEM
/////////////////////////

        private void NavigateMyBalloon(HotAirBalloon Balloon, BaseEntity Loloon, BasePlayer player)
        {
            if (!player.HasParent())
            {
                if (debug)Puts($"player NOT in Balloon");
                return;
            }
            else
            {
                var isparentaballoon = player.GetParentEntity() as HotAirBalloon;
                if (isparentaballoon == null) return;
                if (isparentaballoon != Balloon) return;
            }
            if (debug)Puts($"player IS in Balloon. HUD launch");
            bool isnavigator = permission.UserHasPermission(player.UserIDString, Navigator);
            //if (!isnavigator) return;
            bool isbomber = permission.UserHasPermission(player.UserIDString, Bomber);
            if (isbomber) MyBallonBombHUD(Balloon, Loloon, player);
            if (isnavigator) NavigatorBarHUD(Balloon, Loloon, player);
            //list playerinballoon
        }

        void NavigatorBarHUD(HotAirBalloon Balloon, BaseEntity Loloon, BasePlayer player)
        {
			var CuiElement = new CuiElementContainer();
			DaBalloonNavigatorBar = CuiElement.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.645 {barbottom+0.06}",AnchorMax = $"0.68 {barbottom+0.09}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });

            if (debug)Puts($"WIND VECTOR => {Balloon.currentWindVec}");
            Vector3 actualwind = Balloon.currentWindVec;
            Vector3 finalwind = new Vector3(0,0,0);
            Vector3 eastwind = new Vector3(1000,0,0);
            Vector3 westwind = new Vector3(-1000,0,0);
            Vector3 northwind = new Vector3(0,0,1000);
            Vector3 southwind = new Vector3(0,0,-1000);

            string navigatecolor = "1.0 0.5 0.5 0.2";
            string navigatewest = "1.0 1.0 0.5 0.2";
            string navigateeast = "1.0 1.0 0.5 0.2";
            string navigatenorth = "1.0 1.0 0.5 0.2";
            string navigatesouth = "1.0 1.0 0.5 0.2";

            if (NavigateMode.Contains(player))
            {
                navigatecolor = "0.0 1.0 0.0 0.2";
                if (BalloonEast.Contains(player))
                {
                    navigateeast = "0.0 1.0 0.0 0.6";
                    finalwind = finalwind + eastwind;
                }
                if (BalloonWest.Contains(player))
                {
                    navigatewest = "0.0 1.0 0.0 0.6";
                    finalwind = finalwind + westwind;
                }
                if (BalloonNorth.Contains(player))
                {
                    navigatenorth = "0.0 1.0 0.0 0.6";
                    finalwind = finalwind + northwind;
                }
                if (BalloonSouth.Contains(player))
                {
                    navigatesouth = "0.0 1.0 0.0 0.6";
                    finalwind = finalwind + southwind;
                }
                Balloon.windForce = 0;
                if (debug)Puts($"FINAL VECTOR3 => {finalwind}");
                if (Balloon.inflationLevel >= 1) Balloon.myRigidbody.AddForce(finalwind,ForceMode.Impulse);
            }
            else
            {
                if (Balloon.windForce == 0) Balloon.windForce = 600f;
            }
            var NavigatorButton = CuiElement.Add(new CuiButton
                {Button ={Command = $"NavigateMyHotAirBalloon state",Color = navigatecolor},Text ={Text = $"NAV\nON/OFF",Color = "1.0 1.0 1.0 1.0",FontSize = 8,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonNavigatorBar);
			CuiHelper.AddUi(player, CuiElement);

			var CuiElementWest = new CuiElementContainer();
			DaBalloonNavigatorBarWest = CuiElementWest.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.61 {barbottom+0.06}",AnchorMax = $"0.64 {barbottom+0.09}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });

			var CuiElementEast = new CuiElementContainer();
			DaBalloonNavigatorBarEast = CuiElementEast.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.685 {barbottom+0.06}",AnchorMax = $"0.715 {barbottom+0.09}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });
            
			var CuiElementNorth = new CuiElementContainer();
			DaBalloonNavigatorBarNorth = CuiElementNorth.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.645 {barbottom+0.10}",AnchorMax = $"0.68 {barbottom+0.13}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });

			var CuiElementSouth = new CuiElementContainer();
			DaBalloonNavigatorBarSouth = CuiElementSouth.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.645 {barbottom+0.02}",AnchorMax = $"0.68 {barbottom+0.05}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });

            var NavigatorWestButton = CuiElementWest.Add(new CuiButton
                {Button ={Command = $"NavigateMyHotAirBalloon west",Color = navigatewest},Text ={Text = $"WEST",Color = "1.0 1.0 1.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonNavigatorBarWest);

            var NavigatorEastButton = CuiElementEast.Add(new CuiButton
                {Button ={Command = $"NavigateMyHotAirBalloon east",Color = navigateeast},Text ={Text = $"EAST",Color = "1.0 1.0 1.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonNavigatorBarEast);

            var NavigatorNorthButton = CuiElementNorth.Add(new CuiButton
                {Button ={Command = $"NavigateMyHotAirBalloon north",Color = navigatenorth},Text ={Text = $"NORTH",Color = "1.0 1.0 1.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonNavigatorBarNorth);

            var NavigatorSouthButton = CuiElementSouth.Add(new CuiButton
                {Button ={Command = $"NavigateMyHotAirBalloon south",Color = navigatesouth},Text ={Text = $"SOUTH",Color = "1.0 1.0 1.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.0 0.0",   AnchorMax = "1.0 1.0"}
                }, DaBalloonNavigatorBarSouth);

			CuiHelper.AddUi(player, CuiElementWest);
			CuiHelper.AddUi(player, CuiElementEast);
			CuiHelper.AddUi(player, CuiElementNorth);
			CuiHelper.AddUi(player, CuiElementSouth);
        }

        [ConsoleCommand("NavigateMyHotAirBalloon")]
        private void NavigateMyHotAirBalloon(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;

            if (arg.Args[0] == "state")
            {
                if (NavigateMode.Contains(player))
                {
                    NavigateMode.Remove(player);
                    BalloonEast.Remove(player);
                    BalloonWest.Remove(player);
                    BalloonSouth.Remove(player);
                    BalloonNorth.Remove(player);
                }
                else NavigateMode.Add(player);
            }
            else
            {
                if (!NavigateMode.Contains(player))
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NavButtonMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    return;
                }
                if (arg.Args[0] == "west")
                {
                    if (BalloonWest.Contains(player)) BalloonWest.Remove(player);
                    else BalloonWest.Add(player);
                    if (BalloonEast.Contains(player)) BalloonEast.Remove(player);
                    return;
                }
                if (arg.Args[0] == "east")
                {
                    if (BalloonEast.Contains(player)) BalloonEast.Remove(player);
                    else BalloonEast.Add(player);
                    if (BalloonWest.Contains(player)) BalloonWest.Remove(player);
                    return;
                }
                if (arg.Args[0] == "north")
                {
                    if (BalloonNorth.Contains(player)) BalloonNorth.Remove(player);
                    else BalloonNorth.Add(player);
                    if (BalloonSouth.Contains(player)) BalloonSouth.Remove(player);
                    return;
                }
                if (arg.Args[0] == "south")
                {
                    if (BalloonSouth.Contains(player)) BalloonSouth.Remove(player);
                    else BalloonSouth.Add(player);
                    if (BalloonNorth.Contains(player)) BalloonNorth.Remove(player);
                    return;  
                }
            }
        }
#endregion
#region BalloonSpawn
//////////////////////////
// BALLOON SPAWN
//////////////////////////

        float RandomAFloatBuddy()
        {
            System.Random randomized = new System.Random();
            float x = randomized.Next(-10,10);
            return x;
        }

        [ConsoleCommand("SpawnMyHotAirBalloon")]
        private void SpawnMyHotAirBalloonConsole(ConsoleSystem.Arg arg)
        {
            //BasePlayer player = arg.Connection.player as BasePlayer;
            if(arg.Args == null || arg.Args.Length == 0)
            {
                if (debug)PrintWarning($"SPAWN CONSOLE COMMAND NULL");
                return;
            }
            ulong searchID = 0;
            if (ulong.TryParse(arg.Args[0], out searchID) == false)
            {
                if (debug)PrintWarning($"SPAWN CONSOLE COMMAND - NOT ULONG");               
                return;
            }
            BasePlayer playerfound;
            foreach (var playerzonline in BasePlayer.activePlayerList.ToList())
            {
                if (playerzonline.userID == searchID)
                {
                    playerfound = playerzonline;
                    if (debug)Puts($"SPAWN CONSOLE COMMAND ON PLAYER");
                    SpawnMyBalloon(playerfound, null, null);
                    return;
                }
            }
            if (debug)Puts($"PLAYER NOT FOUND");
        }

        [ChatCommand("balloon")]         
        private void SpawnMyBalloonChatCommand(BasePlayer player, string command, string[] args)
        {
            bool isballooner = permission.UserHasPermission(player.UserIDString, Ballooner);
            if (isballooner == false)
            {
                Player.Message(player, $"<color={ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            if (storedData.playerballoon.ContainsKey(player.userID) == true)
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("AlreadyMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            SpawnMyBalloon(player, null, null); 

        }

        private void SpawnMyBalloon(BasePlayer player, string command, string[] args)
        {
            //Vector3 position = player.transform.position + (player.transform.forward * 20);

            float randomx = RandomAFloatBuddy();
            float randomy = RandomAFloatBuddy();

            Vector3 random3 = new Vector3(randomx,15,randomy);
            Vector3 position = player.transform.position + random3;
            
            if (position == null) return;
            HotAirBalloon Balloon = (HotAirBalloon)GameManager.server.CreateEntity(prefab, position, new Quaternion());
            if (Balloon == null) return;
            Balloon.fuelPerSec = fuelrate;
            bool isfuel = permission.UserHasPermission(player.UserIDString, FuelRateBalloon);
            if (isfuel == true)
            {
                Balloon.fuelPerSec = 0; //0.25 by default
            }
            Balloon.Spawn();
            Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("SpawnedMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            BaseEntity Loloon = Balloon as BaseEntity;
            Loloon.OwnerID = player.userID;
#endregion
#region BalloonLights
//////////////////
//BALLOON LIGHTS
//////////////////

            //Quaternion entityrot;
            //Vector3 entitypos;


            BaseEntity lightunderleft = SpawnEntity(lightprefab, true, 0, 90, 0, 1.4f, 0.31f, 0.1f, Loloon, 1);
            if (lightunderleft != null){lightunderleft.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity lightunderright = SpawnEntity(lightprefab, true, 0, 90, 0, -1.5f, 0.31f, 0.1f, Loloon, 1);
            if (lightunderright != null){lightunderright.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity lightdoorleft = SpawnEntity(lightprefab, true, 0, 0, 90, 0.7f, 1.4f, 1.5f, Loloon, 1);
            if (lightdoorleft != null){lightdoorleft.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity lightdoorright = SpawnEntity(lightprefab, true, 0, 0, 90, -0.8f, 1.4f, 1.5f, Loloon, 1);
            if (lightdoorright != null){lightdoorright.SetFlag(BaseEntity.Flags.Busy, true);}
#endregion
#region BalloonSocks
//////////////////
//STOCKS
//////////////////
            BaseEntity stock1L = SpawnEntity(stockprefab, true, 0, 90, 0, 1.5f, 0.2f, 0.6f, Loloon, 1);
            if (stock1L != null){stock1L.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity stock2L = SpawnEntity(stockprefab, true, 0, 90, 0, 1.5f, 0.2f, -0.6f, Loloon, 1);
            if (stock2L != null){stock1L.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity stock1R = SpawnEntity(stockprefab, true, 0, 90, 0, -1.5f, 0.2f, 0.6f, Loloon, 1);
            if (stock1L != null){stock1R.SetFlag(BaseEntity.Flags.Busy, true);}
            BaseEntity stock2R = SpawnEntity(stockprefab, true, 0, 90, 0, -1.5f, 0.2f, -0.6f, Loloon, 1);
            if (stock2L != null){stock2R.SetFlag(BaseEntity.Flags.Busy, true);}

            uint balluint = Balloon.net.ID;
            if (debug == true) {Puts($"SPAWNED BALLOON {balluint.ToString()} for player {player.displayName}");}

            //BaseCombatEntity Loon = Balloon as BaseCombatEntity;
            storedData.playerballoon.Remove(player.userID);
            storedData.playerballoon.Add(player.userID,balluint);
            //balloonlist.Add(balluint,Balloon);
            baseplayerballoon.Remove(player);
            baseplayerballoon.Add(player, Balloon);
//////////////////
            float entityhealth = Loloon.Health();
            BalloonBar(player);
            BalloonTimer(Balloon, Loloon, player);
            BalloonBarButtons(player, Balloon.fuelPerSec, Balloon.inflationLevel, Balloon.liftAmount, Balloon.windForce, entityhealth);
        }
#endregion
#region Despawn/Kill
/////////////////////////////
// BALLOON DESPAWN KILL
////////////////////////////
        [ConsoleCommand("DespawnMyHotAirBalloon")]
        private void DespawnMyHotAirBalloonConsole(ConsoleSystem.Arg arg)
        {
            //BasePlayer player = arg.Connection.player as BasePlayer;
            if(arg.Args == null || arg.Args.Length == 0)
            {
                if (debug)PrintWarning($"DESPAWN CONSOLE COMMAND NULL");
                return;
            }
            ulong searchID = 0;
            if (ulong.TryParse(arg.Args[0], out searchID) == false)
            {
                if (debug)PrintWarning($"SPAWN CONSOLE COMMAND - NOT ULONG");               
                return;
            }
            BasePlayer playerfound;
            foreach (var playerzonline in BasePlayer.activePlayerList.ToList())
            {
                if (playerzonline.userID == searchID)
                {
                    playerfound = playerzonline;
                    if (debug)Puts($"DESPAWN CONSOLE COMMAND ON PLAYER");
                    KillMyBalloon(playerfound, null, null);
                    return;
                }
            }
            if (debug)Puts($"PLAYER NOT FOUND");
        }

        [ChatCommand("noballoon")]         
        private void KillMyBalloonChatCommand(BasePlayer player, string command, string[] args)
        {
            bool isunballooner = permission.UserHasPermission(player.UserIDString, UnBallooner);
            if (isunballooner == false)
            {
                Player.Message(player, $"<color={ChatColor}><i>{lang.GetMessage("NoPermMsg", this, player.UserIDString)}</i></color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            KillMyBalloon(player, null, null);
        }

        private void KillMyBalloon(BasePlayer player, string command, string[] args)
        {
            if (storedData.playerballoon.ContainsKey(player.userID) == true)
            {
                uint deluint;
                storedData.playerballoon.TryGetValue(player.userID, out deluint);
                var tokill = BaseNetworkable.serverEntities.Find(deluint);
                if (tokill != null) tokill.Kill();
                storedData.playerballoon.Remove(player.userID);
                //balloonlist.Remove(deluint);
                baseplayerballoon.Remove(player);
                CuiHelper.DestroyUi(player, DaBalloonBar);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBar);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarWest);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarEast);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarNorth);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarSouth);
            }
        }
#endregion
/////////// CHAT MESSAGE TO ONLINE PLAYER with ulong //////////////

        private void ChatPlayerOnline(ulong ailldi, string message)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                if (player.userID == ailldi)
                {
                    if (message == "killed")
                    {
                        Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("KilledMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    }
                }
            }
        }

/////////////////// SET A SPAWN LOCATION TO RECALL : balloon_set balloon_call /////////////////////////////

#region Damage
////////////////////
// ON DAMAGE - chat owner and in future restore health to max
/////////////////////

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null) return;
            if (entity.net.ID == null)return;

            if (hitInfo.Initiator != null) NullMHABDamage(entity, hitInfo);

            HotAirBalloon check = entity as HotAirBalloon;
            if (check == null) return;

            if (storedData.playerballoon == null) return;
            foreach (var item in storedData.playerballoon)
            {
                if (item.Value == entity.net.ID)
                {
                    bool isgod = permission.UserHasPermission(item.Key.ToString(), GodBalloon);
                    if (isgod == true)
                    {
                        hitInfo.damageTypes.ScaleAll(0);
                    }
                }
            }
        }

        void NullMHABDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            HotAirBalloon balloon = hitInfo.Initiator as HotAirBalloon;
            if (balloon == null) return;
            BasePlayer goodguy = entity as BasePlayer;
            if (goodguy == null) return;
            hitInfo.damageTypes.ScaleAll(0);
        }

#endregion
#region HUD
/////////////////
// MAIN HUD
///////////////////////////

        void BalloonBar(BasePlayer player)
        {
			var CuiElement = new CuiElementContainer();
			DaBalloonBar = CuiElement.Add(new CuiPanel{Image ={Color = "0.0 0.0 0.0 0.2"},RectTransform ={AnchorMin = $"0.345 {barbottom}",AnchorMax = $"0.64 {barbottom+0.05}"},CursorEnabled = false
//                }, new CuiElement().Parent = "Overlay", DaBalloonBar);
            });

            var speedminus = CuiElement.Add(new CuiButton
                {Button ={Command = $"BalloonMinus",Color = $"1.0 0.5 0.5 0.2"},Text ={Text = $"-",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.26 0.10",   AnchorMax = "0.34 0.90"}
                }, DaBalloonBar);

            var speedplus = CuiElement.Add(new CuiButton
                {Button ={Command = $"BalloonPlus",Color = $"0.0 1.0 0.0 0.2"},Text ={Text = $"+",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = "0.46 0.10",   AnchorMax = "0.53 0.90"}
                }, DaBalloonBar);

			CuiHelper.AddUi(player, CuiElement);
        }

        private void BalloonBarButtons(BasePlayer player, float fuelpersec, float inflation, float lift, float windforce, float entityhealth)
        {
            if (debug) Puts($"lift {lift}");
            bool isgod = permission.UserHasPermission(player.UserIDString, GodBalloon);
            string health = ($"{entityhealth.ToString()}/1500");
            if (isgod == true)
            {
                health = "GOD";
            }
            bool isfuel = permission.UserHasPermission(player.UserIDString, FuelRateBalloon);
            string fuelrated = ($"{fuelrate}");
            if (isfuel == true)
            {
                fuelrated = "UNLIMITED";
            }

            string locked = "N/A";
            string windforced = windforce.ToString();
            if (windforce == 600f)
            {
                windforced = "MIN";
            }
            if (windforce >= 3000f)
            {
                windforced = "MAX";
            }
            if (windforce == 0f)
            {
                windforced = "NAV";
            }
			    var CuiElement = new CuiElementContainer();

			    DaBalloonBarHealth = CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("healthinfoMsg", this, player.UserIDString)} {health}",FontSize = 10,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.01 0.10",   AnchorMax = "0.25 0.90"}
				}, DaBalloonBar);

			    DaBalloonBarWind = CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("windforceMsg", this, player.UserIDString)}\n{windforced}",FontSize = 10,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.35 0.10",   AnchorMax = "0.45 0.90"}
				}, DaBalloonBar);

			    /*DaBalloonBarInflation = CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("inflationMsg", this, player.UserIDString)}\n{inflation}",FontSize = 10,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.54 0.10",   AnchorMax = "0.64 0.90"}
				}, DaBalloonBar);*/
                if (inflation == 1)
                {
                    DaBalloonBarupboost = CuiElement.Add(new CuiButton
                    {Button ={Command = $"BalloonBoost",Color = $"0.0 1.0 0.0 0.2"},Text ={Text = $"upBOOST",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                        RectTransform ={AnchorMin = "0.54 0.10",   AnchorMax = "0.68 0.90"}
                    }, DaBalloonBar);
                }

                DaBalloonBarLock = CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("lockMsg", this, player.UserIDString)}\n{locked}",FontSize = 10,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.69 0.10",   AnchorMax = "0.81 0.90"}
				}, DaBalloonBar);
                
                DaBalloonBarFuel = CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("fuelMsg", this, player.UserIDString)}\n{fuelrated}",FontSize = 10,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.82 0.10",   AnchorMax = "0.99 0.90"}
				}, DaBalloonBar);

			    CuiHelper.AddUi(player, CuiElement);
        }

        [ConsoleCommand("BalloonMinus")]
        private void BalloonMinus(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (NavigateMode.Contains(player))
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NoSpeedMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            foreach (var item in baseplayerballoon)
            {
                if (item.Key == player)
                {
                    HotAirBalloon Balloon = item.Value;
                    Balloon.windForce = Balloon.windForce - 100f;
                    if (Balloon.windForce < 600f)
                    {
                        Balloon.windForce = 600f;
                    }
                }
            }
        }

        [ConsoleCommand("BalloonPlus")]
        private void BalloonPlus(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (NavigateMode.Contains(player))
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("NoSpeedMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            foreach (var item in baseplayerballoon)
            {
                if (item.Key == player)
                {
                    HotAirBalloon Balloon = item.Value;
                    Balloon.windForce = Balloon.windForce + 100f;
                    if (Balloon.windForce > 3000f)
                    {
                        Balloon.windForce = 3000f;
                    }
                }
            }
        }

        [ConsoleCommand("BalloonBoost")]
        private void BalloonUpBoost(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            foreach (var item in baseplayerballoon)
            {
                if (item.Key == player)
                {
                    HotAirBalloon Balloon = item.Value;
                    if (Balloon.inflationLevel == 1f)
                    {
                        Balloon.inflationLevel = 2f;
                        timer.Once(3f, () =>
                        {
                            Balloon.inflationLevel = 1f;
                        });
                    }
                }
            }
        }
#endregion
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            CuiHelper.DestroyUi(player, DaBalloonBar);
            CuiHelper.DestroyUi(player, DaBalloonNavigatorBar);
            CuiHelper.DestroyUi(player, DaBalloonBombBar);
        }

        private void BalloonTimer(HotAirBalloon Balloon, BaseEntity Loloon, BasePlayer player)
        {
            bool stand = new bool();
            Vector3 tonpere = new Vector3();
            Vector3 tamere = new Vector3();

           /* var zicontainer = Loloon.gameObject.GetComponent<LootContainer>();
            if (zicontainer !=null)
            {
                    Puts($"CONTAINER ON !!!!!");

            }*/


            Timer newtimer = timer.Every(2f, () =>
            {
                //Balloon.ScheduleOff();
                //Puts($"ScheduleOff");
                tonpere = new Vector3();
                tamere = new Vector3();
                CuiHelper.DestroyUi(player, DaBalloonBarHealth);
                CuiHelper.DestroyUi(player, DaBalloonBarWind);
                CuiHelper.DestroyUi(player, DaBalloonBarLock);
                CuiHelper.DestroyUi(player, DaBalloonBarFuel);
                CuiHelper.DestroyUi(player, DaBalloonBarupboost);
                /////// nav
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBar);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarWest);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarEast);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarNorth);
                CuiHelper.DestroyUi(player, DaBalloonNavigatorBarSouth);
                ///// bomb
                CuiHelper.DestroyUi(player, DaBalloonBombBar);


                tamere = Balloon.transform.position;

                if (!balloonposition.ContainsKey(Balloon))
                {
                    balloonposition.Add(Balloon, tamere);
                    if (debug)Puts($"POSITION VIERGE");
                }
                else
                {
                    balloonposition.TryGetValue(Balloon, out tonpere);
                    if (tonpere == tamere)
                    {
                        if (debug)Puts($"MEME POSITION");
                    }
                    else
                    {
                        balloonposition.Remove(Balloon);
                        balloonposition.Add(Balloon, tamere);
                        if (debug)Puts($"IS MOVING");
                        if (debug)Puts($"1 {tonpere}");
                        if (debug)Puts($"2 {tamere}");
                    }
                }
                float fuelpersec = Balloon.fuelPerSec;
                float entityhealth = Loloon.Health();
                BalloonBarButtons(player, Balloon.fuelPerSec, Balloon.inflationLevel, Balloon.liftAmount, Balloon.windForce, entityhealth);
                NavigateMyBalloon(Balloon, Loloon, player);
            });
            balloontimer.Remove(Balloon);
            balloontimer.Add(Balloon, newtimer);
        }

#region OnKill
////////////////////// ON KILL - chat owner /////////////////////

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;
            if (entity.net.ID == null)return;
            HotAirBalloon check = entity as HotAirBalloon;
            if (check == null) return;
            if (storedData.playerballoon == null) return;
            foreach (var item in storedData.playerballoon)
            {
                if (item.Value == entity.net.ID)
                {
                    ChatPlayerOnline(item.Key, "killed");
                    storedData.playerballoon.Remove(item.Value);
                    foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                    {
                        if (player.userID == item.Key)
                        {
                            baseplayerballoon.Remove(player);
                            NavigateMode.Remove(player);
                            BalloonWest.Remove(player);
                            BalloonEast.Remove(player);
                            BalloonNorth.Remove(player);
                            BalloonSouth.Remove(player);
                        }                       
                    }
                }
            }

/// KILL TIMER
            foreach (var item in balloontimer)
            {
                Timer timertokill;
                if (item.Key == check)
                {
                    timertokill = item.Value;
                    timertokill.Destroy();
                    //balloontimer.Remove(item.Value);
                }
            }
        }
#endregion
    }
}

// --- End of file: MyHotAirBalloon.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-halloween-panel ---
// --- Original File Path: M/MagicHalloweenPanel/MagicHalloweenPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Halloween Panel", "MJSU", "1.0.3")]
    [Description("Displays if the halloween event is active")]
    public class MagicHalloweenPanel : RustPlugin
    {
        #region Class Fields

        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<HalloweenHunt> _halloweenEvents = new List<HalloweenHunt>();

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            UnsubscribeAll();
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/BbYRRf6N/3fTHEiz.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 13,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            NextTick(() =>
            {
                _halloweenEvents = UnityEngine.Object.FindObjectsOfType<HalloweenHunt>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }

            SubscribeAll();
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        
        public void CheckEvent()
        {
            if (_halloweenEvents.Count == 0 || _halloweenEvents.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        public void SubscribeAll()
        {
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityKill));
        }
        
        public void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks
        private void OnEntitySpawned(HalloweenHunt hunt)
        {
            if (CanShowPanel(hunt))
            {
                _halloweenEvents.Add(hunt);
                CheckEvent();
            }
        }

        private void OnEntityKill(HalloweenHunt hunt)
        {
            _halloweenEvents.Remove(hunt);
            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _halloweenEvents.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(HalloweenHunt hunt)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, hunt);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#EB6123FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicHalloweenPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-death-notes-panel ---
// --- Original File Path: M/MagicDeathNotesPanel/MagicDeathNotesPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Death Notes Panel", "MJSU", "1.0.2")]
    [Description("Displays death notes in MagicPanel")]
    public class MagicDeathNotesPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _deathText;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private Timer _updateTimer;
        private readonly List<string> _displayText = new List<string>();
        private readonly List<DateTime> _expireTime = new List<DateTime>();
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _deathText = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? false,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.2f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 1f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#fff2df08",
                Dock = config.PanelSettings?.Dock ?? "undercompass",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.4f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region Death Notes Hook
        
        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            _displayText.Add(message);
            if (_displayText.Count <= _pluginConfig.MaxDisplayEntries)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int) UpdateEnum.Text);
                _expireTime.Add(GetExpireTime());
            }

            if (_updateTimer == null)
            {
                _updateTimer = timer.In(_pluginConfig.DisplayDuration, UpdateDisplay);
            }
        }

        private void UpdateDisplay()
        {
            if (_displayText.Count == 0)
            {
                _updateTimer = null;
                return;
            }
            
            _displayText.RemoveAt(0);
            _expireTime.RemoveAt(0);
            
            MagicPanel?.Call("UpdatePanel", Name, (int) UpdateEnum.Text);
            if (_displayText.Count == 0)
            {
                _updateTimer = null;
                return;
            }

            if (_displayText.Count >= _pluginConfig.MaxDisplayEntries)
            {
                _expireTime.Add(GetExpireTime());
            }
            
            if (_expireTime.Count != 0)
            {
                _updateTimer = timer.In((float) (_expireTime[0] - DateTime.Now).TotalSeconds, UpdateDisplay);
            }
        }

        private DateTime GetExpireTime()
        {
            return DateTime.Now + TimeSpan.FromSeconds(_pluginConfig.DisplayDuration);
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                string message = string.Join("\n", _displayText.Take(_pluginConfig.MaxDisplayEntries).ToArray());
                text.Text = string.Format(_deathText, message);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Display Duration (Seconds)")]
            public float DisplayDuration { get; set; }
            
            [DefaultValue(1)]
            [JsonProperty(PropertyName = "Max Entries To Show")]
            public int MaxDisplayEntries { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicDeathNotesPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mega-drones ---
// --- Original File Path: M/MegaDrones/MegaDrones.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Text;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Mega Drones", "WhiteThunder", "0.2.10")]
    [Description("Allows players to spawn large drones with computer stations attached to them.")]
    internal class MegaDrones : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin DroneScaleManager, EntityScaleManager, VehicleDeployedLocks;

        private Configuration _config;
        private StoredData _data;

        private const string PermissionSpawn = "megadrones.spawn";
        private const string PermissionFetch = "megadrones.fetch";
        private const string PermissionDestroy = "megadrones.destroy";
        private const string PermissionGive = "megadrones.give";
        private const string PermissionCooldownPrefix = "megadrones.cooldown";

        private const string CommandName_MegaDrone = "megadrone";
        private const string CommandName_GiveMegaDrone = "givemegadrone";
        private const string SubCommandName_Help = "help";
        private const string SubCommandName_Fetch = "fetch";
        private const string SubCommandName_Destroy = "destroy";

        private const float MegaDroneScale = 7f;

        private const int DroneItemId = 1588492232;
        private const int ComputerStationItemId = -1588628467;
        private const int CCTVItemId = 634478325;

        private const BaseEntity.Slot MegaDroneSlot = BaseEntity.Slot.UpperModifier;

        private const string DronePrefab = "assets/prefabs/deployable/drone/drone.deployed.prefab";
        private const string ComputerStationPrefab = "assets/prefabs/deployable/computerstation/computerstation.deployed.prefab";
        private const string ComputerStationDeployEffectPrefab = "assets/prefabs/deployable/table/effects/table-deploy.prefab";
        private const string CCTVPrefab = "assets/prefabs/deployable/cctvcamera/cctv_deployed.prefab";
        private const string CCTVDeployEffectPrefab = "assets/prefabs/deployable/tuna can wall lamp/effects/tuna-can-lamp-deploy.prefab";

        private static readonly Vector3 ComputerStationLocalPosition = new Vector3(0, 0.115f, 0);
        private static readonly Quaternion ComputerStationLocalRotation = Quaternion.Euler(0, 180, 0);
        private static readonly Vector3 CameraLocalPosition = new Vector3(0, -0.032f);
        private static readonly Quaternion CameraLocalRotation = Quaternion.Euler(90, 0, 0);

        private static readonly Vector3 LockPosition = new Vector3(-0.65f, 0.732f, 0.242f);
        private static readonly Quaternion LockRotation = Quaternion.Euler(0, 270, 90);

        private static readonly Vector3 DroneExtents = new Vector3(0.75f, 0.1f, 0.75f) * MegaDroneScale / 2;

        private readonly object True = true;
        private readonly object False = false;

        // These layers are used to preventing spawning inside walls or players.
        private const int BoxcastLayers = Layers.Mask.Default
            + Layers.Mask.Deployed
            + Layers.Mask.Player_Server
            + Layers.Mask.AI
            + Layers.Mask.Vehicle_Detailed
            + Layers.Mask.Vehicle_World
            + Layers.Mask.World
            + Layers.Mask.Construction
            + Layers.Mask.Tree;

        private DynamicHookHashSet<NetworkableId> _megaDroneTracker;
        private DynamicHookHashSet<ulong> _droneMounteeTracker;
        private DynamicHookHashSet<ulong> _droneControllerTracker;

        public MegaDrones()
        {
            _droneMounteeTracker = new DynamicHookHashSet<ulong>(this,
                nameof(OnEntityDismounted),
                nameof(OnPlayerDismountFailed)
            );

            _droneControllerTracker = new DynamicHookHashSet<ulong>(this,
                nameof(OnServerCommand)
            );
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);
            _data = StoredData.Load();

            permission.RegisterPermission(PermissionSpawn, this);
            permission.RegisterPermission(PermissionFetch, this);
            permission.RegisterPermission(PermissionDestroy, this);
            permission.RegisterPermission(PermissionGive, this);

            foreach (var entry in _config.CommandAliases)
            {
                if (entry.Key == CommandName_MegaDrone)
                {
                    AddCovalenceCommand(entry.Value, nameof(CommandMegaDrone));
                }
                else if (entry.Key == CommandName_GiveMegaDrone)
                {
                    AddCovalenceCommand(entry.Value, nameof(CommandGiveMegaDrone));
                }
            }

            var megaDroneDynamicHookNames = new List<string>()
            {
                nameof(OnEntityTakeDamage),
                nameof(canRemove),
                nameof(OnEntityKill),
                nameof(OnBookmarkControlStarted),
                nameof(OnBookmarkControlEnded),
                nameof(OnEntityMounted),
                nameof(OnCCTVDirectionChange),
                nameof(OnVehicleLockDeployed),
                nameof(OnCCTVMovableBecome),
                nameof(OnDroneRangeLimit),
            };

            if (_config.DestroyOnDisconnect)
            {
                megaDroneDynamicHookNames.Add(nameof(OnPlayerDisconnected));
            }

            _megaDroneTracker = new DynamicHookHashSet<NetworkableId>(this, megaDroneDynamicHookNames.ToArray());
            _megaDroneTracker.Unsubscribe();

            _droneControllerTracker.Unsubscribe();
            _droneMounteeTracker.Unsubscribe();
        }

        private void OnServerInitialized()
        {
            RegisterWithVehicleDeployedLocks();

            if (VerifyDependencies())
            {
                RefreshAllMegaDrones();
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                var computerStation = player.GetMounted() as ComputerStation;
                if (computerStation == null)
                    continue;

                OnEntityMounted(computerStation, player);

                var entity = computerStation.currentlyControllingEnt.Get(serverside: true);
                var drone = entity as Drone;
                if (drone != null)
                {
                    OnBookmarkControlStarted(computerStation, player, string.Empty, drone);
                    continue;
                }

                var camera = entity as CCTV_RC;
                if (camera != null)
                {
                    OnBookmarkControlStarted(computerStation, player, string.Empty, camera);
                    continue;
                }
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CameraMovement.RemoveFromPlayer(player);
            }

            _data.Save();
        }

        private void OnServerSave()
        {
            _data.Save();
        }

        private void OnNewSave()
        {
            _data = StoredData.Reset();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin == DroneScaleManager || plugin == EntityScaleManager)
            {
                if (DroneScaleManager != null && EntityScaleManager != null)
                {
                    RefreshAllMegaDrones();
                }
            }
            else if (plugin == VehicleDeployedLocks)
            {
                RegisterWithVehicleDeployedLocks();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
                return;

            var drone = FindPlayerDrone(player.UserIDString);
            if (drone == null)
                return;

            NextTick(() =>
            {
                if (drone == null)
                    return;

                if (GetMountedPlayer(drone) == null)
                {
                    drone.Kill();
                }
            });
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.cmd.FullName != "vehicle.swapseats")
                return;

            var basePlayer = arg.Player();
            if (basePlayer == null)
                return;

            var station = basePlayer.GetMounted() as ComputerStation;
            if (station == null)
                return;

            var controlledEntity = station.currentlyControllingEnt.Get(serverside: true);
            if (controlledEntity == null)
                return;

            CCTV_RC camera;

            Drone drone = controlledEntity as Drone;
            if (drone != null && IsMegaDrone(drone))
            {
                camera = GetCamera(drone);
                if (camera == null)
                    return;

                station.StopControl(basePlayer);
                StartControlling(basePlayer, station, camera);
                return;
            }

            camera = controlledEntity as CCTV_RC;
            if (camera != null)
            {
                drone = GetParentMegaDrone(camera);
                if (drone == null)
                    return;

                station.StopControl(basePlayer);
                StartControlling(basePlayer, station, drone);
                return;
            }
        }

        // Redirect damage from the computer station to the drone.
        private object OnEntityTakeDamage(ComputerStation station, HitInfo hitInfo)
        {
            return HandleOnEntityTakeDamage(station, hitInfo);
        }

        // Redirect damage from the camera to the drone.
        private object OnEntityTakeDamage(CCTV_RC camera, HitInfo hitInfo)
        {
            return HandleOnEntityTakeDamage(camera, hitInfo);
        }

        // Not a hook, just a helper.
        private object HandleOnEntityTakeDamage(BaseEntity entity, HitInfo hitInfo)
        {
            var drone = GetParentMegaDrone(entity);
            if (drone == null)
                return null;

            drone.Hurt(hitInfo);
            HitNotify(drone, hitInfo);

            // Return true (standard) to cancel default behavior (to prevent damage).
            return True;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private object canRemove(BasePlayer player, Drone drone)
        {
            return IsMegaDrone(drone) ? False : null;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private object canRemove(BasePlayer player, ComputerStation station)
        {
            return HandleCanRemove(station);
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        private object canRemove(BasePlayer player, CCTV_RC camera)
        {
            return HandleCanRemove(camera);
        }

        // Not a hook, just a helper.
        private object HandleCanRemove(BaseEntity entity)
        {
            return GetParentMegaDrone(entity) != null ? False : null;
        }

        private void OnEntityKill(Drone drone)
        {
            string userIdString;
            if (!IsMegaDrone(drone, out userIdString))
                return;

            _megaDroneTracker.Remove(drone.net.ID);

            if (userIdString != null)
            {
                var player = BasePlayer.Find(userIdString);
                if (player != null)
                {
                    ChatMessage(player, Lang.InfoDroneDestroyed);
                }

                _data.UnregisterPlayerDrone(userIdString);
                return;
            }

            _data.UnregisterOtherDrone(drone);
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone)
        {
            if (!IsMegaDrone(drone))
                return;

            _droneControllerTracker.Add(player.userID);
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, CCTV_RC camera)
        {
            var drone = GetParentMegaDrone(camera);
            if (drone == null)
                return;

            if (!RCUtils.CanControl(player, drone))
                return;

            RCUtils.AddViewer(drone, player);
            CameraMovement.AddToPlayer(player, drone);
            Interface.CallHook("OnBookmarkControlStarted", station, player, drone.GetIdentifier(), drone);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, Drone drone)
        {
            if (drone == null || !IsMegaDrone(drone))
                return;

            _droneControllerTracker.Remove(player.userID);
        }

        private void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, CCTV_RC camera)
        {
            if (camera == null)
                return;

            var drone = GetParentMegaDrone(camera);
            if (drone == null)
                return;

            if (!RCUtils.HasController(drone, player))
                return;

            RCUtils.RemoveController(drone);
            CameraMovement.RemoveFromPlayer(player);
            Interface.CallHook("OnBookmarkControlEnded", station, player, drone);
        }

        private void OnEntityMounted(ComputerStation station, BasePlayer player)
        {
            var drone = GetParentMegaDrone(station);
            if (drone == null)
                return;

            StartControlling(player, station, drone);
        }

        private void OnEntityDismounted(ComputerStation station, BasePlayer player)
        {
            var drone = GetParentMegaDrone(station);
            if (drone == null)
                return;

            _droneMounteeTracker.Remove(player.userID);

            if (_config.DestroyOnDisconnect
                // Can skip if the owner dismounted since the disconnect hook will handle that case.
                && player.userID != drone.OwnerID
                // Make sure it's the player's personal drone, not one given by givemegadrone or via API.
                && IsPlayerMegaDrone(drone))
            {
                var ownerPlayer = BasePlayer.FindByID(drone.OwnerID);
                if (ownerPlayer == null || !ownerPlayer.IsConnected)
                {
                    drone.Kill();
                }
            }
        }

        private void OnPlayerDismountFailed(BasePlayer player, ComputerStation station)
        {
            if (station == null)
                return;

            BaseEntity rootEntity;
            var drone = GetParentMegaDrone(station, out rootEntity);
            if (drone == null)
                return;

            var rootTransform = rootEntity.transform;
            if (Vector3.Dot(Vector3.up, rootTransform.up) > 0.1f)
                return;

            // Player failed to dismount, and drone is at a bad angle, flip it upright.
            rootTransform.rotation = Quaternion.Euler(0, rootTransform.rotation.eulerAngles.y, 0);
        }

        private object OnCCTVDirectionChange(CCTV_RC camera)
        {
            return GetParentMegaDrone(camera) != null ? False : null;
        }

        // This hook is exposed by plugin: Vehicle Deployed Locks (VehicleDeployedLocks).
        private void OnVehicleLockDeployed(ComputerStation computerStation, BaseLock baseLock)
        {
            BaseEntity rootEntity;
            var drone = GetParentMegaDrone(computerStation, out rootEntity);
            if (drone == null)
                return;

            // Reference the lock from the other entities to make things easier for other plugins.
            rootEntity.SetSlot(BaseEntity.Slot.Lock, baseLock);
            drone.SetSlot(BaseEntity.Slot.Lock, baseLock);
        }

        // This hook is exposed by plugin: Drone Settings (DroneSettings).
        private string OnDroneTypeDetermine(Drone drone)
        {
            return IsMegaDrone(drone) ? Name : null;
        }

        // This hook is exposed by plugin: Movable CCTV (MovableCCTV)
        private object OnCCTVMovableBecome(CCTV_RC camera)
        {
            return GetParentMegaDrone(camera) != null ? False : null;
        }

        // This hook is exposed by plugin: Limited Drone Range (LimitedDroneRange).
        private object OnDroneRangeLimit(Drone drone)
        {
            return IsMegaDrone(drone) ? False : null;
        }

        #endregion

        #region API

        [HookMethod(nameof(API_SpawnMegaDrone))]
        public Drone API_SpawnMegaDrone(BasePlayer player)
        {
            if (SpawnMegaDroneWasBlocked(player))
                return null;

            return SpawnMegaDrone(player, shouldTrack: false);
        }

        #endregion

        #region Commands

        [Command(CommandName_MegaDrone)]
        private void CommandMegaDrone(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer)
                return;

            // Key binds automatically pass the "True" argument.
            if (args.Length == 0 || args[0] == "True")
            {
                SubCommand_Spawn(player, cmd);
                return;
            }

            switch (DetermineSubCommand(args[0].ToLower()))
            {
                case SubCommandName_Help:
                    SubCommand_Help(player, cmd);
                    return;

                case SubCommandName_Fetch:
                    SubCommand_Fetch(player);
                    return;

                case SubCommandName_Destroy:
                    SubCommand_Destroy(player);
                    return;

                default:
                    ReplyToPlayer(player, Lang.ErrorUnknownCommand, cmd + " " + String.Join(" ", args));
                    return;
            }
        }

        private void SubCommand_Help(IPlayer player, string cmd)
        {
            var canSpawn = player.HasPermission(PermissionSpawn);
            var canFetch = player.HasPermission(PermissionFetch);
            var canDestroy = player.HasPermission(PermissionDestroy);

            if (!canSpawn && !canFetch && !canDestroy)
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine(GetMessage(player, Lang.Help));

            if (canSpawn)
            {
                var spawnSecondsRemaining = GetRemainingCooldownSeconds(player.Id, CooldownType.Spawn);
                var cooldownMessage = spawnSecondsRemaining > 0
                    ? GetMessage(player, Lang.HelpRemainingCooldown, FormatTime(spawnSecondsRemaining))
                    : string.Empty;

                sb.AppendLine(GetMessage(player, Lang.HelpSpawn, cmd, cooldownMessage));
            }

            if (canFetch)
            {
                var fetchSecondsRemaining = GetRemainingCooldownSeconds(player.Id, CooldownType.Fetch);
                var cooldownMessage = fetchSecondsRemaining > 0
                    ? GetMessage(player, Lang.HelpRemainingCooldown, FormatTime(fetchSecondsRemaining))
                    : string.Empty;

                sb.AppendLine(GetMessage(player, Lang.HelpFetch, cmd, cooldownMessage));
            }

            if (canDestroy)
            {
                sb.AppendLine(GetMessage(player, Lang.HelpDestroy, cmd));
            }

            player.Reply(sb.ToString());
        }

        private void SubCommand_Spawn(IPlayer player, string cmd)
        {
            if (!VerifyPermission(player, PermissionSpawn))
                return;

            var basePlayer = player.Object as BasePlayer;
            Vector3 spawnPosition;
            Quaternion spawnRotation;

            if (!VerifyCanInteract(player)
                || !VerifyNotMounted(player))
                return;

            var drone = FindPlayerDrone(player.Id);
            if (drone != null)
            {
                var hasFetchPermission = permission.UserHasPermission(player.Id, PermissionFetch);

                if (_config.AutoFetch && hasFetchPermission)
                {
                    FetchInternal(player, drone);
                }
                else
                {
                    var messages = new List<string> { GetMessage(player, Lang.SpawnErrorDroneAlreadyExists) };
                    if (hasFetchPermission)
                    {
                        messages.Add(GetMessage(player, Lang.SpawnErrorDroneAlreadyExistsHelp, cmd));
                    }

                    player.Reply(string.Join(" ", messages));
                }

                return;
            }

            if (!VerifyOffCooldown(player, CooldownType.Spawn)
                || !_config.CanSpawnBuildingBlocked && !VerifyCanBuild(player)
                || !VerifySufficientSpace(player, out spawnPosition, out spawnRotation)
                || SpawnMegaDroneWasBlocked(basePlayer))
                return;

            drone = SpawnMegaDrone(basePlayer);
            if (drone != null)
            {
                ReplyToPlayer(player, Lang.SpawnSuccess);

                if (_config.AutoMount)
                {
                    TryMountPlayer(drone, basePlayer);
                }
            }
        }

        private void FetchInternal(IPlayer player, Drone drone)
        {
            var basePlayer = player.Object as BasePlayer;
            Vector3 fetchPosition;
            Quaternion fetchRotation;

            if (!VerifyOffCooldown(player, CooldownType.Fetch)
                || !_config.CanFetchOccupied && !VerifyDroneNotOccupied(player, drone)
                || !_config.CanFetchBuildingBlocked && !VerifyCanBuild(player)
                || !VerifySufficientSpace(player, out fetchPosition, out fetchRotation)
                || FetchMegaDroneWasBlocked(basePlayer, drone))
                return;

            if (_config.DismountPlayersOnFetch)
            {
                DismountAllPlayersFromDrone(drone);
            }

            var rootEntity = GetRootEntity(drone);

            // The root entity rotation may not match the drone rotation.
            fetchRotation *= Quaternion.Inverse(drone.transform.localRotation);

            rootEntity.transform.SetPositionAndRotation(fetchPosition, fetchRotation);
            rootEntity.UpdateNetworkGroup();
            rootEntity.SendNetworkUpdateImmediate();

            StartCooldown(player.Id, CooldownType.Fetch);
            ReplyToPlayer(player, Lang.SpawnSuccess);

            if (_config.AutoMount)
            {
                TryMountPlayer(drone, basePlayer);
            }
        }

        private void SubCommand_Fetch(IPlayer player)
        {
            if (!VerifyPermission(player, PermissionFetch))
                return;

            Drone drone;

            if (!VerifyCanInteract(player)
                || !VerifyNotMounted(player)
                || !VerifyHasDrone(player, out drone))
                return;

            FetchInternal(player, drone);
        }

        private void SubCommand_Destroy(IPlayer player)
        {
            if (!VerifyPermission(player, PermissionDestroy))
                return;

            var basePlayer = player.Object as BasePlayer;
            Drone drone;

            if (!VerifyHasDrone(player, out drone)
                || !_config.CanDestroyWhileOccupied && !VerifyDroneNotOccupied(player, drone)
                || DestroyMegaDroneWasBlocked(basePlayer, drone))
                return;

            drone.Kill();
        }

        [Command(CommandName_GiveMegaDrone)]
        private void CommandGiveMegaDrone(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer && !player.HasPermission(PermissionGive))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            BasePlayer targetPlayer;

            if (args.Length > 0)
            {
                var playerNameOrIdArg = args[0];

                targetPlayer = BasePlayer.Find(playerNameOrIdArg);
                if (targetPlayer == null)
                {
                    ReplyToPlayer(player, Lang.GiveErrorPlayerNotFound, playerNameOrIdArg);
                    return;
                }
            }
            else if (player.IsServer)
            {
                ReplyToPlayer(player, Lang.GiveErrorSyntax, cmd);
                return;
            }
            else
            {
                targetPlayer = player.Object as BasePlayer;
            }

            var drone = SpawnMegaDrone(targetPlayer, shouldTrack: false);
            if (drone != null)
            {
                ReplyToPlayer(player, Lang.GiveSuccess, targetPlayer.displayName);
            }
        }

        #endregion

        #region Utilities

        private static class RCUtils
        {
            public static bool HasController(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.ControllingViewerId?.SteamId == player.userID;
            }

            public static bool HasRealController(IRemoteControllable controllable)
            {
                return controllable.ControllingViewerId.GetValueOrDefault().SteamId != 0;
            }

            public static bool CanControl(BasePlayer player, IRemoteControllable controllable)
            {
                return !HasRealController(controllable) || HasController(controllable, player);
            }

            public static void RemoveController(IRemoteControllable controllable)
            {
                var controllerId = controllable.ControllingViewerId;
                if (controllerId.HasValue)
                {
                    controllable.StopControl(controllerId.Value);
                }
            }

            public static bool AddViewer(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.InitializeControl(new CameraViewerId(player.userID, 0));
            }
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermission(IPlayer player, string perm)
        {
            if (permission.UserHasPermission(player.Id, perm))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoPermission);
            return false;
        }

        private bool VerifyHasNoDrone(IPlayer player, string cmd)
        {
            if (FindPlayerDrone(player.Id) == null)
                return true;

            var messages = new List<string> { GetMessage(player, Lang.SpawnErrorDroneAlreadyExists) };
            if (permission.UserHasPermission(player.Id, PermissionFetch))
            {
                messages.Add(GetMessage(player, Lang.SpawnErrorDroneAlreadyExistsHelp, cmd));
            }

            player.Reply(string.Join(" ", messages));
            return false;
        }

        private bool VerifyHasDrone(IPlayer player, out Drone drone)
        {
            drone = FindPlayerDrone(player.Id);
            if (drone != null)
                return true;

            ReplyToPlayer(player, Lang.ErrorDroneNotFound);
            return false;
        }

        private bool VerifyCanBuild(IPlayer player)
        {
            if ((player.Object as BasePlayer).CanBuild())
                return true;

            ReplyToPlayer(player, Lang.ErrorBuildingBlocked);
            return false;
        }

        private bool VerifyDroneNotOccupied(IPlayer player, Drone drone)
        {
            if (GetMountedPlayer(drone) == null && !HasChildPlayer(drone))
                return true;

            ReplyToPlayer(player, Lang.ErrorDroneOccupied);
            return false;
        }

        private bool VerifyOffCooldown(IPlayer player, CooldownType cooldownType)
        {
            var secondsRemaining = GetRemainingCooldownSeconds(player.Id, cooldownType);
            if (secondsRemaining <= 0)
                return true;

            ReplyToPlayer(player, Lang.ErrorCooldown, FormatTime(secondsRemaining));
            return false;
        }

        private bool VerifySufficientSpace(IPlayer player, out Vector3 determinedPosition, out Quaternion determinedRotation)
        {
            var basePlayer = player.Object as BasePlayer;
            determinedPosition = GetPlayerRelativeSpawnPosition(basePlayer);
            determinedRotation = GetPlayerRelativeSpawnRotation(basePlayer);

            if (!Physics.CheckBox(determinedPosition, DroneExtents, determinedRotation, BoxcastLayers, QueryTriggerInteraction.Ignore))
                return true;

            ReplyToPlayer(player, Lang.ErrorInsufficientSpace);
            return false;
        }

        private bool VerifyCanInteract(IPlayer player)
        {
            if ((player.Object as BasePlayer).CanInteract())
                return true;

            ReplyToPlayer(player, Lang.ErrorGenericRestricted);
            return false;
        }

        private bool VerifyNotMounted(IPlayer player)
        {
            if ((player.Object as BasePlayer).isMounted)
            {
                ReplyToPlayer(player, Lang.ErrorMounted);
                return false;
            }

            return true;
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Mega Drones] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Mega Drones] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Mega Drones] {message}");

        private bool VerifyDependencies()
        {
            if (DroneScaleManager == null)
            {
                LogError("DroneScaleManager is not loaded, get it at https://umod.org");
                return false;
            }

            if (EntityScaleManager == null)
            {
                LogError("EntityScaleManager is not loaded, get it at https://umod.org");
                return false;
            }

            return true;
        }

        private void RegisterWithVehicleDeployedLocks()
        {
            if (VehicleDeployedLocks == null)
                return;

            // Locks will be attached to the computer station.
            // A reference to the lock is also added to the root entity after it's deployed.
            Func<BaseEntity, BaseEntity> determineLockParent = (entity) =>
            {
                var computerStation = entity as ComputerStation;
                if (computerStation != null && GetParentMegaDrone(computerStation) != null)
                    return computerStation;

                var drone = entity as Drone;
                if (drone != null)
                    return GetComputerStation(drone);

                // Returning null indicates that this is not a mega drone.
                return null;
            };

            VehicleDeployedLocks.Call("API_RegisterCustomVehicleType", "megadrone", LockPosition, LockRotation, null, determineLockParent);
        }

        private static bool SpawnMegaDroneWasBlocked(BasePlayer player)
        {
            var hookResult = Interface.CallHook("OnMegaDroneSpawn", player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool FetchMegaDroneWasBlocked(BasePlayer player, Drone drone)
        {
            var hookResult = Interface.CallHook("OnMegaDroneFetch", player, drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool DestroyMegaDroneWasBlocked(BasePlayer player, Drone drone)
        {
            var hookResult = Interface.CallHook("OnMegaDroneDestroy", player, drone);
            return hookResult is bool && (bool)hookResult == false;
        }

        private BaseEntity GetRootEntity(Drone drone)
        {
            return DroneScaleManager?.Call("API_GetRootEntity", drone) as BaseEntity;
        }

        private static string GetCooldownPermission(string permissionSuffix)
        {
            return $"{PermissionCooldownPrefix}.{permissionSuffix}";
        }

        public bool IsMegaDrone(Drone drone)
        {
            return _data.IsMegaDrone(drone);
        }

        public bool IsMegaDrone(Drone drone, out string userIdString)
        {
            return _data.IsMegaDrone(drone, out userIdString);
        }

        public bool IsPlayerMegaDrone(Drone drone)
        {
            string userIdString;
            return _data.IsMegaDrone(drone, out userIdString) && userIdString != null;
        }

        private Drone GetParentMegaDrone(BaseEntity entity, out BaseEntity rootEntity)
        {
            rootEntity = entity.GetParentEntity();
            if (rootEntity == null)
                return null;

            var drone = DroneScaleManager?.Call("API_GetParentDrone", entity) as Drone;
            if (drone == null || !IsMegaDrone(drone))
                return null;

            return drone;
        }

        private Drone GetParentMegaDrone(BaseEntity entity)
        {
            BaseEntity rootEntity;
            return GetParentMegaDrone(entity, out rootEntity);
        }

        private bool ParentEntityToDrone(Drone drone, BaseEntity entity)
        {
            var result = DroneScaleManager?.Call("API_ParentEntity", drone, entity);
            return result is bool && (bool)result;
        }

        private static T GetChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }

            return null;
        }

        private ComputerStation GetComputerStation(Drone drone)
        {
            var rootEntity = GetRootEntity(drone);
            if (rootEntity == null)
                return null;

            return GetChildOfType<ComputerStation>(rootEntity);
        }

        private CCTV_RC GetCamera(Drone drone)
        {
            var rootEntity = GetRootEntity(drone);
            if (rootEntity == null)
                return null;

            return GetChildOfType<CCTV_RC>(rootEntity);
        }

        private static void StartControlling(BasePlayer player, ComputerStation station, IRemoteControllable controllable)
        {
            var entity = controllable.GetEnt();
            if (entity == null)
                return;

            station.currentlyControllingEnt.uid = entity.net.ID;
            station.currentPlayerID = player.userID;
            var isControlling = RCUtils.AddViewer(controllable, player);
            station.SetFlag(ComputerStation.Flag_HasFullControl, isControlling, networkupdate: false);
            station.SendNetworkUpdateImmediate();
            station.InvokeRepeating(station.ControlCheck, 0, 0);
            Interface.CallHook("OnBookmarkControlStarted", station, player, controllable.GetIdentifier(), entity);
        }

        private bool TryMountPlayer(Drone drone, BasePlayer player)
        {
            var station = GetComputerStation(drone);
            if (station == null)
                return false;

            station.AttemptMount(player, doMountChecks: false);
            return true;
        }

        private static bool IsDroneEligible(Drone drone)
        {
            return !(drone is DeliveryDrone);
        }

        private static void HitNotify(BaseEntity entity, HitInfo info)
        {
            var player = info.Initiator as BasePlayer;
            if (player == null)
                return;

            entity.ClientRPCPlayer(null, player, "HitNotify");
        }

        private static void SetupComputerStation(Drone drone, ComputerStation station)
        {
            // Damage will be processed by the drone.
            station.baseProtection = null;

            RemoveGroundWatch(station);
            station.pickup.enabled = false;
            station.OwnerID = drone.OwnerID;
            station.isMobile = true;

            if (station.IsFullySpawned() && !BaseMountable.AllMountables.Contains(station))
            {
                BaseMountable.AllMountables.Add(station);
            }

            foreach (var collider in station.GetComponents<BoxCollider>())
            {
                // Removing the box collider helps with mounting and dismounting at an angle
                UnityEngine.Object.Destroy(collider);
            }
        }

        private ComputerStation DeployComputerStation(Drone drone, BasePlayer player)
        {
            var station = GameManager.server.CreateEntity(ComputerStationPrefab, ComputerStationLocalPosition, ComputerStationLocalRotation) as ComputerStation;
            if (station == null)
                return null;

            SetupComputerStation(drone, station);

            if (!ParentEntityToDrone(drone, station))
            {
                station.Spawn();
                station.Kill();
                return null;
            }

            drone.SetSlot(MegaDroneSlot, station);

            Effect.server.Run(ComputerStationDeployEffectPrefab, station.transform.position, station.transform.up);
            RunOnEntityBuilt(player, station, ComputerStationItemId);

            return station;
        }

        private static void SetupCamera(Drone drone, CCTV_RC camera)
        {
            // Damage will be processed by the drone.
            camera.baseProtection = null;

            RemoveGroundWatch(camera);
            camera.pickup.enabled = false;
            camera.OwnerID = drone.OwnerID;
            camera.UpdateFromInput(5, 0);
        }

        private CCTV_RC DeployCamera(Drone drone, BasePlayer player, int idNumber)
        {
            var camera = GameManager.server.CreateEntity(CCTVPrefab, CameraLocalPosition, CameraLocalRotation) as CCTV_RC;
            if (camera == null)
                return null;

            camera.UpdateIdentifier($"{_config.CamIdentifierPrefix}{idNumber}");
            SetupCamera(drone, camera);

            if (!ParentEntityToDrone(drone, camera))
            {
                camera.Spawn();
                camera.Kill();
                return null;
            }

            Effect.server.Run(CCTVDeployEffectPrefab, camera.transform.position, camera.transform.up);
            RunOnEntityBuilt(player, camera, CCTVItemId);

            return camera;
        }

        private static Quaternion GetPlayerWorldRotation(BasePlayer player)
        {
            var rotation = player.GetNetworkRotation();
            var parent = player.GetParentEntity();

            if (parent != null)
            {
                rotation *= parent.transform.rotation;
            }

            return rotation;
        }

        private static Vector3 GetPlayerForwardPosition(BasePlayer player)
        {
            Vector3 forward = GetPlayerWorldRotation(player) * Vector3.forward;
            forward.y = 0;
            return forward.normalized;
        }

        // Directly in front of the player.
        private static Vector3 GetPlayerRelativeSpawnPosition(BasePlayer player)
        {
            Vector3 forward = GetPlayerForwardPosition(player);
            Vector3 position = player.transform.position + forward * 3.5f;
            position.y = player.transform.position.y + 1f;
            return position;
        }

        private static Quaternion GetPlayerRelativeSpawnRotation(BasePlayer player)
        {
            var rotation = player.GetNetworkRotation();
            var parent = player.GetParentEntity();
            if (parent != null)
            {
                rotation *= parent.transform.rotation;
            }

            return Quaternion.Euler(0, rotation.eulerAngles.y, 0);
        }

        private void SetupDrone(Drone drone)
        {
            drone.pickup.enabled = false;
            _megaDroneTracker.Add(drone.net.ID);
        }

        private static int SetRandomIdentifier(IRemoteControllable controllable, string prefix)
        {
            var idNumber = UnityEngine.Random.Range(1, 9999);
            controllable.UpdateIdentifier($"{prefix}{idNumber}");
            return idNumber;
        }

        private static void RegisterIdentifier(ComputerStation station, IRemoteControllable controllable)
        {
            var identifier = controllable.GetIdentifier();
            if (string.IsNullOrEmpty(identifier))
                return;

            var entity = controllable.GetEnt();
            if (entity == null)
                return;

            if (!station.controlBookmarks.Contains(identifier))
            {
                station.controlBookmarks.Add(identifier);
            }
        }

        private Drone SpawnMegaDrone(BasePlayer player, bool shouldTrack = true)
        {
            if (!VerifyDependencies())
                return null;

            var drone = GameManager.server.CreateEntity(DronePrefab, GetPlayerRelativeSpawnPosition(player), GetPlayerRelativeSpawnRotation(player)) as Drone;
            if (drone == null)
                return null;

            drone.OwnerID = player.userID;
            var idNumber = SetRandomIdentifier(drone, _config.DroneIdentifierPrefix);
            drone.Spawn();
            SetupDrone(drone);

            DroneScaleManager.Call("API_ScaleDrone", drone, MegaDroneScale);
            RunOnEntityBuilt(player, drone, DroneItemId);

            var computerStation = DeployComputerStation(drone, player);
            var camera = DeployCamera(drone, player, idNumber);

            if (computerStation != null)
            {
                RegisterIdentifier(computerStation, drone);

                if (camera != null)
                {
                    RegisterIdentifier(computerStation, camera);
                }
            }

            if (shouldTrack)
            {
                _data.RegisterPlayerDrone(player.UserIDString, drone);
                StartCooldown(player.UserIDString, CooldownType.Spawn);
            }
            else
            {
                _data.RegisterOtherDrone(drone);
            }

            Interface.CallHook("OnMegaDroneSpawned", drone, player);
            return drone;
        }

        private static void RemoveGroundWatch(BaseEntity entity)
        {
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static void RunOnEntityBuilt(Item item, BaseEntity entity)
        {
            Interface.CallHook("OnEntityBuilt", item.GetHeldEntity(), entity.gameObject);
        }

        private static void RunOnEntityBuilt(BasePlayer basePlayer, BaseEntity entity, int itemid)
        {
            // Allow other plugins to detect the entity being deployed.
            var turretItem = basePlayer.inventory.FindItemByItemID(itemid);
            if (turretItem != null)
            {
                RunOnEntityBuilt(turretItem, entity);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                basePlayer.inventory.containerMain.capacity++;
                var temporaryItem = ItemManager.CreateByItemID(itemid);
                if (basePlayer.inventory.GiveItem(temporaryItem))
                {
                    RunOnEntityBuilt(temporaryItem, entity);
                    temporaryItem.RemoveFromContainer();
                }

                temporaryItem.Remove();
                basePlayer.inventory.containerMain.capacity--;
            }
        }

        private static string FormatTime(double seconds)
        {
            return TimeSpan.FromSeconds(seconds).ToString("g");
        }

        private void DismountAllPlayersFromDrone(Drone drone)
        {
            var rootEntity = GetRootEntity(drone);
            var station = GetComputerStation(drone);

            if (station.AnyMounted())
            {
                station.DismountAllPlayers();
            }

            if (rootEntity != null)
            {
                foreach (var child in rootEntity.children.ToList())
                {
                    var childPlayer = child as BasePlayer;
                    if (childPlayer != null)
                    {
                        childPlayer.SetParent(null, worldPositionStays: true);
                    }
                }
            }
        }

        private Drone FindPlayerDrone(string userId)
        {
            ulong droneId;
            if (!_data.PlayerDrones.TryGetValue(userId, out droneId))
                return null;

            var drone = BaseNetworkable.serverEntities.Find(new NetworkableId(droneId)) as Drone;
            if (drone == null)
            {
                _data.UnregisterPlayerDrone(userId);
            }

            return drone;
        }

        private BasePlayer GetMountedPlayer(Drone drone)
        {
            var station = GetComputerStation(drone);
            if (station == null)
                return null;

            return station.GetMounted();
        }

        private bool HasChildPlayer(Drone drone)
        {
            var rootEntity = GetRootEntity(drone);
            if (rootEntity == null)
                return false;

            foreach (var child in rootEntity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private void RefreshMegaDrone(Drone drone)
        {
            SetupDrone(drone);

            var rootEntity = GetRootEntity(drone);
            if (rootEntity == null)
                return;

            foreach (var child in rootEntity.children)
            {
                var station = child as ComputerStation;
                if (station != null)
                {
                    SetupComputerStation(drone, station);
                    continue;
                }

                var camera  = child as CCTV_RC;
                if (camera != null)
                {
                    SetupCamera(drone, camera);
                    continue;
                }
            }
        }

        private void RefreshAllMegaDrones()
        {
            var megaDroneIds = _data.GetAllMegaDroneIds();

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var drone = entity as Drone;
                if (drone == null || !IsDroneEligible(drone))
                    continue;

                if (!megaDroneIds.Contains(drone.net.ID.Value))
                    continue;

                RefreshMegaDrone(drone);
            }
        }

        private string DetermineSubCommand(string argLower)
        {
            foreach (var entry in _config.SubcommandAliases)
            {
                var commandLower = entry.Key.ToLowerInvariant();
                if (commandLower == argLower || entry.Value.Contains(argLower))
                    return commandLower;
            }

            return argLower;
        }

        private long GetRemainingCooldownSeconds(string userId, CooldownType cooldownType)
        {
            long cooldownStart;
            if (!_data.Cooldowns.GetCooldownMap(cooldownType).TryGetValue(userId, out cooldownStart))
                return 0;

            var cooldownSeconds = _config.GetCooldownConfigForPlayer(this, userId).GetSeconds(cooldownType);
            return cooldownStart + cooldownSeconds - DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        }

        private void StartCooldown(string userId, CooldownType cooldownType)
        {
            if (_config.GetCooldownConfigForPlayer(this, userId).GetSeconds(cooldownType) <= 0)
                return;

            _data.Cooldowns.GetCooldownMap(cooldownType)[userId] = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        }

        #endregion

        #region Dynamic Hooks

        private class HookCollection
        {
            public bool IsSubscribed { get; private set; } = true;
            private readonly MegaDrones _plugin;
            private readonly string[] _hookNames;
            private readonly Func<bool> _shouldSubscribe;

            public HookCollection(MegaDrones plugin, Func<bool> shouldSubscribe, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
                _shouldSubscribe = shouldSubscribe;
            }

            public void Subscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }

                IsSubscribed = true;
            }

            public void Unsubscribe()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }

                IsSubscribed = false;
            }

            public void Refresh()
            {
                if (_shouldSubscribe())
                {
                    if (!IsSubscribed)
                    {
                        Subscribe();
                    }
                }
                else if (IsSubscribed)
                {
                    Unsubscribe();
                }
            }
        }

        private class DynamicHookHashSet<T> : HashSet<T>
        {
            private readonly HookCollection _hookCollection;

            public DynamicHookHashSet(MegaDrones plugin, params string[] hookNames)
            {
                _hookCollection = new HookCollection(plugin, () => Count > 0, hookNames);
            }

            public new bool Add(T item)
            {
                var result = base.Add(item);
                if (result)
                {
                    _hookCollection.Refresh();
                }
                return result;
            }

            public new bool Remove(T item)
            {
                var result = base.Remove(item);
                if (result)
                {
                    _hookCollection.Refresh();
                }
                return result;
            }

            public void Unsubscribe() => _hookCollection.Unsubscribe();
        }

        #endregion

        #region Camera Movement

        private class CameraMovement : EntityComponent<BasePlayer>
        {
            public static CameraMovement AddToPlayer(BasePlayer player, Drone drone)
            {
                return player.GetOrAddComponent<CameraMovement>().SetDrone(drone);
            }

            public static void RemoveFromPlayer(BasePlayer player)
            {
                DestroyImmediate(player.GetComponent<CameraMovement>());
            }

            private Drone _drone;

            private CameraMovement SetDrone(Drone drone)
            {
                _drone = drone;
                _drone.InitializeControl(new CameraViewerId(baseEntity.userID, 0));
                return this;
            }

            private void Update()
            {
                if (_drone == null)
                    return;

                // Optimization: Skip if there was no user input this frame.
                if (baseEntity.lastTickTime < Time.time)
                    return;

                _drone.UserInput(baseEntity.serverInput, new CameraViewerId(baseEntity.userID, 0));
            }
        }

        #endregion

        #region Data

        private class StoredData
        {
            [JsonProperty("PlayerDrones")]
            public Dictionary<string, ulong> PlayerDrones = new Dictionary<string, ulong>();

            [JsonProperty("OtherDrones")]
            public HashSet<ulong> OtherDrones = new HashSet<ulong>();

            [JsonProperty("Cooldowns")]
            public CooldownManager Cooldowns = new CooldownManager();

            public static StoredData Load()
            {
                return Interface.Oxide.DataFileSystem.ReadObject<StoredData>(nameof(MegaDrones)) ?? new StoredData();
            }

            public static StoredData Reset() => new StoredData().Save();

            public StoredData Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(nameof(MegaDrones), this);
                return this;
            }

            public HashSet<ulong> GetAllMegaDroneIds()
            {
                var droneIds = new HashSet<ulong>(PlayerDrones.Values);
                droneIds.UnionWith(OtherDrones);
                return droneIds;
            }

            public bool IsMegaDrone(Drone drone, out string userIdString)
            {
                var droneId = drone.net.ID.Value;

                foreach (var entry in PlayerDrones)
                {
                    if (entry.Value == droneId)
                    {
                        userIdString = entry.Key;
                        return true;
                    }
                }

                userIdString = null;
                return OtherDrones.Contains(droneId);
            }

            public bool IsMegaDrone(Drone drone)
            {
                string userIdString;
                return IsMegaDrone(drone, out userIdString);
            }

            public void RegisterPlayerDrone(string userId, Drone drone)
            {
                PlayerDrones[userId] = drone.net.ID.Value;
            }

            public void UnregisterPlayerDrone(string userId)
            {
                PlayerDrones.Remove(userId);
            }

            public void RegisterOtherDrone(Drone drone)
            {
                OtherDrones.Add(drone.net.ID.Value);
            }

            public void UnregisterOtherDrone(Drone drone)
            {
                OtherDrones.Remove(drone.net.ID.Value);
            }
        }

        private enum CooldownType { Spawn, Fetch }

        private class CooldownManager
        {
            [JsonProperty("Spawn")]
            private Dictionary<string, long> Spawn = new Dictionary<string, long>();

            [JsonProperty("Fetch")]
            private Dictionary<string, long> Fetch = new Dictionary<string, long>();

            public Dictionary<string, long> GetCooldownMap(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return Spawn;
                    case CooldownType.Fetch:
                        return Fetch;
                    default:
                        LogWarning($"Cooldown not implemented for {cooldownType}");
                        return null;
                }
            }

            public void ClearAll()
            {
                Spawn.Clear();
                Fetch.Clear();
            }
        }

        #endregion

        #region Configuration

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("AutoMount")]
            public bool AutoMount = true;

            [JsonProperty("AutoFetch")]
            public bool AutoFetch = false;

            [JsonProperty("DroneIdentifierPrefix")]
            public string DroneIdentifierPrefix = "MD";

            [JsonProperty("CamIdentifierPrefix")]
            public string CamIdentifierPrefix = "MDCam";

            [JsonProperty("CanSpawnWhileBuildingBlocked")]
            public bool CanSpawnBuildingBlocked = false;

            [JsonProperty("CanFetchWhileBuildingBlocked")]
            public bool CanFetchBuildingBlocked = false;

            [JsonProperty("CanFetchWhileOccupied")]
            public bool CanFetchOccupied = false;

            [JsonProperty("CanDestroyWhileOccupied")]
            public bool CanDestroyWhileOccupied = false;

            [JsonProperty("DismountPlayersOnFetch")]
            public bool DismountPlayersOnFetch = true;

            [JsonProperty("DestroyOnDisconnect")]
            public bool DestroyOnDisconnect = false;

            [JsonProperty("DefaultCooldowns")]
            public CooldownConfig DefaultCooldowns = new CooldownConfig()
            {
                SpawnSeconds = 3600,
                FetchSeconds = 600,
            };

            [JsonProperty("CooldownsRequiringPermission")]
            public CooldownConfig[] CooldownsRequiringPermission =
            {
                new CooldownConfig
                {
                    PermissionSuffix = "long",
                    SpawnSeconds = 86400,
                    FetchSeconds = 3600,
                },
                new CooldownConfig
                {
                    PermissionSuffix = "medium",
                    SpawnSeconds = 3600,
                    FetchSeconds = 600,
                },
                new CooldownConfig
                {
                    PermissionSuffix = "short",
                    SpawnSeconds = 600,
                    FetchSeconds = 60,
                },
                new CooldownConfig
                {
                    PermissionSuffix = "none",
                    SpawnSeconds = 0,
                    FetchSeconds = 0,
                },
            };

            [JsonProperty("CommandAliases")]
            public Dictionary<string, string[]> CommandAliases = new Dictionary<string, string[]>()
            {
                [CommandName_MegaDrone] = new[] { "md" },
                [CommandName_GiveMegaDrone] = new[] { "givemd" },
            };

            [JsonProperty("SubcommandAliases")]
            public Dictionary<string, string[]> SubcommandAliases = new Dictionary<string, string[]>()
            {
                [SubCommandName_Help] = new[] { "h" },
                [SubCommandName_Fetch] = new[] { "f" },
                [SubCommandName_Destroy] = new[] { "d" },
            };

            public void Init(MegaDrones pluginInstance)
            {
                foreach (var cooldownConfig in CooldownsRequiringPermission)
                {
                    cooldownConfig.Init(pluginInstance);
                }
            }

            public CooldownConfig GetCooldownConfigForPlayer(MegaDrones plugin, string userId)
            {
                if (CooldownsRequiringPermission.Length == 0)
                    return DefaultCooldowns;

                for (var i = CooldownsRequiringPermission.Length - 1; i >= 0; i--)
                {
                    var config = CooldownsRequiringPermission[i];
                    if (config.Permission != null && plugin.permission.UserHasPermission(userId, config.Permission))
                        return config;
                }

                return DefaultCooldowns;
            }
        }

        private class CooldownConfig
        {
            [JsonProperty("PermissionSuffix", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string PermissionSuffix;

            [JsonProperty("SpawnSeconds")]
            public long SpawnSeconds;

            [JsonProperty("FetchSeconds")]
            public long FetchSeconds;

            [JsonIgnore]
            public string Permission;

            public void Init(MegaDrones plugin)
            {
                if (string.IsNullOrWhiteSpace(PermissionSuffix))
                    return;

                Permission = GetCooldownPermission(PermissionSuffix);
                plugin.permission.RegisterPermission(Permission, plugin);
            }

            public long GetSeconds(CooldownType cooldownType)
            {
                switch (cooldownType)
                {
                    case CooldownType.Spawn:
                        return SpawnSeconds;
                    case CooldownType.Fetch:
                        return FetchSeconds;
                    default:
                        LogWarning($"Cooldown not implemented for {cooldownType}");
                        return 0;
                }
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.UserIDString, messageName), args));

        private class Lang
        {
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorBuildingBlocked = "Error.BuildingBlocked";
            public const string ErrorDroneNotFound = "Error.DroneNotFound";
            public const string ErrorDroneOccupied = "Error.DroneOccupied";
            public const string ErrorCooldown = "Error.Cooldown";
            public const string ErrorGenericRestricted = "Error.GenericRestricted";
            public const string ErrorUnknownCommand = "Error.UnknownCommand";
            public const string ErrorMounted = "Error.Mounted";
            public const string ErrorInsufficientSpace = "Error.InsufficientSpace";

            public const string SpawnSuccess = "Spawn.Success";
            public const string SpawnErrorDroneAlreadyExists = "Spawn.Error.DroneAlreadyExists";
            public const string SpawnErrorDroneAlreadyExistsHelp = "Spawn.Error.DroneAlreadyExists.Help";

            public const string GiveErrorSyntax = "Give.Error.Syntax";
            public const string GiveErrorPlayerNotFound = "Give.Error.PlayerNotFound";
            public const string GiveSuccess = "Give.Success";

            public const string InfoDroneDestroyed = "Info.DroneDestroyed";

            public const string Help = "Help";
            public const string HelpSpawn = "Help.Spawn";
            public const string HelpFetch = "Help.Fetch";
            public const string HelpDestroy = "Help.Destroy";
            public const string HelpRemainingCooldown = "Help.RemainingCooldown";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.ErrorDroneNotFound] = "Error: You need a mega drone to do that.",
                [Lang.ErrorDroneOccupied] = "Error: Cannot do that while your mega drone is occupied.",
                [Lang.ErrorCooldown] = "Please wait <color=#f44>{0}</color> and try again.",
                [Lang.ErrorGenericRestricted] = "Error: You cannot do that right now.",
                [Lang.ErrorUnknownCommand] = "Error: Unrecognized command <color=#fb4>{0}</color>.",
                [Lang.ErrorMounted] = "Error: Cannot do that while mounted.",
                [Lang.ErrorInsufficientSpace] = "Error: Not enough space.",

                [Lang.SpawnSuccess] = "Here is your mega drone.",
                [Lang.SpawnErrorDroneAlreadyExists] = "Error: You already have a mega drone.",
                [Lang.SpawnErrorDroneAlreadyExistsHelp] = "Try <color=#fb4>{0} fetch</color> or <color=#fb4>{0} help</color>.",

                [Lang.GiveErrorSyntax] = "Syntax: {0} <player>",
                [Lang.GiveErrorPlayerNotFound] = "Error: Player '{0}' not found.",
                [Lang.GiveSuccess] = "Player '{0}' has been given a mega drone.",

                [Lang.InfoDroneDestroyed] = "Your mega drone was destroyed.",

                [Lang.Help] = "<color=#fb4>Mega Drone Commands</color>",
                [Lang.HelpSpawn] = "<color=#fb4>{0}</color> - Spawn a mega drone{1}",
                [Lang.HelpFetch] = "<color=#fb4>{0} f | fetch</color> - Fetch your mega drone{1}",
                [Lang.HelpDestroy] = "<color=#fb4>{0} d | destroy</color> - Destroy your mega drone",
                [Lang.HelpRemainingCooldown] = " - <color=#f44>{0}</color>",
            }, this, "en");
            //Added Brazilian Portuguese translation
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "Você não tem permissão para fazer isso.",
                [Lang.ErrorBuildingBlocked] = "Erro: Não é possível fazer isso enquanto o prédio está bloqueado.",
                [Lang.ErrorDroneNotFound] = "Erro: você precisa de um mega drone para fazer isso.",
                [Lang.ErrorDroneOccupied] = "Erro: Não é possível fazer isso enquanto o mega drone está ocupado.",
                [Lang.ErrorCooldown] = "Aguarde <color=#f44>{0}</color> e tente novamente.",
                [Lang.ErrorGenericRestricted] = "Erro: você não pode fazer isso agora.",
                [Lang.ErrorUnknownCommand] = "Erro: comando não reconhecido <color=#fb4>{0}</color>.",
                [Lang.ErrorMounted] = "Erro: não é possível fazer isso enquanto está montado.",
                [Lang.ErrorInsufficientSpace] = "Erro: espaço insuficiente.",

                [Lang.SpawnSuccess] = "Aqui está o seu mega drone.",
                [Lang.SpawnErrorDroneAlreadyExists] = "Erro: você já tem um mega drone.",
                [Lang.SpawnErrorDroneAlreadyExistsHelp] = "Experimente <color=#fb4>{0} fetch</color> ou <color=#fb4>{0} help</color>.",

                [Lang.GiveErrorSyntax] = "Syntax: {0} <player>",
                [Lang.GiveErrorPlayerNotFound] = "Erro: Player '{0}' não encontrado.",
                [Lang.GiveSuccess] = "O jogador '{0}' recebeu um mega drone.",

                [Lang.InfoDroneDestroyed] = "Seu mega drone foi destruído.",

                [Lang.Help] = "<color=#fb4>Comandos Mega Drone</color>",
                [Lang.HelpSpawn] = "<color=#fb4>{0}</color> - Gerar um mega drone{1}",
                [Lang.HelpFetch] = "<color=#fb4>{0} f | fetch</color> - Pegue seu mega drone{1}",
                [Lang.HelpDestroy] = "<color=#fb4>{0} d | destroy</color> - Destrua seu mega drone",
                [Lang.HelpRemainingCooldown] = " - <color=#f44>{0}</color>",
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: MegaDrones.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/medic-revive ---
// --- Original File Path: M/MedicRevive/MedicRevive.cs ---

﻿namespace Oxide.Plugins
{
    [Info("MedicRevive", "k1lly0u", "0.1.0", ResourceId = 0)]
    class MedicRevive : RustPlugin
    {
        void Loaded() => permission.RegisterPermission("medicrevive.use", this);
        void OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            if (tool.ShortPrefabName == "syringe_medical.entity")
            {
                var healingPlayer = tool.GetOwnerPlayer();
                if (healingPlayer != null)
                {
                    if (permission.UserHasPermission(healingPlayer.UserIDString, "medicrevive.use"))
                        player.StopWounded();
                }
            }
        }       
    }
}

// --- End of file: MedicRevive.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-sets ---
// --- Original File Path: M/MagicSets/MagicSets.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("Magic Sets", "Norn", "0.2.0")]
    [Description("Allows users to store and create custom gearsets with one command")]

    class MagicSets : RustPlugin
    {
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private const string PERMISSION_DEFAULT = "MagicSets.able";
        private const string PERMISSION_VIP = "MagicSets.vip";

        private List<SetInfo> Sets = new List<SetInfo>();

        class SetInfo
        {
            public int ID;
            public ulong OwnerID;
            public string Name;
            public bool Public;
            public int TimesUsed;
            public long LastUsed;
            public List<InternalItemInfo> Contents = new List<InternalItemInfo>();
            public SetInfo() { }
        }
        class InternalItemInfo
        {
            public string Shortname;
            public ulong SkinID;
            public InternalItemInfo() { }
        }

        void Init()
        {
            permission.RegisterPermission(PERMISSION_DEFAULT, this);
            permission.RegisterPermission(PERMISSION_VIP, this);
            LoadData();
        }

        void Unload() { SaveData(); }

        private long UnixTimestamp() => DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        private DateTime UnixToDateTime(long unixTime) { DateTime dt = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc); return dt.AddSeconds(unixTime).ToLocalTime(); }
        private long DateTimeToUnixTimestamp(DateTime dateTime) => (long)(TimeZoneInfo.ConvertTimeToUtc(dateTime) - new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc)).TotalSeconds;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoValue"] = "<color=#e5f441>USAGE:</color> /sets [Add | Remove | Create | Reskin | List | Public | Clear]",
                ["ClearSuccess"] = "<color=#e5f441>INFO:</color> You have <color=#41f45e>successfully</color> removed {0} sets.",
                ["NoSets"] = "<color=#e5f441>INFO:</color> You have <color=#f44141>no</color> sets.",
                ["SetAlreadyExists"] = "<color=#e5f441>INFO:</color> A set with the name <color=#f44141>{0}</color> already exists!",
                ["SetAdded"] = "<color=#e5f441>INFO:</color> You have <color=#41f45e>added</color> a new set! (<color=#e5f441>{0}</color>)\n<color=#e5f441>/sets create <color=#41f45e>{1}</color> to create it</color>",
                ["SetAddUsage"] = "<color=#e5f441>USAGE:</color> /sets add <color=#41f45e>name</color>",
                ["SetNotExist"] = "<color=#e5f441>INFO:</color> A set with the name <color=#f44141>{0}</color> does not exist.",
                ["SetNotExistID"] = "<color=#e5f441>INFO:</color> Set with the ID <color=#f44141>{0}</color> does not exist.",
                ["SetNotPublic"] = "<color=#e5f441>INFO:</color> Set with id <color=#f44141>{0}</color> is not public.",
                ["SetRemoved"] = "<color=#e5f441>INFO:</color> You have successfully removed the set <color=#f44141>{0}</color>.",
                ["SetPublicUpdated"] = "<color=#e5f441>INFO:</color> Set <color=#f44141>{0}</color> is now <color=#e5f441>Public:</color> {1}.",
                ["RemoveUsage"] = "<color=#e5f441>USAGE:</color> /sets remove <color=#41f45e>name</color>",
                ["ReskinUsage"] = "<color=#e5f441>USAGE:</color> /sets reskin <color=#41f45e>name</color> or /sets reskin id <color=#41f45e>id</color> to reskin wearable items to a specific set.",
                ["ReskinSuccessful"] = "<color=#e5f441>INFO:</color> Successfully reskinned <color=#41f45e>{0}</color> items using set: <color=#e5f441>{1}</color>, ID: <color=#e5f441>{2}</color>.",
                ["PublicUsage"] = "<color=#e5f441>USAGE:</color> /sets public <color=#41f45e>name</color>",
                ["MaxSets"] = "You have reached your <color=#e5f441>maximum</color> allowed sets. (<color=#f44141>{0}</color>)",
                ["ListFormat"] = "<color=#42ebf4>{0}</color>\n<color=#e5f441>ID:</color> {1}, <color=#e5f441>Times Used:</color> {2}, <color=#e5f441>Public:</color> {3},\n<color=#e5f441>Contents:</color> {4}.",
                ["SetCreated"] = "<color=#e5f441>INFO:</color> You have successfully created a set!\n<color=#e5f441>Name:</color> {0}, <color=#e5f441>ID:</color> {1}.",
                ["NotEnoughResources"] = "<color=#f44141>ERROR:</color> You do not have enough resources to create set (<color=#41f45e>{0}</color>).",
                ["NOBPS"] = "<color=#f44141>ERROR:</color> You do not have the blueprints required to craft any of the items in this set or the set has corrupted.",
                ["MissingBPS"] = "<color=#e5f441>INFO:</color> <color=#f44141>{0}</color> items weren't crafted due to missing blueprints.",
                ["SetCreateUsage"] = "<color=#e5f441>USAGE:</color> /sets create <color=#41f45e>name</color> or /sets create id <color=#41f45e>id</color>",
                ["NoItems"] = "<color=#e5f441>INFO:</color> You are <color=#f44141>not</color> wearing any <color=#e5f441>suitable</color> gear. Please equip the items you want to add to a set.",
                ["NoPermission"] = "<color=#e5f441>INFO:</color> You <color=#f44141>don't</color> have access to this command.",
                ["NoWearables"] = "<color=#e5f441>INFO:</color> You <color=#f44141>must</color> be wearing attire to be able to reskin.",
                ["ReskinFailed"] = "<color=#e5f441>INFO:</color> Reskin has failed, you have <color=#f44141>0</color> items that match the set."
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");

            Config["General", "RequireBP"] = true;
            Config["General", "RemoveOldEntries"] = true;
            Config["General", "ChargeForSets"] = true;

            Config["Limits", "Limit"] = 2;
            Config["Limits", "LimitVIP"] = 5;
            Config["Limits", "DaysUntilRemoval"] = 30;

            Config["Misc", "ForceWear"] = false;
        }

        private List<ItemAmount> ReturnIngredients(ItemDefinition item)
        {
            var bp = ItemManager.FindBlueprint(item);
            if (bp == null) return null;
            return bp.ingredients;
        }

        void LoadData()
        {
            Sets = Interface.Oxide.DataFileSystem.ReadObject<List<SetInfo>>(Name);
            if(Config["General", "ChargeForSets"] == null) { Config["General", "ChargeForSets"] = true; SaveConfig(); }
            Puts("Loaded " + Sets.Count + " sets from /data/" + Name + ".json");
            Puts("Users require blueprints to craft set items: " + Convert.ToString(Config["General", "RequireBP"]).ToUpper() + ".");
            if (Convert.ToBoolean(Config["General", "RemoveOldEntries"])) { Puts("Old entries will be removed after " + Convert.ToString(Config["Limits", "DaysUntilRemoval"]) + " days."); }
            RemoveOldEntries();
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, Sets);

        void RemoveOldEntries()
        {
            if (Convert.ToBoolean(Config["General", "RemoveOldEntries"])) {
                DateTime expiryDate = DateTime.Now - TimeSpan.FromDays(Convert.ToInt32(Config["Limits", "DaysUntilRemoval"]));
                int count = Sets.Count(x => x.LastUsed <= DateTimeToUnixTimestamp(expiryDate));
                if (count != 0) { Sets.RemoveAll(x => x.LastUsed <= DateTimeToUnixTimestamp(expiryDate)); Puts("Removed " + count.ToString() + " old entries from /data/" + Name + ".json"); } else { Puts("No outdated entries to remove."); }
            }
        }

        private bool HasItem(BasePlayer player, string item, int amount)
        {
            if (amount <= 0) return false;
            var definition = ItemManager.FindItemDefinition(item);
            if (definition == null) return false;
            var pamount = player.inventory.GetAmount(definition.itemid);
            if (pamount < amount) return false;
            return true;
        }

        private bool TakeItem(BasePlayer player, string item, int amount)
        {
            if(!HasItem(player, item, amount)) { return false; }
            player.inventory.Take(null, ItemManager.FindItemDefinition(item).itemid, amount);
            return true;
        }

        private bool GiveSetItem(BasePlayer player, int itemid, ulong skinid, int amount, bool wear=false)
        {
            Item itemToGive;
            if (!player.IsConnected) { return false; }
            itemToGive = ItemManager.CreateByItemID(itemid, amount, skinid);
            if (itemToGive == null) { return false; }
            if (Convert.ToBoolean(Config["Misc", "ForceWear"]))
            {
                if (!itemToGive.MoveToContainer(player.inventory.containerWear) 
                    && !itemToGive.MoveToContainer(player.inventory.containerMain) 
                    && !itemToGive.MoveToContainer(player.inventory.containerBelt))
                { itemToGive.Drop(player.eyes.position, player.eyes.BodyForward() * 2f); }
            }
            else
            {
                if (!itemToGive.MoveToContainer(player.inventory.containerMain) 
                    && !itemToGive.MoveToContainer(player.inventory.containerBelt))
                { itemToGive.Drop(player.eyes.position, player.eyes.BodyForward() * 2f); }
            }
            return true;
        }

        [ChatCommand("sets")]
        private void SetsCommand(BasePlayer player, string command, string[] args) => SetsCommandHandler(player, args);

        private void SetsCommandHandler(BasePlayer player, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_DEFAULT)) { PrintToChat(player, Lang("NoPermission", player.UserIDString)); return; }
            if (args.Length == 0 || args.Length > 3) { PrintToChat(player, Lang("NoValue", player.UserIDString)); return; }
            string cmd = args[0].ToLower();
            switch (cmd)
            {
                case "clear":
                    ClearSets(player);
                    break;
                case "add":
                    AddFromArgs(player, args);
                    break;
                case "remove":
                    RemoveFromArgs(player, args);
                    break;
                case "public":
                    PublicStatusFromArgs(player, args);
                    break;
                case "list":
                    SetList(player);
                    break;
                case "create":
                    CreateFromArgs(player, args);
                    break;
                case "reskin":
                    ReskinFromArgs(player, args);
                    break;
                default:
                    PrintToChat(player, Lang("NoValue", player.UserIDString));
                    break;
            }
        }

        private void Reskin(BasePlayer player, int id)
        {
            if (!player.IsConnected) { return; }
            SetInfo Set = SetFromID(id);
            if(Set == null) { PrintToChat(player, Lang("SetNotExistID", player.UserIDString, id)); return; }
            if(player.inventory.containerWear.itemList.Count == 0) { PrintToChat(player, Lang("NoWearables", player.UserIDString)); return;  }
            int updateCount = 0;
            foreach(InternalItemInfo item in Set.Contents)
            {
                Item itemToUpdate = player.inventory.containerWear.itemList.FirstOrDefault(x => x.info.shortname.ToLower() == item.Shortname.ToLower());
                if(itemToUpdate == null) { continue; }
                itemToUpdate.skin = item.SkinID;
                itemToUpdate.MarkDirty();
                updateCount++;
            }
            if(updateCount != 0) { PrintToChat(player, Lang("ReskinSuccessful", player.UserIDString, updateCount.ToString(), Set.Name, Set.ID.ToString())); Set.TimesUsed++; Set.LastUsed = UnixTimestamp(); }
            else { PrintToChat(player, Lang("ReskinFailed", player.UserIDString)); }
        }

        private void ReskinFromArgs(BasePlayer player, string[] args)
        {
            if(args.Length == 3)
            {
                if (args[1].ToLower() == "id")
                {
                    int id = 0;
                    if (Int32.TryParse(args[2], out id))
                    {
                        SetInfo set = SetFromID(id);
                        if (set == null) { PrintToChat(player, Lang("SetNotExistID", player.UserIDString, id)); return; }
                        if (set.Public == false && set.OwnerID != player.userID) { PrintToChat(player, Lang("SetNotPublic", player.UserIDString, id.ToString())); return; }
                        Reskin(player, set.ID);
                    } else { PrintToChat(player, Lang("ReskinUsage", player.UserIDString)); }
                }
            }
            else if (args.Length == 2)
            {
                int setID = SetIDFromName(player, args[1]);
                if (setID == 0) { PrintToChat(player, Lang("SetNotExist", player.UserIDString, args[1].ToLower())); return; }
                Reskin(player, setID);
            }
            else { PrintToChat(player, Lang("ReskinUsage", player.UserIDString)); }
        }

        private void CreateFromArgs(BasePlayer player, string[] args)
        {
            if (args.Length == 3)
            {
                if (args[1].ToLower() == "id")
                {
                    int id = 0;
                    if (Int32.TryParse(args[2], out id))
                    {
                        SetInfo set = SetFromID(id);
                        if (set == null) { PrintToChat(player, Lang("SetNotExistID", player.UserIDString, id)); return; }
                        if (set.Public == false && set.OwnerID != player.userID) { PrintToChat(player, Lang("SetNotPublic", player.UserIDString, id.ToString())); return; }
                        CreateSet(player, set.ID);
                    }
                    else { PrintToChat(player, Lang("SetCreateUsage", player.UserIDString)); }
                }
            }
            else if (args.Length == 2)
            {
                int setID = SetIDFromName(player, args[1]);
                if (setID == 0) { PrintToChat(player, Lang("SetNotExist", player.UserIDString, args[1])); return; }
                CreateSet(player, setID);
            }
            else { PrintToChat(player, Lang("SetCreateUsage", player.UserIDString)); }
        }

        private void PublicStatusFromArgs(BasePlayer player, string[] args)
        {
            if (args.Length != 2) { PrintToChat(player, Lang("PublicUsage", player.UserIDString)); return; }
            UpdatePublicStatus(player, args[1]);
        }

        private void RemoveFromArgs(BasePlayer player, string[] args)
        {
            if (args.Length != 2) { PrintToChat(player, Lang("RemoveUsage", player.UserIDString)); return; }
            RemoveSet(player, args[1]);
        }

        private void AddFromArgs(BasePlayer player, string[] args)
        {
            if (args.Length != 2) { PrintToChat(player, Lang("SetAddUsage", player.UserIDString)); return; }
            AddSet(player, args[1]);
        }

        private void UpdatePublicStatus(BasePlayer player, string args)
        {
            if (!player.IsConnected) { return; }
            if (string.IsNullOrEmpty(args)) { PrintToChat(player, Lang("PublicUsage", player.UserIDString)); return; }
            string setname = args.ToLower();
            if (!SetExistsFromName(player, setname)) { PrintToChat(player, Lang("SetNotExist", player.UserIDString, setname)); return; }
            SetInfo setToUpdate = SetFromName(player, setname);
            if (setToUpdate == null) { return; }
            if (setToUpdate.Public) { setToUpdate.Public = false; } else { setToUpdate.Public = true; }
            PrintToChat(player, Lang("SetPublicUpdated", player.UserIDString, setname, FormatPublicString(setToUpdate.Public)));
        }

        private void CreateSet(BasePlayer player, int id)
        {
            if (!player.IsConnected) { return; }
            List<InternalItemInfo> filteredItemList = new List<InternalItemInfo>();
            Dictionary<ItemDefinition, float> Costs = new Dictionary<ItemDefinition, float>();

            SetInfo setToCreate = SetFromID(id);
            if (setToCreate == null) { return; }

            int missingBlueprints = 0;

            if (Convert.ToBoolean(Config["General", "RequireBP"]))
            {
                foreach (var item in setToCreate.Contents) // BP Check
                {
                    var def = ItemManager.FindItemDefinition(item.Shortname);
                    if (player.blueprints.HasUnlocked(def)) { filteredItemList.Add(item); } else { missingBlueprints++; }
                }
            }
            else { filteredItemList = setToCreate.Contents; }

            if (filteredItemList.Count == 0) { PrintToChat(player, Lang("NOBPS", player.UserIDString)); return; }

            if (Convert.ToBoolean(Config["General", "ChargeForSets"]))
            {
                foreach (InternalItemInfo item in filteredItemList)
                {
                    List<ItemAmount> ingredientsList = ReturnIngredients(ItemManager.FindItemDefinition(item.Shortname));
                    foreach (ItemAmount ingredients in ingredientsList)
                    {
                        if (!Costs.ContainsKey(ingredients.itemDef)) { Costs.Add(ingredients.itemDef, ingredients.amount); }
                        else { Costs[ingredients.itemDef] += ingredients.amount; }
                    }
                }
                int requiredCostItems = Costs.Count, currentItems = 0;
                foreach (var individualCost in Costs) { if (HasItem(player, individualCost.Key.shortname, Convert.ToInt32(individualCost.Value))) { currentItems++; } }
                if (currentItems != requiredCostItems) { PrintToChat(player, Lang("NotEnoughResources", player.UserIDString, setToCreate.Name)); return; }
                foreach (var individualCost in Costs) { TakeItem(player, individualCost.Key.shortname, Convert.ToInt32(individualCost.Value)); }
            }
            foreach (InternalItemInfo item in filteredItemList) { GiveSetItem(player, ItemManager.FindItemDefinition(item.Shortname).itemid, item.SkinID, 1); }
            PrintToChat(player, Lang("SetCreated", player.UserIDString, setToCreate.Name, setToCreate.ID));
            setToCreate.TimesUsed++;
            setToCreate.LastUsed = UnixTimestamp();
            int itemcount = setToCreate.Contents.Count - filteredItemList.Count;
            if (itemcount != 0 && Convert.ToBoolean(Config["General", "RequireBP"])) { PrintToChat(player, Lang("MissingBPS", player.UserIDString, itemcount.ToString())); }
        }

        private SetInfo SetFromName(BasePlayer player, string setname) => Sets.FirstOrDefault(x => x.OwnerID == player.userID && x.Name == setname);
        private SetInfo SetFromID(int id) => Sets.FirstOrDefault(x => x.ID == id);
        private bool SetExistsFromName(BasePlayer player, string setname) => Sets.Any(x => x.OwnerID == player.userID && x.Name == setname);
        private bool SetExistsFromID(int id) => Sets.Any(x => x.ID == id);
        private int SetIDFromName(BasePlayer player, string setname) { var set = Sets.Where(x => x.OwnerID == player.userID && x.Name == setname).FirstOrDefault(); if(set == null) { return 0; } return set.ID; }
        private IEnumerable<SetInfo> ReturnSets(BasePlayer player) { if (!HasSets(player) || !player.IsConnected) { return null; } return Sets.Where(x => x.OwnerID == player.userID); }
        private string FormatPublicString(bool status) { if (status) { return "<color=#41f45e>true</color>"; } else { return "<color=#f44141>false</color>"; } }
        private bool HasSets(BasePlayer player) => Sets.Any(x => x.OwnerID == player.userID);
        private int SetsNextID() { List<int> currentIdList = Sets.ConvertAll<int>(set => set.ID); return Enumerable.Range(1, Int32.MaxValue).Except(currentIdList).First(); }
        private int SetCount(BasePlayer player) => Sets.Count(x => x.OwnerID == player.userID);
        private int RemoveAllSets(BasePlayer player) { if (!player.IsConnected) { return 0; } int removed = SetCount(player); Sets.RemoveAll(x => x.OwnerID == player.userID); return removed; }

        private void SetList(BasePlayer player)
        {
            if (!player.IsConnected) { return; }
            if (!HasSets(player)) { PrintToChat(player, Lang("NoSets", player.UserIDString)); return; }
            foreach (var set in ReturnSets(player)) {
                string contents = string.Empty;
                foreach (var item in set.Contents.ToList())
                {
                    var defFromShortname = ItemManager.FindItemDefinition(item.Shortname);
                    if (defFromShortname == null) { set.Contents.Remove(item); continue; }
                    if (contents.Length == 0) { contents = defFromShortname.displayName.english; }
                    else { contents = contents + ", " + defFromShortname.displayName.english; }
                }
                string publicStatus = FormatPublicString(set.Public);
                PrintToChat(player, Lang("ListFormat", player.UserIDString, set.Name, set.ID.ToString(), set.TimesUsed.ToString(), publicStatus, contents));
            }
        }

        private void RemoveSet(BasePlayer player, string arg)
        {
            if (!player.IsConnected) { return; }
            if (string.IsNullOrEmpty(arg)) { PrintToChat(player, Lang("RemoveUsage", player.UserIDString)); return; }
            string setname = arg.ToLower();
            if (!HasSets(player)) { PrintToChat(player, Lang("NoSets", player.UserIDString)); return; }
            var setToRemove = SetFromName(player, setname);
            if (setToRemove == null) { PrintToChat(player, Lang("SetNotExist", player.UserIDString, setname)); return; }
            Sets.Remove(setToRemove);
            PrintToChat(player, Lang("SetRemoved", player.UserIDString, setname));
        }

        private void AddSet(BasePlayer player, string arg)
        {
            if (!player.IsConnected) { return; }
            if (string.IsNullOrEmpty(arg)) { PrintToChat(player, Lang("SetAddUsage", player.UserIDString)); return; }
            if(player.inventory.containerWear.itemList.Count == 0) { PrintToChat(player, Lang("NoItems", player.UserIDString)); return; }

            int count = SetCount(player);

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_VIP) 
                && count >= Convert.ToInt16(Config["Limits", "Limit"])) {
                PrintToChat(player, Lang("MaxSets", player.UserIDString, Config["Limits", "Limit"].ToString()));
                return;
            } else if(permission.UserHasPermission(player.UserIDString, PERMISSION_VIP)  
                && count >= Convert.ToInt16(Config["Limits", "LimitVIP"])) {
                PrintToChat(player, Lang("MaxSets", player.UserIDString, Config["Limits", "LimitVIP"].ToString()));
                return;
            }

            string setname = arg.ToLower();

            if(SetExistsFromName(player, setname)) { PrintToChat(player, Lang("SetAlreadyExists", player.UserIDString, setname)); return; }

            SetInfo newSet = new SetInfo();
            newSet.OwnerID = player.userID;
            newSet.Name = setname;
            newSet.TimesUsed = 0;
            newSet.LastUsed = UnixTimestamp();
            newSet.ID = SetsNextID();
            newSet.Public = false;
			int itemsToAdd = 0;
            foreach (var wearItem in player.inventory.containerWear.itemList) {
                if (ReturnIngredients(wearItem.info) == null) { continue;  }
                InternalItemInfo setItem = new InternalItemInfo();
                setItem.Shortname = wearItem.info.shortname;
                setItem.SkinID = wearItem.skin;
                newSet.Contents.Add(setItem);
				itemsToAdd++;
            }
            if(itemsToAdd != 0) { Sets.Add(newSet); PrintToChat(player, Lang("SetAdded", player.UserIDString, newSet.Name, newSet.Name)); } 
			else { PrintToChat(player, Lang("NoItems", player.UserIDString)); }
        }

        private void ClearSets(BasePlayer player)
        {
            if (!player.IsConnected) { return; }
            if(!HasSets(player)) { PrintToChat(player, Lang("NoSets", player.UserIDString)); return; }
            PrintToChat(player, Lang("ClearSuccess", player.UserIDString, RemoveAllSets(player).ToString()));
        }
    }
}

// --- End of file: MagicSets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-oil-rig-panel ---
// --- Original File Path: M/MagicOilRigPanel/MagicOilRigPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins;

[Info("Magic Oil Rig Panel", "MJSU", "1.0.4")]
[Description("Displays if the small of large oil rig crate is present")]
public class MagicOilRigPanel : RustPlugin
{
    #region Class Fields

    [PluginReference] private readonly Plugin MagicPanel;

    private PluginConfig _pluginConfig; //Plugin Config

    private string _largeName;
    private readonly List<HackableLockedCrate> _activeLargeOil = new();
    private Vector3 _largePos;
    private const string LargeOilPrefab = "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_1.prefab";
        
    private string _smallName;
    private readonly List<HackableLockedCrate> _activeSmallOil = new();
    private Vector3 _smallPos;
    private const string SmallOilPrefab = "assets/bundled/prefabs/autospawn/monument/offshore/oilrig_2.prefab";

    private bool _init;

    private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
    #endregion

    #region Setup & Loading
    protected override void LoadDefaultConfig()
    {
        PrintWarning("Loading Default Config");
    }

    protected override void LoadConfig()
    {
        string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
        DynamicConfigFile newConfig = new(path);
        if (!newConfig.Exists())
        {
            LoadDefaultConfig();
            newConfig.Save();
        }
        try
        {
            newConfig.Load();
        }
        catch (Exception ex)
        {
            RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
            return;
        }
            
        newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
        _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
        newConfig.WriteObject(_pluginConfig);
    }

    private PluginConfig AdditionalConfig(PluginConfig config)
    {
        config.SmallOilRig = new PanelSetup
        {
            InactiveColor = config.SmallOilRig?.InactiveColor ?? "#FFFFFF1A",
            ActiveColor = config.SmallOilRig?.ActiveColor ?? "#FF4E49FF",
            HackingColor = config.SmallOilRig?.HackingColor ?? "#E5E500FF",
            FullyHackedColor = config.SmallOilRig?.FullyHackedColor ?? "#4EE44EFF",
            Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.SmallOilRig?.Panel?.Image?.Enabled ?? true,
                    Color = config.SmallOilRig?.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.SmallOilRig?.Panel?.Image?.Order ?? 0,
                    Width = config.SmallOilRig?.Panel?.Image?.Width ?? 1f,
                    Url = config.SmallOilRig?.Panel?.Image?.Url ?? "https://i.postimg.cc/zXTndScH/xnT0SjR.png",
                    Padding = config.SmallOilRig?.Panel?.Image?.Padding ?? new TypePadding(0.1f, 0.1f, 0.1f, 0.1f)
                }
            },
            PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.SmallOilRig?.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.SmallOilRig?.PanelSettings?.Dock ?? "center",
                Order = config.SmallOilRig?.PanelSettings?.Order ?? 12,
                Width = config.SmallOilRig?.PanelSettings?.Width ?? 0.02f
            }
        };
            
        config.LargeOilRig = new PanelSetup
        {
            InactiveColor = config.LargeOilRig?.InactiveColor ?? "#FFFFFF1A",
            ActiveColor = config.LargeOilRig?.ActiveColor ?? "#FF4E49FF",
            HackingColor = config.LargeOilRig?.HackingColor ?? "#E5E500FF",
            FullyHackedColor = config.LargeOilRig?.FullyHackedColor ?? "#4EE44EFF",
            Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.LargeOilRig?.Panel?.Image?.Enabled ?? true,
                    Color = config.LargeOilRig?.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.LargeOilRig?.Panel?.Image?.Order ?? 0,
                    Width = config.LargeOilRig?.Panel?.Image?.Width ?? 1f,
                    Url = config.LargeOilRig?.Panel?.Image?.Url ?? "https://i.postimg.cc/zXTndScH/xnT0SjR.png",
                    Padding = config.LargeOilRig?.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f)
                }
            },
            PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.LargeOilRig?.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.LargeOilRig?.PanelSettings?.Dock ?? "center",
                Order = config.LargeOilRig?.PanelSettings?.Order ?? 13,
                Width = config.LargeOilRig?.PanelSettings?.Width ?? 0.02f
            }
        };
            
        return config;
    }

    private void OnServerInitialized()
    {
        _init = true;
        _smallName = $"{Name}_Small";
        _largeName = $"{Name}_Large";
            
        foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
        {
            //Puts($"{monument.name}");
            if (monument.name == LargeOilPrefab)
            {
                _largePos = monument.transform.position;
                Puts($"Set Large Oil Position: {_largePos}");
            }
            else if (monument.name == SmallOilPrefab)
            {
                _smallPos = monument.transform.position;
                Puts($"Set Small Oil Position: {_smallPos}");
            }
        }

        NextTick(() =>
        {
            foreach (HackableLockedCrate crate in BaseNetworkable.serverEntities.OfType<HackableLockedCrate>())
            {
                if (IsCrateAt(crate, _largePos))
                {
                    _activeLargeOil.Add(crate);
                }
                else if (IsCrateAt(crate, _smallPos))
                {
                    _activeSmallOil.Add(crate);
                }
            }

            MagicPanelRegisterPanels();
        });
    }

    private void MagicPanelRegisterPanels()
    {
        if (MagicPanel == null)
        {
            PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
            UnsubscribeAll();
            return;
        }

        MagicPanel?.Call("RegisterGlobalPanel", this, _smallName, JsonConvert.SerializeObject(_pluginConfig.SmallOilRig.PanelSettings), nameof(GetPanel));
        MagicPanel?.Call("RegisterGlobalPanel", this, _largeName, JsonConvert.SerializeObject(_pluginConfig.LargeOilRig.PanelSettings), nameof(GetPanel));
    }

    private void CheckSmallEvent(bool force = false)
    {
        if (force || _activeSmallOil.Count == 0 || _activeSmallOil.Count == 1)
        {
            MagicPanel?.Call("UpdatePanel", _smallName, (int)UpdateEnum.Image);
        }
    }
        
    private void CheckLargeEvent(bool force = false)
    {
        if (force || _activeLargeOil.Count == 0 || _activeLargeOil.Count == 1)
        {
            MagicPanel?.Call("UpdatePanel", _largeName, (int)UpdateEnum.Image);
        }
    }
        
    private void UnsubscribeAll()
    {
        Unsubscribe(nameof(OnEntitySpawned));
        Unsubscribe(nameof(OnEntityKill));
    }
    #endregion

    #region uMod Hooks

    private void OnEntitySpawned(HackableLockedCrate crate)
    {
        if (!_init)
        {
            return;
        }
            
        NextTick(() =>
        {
            if (IsCrateAt(crate, _smallPos))
            {
                _activeSmallOil.Add(crate);
                CheckSmallEvent();
            }
            else if(IsCrateAt(crate, _largePos))
            {
                _activeLargeOil.Add(crate);
                CheckLargeEvent();
            }
        });
    }

    private void OnCrateHack(HackableLockedCrate crate)
    {
        NextTick(() =>
        {
            if (IsCrateAt(crate, _smallPos))
            {
                CheckSmallEvent(true);
            }
            else if (IsCrateAt(crate, _largePos))
            {
                CheckLargeEvent(true);
            }
        });
    }
        
    private void OnCrateHackEnd(HackableLockedCrate crate)
    {
        NextTick(() =>
        {
            if (IsCrateAt(crate, _smallPos))
            {
                CheckSmallEvent(true);
            }
            else if (IsCrateAt(crate, _largePos))
            {
                CheckLargeEvent(true);
            }
        });
    }
        
    private void OnEntityKill(HackableLockedCrate crate)
    {
        if (_activeSmallOil.Remove(crate))
        {
            CheckSmallEvent();
        }
        else if (_activeLargeOil.Remove(crate))
        {
            CheckLargeEvent();
        }
    }
    #endregion

    #region MagicPanel Hook
    private Hash<string, object> GetPanel(string name)
    {
        Panel panel;
        string color;
        if (name == _smallName)
        {
            panel = _pluginConfig.SmallOilRig.Panel;
            color = GetPanelColor(_activeSmallOil, _pluginConfig.SmallOilRig);
        }
        else if (name == _largeName)
        {
            panel = _pluginConfig.LargeOilRig.Panel;
            color = GetPanelColor(_activeLargeOil, _pluginConfig.LargeOilRig);
        }
        else
        {
            return null;
        }
            
        PanelImage image = panel.Image;
        if (image != null)
        {
            image.Color = color;
        }

        return panel.ToHash();
    }

    private string GetPanelColor(List<HackableLockedCrate> crates, PanelSetup setup)
    {
        if (crates.Count == 0)
        {
            return setup.InactiveColor;
        }

        if (crates.Any(h => h.IsFullyHacked()))
        {
            return setup.FullyHackedColor;
        }

        if (crates.Any(h => h.IsBeingHacked()))
        {
            return setup.HackingColor;
        }
            
        return setup.ActiveColor;
    }
    #endregion
        
    #region Helper Methods
    private bool IsCrateAt(HackableLockedCrate crate, Vector3 pos)
    {
        var distance = Vector3.Distance(crate.transform.position, pos);
        //Puts($"Is Crate At: {pos}: {distance} <= {50} = {distance <= 50}");
        return distance <= 50;
    }
    #endregion

    #region Classes

    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Small Oil Rig")]
        public PanelSetup SmallOilRig { get; set; }
            
        [JsonProperty(PropertyName = "Large Oil Rig")]
        public PanelSetup LargeOilRig { get; set; }
    }

    private class PanelSetup
    {
        [JsonProperty(PropertyName = "No Crate Color")]
        public string InactiveColor { get; set; }

        [JsonProperty(PropertyName = "Untouched Crate Color")]
        public string ActiveColor { get; set; }

        [JsonProperty(PropertyName = "Hacking Crate Color")]
        public string HackingColor { get; set; }
            
        [JsonProperty(PropertyName = "Fully Hacked Crate Color")]
        public string FullyHackedColor { get; set; }

        [JsonProperty(PropertyName = "Panel Settings")]
        public PanelRegistration PanelSettings { get; set; }

        [JsonProperty(PropertyName = "Panel Layout")]
        public Panel Panel { get; set; }
    }

    private class PanelRegistration
    {
        public string Dock { get; set; }
        public float Width { get; set; }
        public int Order { get; set; }
        public string BackgroundColor { get; set; }
    }

    private class Panel
    {
        public PanelImage Image { get; set; }
            
        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Image)] = Image.ToHash(),
            };
        }
    }

    private abstract class PanelType
    {
        public bool Enabled { get; set; }
        public string Color { get; set; }
        public int Order { get; set; }
        public float Width { get; set; }
        public TypePadding Padding { get; set; }
            
        public virtual Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Enabled)] = Enabled,
                [nameof(Color)] = Color,
                [nameof(Order)] = Order,
                [nameof(Width)] = Width,
                [nameof(Padding)] = Padding.ToHash(),
            };
        }
    }

    private class PanelImage : PanelType
    {
        public string Url { get; set; }
            
        public override Hash<string, object> ToHash()
        {
            Hash<string, object> hash = base.ToHash();
            hash[nameof(Url)] = Url;
            return hash;
        }
    }

    private class TypePadding
    {
        public float Left { get; set; }
        public float Right { get; set; }
        public float Top { get; set; }
        public float Bottom { get; set; }

        public TypePadding(float left, float right, float top, float bottom)
        {
            Left = left;
            Right = right;
            Top = top;
            Bottom = bottom;
        }
            
        public Hash<string, object> ToHash()
        {
            return new Hash<string, object>
            {
                [nameof(Left)] = Left,
                [nameof(Right)] = Right,
                [nameof(Top)] = Top,
                [nameof(Bottom)] = Bottom
            };
        }
    }
    #endregion
}

// --- End of file: MagicOilRigPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mushroom-effects ---
// --- Original File Path: M/MushroomEffects/MushroomEffects.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Mushroom Effects", "supreme", "1.1.2")]
    [Description("Make mushroom eating fun and add effects")]
    public class MushroomEffects : RustPlugin
    {
        #region Class Fields
        
        private PluginConfig _pluginConfig;

        private readonly Hash<string, Effect> _cachedEffects = new Hash<string, Effect>();
        private readonly Hash<ulong, List<Timer>> _cachedTimers = new Hash<ulong, List<Timer>>();
        private readonly Hash<ulong, int> _cachedUsedMushrooms = new Hash<ulong, int>();
        private readonly System.Random _random = new System.Random();

        private const string UiBlur = "MushroomEffects_UiBlur";
        private const string UiEffects = "MushroomEffects_UiEffects";
        private const string HardShakeEffectPrefab = "assets/bundled/prefabs/fx/screen_land.prefab";
        private const string SoftShakeEffectPrefab = "assets/bundled/prefabs/fx/takedamage_generic.prefab";
        private const string VomitEffetPrefab = "assets/bundled/prefabs/fx/gestures/drink_vomit.prefab";
        private const string BreatheEffectPrefab = "assets/prefabs/npc/bear/sound/breathe.prefab";
        private const string UsePermission = "mushroomeffects.use";
        private const int MushroomItemId = -1962971928;
        private string _cachedUi;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
        }

        private void OnServerInitialized()
        {
            CacheUiBlur();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                DestroyMushroomEffects(player);
            }
        }
        
        private void OnItemUse(Item item, int amount)
        {
            if (item.info.itemid != MushroomItemId)
            {
                return;
            }
            
            BasePlayer player = item.GetOwnerPlayer();
            if (!player || !permission.UserHasPermission(player.UserIDString, UsePermission))
            {
                return;
            }

            ulong playerId = player.userID;
            _cachedUsedMushrooms[playerId]++;
            if (_cachedUsedMushrooms[playerId] < _random.Next(_pluginConfig.MinUsed, _pluginConfig.MaxUsed))
            {
                return;
            }
            
            List<Timer> cachedTimers = GetCachedTimers(playerId);
            int times = 0;
            // No point in implementing a proper system for such a simple plugin
            cachedTimers.Add(timer.Every(0.25f, () =>
            {
                if (_pluginConfig.EnableShakeEffect)
                {
                    SendEffectTo(HardShakeEffectPrefab, player);
                    SendEffectTo(SoftShakeEffectPrefab, player);
                }

                // instead of instantiating more timers
                if (times % 16 == 0 && _pluginConfig.EnableVomitEffect)
                {
                    SendEffectTo(VomitEffetPrefab, player);
                }

                if (times % 4 == 0 && _pluginConfig.EnableBreathEffect)
                {
                    SendEffectTo(BreatheEffectPrefab, player);
                }

                DisplayUiEffects(player);
                times++;
            }));

            DisplayUiBlur(player);
            _cachedUsedMushrooms[playerId] = 0;
            
            cachedTimers.Add(timer.Once(_pluginConfig.EffectsDuration, () => DestroyMushroomEffects(player)));
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            DestroyMushroomEffects(player);
        }
        
        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyMushroomEffects(player);
            _cachedUsedMushrooms.Remove(player.userID);
            _cachedTimers.Remove(player.userID);
        }

        #endregion

        #region Core Methods

        private void DisplayUiBlur(BasePlayer player)
        {
            if (!player)
            {
                return;
            }

            CuiHelper.DestroyUi(player, UiBlur);
            CuiHelper.AddUi(player, _cachedUi);
        }
        
        private void DisplayUiEffects(BasePlayer player)
        {
            if (!player)
            {
                return;
            }

            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = $"{GetRandomColor()}" }
            }, "Overlay", UiEffects);

            CuiHelper.DestroyUi(player, UiEffects);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Helper Methods
        
        private List<Timer> GetCachedTimers(ulong playerId)
        {
            return _cachedTimers[playerId] ?? (_cachedTimers[playerId] = new List<Timer>());
        }
        
        private void CacheUiBlur()
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.65", Material = "assets/content/ui/uibackgroundblur.mat" },
            }, "Overlay", UiBlur);

            _cachedUi = container.ToJson();
        }
        
        private void SendEffectTo(string effectPrefab, BasePlayer player)
        {
            Effect effect = _cachedEffects[effectPrefab];
            if (effect == null)
            {
                effect = new Effect(effectPrefab, Vector3.zero, Vector3.zero)
                {
                    attached = true
                };
                
                _cachedEffects[effectPrefab] = effect;
            }
            
            effect.entity = player.net.ID;
            EffectNetwork.Send(effect, player.net.connection);
        }

        private void DestroyMushroomEffects(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UiEffects);
            CuiHelper.DestroyUi(player, UiBlur);
            DestroyTimers(player.userID);
        }

        private void DestroyTimers(ulong playerId)
        {
            List<Timer> timers = _cachedTimers[playerId];
            if (timers == null)
            {
                return;
            }
            
            foreach (Timer cachedTimer in timers)
            {
                cachedTimer?.Destroy();
            }
        }
        
        private string GetRandomColor()
        {
            return $"{_random.NextDouble()} {_random.NextDouble()} {_random.NextDouble()} {_pluginConfig.ColorOpacity}";
        }

        #endregion

        #region Configuration

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Duration of the effects")]
            public float EffectsDuration { get; set; } = 10f;
            
            [JsonProperty(PropertyName = "Minimum Amount Of Mushrooms required to trigger the effect")]
            public int MinUsed { get; set; } = 1;

            [JsonProperty(PropertyName = "Maximum Amount Of Mushrooms required to trigger the effect")]
            public int MaxUsed { get; set; } = 5;

            [JsonProperty(PropertyName = "Opacity of the colors")]
            public float ColorOpacity { get; set; } = 0.3f;

            [JsonProperty(PropertyName = "Enable vomit effect")] 
            public bool EnableVomitEffect { get; set; } = true;

            [JsonProperty(PropertyName = "Enable breath effect")]
            public bool EnableBreathEffect { get; set; } = true;

            [JsonProperty(PropertyName = "Enable shake effect")]
            public bool EnableShakeEffect { get; set; } = true;

        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<PluginConfig>();
                if (_pluginConfig == null)
                {
                    throw new Exception();
                }
                
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_pluginConfig);

        protected override void LoadDefaultConfig() => _pluginConfig = new PluginConfig();

        #endregion
    }
}

// --- End of file: MushroomEffects.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-craft ---
// --- Original File Path: M/MagicCraft/MagicCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Magic Craft", "Orange", "1.0.0")]
    [Description("Alternative crafting system")]
    public class MagicCraft : RustPlugin
    {
        #region Vars

        private const string permUse = "magiccraft.use";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }
        
        private object OnItemCraft(ItemCraftTask item)
        {
            return OnCraft(item);
        }

        #endregion

        #region Core

        private object OnCraft(ItemCraftTask task)
        {
            if (task.cancelled == true)
            {
                return null;
            }
            
            var player = task.owner;
            var target = task.blueprint.targetItem;
            var name = target.shortname;
            
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return null;
            }

            if (IsBlocked(name))
            {
                task.cancelled = true;
                Message(player, "Blocked");
                GiveRefund(player, task.takenItems);
                return null;
            }

            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            var slots = FreeSlots(player);

            if (HasPlace(slots, stacks) == false)
            {
                task.cancelled = true;
                Message(player, "Slots", stacks.Count, slots);
                GiveRefund(player, task.takenItems);
                return null;
            }
            
            if (IsNormalItem(name))
            {
                Message(player, "Normal");
                return null;
            }
            
            GiveItem(player, task, target, stacks, task.skinID);
            task.cancelled = true;
            return null;
        }

        private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID)
        {
            var skin = ItemDefinition.FindSkin(def.itemid, taskSkinID);
            
            if (config.split == false)
            {
                var final = 0;

                foreach (var stack in stacks)
                {
                    final += stack;
                }
                
                var item = ItemManager.Create(def, final, skin);
                player.GiveItem(item);
                Interface.CallHook("OnItemCraftFinished", task, item);
            }
            else
            {
                foreach (var stack in stacks)
                {
                    var item = ItemManager.Create(def, stack, skin);
                    player.GiveItem(item);
                    Interface.CallHook("OnItemCraftFinished", task, item);
                }
            }
        }

        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private void GiveRefund(BasePlayer player, List<Item> items)
        {
            foreach (var item in items)
            {
                player.GiveItem(item);
            }
        }

        private List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        private bool IsNormalItem(string name)
        {
            return config.normal?.Contains(name) ?? false;
        }

        private bool IsBlocked(string name)
        {
            return config.blocked?.Contains(name) ?? false;
        }

        private bool HasPlace(int slots, List<int> stacks)
        {
            if (config.checkPlace == false)
            {
                return true;
            }

            if (config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }

        #endregion

        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.SendConsoleCommand("chat.add", (object) 0, (object) message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public List<string> normal;

            [JsonProperty(PropertyName = "Blacklist")]
            public List<string> blocked;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                normal = new List<string>
                {
                    "hammer",
                    "put item shortname here"
                },
                blocked = new List<string>
                {
                    "rock",
                    "put item shortname here"
                },
                checkPlace = false,
                split = false
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: MagicCraft.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-note-teleport ---
// --- Original File Path: M/MapNoteTeleport/MapNoteTeleport.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using ProtoBuf;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("MapNote Teleport", "MON@H", "2.2.1")]
    [Description("Teleports player to marker on map when placed.")]
    public class MapNoteTeleport : CovalencePlugin
    {
        #region Initialization

        private const string PermissionUse = "mapnoteteleport.use";
        private readonly List<ulong> _playersOnCooldown = new List<ulong> ();
        private readonly List<ulong> _playersWithGodMode = new List<ulong> ();

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PermissionUse, this);
            foreach (var command in _configData.GlobalSettings.Commands)
            {
                AddCovalenceCommand(command, nameof(CmdMapNoteTeleport));
            }
            Unsubscribe(nameof(OnEntityTakeDamage));
        }

        private void OnServerInitialized()
        {
            if (_configData.GlobalSettings.Commands.Length == 0)
            {
                _configData.GlobalSettings.Commands = new[] { "mnt" };
                SaveConfig();
            } 
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            SaveData();
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalConfiguration GlobalSettings = new GlobalConfiguration();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatConfiguration ChatSettings = new ChatConfiguration();

            public class GlobalConfiguration
            {
                [JsonProperty(PropertyName = "Use permissions")]
                public bool UsePermission = true;

                [JsonProperty(PropertyName = "Allow admins to use without permission")]
                public bool AdminsAllowed = true;

                [JsonProperty(PropertyName = "Default Enabled")]
                public bool DefaultEnabled = true;

                [JsonProperty(PropertyName = "Default Cooldown")]
                public float DefaultCooldown = 10f;

                [JsonProperty(PropertyName = "Maximum Cooldown")]
                public float MaximumCooldown = 15f;

                [JsonProperty(PropertyName = "Minimum Cooldown")]
                public float MinimumCooldown = 5f;

                [JsonProperty(PropertyName = "GodMode Cooldown")]
                public float GodModeCooldown = 5f;

                [JsonProperty(PropertyName = "Commands list")]
                public string[] Commands = new[] { "mnt", "mapnoteteleport" };
            }

            public class ChatConfiguration
            {
                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong SteamIDIcon = 0;

                [JsonProperty(PropertyName = "Notifications Enabled by default")]
                public bool DefaultNotification = true;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
        }

        public class PlayerData
        {
            public bool Enabled;
            public float Cooldown;
            public bool Notification;
        }

        private PlayerData GetPlayerData(ulong playerId, bool addToStored = false)
        {
            PlayerData playerData;
            if (!_storedData.PlayerData.TryGetValue(playerId, out playerData))
            {
                playerData = new PlayerData
                {
                    Enabled = _configData.GlobalSettings.DefaultEnabled,
                    Cooldown = _configData.GlobalSettings.DefaultCooldown,
                    Notification = _configData.ChatSettings.DefaultNotification,
                };

                if (addToStored)
                {
                    _storedData.PlayerData.Add(playerId, playerData);
                }
            }

            return playerData;
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                _storedData = null;
            }
            finally
            {
                if (_storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CooldownEnded"] = "Cooldown is now ended. You can teleport again.",
                ["GodModeEnded"] = "Godmode is now <color=#B22222>Disabled</color>.",
                ["Disabled"] = "<color=#B22222>Disabled</color>",
                ["Enabled"] = "<color=#228B22>Enabled</color>",
                ["MapNoteTeleport"] = "Teleporting to map marker is now {0}",
                ["MapNoteTeleportCooldown"] = "Teleporting to map marker Cooldown set to <color=#FFA500>{0}</color>s.",
                ["MapNoteTeleportCooldownLimit"] = "Teleporting to map marker Cooldown allowed is between <color=#FFA500>{0}</color>s and <color=#FFA500>{1}</color>s",
                ["MapNoteTeleportDead"] = "You can't teleport while being dead!",
                ["MapNoteTeleportMounted"] = "You can't teleport while seated!",
                ["MapNoteTeleportNotification"] = "Notification to chat is now {0}",
                ["NotAllowed"] = "You do not have permission to use this command!",
                ["Prefix"] = "<color=#00FFFF>[MapNote Teleport]</color>: ",
                ["Teleported"] = "Teleported to <color=#FFA500>{0}</color>. Godmode is now <color=#228B22>Enabled</color> for <color=#FFA500>{1}</color>s. Teleport is on Cooldown for <color=#FFA500>{2}</color>s.",

                ["SyntaxError"] = "Syntax error occured!\n"
                + "<color=#FFFF00>/{0} <time (seconds)></color> - Set teleport Cooldown time, the allowed time is between <color=#FFA500>{1}</color>s and <color=#FFA500>{2}</color>s.\n"
                + "<color=#FFFF00>/{0} <t | toggle></color> - Enable/Disable teleporting to map marker\n"
                + "<color=#FFFF00>/{0} <n | notify></color> - Enable/Disable notification to chat",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CooldownEnded"] = "Перезарядка завершена. Можете телепортироваться снова.",
                ["GodModeEnded"] = "Неуязвимость <color=#B22222>Откл.</color>.",
                ["Disabled"] = "<color=#B22222>Откл.</color>",
                ["Enabled"] = "<color=#228B22>Вкл.</color>",
                ["MapNoteTeleport"] = "Телепортация к маркеру на карте сейчас {0}",
                ["MapNoteTeleportCooldown"] = "Время перезарядки телепорта к маркеру на карте установлено на <color=#FFA500>{0}</color> секунд.",
                ["MapNoteTeleportCooldownLimit"] = "Значение времени перезарядки телепорта к маркеру на карте должно быть между <color=#FFA500>{0}</color> сек и <color=#FFA500>{1}</color> сек",
                ["MapNoteTeleportDead"] = "Вы не можете телепортироваться, пока мертвы!",
                ["MapNoteTeleportMounted"] = "Вы не можете телепортироваться, когда сидите!",
                ["MapNoteTeleportNotification"] = "Уведомления в чат сейчас {0}",
                ["NotAllowed"] = "У вас нет разрешения на использование этой команды!",
                ["Prefix"] = "<color=#00FFFF>[MapNote Teleport]</color>: ",
                ["Teleported"] = "Вы телепортированы на <color=#FFA500>{0}</color>. Неуязвимость <color=#228B22>Вкл.</color> на <color=#FFA500>{1}</color> сек. Перезарядка телепорта <color=#FFA500>{2}</color> сек.",

                ["SyntaxError"] = "Синтаксическая ошибка!\n"
                + "<color=#FFFF00>/{0} <время (сек.)></color> - Установить время перезарядки телепорта к маркеру на карте. Значение должно быть между <color=#FFA500>{1}</color> сек. и <color=#FFA500>{2}</color> сек.\n"
                + "<color=#FFFF00>/{0} <t | toggle></color> - Вкл./Откл. телепортацию к маркеру на карте\n"
                + "<color=#FFFF00>/{0} <n | notify></color> - Вкл./Откл. уведомления в чат",
            }, this, "ru");
        }

        #endregion Localization

        #region Commands

        private void CmdMapNoteTeleport(IPlayer player, string command, string[] args)
        {

            if (_configData.GlobalSettings.UsePermission && !permission.UserHasPermission(player.Id, PermissionUse))
            {
                if (!_configData.GlobalSettings.AdminsAllowed || !player.IsAdmin)
                {
                    Print(player, Lang("NotAllowed", player.Id));
                    return;
                }
            }

            if (args == null || args.Length == 0)
            {
                Print(player, Lang("SyntaxError", player.Id, _configData.GlobalSettings.Commands[0], _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
                return;
            }

            var playerData = GetPlayerData(ulong.Parse(player.Id), true);

            float Cooldown;
            if (float.TryParse(args[0], out Cooldown))
            {
                if (Cooldown <= _configData.GlobalSettings.MaximumCooldown && Cooldown >= _configData.GlobalSettings.MinimumCooldown)
                {
                    playerData.Cooldown = Cooldown;
                    if (!playerData.Enabled)
                    {
                        playerData.Enabled = true;
                    }

                    Print(player, Lang("MapNoteTeleportCooldown", player.Id, Cooldown));
                    return;
                }

                Print(player, Lang("MapNoteTeleportCooldownLimit", player.Id, _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
                return;
            }

            switch (args[0].ToLower())
            {
                case "t":
                case "toggle":
                    playerData.Enabled = !playerData.Enabled;
                    Print(player, Lang("MapNoteTeleport", player.Id, playerData.Enabled ? Lang("Enabled", player.Id) : Lang("Disabled", player.Id)));
                    return;
                case "n":
                case "notify":
                    playerData.Notification = !playerData.Notification;
                    Print(player, Lang("MapNoteTeleportNotification", player.Id, playerData.Notification ? Lang("Enabled", player.Id) : Lang("Disabled", player.Id)));
                    return;
            }

            Print(player, Lang("SyntaxError", player.Id, _configData.GlobalSettings.Commands[0], _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
        }

        #endregion Commands

        #region Helpers

        private void TeleportToNote(BasePlayer player, MapNote note)
        {
            var err = CheckPlayer(player);
            if (err != null)
            {
                Print(player.IPlayer, Lang(err, player.UserIDString));
                return;
            }

            ulong userID = player.userID;
            _playersOnCooldown.Add(userID);
            _playersWithGodMode.Add(userID);
            Subscribe(nameof(OnEntityTakeDamage));
            player.flyhackPauseTime = _configData.GlobalSettings.MaximumCooldown;
            var pos = note.worldPosition;
            pos.y = GetGroundPosition(pos);

            player.Teleport(pos);
            player.RemoveFromTriggers();
            player.ForceUpdateTriggers();
            var playerData = GetPlayerData(userID);
            if (playerData.Notification)
            {
                Print(player.IPlayer, Lang("Teleported", player.UserIDString, pos, _configData.GlobalSettings.GodModeCooldown, playerData.Cooldown));
            }

            timer.Once(playerData.Cooldown, () =>
            {
                _playersOnCooldown.Remove(userID);

                if (playerData.Notification && player != null)
                {
                    Print(player.IPlayer, Lang("CooldownEnded", player.UserIDString));
                }
            });

            timer.Once(_configData.GlobalSettings.GodModeCooldown, () =>
            {
                _playersWithGodMode.Remove(userID);
                if (_playersWithGodMode.Count == 0)
                {
                    Unsubscribe(nameof(OnEntityTakeDamage));
                }

                if (playerData.Notification && player != null)
                {
                    Print(player.IPlayer, Lang("GodModeEnded", player.UserIDString));
                }
            });
        }

        private string CheckPlayer(BasePlayer player)
        {
            if (player.isMounted)
            {
                return "MapNoteTeleportMounted";
            }

            if (!player.IsAlive())
            {
                return "MapNoteTeleportDead";
            }

            return null;
        }

        private void OnMapMarkerAdded(BasePlayer player, MapNote note)
        {
            if (player == null || note == null || _playersOnCooldown.Contains(player.userID))
            {
                return;
            }

            if (_configData.GlobalSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                if (!_configData.GlobalSettings.AdminsAllowed || !player.IsAdmin)
                {
                    return;
                }
            }

            var playerData = GetPlayerData(player.userID);
            if (!playerData.Enabled)
            {
                return;
            }

            TeleportToNote(player, note);
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hitInfo;

            if (Physics.Raycast(
                new Vector3(pos.x, pos.y + 200f, pos.z),
                Vector3.down,
                out hitInfo,
                float.MaxValue,
                (Rust.Layers.Mask.Vehicle_Large | Rust.Layers.Solid | Rust.Layers.Mask.Water)))
            {
                var cargoShip = hitInfo.GetEntity() as CargoShip;
                if (cargoShip != null)
                {
                    return hitInfo.point.y;
                }

                return Mathf.Max(hitInfo.point.y, y);
            }

            return y;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || !player.userID.IsSteamId())
            {
                return null;
            }

            if (_playersWithGodMode.Contains(player.userID))
            {
                return true;
            }

            return null;
        }

        private void Print(IPlayer player, string message)
        {
            string text;
            if (string.IsNullOrEmpty(Lang("Prefix", player.Id)))
            {
                text = message;
            }
            else
            {
                text = Lang("Prefix", player.Id) + message;
            }
#if RUST
            (player.Object as BasePlayer).SendConsoleCommand ("chat.add", 2, _configData.ChatSettings.SteamIDIcon, text);
            return;
#endif
            player.Message(text);
        }

        #endregion Helpers
    }
}

// --- End of file: MapNoteTeleport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mount-restrictions ---
// --- Original File Path: M/MountRestrictions/MountRestrictions.cs ---

﻿using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace Oxide.Plugins {
    [Info("Mount Restrictions", "Jhawins", "1.0.2")]
    [Description("Restricts equipment when mounting entities based on configuration")]
    class MountRestrictions : CovalencePlugin {
        #region Localization

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string>() {
                ["Prefix"] = "Mount Restriction: ",
                ["HeavyArmor"] = "Wearing more than 1 heavy item while mounting this is not allowed!",
            }, this, "en");
        }

        private string GetMessage(string key, string id = null) => lang.GetMessage("Prefix", this, id) + lang.GetMessage(key, this, id);

        #endregion

        #region Configuration

        private struct RestrictionSet {
            public List<string> restrictedItems { get; set; }
            public int? maximumAllowed { get; set; }
            public string langKey { get; set; }
            public List<string> entityNames { get; set; }
        }

        private Configuration config;

        private class Configuration {
            [JsonProperty(PropertyName = "RestrictionSets", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<RestrictionSet> RestrictionSets { get; set; }
        }

        private Configuration GetDefaultConfig() {
            return new Configuration {
                RestrictionSets = new List<RestrictionSet>() {
                    {
                        new RestrictionSet {
                            restrictedItems = new List<string> () { "heavy.plate.helmet", "heavy.plate.jacket", "heavy.plate.pants" },
                            maximumAllowed = 1,
                            langKey = "HeavyArmor",
                            entityNames = new List<string> { "testridablehorse", "minicopterentity", "scraptransporthelicopter", "rowboat" }
                        }
                    }
                }
            };
        }

        protected override void LoadDefaultConfig() {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        protected override void LoadConfig() {
            base.LoadConfig();
            try {
                config = Config.ReadObject<Configuration>();
                if (config == null) {
                    throw new JsonException();
                }
                SaveConfig();
                Config.WriteObject(config);
            } catch (Exception e) {
                // Likely to be a pretty insane exception. It is probably just invalid JSON
                Puts("Configuration is syntactically invalid! Validate your configuration. Loading defaults {0}", e.ToString());
                LoadDefaultConfig();
                return;
            }
        }

        #endregion

        #region Hooks

        bool? CanMountEntity(BasePlayer player, BaseMountable entity) {
            if (entity != null && player != null) {
                BaseVehicle vehicleEntity = entity.VehicleParent();
                if (vehicleEntity != null && CheckAnyRestrictionsMatched(player.inventory.containerWear.itemList, player, vehicleEntity, false)) {
                    return false;
                }
            }

            return null;
        }

        bool? CanWearItem(PlayerInventory inventory, Item item) {
            BasePlayer player = inventory.containerWear.playerOwner;
            BaseVehicle mountedEntity = player.GetMountedVehicle();
            if (mountedEntity != null) {
                List<Item> newWearables = new List<Item>(player.inventory.containerWear.itemList);
                newWearables.Add(item);
                if (CheckAnyRestrictionsMatched(newWearables, player, mountedEntity, true)) {
                    return false;
                }
                return null;
            }

            return null;
        }

        #endregion

        #region Methods
        // track exceptions, hooks will be unsubscribed after 10 exceptions
        private int ConfigExceptions = 0;
        bool CheckAnyRestrictionsMatched(List<Item> items, BasePlayer player, BaseMountable mountedEntity, bool alreadyMounted) {
            try {
                if (mountedEntity.ShortPrefabName != null) {
                    string entityName = new Regex(@"\W").Replace(mountedEntity.ShortPrefabName, "");
                    List<RestrictionSet> restrictionSets = config.RestrictionSets;
                    List<RestrictionSet> matchedRestrictionSets = restrictionSets.FindAll(restrictionSet => restrictionSet.restrictedItems != null
                        && (restrictionSet.entityNames == null || restrictionSet.entityNames.Contains(entityName))
                        && restrictionSet.restrictedItems.FindAll(itemName => items.Exists(item => item.info.shortname == itemName)).Count > restrictionSet.maximumAllowed);
                    if (matchedRestrictionSets.Count > 0) {
                        matchedRestrictionSets.ForEach(restrictionSet => player.ChatMessage(GetMessage(restrictionSet.langKey, player.UserIDString)));
                        return true;
                    }
                }
            } catch (Exception e) {
                ConfigExceptions++;
                Puts("Error - one or more restriction configurations is probably invalid {0}", e.ToString());
                if (ConfigExceptions >= 10) {
                    Puts("Fatal Error - Max exceptions of 10 has been reached. Unsubscribing hooks. Fix configuration and reload plugin");
                    Unsubscribe(nameof(CanMountEntity));
                    Unsubscribe(nameof(CanWearItem));
                }
            }
            return false;
        }

        #endregion

    }
}

// --- End of file: MountRestrictions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-last-wipe-panel ---
// --- Original File Path: M/MagicLastWipePanel/MagicLastWipePanel.cs ---

﻿using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Last Wipe Panel", "MJSU", "1.0.1")]
    [Description("Displays the date the server wiped in magic panel")]
    public class MagicLastWipePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;
        private PluginConfig _pluginConfig; //Plugin Config

        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? false,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.33f,
                    Url = config.Panel?.Image?.Url ?? "",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.05f, 0.05f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 1f,
                    FontSize = config.Panel?.Text?.FontSize ?? 12,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "Last Wipe: {0:MM/dd/yyyy}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "centerupper",
                Order = config.PanelSettings?.Order ?? 9,
                Width = config.PanelSettings?.Width ?? 0.1f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, SaveRestore.SaveCreatedTime);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicLastWipePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/monument-finder ---
// --- Original File Path: M/MonumentFinder/MonumentFinder.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Monument Finder", "WhiteThunder", "3.1.4")]
    [Description("Find monuments with commands or API.")]
    internal class MonumentFinder : CovalencePlugin
    {
        #region Fields

        private static MonumentFinder _pluginInstance;
        private static Configuration _pluginConfig;

        private const string PermissionFind = "monumentfinder.find";

        private const float DrawDuration = 30;

        private readonly FieldInfo DungeonBaseLinksFieldInfo = typeof(TerrainPath).GetField("DungeonBaseLinks", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

        private Dictionary<MonumentInfo, NormalMonumentAdapter> _normalMonuments = new();
        private Dictionary<DungeonGridCell, TrainTunnelAdapter> _trainTunnels = new();
        private Dictionary<DungeonBaseLink, UnderwaterLabLinkAdapter> _labModules = new();
        private Dictionary<MonoBehaviour, BaseMonumentAdapter> _allMonuments = new();

        private Collider[] _colliderBuffer = new Collider[8];

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;
            permission.RegisterPermission(PermissionFind, this);

            AddCovalenceCommand(_pluginConfig.Command, nameof(CommandFind));
        }

        private void Unload()
        {
            _pluginConfig = null;
            _pluginInstance = null;
        }

        private void OnServerInitialized()
        {
            if (DungeonBaseLinksFieldInfo != null)
            {
                if (DungeonBaseLinksFieldInfo.GetValue(TerrainMeta.Path) is List<DungeonBaseLink> dungeonLinks)
                {
                    foreach (var link in dungeonLinks)
                    {
                        // End links represent the posts holding up the lab modules.
                        if (link.Type == DungeonBaseLinkType.End)
                            continue;

                        var labLink = new UnderwaterLabLinkAdapter(link);
                        _labModules[link] = labLink;
                        _allMonuments[link] = labLink;
                    }
                }
            }

            foreach (var dungeonCell in TerrainMeta.Path.DungeonGridCells)
            {
                if (TrainTunnelAdapter.IgnoredPrefabs.Contains(dungeonCell.name))
                    continue;

                try
                {
                    var trainTunnel = new TrainTunnelAdapter(dungeonCell);
                    _trainTunnels[dungeonCell] = trainTunnel;
                    _allMonuments[dungeonCell] = trainTunnel;
                }
                catch (NotImplementedException exception)
                {
                    LogWarning(exception.Message);
                }
            }

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                var normalMonument = new NormalMonumentAdapter(monument);
                _normalMonuments[monument] = normalMonument;
                _allMonuments[monument] = normalMonument;
            }
        }

        #endregion

        #region API

        private Dictionary<string, object> API_GetClosest(Vector3 position) =>
            GetClosestMonumentForAPI(_allMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestMonument(Vector3 position) =>
            GetClosestMonumentForAPI(_normalMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestTrainTunnel(Vector3 position) =>
            GetClosestMonumentForAPI(_trainTunnels.Values, position);

        private Dictionary<string, object> API_GetClosestUnderwaterLabModules(Vector3 position) =>
            GetClosestMonumentForAPI(_labModules.Values, position);

        private List<Dictionary<string, object>> API_FindMonuments(string filter) =>
            FilterMonumentsForAPI(_normalMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindTrainTunnels(string filter) =>
            FilterMonumentsForAPI(_trainTunnels.Values, filter);

        private List<Dictionary<string, object>> API_FindUnderwaterLabModules(string filter) =>
            FilterMonumentsForAPI(_labModules.Values, filter);

        private List<Dictionary<string, object>> API_Find(string filter) =>
            FilterMonumentsForAPI(_allMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindByShortName(string shortName) =>
            FilterMonumentsForAPI(_allMonuments.Values, shortName: shortName);

        private List<Dictionary<string, object>> API_FindByAlias(string alias) =>
            FilterMonumentsForAPI(_allMonuments.Values, alias: alias);

        // Kept for backwards compatibility with previous versions.
        private List<MonumentInfo> FindMonuments(string filter)
        {
            var monuments = new List<MonumentInfo>();

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                if (!monument.name.Contains("/monument/") || !string.IsNullOrEmpty(filter) &&
                    !monument.Type.ToString().Contains(filter, CompareOptions.IgnoreCase) &&
                    !monument.name.Contains(filter, CompareOptions.IgnoreCase))
                    continue;

                monuments.Add(monument);
            }

            return monuments;
        }

        #endregion

        #region Commands

        private void CommandFind(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionFind))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            if (args == null || args.Length == 0)
            {
                SubcommandHelp(player, command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "find":
                case "f":
                case "list":
                case "l":
                {
                    SubcommandList(player, command, args.Skip(1).ToArray());
                    return;
                }

                case "show":
                case "s":
                case "view":
                case "v":
                {
                    SubcommandShow(player, command, args.Skip(1).ToArray());
                    break;
                }

                case "closest":
                case "nearest":
                {
                    SubcommandClosest(player, command, args.Skip(1).ToArray());
                    break;
                }

                default:
                {
                    SubcommandHelp(player, command);
                    break;
                }
            }
        }

        private void SubcommandHelp(IPlayer player, string command)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.HelpHeader));
            builder.AppendLine(GetMessage(player, Lang.HelpList, command));
            builder.AppendLine(GetMessage(player, Lang.HelpShow, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosest, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosestConfig, command));
            player.Reply(builder.ToString());
        }

        private void SubcommandList(IPlayer player, string cmd, string[] args)
        {
            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);

            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            PrintMonumentList(player, monuments);
        }

        private void SubcommandShow(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);
            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            foreach (var monument in monuments)
                ShowMonumentName(basePlayer, monument);
        }

        private void SubcommandClosest(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var position = basePlayer.transform.position;
            var monument = GetClosestMonument(_allMonuments.Values, position);
            if (monument == null)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            var firstArg = args.FirstOrDefault() ?? string.Empty;
            if (firstArg.Equals("config", StringComparison.CurrentCultureIgnoreCase))
            {
                var aliasOrShortName = monument.Alias ?? monument.ShortName;
                if (_pluginConfig.AddMonument(aliasOrShortName, monument))
                {
                    Config.WriteObject(_pluginConfig, true);
                    ReplyToPlayer(player, Lang.ClosestConfigSuccess, aliasOrShortName);
                }
                else
                {
                    ReplyToPlayer(player, Lang.ClosestConfigAlreadyPresent, aliasOrShortName);
                }
            }
            else
            {
                if (monument.IsInBounds(position))
                {
                    var relativePosition = monument.InverseTransformPoint(position);
                    ReplyToPlayer(player, Lang.AtMonument, monument.PrefabName, relativePosition);
                }
                else
                {
                    var closestPoint = monument.ClosestPointOnBounds(position);
                    var distance = (position - closestPoint).magnitude;
                    ReplyToPlayer(player, Lang.ClosestMonument, monument.PrefabName, distance);
                }
            }

            if (basePlayer.IsAdmin)
            {
                ShowMonumentName(basePlayer, monument);

                var showBoxDetails = monument.BoundingBoxes.Length == 1;
                foreach (var boundingBox in monument.BoundingBoxes)
                {
                    if (boundingBox.extents == Vector3.zero)
                        continue;

                    Ddraw.Box(basePlayer, boundingBox, Color.magenta, DrawDuration, showBoxDetails);
                }
            }
        }

        #endregion

        #region Helper Methods

        private static void LogError(string message) => Interface.Oxide.LogError($"[Monument Finder] {message}");

        private static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Monument Finder] {message}");

        private static bool IsCustomMonument(MonumentInfo monumentInfo)
        {
            return monumentInfo.name.Contains("monument_marker.prefab");
        }

        private static Collider FindPreventBuildingVolume(Vector3 position)
        {
            var buffer = _pluginInstance._colliderBuffer;
            var count = Physics.OverlapSphereNonAlloc(position, 1, buffer, Rust.Layers.Mask.Prevent_Building, QueryTriggerInteraction.Ignore);

            if (count == 0)
                return null;

            for (var i = 0; i < count; i++)
            {
                var collider = buffer[i];
                if ((collider is BoxCollider || collider is SphereCollider)
                    // Only count prevent_building prefabs, not all prefabs that have prevent building colliders.
                    && collider.name.Contains("prevent_building", CompareOptions.IgnoreCase))
                    return collider;
            }

            return null;
        }

        private static T GetClosestMonument<T>(IEnumerable<T> monumentList, Vector3 position) where T : BaseMonumentAdapter
        {
            T closestMonument = null;
            var closestSqrDistance = float.MaxValue;

            foreach (var baseMonument in monumentList)
            {
                var currentSqrDistance = (position - baseMonument.ClosestPointOnBounds(position)).sqrMagnitude;
                if (currentSqrDistance < closestSqrDistance)
                {
                    closestSqrDistance = currentSqrDistance;
                    closestMonument = baseMonument;
                }
            }

            return closestMonument;
        }

        private static Dictionary<string, object> GetClosestMonumentForAPI(IEnumerable<BaseMonumentAdapter> monumentList, Vector3 position)
        {
            return GetClosestMonument(monumentList, position)?.APIResult;
        }

        private static List<T> FilterMonuments<T>(IEnumerable<T> monumentList, string filter = null, string shortName = null, string alias = null) where T : BaseMonumentAdapter
        {
            var results = new List<T>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                    results.Add(baseMonument);
            }

            return results;
        }

        private static List<Dictionary<string, object>> FilterMonumentsForAPI(IEnumerable<BaseMonumentAdapter> monumentList, string filter = null, string shortName = null, string alias = null)
        {
            var results = new List<Dictionary<string, object>>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                {
                    results.Add(baseMonument.APIResult);
                }
            }

            return results;
        }

        private void PrintMonumentList(IPlayer player, IEnumerable<BaseMonumentAdapter> monuments)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.ListHeader));

            foreach (var monument in monuments)
            {
                builder.AppendLine(monument.PrefabName);
            }

            player.Reply(builder.ToString());
        }

        private static void ShowMonumentName(BasePlayer player, BaseMonumentAdapter monument)
        {
            Ddraw.Text(player, monument.Position, $"<size=20>{monument.ShortName}</size>", Color.magenta, 30);
        }

        #endregion

        #region Monument Adapter

        private abstract class BaseMonumentAdapter
        {
            protected static string GetShortName(string prefabName)
            {
                var slashIndex = prefabName.LastIndexOf("/");
                var baseName = (slashIndex == -1) ? prefabName : prefabName[(slashIndex + 1)..];
                return baseName.Replace(".prefab", "");
            }

            public MonoBehaviour Object { get; }
            public string PrefabName { get; protected set; }
            public string ShortName { get; protected set; }

            // Subclasses should overwrite this is if multiple monuments need to share an alias.
            // For instance, each train station prefab should share the same alias since they only differ in rotation.
            public string Alias { get; protected set; }

            public Vector3 Position { get; protected set; }
            protected Quaternion Rotation { get; set; }
            public OBB[] BoundingBoxes { get; protected set; }

            protected BaseMonumentAdapter(MonoBehaviour behavior)
            {
                Object = behavior;
                PrefabName = behavior.name;
                ShortName = GetShortName(behavior.name);

                var transform = behavior.transform;
                Position = transform.position;
                Rotation = transform.rotation;
            }

            public Vector3 TransformPoint(Vector3 localPosition)
            {
                return Position + Rotation * localPosition;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return Quaternion.Inverse(Rotation) * (worldPosition - Position);
            }

            public bool IsInBounds(Vector3 position)
            {
                foreach (var box in BoundingBoxes)
                {
                    if (box.Contains(position))
                        return true;
                }

                return false;
            }

            public Vector3 ClosestPointOnBounds(Vector3 position)
            {
                var overallClosestPoint = Vector3.positiveInfinity;
                var closestSqrDistance = float.MaxValue;

                foreach (var box in BoundingBoxes)
                {
                    var closestPoint = box.ClosestPoint(position);
                    var currentSqrDistance = (position - closestPoint).sqrMagnitude;

                    if (currentSqrDistance < closestSqrDistance)
                    {
                        overallClosestPoint = closestPoint;
                        closestSqrDistance = currentSqrDistance;
                    }
                }

                return overallClosestPoint;
            }

            public virtual bool MatchesFilter(string filter, string shortName, string alias)
            {
                if (alias != null)
                    return Alias?.Equals(alias, StringComparison.InvariantCultureIgnoreCase) ?? false;

                if (shortName != null)
                    return ShortName.Equals(shortName, StringComparison.InvariantCultureIgnoreCase);

                if (string.IsNullOrEmpty(filter))
                    return true;

                return PrefabName.Contains(filter, CompareOptions.IgnoreCase);
            }

            private Dictionary<string, object> _cachedAPIResult;
            public Dictionary<string, object> APIResult
            {
                get
                {
                    if (_cachedAPIResult == null)
                    {
                        _cachedAPIResult = new Dictionary<string, object>
                        {
                            ["Object"] = Object,
                            ["PrefabName"] = PrefabName,
                            ["ShortName"] = ShortName,
                            ["Alias"] = Alias,
                            ["Position"] = Position,
                            ["Rotation"] = Rotation,
                            ["BoundingBoxes"] = BoundingBoxes,
                            ["TransformPoint"] = new Func<Vector3, Vector3>(TransformPoint),
                            ["InverseTransformPoint"] = new Func<Vector3, Vector3>(InverseTransformPoint),
                            ["ClosestPointOnBounds"] = new Func<Vector3, Vector3>(ClosestPointOnBounds),
                            ["IsInBounds"] = new Func<Vector3, bool>(IsInBounds),
                        };
                    }

                    return _cachedAPIResult;
                }
            }
        }

        private class NormalMonumentAdapter : BaseMonumentAdapter
        {
            public static Dictionary<string, Bounds> MonumentBounds = new()
            {
                // These bounds are more accurate than what is provided in vanilla.
                ["airfield_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(355, 70, 210)),
                ["bandit_town"] = new Bounds(new Vector3(0, 12, -5), new Vector3(150, 40, 140)),
                ["cave_large_sewers_hard"] = new Bounds(new Vector3(18, -5, -9), new Vector3(52, 80, 56)),
                ["cave_medium_medium"] = new Bounds(new Vector3(-5, 10, -3), new Vector3(100, 20, 50)),
                ["cave_small_easy"] = new Bounds(new Vector3(5, 10, 0), new Vector3(55, 24, 55)),
                ["cave_small_hard"] = new Bounds(new Vector3(0, 10, -5), new Vector3(40, 20, 35)),
                ["cave_small_medium"] = new Bounds(new Vector3(10, 10, 0), new Vector3(45, 26, 40)),
                ["compound"] = new Bounds(new Vector3(0, 12, 0), new Vector3(200, 50, 200)),
                ["entrance_bunker_a"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 18)),
                ["entrance_bunker_b"] = new Bounds(new Vector3(-8, 1, 0), new Vector3(30, 30, 18)),
                ["entrance_bunker_c"] = new Bounds(new Vector3(-3.5f, 1, -5f), new Vector3(24, 30, 27)),
                ["entrance_bunker_d"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 17)),
                ["excavator_1"] = new Bounds(new Vector3(0, 40, 0), new Vector3(240, 100, 230)),
                ["fishing_village_a"] = new Bounds(new Vector3(-3, 5, -11), new Vector3(76, 24, 80)),
                ["fishing_village_b"] = new Bounds(new Vector3(-3, 4, -4), new Vector3(42, 24, 76)),
                ["fishing_village_c"] = new Bounds(new Vector3(-0.5f, 4, -4.5f), new Vector3(31, 22, 75)),
                ["gas_station_1"] = new Bounds(new Vector3(0, 13, 15), new Vector3(70, 42, 60)),
                ["harbor_1"] = new Bounds(new Vector3(-8, 23, 15), new Vector3(246, 60, 200)),
                ["harbor_2"] = new Bounds(new Vector3(6, 23, 18), new Vector3(224, 60, 250)),
                ["junkyard_1"] = new Bounds(new Vector3(0, 20, 0), new Vector3(180, 50, 180)),
                ["launch_site_1"] = new Bounds(new Vector3(10, 25, -26), new Vector3(544, 120, 276)),
                ["lighthouse"] = new Bounds(new Vector3(10f, 23, 5), new Vector3(74, 96, 68)),
                ["military_tunnel_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(265, 70, 250)),
                ["mining_quarry_a"] = new Bounds(new Vector3(2, 10, 2), new Vector3(52, 20, 72)),
                ["mining_quarry_b"] = new Bounds(new Vector3(-5, 10, -8), new Vector3(60, 20, 40)),
                ["mining_quarry_c"] = new Bounds(new Vector3(-6, 10, 8), new Vector3(42, 20, 60)),
                ["oilrig_1"] = new Bounds(new Vector3(3, 43, 12), new Vector3(80, 96, 120)),
                ["oilrig_2"] = new Bounds(new Vector3(18, 20, -2), new Vector3(68, 60, 76)),
                ["power_sub_big_1"] = new Bounds(new Vector3(0, 5, 0.5f), new Vector3(20, 10, 22f)),
                ["power_sub_big_2"] = new Bounds(new Vector3(-1, 5, 1), new Vector3(23, 10, 22)),
                ["power_sub_small_1"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["power_sub_small_2"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["powerplant_1"] = new Bounds(new Vector3(-15, 25, -11), new Vector3(220, 64, 290)),
                ["radtown_small_3"] = new Bounds(new Vector3(-10, 15, -18), new Vector3(130, 50, 148)),
                ["satellite_dish"] = new Bounds(new Vector3(0, 25, 3), new Vector3(155, 55, 125)),
                ["sphere_tank"] = new Bounds(new Vector3(0, 41, 0), new Vector3(100, 84, 100)),
                ["stables_a"] = new Bounds(new Vector3(0, 10, 4), new Vector3(50, 20, 60)),
                ["stables_b"] = new Bounds(new Vector3(2, 15, 6), new Vector3(78, 30, 66)),
                ["supermarket_1"] = new Bounds(new Vector3(1, 4.5f, 1), new Vector3(40, 10, 44)),
                ["swamp_a"] = new Bounds(new Vector3(-10, 11, 0), new Vector3(140, 30, 140)),
                ["swamp_b"] = new Bounds(new Vector3(0, 14, 0), new Vector3(100, 36, 100)),
                ["swamp_c"] = new Bounds(new Vector3(0, 7, 0), new Vector3(100, 30, 100)),
                ["trainyard_1"] = new Bounds(new Vector3(10, 22, -30), new Vector3(235, 70, 220)),
                ["underwater_lab_a"] = new Bounds(),
                ["underwater_lab_b"] = new Bounds(),
                ["underwater_lab_c"] = new Bounds(),
                ["underwater_lab_d"] = new Bounds(),
                ["warehouse"] = new Bounds(new Vector3(0, 5, -8), new Vector3(44, 10, 24)),
                ["water_treatment_plant_1"] = new Bounds(new Vector3(20, 30, -45), new Vector3(250, 84, 290)),
                ["water_well_a"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_b"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_c"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_d"] = new Bounds(new Vector3(0, 10, 0), new Vector3(30, 20, 30)),
                ["water_well_e"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
            };

            public MonumentInfo MonumentInfo { get; }

            public NormalMonumentAdapter(MonumentInfo monumentInfo) : base(monumentInfo)
            {
                MonumentInfo = monumentInfo;
                var bounds = monumentInfo.Bounds;

                if (IsCustomMonument(monumentInfo))
                {
                    PrefabName = monumentInfo.transform.root.name;
                    ShortName = PrefabName;

                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName)
                        ?? _pluginConfig.DefaultCustomMonumentSettings;

                    var volumeCollider = monumentSettings.Position.UsePreventBuildingVolume
                        || monumentSettings.Rotation.UsePreventBuildingVolume
                        || monumentSettings.Bounds.UsePreventBuildingVolume
                            ? FindPreventBuildingVolume(Position)
                            : null;

                    if (!monumentSettings.Position.UseMonumentMarker
                        && monumentSettings.Position.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Position = volumeCollider.transform.position;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining position from monument marker instead.");
                        }
                    }

                    if (!monumentSettings.Rotation.UseMonumentMarker
                        && monumentSettings.Rotation.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Rotation = volumeCollider.transform.rotation;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining rotation from monument marker instead.");
                        }
                    }

                    if (monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else if (monumentSettings.Bounds.UseMonumentMarker)
                    {
                        bounds = new Bounds(Position - monumentInfo.transform.position, monumentInfo.transform.localScale);
                    }
                    else if (monumentSettings.Bounds.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            var volumeColliderBounds = volumeCollider.bounds;
                            bounds = new Bounds(volumeColliderBounds.center, volumeColliderBounds.size);
                            bounds.center = Quaternion.Inverse(Rotation) * (bounds.center - Position);
                        }
                        else
                        {
                            LogError($"Unable to find a PreventBuilding volume for monument {ShortName}. Unable to determine bounds.");
                        }
                    }
                }
                else
                {
                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName);
                    if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else
                    {
                        if (MonumentBounds.TryGetValue(ShortName, out var hardCodedBounds))
                        {
                            bounds = hardCodedBounds;
                        }
                    }
                }

                BoundingBoxes = new[] { new OBB(Position, Rotation, bounds) };
            }

            public override bool MatchesFilter(string filter, string shortName, string alias)
            {
                return base.MatchesFilter(filter, shortName, alias)
                    || !string.IsNullOrEmpty(filter) && MonumentInfo.Type.ToString().Contains(filter, CompareOptions.IgnoreCase);
            }
        }

        private class TrainTunnelAdapter : BaseMonumentAdapter
        {
            public static readonly string[] IgnoredPrefabs =
            {
                // These prefabs are simply used for decorating.
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-1.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-1.prefab",
            };

            private abstract class BaseTunnelInfo
            {
                public Quaternion Rotation;
                public virtual Bounds Bounds { get; }
                public virtual string Alias { get; }
            }

            // Train stations.
            private class TrainStation : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 8.75f, 0), new Vector3(108, 18, 216));
                public override string Alias => "TrainStation";
            }

            // Straight tunnels that contain barricades, loot and tunnel dwellers.
            private class BarricadeTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 0), new Vector3(45f, 9, 216));
                public override string Alias => "BarricadeTunnel";
            }

            // Straight tunnels contain loot and tunnel dwellers.
            private class LootTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "LootTunnel";
            }

            // Straight tunnels with a divider in the tracks.
            private class SplitTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "SplitTunnel";
            }

            // 3-way intersections.
            private class Intersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 49.875f), new Vector3(216, 9, 116.25f));
                public override string Alias => "Intersection";
            }

            // 4-way intersections.
            private class LargeIntersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 0), new Vector3(216, 9, 216));
                public override string Alias => "LargeIntersection";
            }

            // 3-way intersections that connect to above ground.
            private class VerticalIntersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(0, 4.25f, 49.875f), new Vector3(216, 9, 116.25f));
                public override string Alias => "VerticalIntersection";
            }

            // Corner tunnels (45-degree angle).
            private class CornerTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new(new Vector3(-49.875f, 4.25f, 49.875f), new Vector3(116.25f, 9, 116.25f));
                public override string Alias => "CornerTunnel";
            }

            private static readonly Dictionary<string, BaseTunnelInfo> PrefabToTunnelInfo = new()
            {
                ["station-sn-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-sn-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-we-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },
                ["station-we-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-we-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["straight-sn-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 0, 0) },

                ["intersection-n"] = new Intersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-e"] = new Intersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-s"] = new Intersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-w"] = new Intersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b1-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b1-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b1-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b1-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b2-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b2-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b2-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b2-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b3-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b3-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b3-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b3-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b4-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b4-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b4-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b4-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b5-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b5-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b5-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b5-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b6-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b6-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b6-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b6-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb1-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb1-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb1-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb1-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb2-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb2-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb2-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb2-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb3-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb3-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb3-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb3-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb4-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb4-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb4-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb4-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb5-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb5-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb5-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb5-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-bb6-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-bb6-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-bb6-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-bb6-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection"] = new LargeIntersection { Rotation = Quaternion.Euler(0, 0, 0) },

                ["curve-ne-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-ne-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-nw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-nw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-se-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-se-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-sw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["curve-sw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
            };

            private static BaseTunnelInfo GetTunnelInfo(string shortName)
            {
                if (PrefabToTunnelInfo.TryGetValue(shortName, out var tunnelInfo))
                    return tunnelInfo;

                throw new NotImplementedException($"Tunnel type not implemented: {shortName}");
            }

            private BaseTunnelInfo _tunnelInfo;

            public TrainTunnelAdapter(DungeonGridCell dungeonCell) : base(dungeonCell)
            {
                _tunnelInfo = GetTunnelInfo(ShortName);

                Rotation = _tunnelInfo.Rotation;
                Alias = _tunnelInfo.Alias;

                var bounds = _tunnelInfo.Bounds;

                var monumentSettings = _pluginConfig.GetMonumentSettings(_tunnelInfo.Alias);
                if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                {
                    bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                }

                BoundingBoxes = new[] { new OBB(Position, Rotation, bounds) };
            }
        }

        private class UnderwaterLabLinkAdapter : BaseMonumentAdapter
        {
            public UnderwaterLabLinkAdapter(DungeonBaseLink dungeonLink) : base(dungeonLink)
            {
                var volumeList = dungeonLink.GetComponentsInChildren<DungeonVolume>();
                BoundingBoxes = new OBB[volumeList.Length];

                for (var i = 0; i < volumeList.Length; i++)
                {
                    var volume = volumeList[i];
                    var transform = volume.transform;
                    BoundingBoxes[i] = new OBB(transform.position, transform.rotation, volume.bounds);
                }
            }
        }

        #endregion

        #region Ddraw

        private static class Ddraw
        {
            public static void Sphere(BasePlayer player, Vector3 origin, float radius, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.sphere", duration, color, origin, radius);

            public static void Line(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.line", duration, color, origin, target);

            public static void Text(BasePlayer player, Vector3 origin, string text, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.text", duration, color, origin, text);

            public static void Segments(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration)
            {
                var delta = target - origin;
                var distance = delta.magnitude;
                var direction = delta.normalized;

                var segmentLength = 10f;
                var numSegments = Mathf.CeilToInt(distance / segmentLength);

                for (var i = 0; i < numSegments; i++)
                {
                    var length = segmentLength;
                    if (i == numSegments - 1 && distance % segmentLength != 0)
                        length = distance % segmentLength;

                    var start = origin + i * segmentLength * direction;
                    var end = start + length * direction;
                    Line(player, start, end, color, duration);
                }
            }

            public static void Box(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 halfExtents, Color color, float duration, bool showBoxDetails = true)
            {
                var boxArea = halfExtents.x * halfExtents.z;

                var sphereRadius = boxArea > 200
                    ? 1f
                    : boxArea > 10
                    ? 0.5f
                    : 0.1f;

                var forwardUpperLeft = center + rotation * halfExtents.WithX(-halfExtents.x);
                var forwardUpperRight = center + rotation * halfExtents;
                var forwardLowerLeft = center + rotation * halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var forwardLowerRight = center + rotation * halfExtents.WithY(-halfExtents.y);

                var backLowerRight = center + rotation * -halfExtents.WithX(-halfExtents.x);
                var backLowerLeft = center + rotation * -halfExtents;
                var backUpperRight = center + rotation * -halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var backUpperLeft = center + rotation * -halfExtents.WithY(-halfExtents.y);

                var forwardLowerMiddle = Vector3.Lerp(forwardLowerLeft, forwardLowerRight, 0.5f);
                var forwardUpperMiddle = Vector3.Lerp(forwardUpperLeft, forwardUpperRight, 0.5f);

                var backLowerMiddle = Vector3.Lerp(backLowerLeft, backLowerRight, 0.5f);
                var backUpperMiddle = Vector3.Lerp(backUpperLeft, backUpperRight, 0.5f);

                var leftLowerMiddle = Vector3.Lerp(forwardLowerLeft, backLowerLeft, 0.5f);
                var leftUpperMiddle = Vector3.Lerp(forwardUpperLeft, backUpperLeft, 0.5f);

                var rightLowerMiddle = Vector3.Lerp(forwardLowerRight, backLowerRight, 0.5f);
                var rightUpperMiddle = Vector3.Lerp(forwardUpperRight, backUpperRight, 0.5f);

                Sphere(player, forwardUpperLeft, sphereRadius, color, duration);
                Sphere(player, forwardUpperRight, sphereRadius, color, duration);
                Sphere(player, forwardLowerLeft, sphereRadius, color, duration);
                Sphere(player, forwardLowerRight, sphereRadius, color, duration);

                Sphere(player, backLowerRight, sphereRadius, color, duration);
                Sphere(player, backLowerLeft, sphereRadius, color, duration);
                Sphere(player, backUpperRight, sphereRadius, color, duration);
                Sphere(player, backUpperLeft, sphereRadius, color, duration);

                Segments(player, forwardUpperLeft, forwardUpperRight, color, duration);
                Segments(player, forwardLowerLeft, forwardLowerRight, color, duration);
                Segments(player, forwardUpperLeft, forwardLowerLeft, color, duration);
                Segments(player, forwardUpperRight, forwardLowerRight, color, duration);

                Segments(player, backUpperLeft, backUpperRight, color, duration);
                Segments(player, backLowerLeft, backLowerRight, color, duration);
                Segments(player, backUpperLeft, backLowerLeft, color, duration);
                Segments(player, backUpperRight, backLowerRight, color, duration);

                Segments(player, forwardUpperLeft, backUpperLeft, color, duration);
                Segments(player, forwardLowerLeft, backLowerLeft, color, duration);
                Segments(player, forwardUpperRight, backUpperRight, color, duration);
                Segments(player, forwardLowerRight, backLowerRight, color, duration);

                if (showBoxDetails)
                {
                    Sphere(player, forwardLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, forwardUpperMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backUpperMiddle, sphereRadius, Color.yellow, duration);

                    Sphere(player, leftLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, leftUpperMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightUpperMiddle, sphereRadius, Color.green, duration);

                    Text(player, forwardUpperMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, forwardLowerMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, backUpperMiddle, "<size=20>-Z</size>", Color.yellow, duration);
                    Text(player, backLowerMiddle, "<size=20>-Z</size>", Color.yellow, duration);

                    Text(player, leftLowerMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, leftUpperMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, rightLowerMiddle, "<size=20>+X</size>", Color.green, duration);
                    Text(player, rightUpperMiddle, "<size=20>+X</size>", Color.green, duration);

                    Text(player, forwardUpperLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerRight, "<size=28>*</size>", color, duration);

                    Text(player, backLowerRight, "<size=28>*</size>", color, duration);
                    Text(player, backLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, backUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, backUpperLeft, "<size=28>*</size>", color, duration);
                }
            }

            public static void Box(BasePlayer player, OBB boundingBox, Color color, float duration, bool showBoxDetails = true)
            {
                Box(player, boundingBox.position, boundingBox.rotation, boundingBox.extents, color, duration, showBoxDetails);
            }
        }

        #endregion

        #region Configuration

        private class CustomBounds
        {
            [JsonProperty("Size")]
            public Vector3 Size;

            [JsonProperty("Center adjustment")]
            public Vector3 CenterOffset;

            [JsonProperty("Center")]
            private Vector3 DeprecatedCenter { set => CenterOffset = value; }

            public Bounds ToBounds() => new(CenterOffset, Size);

            public CustomBounds Copy()
            {
                return new CustomBounds
                {
                    Size = Size,
                    CenterOffset = CenterOffset,
                };
            }
        }

        private class BaseDetectionSettings
        {
            [JsonProperty("Auto determine from monument marker", Order = -3)]
            public bool UseMonumentMarker;

            [JsonProperty("Auto determine from prevent building volume", Order = -2)]
            public bool UsePreventBuildingVolume;

            public BaseDetectionSettings Copy()
            {
                return new BaseDetectionSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                };
            }
        }

        private class BoundSettings : BaseDetectionSettings
        {
            [JsonProperty("Use custom bounds")]
            public bool UseCustomBounds;

            [JsonProperty("Custom bounds")]
            public CustomBounds CustomBounds = new();

            public new BoundSettings Copy()
            {
                return new BoundSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                    UseCustomBounds = UseCustomBounds,
                    CustomBounds = CustomBounds.Copy(),
                };
            }
        }

        private class MonumentSettings
        {
            [JsonProperty("Position")]
            public BaseDetectionSettings Position = new();

            [JsonProperty("Rotation")]
            public BaseDetectionSettings Rotation = new();

            [JsonProperty("Bounds")]
            public BoundSettings Bounds = new();

            public MonumentSettings Copy()
            {
                return new MonumentSettings
                {
                    Position = Position.Copy(),
                    Rotation = Rotation.Copy(),
                    Bounds = Bounds.Copy(),
                };
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "mf";

            [JsonProperty("Default custom monument settings")]
            public MonumentSettings DefaultCustomMonumentSettings = new()
            {
                Position = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Rotation = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Bounds = new BoundSettings
                {
                    UseMonumentMarker = false,
                    UseCustomBounds = true,
                    CustomBounds = new CustomBounds
                    {
                        CenterOffset = new Vector3(0, 10, 0),
                        Size = new Vector3(30, 30, 30),
                    },
                },
            };

            [JsonProperty("Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            private Dictionary<string, MonumentSettings> MonumentSettingsMap = new()
            {
                ["example_monument"] = new()
                {
                    Position = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Rotation = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Bounds = new BoundSettings
                    {
                        UseMonumentMarker = false,
                        UseCustomBounds = true,
                        CustomBounds = new CustomBounds
                        {
                            CenterOffset = new Vector3(0, 10, 0),
                            Size = new Vector3(30, 30, 30),
                        },
                    },
                },
            };

            [JsonProperty("OverrideMonumentBounds")]
            private Dictionary<string, CustomBounds> DeprecatedOverrideMonumentBounds
            {
                set
                {
                    foreach (var entry in value)
                    {
                        MonumentSettingsMap[entry.Key] = new MonumentSettings
                        {
                            Position = new BaseDetectionSettings { UseMonumentMarker = true },
                            Rotation = new BaseDetectionSettings { UseMonumentMarker = true },
                            Bounds = new BoundSettings
                            {
                                UseCustomBounds = true,
                                CustomBounds = entry.Value,
                            },
                        };
                    }
                }
            }

            public MonumentSettings GetMonumentSettings(string monumentName)
            {
                return MonumentSettingsMap.TryGetValue(monumentName, out var monumentSettings)
                    ? monumentSettings
                    : null;
            }

            public bool AddMonument(string aliasOrShortName, BaseMonumentAdapter monument)
            {
                if (MonumentSettingsMap.ContainsKey(aliasOrShortName))
                    return false;

                var monumentInfo = monument.Object as MonumentInfo;
                var isCustomMonument = monumentInfo != null && IsCustomMonument(monumentInfo);

                MonumentSettings monumentSettings;

                if (isCustomMonument)
                {
                    monumentSettings = DefaultCustomMonumentSettings.Copy();
                }
                else
                {
                    if (!NormalMonumentAdapter.MonumentBounds.TryGetValue(aliasOrShortName, out var bounds))
                    {
                        bounds = default;
                    }

                    monumentSettings = new MonumentSettings
                    {
                        Bounds = new BoundSettings
                        {
                            UseCustomBounds = true,
                            CustomBounds = new CustomBounds
                            {
                                Size = bounds.size,
                                CenterOffset = bounds.center,
                            },
                        }
                    };
                }

                MonumentSettingsMap[aliasOrShortName] = monumentSettings;
                return true;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                        {
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ErrorNoPermission = "NoPermission";
            public const string NoMonumentsFound = "NoMonumentsFound";
            public const string ListHeader = "List.Header";
            public const string AtMonument = "AtMonument";
            public const string ClosestMonument = "ClosestMonument";
            public const string ClosestConfigSuccess = "Closest.Config.Success";
            public const string ClosestConfigAlreadyPresent = "Closest.Config.AlreadyPresent";
            public const string HelpHeader = "Help.Header";
            public const string HelpList = "Help.List";
            public const string HelpShow = "Help.Show";
            public const string HelpClosest = "Help.Closest";
            public const string HelpClosestConfig = "Help.Closest.Config";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.NoMonumentsFound] = "No monuments found",
                [Lang.AtMonument] = "At monument: {0}\nRelative position: {1}",
                [Lang.ClosestMonument] = "Closest monument: {0}\nDistance: {1:f2}m",
                [Lang.ClosestConfigSuccess] = "Added monument <color=#9f6>{0}</color> to the plugin config.",
                [Lang.ClosestConfigAlreadyPresent] = "Monument <color=#9f6>{0}</color> is already in the plugin config.",
                [Lang.ListHeader] = "Listing monuments:",
                [Lang.HelpHeader] = "Monument Finder commands:",
                [Lang.HelpList] = "<color=#9f6>{0} list <filter></color> - List monuments matching filter",
                [Lang.HelpShow] = "<color=#9f6>{0} show <filter></color> - Show monuments matching filter",
                [Lang.HelpClosest] = "<color=#9f6>{0} closest</color> - Show info about the closest monument",
                [Lang.HelpClosestConfig] = "<color=#9f6>{0} closest config</color> - Adds the closest monument to the config",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: MonumentFinder.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/medical-tool-tweaker ---
// --- Original File Path: M/MedicalToolTweaker/MedicalToolTweaker.cs ---

using System.Collections.Generic;
using Convert = System.Convert;

namespace Oxide.Plugins
{
    [Info("Medical Tool Tweaker", "BuzZ", "0.0.1")]
    [Description("Modify medical tools variables")]

/*======================================================================================================================= 
*
*   
*   08th february 2019
*
*   0.0.1   20190208    creation

*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*=======================================================================================================================*/

    public class MedicalToolTweaker : RustPlugin
    {

        bool debug = false;
        private bool ConfigChanged;
        const string MedicalTweaker = "medicaltooltweaker.use";

        float maxdistanceother = 2f;
        float healdurationother = 4f;
        bool canuseonother = true;
        float healdurationself = 4f;
        bool canrevive = false;


        void Init()
        {
            permission.RegisterPermission(MedicalTweaker, this);
            LoadVariables();
        }

//////////////////////////////////
#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            maxdistanceother = Convert.ToSingle(GetConfig("Healing Others", "Max Distance (2 by default)", "2"));
            healdurationother = Convert.ToSingle(GetConfig("Healing Others", "Heal duration (4 by default)", "4"));
            canuseonother = Convert.ToBoolean(GetConfig("Healing Others", "Can heal others (true by default)", "true"));
            healdurationself = Convert.ToSingle(GetConfig("Healing Self", "Heal duration (4 by default)", "4"));
            canrevive = Convert.ToBoolean(GetConfig("Revive", "Can be used to revive (false by default)", "false"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion

//////////////////////////////////////////////////////

        void OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            bool tweaker = permission.UserHasPermission(player.UserIDString, MedicalTweaker);
            if (tweaker)
            {
                tool.maxDistanceOther = maxdistanceother;//2  serynge +bandage//
                tool.healDurationSelf = healdurationself;//4
                tool.healDurationOther = healdurationother;//4
                tool.canRevive = canrevive;//false
                tool.canUseOnOther = canuseonother;//true
            }
        }
    }
}

// --- End of file: MedicalToolTweaker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/memory-cache ---
// --- Original File Path: M/MemoryCache/MemoryCache.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Memory Cache", "austinv900", "1.0.6")]
    [Description("Provides api for in-memory storage")]
    internal class MemoryCache : CovalencePlugin
    {
        /// <summary>
        /// Defines a set of options used to control the behavior of cached items
        /// </summary>
        public sealed class CacheItemOptions
        {

            /// <summary>
            /// Gets or sets an absolute expiration date for the cache entry.
            /// </summary>
            public DateTimeOffset? AbsoluteExpiration { get; set; }

            /// <summary>
            /// Gets or sets an absolute expiration time, relative to now.
            /// </summary>
            public TimeSpan? AbsoluteExpirationRelativeToNow { get; set; }

            /// <summary>
            /// Gets or sets the callback that is fired when a cache object expires
            /// </summary>
            public Action<object> ExpirationCallback { get; set; }

            /// <summary>
            /// Gets or sets how long a cache entry can be inactive (e.g. not accessed) before it will be removed. This will not extend the entry lifetime beyond the absolute expiration (if set).
            /// </summary>
            public TimeSpan? SlidingExpiration { get; set; }
        }

        /// <summary>
        /// Defines a object being stored in memory
        /// </summary>
        private class CacheItem
        {
            /// <summary>
            /// Gets or sets the cached object
            /// </summary>
            public object StoredObject { get; set; }

            /// <summary>
            /// Gets or sets the behavior of the cached object
            /// </summary>
            public CacheItemOptions Options { get; set; }

            /// <summary>
            /// Gets or sets the last access time for this object
            /// </summary>
            public DateTimeOffset LastAccess { get; set; }
        }

        /// <summary>
        /// Contains all currently stored object
        /// </summary>
        private Dictionary<string, CacheItem> _memoryCache = new Dictionary<string, CacheItem>();

        #region Oxide Hooks

        private void Init()
        {
            Unsubscribe(nameof(RunCacheCleanup));
            Unsubscribe(nameof(ProcessCacheCleanupItem));
            Unsubscribe(nameof(_memoryCache));
            Unsubscribe(nameof(ExpireItem));
            Unsubscribe(nameof(IsExpired));
        }

        private void Unload()
        {
            foreach (var cacheItem in _memoryCache.ToArray())
            {
                ExpireItem(cacheItem.Key, cacheItem.Value);
            }
        }

        private void OnServerSave() => RunCacheCleanup();

        #endregion



        private void RunCacheCleanup()
        {
            var now = DateTimeOffset.UtcNow;
            foreach (var kv in _memoryCache.ToArray())
            {
                ProcessCacheCleanupItem(kv.Key, kv.Value, kv.Value.Options, now);
            }
        }

        private bool IsExpired(CacheItem item, CacheItemOptions options, DateTimeOffset current)
        {
            if (options.AbsoluteExpiration.HasValue)
            {
                if (options.AbsoluteExpiration <= current)
                {
                    return true;
                }
            }

            if (options.SlidingExpiration.HasValue)
            {
                if ((current - item.LastAccess) <= options.SlidingExpiration.Value)
                {
                    return true;
                }
            }

            return false;
        }

        private void ProcessCacheCleanupItem(string key, CacheItem item, CacheItemOptions options, DateTimeOffset currentTimestamp)
        {
            if (IsExpired(item, options, currentTimestamp))
            {
                ExpireItem(key, item);
            }
        }

        private void ExpireItem(string key, CacheItem item)
        {
            if (item.Options != null && item.Options.ExpirationCallback != null)
            {
                try
                {
                    item.Options.ExpirationCallback.Invoke(item.StoredObject);
                }
                catch (Exception e)
                {
#if DEBUG
                    PrintWarning($"Expiration callback for key '{key}' resulted in error | {e.Message}");
#endif
                }
            }
            else
            {
                if (item.StoredObject is IDisposable)
                {
                    var d = item.StoredObject as IDisposable;

                    try
                    {
                        d.Dispose();
                    }
                    catch (Exception e)
                    {
#if DEBUG
                        PrintWarning($"Failed to dispose IDisposable with key '{key}' | {e.Message}");
#endif
                    }
                }
            }

            _memoryCache.Remove(key);
#if DEBUG
            PrintWarning($"Removed cached item with key {key}");
#endif
        }

        public bool Add(string key, object item, CacheItemOptions options = null)
        {
            if (string.IsNullOrEmpty(key) || item == null)
            {
                return false;
            }

            if (options == null)
            {
                options = new CacheItemOptions();
            }

            if (!options.AbsoluteExpiration.HasValue && !options.SlidingExpiration.HasValue && !options.AbsoluteExpirationRelativeToNow.HasValue)
            {
                options.SlidingExpiration = TimeSpan.FromHours(1);
            }

            var now = DateTimeOffset.UtcNow;
            if (options.AbsoluteExpirationRelativeToNow.HasValue && !options.AbsoluteExpiration.HasValue)
            {
                options.AbsoluteExpiration = now + options.AbsoluteExpirationRelativeToNow.Value;
                options.AbsoluteExpirationRelativeToNow = null;
            }

            if (_memoryCache.ContainsKey(key))
            {
                ExpireItem(key, _memoryCache[key]);
            }

            _memoryCache[key] = new CacheItem()
            {
                Options = options,
                StoredObject = item,
                LastAccess = now
            };

#if DEBUG
            PrintWarning($"Cached new item with key {key} with value {item}");
#endif
            return true;
        }

        private bool Add(string key, object item, Action<object> expireCallback, DateTimeOffset? absoluteExpire, TimeSpan? slidingExpire)
        {
            if (string.IsNullOrEmpty(key) || item == null)
            {
                return false;
            }

            var options = new CacheItemOptions();

            if (absoluteExpire.HasValue)
            {
                options.AbsoluteExpiration = absoluteExpire;
                if (absoluteExpire >= DateTimeOffset.UtcNow)
                {
                    return false;
                }
            }

            if (slidingExpire.HasValue)
            {
                options.SlidingExpiration = slidingExpire;
            }

            if (expireCallback != null)
            {
                options.ExpirationCallback = expireCallback;
            }

            return Add(key, item, options);
        }

        private bool Add(string key, object item, Action<object> expireCallback, TimeSpan? slidingExpire) => Add(key, item, expireCallback, (DateTimeOffset?)null, slidingExpire);

        private bool Add(string key, object item, Action<object> expireCallback, DateTimeOffset? absoluteExpire) => Add(key, item, expireCallback, absoluteExpire, (TimeSpan?)null);

        private bool Add(string key, object item, TimeSpan? slidingExpire) => Add(key, item, (Action<object>)null, (DateTimeOffset?)null, slidingExpire);

        private bool Add(string key, object item, DateTimeOffset? absoluteExpire) => Add(key, item, null, absoluteExpire, null);

        private bool Add(string key, object item) => Add(key, item, (Action<object>)null, (DateTimeOffset?)null, (TimeSpan?)null);

        private object Get(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                return null;
            }

            var obj = (CacheItem)null;
            if (_memoryCache.TryGetValue(key, out obj))
            {
                if (IsExpired(obj, obj.Options, DateTimeOffset.UtcNow))
                {
                    ExpireItem(key, obj);
                    return null;
                }

                obj.LastAccess = DateTimeOffset.UtcNow;
                return obj.StoredObject;
            }

            return null;
        }

        public TCacheItem Get<TCacheItem>(string key) => (TCacheItem)Get(key);

        private bool Remove(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                return false;
            }

            if (_memoryCache.ContainsKey(key))
            {
                ExpireItem(key, _memoryCache[key]);
                return true;
            }

            return false;
        }
    }
}

// --- End of file: MemoryCache.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/more-resources-team ---
// --- Original File Path: M/MoreResourcesTeam/MoreResourcesTeam.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("More Resources Team", "Krungh Crow", "1.1.1")]
    [Description("Get more resources when you're farming close to a team member")]

    class MoreResourcesTeam : CovalencePlugin
    {
        #region Variables
        const string Use_Perm = "moreresourcesteam.use";
        const string Vip_Perm = "moreresourcesteam.vip";
        #endregion

        #region Configuration
        void Init()
        {
            if (!LoadConfigVariables())
            {
            Puts("Config file issue detected. Please delete file, or check syntax and fix.");
            return;
            }
            permission.RegisterPermission(Use_Perm, this);
            permission.RegisterPermission(Vip_Perm, this);
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty("Distance between you and your mates (in feet)")]
            public float distanceMate = 32f;
            [JsonProperty("Bonus percentage Default")]
            public int bonusMate = 10;
            [JsonProperty("Bonus percentage Vip")]
            public int bonusMateVip = 50;
        }

        private bool LoadConfigVariables()
        {
            try
            {
            configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
            return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GatherMoreMessage"] = "You got {0}% more because you're close to a member of your team"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GatherMoreMessage"] = "Vous avez re�u {0}% de ressources en plus car vous �tes proche d'un membre de votre �quipe"
            }, this, "fr");
        }

        #endregion

        #region Helpers

        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        private void notifyPlayer(IPlayer player, string text)
        {
            text = Formatter.ToPlaintext(text);
            player.Command("gametip.hidegametip");
            player.Command("gametip.showgametip", text);
            timer.In(5, () => player?.Command("gametip.hidegametip"));
        }
        #endregion

        #region Hooks

        void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (!permission.UserHasPermission(player.UserIDString, Use_Perm))
            {

                var currentTeam = player.currentTeam;
                if (currentTeam != 0)
                {
                    RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(currentTeam);
                    if (team != null)
                    {
                        var players = team.members;
                        if (team.members.Count > 1)
                        {
                            int totalPercentage = 0;
                            foreach (var teamMember in players)
                            {
                                if (teamMember != player.userID)
                                {
                                    BasePlayer member = RelationshipManager.FindByID(teamMember);
                                    if (member != null)
                                    {
                                        if (Vector3.Distance(player.transform.position, member.transform.position) <= configData.distanceMate)
                                        {
                                            if (permission.UserHasPermission(player.UserIDString, Vip_Perm))
                                            {
                                                totalPercentage = totalPercentage + configData.bonusMateVip;
                                                item.amount = item.amount + (item.amount * configData.bonusMateVip / 100);
                                            }
                                            else if (!permission.UserHasPermission(player.UserIDString, Vip_Perm))
                                            {
                                                totalPercentage = totalPercentage + configData.bonusMate;
                                                item.amount = item.amount + (item.amount * configData.bonusMate / 100);
                                            }
                                        }
                                    }
                                }
                            }
                            notifyPlayer(player.IPlayer, string.Format(GetMessage("GatherMoreMessage", player.UserIDString), totalPercentage.ToString()));
                        }
                    }
                }
            }
            return;
        }

        #endregion
    }
}

// --- End of file: MoreResourcesTeam.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-santa-panel ---
// --- Original File Path: M/MagicSantaPanel/MagicSantaPanel.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Magic Santa Panel", "MJSU", "1.0.2")]
    [Description("Displays if the santa event is active")]
    public class MagicSantaPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private List<SantaSleigh> _activeSleighs = new List<SantaSleigh>();
        private bool _init;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 1f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/vTdM8sLz/9wwPj3b.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.05f, 0.07f, 0.07f)
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "center",
                Order = config.PanelSettings?.Order ?? 11,
                Width = config.PanelSettings?.Width ?? 0.02f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _init = true;
            NextTick(() =>
            {
                _activeSleighs = UnityEngine.Object.FindObjectsOfType<SantaSleigh>().Where(CanShowPanel).ToList();
                MagicPanelRegisterPanels();
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                UnsubscribeAll();
                return;
            }

            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void CheckEvent()
        {
            if (_activeSleighs.Count == 0 || _activeSleighs.Count == 1)
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Image);
            }
        }
        
        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }
        #endregion

        #region uMod Hooks

        private void OnEntitySpawned(SantaSleigh santa)
        {
            if (!_init)
            {
                return;
            }
            
            NextTick(() =>
            {
                if (!CanShowPanel(santa))
                {
                    return;
                }

                _activeSleighs.Add(santa);
                CheckEvent();
            });
        }
        
        private void OnEntityKill(SantaSleigh santa)
        {
            if (!_activeSleighs.Remove(santa))
            {
                return;
            }

            CheckEvent();
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelImage image = panel.Image;
            if (image != null)
            {
                image.Color = _activeSleighs.Count != 0 ? _pluginConfig.ActiveColor : _pluginConfig.InactiveColor;
            }

            return panel.ToHash();
        }
        #endregion
        
        #region Helper Methods
        private bool CanShowPanel(SantaSleigh santa)
        {
            object result = Interface.Call("MagicPanelCanShow", Name, santa);
            if (result is bool)
            {
                return (bool) result;
            }

            return true;
        }
        #endregion

        #region Classes

        private class PluginConfig
        {
            [DefaultValue("#DC3545FF")]
            [JsonProperty(PropertyName = "Active Color")]
            public string ActiveColor { get; set; }

            [DefaultValue("#FFFFFF1A")]
            [JsonProperty(PropertyName = "Inactive Color")]
            public string InactiveColor { get; set; }

            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicSantaPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/my-digicode ---
// --- Original File Path: M/MyDigicode/MyDigicode.cs ---

using System.Collections.Generic;   //list.config
using System;   //Convert
using Oxide.Core;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("My Digicode", "BuzZ", "1.0.1")]
    [Description("Set a unique code for all codelocks, with autolock and remote options")]

/*======================================================================================================================= 
*   
*   30th december 2018
*
*   0.0.1   20181230    creation
*   1.0.0              code and new version#umod
*   1.0.1   20190907    +bool msg info on destroy
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*=======================================================================================================================*/

    public class MyDigicode : RustPlugin
    {
        bool debug = false;
        const string Digicoder = "mydigicode.user"; 
        const string AutoRemote = "mydigicode.auto"; 
        const string LockRemote = "mydigicode.lock"; 
        private bool ConfigChanged;
        bool loaded;

        string Prefix = "[DIGICODE] ";                       // CHAT PLUGIN PREFIX
        string PrefixColor = "#2eae00";                 // CHAT PLUGIN PREFIX COLOR
        ulong SteamIDIcon = 76561198413544653;          // SteamID FOR PLUGIN ICON
        bool destroy_info = false;

    class StoredData
    {
        public Dictionary<ulong, Digicode> playerdigicode = new Dictionary<ulong, Digicode>();

        public StoredData()
        {
        }
    }
        private StoredData storedData;

        public class Digicode
        {
            public string digicode;
            public bool autolock;
            public List<uint> uniques = new List<uint>();
        }
#region LOAD/UNLOAD
//////////////////////
// GET ALL DIGICODES ON LOAD - and analyse one by one
//////////////////////
        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(Digicoder, this);
            permission.RegisterPermission(AutoRemote, this);
            permission.RegisterPermission(LockRemote, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name); 
            TheWorldIsLocked();
        }

        void OnServerInitialized()
        {
            loaded = true;
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }
#endregion
#region LANG MESSAGES

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Do not have permission for this"},
            {"DigicodeMsg", "Your digicode is <color=orange>{0}</color>\ncode applied on {1} locks\nauto lock is <color=cyan>{2}</color>"},
            {"AutoModeMsg", "Auto lock mode for new codelock\nis now : <color=cyan>{0}</color>"},
            {"LockMsg", "Locking [{0}] codelock(s)"},
            {"UnlockMsg", "Unlocking [{0}] codelock(s)"},
            {"NoDataMsg", "No digicode data"},
            {"KilledMsg", "One of your codelock has disappeared"},
            {"ChangedMsg", "Your digicode has changed to : <color=orange>{0}</color>"},
            {"NewSpawnMsg", "Digicode <color=orange>{0}</color> applied to new CodeLock."},


        }, this, "en");

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"NoPermMsg", "Vous n'avez pas la permission pour cela."},
            {"DigicodeMsg", "Votre digicode est : <color=orange>{0}</color>\ncode appliqué à {1} serrures\nauto lock est <color=cyan>{2}</color>"},
            {"AutoModeMsg", "Mode Auto lock pour les nouvelles serrures\nest maintenant : <color=cyan>{0}</color>"},
            {"LockMsg", "Verrouillage de [{0}] serrure(s)"},
            {"UnlockMsg", "Déverrouillage de [{0}] serrure(s)"},
            {"NoDataMsg", "Pas de données enregistrées."},
            {"KilledMsg", "Une de vos serrures a été détruite."},
            {"ChangedMsg", "Votre digicode est maintenant : <color=orange>{0}</color>"},
            {"NewSpawnMsg", "Digicode <color=orange>{0}</color> enregistré sur une nouvelle serrure."},

        }, this, "fr");
    }

#endregion
#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[DIGICODE] "));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#2eae00"));                // CHAT PLUGIN PREFIX COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561198413544653"));
            destroy_info = Convert.ToBoolean(GetConfig("Message Settings", "Inform player when a lock is destroyed", false));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion
//////////////////////////////////////////////////////////////////////////////////////////////////////
#region SCAN ALL WOLRD codelocks
/////////////////////////
// WHOLE CODELOCK WORLD
/////////////////////////////
        void TheWorldIsLocked()
        {
            ResetAllCounters();
            foreach (var worldlocks in UnityEngine.Object.FindObjectsOfType<CodeLock>())
            {
                if (debug) Puts("FOUND ONE codelock");
                BaseEntity parent = worldlocks.GetParentEntity() as BaseEntity; //to use in future
                if (parent == null)
                {
                    if (debug) Puts("parent NULL !");
                    return;
                }
                if (parent.OwnerID == null)
                {
                    if (debug) Puts("parent owner is NULL");
                    return;
                }
                bool masterlocker = permission.UserHasPermission(parent.OwnerID.ToString(), Digicoder);
                if (!masterlocker) return;
                OneDigicodeAnalyze(worldlocks, parent, null);
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        void ResetAllCounters()
        {
            Dictionary<ulong, Digicode > tempplayerdigicode = new Dictionary<ulong, Digicode>();
            foreach (var item in storedData.playerdigicode)
            {
                Digicode now = new Digicode();
                now = item.Value;
                List<uint> IDz = new List<uint>();
                now.uniques = IDz;
                tempplayerdigicode.Add(item.Key, now);
            }
            storedData.playerdigicode = tempplayerdigicode;
        }
#endregion
#region SCAN ONE PLAYER codelocks population
//////////////////////
// ONE PLAYER CODELOCK WORLD
///////
        void MyWorldIsLocked(ulong playerID, string reason)
        {
            ResetMyCounter(playerID);
            foreach (var worldlocks in UnityEngine.Object.FindObjectsOfType<CodeLock>())
            {
                if (debug) Puts("FOUND ONE codelock");
                BaseEntity parent = worldlocks.GetParentEntity() as BaseEntity; //to use in future
                if (parent == null)
                {
                    if (debug) Puts("parent NULL !");
                    return;
                }
                if (parent.IsDestroyed) continue;
                if (parent.OwnerID == null)
                {
                    if (debug) Puts("parent owner is NULL");
                    return;
                }
                if (parent.OwnerID != playerID) return;
                OneDigicodeAnalyze(worldlocks, parent, reason);
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        void ResetMyCounter(ulong playerID)
        {
            Digicode now = new Digicode();
            foreach (var item in storedData.playerdigicode)
            {
                if (item.Key == playerID)
                {
                    now = item.Value;
                    now.uniques = new List<uint>();
                }
            }
            storedData.playerdigicode.Remove(playerID);
            storedData.playerdigicode.Add(playerID, now);
        }
#endregion
#region RANDOMIzator
///////////////////
// CODE RANDOMIZATOR
//////////////////////
        private string CodeRandomizor()
        {
            int random = Core.Random.Range(0, 9999);
            //string randomstring = Convert.ToString(random);
            string randomstring = random.ToString("0000");
            if (debug) Puts($"randomstring {randomstring}");
            return(randomstring);
        }
#endregion
#region ENTITY SPAWN HOOK
////////////////////////////////////////////
// NEW DIGICODE = new analyse
///////////////////
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!loaded) return; 
    	    CodeLock codelockcomponent = entity.GetComponent<CodeLock>();
            if (codelockcomponent != null)
            {
                if (debug) Puts($"CODELOCK SPAWNED IN WORLD !");
                bool masterlocker = permission.UserHasPermission(codelockcomponent.OwnerID.ToString(), Digicoder);
                if (masterlocker)
                {
                    BaseEntity parent = entity.GetParentEntity() as BaseEntity; //to use in future
                    if (parent == null)
                    {
                        if (debug) Puts("parent NULL !");
                        return;
                    }
                    if (parent.OwnerID == null)
                    {
                        if (debug) Puts("parent owner is NULL");
                        return;
                    }
                    OneDigicodeAnalyze(codelockcomponent, parent, "newspawn");
                }
            }
        }
#endregion
#region ANALYZE ONE codelock
//////////////////
// CODE ANALYZATOR
//////////////////
        void OneDigicodeAnalyze(CodeLock dacodelock, BaseEntity parent, string reason)
        {
            if (debug) Puts("OneDigicodeAnalyze");
            List<uint> IDz = new List<uint>();

            //BaseLock lockbase = dacodelock as BaseLock;   //future
            //BaseEntity  lockentity = dacodelock as BaseEntity;

            Digicode now = new Digicode();
            if (storedData.playerdigicode.ContainsKey(parent.OwnerID))
            {
                storedData.playerdigicode.TryGetValue(parent.OwnerID, out now);
                if (debug) Puts($"PLAYER ALREADY IN DATABASE !");
            }
            else
            {
                string randomized = CodeRandomizor();
                now.digicode = randomized;
                if (debug) Puts($"PLAYER ADDED in database - code {now.digicode} !");
            }
            if (now == null) return;
            if (debug) Puts($"APPLYING ONE CODE {now.digicode} !");
            IDz = now.uniques;
            IDz.Add(dacodelock.net.ID);
            dacodelock.code = now.digicode;
            now.uniques = IDz;
            storedData.playerdigicode.Remove(parent.OwnerID);
            storedData.playerdigicode.Add(parent.OwnerID, now);
            switch (reason)
            {
                case "newspawn" : 
                {
                    if (now.autolock) dacodelock.SetFlag(BaseEntity.Flags.Locked, true);
                    foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                    {
                        if (player.userID == parent.OwnerID)
                        {
                            Player.Message(player,String.Format(lang.GetMessage("NewSpawnMsg", this, player.UserIDString), now.digicode),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                        }
                    }
                    break;
                }
                case "lock" : 
                {
                    dacodelock.SetFlag(BaseEntity.Flags.Locked, true);
                    break;
                }      
                case "unlock" : 
                {
                    dacodelock.SetFlag(BaseEntity.Flags.Locked, false);
                    break;
                }    
            }
        }
#endregion
#region CHAT COMMANDS
//////////////////
// CHAT COMMAND : info
//////////////////////
        [ChatCommand("digi")]
        void MyDigicodeChatCommand(BasePlayer player, string command, string[] args)
        {
            bool masterlocker = permission.UserHasPermission(player.UserIDString, Digicoder);
            if (!masterlocker)
            {
                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                return;
            }
            Digicode now = new Digicode();
            List<uint> IDz = new List<uint>();
            if (storedData.playerdigicode.ContainsKey(player.userID))
            {
                storedData.playerdigicode.TryGetValue(player.userID, out now);
                if (debug) Puts($"PLAYER ALREADY IN DATABASE !");
                IDz = now.uniques;
                if (args.Length == 0)
                {
                    Player.Message(player,String.Format(lang.GetMessage("DigicodeMsg", this, player.UserIDString), now.digicode, IDz.Count, now.autolock),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                }
                if (args.Length == 1)
                {
                    switch (args[0].ToLower())
                    {
                        case "code" : 
                        {
                            if (debug) Puts($"PLAYER CHAT COMMAND code change !");
                            now.digicode = CodeRandomizor();
                            storedData.playerdigicode.Remove(player.userID);
                            storedData.playerdigicode.Add(player.userID, now);
                            MyWorldIsLocked(player.userID, null);
                            Player.Message(player,String.Format(lang.GetMessage("ChangedMsg", this, player.UserIDString), now.digicode),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            break;
                        }
                        case "auto" : 
                        {
                            if (debug) Puts($"PLAYER CHAT COMMAND mode autolock !");
                            bool autolocker = permission.UserHasPermission(player.UserIDString, AutoRemote);
                            if (!autolocker)
                            {
                                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                                return;
                            }
                            now.autolock = !now.autolock;
                            storedData.playerdigicode.Remove(player.userID);
                            storedData.playerdigicode.Add(player.userID, now);
                            Player.Message(player,String.Format(lang.GetMessage("AutoModeMsg", this, player.UserIDString), now.autolock),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            break;
                        }
                        case "lock" : 
                        {
                            if (debug) Puts($"PLAYER CHAT COMMAND lock all !");
                            bool remotelocker = permission.UserHasPermission(player.UserIDString, LockRemote);
                            if (!remotelocker)
                            {
                                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                                return;
                            }
                            Player.Message(player,String.Format(lang.GetMessage("LockMsg", this, player.UserIDString), now.uniques.Count),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            MyWorldIsLocked(player.userID, "lock");
                            break;
                        }
                        case "unlock" : 
                        {
                            if (debug) Puts($"PLAYER CHAT COMMAND unlock all !");
                            bool remotelocker = permission.UserHasPermission(player.UserIDString, LockRemote);
                            if (!remotelocker)
                            {
                                Player.Message(player, $"{lang.GetMessage("NoPermMsg", this, player.UserIDString)}",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                                return;
                            }
                            Player.Message(player,String.Format(lang.GetMessage("UnlockMsg", this, player.UserIDString), now.uniques.Count),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                            MyWorldIsLocked(player.userID, "unlock");
                            break;
                        }
                    }
                }
            }
            else
            {
                Player.Message(player, lang.GetMessage("NoDataMsg", this, player.UserIDString),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
            }
        }

#endregion
#region ENTITY KILL HOOK
//////////////
// KILL CODELOCK
///////////////////
        void OnEntityKill(BaseNetworkable Entity)
        {
            if (!loaded) return;
			if (Entity == null) return;
    	    CodeLock codelockcomponent = Entity.GetComponent<CodeLock>();
            if (codelockcomponent != null)
            {
                BaseEntity parent = codelockcomponent.GetParentEntity() as BaseEntity; //to use in future
                if (parent == null)
                {
                    if (debug) Puts("parent NULL !");
                    return;
                }
                if (parent.OwnerID == null)
                {
                    if (debug) Puts("parent owner is NULL");
                    return;
                }
                if (debug) Puts($"KILL one codelock from {parent.OwnerID}");
                foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                {
                    if (player.userID == parent.OwnerID && destroy_info)
                    {
                        Player.Message(player, lang.GetMessage("KilledMsg", this, player.UserIDString),$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                    }
                }
                MyWorldIsLocked(parent.OwnerID, null);
                Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            }
        }
#endregion
    }
}

// --- End of file: MyDigicode.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-block ---
// --- Original File Path: M/MapBlock/MapBlock.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Map Block", "Jacob", "1.0.0")]
    internal class MapBlock : RustPlugin
    {
        private MapMarkerGenericRadius _marker;

        private void OnPlayerInit(BasePlayer player) => UpdateMarker();

        private void OnServerInitialized()
        {
            _marker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", new Vector3(0, 100, 0)) as MapMarkerGenericRadius;
            _marker.alpha = 1;
            _marker.color1 = Color.black;
            _marker.color2 = Color.black;
            _marker.radius = ConVar.Server.worldsize;
            _marker.Spawn();
            _marker.SendUpdate();
        }

        private void Unload() => _marker?.Kill();

        private void UpdateMarker()
        {
            _marker.Kill();
            _marker.Spawn();
            _marker.SendUpdate();
        }
    }
}

// --- End of file: MapBlock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-queue-panel ---
// --- Original File Path: M/MagicQueuePanel/MagicQueuePanel.cs ---

﻿using System;
using System.ComponentModel;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Queue Panel", "MJSU", "1.0.3")]
    [Description("Displays queued players in magic panel")]
    public class MagicQueuePanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private int _queueCount;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.4f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/W1Q8KH1j/vNHFpsm.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .6f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "lefttop",
                Order = config.PanelSettings?.Order ?? 3,
                Width = config.PanelSettings?.Width ?? 0.045f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
            _queueCount = ServerMgr.Instance.connectionQueue.Queued;

            timer.Every(_pluginConfig.UpdateRate, () =>
            {
                int queued = ServerMgr.Instance.connectionQueue.Queued;
                if (queued != _queueCount)
                {
                    _queueCount = queued;
                    UpdatePanel();
                }
            });
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            UpdatePanel();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            UpdatePanel();
        }

        private void UpdatePanel()
        {
            NextTick(() =>
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
            });
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, ServerMgr.Instance.connectionQueue.Queued);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
            
            [DefaultValue(5f)]
            [JsonProperty(PropertyName = "Update Rates (Seconds)")]
            public float UpdateRate { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicQueuePanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/map-my-patrol ---
// --- Original File Path: M/MapMyPatrol/MapMyPatrol.cs ---

using System.Collections.Generic;	//dict
using Oxide.Game.Rust.Cui;
using UnityEngine;	//Vector3
using Oxide.Core.Plugins;
using Convert = System.Convert;
using System.Linq;

namespace Oxide.Plugins
{
	[Info("Map My Patrol", "BuzZ[PHOQUE]", "0.0.5")]
	[Description("Adds red marker(s) on ingame map for Heli Patrol(s) position, HUD with details, and refresh on timer.")]

/*======================================================================================================================= 
*
*   
*   20th august 2018
* 
*	0.0.4	configfile with sound/banner/bannercolor/HUDcolor/HUDfontsize
*	0.0.5	hud permi + hud mecha HUDlist + bannerlook
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*	https://umod.org/plugins/image-library to get little animation on HUD
*
*=======================================================================================================================*/


	public class MapMyPatrol : RustPlugin
	{
        [PluginReference]
        Plugin ImageLibrary;

		bool debug = false;
		int anim;
		string icondapatrol;
        private bool ConfigChanged;
        const string MapMyPatrolHUD = "mapmypatrol.hud"; 
		bool sound = false;
		bool bannerdisplay = false;
		string bannercolor = "0.5 0.5 0.5 0.30";
		string HUDcolor = "0.5 0.5 0.5 0.30";
		int HUDfontsize = 10;
		
        public Dictionary<BaseHelicopter, MapMarkerGenericRadius> baseradius = new Dictionary<BaseHelicopter, MapMarkerGenericRadius>();
        public Dictionary<BaseHelicopter, Vector3> baseposition = new Dictionary<BaseHelicopter, Vector3>();
        public Dictionary<BaseHelicopter, string> basemessage = new Dictionary<BaseHelicopter, string>();
        public Dictionary<BaseHelicopter, PatrolHelicopterAI> baseai = new Dictionary<BaseHelicopter, PatrolHelicopterAI>();
        public Dictionary<BaseHelicopter, BaseCombatEntity> basecombat = new Dictionary<BaseHelicopter, BaseCombatEntity>();
        public Dictionary<BaseHelicopter, BaseEntity> baseent = new Dictionary<BaseHelicopter, BaseEntity>();
		public Dictionary<string, BasePlayer> HUDlist = new Dictionary<string, BasePlayer>();

		private Timer patrolrefresh;

/*	FOR FUTURE VERSIONS
https://image.ibb.co/eCiHqK/Map_My_Patrol_icone_HUD_blue.png
https://image.ibb.co/i2RsPe/Map_My_Patrol_icone_HUD_fullgreen.png
https://image.ibb.co/dJYTxz/Map_My_Patrol_icone_HUD_fullred.png
https://image.ibb.co/npaK4e/Map_My_Patrol_icone_HUD_green.png
https://image.ibb.co/mJVmje/Map_My_Patrol_icone_HUD_purple.png
https://image.ibb.co/bYrsPe/Map_My_Patrol_icone_HUD_red.png
*/
        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(MapMyPatrolHUD, this);
        }

        void Loaded()
        {
			ulong imageId = 666999666999;
			if (ImageLibrary)
			{
				bool exists = (bool)ImageLibrary?.Call ("HasImage", "mapmypatrolblue", imageId);
				if (exists == false)
				{
//					ImageLibrary?.Call ("AddImage","https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Maki-heliport-15.svg/240px-Maki-heliport-15.svg.png", "mapmypatrolblack", imageId);
					ImageLibrary?.Call ("AddImage","https://image.ibb.co/eCiHqK/Map_My_Patrol_icone_HUD_blue.png", "mapmypatrolblue", imageId);
					if (debug) {Puts($"ADDING ICON TO ImageLibrary");}
				}
				if (debug) {Puts($"LOADING ICON from ImageLibrary");}
				icondapatrol = (string)ImageLibrary?.Call ("GetImage","mapmypatrolblue", imageId);
			}
			if (ImageLibrary == false)
			{
				PrintWarning($"You are missing plugin reference : ImageLibrary");
			}
		}

		void Unload()
		{
			foreach (var paire in baseradius)
			{
				paire.Value.Kill();
            	paire.Value.SendUpdate();
				if (debug)  Puts($"PATROL MAPMARKER KILLED");
				/*baseradius.Clear();
				basemessage.Clear();
				baseposition.Clear();
				baseai.Clear();
				basecombat.Clear();
				baseent.Clear();*/
			}
			foreach (var playerhud in HUDlist)
			{
				CuiHelper.DestroyUi(playerhud.Value, playerhud.Key);
			}
		}


#region MESSAGES

    void LoadDefaultMessages()
    {

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"SpawnMsg", "A Patrol has spawned and will fly above Island in a few. Check your MAP (G) for a red marker."},
            {"KilledMsg", "A Patrol has gone away from Island."},

			
        }, this, "en");

        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"SpawnMsg", "Une patrouille est en route pour l'île. Un marqueur rouge est rajouté sur la carte (G)"},
            {"KilledMsg", "Une patrouille a quitté l'île."},
        }, this, "fr");
    }


#endregion


#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            /*Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[My CH47] "));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#149800"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#bbffb1"));                    // CHAT MESSAGE COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561198332562475"));*/       
            sound = Convert.ToBoolean(GetConfig("Sound Settings", "play soundfx", "false"));
            bannerdisplay = Convert.ToBoolean(GetConfig("Banner Settings", "display banner", "false"));
            HUDfontsize = Convert.ToInt32(GetConfig("HUD Settings", "font size", "10"));
            HUDcolor = Convert.ToString(GetConfig("HUD Settings", "color on 3 firsts numbers - opacity on last number", "0.5 0.5 0.5 0.30"));      
            bannercolor = Convert.ToString(GetConfig("Banner Settings", "color on 3 firsts numbers - opacity on last number", "0.5 0.5 0.5 0.30"));      

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion


        void MarkerDisplayingDelete(BaseHelicopter delpatrol)
        {
			if (baseradius.ContainsKey(delpatrol) == true)
			{
				MapMarkerGenericRadius delmarker;
				baseradius.TryGetValue(delpatrol, out delmarker);
				delmarker.Kill();
            	delmarker.SendUpdate();
				if (debug) {Puts($"PATROL MAPMARKER KILLED");}
			}
		}

        void GenerateMarkers()
		{
			if (baseradius != null)
			{
				foreach (var paire in baseradius)
				{
					MapMarkerGenericRadius MapMarkerDel = paire.Value;
					if (MapMarkerDel != null)
					{
						MapMarkerDel.Kill();
						MapMarkerDel.SendUpdate();
					}
				}
			}


			foreach (var nelico in baseposition)
			{
				Vector3 position = nelico.Value;
				MapMarkerGenericRadius MapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", position) as MapMarkerGenericRadius;
				MapMarker.alpha = 0.6f;
				MapMarker.color1 = Color.red;
				MapMarker.color2 = Color.black;
				MapMarker.radius = 8;
				baseradius.Remove(nelico.Key);
				baseradius.Add(nelico.Key, MapMarker);
				if (debug) {Puts($"PATROL MARKER SPAWNED ON MAP");}
			}
			foreach (var paire in baseradius)
			{
				paire.Value.Spawn();
            	paire.Value.SendUpdate();
			}
		}

#region HUD

		private void PatrolHUD()
		{
			int patrolnum = basemessage.Count;
			anim = anim + 1;
			double colonnegauche = 0.00;
			colonnegauche = colonnegauche + (anim * 0.16);
			if (colonnegauche > 0.89)
			{
				anim = 0;
				colonnegauche = 0.00;
			}
			double colonnedroite = colonnegauche + 0.15;
			double lignehaut = 0.80;
			double lignebas = lignehaut - 0.10;
            int Round = 1;
            int round = -1;
			List<string> messagelist = new List<string>();
			List<BaseHelicopter> helilist = new List<BaseHelicopter>();
			List<PatrolHelicopterAI> ailist = new List<PatrolHelicopterAI>();
			string[] messagearray;			
			BaseHelicopter[] heliarray;
			PatrolHelicopterAI[] aiarray;
			foreach (var paire in basemessage)
			{
				messagelist.Add(paire.Value);
				helilist.Add(paire.Key);
				if (baseai.ContainsKey(paire.Key) == true)
				{
					PatrolHelicopterAI ai;
					baseai.TryGetValue(paire.Key, out ai);
					ailist.Add(ai);
				}
			}
			messagearray = messagelist.ToArray();
			heliarray = helilist.ToArray();
			aiarray = ailist.ToArray();
			if (debug) {Puts($"BaseMessage COUNT : {messagelist.Count}");}
            for (Round = 1; Round <= patrolnum ; Round++)     
            {
                round = round + 1;
				double lignedecalage = 0.11 * round;
				var CuiElement = new CuiElementContainer();
				var PatrolHUDBanner = CuiElement.Add(new CuiPanel{Image ={Color = HUDcolor},RectTransform ={AnchorMin = $"0.0 {lignebas - lignedecalage}",AnchorMax = $"0.08 {lignehaut - lignedecalage}"},CursorEnabled = false});
					/*var closeButton = new CuiButton{Button ={Close = PatrolHUDBanner,Color = "0.0 0.0 0.0 0.6"},RectTransform ={AnchorMin = "0.90 0.00",AnchorMax = "0.99 1.00"},Text ={Text = "X",FontSize = 20,Align = TextAnchor.MiddleCenter}};
					CuiElement.Add(closeButton, PatrolHUDBanner);       */       		
				foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
				{
					Vector3 basepos;
					baseposition.TryGetValue(heliarray[round], out basepos);
					int dist = (int)Vector3.Distance(player.transform.position, basepos);
					string finalmessage = $": <color=orange>{dist}m.</color> away.{messagearray[round]}";
					PatrolHelicopterAI myAI = aiarray[round];
					if (myAI.PlayerVisible(player) == true)
					{
						if (debug) {Puts($"PLAYER {player.displayName} IS VISIBLE !");}
						finalmessage = $"{finalmessage}\n<color=red>YOU ARE VISIBLE</color>";
					}
					CuiElement.Add(new CuiLabel{Text ={Text = $"<color=white>#{round+1}</color> {finalmessage}",FontSize = HUDfontsize,Align = TextAnchor.MiddleLeft,Color = "0.0 0.0 0.0 1"},RectTransform ={AnchorMin = "0.10 0.10",   AnchorMax = "0.90 0.79"}
					}, PatrolHUDBanner);
					if (ImageLibrary)
					{
						CuiElement.Add(new CuiElement
						{
							Name = CuiHelper.GetGuid(),
							Parent = PatrolHUDBanner,
							Components =
								{
									new CuiRawImageComponent {Png = icondapatrol},
									new CuiRectTransformComponent {AnchorMin = $"{colonnegauche} 0.80", AnchorMax = $"{colonnedroite} 0.99"}
								}
						});
					}
					bool displayhud = permission.UserHasPermission(player.UserIDString, MapMyPatrolHUD);
					if (displayhud)
					{
						CuiHelper.AddUi(player, CuiElement);
						HUDlist.Remove(PatrolHUDBanner);
						HUDlist.Add(PatrolHUDBanner, player);
					}
				}
			}

		}

		private void DestroyAllUiPlease()
		{
			foreach (var playerhud in HUDlist)
			{
				CuiHelper.DestroyUi(playerhud.Value, playerhud.Key);
			}
			HUDlist.Clear();
		}

#endregion

#region SPAWN DETECTION

        private void OnEntitySpawned(BaseEntity Entity)
        {

            if (Entity == null) return;
            if (Entity is BaseHelicopter)
            {
				anim = 0;
				BaseHelicopter helicopter = Entity as BaseHelicopter;  
				baseent.Add(helicopter, Entity);
				var position = Entity.ServerPosition;
				baseposition.Remove(helicopter);
				baseposition.Add(helicopter, position);
				PatrolHelicopterAI AI = Entity.GetComponent<PatrolHelicopterAI>();
				baseai.Add(helicopter, AI);
				BaseCombatEntity pat = Entity as BaseCombatEntity;
				basecombat.Add(helicopter, pat);
				//GenerateMarkers(helicopter);
				DisplayBannerToAll("spawn");
				if (debug) {Puts($"BEFORE TIMER - IN BasePosition : {baseposition.Count}");}	// bonus info
				if (patrolrefresh == null)
				{
					AfterSpawn();
					if (debug) {Puts($"TIMER IS NULL");}
					patrolrefresh = timer.Repeat(5f, 0, () =>
					{
						DestroyAllUiPlease();
						AfterSpawn();
					});
				}
		    }
		}
#endregion


		void AfterSpawn()
		{
			if (debug) {Puts($"VOID AFTERSPAWN");}	// bonus info
			foreach (var paire in baseent)
			{
				if (debug) {Puts($"AI COUNT : {baseent.Count}");}	// bonus info
				BaseEntity Entity2;
				Entity2 = paire.Value;
				BaseHelicopter helicopter = paire.Key;	
				PatrolHelicopterAI myAI;
				baseai.TryGetValue(helicopter, out myAI);
				BaseCombatEntity patrol;
				basecombat.TryGetValue(helicopter, out patrol);
				var position2 = Entity2.ServerPosition;
				if (debug) {Puts($"ENTITY NEW POSITION : {position2} - SPEED {myAI.moveSpeed}");}
				baseposition.Remove(helicopter);
				baseposition.Add(helicopter, position2);
				if (debug) Puts($"Left Rockets : {myAI.numRocketsLeft}");
				if (debug) Puts($"DESTINATION : {myAI.destination}");
				if (debug) Puts($"SPAWNTIME : {myAI.spawnTime}");
				string names = "";
				string message = "";
				message = $"\nSpeed : <size=11><color=cyan>{myAI.moveSpeed}</color></size>\nLeft Rockets : <size=11><color=cyan>{myAI.numRocketsLeft}</color></size>";
				basemessage.Remove(helicopter);
				basemessage.Add(helicopter, message);
			}		
			PatrolHUD();
			GenerateMarkers();
		}

#region ON PATROL KILL

		void OnEntityKill(BaseCombatEntity Entity, HitInfo info)
		{
			if (Entity == null) return;
			if (Entity is BaseHelicopter)
			{	
				BaseHelicopter helicopterkilled = Entity as BaseHelicopter;  
				if (baseent.ContainsKey(helicopterkilled) == true)
				{
					DisplayBannerToAll("killed");
					MarkerDisplayingDelete(helicopterkilled);
					baseradius.Remove(helicopterkilled);
					basemessage.Remove(helicopterkilled);
					baseposition.Remove(helicopterkilled);
					baseai.Remove(helicopterkilled);
					basecombat.Remove(helicopterkilled);
					baseent.Remove(helicopterkilled);
					if (baseent.Count == 0)
					{
						DestroyAllUiPlease();
						patrolrefresh.Destroy();
						//patrolrefresh = null;
						if (debug) {Puts($"PATROL IS NO MORE. TIMER DESTROYED");}
						baseradius.Clear();
						basemessage.Clear();
						baseposition.Clear();
						baseai.Clear();
						basecombat.Clear();
						baseent.Clear();
					}
				}
			}
		}

#endregion

#region BANNER

		void DisplayBannerToAll(string reason)
		{
			foreach (var player in BasePlayer.activePlayerList)
			{
				if (bannerdisplay)
				{
					string message = string.Empty;
					if (reason == "spawn") message = $"{lang.GetMessage("SpawnMsg", this, player.UserIDString)}";
					if (reason == "killed") message = $"{lang.GetMessage("KilledMsg", this, player.UserIDString)}";
					var CuiElement = new CuiElementContainer();
					var PatrolBanner = CuiElement.Add(new CuiPanel{Image ={Color = bannercolor},RectTransform ={AnchorMin = "0.0 0.85",AnchorMax = "1.0 0.88"},CursorEnabled = false});                   
					var closeButton = new CuiButton{
						Button ={Close = PatrolBanner,Color = "0.0 0.0 0.0 0.6"},RectTransform ={AnchorMin = "0.90 0.01",AnchorMax = "0.99 0.99"},Text ={Text = "X",FontSize = 12,Align = TextAnchor.MiddleCenter}};
					CuiElement.Add(closeButton, PatrolBanner);         
					CuiElement.Add(new CuiLabel{
						Text ={Text = $"{message}",FontSize = 14,Align = TextAnchor.MiddleCenter,Color = "1.0 1.0 1.0 1"},RectTransform ={AnchorMin = "0.10 0.10",   AnchorMax = "0.90 0.90"}
						}, PatrolBanner);

					CuiHelper.AddUi(player, CuiElement);
					timer.Once(12, () =>
						{
							CuiHelper.DestroyUi(player, PatrolBanner);
						});
					if (debug) {Puts($"BANNER DISPLAYING FOR PLAYER {player.displayName}");}
				}
				if (sound)
				{
					var sound = new Effect("assets/bundled/prefabs/fx/player/howl.prefab", player, 0, Vector3.zero, Vector3.forward);
					EffectNetwork.Send(sound, player.net.connection);
					if (debug) {Puts($"PLAYING SOUND FOR PLAYER {player.displayName}");}
				}
			}
		}

#endregion

	}
}


/*

FOR FUTURE VERSIONS
change icon color on behaviour (red on attack/blue on visible/etc.)

	public float lastSeenTime = float.PositiveInfinity;
	public float visibleFor;
	public Vector3 destination;
	public float moveSpeed;
	public float throttleSpeed;
	public aiState _currentState;
	private Vector3 _aimTarget;
	private bool movementLockingAiming;
	private bool hasAimTarget;
	private bool aimDoorSide;
	private Vector3 _lastPos;
	private Vector3 _lastMoveDir;
	public bool isDead;
	private bool isRetiring;
	public float spawnTime;
	public float lastDamageTime;
	public List<targetinfo> _targetList = new List<targetinfo>();
	public List<MonumentInfo> _visitedMonuments;
	public float arrivalTime;
	public float lastRocketTime;

 */

// --- End of file: MapMyPatrol.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/murderers ---
// --- Original File Path: M/Murderers/Murderers.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;
using Rust;
using Rust.Ai;

#region Changelogs and ToDo

/**********************************************************************
* 
*   1.1.0   Cleanup and refacturing
*           Added Debug option
*           Changed murderer for ScarecrowNPC
*           Added npc health
*           Added npc random names
*           Added support for Kits and use random kits from list
*           Added support for Chainsaw when used
*           Added NpcKits block (plugin) to avoid overriding current kits
*           Improved info through responce messages
*           Added option to change displayname as murderer or scarecrow (npc will remain scarecrow)
*           Removed Wipe command (was giving issues)
*   1.1.1   Fix for some Compiler issues
*           Reformatted Turret targeting
*           Added check if kits is installed
*   1.1.2   Patch by Whispers88
*   1.1.3   Fix for compiler issues
*           
**********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Murderers", "Krungh Crow", "1.1.3")]
    [Description("Murderers Reborn")]
    class Murderers : RustPlugin
    {
        [PluginReference]
        Plugin Kits;

        #region Variable

        ulong chaticon = 0;
        string prefix;
        bool Debug = false;
        public string Kit;
        public bool Turret_Safe;
        public bool Animal_Safe;
        public bool SpawnScarecrow;
        private const string _PermKill = "murderers.kill";
        private const string _PermAddLoc = "murderers.point";
        private const string _PermSpawn = "murderers.spawn";
        private Dictionary<string, int> murdersPoint = new Dictionary<string, int>();
        private Dictionary<ulong, string> npcCreated = new Dictionary<ulong, string>();
        private string npcPrefab = "assets/prefabs/npc/scarecrow/scarecrow.prefab";
        int npcCoolDown;

        #endregion

        #region Configuration
        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }

            permission.RegisterPermission(_PermKill, this);
            permission.RegisterPermission(_PermAddLoc, this);
            permission.RegisterPermission(_PermSpawn, this);

            Debug = configData.PlugCFG.Debug;
            prefix = configData.PlugCFG.Prefix;
            chaticon = configData.PlugCFG.Chaticon;
            if (Debug) Puts($"[Debug] trigger for Debug is true");

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("murdersPoint"))
            {
                if (Debug) Puts(msg("AddPoint"));
                return;
            }
            murdersPoint = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, int>>("murdersPoint");
            npcCoolDown = configData.NPCCFG.RespawnTime;
            Kit = configData.NPCCFG.KitName.ToString();
            Turret_Safe = configData.NPCCFG._TurretSafe;
            Animal_Safe = configData.NPCCFG._AnimalSafe;
            SpawnScarecrow = configData.NPCCFG.Scarecrow;
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Main config")]
            public SettingsPlugin PlugCFG = new SettingsPlugin();
            [JsonProperty(PropertyName = "NPC config")]
            public SettingsNPC NPCCFG = new SettingsNPC();
        }

        class SettingsPlugin
        {
            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong Chaticon = 0;
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix = "[<color=yellow>Murderers<color=red>Reborn</color></color>] ";
        }

        class SettingsNPC
        {
            [JsonProperty(PropertyName = "Spawn as Scarecrow (displayname only)")]
            public bool Scarecrow = true;
            [JsonProperty(PropertyName = "Health (HP)")]
            public int NPCHealth = 150;
            [JsonProperty(PropertyName = "Respawn time (seconds)")]
            public int RespawnTime = 300;
            [JsonProperty(PropertyName = "AnimalSafe")]
            public bool _AnimalSafe = true;
            [JsonProperty(PropertyName = "TurretSafe")]
            public bool _TurretSafe = true;
            [JsonProperty(PropertyName = "Kit ID")]
            public List<string> KitName = new List<string>();
        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Remove"] = "Removing all Murderers",
                ["Delete"] = "Removing all Murderers Points",
                ["StartSpawn"] = "Start spawning all Murderers on their points",
                ["SavePoint"] = "Saving spawn location {0}",
                ["SaveConsole"] = "{0} Saving spawn location {1}",
                ["EndSpawn"] = "All Murderers spawned on their points",
                ["Added"] = "Added Murderers point to Data-file!",
                ["AddPoint"] = "No Murderers points found! Add new!"
            }, this);
        }

        #endregion

        #region Initialize <---- Obsolete needs to be converted

        private void OnServerInitialized()
        {
            startSpawn();
        }

        private void Unload()
        {
            Kill();
        }
        #endregion

        #region FacepunchBehaviour

        #region Scarecrow
        private class Zombies : FacepunchBehaviour
        {
            private ScarecrowNPC npc;
            public bool ReturningToHome = false;
            public bool isRoaming = true;
            public Vector3 SpawnPoint;

            private void Awake()
            {
                npc = GetComponent<ScarecrowNPC>();
                Invoke(nameof(_UseBrain), 0.1f);
                InvokeRepeating(Attack, 0.1f, 1.5f);
                InvokeRepeating(GoHome, 2.0f, 4.5f);
            }

            private void Attack()
            {
                BaseEntity entity = npc.Brain.Senses.GetNearestThreat(40);
                Chainsaw heldEntity = npc.GetHeldEntity() as Chainsaw;
                if (entity == null || Vector3.Distance(entity.transform.position, npc.transform.position) > 30.0f)
                {
                    npc.Brain.Navigator.ClearFacingDirectionOverride();
                    GoHome();
                }
                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) < 2.0f)
                {
                    npc.StartAttacking(entity);
                    npc.Brain.Navigator.SetFacingDirectionEntity(entity);
                    if (heldEntity is Chainsaw)
                    {
                        if (!(heldEntity as Chainsaw).EngineOn())
                        {
                            (heldEntity as Chainsaw).ServerNPCStart();
                        }
                        heldEntity.SetFlag(BaseEntity.Flags.Busy, true, false, true);
                        heldEntity.SetFlag(BaseEntity.Flags.Reserved8, true, false, true);
                    }
                }

                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) > 1.5f)
                {
                    if (heldEntity is Chainsaw)
                    {
                        if (!(heldEntity as Chainsaw).EngineOn())
                        {
                            (heldEntity as Chainsaw).ServerNPCStart();
                        }
                        heldEntity.SetFlag(BaseEntity.Flags.Busy, false, false, true);
                        heldEntity.SetFlag(BaseEntity.Flags.Reserved8, false, false, true);
                    }
                }

                if (entity != null && Vector3.Distance(entity.transform.position, npc.transform.position) > 2.0f)
                {
                    npc.Brain.Navigator.SetFacingDirectionEntity(entity);
                }
            }

            public void _UseBrain()
            {
                #region navigation
                npc.Brain.Navigator.Agent.agentTypeID = -1372625422;
                npc.Brain.Navigator.DefaultArea = "Walkable";
                npc.Brain.Navigator.Agent.autoRepath = true;
                npc.Brain.Navigator.enabled = true;
                npc.Brain.Navigator.CanUseNavMesh = true;
                npc.Brain.Navigator.BestRoamPointMaxDistance = 20f;
                npc.Brain.Navigator.MaxRoamDistanceFromHome = 20f;
                npc.Brain.Navigator.Init(npc, npc.Brain.Navigator.Agent);
                npc.Brain.Navigator.SetDestination(SpawnPoint, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
                #endregion

                #region senses & Targeting
                npc.Brain.ForceSetAge(0);
                npc.Brain.AllowedToSleep = false;
                npc.Brain.sleeping = false;
                npc.Brain.SenseRange = 30f;
                npc.Brain.ListenRange = 40f;
                npc.Brain.Senses.Init(npc, npc.Brain, 30, 40f, 135f,100f, true, true, true, 60f, false, false, true, EntityType.Player, true);
                npc.Brain.TargetLostRange = 20f;
                npc.Brain.HostileTargetsOnly = false;
                npc.Brain.IgnoreSafeZonePlayers = true;
                #endregion
            }

            void GoHome()
            {
                if (npc == null || npc.IsDestroyed || npc.isMounted)
                    return;

                if (!npc.HasBrain)
                    return;
                if (npc.Brain.Senses.Memory.Targets.Count > 0)
                {
                    for (var i = 0; i < npc.Brain.Senses.Memory.Targets.Count; i++)
                    {
                        BaseEntity target = npc.Brain.Senses.Memory.Targets[i];
                        BasePlayer player = target as BasePlayer;

                        if (target == null || !player.IsAlive() || player.IsSleeping() || player.IsFlying)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                        if (npc.Distance(player.transform.position) > 25f)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                        if (player.IsSleeping() || player.IsFlying)
                        {
                            WipeMemory();
                            ReturningToHome = true;
                            isRoaming = false;
                            return;
                        }
                    }
                }

                var distanceHome = Vector3.Distance(npc.transform.position, SpawnPoint);
                if (ReturningToHome == false)
                {
                    if (isRoaming == true && distanceHome > 20f)
                    {
                        ReturningToHome = true;
                        isRoaming = false;
                        return;
                    }
                    if (isRoaming == true && distanceHome < 20f)
                    {
                        SettargetDestination(SpawnPoint);
                        return;
                    }
                }
                if (ReturningToHome && distanceHome > 2)
                {
                    if (npc.Brain.Navigator.Destination == SpawnPoint)
                    {
                        return;
                    }

                    WipeMemory();
                    SettargetDestination(SpawnPoint);
                    return;
                }
                ReturningToHome = false;
                isRoaming = true;
            }

            private void SettargetDestination(Vector3 position)
            {
                npc.Brain.Navigator.Destination = position;
                npc.Brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Slow, 0f, 0f);
            }

            void WipeMemory()
            {
                if (!npc.HasBrain)
                {
                    return;
                }

                npc.Brain.Senses.Players.Clear();
                npc.Brain.Senses.Memory.Players.Clear();
                npc.Brain.Senses.Memory.Targets.Clear();
                npc.Brain.Senses.Memory.Threats.Clear();
                npc.Brain.Senses.Memory.LOS.Clear();
                npc.Brain.Senses.Memory.All.Clear();
            }

            void OnDestroy()
            {
                if (npc != null && !npc.IsDestroyed)
                {
                    npc.Kill();
                }
                CancelInvoke(GoHome);
                CancelInvoke(Attack);
                CancelInvoke(nameof(_UseBrain));
            }
        }
        #endregion

        #endregion

        #region Hooks
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (npcCreated.ContainsKey(entity.net.ID.Value))
            {
                startSpawn(npcCreated[entity.net.ID.Value]);
                npcCreated.Remove(entity.net.ID.Value);
            }
        }

        object CanBeTargeted(ScarecrowNPC target, MonoBehaviour turret)//stops autoturrets targetting bots
        {
            if (target != null && Turret_Safe) return false;
            return null;
        }

        object CanNpcAttack(BaseNpc npc, BaseEntity target) //nulls animal damage to bots
        {
            if (target is ScarecrowNPC && Animal_Safe) return true;
            return null;
        }


        #endregion

        #region external hooks

        #region NpcKits plugin
        object OnNpcKits(BasePlayer player)
        {
            if (player?.gameObject?.GetComponent<Zombies>() != null)
                return true;
            return null;
        }
        #endregion

        #endregion

        #region Helpers
        void startSpawn(string position = null)
        {
            var _Health = configData.NPCCFG.NPCHealth;

            if (position != null)
            {
                timer.Once(npcCoolDown, () =>
                {
                    ScarecrowNPC npc = (ScarecrowNPC)GameManager.server.CreateEntity(npcPrefab, position.ToVector3(), new Quaternion(), true);
                    if (npc != null)
                        npc.Spawn();
                    Vector3 pos = npc.transform.position;

                    npc.displayName = "Scarecrow" + " " + RandomUsernames.Get((int)npc.userID.Get());
                    if (SpawnScarecrow == false)
                    {
                        npc.inventory.containerWear.Clear();
                        npc.displayName = "Murderer" + " " + RandomUsernames.Get((int)npc.userID.Get());
                    }
                    NextTick(() =>
                    {
                        if (npc == null) return;

                        var mono = npc.gameObject.AddComponent<Zombies>();
                        mono.SpawnPoint = pos;
                        npc.startHealth = _Health;
                        npc.InitializeHealth(_Health, _Health);
                        if (Kits && configData.NPCCFG.KitName.Count > 0)
                        {
                            object checkKit = Kits?.CallHook("GetKitInfo", configData.NPCCFG.KitName[new System.Random().Next(configData.NPCCFG.KitName.Count())]);
                            if (checkKit == null)
                            {
                                if (Debug) Puts("Kit does not exist!");
                            }
                            else
                            {
                                npc.inventory.containerWear.Clear();
                                Kits?.Call($"GiveKit", npc, configData.NPCCFG.KitName[new System.Random().Next(configData.NPCCFG.KitName.Count())]);
                            }
                        }
                        npc.SendNetworkUpdate();
                    });
                });
                return;
            }

            foreach (var check in murdersPoint)
            {
                ScarecrowNPC npc = (ScarecrowNPC)GameManager.server.CreateEntity(npcPrefab, check.Key.ToVector3(), new Quaternion(), true);
                if (npc != null)
                    npc.Spawn();

                Vector3 pos = npc.transform.position;

                npc.displayName = "Scarecrow" + " " + RandomUsernames.Get((int)npc.userID.Get());
                if (SpawnScarecrow == false)
                {
                    npc.inventory.containerWear.Clear();
                    npc.displayName = "Murderer" + " " + RandomUsernames.Get((int)npc.userID.Get());
                }

                npcCreated.Add(npc.net.ID.Value, check.Key);
                NextTick(() =>
                {
                    if (npc == null) return;

                    var mono = npc.gameObject.AddComponent<Zombies>();
                    mono.SpawnPoint = pos;
                    npc.startHealth = _Health;
                    npc.InitializeHealth(_Health, _Health);
                    if (Kits && configData.NPCCFG.KitName.Count > 0)
                    {
                        object checkKit = Kits?.CallHook("GetKitInfo", configData.NPCCFG.KitName[new System.Random().Next(configData.NPCCFG.KitName.Count())]);
                        if (checkKit == null)
                        {
                            if (Debug) Puts("Kit does not exist!");
                        }
                        else
                        {
                            npc.inventory.containerWear.Clear();
                            Kits?.Call($"GiveKit", npc, configData.NPCCFG.KitName[new System.Random().Next(configData.NPCCFG.KitName.Count())]);
                        }
                    }
                    npc.SendNetworkUpdate();
                });
            }
            if (Debug) Puts(msg("EndSpawn"));
        }

        void Kill()
        {
            foreach (var check in npcCreated)
            {
                BaseNetworkable.serverEntities.Find(new NetworkableId(check.Key)).Kill();
            }
        }

        private void Reload()
        {
            Interface.Oxide.ReloadPlugin("Murderers");
            startSpawn();
        }

        #endregion

        #region Console Commands
        [ConsoleCommand("m.spawn")]
        void CmdSpawn(ConsoleSystem.Arg arg)
        {
            Zombies[] zombies = UnityEngine.Object.FindObjectsOfType<Zombies>();
            if (zombies != null)
            {
                foreach (Zombies zombie in zombies)
                    UnityEngine.Object.Destroy(zombie);
            }
            startSpawn();
        }

        [ConsoleCommand("m.kill")]
        void CmdBotKill(ConsoleSystem.Arg arg)
        {
            Kill();
        }
        #endregion

        #region chat commands
        [ChatCommand("m.spawn")]
        void npcSpawn(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, _PermSpawn)) return;
            Zombies[] zombies = UnityEngine.Object.FindObjectsOfType<Zombies>();
            if (zombies != null)
            {
                foreach (Zombies zombie in zombies)
                    UnityEngine.Object.Destroy(zombie);
            }
            startSpawn();
            {
                Player.Message(player, prefix + string.Format(msg("StartSpawn", player.UserIDString)), chaticon);
            }
        }

        [ChatCommand("m.point")]
        void npcMain(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _PermAddLoc)) return;
            {
                int amount = 1;

                if (args.Length == 1 && Int32.Parse(args[0]) > 0)
                {
                    amount = Int32.Parse(args[0]);
                }
                var location = player.transform.position.ToString();
                murdersPoint.Add(location, amount);
                Interface.Oxide.DataFileSystem.WriteObject("murdersPoint", murdersPoint);
                if (Debug) Puts(msg($"{player} created a new spawn location at {location}"));
                Player.Message(player, prefix + string.Format(msg("SavePoint", player.UserIDString), location), chaticon);
                timer.Once(3.0f, () =>
                {
                    startSpawn();
                    if (Debug) Puts(msg("StartSpawn"));
                    Player.Message(player, prefix + string.Format(msg("StartSpawn", player.UserIDString), location), chaticon);

                });
            }
        }

        [ChatCommand("m.kill")]
        void npcKill(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _PermKill)) return;
            {
                Kill();
                Player.Message(player, prefix + string.Format(msg("Remove", player.UserIDString)), chaticon);
            }
        }
        #endregion

        #region msg helper
        private string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        #endregion
    }
}

// --- End of file: Murderers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-sleepers-panel ---
// --- Original File Path: M/MagicSleepersPanel/MagicSleepersPanel.cs ---

﻿using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Sleepers Panel", "MJSU", "1.0.3")]
    [Description("Displays the sleeping players in magic panel")]
    public class MagicSleepersPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config
        private string _textFormat;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.4f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/j5SP8pJM/spdF7sR.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? .6f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0}",
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#fff2df08",
                Dock = config.PanelSettings?.Dock ?? "lefttop",
                Order = config.PanelSettings?.Order ?? 2,
                Width = config.PanelSettings?.Width ?? 0.05f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            UpdatePanel();
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            UpdatePanel();
        }

        private void UpdatePanel()
        {
            NextTick(() =>
            {
                MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
            });
        }
        #endregion

        #region MagicPanel Hook

        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, BasePlayer.sleepingPlayerList.Count.ToString());
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicSleepersPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/mount-logger ---
// --- Original File Path: M/MountLogger/MountLogger.cs ---


using Oxide.Core;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;



namespace Oxide.Plugins
{
    [Info("Mount Logger", "BaronVonFinchus", "1.6")]
    [Description("A simple plugin to track the location of mounted entities. Logs player name, ID and position to a file. Useful for PvE servers.")]
    public class MountLogger : RustPlugin
    {

        private PluginConfig _config;

        void Init()
        {
            _config = Config.ReadObject<PluginConfig>();
            permission.RegisterPermission("mountlogger.use", this);
            permission.RegisterPermission("mountlogger.scrapheli.log", this);
            permission.RegisterPermission("mountlogger.miniheli.log", this);
            permission.RegisterPermission("mountlogger.modularcar.log", this);
            permission.RegisterPermission("mountlogger.ridablehorse.log", this);
            permission.RegisterPermission("mountlogger.smallboat.log", this);
            permission.RegisterPermission("mountlogger.rhibboat.log", this);
            permission.RegisterPermission("mountlogger.cranedriver.log", this);
            permission.RegisterPermission("mountlogger.trackpassengers.log", this);
        }

        void OnServerInitialized()
        {
            //Puts("MountLogger Loaded");
        }

        private void Unload()
        {
            //Puts("MountLogger Unloaded");
        }

        private void PrintToConsole(string message)
        {
            if (message == null)
            {
                return;
            }
            Puts(message);
        }

        private void PrintToFile(string message)
        {
            if (message == null)
            {
                return;
            }
            var timestamp = DateTime.Now.ToString("HH:mm:ss");
            message = $"{timestamp} | {message}";
            LogToFile("common", message, this);
        }




        string getGrid(Vector3 pos) { //Credit: yetzt
			char letter = 'A';
			var x = Mathf.Floor((pos.x+(ConVar.Server.worldsize/2)) / 146.3f)%26;
			var z = (Mathf.Floor(ConVar.Server.worldsize/146.3f))-Mathf.Floor((pos.z+(ConVar.Server.worldsize/2)) / 146.3f);
			letter = (char)(((int)letter)+x);
			return $"{letter}{z}";
		}





        #region Mount hooks

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "mountlogger.use"))
            {
                if (!player.IsConnected)
                {
                    return;
                }
                //Discarded logs for mounted entities - Chairs, Kyaks, Instruments, Summer DLC items, Christmas Sled, Computer station
                if ((entity.ShortPrefabName == "chair.invisible.static") || (entity.ShortPrefabName == "chair.deployed") || (entity.ShortPrefabName == "xylophone.deployed") || (entity.ShortPrefabName == "xylophone.deployed.static") || (entity.ShortPrefabName == "sofaseat") || (entity.ShortPrefabName == "piano.deployed") || (entity.ShortPrefabName == "piano.deployed.static") || (entity.ShortPrefabName == "drumkit.deployed") || (entity.ShortPrefabName == "drumkit.deployed.static") || (entity.ShortPrefabName == "sledseatfront") || (entity.ShortPrefabName == "sledseatrear") || (entity.ShortPrefabName == "kayakseat") || (entity.ShortPrefabName == "boogieboard.deployed") || (entity.ShortPrefabName == "innertube.deployed") || (entity.ShortPrefabName == "computerstation.deployed") || (entity.ShortPrefabName == "beachchair.deployed") || (entity.ShortPrefabName == "cardtableseat") || (entity.ShortPrefabName == "workcartdriver") || (entity.ShortPrefabName == "arcadeuser") || (entity.ShortPrefabName == "chair.static"))
                {
                    return;
                }
                //Passengers
                if ((entity.ShortPrefabName == "modularcarpassengerseatlesslegroomleft") || (entity.ShortPrefabName == "modularcarpassengerseatlesslegroomright") || (entity.ShortPrefabName == "modularcarpassengerseatright") || (entity.ShortPrefabName == "modularcarpassengerseatlesslegroomright") || (entity.ShortPrefabName == "transporthelicopilot") || (entity.ShortPrefabName == "minihelipassenger") || (entity.ShortPrefabName == "smallboatpassenger") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.trackpassengers.log")))
                {
                    return;
                }
                //Scrap Heli
                if ((entity.ShortPrefabName == "transporthelipilot") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.scrapheli.log")))
                {
                    return;
                }
                //Minicopter
                if ((entity.ShortPrefabName == "miniheliseat") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.miniheli.log")))
                {
                    return;
                }
                //Modular Cars
                if ((entity.ShortPrefabName == "modularcardriverseat") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.modularcar.log")))
                {
                    return;
                }
                //Horses
                if ((entity.ShortPrefabName == "saddletest") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.ridablehorse.log")))
                {
                    return;
                }
                if ((entity.ShortPrefabName == "craneoperator") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.cranedriver.log")))
                {
                    return;
                }
                //Rowboat
                if ((entity.ShortPrefabName == "smallboatdriver") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.smallboat.log")))
                {
                    return;
                }
                //RHIB
                if ((entity.ShortPrefabName == "standingdriver") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.rhibboat.log")))
                {
                    return;
                }
                string GridPos = getGrid(entity.transform.position);
                LogKey(
                    "OnEntityMount",
                    entity.ShortPrefabName,
                    player,
                    GridPos,
                    entity.transform.position);
            }
            else
            {
                return;
            }
        }


        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "mountlogger.use"))
            {
                if (!player.IsConnected)
                {
                    return;
                }
                //Discarded logs for mounted entities - Chairs, Kyaks, Instruments, Summer DLC items, Christmas Sled, Computer station
                if ((entity.ShortPrefabName == "chair.invisible.static") || (entity.ShortPrefabName == "chair.deployed") || (entity.ShortPrefabName == "xylophone.deployed") || (entity.ShortPrefabName == "xylophone.deployed.static") || (entity.ShortPrefabName == "sofaseat") || (entity.ShortPrefabName == "piano.deployed") || (entity.ShortPrefabName == "piano.deployed.static") || (entity.ShortPrefabName == "drumkit.deployed") || (entity.ShortPrefabName == "drumkit.deployed.static") || (entity.ShortPrefabName == "sledseatfront") || (entity.ShortPrefabName == "sledseatrear") || (entity.ShortPrefabName == "kayakseat") || (entity.ShortPrefabName == "boogieboard.deployed") || (entity.ShortPrefabName == "innertube.deployed") || (entity.ShortPrefabName == "computerstation.deployed") || (entity.ShortPrefabName == "beachchair.deployed") || (entity.ShortPrefabName == "cardtableseat") || (entity.ShortPrefabName == "workcartdriver") || (entity.ShortPrefabName == "arcadeuser") || (entity.ShortPrefabName == "chair.static"))
                {
                    return;
                }
                //Passengers
                if ((entity.ShortPrefabName == "modularcarpassengerseatlesslegroomleft") || (entity.ShortPrefabName == "modularcarpassengerseatlesslegroomright") || (entity.ShortPrefabName == "modularcarpassengerseatright") || (entity.ShortPrefabName == "modularcarpassengerseatlesslegroomright") || (entity.ShortPrefabName == "transporthelicopilot") || (entity.ShortPrefabName == "minihelipassenger") || (entity.ShortPrefabName == "smallboatpassenger") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.trackpassengers.log")))
                {
                    return;
                }
                //Scrap Heli
                if ((entity.ShortPrefabName == "transporthelipilot") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.scrapheli.log")))
                {
                    return;
                }
                //Minicopter
                if ((entity.ShortPrefabName == "miniheliseat") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.miniheli.log")))
                {
                    return;
                }
                //Modular Cars
                if ((entity.ShortPrefabName == "modularcardriverseat") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.modularcar.log")))
                {
                    return;
                }
                //Horses
                if ((entity.ShortPrefabName == "saddletest") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.ridablehorse.log")))
                {
                    return;
                }
                if ((entity.ShortPrefabName == "craneoperator") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.cranedriver.log")))
                {
                    return;
                }
                //Rowboat
                if ((entity.ShortPrefabName == "smallboatdriver") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.smallboat.log")))
                {
                    return;
                }
                //RHIB
                if ((entity.ShortPrefabName == "standingdriver") && (!permission.UserHasPermission(player.UserIDString, "mountlogger.rhibboat.log")))
                {
                    return;
                }
                string GridPos = getGrid(entity.transform.position);
                LogKey(
                    "OnEntityDismount",
                    entity.ShortPrefabName,
                    player,
                    GridPos,
                    entity.transform.position);
            }
            else
            {
                return;
            }
        }



        #endregion

        #region Messages

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new RuLocalization(), this, "ru");
            lang.RegisterMessages(new DefaultLocalization(), this);
        }
        protected override void LoadDefaultConfig() => Config.WriteObject(new PluginConfig(), true);

        private void LogKey(string key, params object[] args) =>
            LogMessage(this[key, args]);

        private void LogMessage(string message)
        {
            if (_config.PrintToConsole) PrintToConsole(message);
            if (_config.PrintToFile) PrintToFile(message);
        }

        private string this[string key, params object[] args] => args?.Any() == true
            ? string.Format(lang.GetMessage(key, this), args)
            : lang.GetMessage(key, this);

        #endregion
    
        #region MountLogger.Localization

        private class DefaultLocalization : Dictionary<string, string>
        {
            public DefaultLocalization()
            {
                this["OnEntityMount"] = "A {0} was mounted by '{1}' at Grid {2}";
                this["OnEntityDismount"] = "A {0} was dismounted by '{1}' at Grid {2}";
            }
        }
    
        private class RuLocalization : Dictionary<string, string>
        {
            public RuLocalization()
            {
                this["OnEntityMount"] = "{0} mounted by {1} at {2)";
                this["OnEntityDismount"] = "{0} dismounted by {1} at {2}";
            }
        }
    
        #endregion
    
        #region MountLogger.Models

        private class PluginConfig
        {
            [JsonProperty("Print logs to console")]
            public bool PrintToConsole { get; set; } = true;
    
            [JsonProperty("Print logs to file")]
            public bool PrintToFile { get; set; } = true;
    
        }
    
        private class PluginData
        {
            public bool FirstStart { get; set; } = true;
        }
    
        #endregion
    }
}


// --- End of file: MountLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-clock-panel ---
// --- Original File Path: M/MagicClockPanel/MagicClockPanel.cs ---

﻿using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Magic Clock Panel", "MJSU", "1.0.3")]
    [Description("Displays the in game time in magic panel")]
    public class MagicClockPanel : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin MagicPanel;

        private PluginConfig _pluginConfig; //Plugin Config

        private TOD_Sky _sky;
        private TOD_Time _time;

        private enum UpdateEnum { All = 1, Panel = 2, Image = 3, Text = 4 }

        private string _textFormat;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _textFormat = _pluginConfig.Panel.Text.Text;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            string path = $"{Manager.ConfigPath}/MagicPanel/{Name}.json";
            DynamicConfigFile newConfig = new DynamicConfigFile(path);
            if (!newConfig.Exists())
            {
                LoadDefaultConfig();
                newConfig.Save();
            }
            try
            {
                newConfig.Load();
            }
            catch (Exception ex)
            {
                RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
                return;
            }
            
            newConfig.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(newConfig.ReadObject<PluginConfig>());
            newConfig.WriteObject(_pluginConfig);
        }

        private PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.Panel = new Panel
            {
                Image = new PanelImage
                {
                    Enabled = config.Panel?.Image?.Enabled ?? true,
                    Color = config.Panel?.Image?.Color ?? "#FFFFFFFF",
                    Order = config.Panel?.Image?.Order ?? 0,
                    Width = config.Panel?.Image?.Width ?? 0.28f,
                    Url = config.Panel?.Image?.Url ?? "https://i.postimg.cc/vZFLtS8V/cSykHxd.png",
                    Padding = config.Panel?.Image?.Padding ?? new TypePadding(0.05f, 0.0f, 0.1f, 0.1f)
                },
                Text = new PanelText
                {
                    Enabled = config.Panel?.Text?.Enabled ?? true,
                    Color = config.Panel?.Text?.Color ?? "#FFFFFFFF",  
                    Order = config.Panel?.Text?.Order ?? 1,
                    Width = config.Panel?.Text?.Width ?? 0.72f,
                    FontSize = config.Panel?.Text?.FontSize ?? 14,
                    Padding = config.Panel?.Text?.Padding ?? new TypePadding(0.05f, 0.05f, 0.05f, 0.05f),
                    TextAnchor = config.Panel?.Text?.TextAnchor ?? TextAnchor.MiddleCenter,
                    Text = config.Panel?.Text?.Text ?? "{0:hh:mm tt}"
                }
            };
            config.PanelSettings = new PanelRegistration
            {
                BackgroundColor = config.PanelSettings?.BackgroundColor ?? "#FFF2DF08",
                Dock = config.PanelSettings?.Dock ?? "leftbottom",
                Order = config.PanelSettings?.Order ?? 1,
                Width = config.PanelSettings?.Width ?? 0.075f
            };
            return config;
        }

        private void OnServerInitialized()
        {
            _sky = TOD_Sky.Instance;
            _time = _sky.Components.Time;
            _time.OnMinute += UpdateTime;
            MagicPanelRegisterPanels();
        }

        private void MagicPanelRegisterPanels()
        {
            if (MagicPanel == null)
            {
                PrintError("Missing plugin dependency MagicPanel: https://umod.org/plugins/magic-panel");
                return;
            }
        
            MagicPanel?.Call("RegisterGlobalPanel", this, Name, JsonConvert.SerializeObject(_pluginConfig.PanelSettings), nameof(GetPanel));
        }

        private void UpdateTime()
        {
            MagicPanel?.Call("UpdatePanel", Name, (int)UpdateEnum.Text);
        }

        private void Unload()
        {
            if (_time.IsUnityNull())
            {
                _time.OnMinute -= UpdateTime;
            }
        }
        #endregion

        #region MagicPanel Hook
        private Hash<string, object> GetPanel()
        {
            Panel panel = _pluginConfig.Panel;
            PanelText text = panel.Text;
            if (text != null)
            {
                text.Text = string.Format(_textFormat, _sky.Cycle.DateTime);
            }

            return panel.ToHash();
        }
        #endregion

        #region Classes
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Panel Settings")]
            public PanelRegistration PanelSettings { get; set; }

            [JsonProperty(PropertyName = "Panel Layout")]
            public Panel Panel { get; set; }
        }

        private class PanelRegistration
        {
            public string Dock { get; set; }
            public float Width { get; set; }
            public int Order { get; set; }
            public string BackgroundColor { get; set; }
        }

        private class Panel
        {
            public PanelImage Image { get; set; }
            public PanelText Text { get; set; }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Image)] = Image.ToHash(),
                    [nameof(Text)] = Text.ToHash()
                };
            }
        }

        private abstract class PanelType
        {
            public bool Enabled { get; set; }
            public string Color { get; set; }
            public int Order { get; set; }
            public float Width { get; set; }
            public TypePadding Padding { get; set; }
            
            public virtual Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Enabled)] = Enabled,
                    [nameof(Color)] = Color,
                    [nameof(Order)] = Order,
                    [nameof(Width)] = Width,
                    [nameof(Padding)] = Padding.ToHash(),
                };
            }
        }

        private class PanelImage : PanelType
        {
            public string Url { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Url)] = Url;
                return hash;
            }
        }

        private class PanelText : PanelType
        {
            public string Text { get; set; }
            public int FontSize { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            public TextAnchor TextAnchor { get; set; }
            
            public override Hash<string, object> ToHash()
            {
                Hash<string, object> hash = base.ToHash();
                hash[nameof(Text)] = Text;
                hash[nameof(FontSize)] = FontSize;
                hash[nameof(TextAnchor)] = TextAnchor;
                return hash;
            }
        }

        private class TypePadding
        {
            public float Left { get; set; }
            public float Right { get; set; }
            public float Top { get; set; }
            public float Bottom { get; set; }

            public TypePadding(float left, float right, float top, float bottom)
            {
                Left = left;
                Right = right;
                Top = top;
                Bottom = bottom;
            }
            
            public Hash<string, object> ToHash()
            {
                return new Hash<string, object>
                {
                    [nameof(Left)] = Left,
                    [nameof(Right)] = Right,
                    [nameof(Top)] = Top,
                    [nameof(Bottom)] = Bottom
                };
            }
        }
        #endregion
    }
}


// --- End of file: MagicClockPanel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/magic-teleportation ---
// --- Original File Path: M/MagicTeleportation/MagicTeleportation.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
    [Info("MagicTeleportation", "Norn", "1.1.3", ResourceId = 1404)]
    [Description("Teleportation system.")]
    public class MagicTeleportation : RustPlugin
    {
        [PluginReference]
        Plugin PopupNotifications;

        [PluginReference]
        Plugin BuildingOwners;

        class StoredData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
            public Dictionary<string, HomeEntities> Entities = new Dictionary<string, HomeEntities>();
            public Dictionary<int, TeleportInfo> Teleports = new Dictionary<int, TeleportInfo>();
            public StoredData() { }
        }
        public class TeleportInfo
        {
            public int iID;
            public string tTitle;
            public string tDescription;
            public float fX;
            public float fY;
            public float fZ;
            public bool uEnabled;
            public int iAuthLevel;
            public bool uSleepGod;
            public int iCount;
            public TeleportInfo() { }
        }
        class HomesLocs
        {
            public float fX;
            public float fY;
            public float fZ;
            public float fHealth;
            public int iEID;
            public string tBagName;
            public HomesLocs() { }
        }
        class PlayerData
        {
            public ulong uUserID;
            public bool uCooldownEnabled;
            public Dictionary<int, HomesLocs> HomesLocs = new Dictionary<int, HomesLocs>();
            public PlayerData() { }
        }
        public class HomeEntities
        {
            public string tPrefab_name;
            public string tShortname;
            public bool bEnabled;

            public HomeEntities() { }
        }
        Dictionary<string, string> DEFAULT_HomeEntities = new Dictionary<string, string>() {
            {
                "assets/prefabs/deployable/bed/bed_deployed.prefab", "Bed"
            },
        };
        StoredData MTData;
        private void Loaded()
        {
            MTData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
        }
        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        public static int GetRandomNumber(int min, int max)
        {
            System.Random r = new System.Random();
            int n = r.Next();
            return n;
        }
        private int CreateTeleport(string title, string description, float X, float Y, float Z, bool sleepgod = true, int authlevel = 0, bool enabled = true)
        {
            TeleportInfo TPInfo = new TeleportInfo();
            TPInfo.iID = GetRandomNumber(0, 25);
            TPInfo.tTitle = title;
            TPInfo.tDescription = description;
            TPInfo.fX = X;
            TPInfo.fY = Y;
            TPInfo.fZ = Z;
            TPInfo.uSleepGod = sleepgod;
            TPInfo.iAuthLevel = authlevel;
            TPInfo.uEnabled = enabled;
            MTData.Teleports.Add(TPInfo.iID, TPInfo);
            return TPInfo.iID;
        }
        private bool PlayerExists(BasePlayer player)
        {
            PlayerData item = null;
            if (MTData.PlayerData.TryGetValue(player.userID, out item))
            {
                return true;
            }
            return false;
        }
        private int ResetCooldownForAll()
        {
            int count = 0;
            foreach (var player in MTData.PlayerData.Values)
            {
                player.uCooldownEnabled = false;
                count++;
            }
            return count;
        }
        private int PlayerHomeCount(BasePlayer player)
        {
            PlayerData item = null;
            int count = 0;
            if (MTData.PlayerData.TryGetValue(player.userID, out item))
            {
                foreach (var entry in item.HomesLocs.Values)
                {
                    count++;
                }
            }
            return count;
        }
        private bool InitPlayer(BasePlayer player)
        {
            if (!PlayerExists(player))
            {
                PlayerData z = new PlayerData();
                z.uUserID = player.userID;
                z.uCooldownEnabled = false;
                MTData.PlayerData.Add(z.uUserID, z);
                return true;
            }
            return false;
        }
        private bool EntityPlayerCheck(uint netid, BasePlayer attacker = null)
        {
            PlayerData item = null;
            foreach (var entry in MTData.PlayerData.Values)
            {
                if (MTData.PlayerData.TryGetValue(entry.uUserID, out item))
                {
                    if (item.HomesLocs.Count == 0)
                    {
                        return false;
                    }
                    List<int> remove_list = new List<int>();
                    foreach (var home in item.HomesLocs.Values)
                    {
                        if (home.iEID == netid)
                        {
                            remove_list.Add(home.iEID);
                        }
                    }
                    if (remove_list.Count >= 1)
                    {
                        foreach (var z in remove_list)
                        {
                            if (attacker != null)
                            {
                                if (attacker.userID == entry.uUserID)
                                {
                                    string parsed_config = Config["GeneralMessages", "HomeDestroyed"].ToString();
                                    parsed_config = parsed_config.Replace("{home}", item.HomesLocs[z].tBagName);
                                    if (parsed_config.Length >= 1) PrintToChatEx(attacker, parsed_config);
                                }
                                Puts("[" + item.uUserID.ToString() + "] " + item.HomesLocs[z].tBagName + " has been destroyed by " + attacker.displayName.ToString() + " / " + attacker.userID.ToString() + ".");
                            }
                            else
                            {
                                Puts("[" + item.uUserID.ToString() + "] " + item.HomesLocs[z].tBagName + " has been destroyed.");
                            }
                            item.HomesLocs.Remove(z);
                        }
                    }
                }
                return true;
            }
            return false;
        }
        private bool EntityExists(BaseCombatEntity entity)
        {
            if (entity.isActiveAndEnabled)
            {
                return true;
            }
            return false;
        }
        private void OnHomeEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info.Initiator is BasePlayer)
            {
                var attacker = info.Initiator as BasePlayer;
                EntityPlayerCheck(entity.net.ID, attacker);
            }
            else
            {
                EntityPlayerCheck(entity.net.ID);
            }
        }
        List<ulong> SLEEPING_TELEPORTERS = new List<ulong>();
        Dictionary<ulong, Timer> TELEPORT_QUEUE = new Dictionary<ulong, Timer>();
        private HitInfo OnEntityTakeDamage(BaseCombatEntity vic, HitInfo hitInfo)
        {
            if (vic == null || hitInfo == null || vic.ToPlayer() == null) return null;
            BasePlayer player = vic as BasePlayer;
            if (!player.IsSleeping() && SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
            if (Convert.ToBoolean(Config["Settings", "TPSleepGod"]))
            {
                if (player.IsSleeping())
                {
                    if (SLEEPING_TELEPORTERS.Contains(player.userID))
                    {
                        if (hitInfo.Initiator is BasePlayer)
                        {
                            var attacker = hitInfo.Initiator as BasePlayer;
                            if (attacker.userID == player.userID)
                            {
                                return null;
                            }
                            else
                            {
                                if (Config["GeneralMessages", "PlayerNoAwake"] != null) PrintToChatEx(attacker, Config["GeneralMessages", "PlayerNoAwake"].ToString());
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                }
            }
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                if (Config["GeneralMessages", "TeleportInterrupted"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportInterrupted"].ToString());
                CancelTeleport(player);
            }
            return null;
        }
        bool CancelTeleport(BasePlayer player)
        {
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                try
                {
                    TELEPORT_QUEUE[player.userID].Destroy();
                    TELEPORT_QUEUE.Remove(player.userID);
                    UnfreezePlayer(player.userID);
                    return true;
                }
                catch
                {
                    //Puts("DEBUG: OnEntityTakeDamage(): Failed to kill " + player.displayName + "'s teleport timer.");
                }
            }
            return false;
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity.transform == null)
            {
                return;
            }
            if (MTData.Entities != null)
            {
                foreach (var entry in MTData.Entities)
                {
                    if (entry.Value.bEnabled)
                    {
                        if (entry.Value.tPrefab_name == entity.name)
                        {
                            OnHomeEntityDeath(entity, info);
                            return;
                        }
                    }
                }
            }
        }
        private static Dictionary<string, string> displaynameToShortname = new Dictionary<string, string>();
        private static Dictionary<string, int> deployedToItem = new Dictionary<string, int>();
        private void InitializeTable()
        {
            displaynameToShortname.Clear();
            deployedToItem.Clear();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions() as List<ItemDefinition>;
            foreach (ItemDefinition itemdef in ItemsDefinition)
            {
                if (!displaynameToShortname.ContainsKey(itemdef.displayName.english.ToString().ToLower())) { displaynameToShortname.Add(itemdef.displayName.english.ToString().ToLower(), itemdef.shortname.ToString()); }
                if (itemdef.GetComponent<ItemModDeployable>() != null && !deployedToItem.ContainsKey(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath)) deployedToItem.Add(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath, itemdef.itemid);
            }


        }
        private void RefundHomeEntity(BasePlayer player, BaseEntity entity, int amount)
        {
            if (entity.GetComponentInParent<Deployable>() != null)
            {
                Deployable refund_item = entity.GetComponentInParent<Deployable>();
                Puts(refund_item.name.ToString());
                if (refund_item != null)
                {
                    var RefundItem = ItemManager.FindItemDefinition(deployedToItem[refund_item.gameObject.name]); Item i = null;
                    if (deployedToItem.ContainsKey(refund_item.gameObject.name)) i = ItemManager.CreateByItemID(RefundItem.itemid, 1);
                    if (i != null) { if (!i.MoveToContainer(player.inventory.containerMain)) { i.Drop(player.eyes.position, player.eyes.BodyForward() * 2f); } }
                }
            }
        }
        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BaseEntity e = gameObject.ToBaseEntity();
            BasePlayer player = planner.GetOwnerPlayer();
            if (!(e is BaseEntity) || player == null) { return; }
            if (MTData.Entities != null)
            {
                foreach (var entry in MTData.Entities)
                {
                    if (entry.Value.bEnabled)
                    {
                        if (entry.Value.tPrefab_name == gameObject.name) // Fire Up
                        {
                            int max_per_build = Convert.ToInt32(Config["Settings", "MaxEntitiesPerBuilding"]);
                            int max_homes = Convert.ToInt32(Config["HomeSettings", "MaxHomes"]);
                            if (PlayerHomeCount(player) >= max_homes)
                            {
                                if (Convert.ToBoolean(Config["Settings", "RefundEntity"])) RefundHomeEntity(player, e, 1);
                                string parsed_config = Config["GeneralMessages", "MaxHomes"].ToString();
                                parsed_config = parsed_config.Replace("{max_homes}", max_homes.ToString());
                                if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                                e.Kill();
                                return;
                            }
                            Vector3 position = e.transform.position;
                            if (!PlayerExists(player))
                            {
                                if (InitPlayer(player))
                                {
                                    Puts("Set up user data for " + player.displayName + " (" + player.userID + ").");
                                }
                            }
                            PlayerData d = null;
                            if (MTData.PlayerData.TryGetValue(player.userID, out d))
                            {
                                HomesLocs z = new HomesLocs();
                                z.iEID = (int)e.net.ID;
                                z.fX = position.x;
                                z.fY = position.y;
                                z.fZ = position.z;
                                z.fHealth = e.MaxHealth();
                                z.tBagName = "Bed";
                                d.HomesLocs.Add(z.iEID, z);
                                Puts("Set up new home for " + player.displayName + " (" + player.userID + ") (" + z.iEID.ToString() + ")");

                                if (Config["GeneralMessages", "SetupHome"] != null)
                                {
                                    string parsed_config = Config["GeneralMessages", "SetupHome"].ToString();
                                    parsed_config = parsed_config.Replace("{command}", Config["GeneralMessages", "SetupHome"].ToString());
                                    PrintToChatEx(player, parsed_config);
                                }
                                SaveData();
                            }
                        }
                    }
                }
            }
            else
            {
                Puts("Failed to load entity data, setting default entities...");
                LoadDefaultConfig();
            }

        }
        Dictionary<string, object> GetSleepingBagData(SleepingBag bag)
        {
            var bagdata = new Dictionary<string,
                object>();

            bagdata.Add("name", bag.niceName);
            bagdata.Add("pos", bag.transform.position);

            return bagdata;
        }
        List<Dictionary<string, object>> FindSleepingBags(ulong userid)
        {
            var bags = new List<Dictionary<string,
                object>>();
            foreach (SleepingBag bag in SleepingBag.FindForPlayer(userid, true))
            {
                bags.Add(GetSleepingBagData(bag));
            }

            return bags;
        }
        private bool UnfreezePlayer(ulong steamid)
        {
            PlayerData item = null;
            if (MTData.PlayerData.TryGetValue(steamid, out item))
            {
                if (item.uCooldownEnabled)
                {
                    item.uCooldownEnabled = false;
                }
                return true;
            }
            return false;
        }
        private void CommandMessage(BasePlayer player)
        {
            if (player != null)
            {
                if (Config["GeneralMessages", "Usage"] != null) PrintToChatEx(player, Config["GeneralMessages", "Usage"].ToString());
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]) && Config["GeneralMessages", "AdminCmd"] != null)
                {
                    string parsed_config = Config["GeneralMessages", "AdminCmd"].ToString();
                    parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                    parsed_config = parsed_config.Replace("{createtp}", Config["Commands", "CreateTeleport"].ToString());
                    parsed_config = parsed_config.Replace("{remove}", Config["Commands", "RemoveTeleport"].ToString());
                    PrintToChatEx(player, parsed_config);
                }
            }
        }
        [ChatCommand("t")]
        void cmdHome(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0 || args.Length > 6)
            {
                CommandMessage(player);
            }
            else if (args[0] == "clean")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length == 1)
                    {
                        int count = 0;
                        foreach (SleepingBag bag in SleepingBag.FindForPlayer(player.userID, true))
                        {
                            bag.Kill();
                            count++;
                        }
                        MTData.PlayerData.Remove(player.userID);
                        PrintToChatEx(player, "Removed " + count.ToString() + " homes. (" + player.displayName.ToString() + ").");
                    }
                }
            }
            else if (args[0] == Config["Commands", "Entities"].ToString())
            {

                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length < 2)
                    {
                        int count = 0;
                        foreach (var entity in MTData.Entities.Values)
                        {
                            PrintToChatEx(player, "[" + count.ToString() + "] Entity: <color=yellow>" + entity.tShortname + "</color>\n[" + count.ToString() + "] Prefab: <color=yellow>" + entity.tPrefab_name + "</color>\n[" + count.ToString() + "] Enabled: <color=yellow>" + entity.bEnabled.ToString() + "</color>.");
                            count++;
                        }
                        if (count != 0) PrintToChatEx(player, "Found " + count.ToString() + " entities."); else PrintToChatEx(player, "No entities currently exist.");
                        return;
                    }
                    else
                    {
                        foreach (ItemDefinition item in ItemManager.itemList)
                        {
                            if (item.category == ItemCategory.Items)
                            {
                                if (item.displayName.english == args[1])
                                {
                                    foreach (var itemdef in deployedToItem)
                                    {
                                        if (item.itemid == itemdef.Value)
                                        {
                                            HomeEntities z = new HomeEntities();
                                            z.bEnabled = true;
                                            z.tPrefab_name = itemdef.Key;
                                            z.tShortname = item.displayName.english;
                                            MTData.Entities.Add(z.tPrefab_name, z);
                                            PrintToChatEx(player, "You have <color=green>successfully</color> added <color=yellow>" + z.tShortname + "</color> [ " + z.tPrefab_name + " ] to the entities list. Enabled: " + z.bEnabled.ToString() + ".");
                                            SaveData();
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "RemoveTeleport"].ToString())
            {
                if (args.Length < 2)
                {
                    string parsed_config = Config["GeneralMessages", "RemoveTeleport"].ToString();
                    parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                    parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "RemoveTeleport"].ToString());
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    return;
                }
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    int teleport_id = Convert.ToInt32(args[1]);
                    if (MTData.Teleports.ContainsKey(teleport_id))
                    {
                        string parsed_config = Config["GeneralMessages", "TPRemoveSuccess"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        PrintToChatEx(player, parsed_config);
                        MTData.Teleports.Remove(teleport_id);
                    }
                    else
                    {
                        if (Config["GeneralMessages", "TPNoExist"] != null) PrintToChatEx(player, Config["GeneralMessages", "TPNoExist"].ToString());
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "CreateTeleport"].ToString())
            {
                int return_id = -1;
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length == 3)
                    {
                        string title = args[1];
                        string description = args[2];
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z);
                    }
                    else if (args.Length == 4)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod);
                    }
                    else if (args.Length == 5)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        int authlevel = Convert.ToInt32(args[4]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod, authlevel);
                    }
                    else if (args.Length == 6)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        int authlevel = Convert.ToInt32(args[4]);
                        bool enabled = Convert.ToBoolean(args[5]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod, authlevel, enabled);
                    }
                    else
                    {
                        if (Config["GeneralMessages", "CreateTeleport"] != null)
                        {
                            string parsed_config = Config["GeneralMessages", "CreateTeleport"].ToString();
                            parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                            parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "CreateTeleport"].ToString());
                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                        }

                    }
                    if (return_id != -1 && MTData.Teleports.ContainsKey(return_id))
                    {
                        string parsed_config = Config["GeneralMessages", "TeleportCreated"].ToString();
                        parsed_config = parsed_config.Replace("{id}", return_id.ToString());
                        parsed_config = parsed_config.Replace("{title}", MTData.Teleports[return_id].tTitle);
                        parsed_config = parsed_config.Replace("{description}", MTData.Teleports[return_id].tDescription);
                        parsed_config = parsed_config.Replace("{sleepgod}", MTData.Teleports[return_id].uSleepGod.ToString());
                        parsed_config = parsed_config.Replace("{authlevel}", MTData.Teleports[return_id].iAuthLevel.ToString());
                        parsed_config = parsed_config.Replace("{enabled}", MTData.Teleports[return_id].uEnabled.ToString());
                        PrintToChatEx(player, parsed_config);
                    }
                    else
                    {
                        if (args.Length != 0 && args.Length >= 3)
                        {
                            Puts(player.displayName + " tried to create a teleport. [FAILED]");
                            if (Config["GeneralMessages", "TPCreationFailed"] != null) PrintToChatEx(player, Config["GeneralMessages", "TPCreationFailed"].ToString());
                        }
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "Public"].ToString()) // Public Teleports
            {
                if (args.Length == 1)
                {
                    int count = 0;
                    foreach (var item in MTData.Teleports.Values)
                    {
                        if (item.fX != 0 && item.fZ != 0)
                        {
                            if (player.net.connection.authLevel >= item.iAuthLevel)
                            {
                                count++;
                                if (!item.uEnabled && player.net.connection.authLevel < Convert.ToInt32(Config["General", "AuthLevel"])) break;
                                string parsed_config = Config["GeneralMessages", "TeleportInfo"].ToString();
                                parsed_config = parsed_config.Replace("{id}", count.ToString());
                                parsed_config = parsed_config.Replace("{title}", item.tTitle);
                                parsed_config = parsed_config.Replace("{description}", item.tDescription);
                                parsed_config = parsed_config.Replace("{tpcount}", item.iCount.ToString());

                                if (parsed_config.Length >= 1)
                                {
                                    if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                                    {
                                        string enabled_color = "white";
                                        if (item.uEnabled)
                                        {
                                            enabled_color = "green";
                                        }
                                        else
                                        {
                                            enabled_color = "red";
                                        }
                                        PrintToChatEx(player, parsed_config + "\n[ <color=#33CCFF>" + count.ToString() + "</color> ] <color=red>ID:</color> " + item.iID.ToString() + " : <color=red>Authlevel:</color> " + item.iAuthLevel.ToString() + " : " + "<color=red>Enabled:</color> <color=" + enabled_color.ToString() + ">" + item.uEnabled.ToString() + "</color> : <color=red>Sleep God:</color> " + item.uSleepGod.ToString() + ".");
                                    }
                                    else
                                    {
                                        PrintToChatEx(player, parsed_config);
                                    }
                                }
                            }
                        }
                    }
                    if (count == 0)
                    {
                        if (Config["GeneralMessages", "NoTeleports"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoTeleports"].ToString());
                    }
                    else
                    {
                        string parsed_config = Config["GeneralMessages", "PublicTP"].ToString();
                        parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                        parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "Public"].ToString());
                        PrintToChatEx(player, parsed_config);
                    }
                }
                else if (args.Length == 2)
                {
                    int count = 0;
                    int foundcount = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        foreach (var item in MTData.Teleports.Values)
                        {
                            if (item.fX != 0 && item.fZ != 0)
                            {
                                count++;
                                if (args[1].ToString() == count.ToString())
                                {
                                    if (!TELEPORT_QUEUE.ContainsKey(player.userID))
                                    {
                                        if (item.iAuthLevel == 0 || player.net.connection.authLevel >= item.iAuthLevel)
                                        {
                                            if (Convert.ToBoolean(Config["TPSettings", "SanityCheck"]))
                                            {
                                                string reason = IsTeleportationCapable(player);
                                                if (reason != "continue")
                                                {
                                                    if (reason.Length >= 1) PrintToChatEx(player, reason);
                                                    return;
                                                }
                                            }
                                            foundcount++;
                                            item.iCount++;
                                            InitTeleport(player, Convert.ToSingle(item.fX), Convert.ToSingle(item.fY), Convert.ToSingle(item.fZ), false, true, item.tTitle, item.tDescription, count, Convert.ToInt32(Config["TPSettings", "Cooldown"]));
                                        }
                                        else
                                        {
                                            string parsed_config = Config["GeneralMessages", "TPNoExist"].ToString();
                                            parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                                        }
                                    }
                                    else
                                    {
                                        if (Config["GeneralMessages", "TeleportPending"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportPending"].ToString());
                                    }
                                    return;
                                }
                            }
                        }
                    }
                    if (foundcount == 0)
                    {
                        string parsed_config = Config["GeneralMessages", "TPNoExist"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    }
                }
            }
            else if (args[0] == Config["Commands", "CancelTeleport"].ToString()) // Cancel Teleport
            {
                if (CancelTeleport(player))
                {
                    PrintToChatEx(player, Config["GeneralMessages", "TeleportCancelled"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "Home"].ToString()) // Home Teleport
            {
                if (args.Length == 1)
                {
                    int count = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        if (d.HomesLocs.Count == 0)
                        {
                            PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                            return;
                        }
                        SyncHomesEx(player);
                        foreach (var item in d.HomesLocs)
                        {
                            if (item.Value.fX != 0 && item.Value.fZ != 0)
                            {
                                count++;
                                string parsed_config = Config["GeneralMessages", "HomeInfo"].ToString();
                                parsed_config = parsed_config.Replace("{id}", count.ToString());
                                parsed_config = parsed_config.Replace("{title}", item.Value.tBagName);
                                parsed_config = parsed_config.Replace("{hp}", item.Value.fHealth.ToString());
                                if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);

                            }
                        }
                        if (count == 0)
                        {
                            if (Config["GeneralMessages", "NoHomes"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                        }
                        else
                        {
                            string parsed_config = Config["GeneralMessages", "HomeTP"].ToString();
                            parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                            parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "Home"].ToString());
                            PrintToChatEx(player, parsed_config);
                        }
                    }
                    else
                    {
                        if (Config["GeneralMessages", "NoHomes"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                    }
                }
                else if (args.Length == 2)
                {
                    int count = 0;
                    int foundcount = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        foreach (var item in d.HomesLocs)
                        {
                            if (item.Value.fX != 0 && item.Value.fZ != 0)
                            {
                                count++;
                                if (args[1].ToString() == count.ToString())
                                {
                                    foundcount++;
                                    if (!TELEPORT_QUEUE.ContainsKey(player.userID))
                                    {
                                        if (!d.uCooldownEnabled)
                                        {
                                            if (Convert.ToBoolean(Config["HomeSettings", "SanityCheck"]))
                                            {
                                                string reason = IsTeleportationCapable(player);
                                                if (reason != "continue")
                                                {
                                                    if (reason.Length >= 1) PrintToChatEx(player, reason);
                                                    return;
                                                }
                                            }
                                            InitTeleport(player, Convert.ToSingle(item.Value.fX), Convert.ToSingle(item.Value.fY), Convert.ToSingle(item.Value.fZ), true, true, item.Value.tBagName.ToString());
                                        }
                                        else
                                        {
                                            string parsed_config = Config["GeneralMessages", "TPCooldown"].ToString();
                                            parsed_config = parsed_config.Replace("{cooldown}", Convert.ToInt32(Config["HomeSettings", "Cooldown"]).ToString());
                                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                                        }
                                    }
                                    else
                                    {
                                        if (Config["GeneralMessages", "TeleportPending"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportPending"].ToString());
                                    }
                                    return;
                                }
                            }
                        }
                    }
                    if (count == 0 || foundcount == 0)
                    {
                        string parsed_config = Config["GeneralMessages", "HomeNoExist"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    }
                }
            }
            else
            {
                CommandMessage(player);
            }
        }
        private bool InitTeleport(BasePlayer player, float init_x, float init_y, float init_z, bool type = true, bool printtoplayer = true, string title = "", string description = "", int count = -1, int seconds = 0)
        {
            if(!PlayerExists(player)) InitPlayer(player);
            if (SLEEPING_TELEPORTERS.Contains(player.userID)) { if (!player.IsSleeping()) { SLEEPING_TELEPORTERS.Remove(player.userID); } }
            if (TELEPORT_QUEUE.ContainsKey(player.userID)) { return false; }
            PlayerData d = null;
            if (MTData.PlayerData.TryGetValue(player.userID, out d)) { d.uCooldownEnabled = true; }
            float x = Convert.ToSingle(init_x);
            float y = Convert.ToSingle(init_y);
            float z = Convert.ToSingle(init_z);
            if (seconds == 0)
            {
                seconds = Convert.ToInt32(Config["HomeSettings", "TPWait"]);
            }
            if (type)
            {
                if (title != "")
                {
                    string parsed_config = Config["GeneralMessages", "TPHome"].ToString();
                    parsed_config = parsed_config.Replace("{seconds}", seconds.ToString());
                    parsed_config = parsed_config.Replace("{title}", title);
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                }
                TELEPORT_QUEUE.Add(player.userID, timer.Once(seconds, () => TeleportPlayerPosition(player, new Vector3(x, y + Convert.ToInt32(Config["Settings", "EntityHeight"]), z))));
            }
            else
            {
                if (title != "")
                {
                    string parsed_config = Config["GeneralMessages", "TPGeneral"].ToString();
                    parsed_config = parsed_config.Replace("{title}", title.ToString());
                    parsed_config = parsed_config.Replace("{seconds}", seconds.ToString());
                    parsed_config = parsed_config.Replace("{tpcount}", count.ToString());
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                }
                TELEPORT_QUEUE.Add(player.userID, timer.Once(seconds, () => TeleportPlayerPosition(player, new Vector3(x, y, z))));
            }
            return true;
        }
        //--------------------------->   Position forcing   <---------------------------//

        private void TeleportPlayerPosition(BasePlayer player, Vector3 pos)
        {
			if(player != null)
			{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
				if(!BasePlayer.sleepingPlayerList.Contains(player))	BasePlayer.sleepingPlayerList.Add(player);
				SLEEPING_TELEPORTERS.Add(player.userID);
				player.CancelInvoke("InventoryUpdate");
				player.inventory.crafting.CancelAll(true);
				player.MovePosition(pos);
				player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);
				player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
				player.UpdateNetworkGroup();
				player.SendNetworkUpdateImmediate(false);
				player.ClientRPCPlayer(null, player, "StartLoading");
				player.SendFullSnapshot();
				timer.Once(Convert.ToInt32(Config["HomeSettings", "Cooldown"]), () => UnfreezePlayer(player.userID));
				TELEPORT_QUEUE[player.userID].Destroy();
				TELEPORT_QUEUE.Remove(player.userID);
			}
        }
        void Unload()
        {
            SaveData();
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (!PlayerExists(player)) InitPlayer(player);
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                TELEPORT_QUEUE.Remove(player.userID);
            }
        }
        Timer SyncHomeData;
        void OnServerInitialized()
        {
            InitializeTable();
            InitializeConfig();
        }
        void InitializeConfig()
        {
            if(Convert.ToBoolean(Config["General", "PopulateDefaults"])) { Puts("Generating default entities...");  Config["General", "PopulateDefaults"] = false; SaveConfig(); PopulateEntityData(); }
            if (Config["HomeMessages", "ExternalReason"] == null)
            {
                Puts("Updating configuration file (out of date)...");
                Config["HomeMessages", "ExternalReason"] = "You <color=#FF0000>can't</color> teleport from here.";
                SaveConfig();
            }
            Puts("Populated " + MTData.Entities.Count.ToString() + " entities.");
            int seconds = Convert.ToInt32(Config["Settings", "UpdateTimerInt"]);
            SyncHomeData = timer.Repeat(seconds, 0, () => SyncHomes());
            int player_count = ResetCooldownForAll();
            if (player_count >= 1)
            {
                Puts(player_count.ToString() + " players had their cooldown reset to default.");
            }
            if (!BuildingOwners && Convert.ToBoolean(Config["Dependencies", "BuildingOwners"]))
            {
                Puts("[BuildingOwners][682]: Plugin has not been found! [ BuildingOwners : false ]");
                Config["Dependencies", "BuildingOwners"] = false;
                SaveConfig();
            }
            Puts("[Building Owners][682]: [Enabled: " + Config["Dependencies", "BuildingOwners"].ToString() + "]");
        }
        void SyncHomesEx(BasePlayer player)
        {
            if (player != null)
            {
                if (MTData.PlayerData.ContainsKey(player.userID))
                {
                    if (SleepingBag.FindForPlayer(player.userID, true).Length == 0)
                    {
                        if (MTData.PlayerData[player.userID].HomesLocs.Count >= 1)
                        {
                            MTData.PlayerData[player.userID].HomesLocs.Clear();
                            Puts("Resetting: " + player.displayName + "'s [" + player.userID.ToString() + "] homes list.");
                            return;
                        }
                    }
                    List<uint> ids = new List<uint>();
                    List<uint> remove_list = new List<uint>();
                    foreach (SleepingBag bag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        foreach (var entry in MTData.Entities)
                        {
                            if (entry.Value.bEnabled)
                            {
                                if (entry.Value.tPrefab_name == bag.PrefabName)
                                {
                                    int bag_id = (int)bag.net.ID;
                                    if (MTData.PlayerData[player.userID].HomesLocs.ContainsKey(bag_id))
                                    {
                                        if (MTData.PlayerData[player.userID].HomesLocs[bag_id].tBagName != bag.niceName)
                                        {
                                            MTData.PlayerData[player.userID].HomesLocs[bag_id].tBagName = bag.niceName;
                                        }
                                        if (MTData.PlayerData[player.userID].HomesLocs[bag_id].fHealth != bag.health)
                                        {
                                            MTData.PlayerData[player.userID].HomesLocs[bag_id].fHealth = bag.health;
                                        }
                                        ids.Add(bag.net.ID);
                                    }
                                }
                            }
                        }
                    }
                    foreach (var home in MTData.PlayerData[player.userID].HomesLocs)
                    {
                        if (!ids.Contains((uint)home.Key)) remove_list.Add((uint)home.Key);
                    }
                    new List<uint>(remove_list).ForEach(u => {
                        MTData.PlayerData[player.userID].HomesLocs.Remove((int)u);
                    });
                }
            }
        }
        void SyncHomes()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                SyncHomesEx(player);
            }
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, MTData);
        }
        private string IsTeleportationCapable(BasePlayer player)
        {
            string result = "";
            string tp_correct = "continue";
            if (player != null && player.IsConnected)
            {
                if (Convert.ToBoolean(Config["Settings", "BypassAdmin"]) && player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    return tp_correct;
                }
                float min_hp = (float)Convert.ToDouble(Config["HomeSettings", "MinimumHealthCheck"]);
                float health = player.health;
                float temperature = player.currentTemperature;
                float comfort = player.currentComfort;
                var cantp = Interface.Call("canTeleport", player);
                if (health <= min_hp)
                {
                    result = Config["HomeMessages", "MinHP"].ToString();
                    result = result.Replace("{minhp}", min_hp.ToString());
                }
                else if (player.IsWounded()) { result = Config["HomeMessag