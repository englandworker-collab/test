.AutoMinutes <= 0 && config.AutoAddProtection) PrintError("Time (minutes) after which the raided person gains raid protection is set to 0!!! Change this!!");
        }

        private void RegisterCommands()
        {
            foreach (var command in AdminCommands)
                AddCovalenceCommand(command.Key, command.Value, AdminPerm);
        }

        private void OnServerInitialized(bool isStartup) // Reminder use this hook instead of Loaded(). Thanks Nivex
        {
            foreach (var block in BaseEntity.saveList.OfType<BuildingBlock>()) _blocks.Add(block);

            Subscribe(nameof(OnEntityDeath));
            Subscribe(nameof(OnEntityKill));
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityTakeDamage));

            RegisterCommands();

            foreach (var entry in storedData.players.Where(x => !storedData.lastConnection.ContainsKey(x.Key)))
                storedData.lastConnection.Add(entry.Key, string.Empty);

            StartChecking();
            CheckPlayersWithNoInfo();

            if (!config.Advance.OnServerSave)
            {
                float args = config.Advance.SaveFrequency;
                int offset = (int) args;

                timer.Every(offset, SaveData);
            }

            if (beta) PrintWarning($"Debug Version: {betaversion}");

            if (config.Advance.Frequency <= 10)
            {
                timer.Every(15f, () =>
                {
                    PrintWarning(lang.GetMessage("Increase_Refresh", this, null));
                });
            }

            if (PlaytimeTracker == null)
            {
                PrintWarning(lang.GetMessage("pt_notInstalled", this, null));
                CheckingPT = timer.Every(15f, () =>
                {
                    if (PlaytimeTracker == null)
                    {
                        PrintWarning(lang.GetMessage("pt_notInstalled", this, null));
                    }
                    else
                    {
                        PrintWarning(lang.GetMessage("pt_detected", this, null));
                        timer.Destroy(ref CheckingPT);
                    }

                });
            }
            if (config.Relationship.CheckClan && Clans != null)
            {
                timer.Every(60f, RefreshClanCache);
            }
            if (config.Relationship.CheckClan && Clans == null)
            {
                PrintWarning(lang.GetMessage("C_notInstalled", this, null));
                CheckingC = timer.Every(15f, () =>
                {
                    if (Clans == null)
                    {
                        PrintWarning(lang.GetMessage("C_notInstalled", this, null));
                    }
                    else
                    {
                        PrintWarning(lang.GetMessage("C_detected", this, null));
                        timer.Destroy(ref CheckingC);
                    }

                });
            }
        }

        private void Unload()
        {
            LeaderLower.Clear();
            SaveData();
            SaveDataItemList();
        }

        private void OnServerSave()
        {
            if (config.Advance.OnServerSave) timer.Once(UnityEngine.Random.Range(5, 15), SaveData);
        }

        private void OnNewSave()
        {
            if (config.Other.MapWipe == true)
            {
                storedData.players.Clear();
                storedData.IgnoredPlayers.Clear();
                storedData.lastConnection.Clear();
                storedData.ShowTwigsNotProtected.Clear();
                storedData.InTeam.Clear();
                storedData.FirstMessaged.Clear();
                storedData.playersWithNoData.Clear();
                storedData.AttackAttempts.Clear();
                SaveData();
                PrintWarning("New savefile detected. All Player Data was cleared!");
            }
        }

        #endregion

        #region Commands
        private Dictionary<string, string> AdminCommands = new Dictionary<string, string>
        {
            { "antinoob", "AntiNoobCommand" },
            { "checkname", "CheckNameCmd" },
            { "refunditem", "RefundCmd" },
        };

        private void AntiNoobCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length < 1)
            {
                player.Reply(lang.GetMessage("antinoobcmd_syntax", this, player.Id));
                return;
            }

            switch (args[0].ToLower())
            {
                case "addnoob":
                    {
                        if (args.Length < 2)
                        {
                            player.Reply(lang.GetMessage("antinoobcmd_addnoob_syntax", this, player.Id));
                            return;
                        }

                        var p = covalence.Players.FindPlayer(args[1]);
                        if (p == null)
                        {
                            player.Reply(lang.GetMessage("NoPlayerFound", this, player.Id), null, args[1]);
                            return;
                        }

                        foreach (var entry in storedData.players)
                        {
                            if (entry.Key == ulong.Parse(p.Id))
                            {
                                if (storedData.players[entry.Key] == -25d)
                                {
                                    player.Reply(lang.GetMessage("antinoobcmd_alreadynoob", this, player.Id), null, p.Name);
                                    return;
                                }

                                storedData.players[entry.Key] = -25d;
                                player.Reply(lang.GetMessage("antinoobcmd_marked", this, player.Id), null, p.Name);
                                return;
                            }
                        }
                        player.Reply(lang.GetMessage("NoPlayerFound", this, player.Id), null, args[1]);
                        return;
                    }

                case "removenoob":
                    {
                        if (args.Length < 2)
                        {
                            player.Reply(lang.GetMessage("antinoobcmd_removenoob_syntax", this, player.Id));
                            return;
                        }

                        var p = covalence.Players.FindPlayer(args[1]);
                        if (p == null)
                        {
                            player.Reply(lang.GetMessage("NoPlayerFound", this, player.Id), null, args[1]);
                        }

                        foreach (var entry in storedData.players)
                        {
                            if (entry.Key == ulong.Parse(p.Id))
                            {
                                if (storedData.players[entry.Key] == -50d)
                                {

                                    player.Reply(lang.GetMessage("antinoobcmd_missingnoob", this, player.Id), null, p.Name);
                                    return;
                                }

                                storedData.players[entry.Key] = -50d;
                                player.Reply(lang.GetMessage("antinoobcmd_removednoob", this, player.Id), null, p.Name);
                                return;
                            }
                        }

                        player.Reply(lang.GetMessage("NoPlayerFound", this, player.Id), null, args[1]);
                        return;
                    }

                case "wipe":
                    {
                        if (args.Length < 2)
                        {
                            player.Reply(lang.GetMessage("antinoobcmd_wipe_syntax", this, player.Id));
                            return;
                        }

                        switch (args[1].ToLower())
                        {
                            case "all":
                                {
                                    storedData.lastConnection.Clear();
                                    storedData.playersWithNoData.Clear();
                                    storedData.FirstMessaged.Clear();
                                    storedData.AttackAttempts.Clear();
                                    storedDataItemList.ItemList.Clear();
                                    storedData.players.Clear();
                                    player.Reply(lang.GetMessage("dataFileWiped", this, player.Id));
                                    return;
                                }

                            case "playerdata":
                                {
                                    storedData.players.Clear();
                                    player.Reply(lang.GetMessage("dataFileWiped_playerdata", this, player.Id));
                                    return;
                                }

                            case "attempts":
                                {
                                    storedData.AttackAttempts.Clear();
                                    player.Reply(lang.GetMessage("dataFileWiped_attempts", this, player.Id));
                                    return;
                                }

                            default:
                                {
                                    player.Reply(lang.GetMessage("antinoobcmd_wipe_syntax", this, player.Id));
                                    return;
                                }
                        }
                    }

                default:
                    {
                        player.Reply(lang.GetMessage("antinoobcmd_syntax", this, player.Id));
                        return;
                    }
            }
        }

        [ChatCommand("checknew")]
        private void CheckNewCmd(BasePlayer player, string command, string[] args)
        {
            BaseEntity hitEnt = GetLookAtEntity(player);
            if (hitEnt == null)
            {
                SendReply(player, lang.GetMessage("NotLooking", this, player.UserIDString));
                return;
            }

            if (config.Messages.ShowMessage && config.Other.IgnoreTwig && (hitEnt as BuildingBlock)?.grade == BuildingGrade.Enum.Twigs)
            {
                SendReply(player, lang.GetMessage("twig_can_attack", this, player.UserIDString));
                return;
            }

            ulong owner = config.Other.CheckFullOwnership ? FullOwner(hitEnt) : hitEnt.OwnerID;

            if (owner == 0u || !storedData.players.ContainsKey(owner)) return;
            MessagePlayer(player, owner);
        }

        [ChatCommand("entdebug")]
        private void EntDebugCmd(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            BaseEntity ent = GetLookAtEntity(player);

            if (ent == null)
            {
                SendReply(player, "No entity");
                return;
            }

            var ownerid = (FullOwner(ent) != 0) ? FullOwner(ent) : ent.OwnerID;

            if (args.Length < 1)
            {
                SendReply(player, "OwnerID: " + ent.OwnerID);
                SendReply(player, "FullOwner: " + FullOwner(ent));

                if (storedData.players.ContainsKey(ownerid))
                {
                    var tiem = (int)storedData.players[ownerid];
                    switch (tiem)
                    {
                        case -25:
                            {
                                SendReply(player, "Time: -25d (manually set noob)");
                                break;
                            }

                        case -50:
                            {
                                SendReply(player, "Time: -50d (damaged structure, clan lost protection, inactive)");
                                break;
                            }

                        default:
                            {
                                SendReply(player, "Time: " + tiem + " ('natural' time)");
                                if (tiem >= config.Main.ProtectionTime) SendReply(player, "Should be raidable");
                                else SendReply(player, "Shouldn't be raidable");
                                break;
                            }
                    }
                }

                else SendReply(player, "StoredData does not contain info for " + ownerid);
                return;
            }

            var t = ulong.Parse(args[0]);
            ent.OwnerID = t;
            ent.SendNetworkUpdate();
            SendReply(player, "Set OwnerID: " + ent.OwnerID);
            return;
        }

        private void CheckNameCmd(IPlayer p, string command, string[] args)
        {
            BasePlayer player = p.Object as BasePlayer;
            BaseEntity hitEnt = GetLookAtEntity(player);
            Item helditem = player.GetActiveItem();

            if (player == null) return;

            if (args.Length < 1)
            {
                return;
            }

            switch (args[0].ToLower())
            {
                case "looking":
                    {
                        if (hitEnt == null)
                        {
                            p.Reply(lang.GetMessage("notlooking_item", this, p.Id));
                            return;
                        }

                        if (hitEnt != null)
                        {
                            p.Reply(lang.GetMessage("looking_item", this, player.UserIDString), null, hitEnt);
                            return;
                        }

                        return;
                    }

                case "holding":
                    {
                        if (helditem == null)
                        {
                            p.Reply(lang.GetMessage("notholding_item", this, p.Id));
                            return;
                        }

                        if (NotSupportedRaidTools.ContainsKey(helditem.info.shortname))
                        {
                            p.Reply(lang.GetMessage("Not_Supported", this, p.Id));
                            return;
                        }

                        if (RaidToolsCheck.ContainsKey(helditem.info.shortname))
                        {
                            p.Reply(lang.GetMessage("holding_item", this, player.UserIDString), null, RaidToolsCheck[helditem.info.shortname]);
                            return;
                        }
                        else

                        {
                            p.Reply(lang.GetMessage("notholding_item", this, p.Id));
                            return;
                        }
                    }
            }
        }

        private void RefundCmd(IPlayer p, string command, string[] args)
        {
            BasePlayer player = p.Object as BasePlayer;
            if (player == null) return;

            if (args.Length < 1)
            {
                p.Reply(lang.GetMessage("refunditem_help", this, p.Id));
                return;
            }

            Item helditem = player.GetActiveItem();

            switch (args[0].ToLower())
            {
                case "add":
                    {
                        if (player.GetActiveItem() == null)
                        {
                            p.Reply(lang.GetMessage("refunditem_needholditem", this, player.UserIDString));
                            return;
                        }

                        if (raidtools.ContainsKey(helditem.info.shortname))
                        {
                            if (!storedDataItemList.ItemList.ContainsKey(helditem.info.shortname))
                            {
                                storedDataItemList.ItemList.Add(helditem.info.shortname, raidtools[helditem.info.shortname]);
                                p.Reply(lang.GetMessage("refunditem_added", this, player.UserIDString), null, helditem.info.displayName.english);
                                return;
                            }

                            p.Reply(lang.GetMessage("refunditem_alreadyonlist", this, player.UserIDString));
                            return;
                        }

                        p.Reply(lang.GetMessage("refunditem_notexplosive", this, player.UserIDString));

                        SaveDataItemList();

                        return;
                    }

                case "remove":
                    {
                        if (player.GetActiveItem() == null)
                        {
                            p.Reply(lang.GetMessage("refunditem_needholditem", this, player.UserIDString));
                            return;
                        }

                        if (storedDataItemList.ItemList.ContainsKey(helditem.info.shortname))
                        {
                            storedDataItemList.ItemList.Remove(helditem.info.shortname);
                            p.Reply(lang.GetMessage("refunditem_removed", this, player.UserIDString), null, helditem.info.displayName.english);
                            return;
                        }

                        p.Reply(lang.GetMessage("refunditem_notonlist", this, player.UserIDString));

                        SaveDataItemList();

                        return;
                    }

                case "all":
                    {
                        foreach (var t in raidtools)

                            if (!storedDataItemList.ItemList.ContainsKey(t.Key)) storedDataItemList.ItemList.Add(t.Key, t.Value);

                        p.Reply(lang.GetMessage("refunditem_addedall", this, player.UserIDString));

                        SaveDataItemList();

                        return;
                    }

                case "clear":
                    {
                        storedDataItemList.ItemList.Clear();

                        p.Reply(lang.GetMessage("refunditem_cleared", this, player.UserIDString));

                        SaveDataItemList();

                        return;
                    }

                case "list":
                    {
                        if (storedDataItemList.ItemList.Count < 1)
                        {
                            p.Reply(lang.GetMessage("refunditem_empty", this, player.UserIDString));
                            return;
                        }

                        List<string> T2 = new List<string>();

                        foreach (var entry in storedDataItemList.ItemList)
                        {
                            Item item = ItemManager.CreateByName(entry.Key, 1);

                            if (item.info.displayName.english == null)
                                LogToFile("other", "Failed to find display name for " + entry.Key, this, true);
                            T2.Add(item?.info?.displayName?.english);
                        }

                        string final = string.Join("\n", T2.ToArray());
                        p.Reply(lang.GetMessage("refunditem_list", this, player.UserIDString), null, final);
                        return;
                    }

                default:
                    {
                        p.Reply(lang.GetMessage("refunditem_help", this, player.UserIDString));
                        return;
                    }
            }
        }

        #endregion

        #region Rust/uMod Hooks
        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;
            var dmgType = hitinfo?.damageTypes?.GetMajorityDamageType() ?? DamageType.Generic;
            string name = CheckForRaidingTools(hitinfo);

            if (hitinfo == null || entity == null || attacker == null || owner == 0) return null; //null checks

            if (!entity.OwnerID.IsSteamId() || !attacker.userID.IsSteamId()) return null;

            if (entity?.OwnerID == attacker?.userID) return null;

            if (dmgType == DamageType.Decay || dmgType == DamageType.Generic || dmgType == DamageType.Bite || dmgType == DamageType.Fun_Water) return null;

            if (entity.OwnerID == 0u || CheckForBuildingOrDeployable(entity, hitinfo) == false) return null;

            if (HasProtection(attacker) == true) return null;

            if (config.Other.IgnoreTwig && (entity as BuildingBlock)?.grade == BuildingGrade.Enum.Twigs) return null;

            if (CheckForHelicopterOrMLRS(entity, hitinfo) == true) return null;

            if (NullWeaponCheck(entity, hitinfo) == true) return null;

            if (config.RaidTools.AllowedRaidTools.ContainsKey(name))
            {
                if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    NextTick(() => {
                        MessagePlayer(attacker, owner);
                        Refund(attacker, name, entity);

                    });
                    return true;
                }
                else
                {
                    return null;
                }
            }

            if (config.Entity.AllowedEntities.ContainsKey(entity.ShortPrefabName))
            {
                return null;
            }

            if (config.Entity.AllowedEntitiesNoob.ContainsKey(entity.ShortPrefabName))
            {
                if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    NextTick(() =>
                    {
                        MessagePlayer(attacker, owner);
                        Refund(attacker, name, entity);
                    });
                    return true;
                }
                else
                {
                    return null;
                }
            }

            if (attacker == null || owner == 0u) return null;

            if (storedData.IgnoredPlayers.Contains(attacker.userID)) return null;

            if (owner == attacker?.userID) return null;

            bool wipe = false;
            try
            {
                if (WipeProtection != null) wipe = WipeProtection.Call<bool>("WipeProtected");
            }

            catch (Exception e)
            {
                PrintError("Caught an exception while trying to get data from WipeProtection: " + e.Message);
            }

            if (wipe) return null;

            if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == true)
            {
                return null;
            }
            if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == false)
            {
                if (!string.IsNullOrEmpty(name) && config.Main.UnNoobNew)
                {
                    RemoveTeamProtection(attacker, hitinfo);
                }
            }

            if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == true)
            {
                return null;
            }
            if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == false)
            {
                if (!string.IsNullOrEmpty(name) && config.Main.UnNoobNew)
                {
                    RemoveClanProtection(attacker, attacker?.userID ?? 0u);
                }
            }

            if (cooldown.Contains(attacker))
            {
                if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    return true;
                }
                return null;
            }

            cooldown.Add(attacker);
            RemoveCD(cooldown, attacker);
            LogPlayer(attacker);

            RemoveProtection(attacker, hitinfo);

            if (PlayerIsNew(owner))
            {
                //keep in mind, antinoobraid.noob perm doesn't get removed
                hitinfo.damageTypes = new DamageTypeList();
                hitinfo.DoHitEffects = false;
                hitinfo.HitMaterial = 0;
                hitinfo.damageTypes.ScaleAll(0f);
                NextTick(() => {
                    //if player was *manually* set to noob we don't remove his protection on raid attempt
                    MessagePlayer(attacker, owner);
                    Refund(attacker, name, entity);

                });
                return true;
            }

            return null;
        }

        private void OnEntityBuilt(Planner plan, GameObject gameObject)
        {
            BaseEntity entity = gameObject.ToBaseEntity();
            var player = plan.GetOwnerPlayer();

            if ((entity as BuildingBlock)?.grade == BuildingGrade.Enum.Twigs)
            {
                if (config.Messages.ShowMessageTwig && config.Other.IgnoreTwig && !storedData.ShowTwigsNotProtected.Contains(player.userID))
                {
                    string msg = string.Format(lang.GetMessage("twig_can_attack", this, player.UserIDString));

                    storedData.ShowTwigsNotProtected.Add(player.userID);

                    if (config.Messages.UseGT)
                    {
                        player.SendConsoleCommand("gametip.showgametip", msg);
                        timer.Once(10f, () => player.SendConsoleCommand("gametip.hidegametip"));
                    }
                    else
                    {
                        SendReply(player, msg);
                    }
                }
            }
        }

        private void OnFireBallDamage(FireBall fireball, BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (hitinfo == null || fireball == null || entity == null || !config.Other.KillFire) return;

            if (!(entity is BuildingBlock || entity is Door || entity.OwnerID != 0u || entity.PrefabName.Contains("deployable")) || fireball.IsDestroyed) return;

            if (config.Other.IgnoreTwig && (entity as BuildingBlock)?.grade == BuildingGrade.Enum.Twigs) return;

            BasePlayer attacker = hitinfo?.InitiatorPlayer;

            if (config.Entity.AllowedEntities.ContainsKey(entity.ShortPrefabName))
            {
                return;
            }

            if (entity?.OwnerID == attacker?.userID) return;

            if (attacker?.userID ==  null) return;

            if (PlayerIsNew(entity.OwnerID))
            {
                fireball.Kill();
                var player = fireball.creatorEntity as BasePlayer;
                if (player != null)
                {
                    if (!MessageCooldown.Contains(player))
                    {
                        MessagePlayer(player, entity.OwnerID);
                        MessageCooldown.Add(player);
                        RemoveCD(MessageCooldown, player);
                    }
                }

                return;
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason) => LastConnect(player.userID);

        private void OnEntitySpawned(BuildingBlock block) => _blocks.Add(block);

        private void OnEntityDeath(BuildingBlock block, HitInfo hitInfo) => _blocks.Remove(block);

        private void OnEntityKill(BuildingBlock block) => _blocks.Remove(block);

        private void OnUserConnected(IPlayer player)
        {
            BasePlayer bp = player.Object as BasePlayer;
            LastConnect(bp.userID);

            if (storedData.players.ContainsKey(bp.userID)) return;
            storedData.players.Add(bp.userID, 0d);
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (player is BasePlayer && !player.IsNpc)
            {

                if (!player.userID.IsSteamId()) return;

                if (!config.Messages.MessageOnFirstConnection || storedData.FirstMessaged.Contains(player.userID)) return;
                storedData.FirstMessaged.Add(player.userID);

                var val = 0d;
                if (storedData.players.TryGetValue(player.userID, out val) && (val > 100d || val == -50d || val == -25d)) return;

                string msg = string.Format(lang.GetMessage("firstconnectionmessage", this, player.UserIDString), (config.Main.ProtectionTime / 3600d));
                if (config.Messages.UseGT)
                {
                    player.SendConsoleCommand("gametip.showgametip", msg);
                    timer.Once(10f, () => player.SendConsoleCommand("gametip.hidegametip"));
                }
                else
                {
                    SendReply(player, msg);
                }
            }
        }

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                if (storedData.InTeam.Contains(player.userID)) return;
                storedData.InTeam.Add(player.userID);
            }
        }

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                timer.Once(2f, () =>
                {
                    storedData.InTeam.Add(player.userID);
                    SyncTeam(team, player.userID);
                });
            }
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam team, ulong target)
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                if (storedData.InTeam.Contains(target)) storedData.InTeam.Remove(target);
            }
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                if (storedData.InTeam.Contains(player.userID)) storedData.InTeam.Remove(player.userID);
            }
        }

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                foreach (ulong member in team.members)
                {
                    if (storedData.InTeam.Contains(member)) storedData.InTeam.Remove(member);
                }
            }
        }

        #endregion

        #region API

        bool IgnorePlayer(object o)
        {
            ulong id = 0u;

            if (o is BasePlayer)
            {
                id = (o as BasePlayer).userID;
            }

            else if (ulong.TryParse(o.ToString(), out id))
            {
                //Do nothing I guess?
            }

            if (id == 0u) return false;

            if (!storedData.IgnoredPlayers.Contains(id))
            {
                storedData.IgnoredPlayers.Add(id);
                SaveData();
                return true;
            }

            return false;
        }

        bool UnIgnorePlayer(object o)
        {
            ulong id = 0u;

            if (o is BasePlayer)
            {
                id = (o as BasePlayer).userID;
            }

            else if (ulong.TryParse(o.ToString(), out id))
            {
                //Do nothing I guess?
            }

            if (id == 0u) return false;

            if (storedData.IgnoredPlayers.Contains(id))
            {
                storedData.IgnoredPlayers.Remove(id);
                SaveData();
                return true;
            }

            return false;
        }

        #endregion

        #region Clans
        private bool AllowOwnerCheckTimeClans(BasePlayer attacker, ulong ID)
        {
            var player = Convert.ToString(attacker.UserIDString);
            var owner = Convert.ToString(ID);
            var val = 0d;

            if (config.Messages.ShowOwnerTime && config.Relationship.CheckClan)
            {
                var ownerclanName = Clans.Call<string>("GetClanOf", player);

                var playerclanName = Clans.Call<string>("GetClanOf", owner);

                if (!string.IsNullOrEmpty(playerclanName) || !string.IsNullOrEmpty(ownerclanName))
                {
                    if (playerclanName == ownerclanName)
                    {
                        if (storedData.players.TryGetValue(ID, out val) && (val == -50d)) return false;
                        return true;
                    }
                }
            }
            return false;
        }

        private bool CheckClan(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var name = CheckForRaidingTools(hitinfo);
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;


            ulong userID = attacker?.userID ?? 0u;
            var clan = ClanInfo.GetClanOf(userID) ?? null;
            if (clan == null)
            {
                var clanName = Clans?.Call<string>("GetClanOf", userID) ?? string.Empty;
                if (!string.IsNullOrEmpty(clanName))
                {
                    var members = GetClanMembers(clanName);
                    var claninfo = new ClanInfo { clanName = clanName, members = members };
                    ClanInfo.clanCache.Add(claninfo);

                    if (claninfo.members.Contains(owner)) return true;
                }
            }

            else if (clan.members.Contains(owner)) return true;

            return false;
        }

        private List<ulong> GetClanMembers(string clanName)
        {
            if (string.IsNullOrEmpty(clanName)) return new List<ulong>();

            var claninfo = ClanInfo.FindClanByName(clanName);
            if (claninfo != null) return claninfo.members;

            if (Clans == null) return new List<ulong>();

            List<ulong> IDlist = new List<ulong>();

            foreach (var p in covalence.Players.All)
            {
                string clan = Clans?.Call<string>("GetClanOf", p) ?? string.Empty;

                if (clan == clanName)
                    IDlist.Add(ulong.Parse(p.Id));
            }

            RefreshClanCache();
            return IDlist;
        }

        private void RefreshClanCache()
        {
            if (config.Relationship.CheckClan && Clans == null)
            {
                Puts(lang.GetMessage("C_notInstalled", this, null));
                return;
            }

            foreach (var player in covalence.Players.All.Where(x => !x.IsBanned))
            {
                ulong playerID = ulong.Parse(player.Id);
                var clanName = Clans.Call<string>("GetClanOf", playerID);
                if (!string.IsNullOrEmpty(clanName))
                {
                    if (!ClanInfo.clanCache.Select(x => x.clanName).Contains(clanName))
                    {
                        var clan = new ClanInfo { clanName = clanName, members = new List<ulong> { playerID } };
                        ClanInfo.clanCache.Add(clan);
                    }

                    else
                    {
                        foreach (var clan in ClanInfo.clanCache)
                        {
                            if (clanName == clan.clanName && !clan.members.Contains(playerID))
                                clan.members.Add(playerID);
                        }
                    }
                }
            }
        }

        private void RemoveClanProtection(BasePlayer attacker, ulong playerID)
        {
            if (playerID == 0u) return;

            var clanName = Clans.Call<string>("GetClanOf", playerID);
            if (string.IsNullOrEmpty(clanName)) return;

            var ClanMembers = ClanInfo.FindClanByName(clanName)?.members ?? new List<ulong>();
            if (ClanMembers.Count < 1)
            {
                return;
            }

            var list = storedData.players.Where(x => x.Value != -50d && ClanMembers.Contains(x.Key));
            if (list.Count() < 1) return;

            foreach (var member in list.ToList()) storedData.players[member.Key] = -50d;
            Puts(lang.GetMessage("clan_lostnoob", this, null), clanName);

            string msg = string.Format(lang.GetMessage("lost_clansprotection", this, attacker.UserIDString));
            if (config.Messages.UseGT)
            {
                attacker.SendConsoleCommand("gametip.showgametip", msg);
                timer.Once(10f, () => attacker.SendConsoleCommand("gametip.hidegametip"));
            }
            else
            {
                SendReply(attacker, msg);
            }

            if (config.Advance.EnableLogging) LogToFile("clanlostnoob", $"[{DateTime.Now}] - Clan '{clanName}' lost their noob status because {playerID} tried to raid", this, false);
        }

        #endregion

        #region Teams

        private bool AllowOwnerCheckTimeTeams(BasePlayer attacker, ulong ID)
        {
            var val = 0d;

            if (config.Messages.ShowOwnerTime && config.Relationship.CheckTeam)
            {
                var Instance = RelationshipManager.ServerInstance;

                BasePlayer ownerPlayer;
                if (Instance == null) PrintWarning("RelationshipManager instance is null! how is this even possible?");
                if (Instance.cachedPlayers.TryGetValue(ID, out ownerPlayer))
                {
                    if (ownerPlayer.currentTeam == attacker.currentTeam && ownerPlayer.currentTeam != 0)
                    {
                        if (storedData.players.TryGetValue(ID, out val) && (val == -50d)) return false;
                        return true;
                    }
                }
            }

            return false;
        }

        private bool CheckTeam(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;
            var Instance = RelationshipManager.ServerInstance;

            //Check Team For Owner
            BasePlayer ownerPlayer;
            if (Instance == null) PrintWarning("RelationshipManager instance is null! how is this even possible?");
            else
            {
                if (Instance.cachedPlayers.TryGetValue(owner, out ownerPlayer))
                {
                    if (ownerPlayer.currentTeam == attacker.currentTeam && ownerPlayer.currentTeam != 0) return true;
                }
            }

            return false;
        }

        private void RemoveTeamProtection(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var name = CheckForRaidingTools(hitinfo);
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;

            //Remove protection from whole team
            if (config.Main.UnNoobNew)
            {
                if (attacker.currentTeam != 0)
                {
                    if (storedData.players[attacker.userID] >= 0)
                    {
                        string msg = string.Format(lang.GetMessage("lost_teamsprotection", this, attacker.UserIDString));

                        if (config.Messages.UseGT)
                        {
                            attacker.SendConsoleCommand("gametip.showgametip", msg);
                            timer.Once(10f, () => attacker.SendConsoleCommand("gametip.hidegametip"));
                        }
                        else
                        {
                            SendReply(attacker, msg);
                        }

                        MessagePlayer(attacker, owner);
                        if (config.Advance.EnableLogging) LogToFile($"TeamLostNoob", $"[{DateTime.Now}] - {attacker} lost their team noob status.", this, false);
                    }
                    var team = RelationshipManager.ServerInstance?.FindPlayersTeam(attacker.userID);
                    foreach (var member in team.members) storedData.players[member] = -50d;
                }
            }
        }

        private void SyncTeam(RelationshipManager.PlayerTeam team, ulong ID)
        {
            foreach (ulong member in team.members)
            {
                var LeaderPlayTime = storedData.players[ID];
                var MemberPlaytime = storedData.players[member];

                if (LeaderPlayTime == MemberPlaytime)
                {
                    continue;
                }
                if (LeaderPlayTime > MemberPlaytime)
                {
                    if (MemberPlaytime == -50d)
                    {
                        WriteTeamData(ID, -50d);
                        SyncTeam(team, ID);
                        break;
                    }
                    WriteTeamData(member, LeaderPlayTime);
                    continue;
                }
                if (LeaderPlayTime < MemberPlaytime)
                {
                    if (LeaderPlayTime == -50d)
                    {
                        WriteTeamData(member, -50d);
                        SyncTeam(team, ID);
                        break;
                    }
                    WriteTeamData(ID, MemberPlaytime);
                    SyncTeam(team, ID);
                    break;
                }
            }
        }

        // For when Plugins create Teams without calling any Rust Hooks
        private void FailSafe()
        {
            var TeamManager = RelationshipManager.ServerInstance;

            foreach (var team in TeamManager.teams)
            {
                foreach (var member in team.Value.members)
                {

                    if (storedData.players.ContainsKey(member))
                    {
                        if (storedData.InTeam.Contains(member)) continue;
                        else storedData.InTeam.Add(member);
                    }
                    else
                    {
                        storedData.InTeam.Add(member);
                        storedData.players.Add(member, 0d);
                    }
                }
            }

            foreach (BasePlayer bp in BasePlayer.activePlayerList)
            {
                if (bp.currentTeam == 0)
                {
                    if (storedData.InTeam.Contains(bp.userID)) 
                    {
                        storedData.InTeam.Remove(bp.userID);
                    }
                }
            }

            foreach (BasePlayer bp in BasePlayer.sleepingPlayerList)
            {
                if (bp.currentTeam == 0)
                {
                    if (storedData.InTeam.Contains(bp.userID))
                    {
                        storedData.InTeam.Remove(bp.userID);
                    }
                }
            }
        }

        #endregion

        #region Start Protection

        bool HasProtection(BasePlayer player)
        {
            if (player == null) return false;

            if (StartProtection != null && StartProtection.IsLoaded)
            {
                if (StartProtection.Call<bool>("HasProtection", player))
                {
                    return true;
                }
            }
            return false;
        }

        #endregion

        #region Playtime Checks

        private void APICall(ulong ID)
        {
            if (!ID.IsSteamId()) return;
            if (PlaytimeTracker == null)
            {
                Puts(lang.GetMessage("pt_notInstalled", this, null));
                return;
            }

            double apitime = -1;

            try
            {
                apitime = PlaytimeTracker?.Call<double>("GetPlayTime", ID.ToString()) ?? -1d;
            }

            catch (Exception)
            {
                Puts(lang.GetMessage("userinfo_nofound", this, null), ID);
                if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Failed to get playtime info for {ID}", this, false);
                storedData.playersWithNoData.Add(ID);
                timer.Once(300f, () => APICall_SecondAttempt(ID));
            }

            if (apitime != -1d)
            {
                var val = 0d;
                if (storedData.players.ContainsKey(ID))
                {
                    if (storedData.players.TryGetValue(ID, out val) && (val >= apitime)) return;
                    storedData.players[ID] = apitime;
                }
                else
                {
                    storedData.players.Add(ID, apitime);
                    Puts(lang.GetMessage("userinfo_found", this, null), ID);
                    if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Successfully got playtime info for {ID}", this, false);
                }
            }
        }

        private void APICall_SecondAttempt(ulong ID)
        {
            double apitime = -1;

            try
            {
                apitime = PlaytimeTracker?.Call<double>("GetPlayTime", ID.ToString()) ?? -1d;
            }

            catch (Exception)
            {
                Puts(lang.GetMessage("userinfo_nofound_2nd_attempt", this, null), ID);
                if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Failed to get playtime info for {ID}. Has been marked as non-noob", this, false);

                if (storedData.players.ContainsKey(ID))
                {
                    storedData.players[ID] = -50d;
                    if (storedData.playersWithNoData.Contains(ID)) storedData.playersWithNoData.Remove(ID);
                    if (storedData.FirstMessaged.Contains(ID) == false) storedData.FirstMessaged.Add(ID);
                    if (storedData.ShowTwigsNotProtected.Contains(ID) == false) storedData.ShowTwigsNotProtected.Add(ID);

                    return;
                }
                else
                {
                    storedData.players.Add(ID, -50d);
                    if (storedData.playersWithNoData.Contains(ID)) storedData.playersWithNoData.Remove(ID);
                    if (storedData.FirstMessaged.Contains(ID) == false) storedData.FirstMessaged.Add(ID);
                    if (storedData.ShowTwigsNotProtected.Contains(ID) == false) storedData.ShowTwigsNotProtected.Add(ID);
                }
            }

            if (apitime != -1d)
            {
                if (storedData.players.ContainsKey(ID)) storedData.players[ID] = apitime;
                else
                {
                    storedData.players.Add(ID, apitime);
                    Puts(lang.GetMessage("userinfo_found", this, null), ID);
                    if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Successfully got playtime info for {ID}", this, false);
                }
            }
        }

        private void APICall_TeamSync(ulong ID)
        {
            if (!ID.IsSteamId()) return;
            if (PlaytimeTracker == null)
            {
                Puts(lang.GetMessage("pt_notInstalled", this, null));
                return;
            }

            var team = RelationshipManager.ServerInstance?.FindPlayersTeam(ID);

            foreach (ulong member in team.members)
            {
                double apitime = PlaytimeTracker?.Call<double>("GetPlayTime", ID.ToString()) ?? -1d;
                double apitime_member = PlaytimeTracker?.Call<double>("GetPlayTime", member.ToString()) ?? -1d;

                APICall_TeamSync_Compare(ID, member, apitime, apitime_member);
            }

            APICall_TeamSync_Final(ID);
        }

        private void APICall_TeamSync_Compare(ulong ID, ulong member, double apitime, double apitime_member)
        {
            if (ID == member)
            {
                WriteTeamData(ID, apitime);
                return;
            }
            if (apitime == apitime_member)
            {
                WriteTeamData(ID, apitime);
                WriteTeamData(member, apitime);
                return;
            }
            if (apitime > apitime_member)
            {
                WriteTeamData(ID, apitime);
                WriteTeamData(member, apitime);
                return;
            }
            if (apitime < apitime_member)
            {
                WriteTeamData(ID, apitime_member);
                WriteTeamData(member, apitime_member);

                if (LeaderLower.Contains(ID))
                {
                    return;
                }

                LeaderLower.Add(ID);
                return;
            }
        }

        private void APICall_TeamSync_Final(ulong ID)
        {
            var team = RelationshipManager.ServerInstance?.FindPlayersTeam(ID);

            if (LeaderLower.Contains(ID))
            {
                LeaderLower.Remove(ID);
                SyncTeam(team, ID);

            }
            SyncTeam(team, ID);
            return;
        }

        private void WriteTeamData(ulong ID, double apitime)
        {
            if (ID == 0) return;
            storedData.players[ID] = apitime;
        }

        private void Check()
        {
            if (BasePlayer.activePlayerList.Count == 0) return;

            foreach (BasePlayer bp in BasePlayer.activePlayerList)
            {
                if (!bp.IsConnected || bp == null) continue;
                if (!bp.userID.IsSteamId()) continue;
                if (storedData.playersWithNoData.Contains(bp.userID)) continue;

                var val = 0d;

                if (storedData.players.TryGetValue(bp.userID, out val) && (val == -50d || val == -25d)) continue;
                if (config.Relationship.SyncTeamPlaytime && storedData.InTeam.Contains(bp.userID))
                {
                    APICall_TeamSync(bp.userID);
                    continue;
                }
                APICall(bp.userID);
            }

            foreach (BasePlayer bp in BasePlayer.sleepingPlayerList)
            {
                if (bp == null) continue;
                if (!bp.userID.IsSteamId()) continue;
                if (storedData.playersWithNoData.Contains(bp.userID)) continue;

                var val = 0d;

                if (storedData.players.TryGetValue(bp.userID, out val) && (val == -50d || val == -25d)) continue;
                if (config.Relationship.SyncTeamPlaytime && storedData.InTeam.Contains(bp.userID))
                {
                    APICall_TeamSync(bp.userID);
                    continue;
                }

                APICall(bp.userID);
            }
        }

        private void Check(ulong ID)
        {
            if (storedData.playersWithNoData.Contains(ID)) return;
            if (storedData.players[ID] == -50d || storedData.players[ID] == -25d) return;
            if (config.Relationship.SyncTeamPlaytime && storedData.InTeam.Contains(ID))
            {
                APICall_TeamSync(ID);
                return;
            }
            APICall(ID);
        }

        #endregion

        #region Weapon Checks

        private string CheckForRaidingTools(HitInfo hitinfo)
        {
            string name = string.Empty;

            if (hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_fire"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_heli_napalm"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_heli"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_mlrs"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_hv"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_basic"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rocket_smoke"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "explosive.timed.deployed"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "survey_charge.deployed"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "explosive.satchel.deployed"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "grenade.beancan.deployed"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "grenade.f1.deployed"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "40mm_grenade_he"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "flamethrower.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "spear_stone.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "spear_wooden.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "knife_bone.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "bone_club.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "butcherknife.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "machete.weapon"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "knife.combat.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "longsword.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "mace.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "paddle.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "pitchfork.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "salvaged_cleaver.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "salvaged_sword.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "hatchet.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "pickaxe.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "axe_salvaged.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "hammer_salvaged.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "icepick_salvaged.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "stonehatchet.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "stone_pickaxe.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "rock.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "skull.entity"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "snowballgunbullet"
            || hitinfo?.WeaponPrefab?.ShortPrefabName == "jackhammer.entity")
            {
                name = hitinfo?.WeaponPrefab?.ShortPrefabName;
            }
            else
            {
                name = hitinfo?.ProjectilePrefab?.name.ToString();
            }

            return name;
        }

        private bool NullWeaponCheck(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var name = CheckForRaidingTools(hitinfo);
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;

            if (config.Entity.AllowedEntities.ContainsKey(entity.ShortPrefabName))
            {
                if (name == null && owner != 0u && attacker != null)
                {
                    if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == false)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            NextTick(() =>
                            {
                                RemoveProtection(entity, hitinfo);
                                MessagePlayer(attacker, owner);
                                Refund(attacker, name, entity);
                            });
                            return true;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == true)
                    {
                        return true;
                    }
                    else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == false)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            NextTick(() =>
                            {
                                RemoveProtection(entity, hitinfo);
                                MessagePlayer(attacker, owner);
                                Refund(attacker, name, entity);
                            });
                            return true;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == true)
                    {
                        return true;
                    }
                    else if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }

                if (name == null && owner != 0u && attacker == null)
                {
                    if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }

                return false;
            }

            if (config.Entity.AllowedEntitiesNoob.ContainsKey(entity.ShortPrefabName))
            {
                if (name == null && owner != 0u && attacker != null)
                {
                    if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == false)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            NextTick(() =>
                            {
                                RemoveProtection(entity, hitinfo);
                                MessagePlayer(attacker, owner);
                                Refund(attacker, name, entity);
                            });
                            return true;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == true)
                    {
                        return true;
                    }
                    else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == false)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            NextTick(() =>
                            {
                                RemoveProtection(entity, hitinfo);
                                MessagePlayer(attacker, owner);
                                Refund(attacker, name, entity);
                            });
                            return true;
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == true)
                    {
                        return true;
                    }
                    else if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }

                if (name == null && owner != 0u && attacker == null)
                {
                    if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }

                return false;
            }

            if (name == null && owner != 0u && attacker != null)
            {
                if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == false)
                {
                    if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        NextTick(() =>
                        {
                            RemoveProtection(entity, hitinfo);
                            MessagePlayer(attacker, owner);
                            Refund(attacker, name, entity);
                        });
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }
                else if (config.Relationship.CheckTeam && CheckTeam(entity, hitinfo) == true)
                {
                    return true;
                }
                else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == false)
                {
                    if (PlayerIsNew(owner))
                    {
                        hitinfo.damageTypes = new DamageTypeList();
                        hitinfo.DoHitEffects = false;
                        hitinfo.HitMaterial = 0;
                        hitinfo.damageTypes.ScaleAll(0f);
                        NextTick(() =>
                        {
                            RemoveProtection(entity, hitinfo);
                            MessagePlayer(attacker, owner);
                            Refund(attacker, name, entity);
                        });
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                }
                else if (config.Relationship.CheckClan && CheckClan(entity, hitinfo) == true)
                {
                    return true;
                }
                else if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    return true;
                }
                else
                {
                    return true;
                }
            }

            if (name == null && owner != 0u && attacker == null)
            {
                if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    return true;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        #endregion

        #region Helper Methods

        private bool AllowOwnerCheckTime(BasePlayer attacker, ulong ID)
        {
            var player = Convert.ToString(attacker.UserIDString);
            var owner = Convert.ToString(ID);
            var val = 0d;

            if (config.Messages.ShowOwnerTime)
            {
                if (player == owner)
                {
                    if (storedData.players.TryGetValue(ID, out val) && (val == -50d)) return false;
                    return true;
                }
            }

            return false;
        }

        private bool CheckForBuildingOrDeployable(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var dmgType = hitinfo?.damageTypes?.GetMajorityDamageType() ?? DamageType.Generic;
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;

            if (dmgType == DamageType.Decay || dmgType == DamageType.Generic || dmgType == DamageType.Bite) return false;

            if (owner == 0u) return false;

            if (entity is BuildingBlock || entity is Door) return true;
            if (entity.PrefabName.Contains("deployable")) return true;
            if (entity.PrefabName.Contains("window")) return true;
            if (entity.PrefabName.Contains("grill")) return true;
            if (entity.PrefabName.Contains("turret")) return true;
            if (entity.PrefabName.Contains("wall.external")) return true;
            if (entity.PrefabName.Contains("solarpanel")) return true;
            if (entity.PrefabName.Contains("electrical")) return true;
            if (entity.PrefabName.Contains("furnace")) return true;
            if (entity.PrefabName.Contains("box")) return true;
            if (entity.PrefabName.Contains("frame.cell")) return true;
            if (entity.PrefabName.Contains("shutter")) return true;
            if (entity.PrefabName.Contains("ladder")) return true;
            if (entity.PrefabName.Contains("water_catcher")) return true;
            if (entity.PrefabName.Contains("sign")) return true;
            if (entity.PrefabName.Contains("switch")) return true;
            if (entity.PrefabName.Contains("smart")) return true;
            if (entity.PrefabName.Contains("netting")) return true;
            if (entity.PrefabName.Contains("fence")) return true;
            if (entity.PrefabName.Contains("generator")) return true;
            if (entity.PrefabName.Contains("watchtower")) return true;
            if (entity.PrefabName.Contains("landmine")) return true;

            return false;
        }

        private bool CheckForHelicopterOrMLRS(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var name = CheckForRaidingTools(hitinfo);
            var owner = config.Other.CheckFullOwnership ? FullOwner(entity) : entity.OwnerID;
            BasePlayer attacker = hitinfo.InitiatorPlayer;
            var dmgType = hitinfo?.damageTypes?.GetMajorityDamageType() ?? DamageType.Generic;

            if (name != null && owner != 0u && attacker != null && dmgType != DamageType.Bullet) return false;

            // Patrol Helicopter
            if (name == "rocket_heli" && owner != 0u && attacker == null && dmgType == DamageType.Explosion)
                {
                    if (config.Other.PatrolHeliDamage)
                    {
                        return true;
                    }
                    else if (!config.Other.PatrolHeliDamage)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            return true;
                        }
                    }

                    return false;
                }

            if (name == "rocket_heli_napalm" && owner != 0u && attacker == null && dmgType == DamageType.Heat)
                {
                    if (config.Other.PatrolHeliDamage)
                    {
                        return true;
                    }
                    else if (!config.Other.PatrolHeliDamage)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            return true;
                        }
                    }

                    return false;
                }

            if (name == null && owner != 0u && attacker == null && dmgType == DamageType.Bullet)
                {
                    if (config.Other.PatrolHeliDamage)
                    {
                        return true;
                    }
                    else if (!config.Other.PatrolHeliDamage)
                    {
                        if (PlayerIsNew(owner))
                        {
                            hitinfo.damageTypes = new DamageTypeList();
                            hitinfo.DoHitEffects = false;
                            hitinfo.HitMaterial = 0;
                            hitinfo.damageTypes.ScaleAll(0f);
                            return true;
                        }
                    }

                    return false;
                }

            // MLRS Damage Fix to Noob Structures
            if (attacker == null && name == "rocket_mlrs")
            {
                if (PlayerIsNew(owner))
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                    hitinfo.damageTypes.ScaleAll(0f);
                    return true;
                }

                return false;
            }
            return false;
        }

        private string CheckLeft(int intsecs)
        {
            var time = DateTime.Now.AddSeconds(intsecs - 1);
            var timespan = time.Subtract(DateTime.Now);

            string t = string.Empty;
            if (timespan.Days != 0) t += timespan.Days + "d ";
            if (timespan.Hours != 0) t += timespan.Hours + "h ";
            if (timespan.Minutes != 0) t += timespan.Minutes + "m ";
            if (timespan.Seconds != 0) t += timespan.Seconds + "s";
            if (t.Last() == ' ')
            {
                string nw = t.Remove(t.Length - 1);
                return nw;
            }

            return t;
        }

        private void CheckPlayersWithNoInfo()
        {
            int rate = (config.Advance.Frequency <= 10) ? 10 : config.Advance.Frequency - 10;

            timer.Every(rate, () =>
            {
                if (storedData.playersWithNoData.Count < 1) return;

                foreach (ulong ID in storedData.playersWithNoData.ToList())
                {
                    double time = -1d;
                    try
                    {
                        time = PlaytimeTracker?.Call<double>("GetPlayTime", ID.ToString()) ?? -1d;
                    }

                    catch (Exception)
                    {
                        continue;
                    }

                    if (time == -1d) continue;

                    if (storedData.players.ContainsKey(ID))
                    {
                        string date = "[" + DateTime.Now.ToString() + "] ";
                        Puts(lang.GetMessage("userinfo_found", this, null), ID);
                        if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Successfully got playtime info for {ID}", this, false);
                        storedData.players[ID] = time;
                        storedData.playersWithNoData.Remove(ID);
                        continue;
                    }

                    storedData.players.Add(ID, time);
                    Puts(lang.GetMessage("userinfo_found", this, null), ID);
                    if (config.Advance.EnableLogging) LogToFile("playtimecollection", $"[{DateTime.Now}] - Successfully got playtime info for {ID}", this, false);
                    storedData.playersWithNoData.Remove(ID);
                    continue;
                }
            });
        }

        private ulong FullOwner(BaseEntity ent, BasePlayer p = null)
        {
            if (ent == null) return 0u;

            var block = ent as BuildingBlock;
            if (block == null) return ent.OwnerID;

            var cached = BuildingInfo.GetByBuildingID(block.buildingID);

            if (cached != null)
            {
                if (cached.GetCacheAge() < 180 && cached.GetCacheAge() != -1) return cached.OwnerID;
            }

            var ownership = new Dictionary<ulong, int>();

            _blocks.RemoveAll(x => x == null || x.IsDestroyed || x.OwnerID == 0u);

            foreach (var x in _blocks) // no more expensive LINQ
            {
                if (x.buildingID != block.buildingID || config.Other.IgnoreTwig && x.grade == BuildingGrade.Enum.Twigs)
                {
                    continue;
                }

                if (!ownership.ContainsKey(x.OwnerID)) ownership[x.OwnerID] = 1;
                else ownership[x.OwnerID]++;
            }

            if (ownership.Count == 0)
            {
                //Should this even happen?
                if (config.Advance.ShowNoOwnerBase) PrintWarning(lang.GetMessage("struct_noowner", this, null), ent.transform.position, ent.OwnerID, block.buildingID);
                if (config.Advance.EnableLogging) LogToFile("other", $"[{DateTime.Now}] - Structure at {ent.transform.position} has no owner", this, false);

                if (cached != null)
                {
                    cached.OwnerID = 0;
                    cached.lastUpdate = DateTime.UtcNow;
                }
                else
                {
                    BuildingInfo.buildCache.Add(new BuildingInfo { buildingID = block.buildingID, lastUpdate = DateTime.UtcNow, OwnerID = 0 });
                }

                return ent.OwnerID;
            }

            var owner = ownership.Max(x => x.Key);

            if (cached != null)
            {
                cached.OwnerID = owner;
                cached.lastUpdate = DateTime.UtcNow;
            }

            else BuildingInfo.buildCache.Add(new BuildingInfo { buildingID = block.buildingID, lastUpdate = DateTime.UtcNow, OwnerID = owner });

            return owner;
        }

        private BaseEntity GetLookAtEntity(BasePlayer player, float maxDist = 10f)
        {
            if (player == null || player.IsDead()) return null;
            RaycastHit hit;
            var currentRot = Quaternion.Euler(player?.serverInput?.current?.aimAngles ?? Vector3.zero) * Vector3.forward;
            var ray = new Ray((player?.eyes?.position ?? Vector3.zero), currentRot);
            if (Physics.Raycast(ray, out hit, maxDist, layers))
            {
                var ent = hit.GetEntity() ?? null;
                if (ent != null && !(ent?.IsDestroyed ?? true)) return ent;
            }

            return null;
        }

        private void LastConnect(ulong ID) => storedData.lastConnection[ID] = DateTime.Now.ToString();

        private void LogPlayer(BasePlayer attacker)
        {
            if (attacker == null) return;
            var val = 0;
            if (!storedData.AttackAttempts.TryGetValue(attacker.userID, out val)) storedData.AttackAttempts[attacker.userID] = 1;
            else storedData.AttackAttempts[attacker.userID]++;
        }

        private void MessagePlayer(BasePlayer attacker, ulong ID)
        {
            if (!storedData.players.ContainsKey(ID)) return;
            double time2 = storedData.players[ID];
            int left = (int)(config.Main.ProtectionTime - time2);

            if (config.Messages.ShowMessage)
            {
                if (config.Messages.ShowOwnerTime && AllowOwnerCheckTime(attacker, ID))
                {
                    if (PlayerIsNew(ID))
                    {
                        SendReply(attacker, lang.GetMessage("cannot_attack_time", this, attacker.UserIDString), CheckLeft(left));
                        return;
                    }
                }

                else if (config.Messages.ShowOwnerTime && AllowOwnerCheckTimeClans(attacker, ID))
                {
                    if (PlayerIsNew(ID))
                    {
                        SendReply(attacker, lang.GetMessage("cannot_attack_time", this, attacker.UserIDString), CheckLeft(left));
                        return;
                    }
                }

                else if (config.Messages.ShowOwnerTime && AllowOwnerCheckTimeTeams(attacker, ID))
                {
                    if (PlayerIsNew(ID))
                    {
                        SendReply(attacker, lang.GetMessage("cannot_attack_time", this, attacker.UserIDString), CheckLeft(left));
                        return;
                    }
                }

                else if (PlayerIsNew(ID))
{
                    if (config.Messages.ShowTime)
                    {
                        SendReply(attacker, lang.GetMessage("cannot_attack_time", this, attacker.UserIDString), CheckLeft(left));
                        return;
                    }

                    SendReply(attacker, lang.GetMessage("cannot_attack_no_time", this, attacker.UserIDString));
                    return;
                }
                
                else
                SendReply(attacker, lang.GetMessage("can_attack", this, attacker.UserIDString));
            }
        }

        private bool PlayerIsNew(ulong ID)
        {
            if (permission.UserHasPermission(ID.ToString(), NoobPerm)) return true;
            var outDouble = 0d;
            if (!storedData.players.TryGetValue(ID, out outDouble) || outDouble == -50d) return false;
            if (outDouble < config.Main.ProtectionTime || outDouble == -25d) return true;
            return false;
        }

        private void RemoveCD(List<BasePlayer> List, BasePlayer player)
        {
            if (player == null) return;
            timer.Once(10, () =>
            {
                if (List.Contains(player)) List.Remove(player);
            });
        }

        private void RemoveProtection(BaseCombatEntity entity, HitInfo hitinfo)
        {
            BasePlayer attacker = hitinfo.InitiatorPlayer;

            if (config.Main.UnNoobNew)
            {
                if (storedData.players[attacker.userID] >= 0)
                {
                    storedData.players[attacker.userID] = -50d;

                    string msg = string.Format(lang.GetMessage("new_user_lostprotection", this, attacker.UserIDString));

                    if (config.Messages.UseGT)
                    {
                        attacker.SendConsoleCommand("gametip.showgametip", msg);
                        timer.Once(10f, () => attacker.SendConsoleCommand("gametip.hidegametip"));
                    }
                    else
                    {
                        SendReply(attacker, msg);
                    }

                    if (config.Advance.EnableLogging) LogToFile("damagedstructure", $"[{DateTime.Now}] - {attacker.userID} lost there noob protection for damaging {entity.OwnerID} structure", this, false);
                }
            }

            if (config.Main.UnNoobManual)
            {
                if (storedData.players[attacker.userID] == -25d)
                {
                    storedData.players[attacker.userID] = -50d;

                    string msg = string.Format(lang.GetMessage("new_user_lostprotection", this, attacker.UserIDString));

                    if (config.Messages.UseGT)
                    {
                        attacker.SendConsoleCommand("gametip.showgametip", msg);
                        timer.Once(10f, () => attacker.SendConsoleCommand("gametip.hidegametip"));
                    }
                    else
                    {
                        SendReply(attacker, msg);
                    }

                    if (config.Advance.EnableLogging) LogToFile("damagedstructure", $"[{DateTime.Now}] - {attacker.userID} lost there noob protection for damaging {entity.OwnerID} structure", this, false);
                }
            }
        }

        private void RemoveInactive()
        {
            foreach (var entry in storedData.lastConnection)
            {
                var val = 0d;
                if (string.IsNullOrEmpty(entry.Value) || !storedData.players.TryGetValue(entry.Key, out val)) continue;
                if (val == -50d) continue;
                var tp = DateTime.Now.Subtract(Convert.ToDateTime(entry.Value));

                if (tp.TotalDays > config.Main.InactivityRemove)
                {
                    Puts(lang.GetMessage("console_lostnoobstatus", this, null), entry.Key, config.Main.InactivityRemove);
                    if (config.Advance.EnableLogging) LogToFile("inactive", $"[{DateTime.Now}] - {entry.Key} hasn't connected for {config.Main.InactivityRemove} days so he lost his noob status", this, false);
                    storedData.players[entry.Key] = -50d;
                    if (config.Relationship.SyncTeamPlaytime && storedData.InTeam.Contains(entry.Key))
                    {
                        ulong ID = entry.Key;
                        var team = RelationshipManager.ServerInstance?.FindPlayersTeam(ID);
                        if (team == null) continue;
                        SyncTeam(team, ID);
                    }
                }
            }
        }

        private void Refund(BasePlayer attacker, string name, BaseEntity ent)
        {
            if (!config.Refund.RefundItem || storedDataItemList.ItemList.Count < 1) return;
            
            foreach (var entry in storedDataItemList.ItemList)
            {
                if (name == entry.Value)
                {
                    if (config.Refund.RefundTimes == 0)
                    {
                        Item item = ItemManager.CreateByName(entry.Key, 1);
                        attacker.GiveItem(item);
                        SendReply(attacker, lang.GetMessage("refund_free", this, attacker.UserIDString), item.info.displayName.english);
                        if (config.Advance.EnableLogging) LogToFile("refund", $"[{DateTime.Now}] - {attacker.UserIDString} was refunded {item.info.displayName.english}", this, false);
                        return;
                    }

                    if (storedData.AttackAttempts[attacker.userID] <= config.Refund.RefundTimes)
                    {
                        int a = config.Refund.RefundTimes - (storedData.AttackAttempts[attacker.userID]);
                        Item item = ItemManager.CreateByName(entry.Key, 1);
                        attacker.GiveItem(item);

                        switch (a)
                        {
                            case 0:
                                {
                                    SendReply(attacker, lang.GetMessage("refund_last", this, attacker.UserIDString), item.info.displayName.english);
                                    if (config.Advance.EnableLogging) LogToFile("refund", $"[{DateTime.Now}] - {attacker.UserIDString} was refunded {item.info.displayName.english} but will not be next time", this, false);

                                    return;
                                }

                            case 1:
                                {
                                    SendReply(attacker, lang.GetMessage("refund_1time", this, attacker.UserIDString), item.info.displayName.english);
                                    if (config.Advance.EnableLogging) LogToFile("refund", $"[{DateTime.Now}] - {attacker.UserIDString} was refunded {item.info.displayName.english} but after 1 more attempt it wont be refunded", this, false);
                                    return;
                                }

                            default:
                                {
                                    SendReply(attacker, lang.GetMessage("refund_nTimes", this, attacker.UserIDString), item.info.displayName.english, a);
                                    if (config.Advance.EnableLogging) LogToFile("refund", $"[{DateTime.Now}] - {attacker.UserIDString} was refunded {item.info.displayName.english} but after {a} more attempts it wont be refunded", this, false);

                                    return;
                                }

                        }
                    }
                }
            }
        }

        private void StartChecking()
        {
            if (config.Relationship.SyncTeamPlaytime)
            {
                timer.Every(config.Advance.Frequency - 5, () =>
                {
                    FailSafe();
                });
            }
            timer.Every(config.Advance.Frequency - 5, () =>
            {
                RemoveInactive();
            });
            timer.Every(config.Advance.Frequency, () =>
            {
                Check();
            });
        }

        #endregion
    }
}


//  Copyright (C) <2021>  <MasterSplinter>
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses></https:>.


// --- End of file: AntiNoobRaid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/arena-walls ---
// --- Original File Path: A/ArenaWalls/ArenaWalls.cs ---

using System;
using UnityEngine;
using System.Linq;
using Oxide.Core.Configuration;
using System.Collections.Generic; 
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("ArenaWalls", "Kappasaurus", "1.0.1")]
    public class ArenaWalls : RustPlugin
    {
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("ArenaWalls");
        Dictionary<string, bool> playerPrefs = new Dictionary<string, bool>();

        private float removeTime = 10f;

        #region Init
        void Init()
        {
            LoadConfig();
			LoadMessages();
            permission.RegisterPermission("arenawalls.admin", this);
        }
        #endregion

        #region Config
        private new void LoadConfig()
        {
            GetConfig(ref removeTime, "Remove time (seconds)");
            SaveConfig();
        }
        #endregion

        #region Comamnds
        [ChatCommand("walls")]
        void ToggleCommand(BasePlayer player, string command, string[] args)
        {
			if(!permission.UserHasPermission(player.net.connection.userid.ToString(), "arenawalls.admin"))
            {
                SendReply(player, Lang("No Permission", player.UserIDString));
                return;
            }
			
            if (!playerPrefs.ContainsKey(player.userID.ToString())) playerPrefs.Add(player.userID.ToString(), true);
            playerPrefs[player.userID.ToString()] = !playerPrefs[player.userID.ToString()];
            dataFile.WriteObject(playerPrefs);

            SendReply(player, playerPrefs[player.userID.ToString()] ? Lang("Enabled", player.UserIDString) : Lang("Disabled"));
        } 
        #endregion

        #region Hooks
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var player = plan.GetOwnerPlayer();

			if (!playerPrefs.ContainsKey(player.UserIDString) && !playerPrefs[player.UserIDString])
			{
				return;
			}

            BaseEntity entity = go.ToBaseEntity();

            if (entity.name.Contains("high"))
            {
                timer.Once(removeTime, () =>
                {
					if (entity != null)
					{
						entity.Kill();
					}
                });
            }
        }
        #endregion

        #region Helpers
        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }
		
		protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");
		
		private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled"] = "You have enabled admin exclusion mode.",
                ["Disabled"] = "You have disabled admin exclusion mode.",
				["No Permission"] = "Error! You don't have permission to use that command."
            }, this);
        }

		string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);	
        #endregion
    }
}

// --- End of file: ArenaWalls.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-doors ---
// --- Original File Path: A/AutoDoors/AutoDoors.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Doors", "Wulf/lukespragg/Arainrr/James/Bushhy", "3.3.10", ResourceId = 1924)]
    [Description("Automatically closes doors behind players after X seconds")]
    public class AutoDoors : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin RustTranslationAPI;
        private const string PERMISSION_USE = "autodoors.use";
        private readonly Hash<ulong, Timer> doorTimers = new Hash<ulong, Timer>();
        private readonly Dictionary<string, string> supportedDoors = new Dictionary<string, string>();
        private HashSet<DoorManipulator> doorManipulators;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_USE, this);
            if (configData.chatS.commands.Length == 0)
            {
                configData.chatS.commands = new[] { "ad" };
            }
            foreach (var command in configData.chatS.commands)
            {
                cmd.AddChatCommand(command, this, nameof(CmdAutoDoor));
            }
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            if (configData.globalS.excludeDoorController)
            {
                doorManipulators = new HashSet<DoorManipulator>();
                Subscribe(nameof(OnEntitySpawned));
                foreach (var doorManipulator in BaseNetworkable.serverEntities.OfType<DoorManipulator>())
                {
                    OnEntitySpawned(doorManipulator);
                }
            }
        }

        private void OnEntitySpawned(DoorManipulator doorManipulator)
        {
            if (doorManipulator == null || doorManipulator.OwnerID == 0) return;
            doorManipulators.Add(doorManipulator);
        }

        private void OnEntityKill(DoorManipulator doorManipulator)
        {
            if (doorManipulator == null || doorManipulators == null) return;
            doorManipulators.RemoveWhere(x => x == doorManipulator);
        }

        private void OnEntityKill(Door door)
        {
            if (door == null || door.net == null) return;
            var doorID = door.net.ID.Value;
            Timer value;
            if (doorTimers.TryGetValue(doorID, out value))
            {
                value?.Destroy();
                doorTimers.Remove(doorID);
            }
            foreach (var playerData in storedData.playerData.Values)
            {
                playerData.theDoorS.Remove(doorID);
            }
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            foreach (var value in doorTimers.Values)
            {
                value?.Destroy();
            }
            SaveData();
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (door == null || door.net == null || !door.IsOpen()) return;
            if (!supportedDoors.ContainsKey(door.ShortPrefabName)) return;
            if (!configData.globalS.useUnownedDoor && door.OwnerID == 0) return;
            if (configData.globalS.excludeDoorController && HasDoorController(door)) return;
            if (configData.usePermission && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;

            var playerData = GetPlayerData(player.userID, true);
            if (!playerData.doorData.enabled) return;
            float autoCloseTime;
            var doorID = door.net.ID.Value;
            StoredData.DoorData doorData;
            if (playerData.theDoorS.TryGetValue(doorID, out doorData))
            {
                if (!doorData.enabled) return;
                autoCloseTime = doorData.time;
            }
            else if (playerData.doorTypeS.TryGetValue(door.ShortPrefabName, out doorData))
            {
                if (!doorData.enabled) return;
                autoCloseTime = doorData.time;
            }
            else autoCloseTime = playerData.doorData.time;

            if (autoCloseTime <= 0) return;
            if (Interface.CallHook("OnDoorAutoClose", player, door) != null) return;

            Timer value;
            if (doorTimers.TryGetValue(doorID, out value))
            {
                value?.Destroy();
            }
            doorTimers[doorID] = timer.Once(autoCloseTime, () =>
            {
                doorTimers.Remove(doorID);
                if (door == null || !door.IsOpen()) return;
                if (configData.globalS.cancelOnKill && player != null && player.IsDead()) return;
                door.SetFlag(BaseEntity.Flags.Open, false);
                door.SendNetworkUpdateImmediate();
            });
        }

        private void OnDoorClosed(Door door, BasePlayer player)
        {
            if (door == null || door.net == null || door.IsOpen()) return;
            Timer value;
            if (doorTimers.TryGetValue(door.net.ID.Value, out value))
            {
                value?.Destroy();
                doorTimers.Remove(door.net.ID.Value);
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private bool HasDoorController(Door door)
        {
            foreach (var doorManipulator in doorManipulators)
            {
                if (doorManipulator != null && doorManipulator.targetDoor == door)
                {
                    return true;
                }
            }
            return false;
        }

        private StoredData.PlayerData GetPlayerData(ulong playerID, bool readOnly = false)
        {
            StoredData.PlayerData playerData;
            if (!storedData.playerData.TryGetValue(playerID, out playerData))
            {
                playerData = new StoredData.PlayerData
                {
                    doorData = new StoredData.DoorData
                    {
                        enabled = configData.globalS.defaultEnabled,
                        time = configData.globalS.defaultDelay,
                    }
                };
                if (readOnly)
                {
                    return playerData;
                }
                storedData.playerData.Add(playerID, playerData);
            }

            return playerData;
        }

        private static Door GetLookingAtDoor(BasePlayer player)
        {
            RaycastHit rHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out rHit, 10f, Rust.Layers.Mask.Construction))
            {
                return rHit.GetEntity() as Door;
            }
            return null;
        }

        private void UpdateConfig()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var itemModDeployable = itemDefinition.GetComponent<ItemModDeployable>();
                if (itemModDeployable == null) continue;
                var door = GameManager.server.FindPrefab(itemModDeployable.entityPrefab.resourcePath)?.GetComponent<Door>();
                if (door == null || string.IsNullOrEmpty(door.ShortPrefabName)) continue;
                ConfigData.DoorSettings doorSettings;
                if (!configData.doorS.TryGetValue(itemDefinition.shortname, out doorSettings))
                {
                    doorSettings = new ConfigData.DoorSettings
                    {
                        enabled = true,
                        displayName = itemDefinition.displayName.english
                    };
                    configData.doorS.Add(itemDefinition.shortname, doorSettings);
                }
                if (doorSettings.enabled && !supportedDoors.ContainsKey(door.ShortPrefabName))
                {
                    supportedDoors.Add(door.ShortPrefabName, doorSettings.displayName);
                }
            }
            SaveConfig();
        }

        #region RustTranslationAPI

        private string GetDeployableTranslation(string language, string deployable) => (string)RustTranslationAPI.Call("GetDeployableTranslation", language, deployable);

        private string GetDeployableDisplayName(BasePlayer player, string deployable, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                displayName = GetDeployableTranslation(lang.GetLanguage(player.UserIDString), deployable);
                if (!string.IsNullOrEmpty(displayName))
                {
                    return displayName;
                }
            }
            return displayName;
        }

        #endregion RustTranslationAPI

        #endregion Methods

        #region ChatCommand

        private void CmdAutoDoor(BasePlayer player, string command, string[] args)
        {
            if (configData.usePermission && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            var playerData = GetPlayerData(player.userID);
            if (args == null || args.Length == 0)
            {
                playerData.doorData.enabled = !playerData.doorData.enabled;
                Print(player, Lang("AutoDoor", player.UserIDString, playerData.doorData.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                return;
            }
            float time;
            if (float.TryParse(args[0], out time))
            {
                if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                {
                    playerData.doorData.time = time;
                    if (!playerData.doorData.enabled) playerData.doorData.enabled = true;
                    Print(player, Lang("AutoDoorDelay", player.UserIDString, time));
                    return;
                }
                Print(player, Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                return;
            }
            switch (args[0].ToLower())
            {
                case "a":
                case "all":
                    {
                        if (args.Length > 1)
                        {
                            if (float.TryParse(args[1], out time))
                            {
                                if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                                {
                                    playerData.doorData.time = time;
                                    playerData.doorTypeS.Clear();
                                    playerData.theDoorS.Clear();
                                    Print(player, Lang("AutoDoorDelayAll", player.UserIDString, time));
                                    return;
                                }

                                Print(player,
                                    Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                        configData.globalS.maximumDelay));
                                return;
                            }
                        }

                        break;
                    }
                case "s":
                case "single":
                    {
                        var door = GetLookingAtDoor(player);
                        if (door == null || door.net == null)
                        {
                            Print(player, Lang("DoorNotFound", player.UserIDString));
                            return;
                        }

                        string doorDisplayName;
                        if (!supportedDoors.TryGetValue(door.ShortPrefabName, out doorDisplayName))
                        {
                            Print(player, Lang("DoorNotSupported", player.UserIDString));
                            return;
                        }

                        StoredData.DoorData doorData;
                        if (!playerData.theDoorS.TryGetValue(door.net.ID.Value, out doorData))
                        {
                            doorData = new StoredData.DoorData
                            { enabled = true, time = configData.globalS.defaultDelay };
                            playerData.theDoorS.Add(door.net.ID.Value, doorData);
                        }

                        if (args.Length <= 1)
                        {
                            doorData.enabled = !doorData.enabled;
                            Print(player,
                                Lang("AutoDoorSingle", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName),
                                    doorData.enabled
                                        ? Lang("Enabled", player.UserIDString)
                                        : Lang("Disabled", player.UserIDString)));
                            return;
                        }

                        if (float.TryParse(args[1], out time))
                        {
                            if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                            {
                                doorData.time = time;
                                Print(player, Lang("AutoDoorSingleDelay", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName), time));
                                return;
                            }

                            Print(player,
                                Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                    configData.globalS.maximumDelay));
                            return;
                        }

                        break;
                    }

                case "t":
                case "type":
                    {
                        var door = GetLookingAtDoor(player);
                        if (door == null || door.net == null)
                        {
                            Print(player, Lang("DoorNotFound", player.UserIDString));
                            return;
                        }

                        string doorDisplayName;
                        if (!supportedDoors.TryGetValue(door.ShortPrefabName, out doorDisplayName))
                        {
                            Print(player, Lang("DoorNotSupported", player.UserIDString));
                            return;
                        }

                        StoredData.DoorData doorData;
                        if (!playerData.doorTypeS.TryGetValue(door.ShortPrefabName, out doorData))
                        {
                            doorData = new StoredData.DoorData
                            { enabled = true, time = configData.globalS.defaultDelay };
                            playerData.doorTypeS.Add(door.ShortPrefabName, doorData);
                        }

                        if (args.Length <= 1)
                        {
                            doorData.enabled = !doorData.enabled;
                            Print(player,
                                Lang("AutoDoorType", player.UserIDString, GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName),
                                    doorData.enabled
                                        ? Lang("Enabled", player.UserIDString)
                                        : Lang("Disabled", player.UserIDString)));
                            return;
                        }

                        if (float.TryParse(args[1], out time))
                        {
                            if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                            {
                                doorData.time = time;
                                Print(player, Lang("AutoDoorTypeDelay", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName), time));
                                return;
                            }

                            Print(player,
                                Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                    configData.globalS.maximumDelay));
                            return;
                        }

                        break;
                    }

                case "h":
                case "help":
                    {
                        StringBuilder stringBuilder = Pool.Get<StringBuilder>();
                        stringBuilder.AppendLine();
                        var firstCmd = configData.chatS.commands[0];
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax1", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax2", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax3", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax4", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax5", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax6", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        Print(player, stringBuilder.ToString());
                        stringBuilder.Clear();
                        Pool.Free(ref stringBuilder);
                        return;
                    }
            }
            Print(player, Lang("SyntaxError", player.UserIDString, configData.chatS.commands[0]));
        }

        #endregion ChatCommand

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use permissions")]
            public bool usePermission = false;

            [JsonProperty(PropertyName = "Clear data on map wipe")]
            public bool clearDataOnWipe = false;

            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalS = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty(PropertyName = "Door Settings")]
            public Dictionary<string, DoorSettings> doorS = new Dictionary<string, DoorSettings>();

            public class DoorSettings
            {
                public bool enabled;
                public string displayName;
            }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Allows automatic closing of unowned doors")]
                public bool useUnownedDoor = false;

                [JsonProperty(PropertyName = "Exclude door controller")]
                public bool excludeDoorController = true;

                [JsonProperty(PropertyName = "Cancel on player dead")]
                public bool cancelOnKill = false;

                [JsonProperty(PropertyName = "Default enabled")]
                public bool defaultEnabled = true;

                [JsonProperty(PropertyName = "Default delay")]
                public float defaultDelay = 5f;

                [JsonProperty(PropertyName = "Maximum delay")]
                public float maximumDelay = 10f;

                [JsonProperty(PropertyName = "Minimum delay")]
                public float minimumDelay = 5f;
            }

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat command")]
                public string[] commands = { "ad", "autodoor" };

                [JsonProperty(PropertyName = "Chat prefix")]
                public string prefix = "<color=#00FFFF>[AutoDoors]</color>: ";

                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

            public class PlayerData
            {
                public DoorData doorData = new DoorData();
                public readonly Dictionary<ulong, DoorData> theDoorS = new Dictionary<ulong, DoorData>();
                public readonly Dictionary<string, DoorData> doorTypeS = new Dictionary<string, DoorData>();
            }

            public class DoorData
            {
                public bool enabled;
                public float time;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            finally
            {
                if (storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            if (configData.clearDataOnWipe)
            {
                ClearData();
            }
            else
            {
                foreach (var value in storedData.playerData.Values)
                {
                    value.theDoorS.Clear();
                }
                SaveData();
            }
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
                ["AutoDoor"] = "Automatic door closing is now {0}",
                ["AutoDoorDelay"] = "Automatic door closing delay set to {0}s. (Doors set by 'single' and 'type' are not included)",
                ["AutoDoorDelayAll"] = "Automatic closing delay of all doors set to {0}s",
                ["DoorNotFound"] = "You need to look at a door",
                ["DoorNotSupported"] = "This type of door is not supported",
                ["AutoDoorDelayLimit"] = "Automatic door closing delay allowed is between {0}s and {1}s",
                ["AutoDoorSingle"] = "Automatic closing of this <color=#4DFF4D>{0}</color> is {1}",
                ["AutoDoorSingleDelay"] = "Automatic closing delay of this <color=#4DFF4D>{0}</color> is {1}s",
                ["AutoDoorType"] = "Automatic closing of <color=#4DFF4D>{0}</color> door is {1}",
                ["AutoDoorTypeDelay"] = "Automatic closing delay of <color=#4DFF4D>{0}</color> door is {1}s",
                ["SyntaxError"] = "Syntax error, type '<color=#ce422b>/{0} <help | h></color>' to view help",

                ["AutoDoorSyntax"] = "<color=#ce422b>/{0} </color> - Enable/Disable automatic door closing",
                ["AutoDoorSyntax1"] = "<color=#ce422b>/{0} [time (seconds)]</color> - Set automatic closing delay for doors, the allowed time is between {1}s and {2}s. (Doors set by 'single' and 'type' are not included)",
                ["AutoDoorSyntax2"] = "<color=#ce422b>/{0} <single | s></color> - Enable/Disable automatic closing of the door you are looking at",
                ["AutoDoorSyntax3"] = "<color=#ce422b>/{0} <single | s> [time (seconds)]</color> - Set automatic closing delay for the door you are looking at, the allowed time is between {1}s and {2}s",
                ["AutoDoorSyntax4"] = "<color=#ce422b>/{0} <type | t></color> - Enable/disable automatic door closing for the type of door you are looking at. ('type' is just a word, not the type of door)",
                ["AutoDoorSyntax5"] = "<color=#ce422b>/{0} <type | t> [time (seconds)]</color> - Set automatic closing delay for the type of door you are looking at, the allowed time is between {1}s and {2}s. ('type' is just a word, not the type of door)",
                ["AutoDoorSyntax6"] = "<color=#ce422b>/{0} <all | a> [time (seconds)]</color> - Set automatic closing delay for all doors, the allowed time is between {1}s and {2}s.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有权限使用该命令",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
                ["AutoDoor"] = "自动关门现在的状态为 {0}",
                ["AutoDoorDelay"] = "自动关门延迟设置为 {0}秒",
                ["AutoDoorDelayAll"] = "全部门的自动关闭延迟设置为 {0}秒",
                ["DoorNotFound"] = "请您看着一条门再输入指令",
                ["DoorNotSupported"] = "不支持您看着的这种门",
                ["AutoDoorDelayLimit"] = "自动关门延迟应该在 {0}秒 和 {1}秒 之间",
                ["AutoDoorSingle"] = "这条 <color=#4DFF4D>{0}</color> 的自动关闭状态为 {1}",
                ["AutoDoorSingleDelay"] = "这条 <color=#4DFF4D>{0}</color> 的自动关闭延迟为 {1}秒",
                ["AutoDoorType"] = "这种 <color=#4DFF4D>{0}</color> 的自动关闭状态为 {1}",
                ["AutoDoorTypeDelay"] = "这种 <color=#4DFF4D>{0}</color> 的自动关闭延迟为 {1}秒",
                ["SyntaxError"] = "语法错误, 输入 '<color=#ce422b>/{0} <help | h></color>' 查看帮助",

                ["AutoDoorSyntax"] = "<color=#ce422b>/{0} </color> - 启用/禁用自动关门",
                ["AutoDoorSyntax1"] = "<color=#ce422b>/{0} [时间 (秒)]</color> - 设置自动关门延迟。(时间在 {1}秒 和 {2}秒 之间) (不包括'single'和'type'设置的门)",
                ["AutoDoorSyntax2"] = "<color=#ce422b>/{0} <single | s></color> - 为您看着的这条门，启用/禁用自动关门",
                ["AutoDoorSyntax3"] = "<color=#ce422b>/{0} <single | s> [时间 (秒)]</color> - 为您看着的这条门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
                ["AutoDoorSyntax4"] = "<color=#ce422b>/{0} <type | t></color> - 为您看着的这种门，启用/禁用自动关门",
                ["AutoDoorSyntax5"] = "<color=#ce422b>/{0} <type | t> [时间 (秒)]</color> - 为您看着的这种门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
                ["AutoDoorSyntax6"] = "<color=#ce422b>/{0} <all | a> [时间 (秒)]</color> - 为所有门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/advanced-upgrading ---
// --- Original File Path: A/AdvancedUpgrading/AdvancedUpgrading.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Advanced Upgrading", "Ryan", "1.0.0")]
    class AdvancedUpgrading : RustPlugin
    {
        #region Declaration

        private ConfigFile CFile;
        private DataFileSystem DFS = Interface.Oxide.DataFileSystem;
        private Dictionary<uint, int> Entities = new Dictionary<uint, int>();
        private const string BypassPerm = "advancedupgrading.bypass";

        #endregion

        #region Configuration

        private class ConfigFile
        {
            [JsonProperty("Make hit data persist restarts")]
            public bool Persist;

            [JsonProperty("Grade and amount of hits it needs")]
            public Dictionary<BuildingGrade.Enum, int> Hits;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    Persist = true,
                    Hits = new Dictionary<BuildingGrade.Enum, int>
                    {
                        [BuildingGrade.Enum.Wood] = 10,
                        [BuildingGrade.Enum.Stone] = 20,
                        [BuildingGrade.Enum.Metal] = 30,
                        [BuildingGrade.Enum.TopTier] = 40
                    }
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            CFile = ConfigFile.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                CFile = Config.ReadObject<ConfigFile>();
                if (CFile == null) Regenerate();
            }
            catch { Regenerate(); }
        }

        protected override void SaveConfig() => Config.WriteObject(CFile);

        private void Regenerate()
        {
            PrintWarning($"Configuration file at 'oxide/config/{Name}.json' seems to be corrupt! Regenerating...");
            CFile = ConfigFile.DefaultConfig();
            SaveConfig();
        }

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoUpgrade"] = "You can't upgrade to <color=orange>{0}</color> yet, you need to hit it with a hammer <color=orange>{1}</color> more times.",
                ["UpgradeReady"] = "An upgrade to <color=orange>{0}</color> on this block is now available."
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Hooks

        private void Init()
        {
            if (!CFile.Persist) Unsubscribe(nameof(OnServerSave));
            else Entities = DFS.ReadObject<Dictionary<uint, int>>(Name);
            permission.RegisterPermission(BypassPerm, this);
        }

        private void OnServerSave() => DFS.WriteObject(Name, Entities);

        private void OnNewSave() => Entities.Clear();

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!(entity is BuildingBlock)) return;
            if(!Entities.ContainsKey(entity.net.ID)) Entities.Add(entity.net.ID, 0);
        }

        private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (permission.UserHasPermission(player.UserIDString, BypassPerm)) return null;
            if (CFile.Hits.ContainsKey(grade) && Entities.ContainsKey(entity.net.ID) && CFile.Hits[grade] > Entities[entity.net.ID])
            {
                PrintToChat(player, Lang("NoUpgrade", player.UserIDString, grade.ToString(), CFile.Hits[grade] - Entities[entity.net.ID]));
                return false;
            }
            return null;
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            var entity = info?.HitEntity;
            if (entity != null)
            {
                if(!Entities.ContainsKey(entity.net.ID))
                    Entities.Add(entity.net.ID, 0);
                Entities[entity.net.ID]++;
                player.SendConsoleCommand("note.inv", -1565095136, 1, $"Total Hits: {Entities[entity.net.ID]}");
                foreach (var hit in CFile.Hits)
                {
                    if(hit.Value != Entities[entity.net.ID]) continue;
                    Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + hit.Key.ToString().ToLower() + ".prefab", player.transform.position);
                    PrintToChat(player, Lang("UpgradeReady", player.UserIDString, hit.Key));
                    break;
                }
            }
        }

        #endregion
    }
}

// --- End of file: AdvancedUpgrading.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/advert-messages ---
// --- Original File Path: A/AdvertMessages/AdvertMessages.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Advert Messages", "LaserHydra", "3.0.2", ResourceId = 1510)]
    [Description("Allows to set up messages which are broadcasted in a configured interval")]
    internal class AdvertMessages : CovalencePlugin
    {
        private Configuration _config;
        private int _previousAdvert = -1;

        #region Hooks

        private void Loaded()
        {
            LoadConfig();
            
            Puts($"{Title} is showing adverts every {_config.AdvertInterval} minutes.");
            timer.Every(_config.AdvertInterval * 60, BroadcastNextAdvert);
        }

        #endregion

        #region Helper Methods

        private void BroadcastNextAdvert()
        {
            if (_config.Messages.Count == 0)
                return;

            int advert = GetNextAdvertIndex();

            server.Broadcast(_config.Messages[advert]);

            if (_config.BroadcastToConsole)
                Puts(Formatter.ToPlaintext(_config.Messages[advert]));

            _previousAdvert = advert;
        }

        private int GetNextAdvertIndex()
        {
            if (!_config.ChooseMessageAtRandom)
                return (_previousAdvert + 1) % _config.Messages.Count;

            int advert;
            if (_config.Messages.Count > 1)
            {
                do advert = Random.Range(0, _config.Messages.Count);
                while (advert == _previousAdvert);
            }
            else
                advert = 0;

            return advert;
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = Configuration.CreateDefault();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Messages")]
            public List<string> Messages { get; private set; }

            [JsonProperty("Advert Interval (in Minutes)")]
            public float AdvertInterval { get; private set; }  = 10;

            [JsonProperty("Broadcast to Console (true/false)")]
            public bool BroadcastToConsole { get; private set; } = true;

            [JsonProperty("Choose Message at Random (true/false)")]
            public bool ChooseMessageAtRandom { get; private set; } = false;

            public static Configuration CreateDefault()
            {
                return new Configuration
                {
                    Messages = new List<string>
                    {
                        "Welcome to our server, have fun!",
                        "Please treat everybody respectfully.",
                        "Cheating will result in a [#red]permanent[/#] ban."
                    }
                };
            }
        }

        #endregion
    }
}

// --- End of file: AdvertMessages.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-pickup-barrel ---
// --- Original File Path: A/AutoPickupBarrel/AutoPickupBarrel.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Rust;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Auto Pickup Barrel", "l3rady", "1.3")]
    [Description("Allows players to pick up dropped loot from barrels and road signs on destroy automatically.")]

    public class AutoPickupBarrel : RustPlugin
    {
        private readonly string[] BarrelContainerShortPrefabNames = { "loot_barrel_1", "loot_barrel_2", "loot-barrel-1", "loot-barrel-2", "oil_barrel" };
        private readonly string[] RoadSignContainerShortPrefabNames = { "roadsign1", "roadsign2", "roadsign3", "roadsign4", "roadsign5", "roadsign6", "roadsign7", "roadsign8", "roadsign9" };

        #region Configuration

        private Configuration Settings;

        public class Configuration
        {
            [JsonProperty("Auto pickup distance")]
            public float AutoPickupDistance = 3f;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => Settings = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings == null)
                {
                    throw new JsonException();
                }

                if (!Settings.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(Settings, true);
        }

        #endregion Configuration

        private void Init()
        {
            permission.RegisterPermission("AutoPickupBarrel.Barrel.On", this);
            permission.RegisterPermission("AutoPickupBarrel.Barrel.NoGibs", this);
            permission.RegisterPermission("AutoPickupBarrel.Barrel.InstaKill", this);
            permission.RegisterPermission("AutoPickupBarrel.RoadSign.On", this);
            permission.RegisterPermission("AutoPickupBarrel.RoadSign.NoGibs", this);
            permission.RegisterPermission("AutoPickupBarrel.RoadSign.InstaKill", this);
        }

        private object OnEntityTakeDamage(LootContainer LootEntContainer, HitInfo HitEntInfo)
        {
            // Check we have something to work with
            if (LootEntContainer == null
                || HitEntInfo == null
            ){
                return null;
            }

            // Check we are targetting barrels/roadsigns
            var LootEntContainerName = LootEntContainer.ShortPrefabName;
            if (LootEntContainerName == null){
                return null;
            }

            var AutoPickupPrefab = "";
            if(IsBarrel(LootEntContainerName)) {
                AutoPickupPrefab = "Barrel";
            } else if(IsRoadSign(LootEntContainerName)) {
                AutoPickupPrefab = "RoadSign";
            } else {
                return null;
            }

            return AutoPickup(LootEntContainer, HitEntInfo, AutoPickupPrefab);
        }

        private bool IsBarrel(string LootEntContainerName) {
            return BarrelContainerShortPrefabNames.Contains(LootEntContainerName);
        }

        private bool IsRoadSign(string LootEntContainerName) {
            return RoadSignContainerShortPrefabNames.Contains(LootEntContainerName);
        }

        private object AutoPickup(LootContainer LootEntContainer, HitInfo HitEntInfo, string AutoPickupPrefab) {
            // Check player has permission
            var player = LootEntContainer.lastAttacker as BasePlayer ?? HitEntInfo.InitiatorPlayer;
            if (player == null
                || !permission.UserHasPermission(player.UserIDString, $"AutoPickupBarrel.{AutoPickupPrefab}.On"))
            {
                return null;
            }

            // Check there is loot in the container
            var lootContainerInventory = LootEntContainer?.inventory;
            if (lootContainerInventory == null)
            {
                return null;
            }

            // Check barrel/roadsign is in range unless configured range is 0
            var lootContainerDistance = Vector2.Distance(player.transform.position, LootEntContainer.transform.position);
            if (Settings.AutoPickupDistance > 0 && lootContainerDistance > Settings.AutoPickupDistance)
            {
                return null;
            }


            // Check if InstaKill allowed or enough damage has been done to kill
            var lootContainerRemainingHealth = LootEntContainer.Health() - HitEntInfo.damageTypes.Total();
            if (!permission.UserHasPermission(player.UserIDString, $"AutoPickupBarrel.{AutoPickupPrefab}.InstaKill")
                && lootContainerRemainingHealth > 0)
            {
                return null;
            }

            // Give player the loot from the barrel/roadsign
            for (int i = lootContainerInventory.itemList.Count - 1; i >= 0; i--)
            {

                // If item is scrap, apply the tea bonus drop logic used by the game to award extra scrap.
                if(lootContainerInventory.itemList[i].info.shortname == "scrap")
                {
                    float num = (player.modifiers != null) ? (1f + player.modifiers.GetValue(global::Modifier.ModifierType.Scrap_Yield, 0f)) : 0f;
                    if (num > 1f)
                    {
                        float num2 = player.modifiers.GetVariableValue(global::Modifier.ModifierType.Scrap_Yield, 0f);
                        float num3 = Mathf.Max((float)lootContainerInventory.itemList[i].amount * num - (float)lootContainerInventory.itemList[i].amount, 0f);

                        num2 += num3;
                        int num4 = 0;
                        if (num2 >= 1f)
                        {
                            num4 = (int)num2;
                            num2 -= (float)num4;
                        }
                        player.modifiers.SetVariableValue(global::Modifier.ModifierType.Scrap_Yield, num2);
                        if (num4 > 0)
                        {
                            lootContainerInventory.itemList[i].amount += num4;
                        }
                    }
                }

                // Place item in player inventory
                player.GiveItem(lootContainerInventory.itemList[i], BaseEntity.GiveItemReason.PickedUp);
            }

            // Check the barrel/roadsign is empty
            if (lootContainerInventory.itemList == null || lootContainerInventory.itemList.Count <= 0)
            {
                NextTick(() =>
                {
                    // Call the OnEntityDeath call back as some plugins hook this to award bonus for breaking barrels.
                    Interface.CallHook("OnEntityDeath", LootEntContainer, HitEntInfo);

                    // Kill the barrel/roadsign with or without gibs depending on permission
                    if (permission.UserHasPermission(player.UserIDString, $"AutoPickupBarrel.{AutoPickupPrefab}.NoGibs"))
                    {
                        LootEntContainer?.Kill();

                    } else {
                        LootEntContainer?.Kill(BaseNetworkable.DestroyMode.Gib);

                    }
                });
            }

            return false;
        }
    }
}


// --- End of file: AutoPickupBarrel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auth-level-fix ---
// --- Original File Path: A/AuthLevelFix/AuthLevelFix.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info( "Auth Level Fix", "Mr. Blue", "0.0.1" )]
    [Description( "Stop moderators being able to add moderator or owners" )]
    class AuthLevelFix : CovalencePlugin
    {
        private Configuration _config;

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["Command Blocked"] = "Command '{command}' is blocked for non owners.",
                ["Command Blocked Warning"] = "User {player} ran '{command}' but we blocked it!"
            }, this );
        }

        private string GetMessage( string key, string steamId = null ) => lang.GetMessage( key, this, steamId );
        #endregion

        #region Configuration
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration
            {
                BlockedCommands = new HashSet<string>
                {
                    "moderatorid",
                    "ownerid",
                    "removeowner",
                    "removemoderator",
                },
                LogWarning = true,
                MessageUser = true
            };
        }
        protected override void SaveConfig() => Config.WriteObject( _config );

        private class Configuration
        {
            [JsonProperty( "Log when user tries to run commands" )]
            public bool LogWarning { get; set; }
            
            [JsonProperty( "Show blocked message to user trying to run commands" )]
            public bool MessageUser { get; set; }

            [JsonProperty( "Blocked Commands" )]
            public HashSet<string> BlockedCommands { get; set; }
        }
        #endregion

        private object OnServerCommand( ConsoleSystem.Arg arg )
        {
            if ( _config.BlockedCommands.Contains( arg.cmd.Name ) )
            {
                BasePlayer player = arg.Player();
                if ( player != null && !ServerUsers.Is( player.userID, ServerUsers.UserGroup.Owner ) )
                {
                    if ( _config.LogWarning )
                    {
                        LogWarning( GetMessage( "Command Blocked Warning" ).Replace("{player}", player.displayName).Replace("{command}", $"{arg.cmd.Name} {arg.FullString}" ) );
                    }
                    if ( _config.MessageUser )
                    {
                        player.ConsoleMessage( GetMessage( "Command Blocked", player.UserIDString ).Replace( "{command}", arg.cmd.Name ) );
                    }
                    return true;
                }
            }

            return null;
        }
    }
}


// --- End of file: AuthLevelFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/authentication ---
// --- Original File Path: A/Authentication/Authentication.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Authentication", "FakeNinja", "2.1.2")]
    [Description("Players must enter a password after they wake up or else they'll be kicked")]
    public class Authentication : RustPlugin
    {
		public class Request
		{
			public string m_steamID;
			public BasePlayer m_basePlayer;
			public bool m_authenticated;
			public int m_retries;
			public Timer m_countdown;
			
			public Request(string steamID, BasePlayer basePlayer)
			{
				m_steamID = steamID;
				m_basePlayer = basePlayer;
				m_authenticated = false;
				m_retries = 0;
			}
		}

		/*----------------*/
		/*Plugin Variables*/
		/*----------------*/
		
		static List<Request> requests = new List<Request>();
		
		/*----------------*/
		/*Plugin Functions*/
		/*----------------*/
		
		/*Message Functions*/
		private void write(string message)
		{
			PrintToChat(/*"<color=lightblue>[AUTH]</color> " + */ message);
		}
		
		private void write(BasePlayer player, string message)
		{
			PrintToChat(player,/*"<color=lightblue>[AUTH]</color> " + */ message);
		}
		
		/*Auth Functions*/
		private bool isEnabled()
		{
			return Convert.ToBoolean(Config["ENABLED"]);
		}
		
		private void requestAuth(Request request)
		{
			//Find and replace "{TIMEOUT}" to the timeout set in the config file
			string message = Lang("PASSWORD_REQUEST", request.m_steamID).Replace("{TIMEOUT}",Convert.ToString(Config["TIMEOUT"]));
			
			request.m_countdown = timer.Once(Convert.ToInt32(Config["TIMEOUT"]), () => request.m_basePlayer.Kick(Convert.ToString(Lang("AUTHENTICATION_TIMED_OUT", request.m_steamID))));
			
			write(request.m_basePlayer, message);
		}
		
		/*Chat Commands*/
		[ChatCommand("auth")]
		private void cmdAuth(BasePlayer player, string cmd, string[] args)
		{
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			
			//Shouldn't happen.
			if(request == null) return;
			
			if(!request.m_authenticated) //Limit available commands if player is not authed yet
			{		
				switch(args.Length)
				{
					case 0:
						write(player, "Correct syntax: /auth [password/command] (arguments)");
						break;
					case 1:
						if(args[0] == Convert.ToString(Config["PASSWORD"]))
						{
							request.m_countdown.Destroy();
							request.m_authenticated = true;
							write(player, Lang("AUTHENTICATION_SUCCESSFUL", request.m_steamID));
						}
						else
						{
							int max_retries = Convert.ToInt32(Config["RETRIES"]);
							
							request.m_retries++;
							
							if(max_retries > 0)
							{
								if(request.m_retries == max_retries)
								{
									request.m_basePlayer.Kick(Lang("AUTHENTICATION_TIMED_OUT", request.m_steamID));
								}
								else
								{
									write(player, "Incorrect password. You have " + (max_retries - request.m_retries) + " retries left.");
								}
							}
							else
							{
								write(player, "Incorrect password. Please try again.");
							}
						}
						break;
				}
			}
			else if(/* request.m_authenticated && */permission.UserHasPermission(request.m_steamID, "authentication.edit"))
			{
				switch(args.Length)
				{
					case 0:
						write(player, "Correct syntax: /auth [password/command] (arguments)");
						break;
					case 1:
						if(args[0] == "password")// /auth password
						{
							write(player, "Password: " + Convert.ToString(Config["PASSWORD"]));
						}
						else if(args[0] == "toggle")// /auth toggle
						{
							Config["ENABLED"] = !isEnabled();
							SaveConfig();
							write(player, "Authentication is now " + ((isEnabled()) ? "enabled" : "disabled") + ".");
						}
						else if(args[0] == "status")// /auth status
						{
							write(player, "Authentication is " + ((isEnabled()) ? "enabled" : "disabled") + ".");
						}
						else if(args[0] == "timeout")
						{
							write(player, "Timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
						}
						else if(args[0] == "help")// /auth help
						{
							write(player, 
							"Authentication commands:\n"
							+ "syntax: /auth command [required] (optional)\n"
							+ "<color=lightblue>/auth [password]</color> - authenticates players\n"
							+ "<color=lightblue>/auth password (new password)</color> - shows or sets password\n"
							+ "<color=lightblue>/auth timeout (new timeout)</color> - shows or sets timeout\n"
							+ "<color=lightblue>/auth retries (new retries)</color> - shows or sets retries\n"
							+ "<color=lightblue>/auth toggle (on/off)</color> - toggles Authentication on/off\n"
							+ "<color=lightblue>/auth status</color> - shows Authentication status");
						}
						else if(args[0] == "retries")// /auth retries
						{
							write(player, "Retries: " + Convert.ToString(Config["RETRIES"]));
						}
						break;
					case 2:
						if(args[0] == "password")// /auth password [new password]
						{
							if(args[1] != "password" && args[1] != "help" && args[1] != "toggle" && args[1] != "status" && args[1] != "timeout")
							{
								Config["PASSWORD"] = args[1];
								SaveConfig();
								write(player, "New password: " + Convert.ToString(Config["PASSWORD"]));
							}
						}
						else if(args[0] == "toggle")// /auth toggle (on/off)
						{
							if(args[1] == "on")
							{
								if(!isEnabled())
								{
									Config["ENABLED"] = true;
									SaveConfig();
									write(player, "Authentication is now enabled.");
								}
								else
								{
									write(player, "Authentication is already enabled.");
								}
							}
							else if(args[1] == "off")
							{
								if(isEnabled())
								{
									Config["ENABLED"] = false;
									SaveConfig();
									write(player, "Authentication is now disabled.");
								}
								else
								{
									write(player, "Authentication is already disabled.");
								}
							}
							else
							{
								write(player, "Correct syntax: /auth toggle (on/off)");
							}
						}
						else if(args[0] == "timeout")// /auth timeout [new timeout]
						{
							int converted;
							
							try
							{
								converted = Convert.ToInt32(args[1]);
							}
							catch(FormatException e)
							{
								write(player, "Could not convert " + args[1] + " to an integer.");
								break;
							}
							
							if(converted > 0)
							{	
								Config["TIMEOUT"] = converted;
								SaveConfig();
								write(player, "New timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
							}
							else
							{
								write(player, "Timeout must be greater than 0 seconds.");
							}
							
						}
						else if(args[0] == "retries")// /auth retries [new retries]
						{
							int converted;
							
							try
							{
								converted = Convert.ToInt32(args[1]);
							}
							catch(FormatException e)
							{
								write(player, "Could not convert " + args[1] + " to an integer.");
								break;
							}
							
							if(converted >= 0)
							{	
								Config["RETRIES"] = converted;
								SaveConfig();
								write(player, "New retries: " + Convert.ToString(Config["RETRIES"]));
							}
							else
							{
								write(player, "Retries must be a positive integer.");
							}
						}
						break;
				}
			}
		}
		
		/*Console Commands*/
		[ConsoleCommand("global.auth")]
        void ccmdAuth(ConsoleSystem.Arg arg)
        {
			var args = arg.Args;
			
			if(args == null)
			{
				Puts("Correct syntax: auth [command] (arguments)");
				return;
			}
            
			switch(args.Length)
			{
				case 1:
					if(args[0] == "password")// /auth password
					{
						Puts("Password: " + Convert.ToString(Config["PASSWORD"]));
					}
					else if(args[0] == "toggle")// /auth toggle
					{
						Config["ENABLED"] = !isEnabled();
						SaveConfig();
						Puts("Authentication is now " + ((isEnabled()) ? "enabled" : "disabled") + ".");
					}
					else if(args[0] == "status")// /auth status
					{
						Puts("Authentication is " + ((isEnabled()) ? "enabled" : "disabled") + ".");
					}
					else if(args[0] == "timeout")
					{
						Puts("Timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
					}
					else if(args[0] == "help")// /auth help
					{
						Puts("Authentication commands:\n"
						+ "syntax: auth command [required] (optional)\n"
						+ "auth password (new password) - shows or sets password\n"
						+ "auth timeout (new timeout) - shows or sets timeout\n"
						+ "auth retries (new timeout) - shows or sets retries\n"
						+ "auth toggle (on/off) - toggles Authentication on/off\n"
						+ "auth status - shows Authentication status");
					}
					else if(args[0] == "retries")// /auth retries
					{
						Puts("Retries: " + Convert.ToString(Config["RETRIES"]));
					}
					break;
				case 2:
					if(args[0] == "password")// /auth password [new password]
					{
						if(args[1] != "password" && args[1] != "help" && args[1] != "toggle" && args[1] != "status" && args[1] != "timeout")
						{
							Config["PASSWORD"] = args[1];
							SaveConfig();
							Puts("New password: " + Convert.ToString(Config["PASSWORD"]));
						}
					}
					else if(args[0] == "toggle")// /auth toggle (on/off)
					{
						if(args[1] == "on")
						{
							if(!isEnabled())
							{
								Config["ENABLED"] = true;
								SaveConfig();
								Puts("Authentication is now enabled.");
							}
							else
							{
								Puts("Authentication is already enabled.");
							}
						}
						else if(args[1] == "off")
						{
							if(isEnabled())
							{
								Config["ENABLED"] = false;
								SaveConfig();
								Puts("Authentication is now disabled.");
							}
							else
							{
								Puts("Authentication is already disabled.");
							}
						}
						else
						{
							Puts("Correct syntax: /auth toggle (on/off)");
						}
					}
					else if(args[0] == "timeout")// /auth timeout [new timeout]
					{
						int converted;
						
						try
						{
							converted = Convert.ToInt32(args[1]);
						}
						catch(FormatException e)
						{
							Puts("Could not convert " + args[1] + " to an integer.");
							break;
						}
						
						if(converted > 0)
						{	
							Config["TIMEOUT"] = converted;
							SaveConfig();
							Puts("New timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
						}
						else
						{
							Puts("Timeout must be greater than 0 seconds.");
						}
						
					}
					else if(args[0] == "retries")// /auth retries [new retries]
					{
						int converted;
						
						try
						{
							converted = Convert.ToInt32(args[1]);
						}
						catch(FormatException e)
						{
							Puts("Could not convert " + args[1] + " to an integer.");
							break;
						}
						
						if(converted >= 0)
						{	
							Config["RETRIES"] = converted;
							SaveConfig();
							Puts("New retries: " + Convert.ToString(Config["RETRIES"]));
						}
						else
						{
							Puts("Retries must be a positive integer.");
						}
					}
					break;
			}
		}
		
		/*------------*/
		/*Plugin Hooks*/
		/*------------*/
		
		void Init()
		{
			LoadDefaultConfig();
			permission.RegisterPermission("authentication.edit", this);
		}
		
		void OnServerInitialized()
		{
			HashSet<BasePlayer> online = new HashSet<BasePlayer>(BasePlayer.activePlayerList);
			foreach(BasePlayer player in online)
			{
				Request request = new Request(player.UserIDString, player);
				request.m_authenticated = true;
				requests.Add(request);
			}
		}
		
		void OnPlayerSleepEnded(BasePlayer player)
		{
			if(!requests.Exists(element => element.m_steamID == player.UserIDString))
			{
				Request request = new Request(player.UserIDString, player);
				
				//Authenticate everyone if the plugin is disabled
				request.m_authenticated = !isEnabled();
				requests.Add(request);
				//And don't send the request
				if(isEnabled()) timer.Once(1, () => requestAuth(request));
			}
		}
		
		void OnPlayerDisconnected(BasePlayer player)
		{
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			requests.RemoveAt(requests.IndexOf(request));
		}
		
		object OnPlayerChat(BasePlayer player, string message)
		{
			string hidden = "";
			for(int i = 0; i < Convert.ToString(Config["PASSWORD"]).Length; i++) hidden += "*";
			string replaced = message.Replace(Convert.ToString(Config["PASSWORD"]), hidden);
						
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			
			if(!request.m_authenticated && Convert.ToBoolean(Config["PREVENT_CHAT"]))
			{
				write(player, "You cannot chat before authentication.");
				return true;
			}
			
			if(message != replaced && Convert.ToBoolean(Config["PREVENT_CHAT_PASSWORD"]))
			{
				rust.BroadcastChat("<color=#5af>" + player.displayName + "</color>", replaced, player.UserIDString);
				return true;
			}
			
			return null;
		}
		
		protected override void LoadDefaultConfig()
		{
			Config["ENABLED"] = Config["ENABLED"] ?? true;
			Config["TIMEOUT"] = Config["TIMEOUT"] ?? 30;
			Config["PASSWORD"] = Config["PASSWORD"] ?? "changeme";
			Config["RETRIES"] = Config["RETRIES"] ?? 0;
			Config["PREVENT_CHAT"] = Config["PREVENT_CHAT"] ?? true;
			Config["PREVENT_CHAT_PASSWORD"] = Config["PREVENT_CHAT_PASSWORD"] ?? false;
				
			SaveConfig();	
		}
		
		protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PASSWORD_REQUEST"] = "Type /auth [password] in the following {TIMEOUT} seconds to authenticate or you'll be kicked.",
                ["AUTHENTICATION_TIMED_OUT"] = "You took too long to authenticate or exceeded the maximum amount of retries.",
                ["AUTHENTICATION_SUCCESSFUL"] = "Authentication successful."
            }, this);
		}
		
		private string Lang(string key, string id = null) => lang.GetMessage(key, this, id);
    }
}

// --- End of file: Authentication.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/automatic-plugin-updater ---
// --- Original File Path: A/AutomaticPluginUpdater/AutomaticPluginUpdater.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Automatic Plugin Updater", "birthdates", "1.5.5")]
    [Description("Automatically update your Oxide plugins!")]
    public class AutomaticPluginUpdater : CovalencePlugin
    {
        #region Command

        /// <summary>
        ///     Manually check for updates
        /// </summary>
        /// <param name="caller">Command caller</param>
        /// <param name="command">Command label</param>
        /// <param name="args">Command arguments</param>
        /// <returns>Whether or not the command was executed successfully</returns>
        private bool ManualUpdateCommand(IPlayer caller, string command, IList<string> args)
        {
            if (args.Count < 1)
            {
                caller.Message(Lang("InvalidArgs", caller.Id, command));
                return false;
            }

            var pluginName = args[0];
            if (pluginName.Equals("*"))
            {
                foreach (var loadedPlugin in plugins.GetAll()) CheckPluginCommand(loadedPlugin, caller);
                return true;
            }

            var plugin = plugins.Find(pluginName);
            if (plugin == null)
            {
                caller.Message(Lang("InvalidPlugin", caller.Id, pluginName));
                return false;
            }

            CheckPluginCommand(plugin, caller);
            return true;
        }

        #endregion

        #region Variables

        private const string SearchURL =
            "https://umod.org/plugins/search.json?query={0}&page=1&sort=title&sortdir=asc&filter={1}";

        private readonly IList<string> _toIgnore = new List<string>();
        private readonly IDictionary<Plugin, DateTime> _delayedChecks = new Dictionary<Plugin, DateTime>();
        private const string UpdateCommand = "update";
        private const string UpdatePermission = "automaticpluginupdater.update";

        private readonly Dictionary<string, string> _discordHeaders = new Dictionary<string, string>
            {{"Content-Type", "application/json"}};

        private GameObject _gameObject;

        private CoroutineHandler _coroutineHandler;
        private bool _ready = false;

        private class CoroutineHandler : MonoBehaviour
        {
        }

        #region Rate Limiting

        private const int TimesPerMinute = 30;
        private const int FastTimeMinutes = 1;
        private DateTime _lastCheck;
        private int _frequentTries;

        #endregion

        #endregion

        #region Hooks

        [UsedImplicitly]
        private void Init()
        {
            if (!_config.DisableCheckingOnServerStartup) _ready = true;
            LoadConfig();
            _gameObject = new GameObject();
            _coroutineHandler = _gameObject.AddComponent<CoroutineHandler>();
        }

        [UsedImplicitly]
        private void OnServerInitialized()
        {
            _ready = true;
            AddCovalenceCommand(UpdateCommand, nameof(ManualUpdateCommand), UpdatePermission);
            if (_config.CheckPluginsOnStart) CheckActivePlugins();
            timer.Every(3f, CheckDelayedRequests);
            if (_config.DoRoutineChecks) StartRoutine();
        }

        [UsedImplicitly]
        private void Unload()
        {
            UnityEngine.Object.Destroy(_gameObject);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            CheckPlugin(plugin);
        }

        #endregion

        #region Plugin Checking

        #region Hook Methods

        [HookMethod("CheckActivePlugins")]
        private void CheckActivePlugins()
        {
            foreach (var plugin in plugins.GetAll()) OnPluginLoaded(plugin);
        }

        /// <summary>
        ///     Check a plugin for any updates using uMod's public API
        /// </summary>
        /// <param name="plugin">Target plugin</param>
        /// <param name="bypass">If it should bypass the rate limit</param>
        [HookMethod("CheckPlugin")]
        private void CheckPlugin(Plugin plugin, bool bypass = false)
        {
            if (!_ready || _coroutineHandler == null || plugin.Equals(this) || _toIgnore.Remove(plugin.Filename) ||
                IsBlacklisted(plugin)) return;
            PrintWarning($"Checking for new versions for {plugin.Name} (current version {plugin.Version})");
            var now = DateTime.UtcNow;
            if (!bypass)
            {
                var fast = _delayedChecks.Count > 0 || now - _lastCheck < TimeSpan.FromMinutes(FastTimeMinutes);
                if (fast && _frequentTries++ >= TimesPerMinute)
                {
                    var time = FastTimeMinutes/2 * (_frequentTries - TimesPerMinute);
                    PrintError(
                        $"Too many search requests in such a little time. This request will complete in {time} minute(s).");
                    _delayedChecks[plugin] = DateTime.UtcNow.AddMinutes(time);
                    return;
                }

                if (!fast) _frequentTries = 0;
            }

            _lastCheck = now;
            var title = plugin.Title;
            var splitTitle = SplitByCapital(plugin.Name);
            if (!title.Equals(splitTitle))
            {
                if(!title.Equals(plugin.Name)) PrintWarning("Warning: The plugin \"" + plugin.Name + "\" does not match it's class name! (this can lead to wrong search results)");
                title = splitTitle;
            }
            webrequest.Enqueue(string.Format(SearchURL, title, _config.DisableAuthorCheck ? string.Empty : "&author={1}"), string.Empty,
                (code, data) => HandleSearchRequest(code, data, plugin), this);
        }

        #endregion

        /// <summary>
        ///     Start routine checks on new plugin updates
        /// </summary>
        private void StartRoutine()
        {
            var timeInSeconds = _config.RoutineCheckIntervalSeconds * 60f;
            timer.Every(timeInSeconds, CheckActivePlugins);
        }

        /// <summary>
        ///     Parse a <see cref="string" /> to <see cref="VersionNumber" />
        /// </summary>
        /// <param name="version"><see cref="string" /> version</param>
        /// <returns>The <see cref="VersionNumber" /> of <paramref name="version" /></returns>
        private static VersionNumber ParseVersionNumber(string version)
        {
            var numberStrings = version.Split('.');
            var numbers = new int[3];
            var index = 0;

            foreach (var numberString in numberStrings)
            {
                int number;
                if (!int.TryParse(numberString, out number)) continue;
                numbers[index] = number;
                if (index++ == 2) break;
            }

            return new VersionNumber(numbers[0], numbers[1], numbers[2]);
        }
        
        /// <summary>
        ///     Parse a file name from the end of a download url
        /// </summary>
        /// <param name="url">Target url</param>
        /// <returns>A file name like plugin.cs</returns>
        private static string GetFileNameFromDownloadURL(string url)
        {
            var split = url.Split('/');
            return split[split.Length - 1];
        }

        /// <summary>
        ///     Get the update type
        /// </summary>
        /// <param name="version"><see cref="string" /> version</param>
        /// <param name="oldVersion"><see cref="VersionNumber" /> from the currently loaded plugin</param>
        /// <returns><see cref="UpdateType" /> of this update</returns>
        private static UpdateType GetUpdateType(string version, VersionNumber oldVersion)
        {
            var newVersion = ParseVersionNumber(version);
            if (newVersion <= oldVersion) return UpdateType.Backward;
            if (newVersion.Major > oldVersion.Major) return UpdateType.Major;
            return newVersion.Minor > oldVersion.Minor ? UpdateType.Minor : UpdateType.Patch;
        }

        /// <summary>
        ///     Split a string by it's capital letters
        /// </summary>
        /// <param name="str">Target string</param>
        /// <param name="separator">Separator string between each capital letter</param>
        /// <returns>A new string with <see cref="separator"/> between each capital letter</returns>
        private static string SplitByCapital(string str, string separator = " ")
        {
            var output = string.Empty;
            var chars = str.ToCharArray();
            for (var i = 0; i < chars.Length; i++)
            {
                var character = chars[i];
                if (i != 0 && char.IsUpper(character))
                    output += separator;
                output += character;
            }
            return output;
        }

        /// <summary>
        ///     Check if a plugin is blacklisted & shouldn't fully update
        /// </summary>
        /// <param name="plugin">Target plugin</param>
        /// <param name="start">If we should notify if <see cref="ConfigFile.NotifyBlacklisted" /> is enabled</param>
        /// <returns><see langword="true" /> if we should continue</returns>
        private bool IsBlacklisted(Plugin plugin, bool start = true)
        {
            var blacklisted = _config.BlacklistedPlugins.Any(target => plugin.Name.Equals(target) || plugin.Title.Equals(target)) ||
                              _config.BlacklistedAuthors.Contains(plugin.Author);
            if (blacklisted && _config.NotifyBlacklisted && start) return false;
            return blacklisted;
        }

        /// <summary>
        ///     Handle the search request callback
        /// </summary>
        /// <param name="code">Response code</param>
        /// <param name="data">Response data</param>
        /// <param name="plugin">Plugin we searched for</param>
        private void HandleSearchRequest(int code, string data, Plugin plugin)
        {
            if (TestFailCode(code, data)) return;
            var jObject = JObject.Parse(data);
            JToken dataObject;
            if (!jObject.TryGetValue("data", out dataObject))
            {
                PrintError($"No data found in search? Data:\n{data}");
                return;
            }

            var notFoundType = "No search results";
            var children = dataObject as JArray;
            if (children == null || !children.Any()) goto notFound;
            notFoundType = "No name/author match";
            var first = children.Select(child => child.ToObject<SearchResult>()).FirstOrDefault(child =>
                GetFileNameFromDownloadURL(child.DownloadURL).Equals(plugin.Name + ".cs") && (_config.DisableAuthorCheck || child.Author.Equals(plugin.Author)));
            if (first.Equals(default(SearchResult))) goto notFound;
            if (first.Version.Equals(plugin.Version.ToString()))
            {
                PrintWarning($"{plugin.Name} is up to date! (version: {plugin.Version})");
                return;
            }

            var updateType = GetUpdateType(first.Version, plugin.Version);
            bool updateTypeRet;
            if (!_config.VersionSettings.TryGetValue(updateType, out updateTypeRet) || !updateTypeRet ||
                IsBlacklisted(plugin, false))
            {
                SendUpdateLog(plugin.Name, first.Version, true);
                return;
            }


            PrintWarning($"{plugin.Name} requires new update to {first.Version}");
            _coroutineHandler.StartCoroutine(StartDownload(plugin, first));
            return;
            notFound:
            PrintWarning($"{plugin.Name} was not found on uMod! ({notFoundType})");
        }

        /// <summary>
        ///     Start the download for a new plugin update
        /// </summary>
        /// <param name="plugin">Target plugin</param>
        /// <param name="searchResult">Found plugin from search</param>
        /// <returns><see cref="IEnumerator" /> for coroutine</returns>
        private IEnumerator StartDownload(Plugin plugin, SearchResult searchResult)
        {
            PrintWarning($"Starting download for {plugin.Name} (version {plugin.Version} -> {searchResult.Version})");
            var www = new UnityWebRequest(searchResult.DownloadURL)
            {
                downloadHandler =
                    new DownloadHandlerFile(plugin.Filename)
            };
            yield return www.SendWebRequest();
            if (TestFailCode(Convert.ToInt32(www.responseCode), www.error)) yield break;
            _toIgnore.Add(plugin.Filename);
            SendUpdateLog(plugin.Name, searchResult.Version);
        }

        /// <summary>
        ///     Send an update log into console & Discord
        /// </summary>
        /// <param name="name">Plugin name</param>
        /// <param name="version">New version of this plugin</param>
        /// <param name="halted">If we didn't update due to the config</param>
        private void SendUpdateLog(string name, string version, bool halted = false)
        {
            var updateMessage = name + $" has {(halted ? "a new update" : "been updated to")} version " + version;
            PrintWarning(updateMessage);
            if (!_config.UseDiscordHooks) return;
            var embed = new
            {
                embeds = new object[]
                {
                    new
                    {
                        title = "New plugin update",
                        color = 5238078,
                        description = updateMessage
                    }
                }
            };
            webrequest.Enqueue(_config.DiscordWebHook, JsonConvert.SerializeObject(embed),
                ValidateDiscordWebhookRequest, this, RequestMethod.POST, _discordHeaders);
        }

        /// <summary>
        ///     The shortened JSON struct received from <see cref="SearchURL" />
        /// </summary>
        private struct SearchResult
        {
            [JsonProperty("latest_release_version")]
            public string Version { get; set; }

            [JsonProperty("download_url")] public string DownloadURL { get; set; }
            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("author")] public string Author { get; set; }
        }

        #region Helpers

        /// <summary>
        ///     Check for any delayed requests that are due
        /// </summary>
        private void CheckDelayedRequests()
        {
            for (var i = _delayedChecks.Count - 1; i >= 0; i--)
            {
                var entry = _delayedChecks.ElementAt(i);
                if (entry.Value > DateTime.UtcNow) continue;
                _delayedChecks.Remove(entry);
                CheckPlugin(entry.Key, true);
            }
        }

        /// <summary>
        ///     Helper for retrieving a message from the language file
        /// </summary>
        /// <param name="key">Message key</param>
        /// <param name="id">Player's id (used for languages)</param>
        /// <param name="args">Arguments for formatting</param>
        /// <returns>Fully formatted language message</returns>
        private string Lang(string key, string id, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        /// <summary>
        ///     Test if the web request failed
        /// </summary>
        /// <param name="code">Response code</param>
        /// <param name="data">Response data</param>
        /// <returns>If the web request failed (most likely)</returns>
        private bool TestFailCode(int code, string data)
        {
            if (code == 200) return false;
            PrintError($"Search response without 200! Data:\n{data}");
            if (code == 429) PrintWarning("Possible rate limit.");
            return true;
        }

        /// <summary>
        ///     Check a plugin and send a reply
        /// </summary>
        /// <param name="plugin">Target plugin</param>
        /// <param name="caller">Target to reply to</param>
        private void CheckPluginCommand(Plugin plugin, IPlayer caller)
        {
            caller.Message(Lang("CheckingPlugin", caller.Id, plugin.Name));
            CheckPlugin(plugin);
        }

        /// <summary>
        ///     Validates if a Discord webhook request went through, if not, it prints the error
        /// </summary>
        /// <param name="code">Response code</param>
        /// <param name="data">Response data</param>
        private void ValidateDiscordWebhookRequest(int code, string data)
        {
            if (code != 204 && code != 200 && code != 201) return; //all discord response codes
            PrintError($"Failed to send Discord Webhook (code {code}):\n{data}");
        }

        #endregion

        #endregion

        #region Configuration & Language

        private ConfigFile _config;

        private class ConfigFile
        {
            [JsonProperty("Check Currently Loaded Plugins When This Plugin Enables?")]
            public bool CheckPluginsOnStart { get; set; }

            [JsonProperty("Blacklisted Plugins (won't check for update)")]
            public IList<string> BlacklistedPlugins { get; set; }

            [JsonProperty("Blacklisted Authors (won't check for update)")]
            public IList<string> BlacklistedAuthors { get; set; }

            [JsonProperty("Update Version Settings (which updates to not go through with)")]
            public IDictionary<UpdateType, bool> VersionSettings { get; set; }

            [JsonProperty("Do Routine Checks?")] public bool DoRoutineChecks { get; set; }

            [JsonProperty("Routine Interval Time (Minutes)")]
            public float RoutineCheckIntervalSeconds { get; set; }

            [JsonProperty("Notify on Blacklisted Update?")]
            public bool NotifyBlacklisted { get; set; }

            [JsonProperty("Use Discord Webhooks?")]
            public bool UseDiscordHooks { get; set; }
            
            [JsonProperty("Disable Checking on Server Startup?")]
            public bool DisableCheckingOnServerStartup { get; set; }
            
            [JsonProperty("Disable Author Checking?")] public bool DisableAuthorCheck { get; set; }
            
            [JsonProperty("Discord Webhook")] public string DiscordWebHook { get; set; }
            
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    CheckPluginsOnStart = false,
                    BlacklistedPlugins = new List<string>(),
                    BlacklistedAuthors = new List<string>(),
                    VersionSettings = new Dictionary<UpdateType, bool>
                    {
                        {UpdateType.Backward, false},
                        {UpdateType.Major, false},
                        {UpdateType.Minor, true},
                        {UpdateType.Patch, true}
                    },
                    DoRoutineChecks = true,
                    RoutineCheckIntervalSeconds = 240f, //4 hours
                    UseDiscordHooks = false,
                    NotifyBlacklisted = false,
                    DisableCheckingOnServerStartup = true,
                    DisableAuthorCheck = true,
                    DiscordWebHook = string.Empty
                };
            }
        }

        private enum UpdateType
        {
            Backward,
            Minor,
            Patch,
            Major
        }


        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"InvalidArgs", "Usage: /{0} <*|plugin>"},
                {"InvalidPlugin", "We couldn't find a plugin by the name of \"{0}\""},
                {"CheckingPlugin", "We have starting checking for updates on the plugin \"{0}\""}
            }, this);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: AutomaticPluginUpdater.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/air-fuel ---
// --- Original File Path: A/AirFuel/AirFuel.cs ---

using Newtonsoft.Json;
using System;

// CREDITS
// 0.1.2 - WhiteThunder: allow fuel amount to exceed vanilla fuel amount
// 0.1.1 - WhiteThunder: separate fuel amount setting for ScrapTransportHelicopter
// 0.0.4 - WhiteThunder: restrict fuel amount changes to vendor-spawned vehicles
// 0.0.3 - Orange: various NRE and resource fixes

namespace Oxide.Plugins
{
    [Info("Air Fuel", "WhiteDragon", "0.2.3")]
    [Description("Sets the initial amount of fuel for vendor purchased air vehicles.")]
    public class AirFuel : CovalencePlugin
    {
        private static AirFuel _instance;

        #region _configuration_

        private static Configuration config;

        private class Configuration
        {
            public Fuel.Settings    Fuel;
            public Version.Settings Version;

            private static bool corrupt  = false;
            private static bool dirty    = false;

            public static void Clamp<T>(ref T value, T min, T max) where T : IComparable<T>
            {
                T clamped = Generic.Clamp(value, min, max);

                if(!value.Equals(clamped))
                {
                    dirty = true; value = clamped;
                }
            }

            public static void Load()
            {
                dirty = false;

                try
                {
                    config = _instance.Config.ReadObject<Configuration>();

                    config.Version.Compare(0, 0, 0);
                }
                catch(NullReferenceException)
                {
                    _instance.Puts("Configuration: Created new configuration with default settings.");

                    dirty = true; config = new Configuration();
                }
                catch(JsonException e)
                {
                    _instance.Puts($"Configuration: Using default settings. Delete the configuration file, or fix the following error, and reload; {e}");

                    corrupt = true; config = new Configuration();
                }

                Validate();
            }

            public static void Save()
            {
                if(dirty && !corrupt)
                {
                    dirty = false;

                    _instance.Config.WriteObject(config);
                }
            }

            public static void SetDirty() => dirty = true;

            public static void Unload()
            {
                Save();

                config = null;
            }

            public static void Validate<T>(ref T value, Func<T> initializer, Action validator = null)
            {
                if(value == null)
                {
                    dirty = true; value = initializer();
                }
                else
                {
                    validator?.Invoke();
                }
            }
            private static void Validate()
            {
                Validate(ref config.Fuel,    () => new Fuel.Settings(), () => config.Fuel.Validate());
                Validate(ref config.Version, () => new Version.Settings());

                config.Version.Validate();

                Save();
            }
        }

        #endregion _configuration_

        #region _fuel_

        private class Fuel
        {
            public class Settings
            {
                public int Default;
                public int MiniCopter;
                public int ScrapTransportHelicopter;

                public Settings()
                {
                    Default                  = 100;
                    MiniCopter               =  -1;
                    ScrapTransportHelicopter =  -1;
                }

                public void Validate()
                {
                    Configuration.Clamp(ref Default,                   0, int.MaxValue);
                    Configuration.Clamp(ref MiniCopter,               -2, int.MaxValue);
                    Configuration.Clamp(ref ScrapTransportHelicopter, -2, int.MaxValue);
                }
            }
        }

        #endregion _fuel_

        #region _generic_

        private class Generic
        {
            public static T Clamp<T>(T value, T min, T max) where T : IComparable<T>
            {
                if(value.CompareTo(min) < 0)
                {
                    return min;
                }
                else if(value.CompareTo(max) > 0)
                {
                    return max;
                }

                return value;
            }
        }

        #endregion _generic_

        #region _hooks_

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));

            _instance = this;

            Configuration.Load();
        }

        protected override void LoadDefaultConfig() { }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
        }

        private void OnEntitySpawned(Minicopter vehicle)
        {
            NextTick(() =>
            {
                if(vehicle.creatorEntity == null)
                {
                    return;
                }

                var fuelsystem = vehicle?.GetFuelSystem();
                if(fuelsystem is EntityFuelSystem entityFuelSystem)
                {
                    var fuelAmount = vehicle is ScrapTransportHelicopter ?
                        config.Fuel.ScrapTransportHelicopter :
                        config.Fuel.MiniCopter;

                    if(fuelAmount == -1)
                    {
                        fuelAmount = config.Fuel.Default;
                    }
                    else if(fuelAmount == -2)
                    {
                        return;
                    }

                    var fuelItem = entityFuelSystem.GetFuelItem();
                    if(fuelItem != null && fuelItem.amount != fuelAmount)
                    {
                        fuelItem.amount = fuelAmount;
                        fuelItem.MarkDirty();
                    }
                }
            });
        }

        private void Unload()
        {
            Configuration.Unload();

            _instance = null;
        }

        #endregion _hooks_

        #region _version_

        private new class Version
        {
            public class Settings
            {
                public int Major;
                public int Minor;
                public int Patch;

                public Settings()
                {
                    Major = Minor = Patch = 0;
                }

                public int Compare(int major, int minor, int patch)
                {
                    return
                        (Major != major) ? (Major - major) :
                        (Minor != minor) ? (Minor - minor) :
                        (Patch != patch) ? (Patch - patch) : 0;
                }

                public void Validate()
                {
                    var current = (_instance as CovalencePlugin).Version;

                    if(Compare(current.Major, current.Minor, current.Patch) < 0)
                    {
                        Configuration.SetDirty();

                        Major = current.Major;
                        Minor = current.Minor;
                        Patch = current.Patch;
                    }
                }
            }
        }

        #endregion _version_
    }
}

// --- End of file: AirFuel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-leave-and-join ---
// --- Original File Path: A/AdminLeaveJoin/AdminLeaveJoin.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("AdminLeaveJoin", "austinv900", "0.1.10", ResourceId = 2032)]
    [Description("Custom Join and Leave Message when admins leave and join")]
    class AdminLeaveJoin : CovalencePlugin
    {
        #region Libraries
        Dictionary<IPlayer, string> ActiveStaffList = new Dictionary<IPlayer, string>();
        #endregion

        #region Oxide Hooks
        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(Name + "." + AdminPermission, this);
            permission.RegisterPermission(Name + "." + ModeratorPermission, this);
            UpdateList();
        }

        void OnServerSave()
        {
            UpdateList();
        }

        void OnUserConnected(IPlayer player)
        {
            if (IsAdmin(player) || IsModerator(player))
			{
				UpdateList();
				NextTick(() => JoinLeave(player, true));
			}
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (IsAdmin(player) || IsModerator(player)) { UpdateList(); JoinLeave(player); }
        }
        #endregion

        #region Configuration

        bool showAdminJoin;
        bool showAdminLeave;
        bool showModJoin;
        bool showModLeave;
        string ModeratorGroup;
        string AdminGroup;
        string AdminPermission;
        string ModeratorPermission;
        string msgPrefix;

        protected override void LoadDefaultConfig()
        {
            SetConfig("General", "Admin", "ShowJoin", true);
            SetConfig("General", "Admin", "ShowLeave", true);
            SetConfig("General", "Admin", "OxideGroup", "admin");
            SetConfig("General", "Admin", "Permission(adminleavejoin.?)", "admin");
            SetConfig("General", "Moderator", "ShowJoin", true);
            SetConfig("General", "Moderator", "ShowLeave", true);
            SetConfig("General", "Moderator", "OxideGroup", "moderator");
            SetConfig("General", "Moderator", "Permission(adminleavejoin.?)", "moderator");
            SetConfig("Settings", "Chat", "Prefix", "AdminJoin");
            SetConfig("Settings", "Chat", "Color", "#005682");
            SaveConfig();

            showAdminJoin = GetConfig(true, "General", "Admin", "ShowJoin");
            showAdminLeave = GetConfig(true, "General", "Admin", "ShowLeave");
            AdminGroup = GetConfig("admin", "General", "Admin", "OxideGroup");
            showModJoin = GetConfig(true, "General", "Moderator", "ShowJoin");
            showModLeave = GetConfig(true, "General", "Moderator", "ShowLeave");
            ModeratorGroup = GetConfig("moderator", "General", "Moderator", "OxideGroup");
            AdminPermission = GetConfig("admin", "General", "Admin", "Permission(adminleavejoin.?)");
            ModeratorPermission = GetConfig("moderator", "General", "Moderator", "Permission(adminleavejoin.?)");

            msgPrefix = GetConfig("AdminJoin", "Settings", "Chat", "Prefix");
        }
        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Online"] = "{0} {1} has come Online",
                ["Offline"] = "{0} {1} has just went Offline",
                ["Admin"] = "Admin",
                ["Moderator"] = "Moderator",
                ["NoActiveStaff"] = "No staff currently online",
                ["ChatFormat"] = "[{0}] : {1}",
                ["AdminListHeader"] = "Active Staff List:",
                ["AdminListValues"] = "{0} - {1}"
            }, this, "en");
        }

        #endregion

        #region ChatCommands
        [Command("staff")]
        void cmdAvailable(IPlayer player, string command, string[] args)
        {
            if (ActiveStaffList.Count == 0) { player.Reply(MessageFormat(Lang("NoActiveStaff", player.Id), player.Id)); return; };
            player.Reply(Lang("AdminListHeader", player.Id));
            foreach(var admin in ActiveStaffList.Keys)
            {
                player.Reply(Lang("AdminListValues", player.Id, admin.Name, ActiveStaffList[admin]));
            }
        }

        #endregion

        #region Plugin Hooks

        void UpdateList()
        {
            ActiveStaffList.Clear();
            foreach(var pl in players.Connected)
            {
                if (IsAdmin(pl) && !ActiveStaffList.ContainsKey(pl)) ActiveStaffList.Add(pl, Lang("Admin", pl.Id));
                if (IsModerator(pl) && !ActiveStaffList.ContainsKey(pl)) ActiveStaffList.Add(pl, Lang("Moderator", pl.Id));
            }
        }

        void JoinLeave(IPlayer player, bool Join = false)
        {
            string Rank = "Moderator";
            string join = "Offline";

            if (IsAdmin(player)) Rank = "Admin";
            if (Join) { join = "Online"; if (!ActiveStaffList.ContainsKey(player)) ActiveStaffList.Add(player, Lang(Rank, player.Id)); }

            MessageBroadcast(player.Name, Rank, join);

        }

        void MessageBroadcast(string name, string rank, string status)
        {
            if (rank == "Moderator" && status == "Offline" && !showModLeave) return;
            if (rank == "Moderator" && status == "Online" && !showModJoin) return;
            if (rank == "Admin" && status == "Offline" && !showAdminLeave) return;
            if (rank == "Admin" && status == "Online" && !showAdminJoin) return;
            foreach (var pl in players.Connected)
            {
                string message = MessageFormat(Lang(status, pl.Id, name, Lang(rank, null)), pl.Id);
                pl.Reply(message);
            }
        }
        #endregion

        #region Helpers
        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());
        void SetConfig(params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); stringArgs.RemoveAt(args.Length - 1); if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args); }
        T GetConfig<T>(T defaultVal, params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); if (Config.Get(stringArgs.ToArray()) == null) { PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin."); return defaultVal; } return (T)System.Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T)); }

        bool IsAdmin(IPlayer player) => permission.UserHasPermission(player.Id, Name + "." + AdminPermission) || permission.UserHasGroup(player.Id, AdminGroup) || player.IsAdmin;

        bool IsModerator(IPlayer player) => permission.UserHasPermission(player.Id, Name + "." + ModeratorPermission) || permission.UserHasGroup(player.Id, ModeratorGroup);

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        string MessageFormat(string msg, string id) => Lang("ChatFormat", id, msgPrefix, msg);
        #endregion
    }
}

// --- End of file: AdminLeaveJoin.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/automatic-authorization ---
// --- Original File Path: A/AutomaticAuthorization/AutomaticAuthorization.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Automatic Authorization", "k1lly0u/Arainrr", "1.3.3", ResourceId = 2063)]
    [Description("Shared cupboards, turrets, locks with teams, clans, friends")]
    public class AutomaticAuthorization : RustPlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin Clans, Friends, Bank;

        private const string PERMISSION_USE = "automaticauthorization.use";

        private readonly object _true = true;
        private readonly Dictionary<ulong, EntityCache> _playerEntities = new Dictionary<ulong, EntityCache>();

        private enum ShareType
        {
            None,
            Teams,
            Friends,
            Clans
        }

        [Flags]
        private enum AutoAuthType
        {
            Turret = 1 << 0,
            Cupboard = 1 << 1,
            CodeLock = 1 << 2,
            All = -1,
        }

        private class EntityCache
        {
            public readonly HashSet<AutoTurret> autoTurrets = new HashSet<AutoTurret>();
            public readonly HashSet<BuildingPrivlidge> buildingPrivlidges = new HashSet<BuildingPrivlidge>();
            public readonly HashSet<CodeLock> codeLocks = new HashSet<CodeLock>();
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            UpdateData();

            permission.RegisterPermission(PERMISSION_USE, this);

            cmd.AddChatCommand(configData.Chat.ChatCommand, this, nameof(CmdAutoAuth));
            cmd.AddChatCommand(configData.Chat.UICommand, this, nameof(CmdAutoAuthUI));

            Unsubscribe(nameof(OnEntitySpawned));
            if (!configData.TeamsShare.Enabled)
            {
                Unsubscribe(nameof(OnTeamLeave));
                Unsubscribe(nameof(OnTeamKick));
                Unsubscribe(nameof(OnTeamDisbanded));
                Unsubscribe(nameof(OnTeamAcceptInvite));
            }
            if (!configData.FriendsShare.Enabled)
            {
                Unsubscribe(nameof(OnFriendAdded));
                Unsubscribe(nameof(OnFriendRemoved));
            }
            if (!configData.ClansShare.Enabled)
            {
                Unsubscribe(nameof(OnClanUpdate));
                Unsubscribe(nameof(OnClanDestroy));
                Unsubscribe(nameof(OnClanMemberGone));
            }
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            foreach (var serverEntity in BaseNetworkable.serverEntities)
            {
                var autoTurret = serverEntity as AutoTurret;
                if (autoTurret != null)
                {
                    CheckEntitySpawned(autoTurret);
                    continue;
                }
                var buildingPrivlidge = serverEntity as BuildingPrivlidge;
                if (buildingPrivlidge != null)
                {
                    CheckEntitySpawned(buildingPrivlidge);
                }
                var codeLock = serverEntity as CodeLock;
                if (codeLock != null)
                {
                    CheckEntitySpawned(codeLock);
                }
            }
        }

        private void OnServerSave()
        {
            timer.Once(Random.Range(0f, 60f), SaveData);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
            SaveData();
        }

        private void OnEntitySpawned(AutoTurret autoTurret)
        {
            CheckEntitySpawned(autoTurret, true);
        }

        private void OnEntitySpawned(BuildingPrivlidge buildingPrivlidge)
        {
            CheckEntitySpawned(buildingPrivlidge, true);
        }

        private void OnEntitySpawned(CodeLock codeLock)
        {
            CheckEntitySpawned(codeLock, true);
        }

        private void OnEntityKill(AutoTurret autoTurret)
        {
            CheckEntityKill(autoTurret);
        }

        private void OnEntityKill(BuildingPrivlidge buildingPrivlidge)
        {
            CheckEntityKill(buildingPrivlidge);
        }

        private void OnEntityKill(CodeLock codeLock)
        {
            CheckEntityKill(codeLock);
        }

        private void CanChangeCode(BasePlayer player, CodeLock codeLock, string code, bool isGuest)
        {
            NextFrame(() =>
            {
                if (!isGuest ? codeLock.code != code : codeLock.guestCode != code)
                {
                    return;
                }
                var parentEntity = codeLock.GetParentEntity();
                var ownerId = codeLock.OwnerID.IsSteamId() ? codeLock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
                if (!ownerId.IsSteamId())
                {
                    return;
                }
                UpdateAuthList(ownerId, AutoAuthType.CodeLock);
            });
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || !baseLock.IsLocked())
            {
                return null;
            }
            var parentEntity = baseLock.GetParentEntity();
            var ownerId = baseLock.OwnerID.IsSteamId() ? baseLock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
            if (!ownerId.IsSteamId() || ownerId == player.userID)
            {
                return null;
            }
            if (!permission.UserHasPermission(ownerId.ToString(), PERMISSION_USE))
            {
                return null;
            }

            // Ignore the bank boxes
            if (IsBankBox(parentEntity))
            {
                return null;
            }

            var shareData = GetShareData(ownerId, true);
            if (CanSharingLock(baseLock, parentEntity, shareData, ShareType.Teams, ownerId, player.userID))
            {
                return _true;
            }
            if (CanSharingLock(baseLock, parentEntity, shareData, ShareType.Friends, ownerId, player.userID))
            {
                return _true;
            }
            if (CanSharingLock(baseLock, parentEntity, shareData, ShareType.Clans, ownerId, player.userID))
            {
                return _true;
            }
            return null;
        }

        #endregion Oxide Hooks

        #region Helpers

        private static bool CanShareLockedEntity(BaseEntity parentEntity, StoredData.LockShareEntry lockShareEntry)
        {
            if (!lockShareEntry.enabled)
            {
                return false;
            }
            return parentEntity is Door ? lockShareEntry.door :
                    parentEntity is BoxStorage ? lockShareEntry.box : lockShareEntry.other;
        }

        private static void SendUnlockedEffect(CodeLock codeLock)
        {
            if (codeLock.effectUnlocked.isValid)
            {
                Effect.server.Run(codeLock.effectUnlocked.resourcePath, codeLock.transform.position);
            }
        }

        private static void CheckShareData(StoredData.ShareEntry shareEntry, ConfigData.ShareSettings shareSettings)
        {
            if (!shareSettings.Enabled)
            {
                shareEntry.enabled = false;
            }
            if (!shareSettings.ShareCupboard)
            {
                shareEntry.cupboard = false;
            }
            if (!shareSettings.ShareTurret)
            {
                shareEntry.turret = false;
            }
            if (!shareSettings.KeyLock.Enabled)
            {
                shareEntry.keyLock.enabled = false;
            }
            if (!shareSettings.KeyLock.ShareDoor)
            {
                shareEntry.keyLock.door = false;
            }
            if (!shareSettings.KeyLock.ShareBox)
            {
                shareEntry.keyLock.box = false;
            }
            if (!shareSettings.KeyLock.ShareOtherEntity)
            {
                shareEntry.keyLock.other = false;
            }
            if (!shareSettings.CodeLock.Enabled)
            {
                shareEntry.codeLock.enabled = false;
            }
            if (!shareSettings.CodeLock.ShareDoor)
            {
                shareEntry.codeLock.door = false;
            }
            if (!shareSettings.CodeLock.ShareBox)
            {
                shareEntry.codeLock.box = false;
            }
            if (!shareSettings.CodeLock.ShareOtherEntity)
            {
                shareEntry.codeLock.other = false;
            }
        }

        #endregion Helpers

        #region Methods

        #region Entity Spawn / Kill

        private void CheckEntitySpawned(AutoTurret autoTurret, bool justCreated = false)
        {
            if (autoTurret == null || !autoTurret.OwnerID.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (!_playerEntities.TryGetValue(autoTurret.OwnerID, out entityCache))
            {
                entityCache = new EntityCache();
                _playerEntities.Add(autoTurret.OwnerID, entityCache);
            }
            entityCache.autoTurrets.Add(autoTurret);

            if (justCreated && permission.UserHasPermission(autoTurret.OwnerID.ToString(), PERMISSION_USE))
            {
                AuthToTurret(new HashSet<AutoTurret> { autoTurret }, autoTurret.OwnerID, true);
            }
        }

        private void CheckEntitySpawned(BuildingPrivlidge buildingPrivlidge, bool justCreated = false)
        {
            if (buildingPrivlidge == null || !buildingPrivlidge.OwnerID.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (!_playerEntities.TryGetValue(buildingPrivlidge.OwnerID, out entityCache))
            {
                entityCache = new EntityCache();
                _playerEntities.Add(buildingPrivlidge.OwnerID, entityCache);
            }
            entityCache.buildingPrivlidges.Add(buildingPrivlidge);

            if (justCreated && permission.UserHasPermission(buildingPrivlidge.OwnerID.ToString(), PERMISSION_USE))
            {
                AuthToCupboard(new HashSet<BuildingPrivlidge> { buildingPrivlidge }, buildingPrivlidge.OwnerID, true);
            }
        }

        private void CheckEntitySpawned(CodeLock codeLock, bool justCreated = false)
        {
            if (codeLock == null)
            {
                return;
            }
            var parentEntity = codeLock.GetParentEntity();
            if (parentEntity != null && IsBankBox(parentEntity))
            {
                return;
            }
            var ownerId = codeLock.OwnerID.IsSteamId() ? codeLock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
            if (!ownerId.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (!_playerEntities.TryGetValue(ownerId, out entityCache))
            {
                entityCache = new EntityCache();
                _playerEntities.Add(ownerId, entityCache);
            }
            entityCache.codeLocks.Add(codeLock);

            if (justCreated && permission.UserHasPermission(ownerId.ToString(), PERMISSION_USE))
            {
                AuthToCodeLock(new HashSet<CodeLock> { codeLock }, ownerId, true);
            }
        }

        private void CheckEntityKill(AutoTurret autoTurret)
        {
            if (autoTurret == null || !autoTurret.OwnerID.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (_playerEntities.TryGetValue(autoTurret.OwnerID, out entityCache))
            {
                entityCache.autoTurrets.Remove(autoTurret);
            }
        }

        private void CheckEntityKill(BuildingPrivlidge buildingPrivlidge)
        {
            if (buildingPrivlidge == null || !buildingPrivlidge.OwnerID.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (_playerEntities.TryGetValue(buildingPrivlidge.OwnerID, out entityCache))
            {
                entityCache.buildingPrivlidges.Remove(buildingPrivlidge);
            }
        }

        private void CheckEntityKill(CodeLock codeLock)
        {
            if (codeLock == null)
            {
                return;
            }
            var parentEntity = codeLock.GetParentEntity();
            var ownerId = codeLock.OwnerID.IsSteamId() ? codeLock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
            if (!ownerId.IsSteamId())
            {
                return;
            }
            EntityCache entityCache;
            if (_playerEntities.TryGetValue(ownerId, out entityCache))
            {
                entityCache.codeLocks.Remove(codeLock);
            }
        }

        #endregion Entity Spawn / Kill

        private void UpdateAuthList(ulong playerId, AutoAuthType autoAuthType)
        {
            if (!permission.UserHasPermission(playerId.ToString(), PERMISSION_USE))
            {
                return;
            }
            EntityCache entityCache;
            if (!_playerEntities.TryGetValue(playerId, out entityCache))
            {
                return;
            }
            if (autoAuthType.HasFlag(AutoAuthType.Turret))
            {
                AuthToTurret(entityCache.autoTurrets, playerId);
            }
            if (autoAuthType.HasFlag(AutoAuthType.Cupboard))
            {
                AuthToCupboard(entityCache.buildingPrivlidges, playerId);
            }
            if (autoAuthType.HasFlag(AutoAuthType.CodeLock))
            {
                AuthToCodeLock(entityCache.codeLocks, playerId);
            }
        }

        private void AuthToTurret(HashSet<AutoTurret> autoTurrets, ulong playerId, bool justCreated = false)
        {
            if (autoTurrets.Count <= 0)
            {
                return;
            }
            var authList = GetAuthorNameIDs(playerId, AutoAuthType.Turret);
            foreach (var autoTurret in autoTurrets)
            {
                if (autoTurret == null || autoTurret.IsDestroyed)
                {
                    continue;
                }
                var isOnline = autoTurret.IsOnline();
                if (isOnline)
                {
                    autoTurret.SetIsOnline(false);
                }

                autoTurret.authorizedPlayers.Clear();
                foreach (var friend in authList)
                {
                    autoTurret.authorizedPlayers.Add(friend);
                }

                if (isOnline)
                {
                    autoTurret.SetIsOnline(true);
                }
                autoTurret.SendNetworkUpdate();
            }
            if (justCreated && configData.Chat.SendMessage && authList.Count > 1)
            {
                var player = BasePlayer.FindByID(playerId);
                if (player != null)
                {
                    Print(player, Lang("TurretSuccess", player.UserIDString, authList.Count - 1, autoTurrets.Count));
                }
            }
        }

        private void AuthToCupboard(HashSet<BuildingPrivlidge> buildingPrivlidges, ulong playerId, bool justCreated = false)
        {
            if (buildingPrivlidges.Count <= 0)
            {
                return;
            }
            var authList = GetAuthorNameIDs(playerId, AutoAuthType.Cupboard);
            foreach (var buildingPrivlidge in buildingPrivlidges)
            {
                if (buildingPrivlidge == null || buildingPrivlidge.IsDestroyed)
                {
                    continue;
                }
                buildingPrivlidge.authorizedPlayers.Clear();
                foreach (var friend in authList)
                {
                    buildingPrivlidge.authorizedPlayers.Add(friend);
                }
                buildingPrivlidge.SendNetworkUpdate();
            }
            if (justCreated && configData.Chat.SendMessage && authList.Count > 1)
            {
                var player = BasePlayer.FindByID(playerId);
                if (player != null)
                {
                    Print(player, Lang("CupboardSuccess", player.UserIDString, authList.Count - 1, buildingPrivlidges.Count));
                }
            }
        }

        private void AuthToCodeLock(HashSet<CodeLock> codeLocks, ulong playerId, bool justCreated = false)
        {
            if (codeLocks.Count <= 0)
            {
                return;
            }
            foreach (var codeLock in codeLocks)
            {
                if (codeLock == null || codeLock.IsDestroyed)
                {
                    continue;
                }
                codeLock.whitelistPlayers.Clear(); // only owner id
                codeLock.whitelistPlayers.Add(playerId);
                
                codeLock.guestPlayers.Clear(); // excluding owner id
                var authList = GetAuthorIDsForCodeLock(playerId, codeLock);
                foreach (var friend in authList)
                {
                    codeLock.guestPlayers.Add(friend);
                }
                codeLock.SendNetworkUpdate();
            }
        }

        private List<PlayerNameID> GetAuthorNameIDs(ulong playerId, AutoAuthType autoAuthType)
        {
            if (autoAuthType == AutoAuthType.CodeLock)
            {
                PrintError("Cannot be used for code locks");
                return new List<PlayerNameID>();
            }
            var authList = GetAuthIds(playerId, autoAuthType);
            return authList.Select(userid => new PlayerNameID { userid = userid, username = RustCore.FindPlayerById(userid)?.displayName ?? string.Empty }).ToList();
        }

        private HashSet<ulong> GetAuthorIDsForCodeLock(ulong playerId, CodeLock codeLock)
        {
            var sharePlayers = new HashSet<ulong>();
            var parentEntity = codeLock.GetParentEntity();
            if (parentEntity == null)
            {
                return sharePlayers;
            }
            var shareData = GetShareData(playerId, true);

            var teamsShare = shareData.GetShareEntry(ShareType.Teams);
            if (teamsShare.enabled && CanShareLockedEntity(parentEntity, teamsShare.codeLock))
            {
                var teamMembers = GetTeamMembers(playerId);
                if (teamMembers != null)
                {
                    foreach (var member in teamMembers)
                    {
                        sharePlayers.Add(member);
                    }
                }
            }
            var friendsShare = shareData.GetShareEntry(ShareType.Friends);
            if (friendsShare.enabled && CanShareLockedEntity(parentEntity, friendsShare.codeLock))
            {
                var friends = GetFriends(playerId);
                if (friends != null)
                {
                    foreach (var friend in friends)
                    {
                        sharePlayers.Add(friend);
                    }
                }
            }
            var clansShare = shareData.GetShareEntry(ShareType.Clans);
            if (clansShare.enabled && CanShareLockedEntity(parentEntity, clansShare.codeLock))
            {
                var clanMembers = GetClanMembers(playerId);
                if (clanMembers != null)
                {
                    foreach (var member in clanMembers)
                    {
                        sharePlayers.Add(member);
                    }
                }
            }
            return sharePlayers;
        }

        private HashSet<ulong> GetAuthIds(ulong playerId, AutoAuthType autoAuthType)
        {
            var sharePlayers = new HashSet<ulong> { playerId };
            var shareData = GetShareData(playerId, true);

            var teamsShare = shareData.GetShareEntry(ShareType.Teams);
            if (teamsShare.enabled && (autoAuthType == AutoAuthType.Turret ? teamsShare.turret : teamsShare.cupboard))
            {
                var teamMembers = GetTeamMembers(playerId);
                if (teamMembers != null)
                {
                    foreach (var member in teamMembers)
                    {
                        sharePlayers.Add(member);
                    }
                }
            }
            var friendsShare = shareData.GetShareEntry(ShareType.Friends);
            if (friendsShare.enabled && (autoAuthType == AutoAuthType.Turret ? friendsShare.turret : friendsShare.cupboard))
            {
                var friends = GetFriends(playerId);
                if (friends != null)
                {
                    foreach (var friend in friends)
                    {
                        sharePlayers.Add(friend);
                    }
                }
            }
            var clansShare = shareData.GetShareEntry(ShareType.Clans);
            if (clansShare.enabled && (autoAuthType == AutoAuthType.Turret ? clansShare.turret : clansShare.cupboard))
            {
                var clanMembers = GetClanMembers(playerId);
                if (clanMembers != null)
                {
                    foreach (var member in clanMembers)
                    {
                        sharePlayers.Add(member);
                    }
                }
            }
            return sharePlayers;
        }

        private bool CanSharingLock(BaseLock baseLock, BaseEntity parentEntity, StoredData.ShareData shareData, ShareType shareType, ulong ownerId, ulong playerId)
        {
            var shareEntry = shareData.GetShareEntry(shareType);
            if (shareEntry.enabled && AreFriends(shareType, ownerId, playerId))
            {
                if (baseLock is KeyLock)
                {
                    return CanShareLockedEntity(parentEntity, shareEntry.keyLock);
                }
                var codeLock = baseLock as CodeLock;
                if (codeLock != null && CanShareLockedEntity(parentEntity, shareEntry.codeLock))
                {
                    SendUnlockedEffect(codeLock);
                    return true;
                }
            }
            return false;
        }

        private IEnumerable<ShareType> GetAvailableTypes()
        {
            if (IsShareTypeEnabled(ShareType.Teams))
            {
                yield return ShareType.Teams;
            }
            if (IsShareTypeEnabled(ShareType.Friends))
            {
                yield return ShareType.Friends;
            }
            if (IsShareTypeEnabled(ShareType.Clans))
            {
                yield return ShareType.Clans;
            }
        }

        private bool IsShareTypeEnabled(ShareType shareType)
        {
            var shareSettings = configData.GetShareSettings(shareType);
            if (!shareSettings.Enabled)
            {
                return false;
            }
            switch (shareType)
            {
                case ShareType.Teams:
                    return RelationshipManager.TeamsEnabled();
                case ShareType.Friends:
                    return Friends != null;
                case ShareType.Clans:
                    return Clans != null;
            }
            return false;
        }

        private bool AreFriends(ShareType shareType, ulong ownerId, ulong playerId)
        {
            switch (shareType)
            {
                case ShareType.Teams:
                    return SameTeam(ownerId, playerId);
                case ShareType.Friends:
                    return HasFriend(ownerId, playerId);
                case ShareType.Clans:
                    return SameClan(ownerId, playerId);
            }
            return false;
        }

        #region Data

        private StoredData.ShareData _defaultData;

        private StoredData.ShareData DefaultData => _defaultData ?? (_defaultData = CreateDefaultData());

        private StoredData.ShareData GetShareData(ulong playerId, bool readOnly = false)
        {
            StoredData.ShareData shareData;
            if (!storedData.playerShareData.TryGetValue(playerId, out shareData))
            {
                if (readOnly)
                {
                    return DefaultData;
                }

                shareData = CreateDefaultData();
                storedData.playerShareData.Add(playerId, shareData);
            }
            return shareData;
        }

        private StoredData.ShareData CreateDefaultData()
        {
            return new StoredData.ShareData
            {
                teamsShare = CreateShareEntry(ShareType.Teams),
                friendsShare = CreateShareEntry(ShareType.Friends),
                clansShare = CreateShareEntry(ShareType.Clans)
            };
        }

        private void UpdateData()
        {
            foreach (var shareData in storedData.playerShareData.Values)
            {
                CheckShareData(shareData, ShareType.Teams);
                CheckShareData(shareData, ShareType.Friends);
                CheckShareData(shareData, ShareType.Clans);
            }
            SaveData();
        }

        private StoredData.ShareEntry CreateShareEntry(ShareType shareType)
        {
            var defaultSettings = configData.GetDefaultShareSettings(shareType);
            var shareEntry = new StoredData.ShareEntry
            {
                enabled = defaultSettings.Enabled,
                turret = defaultSettings.ShareTurret,
                cupboard = defaultSettings.ShareCupboard,
                keyLock = new StoredData.LockShareEntry
                {
                    enabled = defaultSettings.KeyLock.Enabled,
                    door = defaultSettings.KeyLock.ShareDoor,
                    box = defaultSettings.KeyLock.ShareBox,
                    other = defaultSettings.KeyLock.ShareOtherEntity
                },
                codeLock = new StoredData.LockShareEntry
                {
                    enabled = defaultSettings.CodeLock.Enabled,
                    door = defaultSettings.CodeLock.ShareDoor,
                    box = defaultSettings.CodeLock.ShareBox,
                    other = defaultSettings.CodeLock.ShareOtherEntity
                }
            };
            CheckShareData(shareEntry, configData.GetShareSettings(shareType));
            return shareEntry;
        }

        private void CheckShareData(StoredData.ShareData shareData, ShareType shareType)
        {
            var shareSettings = configData.GetShareSettings(shareType);
            var shareEntry = shareData.GetShareEntry(shareType);
            CheckShareData(shareEntry, shareSettings);
        }

        #endregion Data

        #region Conflict Resolution

        private bool IsBankBox(BaseNetworkable entity)
        {
            return Bank != null && Bank.Call<bool>("IsBankBox", entity);
        }

        #endregion Conflict Resolution

        #endregion Methods

        #region External Plugins

        #region Teams

        #region Hooks

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            NextTick(() =>
            {
                if (playerTeam == null || player == null)
                {
                    return;
                }
                if (playerTeam.members.Contains(player.userID))
                {
                    UpdateTeamAuthList(playerTeam.members);
                }
            });
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            NextTick(() =>
            {
                if (playerTeam == null || player == null)
                {
                    return;
                }
                if (!playerTeam.members.Contains(player.userID))
                {
                    var teamMembers = new List<ulong>(playerTeam.members) { player.userID };
                    UpdateTeamAuthList(teamMembers);
                }
            });
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer leader, ulong target)
        {
            NextTick(() =>
            {
                if (playerTeam == null)
                {
                    return;
                }
                if (!playerTeam.members.Contains(target))
                {
                    var teamMembers = new List<ulong>(playerTeam.members) { target };
                    UpdateTeamAuthList(teamMembers);
                }
            });
        }

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam playerTeam)
        {
            if (playerTeam == null)
            {
                return;
            }
            UpdateTeamAuthList(playerTeam.members);
        }

        #endregion Hooks

        private void UpdateTeamAuthList(List<ulong> teamMembers)
        {
            if (teamMembers.Count <= 0)
            {
                return;
            }
            foreach (var member in teamMembers)
            {
                UpdateAuthList(member, AutoAuthType.All);
            }
        }

        private static IEnumerable<ulong> GetTeamMembers(ulong playerId)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return null;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            return playerTeam?.members;
        }

        private static bool SameTeam(ulong playerId, ulong friendId)
        {
            if (!RelationshipManager.TeamsEnabled())
            {
                return false;
            }
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerId);
            if (playerTeam == null)
            {
                return false;
            }
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendId);
            if (friendTeam == null)
            {
                return false;
            }
            return playerTeam == friendTeam;
        }

        #endregion Teams

        #region Friends

        #region Hooks

        private void OnFriendAdded(string playerId, string friendId)
        {
            UpdateFriendAuthList(playerId, friendId);
        }

        private void OnFriendRemoved(string playerId, string friendId)
        {
            UpdateFriendAuthList(playerId, friendId);
        }

        #endregion Hooks

        private void UpdateFriendAuthList(string playerId, string friendId)
        {
            UpdateAuthList(Convert.ToUInt64(playerId), AutoAuthType.All);
            UpdateAuthList(Convert.ToUInt64(friendId), AutoAuthType.All);
        }

        private IEnumerable<ulong> GetFriends(ulong playerId)
        {
            if (Friends == null)
            {
                return null;
            }
            var friends = Friends.Call("GetFriends", playerId) as ulong[];
            return friends;
        }

        private bool HasFriend(ulong playerId, ulong friendId)
        {
            if (Friends == null)
            {
                return false;
            }
            var hasFriend = Friends.Call("HasFriend", playerId, friendId);
            return hasFriend is bool && (bool)hasFriend;
        }

        #endregion Friends

        #region Clans

        #region Hooks

        private void OnClanDestroy(string clanName)
        {
            UpdateClanAuthList(clanName);
        }

        private void OnClanUpdate(string clanName)
        {
            UpdateClanAuthList(clanName);
        }

        #region Clans Reborn Hooks

        private void OnClanMemberGone(string playerId, List<string> memberUserIDs)
        {
            UpdateAuthList(Convert.ToUInt64(playerId), AutoAuthType.All);
        }

        #endregion Clans Reborn Hooks

        #endregion Hooks

        private void UpdateClanAuthList(string clanName)
        {
            var clanMembers = GetClanMembers(clanName);
            if (clanMembers != null)
            {
                foreach (var member in clanMembers)
                {
                    UpdateAuthList(member, AutoAuthType.All);
                }
            }
        }

        private IEnumerable<ulong> GetClanMembers(ulong playerId)
        {
            if (Clans == null)
            {
                return null;
            }
            //Clans Reborn
            var members = Clans.Call("GetClanMembers", playerId) as List<string>;
            if (members != null)
            {
                return members.Select(x => Convert.ToUInt64(x));
            }
            //Clans
            var clanName = Clans.Call("GetClanOf", playerId) as string;
            return clanName != null ? GetClanMembers(clanName) : null;
        }

        private IEnumerable<ulong> GetClanMembers(string clanName)
        {
            if (Clans == null)
            {
                return null;
            }
            var clan = Clans.Call("GetClan", clanName) as JObject;
            var members = clan?.GetValue("members") as JArray;
            return members?.Select(Convert.ToUInt64);
        }

        private bool SameClan(ulong playerId, ulong friendId)
        {
            if (Clans == null)
            {
                return false;
            }
            //Clans and Clans Reborn
            var isMember = Clans.Call("IsClanMember", playerId.ToString(), friendId.ToString());
            if (isMember != null)
            {
                return (bool)isMember;
            }
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerId);
            if (playerClan == null)
            {
                return false;
            }
            var friendClan = Clans.Call("GetClanOf", friendId);
            if (friendClan == null)
            {
                return false;
            }
            return (string)playerClan == (string)friendClan;
        }

        #endregion Clans

        #endregion External Plugins

        #region UI

        private const string UINAME_MAIN = "AutoAuthUI_Main";
        private const string UINAME_MENU = "AutoAuthUI_Menu";

        private void CreateMainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.6" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-390 -200", OffsetMax = "390 260" },
                CursorEnabled = true
            }, "Hud", UINAME_MAIN);
            var titlePanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.31 0.88 0.71 1" },
                RectTransform = { AnchorMin = "0 0.912", AnchorMax = "0.998 1" }
            }, UINAME_MAIN);
            container.Add(new CuiElement
            {
                Parent = titlePanel,
                Components =
                {
                    new CuiTextComponent { Text = Lang("UI_Title", player.UserIDString), FontSize = 24, Align = TextAnchor.MiddleCenter, Color = "1 0 0 1" },
                    new CuiOutlineComponent { Distance = "0.5 0.5", Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0", AnchorMax = "0.8 1" }
                }
            });
            container.Add(new CuiButton
            {
                Button = { Color = "0.95 0.1 0.1 0.95", Close = UINAME_MAIN },
                Text = { Text = "X", Align = TextAnchor.MiddleCenter, Color = "0 0 0 1", FontSize = 22 },
                RectTransform = { AnchorMin = "0.915 0", AnchorMax = "1 0.99" }
            }, titlePanel);
            container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.4" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.908" }
            }, UINAME_MAIN, UINAME_MENU);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
            CuiHelper.AddUi(player, container);
            var shareData = GetShareData(player.userID, true);
            UpdateMenuUI(player, shareData);
        }

        private void UpdateMenuUI(BasePlayer player, StoredData.ShareData shareData, ShareType shareType = ShareType.None)
        {
            if (player == null)
            {
                return;
            }
            var availableTypes = GetAvailableTypes();
            var total = availableTypes.Count();
            if (total <= 0)
            {
                return;
            }

            var i = 0;
            var container = new CuiElementContainer();

            #region Teams UI

            if (availableTypes.Contains(ShareType.Teams))
            {
                if (shareType == ShareType.None || shareType == ShareType.Teams)
                {
                    var anchors = GetMenuSubAnchors(i, total);
                    CuiHelper.DestroyUi(player, UINAME_MENU + ShareType.Teams);
                    CreateMenuSubUI(ref container, shareData, player.UserIDString, ShareType.Teams, $"{anchors[0]} 0.03", $"{anchors[1]} 0.97");
                }
                i++;
            }

            #endregion Teams UI

            #region Friends UI

            if (availableTypes.Contains(ShareType.Friends))
            {
                if (shareType == ShareType.None || shareType == ShareType.Friends)
                {
                    var anchors = GetMenuSubAnchors(i, total);
                    CuiHelper.DestroyUi(player, UINAME_MENU + ShareType.Friends);
                    CreateMenuSubUI(ref container, shareData, player.UserIDString, ShareType.Friends, $"{anchors[0]} 0.03", $"{anchors[1]} 0.97");
                }
                i++;
            }

            #endregion Friends UI

            #region Clans UI

            if (availableTypes.Contains(ShareType.Clans))
            {
                if (shareType == ShareType.None || shareType == ShareType.Clans)
                {
                    var anchors = GetMenuSubAnchors(i, total);
                    CuiHelper.DestroyUi(player, UINAME_MENU + ShareType.Clans);
                    CreateMenuSubUI(ref container, shareData, player.UserIDString, ShareType.Clans, $"{anchors[0]} 0.03", $"{anchors[1]} 0.97");
                }
            }

            #endregion Clans UI

            CuiHelper.AddUi(player, container);
        }

        private void CreateMenuSubUI(ref CuiElementContainer container, StoredData.ShareData shareData, string playerId, ShareType shareType, string anchorMin, string anchorMax)
        {
            var panelName = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.5" },
                RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
            }, UINAME_MENU, UINAME_MENU + shareType);
            var titlePanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.5" },
                RectTransform = { AnchorMin = "0 0.9", AnchorMax = "1 1" }
            }, panelName);
            container.Add(new CuiLabel
            {
                Text = { Color = "1 0.5 0 1", FontSize = 18, Align = TextAnchor.MiddleCenter, Text = Lang("UI_SubTitle", playerId, Lang("UI_" + shareType, playerId)) },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, titlePanel);

            var contentPanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.55" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.895" }
            }, panelName);

            var i = 0;
            const float entrySize = 0.08f;
            const float spacingY = 0.012f;

            var shareEntry = shareData.GetShareEntry(shareType);
            var commandPrefix = $"AutoAuthUI {shareType} ";
            var enabledMsg = Lang("Enabled", playerId);
            var disabledMsg = Lang("Disabled", playerId);

            var anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix, Lang("UI_SubShare", playerId, Lang("UI_" + shareType, playerId)),
                             shareEntry.enabled ? enabledMsg : disabledMsg, $"0 {anchors[0]}",
                             $"0.995 {anchors[1]}");

            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "Cupboard", Lang("UI_SubCupboard", playerId),
                             shareEntry.cupboard ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");

            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "Turret", Lang("UI_SubTurret", playerId),
                             shareEntry.turret ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");

            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "KeyLock", Lang("UI_SubKeyLock", playerId),
                             shareEntry.keyLock.enabled ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");

            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "KeyLock Door", Lang("UI_SubKeyLockDoor", playerId),
                             shareEntry.keyLock.door ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "KeyLock Box", Lang("UI_SubKeyLockBox", playerId),
                             shareEntry.keyLock.box ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "KeyLock Other", Lang("UI_SubKeyLockOther", playerId),
                             shareEntry.keyLock.other ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");

            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "CodeLock", Lang("UI_SubCodeLock", playerId),
                             shareEntry.codeLock.enabled ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "CodeLock Door", Lang("UI_SubCodeLockDoor", playerId),
                             shareEntry.codeLock.door ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "CodeLock Box", Lang("UI_SubCodeLockBox", playerId),
                             shareEntry.codeLock.box ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntrySubUI(ref container, contentPanel, commandPrefix + "CodeLock Other", Lang("UI_SubCodeLockOther", playerId),
                             shareEntry.codeLock.other ? enabledMsg : disabledMsg, $"0 {anchors[0]}", $"0.995 {anchors[1]}");
        }

        private static void CreateEntrySubUI(ref CuiElementContainer container, string parentName, string command, string leftText, string rightText, string anchorMin, string anchorMax)
        {
            var panelName = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.6" },
                RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
            }, parentName);
            container.Add(new CuiLabel
            {
                Text = { Color = "0 1 1 1", FontSize = 12, Align = TextAnchor.MiddleLeft, Text = leftText },
                RectTransform = { AnchorMin = "0.04 0", AnchorMax = "0.68 1" }
            }, panelName);
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.7", Command = command },
                Text = { Text = rightText, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 12 },
                RectTransform = { AnchorMin = "0.7 0.2", AnchorMax = "0.985 0.8" }
            }, panelName);
        }

        private static float[] GetEntryAnchors(int i, float entrySize, float spacingY)
        {
            return new[] { 1f - (i + 1) * entrySize - i * spacingY, 1f - i * (entrySize + spacingY) };
        }

        private static float[] GetMenuSubAnchors(int i, int total)
        {
            switch (total)
            {
                case 1:
                    return new[] { 0.32f, 0.68f };
                case 2:
                    return i == 0 ? new[] { 0.15f, 0.48f } : new[] { 0.52f, 0.85f };
                case 3:
                    switch (i)
                    {
                        case 0:
                            return new[] { 0.01f, 0.33f };
                        case 1:
                            return new[] { 0.34f, 0.66f };
                        default:
                            return new[] { 0.67f, 0.99f };
                    }

                default:
                    return null;
            }
        }

        private static void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UINAME_MAIN);
        }

        #endregion UI

        #region Chat Commands

        private void CmdAutoAuth(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            var shareData = GetShareData(player.userID);
            if (args == null || args.Length == 0)
            {
                var availableTypes = GetAvailableTypes();
                if (!availableTypes.Any())
                {
                    Print(player, Lang("UnableAutoAuth", player.UserIDString));
                    return;
                }
                var stringBuilder = new StringBuilder();
                stringBuilder.AppendLine();

                HandleStatusCommand(stringBuilder, player, shareData, availableTypes);

                Print(player, stringBuilder.ToString());
                return;
            }
            switch (args[0].ToLower())
            {
                case "ui":
                    CreateMainUI(player);
                    return;

                case "t":
                case "at":
                case "team":
                case "autoteam":
                    HandleShareCommand(player, shareData, ShareType.Teams, args);
                    return;

                case "f":
                case "af":
                case "friend":
                case "autofriend":
                    HandleShareCommand(player, shareData, ShareType.Friends, args);
                    return;

                case "c":
                case "ac":
                case "clan":
                case "autoclan":
                    HandleShareCommand(player, shareData, ShareType.Clans, args);
                    return;

                case "h":
                case "help":
                    var availableTypes = GetAvailableTypes();
                    if (!availableTypes.Any())
                    {
                        Print(player, Lang("UnableAutoAuth", player.UserIDString));
                        return;
                    }
                    var stringBuilder = new StringBuilder();
                    stringBuilder.AppendLine();

                    HandleHelpCommand(stringBuilder, player, availableTypes);

                    stringBuilder.AppendLine(Lang("UISyntax", player.UserIDString, configData.Chat.UICommand, configData.Chat.ChatCommand));
                    Print(player, stringBuilder.ToString());
                    return;

                default:
                    Print(player, Lang("SyntaxError", player.UserIDString, configData.Chat.ChatCommand));
                    return;
            }
        }

        private void HandleStatusCommand(StringBuilder stringBuilder, BasePlayer player, StoredData.ShareData shareData, IEnumerable<ShareType> availableTypes)
        {
            var enabledMsg = Lang("Enabled", player.UserIDString);
            var disabledMsg = Lang("Disabled", player.UserIDString);
            foreach (var shareType in availableTypes)
            {
                var shareEntry = shareData.GetShareEntry(shareType);
                var shareTypeName = Lang(shareType.ToString(), player.UserIDString);

                stringBuilder.AppendLine(Lang("ShareStatus", player.UserIDString, shareTypeName));
                stringBuilder.AppendLine(Lang("Share", player.UserIDString, shareTypeName, shareEntry.enabled ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareCupboard", player.UserIDString, shareTypeName, shareEntry.cupboard ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareTurret", player.UserIDString, shareTypeName, shareEntry.turret ? enabledMsg : disabledMsg));

                stringBuilder.AppendLine(Lang("ShareKeyLock", player.UserIDString, shareTypeName, shareEntry.keyLock.enabled ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareKeyLockDoor", player.UserIDString, shareTypeName, shareEntry.keyLock.door ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareKeyLockBox", player.UserIDString, shareTypeName, shareEntry.keyLock.box ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareKeyLockOther", player.UserIDString, shareTypeName, shareEntry.keyLock.other ? enabledMsg : disabledMsg));

                stringBuilder.AppendLine(Lang("ShareCodeLock", player.UserIDString, shareTypeName, shareEntry.codeLock.enabled ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareCodeLockDoor", player.UserIDString, shareTypeName, shareEntry.codeLock.door ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareCodeLockBox", player.UserIDString, shareTypeName, shareEntry.codeLock.box ? enabledMsg : disabledMsg));
                stringBuilder.AppendLine(Lang("ShareCodeLockOther", player.UserIDString, shareTypeName, shareEntry.codeLock.other ? enabledMsg : disabledMsg));
            }
        }

        private void HandleHelpCommand(StringBuilder stringBuilder, BasePlayer player, IEnumerable<ShareType> availableTypes)
        {
            foreach (var shareType in availableTypes)
            {
                HandleHelpCommand(stringBuilder, player, shareType);
            }
        }

        private void HandleHelpCommand(StringBuilder stringBuilder, BasePlayer player, ShareType shareType)
        {
            var syntaxName = Lang(shareType + "CmdSyntax", player.UserIDString);
            var membersName = Lang(shareType + "Members", player.UserIDString);
            stringBuilder.AppendLine(Lang("Syntax", player.UserIDString, configData.Chat.ChatCommand, syntaxName, membersName));
            stringBuilder.AppendLine(Lang("Syntax1", player.UserIDString, configData.Chat.ChatCommand, syntaxName, membersName));
            stringBuilder.AppendLine(Lang("Syntax2", player.UserIDString, configData.Chat.ChatCommand, syntaxName, membersName));
            stringBuilder.AppendLine(Lang("Syntax3", player.UserIDString, configData.Chat.ChatCommand, syntaxName, membersName));
            stringBuilder.AppendLine(Lang("Syntax4", player.UserIDString, configData.Chat.ChatCommand, syntaxName, membersName));
        }

        private bool HandleShareCommand(BasePlayer player, StoredData.ShareData shareData, ShareType shareType, string[] args, bool sendMsg = true)
        {
            if (!IsShareTypeEnabled(shareType))
            {
                if (sendMsg)
                {
                    Print(player, Lang("AllDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                }
                return false;
            }

            var shareEntry = shareData.GetShareEntry(shareType);
            if (args.Length <= 1)
            {
                shareEntry.enabled = !shareEntry.enabled;
                if (sendMsg)
                {
                    Print(player, Lang("All", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                }
                UpdateAuthList(player.userID, AutoAuthType.All);
                return true;
            }

            var shareSettings = configData.GetShareSettings(shareType);
            switch (args[1].ToLower())
            {
                case "c":
                case "cupboard":
                    if (!shareSettings.ShareCupboard)
                    {
                        if (sendMsg)
                        {
                            Print(player, Lang("CupboardDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                        }
                        return false;
                    }
                    shareEntry.cupboard = !shareEntry.cupboard;
                    if (sendMsg)
                    {
                        Print(player, Lang("Cupboard", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.cupboard ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                    }
                    UpdateAuthList(player.userID, AutoAuthType.Cupboard);
                    return true;

                case "t":
                case "turret":
                    if (!shareSettings.ShareTurret)
                    {
                        if (sendMsg)
                        {
                            Print(player, Lang("TurretDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                        }
                        return false;
                    }
                    shareEntry.turret = !shareEntry.turret;
                    if (sendMsg)
                    {
                        Print(player, Lang("Turret", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.turret ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                    }
                    UpdateAuthList(player.userID, AutoAuthType.Turret);
                    return true;

                case "kl":
                case "keylock":
                    if (!shareSettings.KeyLock.Enabled)
                    {
                        if (sendMsg)
                        {
                            Print(player, Lang("KeyLockDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                        }
                        return false;
                    }
                    if (args.Length <= 2)
                    {
                        shareEntry.keyLock.enabled = !shareEntry.keyLock.enabled;
                        if (sendMsg)
                        {
                            Print(player, Lang("KeyLock", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.keyLock.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                        }
                        return true;
                    }
                    switch (args[2].ToLower())
                    {
                        case "d":
                        case "door":
                            if (!shareSettings.KeyLock.ShareDoor)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("KeyLockDoorDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.keyLock.door = !shareEntry.keyLock.door;
                            if (sendMsg)
                            {
                                Print(player, Lang("KeyLockDoor", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.keyLock.door ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            return true;

                        case "b":
                        case "box":
                            if (!shareSettings.KeyLock.ShareBox)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("KeyLockBoxDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.keyLock.box = !shareEntry.keyLock.box;
                            if (sendMsg)
                            {
                                Print(player, Lang("KeyLockBox", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.keyLock.box ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            return true;

                        case "o":
                        case "other":
                            if (!shareSettings.KeyLock.ShareOtherEntity)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("KeyLockOtherDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.keyLock.other = !shareEntry.keyLock.other;
                            if (sendMsg)
                            {
                                Print(player, Lang("KeyLockOther", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.keyLock.other ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            return true;
                    }
                    break;

                case "cl":
                case "codelock":
                    if (!shareSettings.CodeLock.Enabled)
                    {
                        if (sendMsg)
                        {
                            Print(player, Lang("CodeLockDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                        }
                        return false;
                    }
                    if (args.Length <= 2)
                    {
                        shareEntry.codeLock.enabled = !shareEntry.codeLock.enabled;
                        if (sendMsg)
                        {
                            Print(player, Lang("CodeLock", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.codeLock.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                        }
                        UpdateAuthList(player.userID, AutoAuthType.CodeLock);
                        return true;
                    }
                    switch (args[2].ToLower())
                    {
                        case "d":
                        case "door":
                            if (!shareSettings.CodeLock.ShareDoor)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("CodeLockDoorDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.codeLock.door = !shareEntry.codeLock.door;
                            if (sendMsg)
                            {
                                Print(player, Lang("CodeLockDoor", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.codeLock.door ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            UpdateAuthList(player.userID, AutoAuthType.CodeLock);
                            return true;

                        case "b":
                        case "box":
                            if (!shareSettings.CodeLock.ShareBox)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("CodeLockBoxDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.codeLock.box = !shareEntry.codeLock.box;
                            if (sendMsg)
                            {
                                Print(player, Lang("CodeLockBox", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.codeLock.box ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            UpdateAuthList(player.userID, AutoAuthType.CodeLock);
                            return true;

                        case "o":
                        case "other":
                            if (!shareSettings.CodeLock.ShareOtherEntity)
                            {
                                if (sendMsg)
                                {
                                    Print(player, Lang("CodeLockOtherDisabled", player.UserIDString, Lang(shareType.ToString(), player.UserIDString)));
                                }
                                return false;
                            }
                            shareEntry.codeLock.other = !shareEntry.codeLock.other;
                            if (sendMsg)
                            {
                                Print(player, Lang("CodeLockOther", player.UserIDString, Lang(shareType.ToString(), player.UserIDString), shareEntry.codeLock.other ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                            }
                            UpdateAuthList(player.userID, AutoAuthType.CodeLock);
                            return true;
                    }
                    break;

                case "h":
                case "help":
                    if (sendMsg)
                    {
                        var stringBuilder = new StringBuilder();
                        stringBuilder.AppendLine();

                        HandleHelpCommand(stringBuilder, player, shareType);

                        Print(player, stringBuilder.ToString());
                    }
                    return true;
            }
            if (sendMsg)
            {
                Print(player, Lang("SyntaxError", player.UserIDString, configData.Chat.ChatCommand));
            }
            return false;
        }

        private void CmdAutoAuthUI(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            CreateMainUI(player);
        }

        [ConsoleCommand("AutoAuthUI")]
        private void CCmdAutoAuthUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null)
            {
                return;
            }
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                return;
            }
            var shareData = GetShareData(player.userID);
            switch (arg.Args[0].ToLower())
            {
                case "teams":
                    HandleShareUICommand(player, shareData, ShareType.Teams, arg.Args);
                    return;

                case "friends":
                    HandleShareUICommand(player, shareData, ShareType.Friends, arg.Args);
                    return;

                case "clans":
                    HandleShareUICommand(player, shareData, ShareType.Clans, arg.Args);
                    return;
            }
        }

        private void HandleShareUICommand(BasePlayer player, StoredData.ShareData shareData, ShareType shareType, string[] args)
        {
            if (HandleShareCommand(player, shareData, shareType, args, false))
            {
                UpdateMenuUI(player, shareData, shareType);
            }
        }

        #endregion Chat Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Clear Share Data On Map Wipe")]
            public bool ClearDataOnWipe { get; set; } = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings Chat { get; set; } = new ChatSettings();

            [JsonProperty(PropertyName = "Teams Share Settings")]
            public ShareSettings TeamsShare { get; set; } = new ShareSettings();

            [JsonProperty(PropertyName = "Friends Share Settings")]
            public ShareSettings FriendsShare { get; set; } = new ShareSettings();

            [JsonProperty(PropertyName = "Clans Share Settings")]
            public ShareSettings ClansShare { get; set; } = new ShareSettings();

            [JsonProperty(PropertyName = "Default Share Settings")]
            public Dictionary<ShareType, ShareSettings> DefaultShare { get; set; } = new Dictionary<ShareType, ShareSettings>
            {
                [ShareType.Teams] = new ShareSettings(),
                [ShareType.Friends] = new ShareSettings(),
                [ShareType.Clans] = new ShareSettings()
            };

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber Version { get; set; }

            public class ShareSettings
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool Enabled { get; set; } = true;

                [JsonProperty(PropertyName = "Share Cupboard")]
                public bool ShareCupboard { get; set; } = true;

                [JsonProperty(PropertyName = "Share Turret")]
                public bool ShareTurret { get; set; } = true;

                [JsonProperty(PropertyName = "Key Lock Settings")]
                public LockSettings KeyLock { get; set; } = new LockSettings();

                [JsonProperty(PropertyName = "Code Lock Settings")]
                public LockSettings CodeLock { get; set; } = new LockSettings();
            }

            public class LockSettings
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool Enabled { get; set; } = true;

                [JsonProperty(PropertyName = "Share Door")]
                public bool ShareDoor { get; set; } = true;

                [JsonProperty(PropertyName = "Share Box")]
                public bool ShareBox { get; set; } = true;

                [JsonProperty(PropertyName = "Share Other Locked Entities")]
                public bool ShareOtherEntity { get; set; } = true;
            }

            public ShareSettings GetShareSettings(ShareType shareType)
            {
                switch (shareType)
                {
                    case ShareType.Teams:
                        return TeamsShare;
                    case ShareType.Friends:
                        return FriendsShare;
                    case ShareType.Clans:
                        return ClansShare;
                }
                return null;
            }

            public ShareSettings GetDefaultShareSettings(ShareType shareType)
            {
                switch (shareType)
                {
                    case ShareType.Teams:
                        return DefaultShare[ShareType.Teams];
                    case ShareType.Friends:
                        return DefaultShare[ShareType.Friends];
                    case ShareType.Clans:
                        return DefaultShare[ShareType.Clans];
                }
                return null;
            }
        }

        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Send Authorization Success Message")]
            public bool SendMessage { get; set; } = true;

            [JsonProperty(PropertyName = "Chat Command")]
            public string ChatCommand { get; set; } = "autoauth";

            [JsonProperty(PropertyName = "Chat UI Command")]
            public string UICommand { get; set; } = "autoauthui";

            [JsonProperty(PropertyName = "Chat Prefix")]
            public string Prefix { get; set; } = "<color=#00FFFF>[AutoAuth]</color>: ";

            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong SteamIdIcon { get; set; } = 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.Version = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        private void UpdateConfigValues()
        {
            if (configData.Version < Version)
            {
                if (configData.Version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.Chat.Prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }

                if (configData.Version <= new VersionNumber(1, 3, 5))
                {
                    UpdateOldData();
                }
                configData.Version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            [JsonProperty(PropertyName = "shareData")]
            public Dictionary<ulong, ShareData> playerShareData = new Dictionary<ulong, ShareData>();

            public class ShareData
            {
                [JsonProperty(PropertyName = "t")]
                public ShareEntry teamsShare = new ShareEntry();

                [JsonProperty(PropertyName = "f")]
                public ShareEntry friendsShare = new ShareEntry();

                [JsonProperty(PropertyName = "c")]
                public ShareEntry clansShare = new ShareEntry();

                public ShareEntry GetShareEntry(ShareType shareType)
                {
                    switch (shareType)
                    {
                        case ShareType.Teams:
                            return teamsShare;
                        case ShareType.Friends:
                            return friendsShare;
                        case ShareType.Clans:
                            return clansShare;
                    }
                    return null;
                }
            }

            public class ShareDataContractResolver : DefaultContractResolver
            {
                private readonly List<string> _excludedProperties = new List<string>();

                public ShareDataContractResolver(bool teams, bool friends, bool clans)
                {
                    if (!teams)
                    {
                        _excludedProperties.Add("t");
                    }
                    if (!friends)
                    {
                        _excludedProperties.Add("f");
                    }
                    if (!clans)
                    {
                        _excludedProperties.Add("c");
                    }
                }

                protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
                {
                    return _excludedProperties.Count <= 0 ? base.CreateProperties(type, memberSerialization) :
                            base.CreateProperties(type, memberSerialization).Where(p => !_excludedProperties.Contains(p.PropertyName)).ToList();
                }
            }

            [JsonConverter(typeof(ShareEntryConverter))]
            public class ShareEntry
            {
                public bool enabled;
                public bool cupboard;
                public bool turret;
                public LockShareEntry keyLock = new LockShareEntry();
                public LockShareEntry codeLock = new LockShareEntry();

                public string Write()
                {
                    var num = Convert.ToInt32(enabled) << 0 | Convert.ToInt32(cupboard) << 1 | Convert.ToInt32(turret) << 2 |
                            Convert.ToInt32(keyLock.enabled) << 3 | Convert.ToInt32(keyLock.door) << 4 | Convert.ToInt32(keyLock.box) << 5 | Convert.ToInt32(keyLock.other) << 6 |
                            Convert.ToInt32(codeLock.enabled) << 7 | Convert.ToInt32(codeLock.door) << 8 | Convert.ToInt32(codeLock.box) << 9 | Convert.ToInt32(codeLock.other) << 10;
                    return Convert.ToString(num, 2);
                }

                public static ShareEntry Read(string json)
                {
                    var shareEntry = new ShareEntry();
                    var num = Convert.ToInt32(json, 2);
                    shareEntry.enabled = (num >> 0 & 1) != 0;
                    shareEntry.cupboard = (num >> 1 & 1) != 0;
                    shareEntry.turret = (num >> 2 & 1) != 0;
                    shareEntry.keyLock.enabled = (num >> 3 & 1) != 0;
                    shareEntry.keyLock.door = (num >> 4 & 1) != 0;
                    shareEntry.keyLock.box = (num >> 5 & 1) != 0;
                    shareEntry.keyLock.other = (num >> 6 & 1) != 0;
                    shareEntry.codeLock.enabled = (num >> 7 & 1) != 0;
                    shareEntry.codeLock.door = (num >> 8 & 1) != 0;
                    shareEntry.codeLock.box = (num >> 9 & 1) != 0;
                    shareEntry.codeLock.other = (num >> 10 & 1) != 0;
                    return shareEntry;
                }
            }

            public class LockShareEntry
            {
                public bool enabled;
                public bool door;
                public bool box;
                public bool other;
            }

            private class ShareEntryConverter : JsonConverter
            {
                public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
                {
                    var shareEntry = (ShareEntry)value;
                    writer.WriteValue(shareEntry.Write());
                }

                public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
                {
                    if (reader.TokenType == JsonToken.String)
                    {
                        return ShareEntry.Read(reader.Value.ToString());
                    }

                    return null;
                }

                public override bool CanConvert(Type objectType)
                {
                    return objectType == typeof(ShareEntry);
                }
            }
        }

        private void LoadData()
        {
            try
            {
                //storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
                var dataFile = Interface.Oxide.DataFileSystem.GetFile(Name);
                storedData = dataFile.ReadObject<StoredData>();
                dataFile.Settings.ContractResolver =
                        new StoredData.ShareDataContractResolver(configData.TeamsShare.Enabled, configData.FriendsShare.Enabled, configData.ClansShare.Enabled);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void OnNewSave(string filename)
        {
            if (configData.ClearDataOnWipe)
            {
                ClearData();
            }
        }

        #region OldData

        private void UpdateOldData()
        {
            try
            {
                var oldStoredData = Interface.Oxide.DataFileSystem.ReadObject<OldStoredData>(Name);
                var newJObject = new JObject();
                var newData = new Dictionary<ulong, JObject>();
                foreach (var entry in oldStoredData.playerShareData)
                {
                    newData.Add(entry.Key, entry.Value.GetNewData());
                }

                newJObject["shareData"] = JObject.FromObject(newData);
                Interface.Oxide.DataFileSystem.WriteObject(Name, newJObject);
            }
            catch
            {
                // ignored
            }
        }

        private class OldStoredData
        {
            public readonly Dictionary<ulong, OldShareData> playerShareData = new Dictionary<ulong, OldShareData>();

            public class OldShareData
            {
                public OldShareEntry teamShare = new OldShareEntry();
                public OldShareEntry friendsShare = new OldShareEntry();
                public OldShareEntry clanShare = new OldShareEntry();

                public JObject GetNewData()
                {
                    var jObject = new JObject();
                    jObject["t"] = teamShare.Write();
                    jObject["f"] = friendsShare.Write();
                    jObject["c"] = clanShare.Write();
                    return jObject;
                }
            }

            public class OldShareEntry
            {
                public bool enabled;
                public bool cupboard;
                public bool turret;
                public bool keyLock;
                public bool codeLock;

                public string Write()
                {
                    var num = Convert.ToInt32(enabled) << 0 | Convert.ToInt32(cupboard) << 1 | Convert.ToInt32(turret) << 2 |
                            Convert.ToInt32(keyLock) << 3 | Convert.ToInt32(keyLock) << 4 | Convert.ToInt32(keyLock) << 5 | Convert.ToInt32(keyLock) << 6 |
                            Convert.ToInt32(codeLock) << 7 | Convert.ToInt32(codeLock) << 8 | Convert.ToInt32(codeLock) << 9 | Convert.ToInt32(codeLock) << 10;
                    return Convert.ToString(num, 2);
                }
            }
        }

        #endregion OldData

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.Chat.Prefix, configData.Chat.SteamIdIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
                ["UnableAutoAuth"] = "Unable to automatically authorize other players",
                ["SyntaxError"] = "Syntax error, please type '<color=#ce422b>/{0} <help | h></color>' to view help",
                ["TurretSuccess"] = "Successfully added <color=#ce422b>{0}</color> friends/clan members/team members to <color=#ce422b>{1}</color> turrets auth list",
                ["CupboardSuccess"] = "Successfully added <color=#ce422b>{0}</color> friends/clan members/team members  to <color=#ce422b>{1}</color> cupboards auth list",

                ["UISyntax"] = "<color=#ce422b>/{0} or /{1} ui</color>\n- Open Automatic Authorization UI",

                ["Syntax"] = "<color=#ce422b>/{0} {1}</color>\n- Enable/Disable automatic authorization for your {2}",
                ["Syntax1"] = "<color=#ce422b>/{0} {1} <cupboard | c></color>\n- Sharing cupboard with your {2}",
                ["Syntax2"] = "<color=#ce422b>/{0} {1} <turret | t></color>\n- Sharing turret with your {2}",
                ["Syntax3"] = "<color=#ce422b>/{0} {1} <keylock | kl> [door / box / other]</color>\n- Sharing key lock with your {2}",
                ["Syntax4"] = "<color=#ce422b>/{0} {1} <codelock | cl> [door / box / other]</color>\n- Sharing code lock with your {2}",

                ["TeamsCmdSyntax"] = "<team | t>",
                ["FriendsCmdSyntax"] = "<friend | f>",
                ["ClansCmdSyntax"] = "<clan | c>",

                ["Teams"] = "<color=#009EFF>Team</color>",
                ["Friends"] = "<color=#009EFF>Friend</color>",
                ["Clans"] = "<color=#009EFF>Clan</color>",
                ["TeamsMembers"] = "<color=#009EFF>team members</color>",
                ["FriendsMembers"] = "<color=#009EFF>friends</color>",
                ["ClansMembers"] = "<color=#009EFF>clan members</color>",

                ["ShareStatus"] = "<color=#ffa500>Current {0} sharing status: </color>",
                ["Share"] = "Auto sharing with {0}: {1}",
                ["ShareCupboard"] = "Auto sharing cupboard with {0}: {1}",
                ["ShareTurret"] = "Auto sharing turret with {0}: {1}",
                ["ShareKeyLock"] = "Auto sharing key lock with {0}: {1}",
                ["ShareKeyLockDoor"] = "Auto sharing key lock of door with {0}: {1}",
                ["ShareKeyLockBox"] = "Auto sharing key lock of box with {0}: {1}",
                ["ShareKeyLockOther"] = "Auto sharing key lock of other entity with {0}: {1}",
                ["ShareCodeLock"] = "Auto sharing code lock with {0}: {1}",
                ["ShareCodeLockDoor"] = "Auto sharing code lock of door with {0}: {1}",
                ["ShareCodeLockBox"] = "Auto sharing code lock of box with {0}: {1}",
                ["ShareCodeLockOther"] = "Auto sharing code lock of other entity with {0}: {1}",

                ["All"] = "Sharing with {0} is {1}",
                ["Cupboard"] = "Sharing cupboard with {0} is {1}",
                ["Turret"] = "Sharing turret with {0} is {1}",
                ["KeyLock"] = "Sharing key lock with {0} is {1}",
                ["KeyLockDoor"] = "Sharing key lock of door with {0} is {1}",
                ["KeyLockBox"] = "Sharing key lock of box with {0} is {1}",
                ["KeyLockOther"] = "Sharing key lock of other entity with {0} is {1}",
                ["CodeLock"] = "Sharing code lock with {0} is {1}",
                ["CodeLockDoor"] = "Sharing code lock of door with {0} is {1}",
                ["CodeLockBox"] = "Sharing code lock of box with {0} is {1}",
                ["CodeLockOther"] = "Sharing code lock of other entity with {0} is {1}",

                ["AllDisabled"] = "Server has disabled {0} sharing",
                ["CupboardDisabled"] = "Server has disabled sharing cupboard with {0}",
                ["TurretDisabled"] = "Server has disabled sharing turret with {0}",
                ["KeyLockDisabled"] = "Server has disabled sharing key lock with {0}",
                ["KeyLockDoorDisabled"] = "Server has disabled sharing key lock of door with {0}",
                ["KeyLockBoxDisabled"] = "Server has disabled sharing key lock of box with {0}",
                ["KeyLockOtherDisabled"] = "Server has disabled sharing key lock of other entity with {0}",
                ["CodeLockDisabled"] = "Server has disabled sharing code lock with {0}",
                ["CodeLockDoorDisabled"] = "Server has disabled sharing code lock of door with {0}",
                ["CodeLockBoxDisabled"] = "Server has disabled sharing code lock of box with {0}",
                ["CodeLockOtherDisabled"] = "Server has disabled sharing code lock of other entity with {0}",

                ["UI_Teams"] = "Team",
                ["UI_Friends"] = "Friend",
                ["UI_Clans"] = "Clan",
                ["UI_Title"] = "Automatic Authorization UI",

                ["UI_SubTitle"] = "{0} Sharing Settings",
                ["UI_SubShare"] = "{0} Sharing",
                ["UI_SubCupboard"] = "Sharing Cupboard",
                ["UI_SubTurret"] = "Sharing Turret",
                ["UI_SubKeyLock"] = "Sharing Key Lock",
                ["UI_SubKeyLockDoor"] = "Sharing Key Lock of Door",
                ["UI_SubKeyLockBox"] = "Sharing Key Lock of Box",
                ["UI_SubKeyLockOther"] = "Sharing Key Lock of Other Entity",
                ["UI_SubCodeLock"] = "Sharing Code Lock",
                ["UI_SubCodeLockDoor"] = "Sharing Code Lock of Door",
                ["UI_SubCodeLockBox"] = "Sharing Code Lock of Box",
                ["UI_SubCodeLockOther"] = "Sharing Code Lock of Other Entity"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有权限使用该命令",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
                ["UnableAutoAuth"] = "服务器无法使用自动授权",
                ["SyntaxError"] = "语法错误, 输入 '<color=#ce422b>/{0} <help | h></color>' 查看帮助",
                ["TurretSuccess"] = "自动添加了 <color=#ce422b>{0}</color> 个朋友/战队成员/队友到您的 <color=#ce422b>{1}</color> 个炮台授权列表中",
                ["CupboardSuccess"] = "自动添加了 <color=#ce422b>{0}</color> 个朋友/战队成员/队友到您的 <color=#ce422b>{1}</color> 个领地柜授权列表中",

                ["UISyntax"] = "<color=#ce422b>/{0} 或 /{1} ui</color>\n- 打开自动共享UI",

                ["Syntax"] = "<color=#ce422b>/{0} {1}</color>\n- 启用/禁用{2}自动授权",
                ["Syntax1"] = "<color=#ce422b>/{0} {1} <cupboard | c></color>\n- 自动与{2}共享领地柜",
                ["Syntax2"] = "<color=#ce422b>/{0} {1} <turret | t></color>\n- 自动与{2}共享炮台",
                ["Syntax3"] = "<color=#ce422b>/{0} {1} <keylock | kl> [door / box / other]</color>\n- 自动与{2}共享钥匙锁",
                ["Syntax4"] = "<color=#ce422b>/{0} {1} <codelock | cl> [door / box / other]</color>\n- 自动与{2}共享密码锁",

                ["TeamsCmdSyntax"] = "<team | at>",
                ["FriendsCmdSyntax"] = "<friend | f>",
                ["ClansCmdSyntax"] = "<clan | c>",

                ["Teams"] = "<color=#009EFF>团队</color>",
                ["Friends"] = "<color=#009EFF>好友</color>",
                ["Clans"] = "<color=#009EFF>战队</color>",
                ["TeamsMembers"] = "<color=#009EFF>团队成员</color>",
                ["FriendsMembers"] = "<color=#009EFF>好友</color>",
                ["ClansMembers"] = "<color=#009EFF>战队成员</color>",

                ["ShareStatus"] = "<color=#ffa500>当前{0}自动授权状态: </color>",
                ["Share"] = "自动与{0}共享: {1}",
                ["ShareCupboard"] = "自动与{0}共享领地柜: {1}",
                ["ShareTurret"] = "自动与{0}共享自动炮塔: {1}",
                ["ShareKeyLock"] = "自动与{0}共享钥匙锁: {1}",
                ["ShareKeyLockDoor"] = "自动与{0}共享门的钥匙锁: {1}",
                ["ShareKeyLockBox"] = "自动与{0}共享箱子的钥匙锁: {1}",
                ["ShareKeyLockOther"] = "自动与{0}共享其它实体的钥匙锁: {1}",
                ["ShareCodeLock"] = "自动与{0}共享密码锁: {1}",
                ["ShareCodeLockDoor"] = "自动与{0}共享门的密码锁: {1}",
                ["ShareCodeLockBox"] = "自动与{0}共享箱子的密码锁: {1}",
                ["ShareCodeLockOther"] = "自动与{0}共享其它实体的密码锁: {1}",

                ["All"] = "{0}自动授权 {1}",
                ["Cupboard"] = "自动与{0}共享领地柜 {1}",
                ["Turret"] = "自动与{0}共享自动炮塔 {1}",
                ["KeyLock"] = "自动与{0}共享钥匙锁 {1}",
                ["KeyLockDoor"] = "自动与{0}共享门的钥匙锁 {1}",
                ["KeyLockBox"] = "自动与{0}共享箱子的钥匙锁 {1}",
                ["KeyLockOther"] = "自动与{0}共享其它实体的钥匙锁 {1}",
                ["CodeLock"] = "自动与{0}共享密码锁 {1}",
                ["CodeLockDoor"] = "自动与{0}共享门的密码锁 {1}",
                ["CodeLockBox"] = "自动与{0}共享箱子的密码锁 {1}",
                ["CodeLockOther"] = "自动与{0}共享其它实体的密码锁 {1}",

                ["AllDisabled"] = "服务器已禁用{0}自动授权",
                ["CupboardDisabled"] = "服务器已禁用自动与{0}共享领地柜",
                ["TurretDisabled"] = "服务器已禁用自动与{0}共享自动炮塔",
                ["KeyLockDisabled"] = "服务器已禁用自动与{0}共享钥匙锁",
                ["KeyLockDoorDisabled"] = "服务器已禁用自动与{0}共享门的钥匙锁",
                ["KeyLockBoxDisabled"] = "服务器已禁用自动与{0}共享箱子的钥匙锁",
                ["KeyLockOtherDisabled"] = "服务器已禁用自动与{0}共享其它实体的钥匙锁",
                ["CodeLockDisabled"] = "服务器已禁用自动与{0}共享密码锁",
                ["CodeLockDoorDisabled"] = "服务器已禁用自动与{0}共享门的密码锁",
                ["CodeLockBoxDisabled"] = "服务器已禁用自动与{0}共享箱子的密码锁",
                ["CodeLockOtherDisabled"] = "服务器已禁用自动与{0}共享其它实体的密码锁",

                ["UI_Teams"] = "团队",
                ["UI_Friends"] = "好友",
                ["UI_Clans"] = "战队",
                ["UI_Title"] = "自动共享用户界面",

                ["UI_SubTitle"] = "{0}共享设置",
                ["UI_SubShare"] = "{0}共享",
                ["UI_SubCupboard"] = "共享领地柜",
                ["UI_SubTurret"] = "共享自动炮台",
                ["UI_SubKeyLock"] = "共享钥匙锁",
                ["UI_SubKeyLockDoor"] = "共享门的钥匙锁",
                ["UI_SubKeyLockBox"] = "共享箱子的钥匙锁",
                ["UI_SubKeyLockOther"] = "共享其它实体的钥匙锁",
                ["UI_SubCodeLock"] = "共享密码锁",
                ["UI_SubCodeLockDoor"] = "共享门的密码锁",
                ["UI_SubCodeLockBox"] = "共享箱子的密码锁",
                ["UI_SubCodeLockOther"] = "共享其它实体的密码锁"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutomaticAuthorization.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-raid-tower ---
// --- Original File Path: A/AntiRaidTower/AntiRaidTower.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiRaidTower", "Calyticc", "0.2.3")]
    [Description("Building/deployable height limit, high jump instant death, no wounded teleport")]
    class AntiRaidTower : RustPlugin
    {
        #region Properties
        
        int FallKill;
        bool BuildingBlockHeight;
        bool DeployableBlockHeight;
        int BuildingMaxHeight;
        int DeployableMaxHeight;
        
        #endregion
        
        #region Initialization

        void OnServerInitialized()
        {
            permission.RegisterPermission("antiraidtower.blockheightbypass", this);
            permission.RegisterPermission("antiraidtower.deployheightbypass", this);
            permission.RegisterPermission("antiraidtower.fallkillbypass", this);
            permission.RegisterPermission("antiraidtower.woundedbypass", this);
            LoadMessages();
            LoadData();

            FallKill = GetConfig("FallKill", 215);
            BuildingBlockHeight = GetConfig("BuildingBlockHeight", true);
            DeployableBlockHeight = GetConfig("DeployableBlockHeight", true);
            BuildingMaxHeight = GetConfig("BuildingMaxHeight", 50);
            DeployableMaxHeight = GetConfig("DeployableMaxHeight", 50);
        }
        
        #endregion
        
        #region Configuration & Data

        protected override void LoadDefaultConfig()
        {
            Config["FallKill"] = 215;
            Config["BuildingBlockHeight"] = true;
            Config["BuildingMaxHeight"] = 50;
            Config["DeployableBlockHeight"] = true;
            Config["DeployableMaxHeight"] = 50;

            Config["VERSION"] = Version.ToString();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Denied: Height", "Too far from ground: {0}m"},
                {"Denied: Wounded", "You may not teleport while wounded"},
            }, this);
        }

        void LoadData()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", Version.ToString()) != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            Config["BuildingBlockHeight"] = true;
            Config["BuildingMaxHeight"] = 50;
            Config["DeployableBlockHeight"] = true;
            Config["DeployableMaxHeight"] = 50;
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole("Upgrading configuration file");
            SaveConfig();
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string GetMsg(string key, string userID = null)
        {
            return lang.GetMessage(key, this, userID);
        }
        
        #endregion
        
        #region Hooks

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (FallKill == 0)
            {
                return;
            }

            if (entity is BasePlayer)
            {
                var player = (BasePlayer)entity;
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.fallkillbypass"))
                {
                    return;
                }
                if (player.IsConnected && player.net.connection.authLevel > 0)
                {
                    return;
                }
                var dt = hitinfo.damageTypes.GetMajorityDamageType();
                float amt = hitinfo.damageTypes.Get(dt);
                if (dt == DamageType.Fall)
                {
                    float fallkill = Convert.ToSingle(FallKill);
                    if (amt > fallkill)
                    {
                        player.Die();
                    }
                }
            }
        }

        object CanTeleport(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "antiraidtower.woundedbypass"))
            {
                return null;
            }
            if (player.IsWounded()) { return GetMsg("Denied: Wounded", player.UserIDString); }
            return null;
        }

        object canTeleport(BasePlayer player)
        {
            return CanTeleport(player);
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null) return;
            if (!BuildingBlockHeight && !DeployableBlockHeight) return;

            var MaxHeight = 0;
            var entity = gameObject.GetComponent<BaseCombatEntity>();
            if(entity is BuildingBlock) {
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.blockheightbypass"))
                {
                    return;
                }
                MaxHeight = BuildingMaxHeight;
            }
            else
            {
                if (permission.UserHasPermission(player.UserIDString, "antiraidtower.deployheightbypass"))
                {
                    return;
                }
                MaxHeight = DeployableMaxHeight;
            }

            RaycastHit hitInfo;
            if (entity != null && Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hitInfo, float.PositiveInfinity, Rust.Layers.Terrain))
            {
                if (hitInfo.distance > MaxHeight)
                {
                    SendReply(player, GetMsg("Denied: Height", player.UserIDString), Math.Round(hitInfo.distance, 0));
                    entity.Kill(BaseNetworkable.DestroyMode.Gib);
                }
            }
        }
        
        #endregion
    }
}

// --- End of file: AntiRaidTower.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-spam ---
// --- Original File Path: A/AntiSpam/AntiSpam.cs ---

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Anti Spam", "MON@H", "2.1.3")]
    [Description("Filters spam and impersonation in player names and chat messages.")]

    public class AntiSpam : CovalencePlugin
    {
        #region Class Fields

        [PluginReference] private readonly Plugin BetterChat;

        private const string PermissionImmunity = "antispam.immunity";
        private const string ColorAdmin = "#AAFF55";
        private const string ColorDeveloper = "#FFAA55";
        private const string ColorPlayer = "#55AAFF";

        private static readonly object _true = true;

        private readonly Regexes _regex = new();

        public class Regexes
        {
            public Regex Spam { get; set; }
            public Regex Impersonation { get; set; }
            public Regex Profanities { get; set; }
        }

        #endregion Class Fields

        #region Initialization

        private void Init() => UnsubscribeHooks();

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermissionImmunity, this);

            CacheRegex();
            CacheProfanities();

            if (_configData.GlobalSettings.FilterPlayerNames)
            {
                foreach (IPlayer player in players.Connected)
                {
                    HandleName(player);
                }
            }

            SubscribeHooks();
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings GlobalSettings = new();

            [JsonProperty(PropertyName = "Spam settings")]
            public SpamSettings SpamSettings = new();

            [JsonProperty(PropertyName = "Impersonation settings")]
            public ImpersonationSettings ImpersonationSettings = new();
        }

        private class GlobalSettings
        {
            [JsonProperty(PropertyName = "Enable logging")]
            public bool LoggingEnabled = false;

            [JsonProperty(PropertyName = "Filter chat messages")]
            public bool FilterChatMessages = false;

            [JsonProperty(PropertyName = "Filter player names")]
            public bool FilterPlayerNames = false;

            [JsonProperty(PropertyName = "Use UFilter plugin on player names")]
            public bool UFilterPlayerNames = false;

            [JsonProperty(PropertyName = "Replacement for empty name")]
            public string ReplacementEmptyName = "Player-";
        }

        private class SpamSettings
        {
            [JsonProperty(PropertyName = "Use regex")]
            public bool UseRegex = false;

            [JsonProperty(PropertyName = "Regex list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RegexList = new()
            {
                "(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",
                "(:\\d{3,5})",
                "(https|http|ftp|):\\/\\/",
                "((\\p{L}|[0-9]|-)+\\.)+(com|org|net|int|edu|gov|mil|ch|cn|co|de|eu|fr|in|nz|ru|tk|tr|uk|us)",
                "((\\p{L}|[0-9]|-)+\\.)+(ua|pro|io|dev|me|ml|tk|ml|ga|cf|gq|tf|money|pl|gg|net|info|cz|sk|nl)",
                "((\\p{L}|[0-9]|-)+\\.)+(store|shop)",
                "(\\#+(.+)?rust(.+)?)",
                "((.+)?rust(.+)?\\#+)"
            };

            [JsonProperty(PropertyName = "Use blacklist")]
            public bool UseBlacklist = false;

            [JsonProperty(PropertyName = "Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Blacklist = new()
            {
                "#SPAMRUST",
                "#BESTRUST"
            };

            [JsonProperty(PropertyName = "Replacement for spam")]
            public string Replacement = "";
        }

        private class ImpersonationSettings
        {
            [JsonProperty(PropertyName = "Use regex")]
            public bool UseRegex = false;

            [JsonProperty(PropertyName = "Regex list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RegexList = new()
            {
                "([Ааa4][Ддd][Ммm][Ииi1][Ннn])",
                "([Ммm][Ооo0][Ддd][Ееe3][Ррr])"
            };

            [JsonProperty(PropertyName = "Use blacklist")]
            public bool UseBlacklist = false;

            [JsonProperty(PropertyName = "Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Blacklist = new()
            {
                "Admin",
                "Administrator",
                "Moder",
                "Moderator"
            };

            [JsonProperty(PropertyName = "Replacement for impersonation")]
            public string Replacement = "";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region Oxide Hooks

        private void OnUserConnected(IPlayer player) => HandleName(player);

        private void OnUserNameUpdated(string id, string oldName, string newName)
        {
            if (newName != oldName)
            {
                HandleName(players.FindPlayerById(id));
            }
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            IPlayer player = (IPlayer)data["Player"];
            string text = (string)data["Message"];

            if (string.IsNullOrWhiteSpace(text) || permission.UserHasPermission(player.Id, PermissionImmunity))
            {
                return null;
            }

            string newText = GetSpamFreeMessage(player, text);
            if (string.IsNullOrWhiteSpace(newText))
            {
                data["CancelOption"] = 2;
                return data;
            }

            if (newText != text)
            {
                data["Message"] = newText;
                return data;
            }

            return null;
        }

#if RUST
        private object OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel) => HandleChatMessage(basePlayer.IPlayer, message, (int)channel);
#else
        private object OnUserChat(IPlayer player, string message) => HandleChatMessage(player, message);
#endif


        private void OnPluginLoaded(Plugin plugin)
        {
            if (plugin == null)
            {
                return;
            }

            if (plugin.Name == "UFilter")
            {
                CacheProfanities();
            }
        }

        private void OnProfanityAdded(string profanity) => CacheProfanities();
        private void RemoveProfanity(string profanity) => CacheProfanities();

        #endregion Oxide Hooks

        #region Core Methods

        public void CacheRegex()
        {
            List<string> pattern = new();

            if (_configData.SpamSettings.UseRegex)
            {
                pattern.AddRange(_configData.SpamSettings.RegexList);
            }

            if (_configData.SpamSettings.UseBlacklist)
            {
                foreach (string item in _configData.SpamSettings.Blacklist)
                {
                    pattern.Add($"^{Regex.Escape(item)}$");
                }
            }

            if (pattern.Count > 0)
            {
                _regex.Spam = new(string.Join("|", pattern), RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);
            }

            pattern.Clear();

            if (_configData.ImpersonationSettings.UseRegex)
            {
                pattern.AddRange(_configData.ImpersonationSettings.RegexList);
            }

            if (_configData.ImpersonationSettings.UseBlacklist)
            {
                foreach (string item in _configData.ImpersonationSettings.Blacklist)
                {
                    pattern.Add($"^{Regex.Escape(item)}$");
                }
            }

            if (pattern.Count > 0)
            {
                _regex.Impersonation = new(string.Join("|", pattern), RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);
            }
        }

        public void CacheProfanities()
        {
            if (!_configData.GlobalSettings.UFilterPlayerNames)
            {
                _regex.Profanities = null;
                return;
            }

            Plugin plugin = plugins.Find("UFilter");

            if (!IsPluginLoaded(plugin))
            {
                PrintWarning("Use UFilter plugin on chat messages is set to true in config, but the UFilter plugin is not loaded! Please load the UFilter plugin and then reload this plugin.");
                return;
            }

            if (plugin.Version < new VersionNumber(5, 1, 2))
            {
                PrintError("UFilter plugin must be version 5.1.2 or higher. Please update the UFilter plugin and then reload this plugin.");
                return;
            }

            List<string> pattern = new();

            string[] profanities = plugin.Call("GetProfanities") as string[] ?? Array.Empty<string>();
            string[] allowedProfanity = plugin.Call("GetAllowedProfanity") as string[] ?? Array.Empty<string>();

            foreach (string profanity in profanities)
            {
                if (!allowedProfanity.Contains(profanity) && !pattern.Contains(profanity))
                {
                    pattern.Add($"^{Regex.Escape(profanity)}$");
                }
            }

            if (pattern.Count > 0)
            {
                pattern.Sort();
                _regex.Profanities = new(string.Join("|", pattern), RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);
            }
        }

        public void HandleName(IPlayer player)
        {
            if (player == null || !player.IsConnected || permission.UserHasPermission(player.Id, PermissionImmunity))
            {
                return;
            }

            string newName = GetClearName(player);
            if (newName != player.Name)
            {
                Log($"{player.Id} renaming '{player.Name}' to '{newName}'");
                player.Rename(newName);
            }
        }

        public object HandleChatMessage(IPlayer player, string message, int channel = 0)
        {
            if (string.IsNullOrWhiteSpace(message)
            || IsPluginLoaded(BetterChat)
            || permission.UserHasPermission(player.Id, PermissionImmunity))
            {
                return null;
            }

            string newText = GetSpamFreeMessage(player, message);
            if (string.IsNullOrWhiteSpace(newText))
            {
                return _true;
            }

            if (newText != message)
            {
                Broadcast(player, covalence.FormatText($"[{(player.IsAdmin ? ColorAdmin : ColorPlayer)}]{player.Name}[/#]: {newText}"), channel);

                return _true;
            }

            return null;
        }

        public string GetSpamFreeMessage(IPlayer player, string message)
        {
            if (player == null || string.IsNullOrWhiteSpace(message))
            {
                return null;
            }

            string newText = GetSpamFreeText(message);
            if (newText != message)
            {
                Log($"{player.Id} spam detected in message: {message}");

                return newText;
            }

            return message;
        }

        #endregion Core Methods

        #region API

        private string GetClearName(IPlayer player)
        {
            if (permission.UserHasPermission(player.Id, PermissionImmunity))
            {
                return player.Name;
            }

            string newName = GetSpamFreeText(player.Name);
            newName = GetImpersonationFreeText(newName);
            if (_regex.Profanities != null)
            {
                newName = _regex.Profanities.Replace(newName, _configData.SpamSettings.Replacement);
            }

            if (string.IsNullOrWhiteSpace(newName))
            {
                newName = $"{_configData.GlobalSettings.ReplacementEmptyName}{player.Id.Substring(11, 6)}";
            }

            return newName.Trim();
        }

        private string GetSpamFreeText(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                return string.Empty;
            }

            return _regex.Spam != null ? _regex.Spam.Replace(text, _configData.SpamSettings.Replacement) : text;
        }

        private string GetImpersonationFreeText(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                return string.Empty;
            }

            return _regex.Impersonation != null ? _regex.Impersonation.Replace(text, _configData.SpamSettings.Replacement) : text;
        }

        private Regex GetRegexImpersonation() => _regex.Impersonation;
        private Regex GetRegexProfanities() => _regex.Profanities;
        private Regex GetRegexSpam() => _regex.Spam;

        #endregion API

        #region Helpers

        public void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnBetterChat));
#if RUST
            Unsubscribe(nameof(OnPlayerChat));
#else
            Unsubscribe(nameof(OnUserChat));
#endif
            Unsubscribe(nameof(OnUserConnected));
            Unsubscribe(nameof(OnUserNameUpdated));
            if (!_configData.GlobalSettings.UFilterPlayerNames)
            {
                Unsubscribe(nameof(OnPluginLoaded));
                Unsubscribe(nameof(OnProfanityAdded));
                Unsubscribe(nameof(RemoveProfanity));
            }
        }

        public void SubscribeHooks()
        {
            if (_configData.GlobalSettings.FilterPlayerNames)
            {
                Subscribe(nameof(OnUserConnected));
                Subscribe(nameof(OnUserNameUpdated));
            }

            if (_configData.GlobalSettings.FilterChatMessages)
            {
                Subscribe(nameof(OnBetterChat));
#if RUST
                Subscribe(nameof(OnPlayerChat));
#else
                Subscribe(nameof(OnUserChat));
#endif
            }
        }

        public bool IsPluginLoaded(Plugin plugin) => plugin != null && plugin.IsLoaded;

        public void Log(string text)
        {
            if (_configData.GlobalSettings.LoggingEnabled)
            {
                LogToFile("log", $"{DateTime.Now:yyyy.MM.dd HH:mm:ss} {text}", this);
            }
        }

        public void Broadcast(IPlayer sender, string text, int channel = 0)
        {
#if RUST
            foreach (IPlayer target in players.Connected)
            {
                target.Command("chat.add", channel, sender.Id, text);
            }
#else
            server.Broadcast(text);
#endif
        }

        #endregion Helpers
    }
}

// --- End of file: AntiSpam.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-heli-hoarding ---
// --- Original File Path: A/AntiHeliHoarding/AntiHeliHoarding.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Anti-Heli Hoarding", "Thisha", "0.2.0")]
    public class AntiHeliHoarding : RustPlugin
    {
        #region ChatCommands
        [ChatCommand("helidecay")]
        void ShowDecay(BasePlayer player)
        {
            if (player == null)
                return;

            if (!player.IsAdmin)
                return;

            MiniCopter heli = GetLookingAtMiniCopter(player);
            if (heli == null)
                return;

            player.ChatMessage(MinicoptersInRange(heli.ServerPosition).ToString());
        }
        #endregion ChatCommands

        #region Hooks
        private void Init()
        {
            try
            {
                LoadConfigData();
            }
            catch
            {
                LoadDefaultConfig();
                LoadConfigData();
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            if (!(entity is MiniCopter))
                return;

            if (!hitInfo.damageTypes.Has(Rust.DamageType.Decay)) return;

            MiniCopter heli = entity as MiniCopter;

            int noOfHelis = MinicoptersInRange(heli.ServerPosition);
            if (noOfHelis >= config.MinimumQuantity)
                hitInfo.damageTypes.Scale(Rust.DamageType.Decay, noOfHelis);
            else
                hitInfo.damageTypes.Scale(Rust.DamageType.Decay, 1);
            return;
        }
        #endregion Hooks

        #region Config
        private ConfigData config = new ConfigData();
        class ConfigData
        {
            public int DetectionRadius;
            public int MinimumQuantity;
        }

        private object ConfigValue(string value)
        {
            switch (value)
            {
                case "Detection Radius":
                    if (Config[value] == null)
                        return 30;
                    else
                        return Config[value];
                case "Minimum Quantity":
                    if (Config[value] == null)
                        return 2;
                    else
                        return Config[value];
                default:
                    return null;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Config["Detection Radius"] = ConfigValue("Detection Radius");
            Config["Minimum Quantity"] = ConfigValue("Minimum Quantity");

            SaveConfig();
        }

        private void LoadConfigData()
        {
            config.DetectionRadius = (int)Config["Detection Radius"];
            config.MinimumQuantity = (int)Config["Minimum Quantity"];
        }
        #endregion Config

        #region helpers
        private MiniCopter GetLookingAtMiniCopter(BasePlayer player)
        {
            RaycastHit raycastHit;
            if (Physics.Raycast(player.eyes.position, player.eyes.HeadForward(), out raycastHit, 5f, 1218652417, QueryTriggerInteraction.Ignore))
            {
                BaseEntity entity = raycastHit.GetEntity();
                if (entity)
                {
                    return entity.GetComponent<MiniCopter>();
                }
            }
            return null;
        }

        private int MinicoptersInRange(Vector3 pos)
        {
            int copters = 0;
            
            List<MiniCopter> list = Pool.GetList<MiniCopter>();
            Vis.Entities<MiniCopter>(pos, config.DetectionRadius, list, -13, QueryTriggerInteraction.Collide);
            foreach (MiniCopter copter in list)
            {
                if (!copter.IsDestroyed)
                {
                    copters = copters + 1;
                }
            }
            Pool.FreeList<MiniCopter>(ref list);

            decimal factor = copters / 8;
            copters = (int)Math.Ceiling(factor);

            if (copters < 1)
                copters = 1;

            return copters;
        }
        
        #endregion helpers
    }
}

// --- End of file: AntiHeliHoarding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-chat ---
// --- Original File Path: A/AutoChat/AutoChat.cs ---

﻿using System;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AutoChat", "Frenk92", "0.5.1", ResourceId = 2230)]
    [Description("Automatic clans/private chat switching")]
    class AutoChat : RustPlugin
    {
        [PluginReference]
        Plugin BetterChat, AdminChatroom;

        bool BC = true;
        const string PermAdmin = "autochat.admin";
        const string PermUse = "autochat.use";
        static AutoChat ac;

        #region ChatInfo

        class ChatInfo : MonoBehaviour
        {
            public BasePlayer player { get; set; }
            public string cmd { get; set; }
            public string target { get; set; }
            public int count { get; set; }
            public bool ui { get; set; }

            public string fullcmd => $"{cmd}{target}";

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                cmd = "g";
                target = "";
                count = 0;
                ui = false;
            }

            void Start()
            {
                if (ac._config.SwitchTime == 0) return;
                CancelInvoke("ChatUpdate");
                count = ac._config.SwitchTime;
                InvokeRepeating("ChatUpdate", 0f, 1f);
            }

            public void Stop()
            {
                CancelInvoke("ChatUpdate");
                cmd = "g";
                target = "";
                Switch(cmd, target);
            }

            void ChatUpdate()
            {
                --count;
                if (count <= 0) Stop();
            }

            void FixedUpdate()
            {
                if (!ac._config.UIEnabled)
                {
                    if (ui) ToggleUI(false);
                    return;
                }

                if (ui)
                {
                    if (player.IsSleeping() || player.IsWounded() || player.IsDead())
                        ToggleUI(false);
                }
                else
                {
                    if (player.IsAlive() && !player.IsSleeping() && !player.IsWounded())
                        ToggleUI(true);
                }
            }

            void ToggleUI(bool flag)
            {
                if (ui && !flag)
                {
                    DestroyUI(player);
                    ui = false;
                }
                if (!ui && flag)
                {
                    ac.AddUI(player, cmd);
                    ui = true;
                }
            }

            public void Switch(string cmd, string target = "")
            {
                this.cmd = cmd;
                this.target = target;
                if (ac._config.UIEnabled && ui)
                {
                    DestroyUI(player);
                    ac.AddUI(player, cmd);
                }
                if (cmd != "g") Start();
            }

            public void Destroy()
            {
                CancelInvoke("ChatUpdate");
                DestroyUI(player);
                GameObject.Destroy(this);
            }
        }

        #endregion

        #region Config

        ConfigData _config;
        class ConfigData
        {
            public bool Enabled { get; set; } = true;
            public bool PlayerActive { get; set; } = false;
            public bool ShowSwitchMessage { get; set; } = true;
            public int SwitchTime { get; set; } = 600;
            public Dictionary<string, List<string>> CustomChat { get; set; } = new Dictionary<string, List<string>>() { { "Test", new List<string> { "command1", "command2" } } };
            public bool UIEnabled { get; set; } = true;
            public UIConfig UISettings { get; set; } = new UIConfig();
        }

        class UIConfig
        {
            public string BackgroundColor { get; set; } = "0.29 0.49 0.69 0.5";
            public string TextColor { get; set; } = "#0000FF";
            public string FontSize { get; set; } = "15";
            public string AnchorMin { get; set; } = "0 0.125";
            public string AnchorMax { get; set; } = "0.012 0.1655";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning(Lang("NoConfig"));
            _config = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Data

        List<string> ChatType = new List<string>();
        List<string> LoadedPlugins = new List<string>();

        Dictionary<string, List<string>> cmdPlugins = new Dictionary<string, List<string>>
        {
            { "Clans", new List<string> { "c", "a" } }, //Universal Clans
            { "Rust:IO Clans", new List<string> { "c" } }, //Rust:IO Clans
            { "Friends.dcode", new List<string> { "fm", "f", "pm $target", "m $target", "rm", "r" } }, //Universal Friends
            { "PrivateMessage", new List<string> { "pm $target", "r" } }, //Private Message
            { "Private Messages", new List<string> { "pm $target", "r" } }, //Private Messages (Universal)
            { "Admin Chatroom", new List<string> { "a" } }, //Admin Chatroom
            { "Admin Chat", new List<string> { "a" } } //Admin Chat
        };

        Dictionary<ulong, PlayerChat> Users = new Dictionary<ulong, PlayerChat>();
        class PlayerChat
        {
            public string Name { get; set; }
            public bool Active { get; set; }

            public PlayerChat(string Name, bool Active)
            {
                this.Name = Name;
                this.Active = Active;
            }
        }

        private void LoadData() { Users = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PlayerChat>>("AutoChat"); }
        private void SaveData() { Interface.Oxide.DataFileSystem.WriteObject("AutoChat", Users); }

        PlayerChat GetPlayerData(BasePlayer player)
        {
            PlayerChat playerData;
            if (!Users.TryGetValue(player.userID, out playerData))
            {
                Users[player.userID] = playerData = new PlayerChat(player.displayName, _config.PlayerActive);
                SaveData();
            }

            return playerData;
        }

        #endregion

        #region Hooks

        void OnServerInitialized() { CheckPlugins(); }

        void Loaded()
        {
            LoadData();

            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermUse, this);

            if (_config.Enabled && _config.UIEnabled)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (!Users.ContainsKey(p.userID) && !_config.PlayerActive) continue;
                    var d = GetPlayerData(p);
                    if (d.Active) p.gameObject.AddComponent<ChatInfo>();
                }
            }

            ac = this;
        }

        void Unload()
        {
            ChatType.Clear();
            LoadedPlugins.Clear();

            foreach (var c in Resources.FindObjectsOfTypeAll<ChatInfo>()) c.Destroy();
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!_config.Enabled || (!_config.PlayerActive && !Users.ContainsKey(player.userID))) return;
			var d = GetPlayerData(player);
            if (d.Active) player.gameObject.AddComponent<ChatInfo>();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var info = player.GetComponent<ChatInfo>();
            if (info != null) info.Destroy();
        }

        void OnPluginLoaded(Plugin pl)
        {
            if (LoadedPlugins.Contains(pl.Name)) return;

            var load = false;
            if (cmdPlugins.ContainsKey(pl.Title))
            {
                var cp = cmdPlugins.FirstOrDefault(x => x.Key.Equals($"{pl.Title}.{pl.Author}") || x.Key.Equals(pl.Title)).Value;
                foreach (var cmd in cp) ChatType.Add(cmd);
                load = true;
            }
            else if (_config.CustomChat.ContainsKey(pl.Name))
            {
                foreach (var cc in _config.CustomChat[pl.Name]) ChatType.Add(cc);
                load = true;
            }

            if (load)
            {
                LoadedPlugins.Add(pl.Name);
                Print("Loaded", pl.Name);
            }
        }

        void OnPluginUnloaded(Plugin pl)
        {
            if (cmdPlugins.ContainsKey(pl.Title))
                timer.Once(3, () =>
                {
                    if (!plugins.Exists(pl.Name))
                    {
                        var cp = cmdPlugins.FirstOrDefault(x => x.Key.Equals($"{pl.Title}.{pl.Author}") || x.Key.Equals(pl.Title)).Value;
                        foreach (var cmd in cp) ChatType.Remove(cmd);
                        LoadedPlugins.Remove(pl.Name);
                        Print("Unloaded", pl.Name);
                    }
                });

            if (_config.CustomChat.ContainsKey(pl.Name))
                timer.Once(3, () =>
                {
                    if (!plugins.Exists(pl.Name))
                    {
                        foreach (var cc in _config.CustomChat[pl.Name]) ChatType.Remove(cc);
                        LoadedPlugins.Remove(pl.Name);
                        Print("Unloaded", pl.Name);
                    }
                });
        }

        #endregion

        #region Commands

        [ChatCommand("ac")]
        private void cmdAutoChat(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0 || args == null) return;
            if (!_config.Enabled && !HasPermission(player.UserIDString, PermAdmin))
            {
                MessageChat(player, "IsDisabled");
                return;
            }
            if (!HasPermission(player.UserIDString, PermUse))
            {
                MessageChat(player, "NoPerm");
                return;
            }

            try
            {
                switch (args[0].ToLower())
                {
                    case "help":
                        {
                            if (HasPermission(player.UserIDString, PermAdmin))
                                PrintToChat(player, Lang("Help", player.UserIDString) + Lang("HelpAdmin", player.UserIDString));
                            else
                                MessageChat(player, "Help");
                            break;
                        }
                    case "active":
                        {
                            var playerData = GetPlayerData(player);
                            var flag = playerData.Active = !playerData.Active;
                            if (args.Length > 1)
                            {
                                if (!bool.TryParse(args[1], out flag))
                                {
                                    MessageChat(player, "ErrorBool");
                                    break;
                                }
                            }
                            playerData.Active = flag;

                            var c = player.GetComponent<ChatInfo>();
                            if (playerData.Active)
                            {
                                if (c == null) player.gameObject.AddComponent<ChatInfo>();
                                MessageChat(player, "Activated");
                            }
                            else
                            {
                                if (c != null) c.Destroy();
                                MessageChat(player, "Deactivated");
                            }
                            SaveData();
                            break;
                        }
                    case "enable":
                        {
                            if (!HasPermission(player.UserIDString, PermAdmin))
                            {
                                MessageChat(player, "NoPerm");
                                break;
                            }

                            var enabled = _config.Enabled = !_config.Enabled;
                            if (args.Length > 1)
                            {
                                if (!bool.TryParse(args[1], out enabled))
                                {
                                    MessageChat(player, "ErrorBool");
                                    break;
                                }
                            }
                            _config.Enabled = enabled;

                            if (enabled)
                            {
                                MessageChat(player, "Enabled");
                                foreach (var p in BasePlayer.activePlayerList)
                                {
                                    if (!Users.ContainsKey(p.userID) && !_config.PlayerActive) continue;
                                    var d = GetPlayerData(p);
                                    if (d.Active) p.gameObject.AddComponent<ChatInfo>();
                                }
                            }
                            else
                            {
                                foreach (var c in Resources.FindObjectsOfTypeAll<ChatInfo>()) c.Destroy();
                                MessageChat(player, "Disabled");
                            }
                            SaveConfig();
                            break;
                        }
                    case "auto":
                        {
                            if (!HasPermission(player.UserIDString, PermAdmin))
                            {
                                MessageChat(player, "NoPerm");
                                break;
                            }

                            var pa = _config.PlayerActive = !_config.PlayerActive;
                            if (args.Length > 1)
                            {
                                if (!bool.TryParse(args[1], out pa))
                                {
                                    MessageChat(player, "ErrorBool");
                                    break;
                                }
                            }
                            _config.PlayerActive = pa;

                            if (pa)
                                MessageChat(player, "AutoON");
                            else
                                MessageChat(player, "AutoOFF");
                            SaveConfig();
                            break;
                        }
                    case "ui":
                        {
                            if (!HasPermission(player.UserIDString, PermAdmin))
                            {
                                MessageChat(player, "NoPerm");
                                break;
                            }

                            var ui = _config.UIEnabled = !_config.UIEnabled;
                            if (args.Length > 1)
                            {
                                if (!bool.TryParse(args[1], out ui))
                                {
                                    MessageChat(player, "ErrorBool");
                                    break;
                                }
                            }
                            _config.UIEnabled = ui;

                            if (ui)
                                MessageChat(player, "UIEnabled");
                            else
                                MessageChat(player, "UIDisabled");
                            SaveConfig();
                            break;
                        }
                    case "msg":
                        {
                            if (!HasPermission(player.UserIDString, PermAdmin))
                            {
                                MessageChat(player, "NoPerm");
                                break;
                            }

                            var msg = _config.ShowSwitchMessage = !_config.ShowSwitchMessage;
                            if (args.Length > 1)
                            {
                                if (!bool.TryParse(args[1], out msg))
                                {
                                    MessageChat(player, "ErrorBool");
                                    break;
                                }
                            }
                            _config.ShowSwitchMessage = msg;

                            if (msg)
                                MessageChat(player, "MsgON");
                            else
                                MessageChat(player, "MsgOFF");
                            SaveConfig();
                            break;
                        }
                }
            }
            catch { }
        }

        [ChatCommand("g")]
        private void cmdGlobalChat(BasePlayer player, string command, string[] args)
        {
            if (!_config.Enabled || !isActive(player.userID)) return;

            var c = player.GetComponent<ChatInfo>();
            if (c == null) return;
            if (args.Length == 0 || args == null)
            {
                if (c.cmd != "g")
                {
                    c.Stop();
                    MessageChat(player, "GlobalChat");
                }
                return;
            }
            if (c.cmd != "g") c.Stop();

            rust.RunClientCommand(player, "chat.say", string.Join(" ", args));
        }

        [ConsoleCommand("ac")]
        private void consAutoChat(ConsoleSystem.Arg arg)
        {
            if ((arg.Connection != null && arg.Connection.authLevel < 2) || arg.Args.Length == 0 || arg.Args == null) return;

            switch (arg.Args[0].ToLower())
            {
                case "enable":
                    {
                        var enabled = _config.Enabled = !_config.Enabled;
                        if (arg.Args.Length > 1)
                        {
                            if (!bool.TryParse(arg.Args[1], out enabled))
                            {
                                Print("ErrorBool");
                                break;
                            }
                        }
                        _config.Enabled = enabled;

                        if (enabled)
                        {
                            Print("Enabled");
                            foreach (var p in BasePlayer.activePlayerList)
                            {
                                if (!Users.ContainsKey(p.userID) && !_config.PlayerActive) continue;
                                var d = GetPlayerData(p);
                                if (d.Active) p.gameObject.AddComponent<ChatInfo>();
                            }
                        }
                        else
                        {
                            foreach (var c in Resources.FindObjectsOfTypeAll<ChatInfo>()) c.Destroy();
                            Print("Disabled");
                        }
                        SaveConfig();
                        break;
                    }
                case "auto":
                    {
                        var pa = _config.PlayerActive = !_config.PlayerActive;
                        if (arg.Args.Length > 1)
                        {
                            if (!bool.TryParse(arg.Args[1], out pa))
                            {
                                Print("ErrorBool");
                                break;
                            }
                        }
                        _config.PlayerActive = pa;

                        if (pa)
                            Print("AutoON");
                        else
                            Print("AutoOFF");
                        SaveConfig();
                        break;
                    }
                case "ui":
                    {
                        var ui = _config.UIEnabled = !_config.UIEnabled;
                        if (arg.Args.Length > 1)
                        {
                            if (!bool.TryParse(arg.Args[1], out ui))
                            {
                                Print("ErrorBool");
                                break;
                            }
                        }
                        _config.UIEnabled = ui;

                        if (ui)
                            Print("UIEnabled");
                        else
                            Print("UIDisabled");
                        SaveConfig();
                        break;
                    }
                case "msg":
                    {
                        var msg = _config.ShowSwitchMessage = !_config.ShowSwitchMessage;
                        if (arg.Args.Length > 1)
                        {
                            if (!bool.TryParse(arg.Args[1], out msg))
                            {
                                Print("ErrorBool");
                                break;
                            }
                        }
                        _config.UIEnabled = msg;

                        if (msg)
                            Print("MsgON");
                        else
                            Print("MsgOFF");
                        SaveConfig();
                        break;
                    }
            }
        }

        #endregion

        #region Methods

        private void OnUserCommand(IPlayer player, string command, string[] args)
        {
            if (!_config.Enabled || !HasPermission(player.Id, PermUse) || !isActive(player.Id) || !player.IsConnected || args == null) return;
            if (AdminChatroom && command == "a" && (args[0] == "invite" || args[0] == "kick")) return;
            var bpl = player.Object as BasePlayer;
            if (!bpl) return;

            var cmdtarget = command + " $target";
            if (!ChatType.Contains(command) && !ChatType.Contains(cmdtarget)) return;

            var target = "";
            if (ChatType.Contains(cmdtarget))
            {
                if (args.Length > 0) target = " " + args[0];
                else return;
            }
            var c = bpl.GetComponent<ChatInfo>();
            if (c == null) c = bpl.gameObject.AddComponent<ChatInfo>();
            if (c.cmd != command || c.target != target)
            {
                if (_config.ShowSwitchMessage && c.cmd == "g") MessageChat(bpl, "Switch");
                c.Switch(command, target);
            }
        }

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (!_config.Enabled) return null;

            var player = (BasePlayer)arg.Connection.player;
            if (!player || !HasPermission(player.UserIDString, PermUse) || !isActive(player.userID)) return null;

            var c = player.GetComponent<ChatInfo>();
            if (c == null || c.cmd == "g") return null;

            var message = arg.GetString(0, "text");
            rust.RunClientCommand(player, "chat.say", $"/{c.fullcmd} {message}");

            if (BC)
                return null;
            else
                return false;
        }

        object OnBetterChat(Dictionary<string, object> data)
        {
            var player = (IPlayer)data["Player"];
            if (!_config.Enabled || !HasPermission(player.Id, PermUse) || !isActive(player.Id)) return data;
            var bPlayer = Game.Rust.RustCore.FindPlayerByIdString(player.Id);
            var c = bPlayer.GetComponent<ChatInfo>();
            if (c == null || c.cmd == "g") return data;

            return false;
        }

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>            {
                ["Enabled"] = "AutoChat is enabled.",
                ["Disabled"] = "AutoChat is disabled.",
                ["Activated"] = "You have active the autochat.",
                ["Deactivated"] = "You have deactive the autochat.",
                ["UIEnabled"] = "UI was enabled.",
                ["UIDisabled"] = "UI was disabled.",
                ["AutoON"] = "AutoChat is now auto-activated for new players.",
                ["AutoOFF"] = "AutoChat is now auto-deactivated for new players.",
                ["MsgON"] = "Message when switching chat is enabled.",
                ["MsgOFF"] = "Message when switching chat is disabled",
                ["GlobalChat"] = "You switched to the global chat.",
                ["NoPerm"] = "You don't have permission to use this command.",
                ["IsDisabled"] = "The plugin is disabled.",
                ["ErrorBool"] = "Error. Only \"true\" or \"false\".",
                ["NoPlugins"] = "The plugin was disabled because weren't found supported plugins.",
                ["ListPlugins"] = "Supported plugins: {0}{1}",
                ["Loaded"] = "Loaded plugin: {0}",
                ["Unloaded"] = "Unloaded plugin: {0}",
                ["NoConfig"] = "Could not read config file. Creating new one...",
                ["Switch"] = "You switched chat. Type \"/g\" to return to the global chat (\"/ac help\" for other commands).",
                ["Help"] = ">> AUTOCHAT HELP <<\n/ac active \"true/false:OPTIONAL\" - to active/deactive autochat.\n/g \"message:OPTIONAL\" - to send message and switch to global chat.",
                ["HelpAdmin"] = "\nAdmin Commands:\n/ac enable \"true/false:OPTIONAL\" - to enable/disable plugin.\n/ac auto \"true/false:OPTIONAL\" - to auto-active/deactive plugin for new players.\n/ac msg \"true/false:OPTIONAL\" - to enable/disable message when switching chat.",
            }, this);
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        void MessageChat(BasePlayer player, string key, params object[] args)
        {
            var msg = Lang(key, player.UserIDString, args);
            PrintToChat(player, msg);
        }
        void Print(string key, params object[] args) => Puts(Lang(key, null, args));

        #endregion

        #region Utilities

        void CheckPlugins()
        {
            var list = new List<string>();
            var listPlugins = new List<Plugin>(plugins.GetAll());
            foreach (var cp in cmdPlugins)
            {
                var pl = listPlugins.Find(p => cp.Key.Equals($"{p.Title}.{p.Author}") || cp.Key.Equals(p.Title));
                if (pl)
                {
                    foreach (var cmd in cp.Value) ChatType.Add(cmd);
                    list.Add(pl.Name);
                    LoadedPlugins.Add(pl.Name);
                }
            }

            var lcus = new List<string>();
            foreach (var p in _config.CustomChat)
                if (plugins.Exists(p.Key))
                {
                    foreach (var c in p.Value) ChatType.Add(c);
                    lcus.Add(p.Key);
                    LoadedPlugins.Add(p.Key);
                }

            if (ChatType.Count == 0)
            {
                _config.Enabled = false;
                PrintWarning(Lang("NoPlugins"));
            }
            else
            {
                Print("ListPlugins", string.Join(", ", list.ToArray()), lcus.Count != 0 ? "\nCustomChat: " + string.Join(", ", lcus.ToArray()) : null);
                list.Clear();
                lcus.Clear();
            }

            if (BetterChat)
            {
                var v = Convert.ToInt32(BetterChat.Version.ToString().Split('.')[0]);
                if (v >= 5) BC = false;
            }
            else
                BC = false;
        }

        bool isActive(string id) => id.IsSteamId() && isActive(Convert.ToUInt64(id));
        bool isActive(ulong id) => Users.ContainsKey(id) && Users[id].Active;

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion

        #region CUI

        static string cuiJson = @"[
        {
            ""name"": ""backAC"",
            ""parent"": ""Hud"",
            ""components"": [
              {
                ""type"": ""UnityEngine.UI.Image"",
                ""color"": ""{BackColor}""
              },
              {
                ""type"": ""RectTransform"",
                ""anchormin"": ""{AnchorMin}"",
                ""anchormax"": ""{AnchorMax}""
              }
            ]
          },
          {
            ""name"": ""lblAC"",
            ""parent"": ""backAC"",
            ""components"": [
              {
                ""text"": ""{Command}"",
                ""type"": ""UnityEngine.UI.Text"",
                ""color"": ""{TextColor}"",
                ""fontSize"": {FontSize},
                ""align"": ""MiddleCenter""
              },
              {
                ""type"": ""RectTransform"",
                ""anchormin"": ""0 0"",
                ""anchormax"": ""1 1""
              }
            ]
          }
        ]";

        void AddUI(BasePlayer player, string cmd)
        {
            var backColor = Color(_config.UISettings.BackgroundColor);
            var textColor = Color(_config.UISettings.TextColor);
            var cui = cuiJson.Replace("{BackColor}", backColor)
                            .Replace("{TextColor}", textColor)
                            .Replace("{FontSize}", _config.UISettings.FontSize)
                            .Replace("{AnchorMin}", _config.UISettings.AnchorMin)
                            .Replace("{AnchorMax}", _config.UISettings.AnchorMax)
                            .Replace("{Command}", cmd);
            CuiHelper.AddUi(player, cui);
        }

        static void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, "backAC");

        public static string Color(string hexColor)
        {
            if (!hexColor.StartsWith("#")) return hexColor;
            if (hexColor.StartsWith("#")) hexColor = hexColor.TrimStart('#');
            int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} 1";
        }

        #endregion
    }
}


// --- End of file: AutoChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-spectate ---
// --- Original File Path: A/AutoSpectate/AutoSpectate.cs ---

using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Auto Spectate", "Aspectdev", "0.0.13")]
    [Description("Provides a way to automatically switch between users while spectating.")]
    class AutoSpectate : CovalencePlugin
    {

        #region Core

        Dictionary<string, Information> _users = new Dictionary<string, Information>();

        const string _permission = "autospectate.use";

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPlayers"] = "Auto Spectate session ended. There are less than the required amount of players in the game.",
                ["StartedSpectate"] = "Successfully started auto spectating with rate of {secondsRate} seconds.",
                ["MovedToSpectator"] = "It doesn't look like you were already spectating. You have been moved to spectator mode.",
                ["Removed"] = "You have been removed from auto spectate mode.",
                ["Updated"] = "{Prefix} Updated spectator to {newMessage}"
            }, this, "en");
        }

        void Init() => permission.RegisterPermission(_permission, this);

        void OnPlayerDisconnected(BasePlayer player)
        {
            string SteamID = player.UserIDString;
            if (_users.ContainsKey(SteamID))
            {
                if (!_users[SteamID].myTimer.Destroyed) _users[SteamID].myTimer.Destroy();
                _users.Remove(SteamID);
            }
        }

        object OnMessagePlayer(string message, BasePlayer player)
        {
            if (_users.ContainsKey(player.UserIDString) && message.StartsWith("Spectating:"))
            {
                return true;
            }
            return null;
        }

        void Unload() => _users.Clear();

        #endregion

        #region Commands

        [Command("autospectate")]
        void Spectate(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            var SteamID = iplayer.Id;

            if (!permission.UserHasPermission(SteamID, _permission) || (!ServerUsers.Is(player.userID, ServerUsers.UserGroup.Moderator) && !ServerUsers.Is(player.userID, ServerUsers.UserGroup.Owner))) return;

            if (_users.ContainsKey(SteamID))
            {
                if (_users[SteamID].myTimer != null) _users[SteamID].myTimer.Destroy();
                _users.Remove(SteamID);

                player.ShowToast(0, lang.GetMessage("Removed", this, player.UserIDString));
                return;
            };

            int result;
            try
            {
                result = Math.Max(Math.Min(Int32.Parse(args[0]), 300), 1);
            } catch
            {
                result = 15;
            }

            player.ShowToast(0, lang.GetMessage("StartedSpectate", this, player.UserIDString).Replace("{secondsRate}", result.ToString()));
            
            Timer myTimer = null;
            myTimer = timer.Every(result, () =>
            {
                if (myTimer.Destroyed) return;

                if (!_users.ContainsKey(SteamID))
                {
                    if (myTimer != null && !myTimer.Destroyed) myTimer.Destroy();
                    return;
                }
                else if (_users[SteamID].myTimer == null) _users[SteamID].myTimer = myTimer;

                var list = BasePlayer.activePlayerList.Where(v => v.UserIDString != SteamID && !v.IsDead()).ToList();
                if (list.Count <= 0)
                {
                    _users.Remove(SteamID);
                    if (!myTimer.Destroyed) myTimer.Destroy();
                    player.ShowToast(0, lang.GetMessage("NoPlayers", this, player.UserIDString));
                    return;
                }

                else SwitchSpectator(list, player);
            });

            _users[SteamID] = new Information(Core.Random.Range(0, BasePlayer.activePlayerList.Where(v => v.UserIDString != SteamID && !v.IsDead()).ToList().Count-2), myTimer);
        }

        #endregion

        #region Helpers

        internal void SwitchSpectator(List<BasePlayer> list, BasePlayer player)
        {
            string SteamID = player.UserIDString;

            BasePlayer target = list[_users[SteamID].spectateId %= list.Count];
            _users[SteamID].spectateId += 1;

            if (target != null)
            {
                if (!player.IsSpectating())
                {
                    player.ShowToast(0, lang.GetMessage("MovedToSpectator", this, player.UserIDString));

                    if (!player.IsDead()) player.DieInstantly();
                    player.StartSpectating();
                }
                else
                {
                    var playerName = target.displayName;
                    player.ShowToast(GameTip.Styles.Red_Normal, lang.GetMessage("Updated", this, player.UserIDString).Replace("{Prefix}", $"[{_users[SteamID].spectateId}/{list.Count}]").Replace("{newMessage}", playerName));
                }
                player.UpdateSpectateTarget(target.UserIDString);
            }
        }

        #endregion

        #region Classes

        public class Information
        {
            public Information(int sp, Timer t)
            {
                spectateId = sp;
                myTimer = t;
            }

            public int spectateId;
            public Timer myTimer;
        }

        #endregion
    }
}

// --- End of file: AutoSpectate.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/always-day ---
// --- Original File Path: A/AlwaysDay/AlwaysDay.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Always Day", "Orange", "1.0.1")]
    [Description("Stops time on your server at one time")]
    public class AlwaysDay : RustPlugin
    {
        #region Vars

        private TOD_Time time;

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            time = UnityEngine.Object.FindObjectOfType<TOD_Time>();
            time.ProgressTime = false;
            Server.Command($"env.time {config.time}");
        }

        private void Unload()
        {
            time.ProgressTime = true;
        }

        #endregion
        
        #region Configuration 1.1.2

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Time")]
            public string time;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                time =  "12"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                
                timer.Every(10f, () =>
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: AlwaysDay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-status-manager ---
// --- Original File Path: A/AdminStatusManager/AdminStatusManager.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Models.Database;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Admin Status Manager", "Ryz0r", "1.1.1")]
    [Description("Give players with permission admin permissions upon connecting. Players may also toggle it with a different permission using a command.")]
    public class AdminStatusManager : RustPlugin
    {
        private List<BasePlayer> _adminList = new List<BasePlayer>();
        private const string AutoPerm = "adminstatusmanager.auto";
        private const string CommandPerm = "adminstatusmanager.use";
        
        private static AdminStatusManager _aa;
        
        #region Hooks/Functions

        private void ChangeStatus(BasePlayer bp, bool status)
        {
            switch (status)
            {
                case true:
                    permission.AddUserGroup(bp.UserIDString, "admin");
                    bp.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    bp.net.connection.authLevel = 2;
                    bp.Command("admintime " + _config.DefaultTime);
                
                    _adminList.Add(bp);
                    bp.SendNetworkUpdateImmediate();
            
                    bp.ChatMessage(lang.GetMessage("ToggledOn", this, bp.UserIDString).Replace("{commands}", String.Join(", ", _config.Commands)));
                    break;
                
                case false:
                    permission.RemoveUserGroup(bp.UserIDString, "admin");
                    bp.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    bp.net.connection.authLevel = 0;
                    bp.Command("admintime -1");
                
                    _adminList.Remove(bp);
                    bp.SendNetworkUpdateImmediate();
            
                    bp.ChatMessage(lang.GetMessage("ToggledOff", this, bp.UserIDString).Replace("{commands}", String.Join(", ", _config.Commands)));

                    break;
            }
        }

        private void Init()
        {
            _aa = this;

            AddCovalenceCommand(_config.Commands, nameof(ToggleCommand));
            AddCovalenceCommand("noclip", nameof(NoclipCommand));
            permission.RegisterPermission(AutoPerm, this);
            permission.RegisterPermission(CommandPerm, this);
        }

        private void Unload() { _aa = null; }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (!_config.AutoAdmin && !permission.UserHasPermission(player.UserIDString, AutoPerm)) return;
            
            permission.AddUserGroup(player.UserIDString, "admin");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            player.net.connection.authLevel = 1;
            player.Command("admintime " + _config.DefaultTime);
            
            player.SendNetworkUpdateImmediate();
            _adminList.Add(player);

            player.ChatMessage(lang.GetMessage("ToggledOff", this, player.UserIDString).Replace("{commands}", String.Join(", ", _config.Commands)));
        }
        
        #endregion
        #region Configuration

        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty(PropertyName = "Valid Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = {"toggle", "admin"};
            
            [JsonProperty(PropertyName = "Automatically Give Admin")]
            public bool AutoAdmin = false;

            [JsonProperty(PropertyName = "Default Time for Admins When Joining")]
            public float DefaultTime = 12f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ToggledOn"] = "Admin permissions toggled <color=green>ON</color>. Turn off with ({commands})",
                ["ToggledOff"] = "Admin permissions toggled <color=red>OFF</color>. Turn on with ({commands})",
                ["NotClient"] = "This command is meant to be run from a client, not the console.",
                ["NoPerm"] = "You don't have the permissions to use this command."
            }, this); 
        }
        #endregion

        private void ToggleCommand(IPlayer player, string command, string[] args)
        {
            var bp = player.Object as BasePlayer;
            if (bp == null)
            {
                player.Reply(lang.GetMessage("NotClient", this, player.Id));
                return;
            }

            if (!permission.UserHasPermission(player.Id,CommandPerm))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }

            ChangeStatus(bp, !_adminList.Contains(bp));
        }
        
       
        private void NoclipCommand(IPlayer player, string command, string[] args)
        {
            var bp = player.Object as BasePlayer;
            if (bp == null)
            {
                player.Reply(lang.GetMessage("NotClient", this, player.Id));
                return;
            }

            if (!permission.UserHasPermission(player.Id,CommandPerm))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }
            
            if (bp.net.connection?.authLevel < 2 || !_adminList.Contains(bp))
            {
                player.Reply(lang.GetMessage("NoPerm", this, player.Id));
                return;
            }
            
            rust.RunClientCommand(bp, "noclip");
        }
    }
}

// --- End of file: AdminStatusManager.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/all-bags-cooldown ---
// --- Original File Path: A/AllBagsCooldown/AllBagsCooldown.cs ---

﻿namespace Oxide.Plugins
{
    [Info("All Bags Cooldown", "Flashtim", "1.0.4")]
    [Description("Put same cooldown on all sleeping bags of player")]
    class AllBagsCooldown : RustPlugin
    {
        private const string permAllow = "allbagscooldown.nosync.allow";

        private void Init()
        {
            permission.RegisterPermission(permAllow, this);
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (!permission.UserHasPermission(player.UserIDString, permAllow))
                ResetSpawnTargets(player);
        }

        private void ResetSpawnTargets(BasePlayer player)
        {
            SleepingBag[] bags = SleepingBag.FindForPlayer(player.userID, true);
            
            float maxTime = 0;

            foreach (SleepingBag bag in bags) {
                if(maxTime < bag.unlockTime)
                {
                    maxTime = bag.unlockTime;
                } 
            }
            foreach (SleepingBag bag in bags) {
                bag.unlockTime = maxTime;
            }
        }
    }
}


// --- End of file: AllBagsCooldown.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/angry-authlevel ---
// --- Original File Path: A/AngryAuthlevel/AngryAuthlevel.cs ---

using System;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("AngryAuthlevel", "Tori1157", "2.0.0")]
	[Description("Automatically gives or removes Authlevel for users.")]
	
	class AngryAuthlevel : CovalencePlugin
	{
		#region Fields

		private bool Changed;
        private bool delayedAdd;
        private bool loadedAdd;
        private bool addingMessage;
        private bool logAdding;
        private bool removeUnlisted;

        private string Auth1List;
		private string Auth2List;

        private const string UpdatePermission = "angryauthlevel.update";
        private const string logFilename = "logging";

        #endregion Fields

        #region Loading

        private void Init()
		{
            permission.RegisterPermission(UpdatePermission, this);

			LoadVariables();
            AddingAuthCheck();
		}

		protected override void LoadDefaultConfig()
		{
			Puts("Creating a new configuration file!");
			Config.Clear();
			LoadVariables();
        }

		private void LoadVariables() 
		{
			Auth1List = ListConfig("Authentication List", "Auth Level 1", new List<string>{""});
			Auth2List = ListConfig("Authentication List", "Auth Level 2", new List<string>{""});

            delayedAdd = BoolConfig("Options", "Add Auths On Connection", true);
            loadedAdd = BoolConfig("Options", "Add Auths On Plugin Load", false);
            addingMessage = BoolConfig("Options", "Adding Message", true);
            logAdding = BoolConfig("Options", "Log Adding", false);
            removeUnlisted = BoolConfig("Options", "Remove Unlisted Users", true);

			if (Changed)
			{
				SaveConfig();
				Changed = false;		
			}	
		}

        private void Loaded() => LoadingAdd();

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["No Permission"] = "You do not have permission to the [#cyan]{0}[/#] command!",
                ["Added By"] = "Added by {0}",
                ["Added Message"] = "Added [#cyan]{0}[/#] as [#cyan]{1}[/#]",
                ["Removed Message"] = "Removed [#cyan]{0}[/#] as [#cyan]{1}[/#]",
                ["Info Message"] = "[#red]FINISHED[/#] - Users need to rejoin for effect",
                ["Adder Message"] = "Added by {0}",
                ["Auth 1"] = "moderator",
                ["Auth 2"] = "owner",
                ["Not SteamId"] = "{0} this is not a valid SteamId.",
                ["Given Auth Level"] = "[#red]You have been given Auth Level {0} automatically, reconnect for it to activate.[/#]",
                ["Console Message"] = "{0} has been given {1} automatically.",
                ["Console Message Removal"] = "{0} has been removed from {1} automatically.",
                ["Log Added"] = "Added {0} to {1}",
                ["Log Removed"] = "Removed {0} from {1}",
                ["Activation Warning"] = "No adding option chosen, users will not be given authlevel automatically. \nEither change settings or use command. (can disable this message in config)",
            }, this);
        }

		#endregion Loading

		#region Functions

        private void AddingAuthCheck()
        {
            if (!delayedAdd && !loadedAdd)
                PrintWarning(Lang("No Activation Warning"));
        }

        private void LoadingAdd()
        {
            if (!loadedAdd)
                return;

            AddAuths(1);
            AddAuths(2);
        }

        private void OnUserConnected(IPlayer player)
        {
            if (player == null || loadedAdd || !delayedAdd)
                return;

            AddAuths(1, null, player, true);
            AddAuths(2, null, player, true);
        }

        [Command("updateauth", "updateauths")]
        private void AuthCommand(IPlayer player, string command, string[] args)
        {
            if (!CanUpdate(player) && !player.IsServer)
            {
                player.Reply(Lang("No Permission", player.Id, command));
                return;
            }

            AddAuths(1, player);
            AddAuths(2, player);

            player.Reply(Lang("Info Message", player.Id));
        }

        void AddAuths(int level, IPlayer adder = null, IPlayer player = null, bool singleAdd = false)
        {
            string lvl = Convert.ToString(level);

            if (singleAdd && player != null)
            {
                if (!AuthList(lvl).Contains(player.Id))
                {
                    if (IsMod(player.Id))
                    {
                        ServerUsers.Set(Convert.ToUInt64(player.Id), ServerUsers.UserGroup.None, null, null);
                        if (logAdding) Log(logFilename, Lang("Log Removed", null, player.Id, Lang("Auth 1")));
                    }

                    if (IsOwner(player.Id))
                    {
                        ServerUsers.Set(Convert.ToUInt64(player.Id), ServerUsers.UserGroup.None, null, null);
                        if (logAdding) Log(logFilename, Lang("Log Removed", null, player.Id, Lang("Auth 2")));
                    }
                    ServerUsers.Save();

                    return;
                }

                if (IsMod(player.Id) || IsOwner(player.Id))
                    return;

                if (level == 1 && !IsMod(player.Id))
                {
                    ServerUsers.Set(Convert.ToUInt64(player.Id), ServerUsers.UserGroup.Moderator, (player != null ? player.Name : string.Empty), (adder != null ? Lang("Adder Message", adder.Id, adder.Name) : string.Empty));

                    if (logAdding) Log(logFilename, Lang("Log Added", null, player.Id, Lang("Auth 1")));
                }

                if (level == 2 || !IsOwner(player.Id))
                {
                    ServerUsers.Set(Convert.ToUInt64(player.Id), ServerUsers.UserGroup.Owner, (player != null ? player.Name : string.Empty), (adder != null ? Lang("Adder Message", adder.Id, adder.Name) : string.Empty));

                    if (logAdding) Log(logFilename, Lang("Log Added", null, player.Id, Lang("Auth 2")));
                }

                ServerUsers.Save();

                if (addingMessage)
                    Puts(Lang($"Console Message", null, player.Id, lvl));

                if (adder != null)
                    adder.Reply(Lang($"Added Message", adder.Id, player.Id, Lang($"Auth {lvl}")));

                if (player != null)
                    timer.Once(5f, () => {
                        player.Reply(Lang($"Given Auth Level", player.Id, lvl));
                    });

                return;
            }

            if (removeUnlisted)
            {
                //int times = Members(1);
                foreach (var member in ServerUsers.GetAll(ServerUsers.UserGroup.Moderator))
                {
                    if (!AuthList("1").Contains(member.steamid.ToString()))
                    {
                        timer.Once(0.01f, () =>
                        {
                            ServerUsers.Set(member.steamid, ServerUsers.UserGroup.None, null, null);
                            ServerUsers.Save();

                            if (logAdding) Log(logFilename, Lang("Log Removed", null, member.steamid.ToString(), Lang("Auth 1")));

                            if (addingMessage)
                                Puts(Lang($"Console Message Removal", null, member.steamid.ToString(), member.group.ToString()));

                            if (adder != null)
                                adder.Reply(Lang($"Removed Message", adder.Id, member.steamid.ToString(), member.group.ToString()));
                        });
                    }
                }

                foreach (var member in ServerUsers.GetAll(ServerUsers.UserGroup.Owner))
                {
                    if (!AuthList("2").Contains(member.steamid.ToString()))
                    {
                        timer.Once(0.01f, () =>
                        {
                            ServerUsers.Set(member.steamid, ServerUsers.UserGroup.None, null, null);
                            ServerUsers.Save();

                            if (logAdding) Log(logFilename, Lang("Log Removed", null, member.steamid.ToString(), Lang("Auth 2")));

                            if (addingMessage)
                                Puts(Lang($"Console Message Removal", null, member.steamid.ToString(), member.group.ToString()));

                            if (adder != null)
                                adder.Reply(Lang($"Removed Message", adder.Id, member.steamid.ToString(), member.group.ToString()));
                        });
                    }
                }
            }

            foreach (string ID in Config["Authentication List", $"Auth Level {lvl}"] as List<object>)
            {
                if (string.IsNullOrEmpty(ID))
                    return;

                if (!ID.IsSteamId())
                {
                    PrintWarning(Lang("Not SteamId", null, ID));
                    return;
                }

                if (level == 1 && AuthList(lvl).Contains(ID) && !IsMod(ID))
                {
                    if (adder != null && !IsMod(ID) || !IsOwner(ID))
                        adder.Reply(Lang($"Added Message", adder.Id, ID, Lang($"Auth {lvl}", adder.Id)));

                    if (addingMessage && !IsMod(ID) || !IsOwner(ID))
                        Puts(Lang($"Console Message", null, ID, lvl));

                    ServerUsers.Set(Convert.ToUInt64(ID), ServerUsers.UserGroup.Moderator, (player != null ? player.Name : string.Empty), (adder != null ? Lang("Adder Message", adder.Id, adder.Name) : string.Empty));

                    if (logAdding) Log(logFilename, Lang("Log Added", null, ID, Lang("Auth 1")));
                }

                if (level == 2 && AuthList(lvl).Contains(ID) && !IsOwner(ID))
                {
                    if (adder != null && !IsMod(ID) || !IsOwner(ID))
                        adder.Reply(Lang($"Added Message", adder.Id, ID, Lang($"Auth {lvl}", adder.Id)));

                    if (addingMessage && !IsMod(ID) || !IsOwner(ID))
                        Puts(Lang($"Console Message", null, ID, lvl));

                    ServerUsers.Set(Convert.ToUInt64(ID), ServerUsers.UserGroup.Owner, (player != null ? player.Name : string.Empty), (adder != null ? Lang("Adder Message", adder.Id, adder.Name) : string.Empty));

                    if (logAdding) Log(logFilename, Lang("Log Added", null, ID, Lang("Auth 2")));
                }

                ServerUsers.Save();
            }
        }

        /*
        int Members(int level)
        {
            int num = 0;
            string ding = null;

            foreach (var member in ServerUsers.GetAll(ServerUsers.UserGroup.Moderator))
                ding = string.Join(" ", member.steamid.ToString());

            num = Convert.ToInt16(ding.LongCount()) / Convert.ToUInt16(AuthList("1").LongCount());

            if (level == 2)
                return Convert.ToInt16(ding.LongCount());

            return num;
        }
        */
        #endregion Functions

        #region Helpers

        private bool CanUpdate(IPlayer player) => player.HasPermission(UpdatePermission);
        bool IsMod(string steamId) => ServerUsers.Is(Convert.ToUInt64(steamId), ServerUsers.UserGroup.Moderator);
        bool IsOwner(string steamId) => ServerUsers.Is(Convert.ToUInt64(steamId), ServerUsers.UserGroup.Owner);
        private string AuthList(string level) => AuthenticationList(Config["Authentication List", $"Auth Level {level}"] as List<object>);
        private string AuthenticationList(List<object> list) => string.Join(" ", list);

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;  
        }

        private bool BoolConfig(string menu, string dataValue, bool defaultValue) => Convert.ToBoolean(GetConfig(menu, dataValue, defaultValue));
        private string StringConfig(string menu, string dataValue, string defaultValue) => Convert.ToString(GetConfig(menu, dataValue, defaultValue));
        private string ListConfig(string menu, string dataValue, List<string> defaultValue) => Convert.ToString(GetConfig(menu, dataValue, defaultValue));

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void Log(string filename, string text) => LogToFile(filename, $"[{DateTime.Now}] {text}", this);

        #endregion Helpers
    }
}

// --- End of file: AngryAuthlevel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-logger ---
// --- Original File Path: A/AdminLogger/AdminLogger.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Facepunch.Extend;
using CompanionServer.Handlers;
using System.Collections;
using UnityEngine.Networking;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Admin Logger", "AK", "2.4.1")]
    [Description("Logs admin commands usage in a file and console.")]
    internal class AdminLogger : CovalencePlugin
    {
        [PluginReference] private Plugin Vanish, AdminRadar, NightVision, ConvertStatus, InventoryViewer, PlayerAdministration, Freeze, Backpacks;

        #region Vars

        private Dictionary<ulong, bool> noclipState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> godmodeState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> spectateState = new Dictionary<ulong, bool>();
        private HashSet<BasePlayer> adminList = new HashSet<BasePlayer>();

        #endregion Vars

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Log to console (true/false)")]
            public bool LogToConsole { get; set; }

            [JsonProperty(PropertyName = "Update frequency (s)")]
            public float UpdateFreq { get; set; }

            [JsonProperty(PropertyName = "Log filename")]
            public string LogFileName { get; set; }

            [JsonProperty(PropertyName = "Enable Discord Messages (true/false)")]
            public bool DiscordLog { get; set; }

            [JsonProperty(PropertyName = "Discord Messages webhook")]
            public string DiscordWebhook { get; set; }

            [JsonProperty(PropertyName = "Exclude List")]
            public List<string> ExcludeList { get; set; }

            [JsonProperty(PropertyName = "Default admin commands")]
            public DefaultCommandsOptions DefaultCommands { get; set; }

            [JsonProperty(PropertyName = "Admin plugins")]
            public PluginsCommandsOptions PluginsCommands { get; set; }

            public class DefaultCommandsOptions
            {
                [JsonProperty(PropertyName = "Admin connections logging (true/false)")]
                public bool ConnectionLog { get; set; }

                [JsonProperty(PropertyName = "Noclip logging (true/false)")]
                public bool NoclipLog { get; set; }

                [JsonProperty(PropertyName = "GodMode logging (true/false)")]
                public bool GodmodeLog { get; set; }

                [JsonProperty(PropertyName = "Spectate logging (true/false)")]
                public bool SpectateLog { get; set; }

                [JsonProperty(PropertyName = "Kill player logging (true/false)")]
                public bool KillPlayerLog { get; set; }

                [JsonProperty(PropertyName = "Admin events logging (true/false)")]
                public bool EventsAllLog { get; set; }

                [JsonProperty(PropertyName = "Admin event commands")]
                public EventsLoggingOptions EventsLogging { get; set; }

                [JsonProperty(PropertyName = "Kick logging (true/false)")]
                public bool KickAllLog { get; set; }

                [JsonProperty(PropertyName = "Kick commands")]
                public KickLoggingOptions KickLogging { get; set; }

                [JsonProperty(PropertyName = "Ban logging (true/false)")]
                public bool BanAllLog { get; set; }

                [JsonProperty(PropertyName = "Ban commands")]
                public BanLoggingOptions BanLogging { get; set; }

                [JsonProperty(PropertyName = "Mute logging (true/false)")]
                public bool MuteAllLog { get; set; }

                [JsonProperty(PropertyName = "Mute commands")]
                public MuteLoggingOptions MuteLogging { get; set; }

                [JsonProperty(PropertyName = "Entity logging (true/false)")]
                public bool EntAllLog { get; set; }

                [JsonProperty(PropertyName = "Entity commands")]
                public EntityLoggingOptions EntityLogging { get; set; }

                [JsonProperty(PropertyName = "Teleport logging (true/false)")]
                public bool TeleportAllLog { get; set; }

                [JsonProperty(PropertyName = "Teleport commands")]
                public TeleportLoggingOptions TeleportLogging { get; set; }

                [JsonProperty(PropertyName = "Give items logging (true/false)")]
                public bool GiveAllLog { get; set; }

                [JsonProperty(PropertyName = "Give commands")]
                public GiveLoggingOptions GiveLogging { get; set; }

                [JsonProperty(PropertyName = "Spawn logging (true/false)")]
                public bool SpawnAllLog { get; set; }

                [JsonProperty(PropertyName = "Spawn commands")]
                public SpawnLoggingOptions SpawnLogging { get; set; }
            }

            public class PluginsCommandsOptions
            {
                [JsonProperty(PropertyName = "Vanish logging (true/false)")]
                public bool VanishLog { get; set; }

                [JsonProperty(PropertyName = "Admin Radar logging (true/false)")]
                public bool RadarLog { get; set; }

                [JsonProperty(PropertyName = "Night Vision logging (true/false)")]
                public bool NightLog { get; set; }

                [JsonProperty(PropertyName = "Convert Status logging (true/false)")]
                public bool ConvertLog { get; set; }

                [JsonProperty(PropertyName = "Inventory Viewer logging (true/false)")]
                public bool InventoryViewerLog { get; set; }

                [JsonProperty(PropertyName = "Backpacks logging (true/false)")]
                public bool BackpacksLog { get; set; }

                [JsonProperty(PropertyName = "Freeze logging (true/false)")]
                public bool FreezeAllLog { get; set; }

                [JsonProperty(PropertyName = "Freeze commands")]
                public FreezeLoggingOptions FreezeLogging { get; set; }

                [JsonProperty(PropertyName = "Player Administration logging (true/false)")]
                public bool PlayerAdministrationAllLog { get; set; }

                [JsonProperty(PropertyName = "Player Administration commands")]
                public PlayerAdministrationLoggingOptions PlayerAdministrationLogging { get; set; }
            }

            public class EventsLoggingOptions
            {
                [JsonProperty(PropertyName = "[Attack Heli] heli.call")]
                public bool HeliCallLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] heli.calltome")]
                public bool HeliCallToMeLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] drop")]
                public bool HeliDropLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.call")]
                public bool AirdropRandomLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.drop")]
                public bool AirdropPosLog { get; set; }
            }

            public class KickLoggingOptions
            {
                [JsonProperty(PropertyName = "kick")]
                public bool KickLog { get; set; }

                [JsonProperty(PropertyName = "kickall")]
                public bool KickEveryoneLog { get; set; }
            }

            public class BanLoggingOptions
            {
                [JsonProperty(PropertyName = "ban")]
                public bool BanLog { get; set; }

                [JsonProperty(PropertyName = "unban")]
                public bool UnbanLog { get; set; }
            }

            public class MuteLoggingOptions
            {
                [JsonProperty(PropertyName = "mute")]
                public bool MuteLog { get; set; }

                [JsonProperty(PropertyName = "unmute")]
                public bool UnmuteLog { get; set; }
            }

            public class EntityLoggingOptions
            {
                [JsonProperty(PropertyName = "ent kill")]
                public bool EntKillLog { get; set; }

                [JsonProperty(PropertyName = "ent who")]
                public bool EntWhoLog { get; set; }

                [JsonProperty(PropertyName = "ent lock")]
                public bool EntLockLog { get; set; }

                [JsonProperty(PropertyName = "ent unlock")]
                public bool EntUnlockLog { get; set; }

                [JsonProperty(PropertyName = "ent auth")]
                public bool EntAuthLog { get; set; }
            }

            public class TeleportLoggingOptions
            {
                [JsonProperty(PropertyName = "teleport")]
                public bool TeleportLog { get; set; }

                [JsonProperty(PropertyName = "teleportpos")]
                public bool TeleportPosLog { get; set; }

                [JsonProperty(PropertyName = "teleport2me")]
                public bool TeleportToMeLog { get; set; }
            }

            public class GiveLoggingOptions
            {
                [JsonProperty(PropertyName = "give")]
                public bool GiveLog { get; set; }

                [JsonProperty(PropertyName = "giveid")]
                public bool GiveIdLog { get; set; }

                [JsonProperty(PropertyName = "givearm")]
                public bool GiveArmLog { get; set; }

                [JsonProperty(PropertyName = "giveto")]
                public bool GiveToLog { get; set; }

                [JsonProperty(PropertyName = "giveall")]
                public bool GiveAllLog { get; set; }
            }

            public class SpawnLoggingOptions
            {
                [JsonProperty(PropertyName = "spawn")]
                public bool SpawnLog { get; set; }

                [JsonProperty(PropertyName = "spawnat")]
                public bool SpawnAtLog { get; set; }

                [JsonProperty(PropertyName = "spawnhere")]
                public bool SpawnHereLog { get; set; }

                [JsonProperty(PropertyName = "spawnitem")]
                public bool SpawnItemLog { get; set; }
            }

            public class FreezeLoggingOptions
            {
                [JsonProperty(PropertyName = "freeze")]
                public bool FreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreeze")]
                public bool UnfreezeLog { get; set; }

                [JsonProperty(PropertyName = "freezeall")]
                public bool AllFreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreezeall")]
                public bool AllUnfreezeLog { get; set; }
            }

            public class PlayerAdministrationLoggingOptions
            {

                [JsonProperty(PropertyName = "OpenPadminCmd")]
                public bool OpenPadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClosePadminCmd")]
                public bool ClosePadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "BanUserCmd")]
                public bool BanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnbanUserCmd")]
                public bool UnbanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KickUserCmd")]
                public bool KickUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "MuteUserCmd")]
                public bool MuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnmuteUserCmd")]
                public bool UnmuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "FreezeCmd")]
                public bool FreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnreezeCmd")]
                public bool UnreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "BackpackViewCmd")]
                public bool BackpackViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "InventoryViewCmd")]
                public bool InventoryViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClearUserInventoryCmd")]
                public bool ClearUserInventoryCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserBPCmd")]
                public bool ResetUserBPCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserMetabolismCmd")]
                public bool ResetUserMetabolismCmdLog { get; set; }

                [JsonProperty(PropertyName = "RecoverUserMetabolismCmd")]
                public bool RecoverUserMetabolismLog { get; set; }

                [JsonProperty(PropertyName = "TeleportToUserCmd")]
                public bool TeleportToUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "TeleportUserCmd")]
                public bool TeleportUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "SpectateUserCmd")]
                public bool SpectateUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "PermsCmd")]
                public bool PermsCmdLog { get; set; }

                [JsonProperty(PropertyName = "HurtUserCmd")]
                public bool HurtUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KillUserCmd")]
                public bool KillUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "HealUserCmd")]
                public bool HealUserCmdLog { get; set; }

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                LogToConsole = true,
                UpdateFreq = 5f,
                LogFileName = "adminlog",
                DiscordLog = true,
                DiscordWebhook = "",
                ExcludeList = new List<string>(){
                    "76561197960279927",
                    "76561197960287930"
                },

                DefaultCommands = new ConfigData.DefaultCommandsOptions
                {
                    ConnectionLog = true,
                    NoclipLog = true,
                    GodmodeLog = true,
                    SpectateLog = true,
                    KillPlayerLog = true,   
                    
                    EventsAllLog = true,
                    EventsLogging = new ConfigData.EventsLoggingOptions
                    {
                        HeliCallLog = true,
                        HeliCallToMeLog = true,
                        HeliDropLog = true,
                        AirdropRandomLog = true,
                        AirdropPosLog = true
                    },

                    KickAllLog = true,
                    KickLogging = new ConfigData.KickLoggingOptions
                    {
                        KickLog = true,
                        KickEveryoneLog = true
                    },

                    BanAllLog = true,
                    BanLogging = new ConfigData.BanLoggingOptions
                    {
                        BanLog = true,                       
                        UnbanLog = true
                    },

                    MuteAllLog = true,
                    MuteLogging = new ConfigData.MuteLoggingOptions
                    {
                        MuteLog = true,
                        UnmuteLog = true
                    },

                    EntAllLog = true,
                    EntityLogging = new ConfigData.EntityLoggingOptions
                    {
                        EntKillLog = true,
                        EntWhoLog = true,
                        EntLockLog = true,
                        EntUnlockLog = true,
                        EntAuthLog = true
                    },

                    TeleportAllLog = true,
                    TeleportLogging = new ConfigData.TeleportLoggingOptions
                    {
                        TeleportLog = true,
                        TeleportPosLog = true,
                        TeleportToMeLog = true

                    },

                    GiveAllLog = true,
                    GiveLogging = new ConfigData.GiveLoggingOptions
                    {
                        GiveLog = true,
                        GiveIdLog = true,
                        GiveArmLog = true,
                        GiveToLog = true,
                        GiveAllLog = true
                    },

                    SpawnAllLog = true,
                    SpawnLogging = new ConfigData.SpawnLoggingOptions
                    {
                        SpawnLog = true,
                        SpawnAtLog = true,
                        SpawnHereLog = true,
                        SpawnItemLog = true
                    }
                },

                PluginsCommands = new ConfigData.PluginsCommandsOptions
                {
                    VanishLog = true,
                    RadarLog = true,
                    NightLog = true,
                    ConvertLog = true,
                    InventoryViewerLog = true,
                    BackpacksLog = true,

                    FreezeAllLog = true,
                    FreezeLogging = new ConfigData.FreezeLoggingOptions
                    {
                        FreezeLog = true,
                        UnfreezeLog = true,
                        AllFreezeLog = true,
                        AllUnfreezeLog = true                       
                    },

                    PlayerAdministrationAllLog = true,
                    PlayerAdministrationLogging = new ConfigData.PlayerAdministrationLoggingOptions
                    {
                        OpenPadminCmdLog = true,
                        ClosePadminCmdLog = true,
                        BanUserCmdLog = true,
                        UnbanUserCmdLog = true,
                        KickUserCmdLog = true,
                        MuteUserCmdLog = true,
                        UnmuteUserCmdLog = true,
                        FreezeCmdLog = true,
                        UnreezeCmdLog = true,
                        BackpackViewCmdLog = true,
                        InventoryViewCmdLog = true,
                        ClearUserInventoryCmdLog = true,
                        ResetUserBPCmdLog = true,
                        ResetUserMetabolismCmdLog = true,
                        RecoverUserMetabolismLog = true,
                        TeleportToUserCmdLog = true,
                        TeleportUserCmdLog = true,
                        SpectateUserCmdLog = true,
                        PermsCmdLog = true,
                        HurtUserCmdLog = true,
                        KillUserCmdLog = true,
                        HealUserCmdLog = true
                    }
                }           
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminConnected"] = "{0} [{1}] connected.",
                ["AdminDisconnected"] = "{0} [{1}] disconnected.",
                ["NoclipEnabled"] = "{0} [{1}] enabled Noclip.",
                ["NoclipDisabled"] = "{0} [{1}] disabled Noclip.",
                ["GodmodeEnabled"] = "{0} [{1}] enabled Godmode.",
                ["GodmodeDisabled"] = "{0} [{1}] disabled Godmode.",
                ["SpectateEnabled"] = "{0} [{1}] enabled Spectate mode.",
                ["SpectateDisabled"] = "{0} [{1}] disabled Spectate mode.",
                ["SpectatePlayer"] = "{0} [{1}] started spectating player {2} [{3}].",
                ["KillPlayer"] = "{0} [{1}] killed {2} [{3}].",
                ["KickPlayer"] = "{0} [{1}] kicked {2} [{3}]. Reason: No reason.",
                ["KickPlayerReason"] = "{0} [{1}] kicked {2} [{3}]. Reason: {4}.",
                ["KickAllPlayers"] = "{0} [{1}] kicked all players.",
                ["BanPlayer"] = "{0} [{1}] banned {2} [{3}]. Reason: No reason.",
                ["BanPlayerReason"] = "{0} [{1}] banned {2} [{3}]. Reason: {4}.",
                ["UnbanPlayer"] = "{0} [{1}] unbanned {2} [{3}].",
                ["MutePlayer"] = "{0} [{1}] muted {2} [{3}].",
                ["UnmutePlayer"] = "{0} [{1}] unmuted {2} [{3}].",
                ["VanishEnabled"] = "{0} [{1}] enabled Vanish.",
                ["VanishDisabled"] = "{0} [{1}] disabled Vanish.",
                ["RadarEnabled"] = "{0} [{1}] enabled AdminRadar.",
                ["RadarDisabled"] = "{0} [{1}] disabled AdminRadar.",
                ["NightVisionEnabled"] = "{0} [{1}] enabled NightVision.",
                ["NightVisionDisabled"] = "{0} [{1}] disabled NightVision.",
                ["ConvertStatusEnabled"] = "{0} [{1}] converted into admin status.",
                ["ConvertStatusDisabled"] = "{0} [{1}] converted out of admin status.",
                ["InventoryView"] = "{0} [{1}] used Inventory Viewer on {2} [{3}].",
                ["TeleportSelfToPlayer"] = "{0} [{1}] teleported to {2} [{3}].",
                ["TeleportPlayerToPlayer"] = "{0} [{1}] teleported {2} [{3}] to {4} [{5}].",
                ["TeleportToSelf"] = "{0} [{1}] teleported {2} [{3}] to self.",
                ["TeleportPosition"] = "{0} [{1}] teleported to coordinates {2}.",
                ["GiveSelf"] = "{0} [{1}] gave themselves {2} x {3}.",
                ["GiveSelfArm"] = "{0} [{1}] added 1 x {2} to their belt.",
                ["GiveTo"] = "{0} [{1}] gave {2} [{3}] {4} x {5}.",
                ["GiveAll"] = "{0} [{1}] gave everyone {2} x {3}.",
                ["EntKillPrefab"] = "{0} [{1}] used *kill* on ent: {2} at position {3}.",
                ["EntKillBaseEntity"] = "{0} [{1}] used *kill* on {2} owned by {3} [{4}] at position {5}.",
                ["EntWhoBaseEntity"] = "{0} [{1}] used *who* on {2} owned by {3} [{4}] at position {5}.",
                ["EntLockBaseEntity"] = "{0} [{1}] used *lock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntUnlockBaseEntity"] = "{0} [{1}] used *unlock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntAuthBaseEntity"] = "{0} [{1}] used *auth* on {2} owned by {3} [{4}] at position {5}.",
                ["Spawn"] = "{0} [{1}] spawned {2} at {3}.",
                ["HeliCall"] = "{0} [{1}] called in Attack Helicopter.",
                ["HeliCallToMe"] = "{0} [{1}] called in Attack Helicopter to themselves at position {2}.",
                ["HeliCallDrop"] = "{0} [{1}] spawned Attack Helicopter at their position {2}.",
                ["AirdropCall"] = "{0} [{1}] called in a Supply Drop.",
                ["AirdropCallPos"] = "{0} [{1}] called in a Supply Drop to position (0, 0, 0).",
                ["PadminOpen"] = "{0} [{1}] opened Padmin Menu.",
                ["PadminClose"] = "{0} [{1}] closed Padmin Menu.",
                ["PadminBan"] = "{0} [{1}] banned {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminUnban"] = "{0} [{1}] unbanned {2} [{3}] using Padmin.",
                ["PadminKick"] = "{0} [{1}] kicked {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminMute"] = "{0} [{1}] muted {2} [{3}] using Padmin.",
                ["PadminUnmute"] = "{0} [{1}] unmuted {2} [{3}] using Padmin.",
                ["PadminFreeze"] = "{0} [{1}] Froze player {2} [{3}] using Padmin.",
                ["PadminUnfreeze"] = "{0} [{1}] Unfroze player {2} [{3}] using Padmin.",
                ["PadminBackpackView"] = "{0} [{1}] viewed Backpack of player {2} [{3}] using Padmin.",
                ["PadminInventoryView"] = "{0} [{1}] viewed Inventory of player {2} [{3}] using Padmin.",
                ["PadminClearInventory"] = "{0} [{1}] cleared the inventory of player {2} [{3}] using Padmin.",
                ["PadminResetBP"] = "{0} [{1}] reset the blueprints of player {2} [{3}] using Padmin.",
                ["PadminResetMetabolism"] = "{0} [{1}] reset the metabolism of player {2} [{3}] using Padmin.",
                ["PadminRecoverMetabolism"] = "{0} [{1}] recovered the metabolism of player {2} [{3}] using Padmin.",
                ["PadminTeleportToPlayer"] = "{0} [{1}] teleported to {2} [{3}] using Padmin.",
                ["PadminTeleportPlayer"] = "{0} [{1}] teleported {2} [{3}] to themselves using Padmin.",
                ["PadminSpectate"] = "{0} [{1}] started spectating player {2} [{3}] using Padmin.",
                ["PadminPerms"] = "{0} [{1}] opened the permissions manager for player {2} [{3}] using Padmin.",
                ["PadminHurt"] = "{0} [{1}] hurt player {2} [{3}] for {4} points using Padmin.",
                ["PadminKill"] = "{0} [{1}] killed player {2} [{3}] using Padmin.",
                ["PadminHeal"] = "{0} [{1}] healed player {2} [{3}] for {4} points using Padmin.",
                ["BackpacksView"] = "{0} [{1}] viewed Backpack of player {2} [{3}].",
                ["FreezePlayer"] = "{0} [{1}] Froze player {2} [{3}].",
                ["UnfreezePlayer"] = "{0} [{1}] Unfroze player {2} [{3}].",
                ["FreezeAllPlayers"] = "{0} [{1}] Froze all players.",
                ["UnfreezeAllPlayers"] = "{0} [{1}] Unfroze all players.",

            }, this);
        }

        #endregion Localization

        #region Oxide Hooks

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            InvokeHandler.Instance.InvokeRepeating(HandlePlayers, 5f, configData.UpdateFreq);
        }

        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(HandlePlayers);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }


            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminConnected", player.displayName, player.UserIDString);
                }

                adminList.Add(player);
                noclipState[player.userID] = false;
                spectateState[player.userID] = false;
                if (player.IsGod())
                {
                    godmodeState[player.userID] = true;
                }
                else
                {
                    godmodeState[player.userID] = false;
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminDisconnected", player.displayName, player.UserIDString);
                }

                adminList.Remove(player);
            }
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsConnectionAdmin) return;
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (fullCommand == "chat.say") return;
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "killplayer":
                    if (configData.DefaultCommands.KillPlayerLog)
                    {
                        KillPlayerLogging(arg);
                    }
                    break;
                case "kick":
                case "kickall":
                    if (configData.DefaultCommands.KickAllLog)
                    {
                        KickLogging(arg);
                    }
                    break;
                case "ban":
                case "unban":
                    if (configData.DefaultCommands.BanAllLog)
                    {
                        BanLogging(arg);
                    }
                    break;
                case "mute": 
                case "unmute":
                    if (configData.DefaultCommands.MuteAllLog)
                    {
                        MuteLogging(arg);
                    }
                    break;
                case "teleport":
                case "teleportpos":
                case "teleport2me":
                    if (configData.DefaultCommands.TeleportAllLog)
                    {
                        TeleportLogging(arg);
                    }
                    break;
                case "spectate":
                    if (configData.DefaultCommands.SpectateLog)
                    {
                        SpectateLogging(arg);
                    }
                    break;
                case "giveid":
                case "give":
                case "givearm":
                case "giveto":
                case "giveall":
                    if (configData.DefaultCommands.GiveAllLog)
                    {
                        GiveItemLogging(arg);
                    }
                    break;
                case "spawn":
                case "spawnat":
                case "spawnhere":
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnAllLog)
                    {
                        SpawnLogging(arg);
                    }
                    break;
                case "entid":
                    if (configData.DefaultCommands.EntAllLog)
                    {
                        EntityLogging(arg);
                    }
                    break;
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(arg);
                    }
                    break;
            }

            switch (fullCommand)
            {
                case "heli.call":
                case "heli.calltome":
                case "global.drop":
                case "drop":
                case "supply.call":
                case "supply.drop":
                    if (configData.DefaultCommands.EventsAllLog)
                    {
                        EventsLogging(arg);
                    }
                    break;
                case "playeradministration.closeui":
                case "playeradministration.kickuser":
                case "playeradministration.banuser":
                case "playeradministration.unbanuser":
                case "playeradministration.perms":
                case "playeradministration.muteuser":
                case "playeradministration.unmuteuser":
                case "playeradministration.tptouser":
                case "playeradministration.tpuser":
                case "playeradministration.viewbackpack":
                case "playeradministration.viewinventory":
                case "playeradministration.freeze":
                case "playeradministration.unfreeze":
                case "playeradministration.clearuserinventory":
                case "playeradministration.resetuserblueprints":
                case "playeradministration.resetusermetabolism":
                case "playeradministration.recoverusermetabolism":
                case "playeradministration.spectateuser":
                case "playeradministration.hurtuser":
                case "playeradministration.killuser":
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded)
                    {
                        PadminLogging(arg);
                    }
                    break;
            }
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "radar":
                    if (configData.PluginsCommands.RadarLog && AdminRadar != null && AdminRadar.IsLoaded && player.IPlayer.HasPermission("adminradar.allowed"))
                    {
                        AdminRadarLogging(player);
                    }
                    break;
                case "nightvision":
                case "nv":
                    if (configData.PluginsCommands.NightLog && NightVision != null && NightVision.IsLoaded && player.IPlayer.HasPermission("nightvision.allowed"))
                    {
                        NightVisionLogging(player);
                    }
                    break;
                case "convert":
                    if (configData.PluginsCommands.ConvertLog && ConvertStatus != null && ConvertStatus.IsLoaded && player.IPlayer.HasPermission("convertstatus.use"))
                    {
                        ConvertStatusLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(player, command, args);
                    }
                    break;
                case "viewinventory":
                case "viewinv":
                    if (configData.PluginsCommands.InventoryViewerLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        InventoryViewerLogging(player, args);
                    }
                    break;
                case "viewbackpack":
                    if (configData.PluginsCommands.BackpacksLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        BackpacksLogging(player, args);
                    }
                    break;
                case "padmin":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        PadminLogging(player);                       
                    }
                    break;
            }
        }

        void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (configData.DefaultCommands.SpectateLog)
            {
                Log(configData.LogFileName, "SpectateDisabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Oxide Hooks

        #region Default Commands

        #region Noclip & Godmode

        private void ClientSideCommandDetection(BasePlayer player)
        {
            if (configData.DefaultCommands.NoclipLog)
            {
                if (player.IsFlying && !noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipEnabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = true;
                }

                if (!player.IsFlying && noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipDisabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = false;
                }
            }

            if (configData.DefaultCommands.GodmodeLog)
            {
                if (player.IsGod() && godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeEnabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = false;
                }

                if (!player.IsGod() && !godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeDisabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = true;
                }
            }
        }

        #endregion Noclip & Godmode

        #region Events

        private void EventsLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            ulong playerUserId = arg.Connection.userid;
            var player = BasePlayer.FindByID(playerUserId);

            if (player == null)
            {
                return;
            }

            switch (fullCommand)
            {
                case "heli.call":
                    if (configData.DefaultCommands.EventsLogging.HeliCallLog)
                    {
                        Log(configData.LogFileName, "HeliCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "heli.calltome":
                    if (configData.DefaultCommands.EventsLogging.HeliCallToMeLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallToMe", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "global.drop":
                    if (configData.DefaultCommands.EventsLogging.HeliDropLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallDrop", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "supply.call":
                    if (configData.DefaultCommands.EventsLogging.AirdropRandomLog)
                    {
                        Log(configData.LogFileName, "AirdropCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "supply.drop":
                    if (configData.DefaultCommands.EventsLogging.AirdropPosLog)
                    {
                        Log(configData.LogFileName, "AirdropCallPos", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Events

        #region Kill Player

        private void KillPlayerLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);

            if (player1 == null) return;

            Log(configData.LogFileName, "KillPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Kill Player

        #region Kick

        private void KickLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.KickLogging.KickEveryoneLog && command == "kickall")
            {
                Log(configData.LogFileName, "KickAllPlayers", player.displayName, player.UserIDString);
            }

            if (configData.DefaultCommands.KickLogging.KickLog && command == "kick")
            {
                if (arg.Args == null || arg.Args.Length == 0) return;

                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;

                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "KickPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "KickPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }
        }

        #endregion Kick

        #region Ban

        private void BanLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.BanLogging.BanLog && command == "ban")
            {
                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "BanPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "BanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }

            if (configData.DefaultCommands.BanLogging.UnbanLog && command == "unban")
            {
                Log(configData.LogFileName, "UnbanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Ban

        #region Mute

        private void MuteLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.MuteLogging.MuteLog && command == "mute")
            {
                Log(configData.LogFileName, "MutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }

            if (configData.DefaultCommands.MuteLogging.UnmuteLog && command == "unmute")
            {
                Log(configData.LogFileName, "UnmutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Mute

        #region Spectate

        private void SpectateLogging(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Log(configData.LogFileName, "SpectateEnabled", player.displayName, player.UserIDString);
            }

            if (arg.Args.Length == 1)
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "SpectatePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Spectate

        #region Teleport

        private void TeleportLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.TeleportLogging.TeleportLog && command == "teleport")
            {
                if (arg.Args.Length == 1)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportSelfToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }

                if (arg.Args.Length == 2)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    var player2 = covalence.Players.FindPlayer(arg.Args[1]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportPlayerToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id, player2.Name, player2.Id);
                }
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportPosLog && command == "teleportpos")
            {
                Log(configData.LogFileName, "TeleportPosition", player.displayName, player.UserIDString, arg.FullString);
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportToMeLog && command == "teleport2me")
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "TeleportToSelf", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Teleport

        #region Give

        private void GiveItemLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;
            if (ItemManager.FindItemDefinition(arg.Args[0].ToInt()) == null) return;
        
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "giveid":
                    if (configData.DefaultCommands.GiveLogging.GiveIdLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                            if (player1 == null) return;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "give":
                    if (configData.DefaultCommands.GiveLogging.GiveLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
                case "givearm":
                    if (configData.DefaultCommands.GiveLogging.GiveArmLog)
                    {
                        var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                        Log(configData.LogFileName, "GiveSelfArm", player.displayName, player.UserIDString, itemShortName);
                    }
                    break;
                case "giveto":
                    if (configData.DefaultCommands.GiveLogging.GiveToLog)
                    {
                        var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                        if (player1 == null) return;

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, "1", itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "giveall":
                    if (configData.DefaultCommands.GiveLogging.GiveAllLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
            }           
        }

        #endregion Give

        #region Spawn

        private void SpawnLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "spawn":
                    if (configData.DefaultCommands.SpawnLogging.SpawnLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnat":
                    if (configData.DefaultCommands.SpawnLogging.SpawnAtLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnhere":
                    if (configData.DefaultCommands.SpawnLogging.SpawnHereLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnLogging.SpawnItemLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
            }
        }

        #endregion Spawn

        #region Ent

        private void EntityLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(Convert.ToUInt64(arg.Args[1])));
            if (entity == null) return;

            if (command != "entid") return;

            switch (arg.Args[0])
            {
                case "kill":
                    if (configData.DefaultCommands.EntityLogging.EntKillLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());

                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntKillBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                            else
                            {
                                Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                            }

                        }
                        else
                        {
                            Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                        }
                    }
                    break;
                case "who":
                    if (configData.DefaultCommands.EntityLogging.EntWhoLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntWhoBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "lock":
                    if (configData.DefaultCommands.EntityLogging.EntLockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntLockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "unlock":
                    if (configData.DefaultCommands.EntityLogging.EntUnlockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntUnlockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "auth":
                    if (configData.DefaultCommands.EntityLogging.EntAuthLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            Log(configData.LogFileName, "EntAuthBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);

                        }
                    }
                    break;
            }           
        }

        #endregion Ent

        #endregion Default Commands

        #region Plugins Commands

        #region Vanish

        private void VanishLogging(BasePlayer player)
        {         
            if (Vanish.Call<bool>("IsInvisible", player))
            {
                Log(configData.LogFileName, "VanishDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "VanishEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Vanish

        #region AdminRadar

        private void AdminRadarLogging(BasePlayer player)
        {
            if (AdminRadar.Call<bool>("IsRadar", player.UserIDString))
            {
                Log(configData.LogFileName, "RadarDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "RadarEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion AdminRadar

        #region NightVision

        private void NightVisionLogging(BasePlayer player)
        {
            if (NightVision.Call<bool>("IsPlayerTimeLocked", player))
            {
                Log(configData.LogFileName, "NightVisionDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "NightVisionEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion NightVision

        #region ConvertStatus

        private void ConvertStatusLogging(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                Log(configData.LogFileName, "ConvertStatusDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "ConvertStatusEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion ConvertStatus

        #region Freeze

        private void FreezeLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        private void FreezeLogging(BasePlayer player, string command, string[] args)
        {
            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Freeze

        #region InventoryViewer

        private void InventoryViewerLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "InventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Backpacks

        private void BackpacksLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "BackpacksView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Padmin

        private void PadminLogging(BasePlayer player)
        {
            if (!configData.PluginsCommands.PlayerAdministrationLogging.OpenPadminCmdLog) return;
            Log(configData.LogFileName, "PadminOpen", player.displayName, player.UserIDString);
        }

        private void PadminLogging(ConsoleSystem.Arg arg)
        {
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (fullCommand)
            {
                case "playeradministration.closeui":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClosePadminCmdLog && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        Log(configData.LogFileName, "PadminClose", player.displayName, player.UserIDString);
                    }
                    break;
                case "playeradministration.kickuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KickUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kick"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKick", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.banuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBan", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unbanuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnbanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnban", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.muteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.MuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminMute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unmuteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnmuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnmute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.freeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.FreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminFreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unfreeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnfreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewbackpack":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BackpackViewCmdLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBackpackView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.InventoryViewCmdLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminInventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.clearuserinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClearUserInventoryCmdLog && player.IPlayer.HasPermission("playeradministration.access.clearinventory"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminClearInventory", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetuserblueprints":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserBPCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetblueprint"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetBP", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserMetabolismCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetmetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.recoverusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.RecoverUserMetabolismLog && player.IPlayer.HasPermission("playeradministration.access.recovermetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminRecoverMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tptouser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportToUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tpuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.spectateuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.SpectateUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.spectate"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminSpectate", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.perms":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.PermsCmdLog && player.IPlayer.HasPermission("playeradministration.access.perms"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminPerms", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.hurtuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HurtUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.hurt"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHurt", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;
                case "playeradministration.killuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KillUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kill"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKill", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HealUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.heal"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHeal", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;

            }
        }

        #endregion Padmin

        #endregion Plugins Commands

        #region Helpers

        private void HandlePlayers()
        {
            foreach (var player in adminList)
            {
                ClientSideCommandDetection(player);
            }
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (configData.LogToConsole)
            {
                Puts($"[{DateTime.Now}] {Lang(key, null, args)}");
            }

            if (configData.DiscordLog)
            {
                DiscordPost($"[{DateTime.Now}] {Lang(key, null, args)}");
            }           

            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private string Lang(string key, string id = null, params object[] args)
        {           
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void DiscordPost(string message)
        {
            var payload = new
            {
                content = message
            };

            var form = new WWWForm();
            form.AddField("payload_json", JsonConvert.SerializeObject(payload));

            InvokeHandler.Instance.StartCoroutine(HandleUpload(configData.DiscordWebhook, form));
        }

        private IEnumerator HandleUpload(string url, WWWForm data)
        {
            var www = UnityWebRequest.Post(url, data);
            yield return www.SendWebRequest();

            if (www.isNetworkError || www.isHttpError)
            {
                Puts($"Failed to post Discord webhook message: {www.error}");
            }
        }

        #endregion Helpers

    }
}

// --- End of file: AdminLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/always-lootable-turrets ---
// --- Original File Path: A/AlwaysLootableTurrets/AlwaysLootableTurrets.cs ---

﻿using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Always Lootable Turrets", "WhiteThunder", "1.0.1")]
    [Description("Allows players to loot auto turrets while powered.")]
    internal class AlwaysLootableTurrets : CovalencePlugin
    {
        #region Fields

        private const string PermissionOwner = "alwayslootableturrets.owner";

        private const string PrefabCodeLockDeniedEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

        private Configuration _pluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionOwner, this);
        }

        private object CanLootEntity(BasePlayer player, AutoTurret turret)
        {
            if (!turret.IsOnline() || turret.IsAuthed(player))
                return null;

            Effect.server.Run(PrefabCodeLockDeniedEffect, turret.transform.position);
            return false;
        }

        private void OnEntitySaved(AutoTurret turret, BaseNetworkable.SaveInfo saveInfo)
        {
            if (turret.IsOnline() && IsTurretEligible(turret) && TurretHasPermission(turret))
                saveInfo.msg.baseEntity.flags = RemoveOnFlag(saveInfo.msg.baseEntity.flags);
        }

        private object OnEntityFlagsNetworkUpdate(AutoTurret turret)
        {
            if (turret.IsOnline() && IsTurretEligible(turret) && TurretHasPermission(turret))
            {
                SendFlagUpdate(turret);
                return true;
            }

            return null;
        }

        #endregion

        #region Helper Methods

        private bool IsTurretEligible(AutoTurret turret)
        {
            return !(turret is NPCAutoTurret);
        }

        private bool TurretHasPermission(AutoTurret turret)
        {
            if (!_pluginConfig.RequireOwnerPermission)
                return true;

            if (turret.OwnerID == 0)
                return false;

            return permission.UserHasPermission(turret.OwnerID.ToString(), PermissionOwner);
        }

        private void SendFlagUpdate(AutoTurret turret)
        {
            List<Connection> subscribers = turret.GetSubscribers();
            if (subscribers != null && subscribers.Count > 0)
            {
                var write = Net.sv.StartWrite();
                write.PacketID(Message.Type.EntityFlags);
                write.EntityID(turret.net.ID);
                write.Int32(RemoveOnFlag((int)turret.flags));
                write.Send(new SendInfo(subscribers));
            }
            turret.gameObject.SendOnSendNetworkUpdate(turret);
        }

        private int RemoveOnFlag(int flags)
        {
            return flags & ~(int)BaseEntity.Flags.On;
        }

        #endregion

        #region Configuration

        internal class Configuration : SerializableConfiguration
        {
            [JsonProperty("RequireOwnerPermission")]
            public bool RequireOwnerPermission = false;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: AlwaysLootableTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-trash-talk ---
// --- Original File Path: A/AntiTrashTalk/AntiTrashTalk.cs ---

﻿using System;
using System.Collections.Generic;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Anti Trash-Talk", "0x89A", "1.0.0")]
    [Description("Mutes players after they kill or are killed by another player")]
    class AntiTrashTalk : RustPlugin
    {
        private Configuration config;
        private Dictionary<ulong, float> lastKillOrDeathTime = new Dictionary<ulong, float>();
        private Dictionary<ulong, float> lastVoiceMessageTime = new Dictionary<ulong, float>();

        private const string exemptionPerm = "antitrashtalk.bypass";

        #region -Oxide Hooks-

        private void Init() => permission.RegisterPermission(exemptionPerm, this);

        private void OnPlayerDeath(BasePlayer player, HitInfo info) => DoBlock(player, info);

        private void OnPlayerWound(BasePlayer player, HitInfo info) => DoBlock(player, info);

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel) => CanSpeak(player);

        private object OnPlayerVoice(BasePlayer player, Byte[] data) => CanSpeak(player, true);

        #endregion

        #region -Helpers-

        private object CanSpeak(BasePlayer player, bool isVoice = false)
        {
            float value;
            if (lastKillOrDeathTime.TryGetValue(player.userID, out value) && Time.time - value < config.blockDuration)
            {
                if (isVoice)
                {
                    float lastTime;
                    if (lastVoiceMessageTime.TryGetValue(player.userID, out lastTime) && Time.time - lastTime < 3f) return true;
                    else if (!lastVoiceMessageTime.ContainsKey(player.userID)) lastVoiceMessageTime.Add(player.userID, Time.time);

                    lastVoiceMessageTime[player.userID] = Time.time;
                }
                
                player.ChatMessage(string.Format(lang.GetMessage("CannotSpeak", this, player.UserIDString), Mathf.Round(config.blockDuration - (Time.time - value))));

                return true;
            }
            
            return null;
        }

        private void DoBlock(BasePlayer victim, HitInfo info)
        {
            BasePlayer other = info?.InitiatorPlayer;
            if (other == null || (config.blockSelfInflicted && victim == other)) return;

            if (config.blockForVictim) BlockChat(victim);
            BlockChat(other);
        }

        private void BlockChat(BasePlayer player)
        {
            if (player == null || permission.UserHasPermission(player.UserIDString, exemptionPerm)) return;

            if (lastKillOrDeathTime.ContainsKey(player.userID)) lastKillOrDeathTime[player.userID] = Time.time;
            else lastKillOrDeathTime.Add(player.userID, Time.time);
        }

        #endregion

        #region -Configuration-

        private class Configuration
        {
            [JsonProperty("Block duration (seconds)")]
            public float blockDuration = 30f;

            [JsonProperty("Block for dead/wounded player")]
            public bool blockForVictim = false;

            [JsonProperty("Block when self inflicted")]
            public bool blockSelfInflicted = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region -Localisation-

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CannotSpeak"] = "You cannot speak right now, please wait {0} more seconds"
            }, this);
        }

        #endregion
    }
}


// --- End of file: AntiTrashTalk.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/automated-stash-traps ---
// --- Original File Path: A/AutomatedStashTraps/AutomatedStashTraps.cs ---

using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using Rust;
using Rust.Workshop;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Automated Stash Traps", "Dana", "1.5.4")]
    [Description("Spawns fully automated stash traps across the map to catch ESP cheaters.")]
    public class AutomatedStashTraps : RustPlugin
    {
        #region Dependencies

        [PluginReference]
        private readonly Plugin Clans;

        #endregion Dependencies

        #region Fields

        private static AutomatedStashTraps _instance;
        private static Configuration _config;
        private static Data _data;

        private SpawnPointManager _spawnPointManager;
        private DiscordWebhook _webhook;
        private SkinManager _skinManager;

        private Coroutine _spawnCoroutine;

        private List<BasePlayer> _manualTrapDeployers = new List<BasePlayer>();
        private HashSet<ulong> _revealedOwnedStashes = new HashSet<ulong>();
        private Dictionary<BasePlayer, StorageContainer> _activeLootEditors = new Dictionary<BasePlayer, StorageContainer>();

        private Timer _reportScheduler;
        private Queue<DiscordWebhook.Message> _queuedDiscordReports = new Queue<DiscordWebhook.Message>();

        private const string BLUEPRINT_TEMPLATE = "blueprintbase";
        private const string STASH_PREFAB = "assets/prefabs/deployable/small stash/small_stash_deployed.prefab";
        private const string STORAGE_PREFAB = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";
        private const string SLEEPING_BAG_PREFAB = "assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab";

        private Vector3 _lastRevealedStashPosition;

        #endregion Fields

        #region Configuration

        private class Configuration
        {
            [JsonProperty("Version")]
            public string Version { get; set; }

            [JsonProperty("Spawn Point")]
            public SpawnPointConfig SpawnPoint { get; set; }

            [JsonProperty("Automated Trap")]
            public AutomatedTrapConfig AutomatedTrap { get; set; }

            [JsonProperty("Violation")]
            public ViolationConfig Violation { get; set; }

            [JsonProperty("Moderation")]
            public ModerationConfig Moderation { get; set; }

            [JsonProperty("Notification")]
            public NotificationConfig Notification { get; set; }

            [JsonProperty("Discord")]
            public DiscordConfig Discord { get; set; }

            [JsonProperty("Stash Loot")]
            public StashLootConfig StashLoot { get; set; }
        }

        private class SpawnPointConfig
        {
            [JsonProperty("Maximum Attempts To Find Spawn Points")]
            public int MaximumAttemptsToFindSpawnPoints { get; set; }

            [JsonProperty("Safe Area Radius")]
            public float SafeAreaRadius { get; set; }

            [JsonProperty("Entity Detection Radius")]
            public float EntityDetectionRadius { get; set; }

            [JsonProperty("Player Detection Radius")]
            public float PlayerDetectionRadius { get; set; }
        }

        private class AutomatedTrapConfig
        {
            [JsonProperty("Maximum Traps To Spawn")]
            public int MaximumTrapsToSpawn { get; set; }

            [JsonProperty("Destroy Revealed Trap After Minutes")]
            public int DestroyRevealedTrapAfterMinutes { get; set; }

            [JsonProperty("Replace Revealed Trap")]
            public bool ReplaceRevealedTrap { get; set; }

            [JsonProperty("Dummy Sleeping Bag")]
            public DummySleepingBagConfig DummySleepingBag { get; set; }
        }

        private class DummySleepingBagConfig
        {
            [JsonProperty("Spawn Along")]
            public bool SpawnAlong { get; set; }

            [JsonProperty("Spawn Proximity To Stash")]
            public float SpawnProximityToStash { get; set; }

            [JsonProperty("Spawn Chance")]
            public int SpawnChance { get; set; }

            [JsonProperty("Randomized Skin Chance")]
            public int RandomizedSkinChance { get; set; }

            [JsonProperty("Randomized Nice Name Chance")]
            public int RandomizedNiceNameChance { get; set; }
        }

        private class ViolationConfig
        {
            [JsonProperty("Reset On Wipe")]
            public bool ResetOnWipe { get; set; }

            [JsonProperty("Can Teammate Ignore")]
            public bool CanTeammateIgnore { get; set; }

            [JsonProperty("Can Clanmate Ignore")]
            public bool CanClanmateIgnore { get; set; }
        }

        private class ModerationConfig
        {
            [JsonProperty("Automatic Ban")]
            public bool AutomaticBan { get; set; }

            [JsonProperty("Violations Tolerance")]
            public int ViolationsTolerance { get; set; }

            [JsonProperty("Ban Delay Seconds")]
            public int BanDelaySeconds { get; set; }

            [JsonProperty("Ban Reason")]
            public string BanReason { get; set; }
        }

        private class NotificationConfig
        {
            [JsonProperty("Prefix")]
            public string Prefix { get; set; }

            [JsonProperty("Enable Console Report")]
            public bool EnableConsoleReport { get; set; }

            [JsonProperty("Stash Report Filter")]
            public int StashReportFilter { get; set; }
        }

        private class DiscordConfig
        {
            [JsonProperty("Post Into Discord")]
            public bool PostIntoDiscord { get; set; }

            [JsonProperty("Webhook Url")]
            public string WebhookUrl { get; set; }

            [JsonProperty("Report Interval")]
            public float ReportInterval { get; set; }

            [JsonProperty("Message")]
            public string Message { get; set; }

            [JsonProperty("Embed Color")]
            public string EmbedColor { get; set; }

            [JsonProperty("Embed Title")]
            public string EmbedTitle { get; set; }

            [JsonProperty("Embed Footer")]
            public string EmbedFooter { get; set; }

            [JsonProperty("Embed Fields")]
            public List<DiscordWebhook.EmbedField> EmbedFields { get; set; }

            [JsonIgnore]
            private int color;

            [JsonIgnore]
            private bool colorIsValidated;

            public int GetColor()
            {
                if (!colorIsValidated)
                {
                    if (!int.TryParse(EmbedColor.TrimStart('#'), NumberStyles.HexNumber, null, out color))
                        color = 16777215;

                    colorIsValidated = true;
                }
                return color;
            }
        }

        private class StashLootConfig
        {
            [JsonProperty("Minimum Loot Spawn Slots")]
            public int MinimumLootSpawnSlots { get; set; }

            [JsonProperty("Maximum Loot Spawn Slots")]
            public int MaximumLootSpawnSlots { get; set; }

            [JsonProperty("Spawn Chance As Blueprint")]
            public int SpawnChanceAsBlueprint { get; set; }

            [JsonProperty("Spawn Chance With Skin")]
            public int SpawnChanceWithSkin { get; set; }

            [JsonProperty("Spawn Chance As Damaged")]
            public int SpawnChanceAsDamaged { get; set; }

            [JsonProperty("Minimum Condition Loss")]
            public float MinimumConditionLoss { get; set; }

            [JsonProperty("Maximum Condition Loss")]
            public float MaximumConditionLoss { get; set; }

            [JsonProperty("Spawn Chance As Repaired")]
            public int SpawnChanceAsRepaired { get; set; }

            [JsonProperty("Spawn Chance As Broken")]
            public int SpawnChanceAsBroken { get; set; }

            [JsonProperty("Loot Table")]
            public List<ItemInfo> LootTable { get; set; }
        }

        private class ItemInfo
        {
            [JsonProperty("Short Name")]
            public string ShortName { get; set; }

            [JsonProperty("Minimum Spawn Amount")]
            public int MinimumSpawnAmount { get; set; }

            [JsonProperty("Maximum Spawn Amount")]
            public int MaximumSpawnAmount { get; set; }

            [JsonIgnore]
            private ItemDefinition itemDefinition;

            [JsonIgnore]
            private bool itemIsValidated;

            // Inspired by WhiteThunder.
            /// <summary>
            /// Returns the item definition associated with this item.
            /// </summary>
            /// <returns> The item definition, or null if the item is not valid. </returns>
            public ItemDefinition GetItemDefinition()
            {
                if (!itemIsValidated)
                {
                    ItemDefinition lookupResult = ItemManager.FindItemDefinition(ShortName);
                    if (lookupResult != null)
                        itemDefinition = lookupResult;
                    else
                        return null;

                    itemIsValidated = true;
                }

                return itemDefinition;
            }

            /// <summary>
            /// Determines whether the item can be researched.
            /// </summary>
            /// <returns> True if the item can be researched, false otherwise. </returns>
            public bool CanBeResearched()
            {
                return itemDefinition.Blueprint == null || !itemDefinition.Blueprint.isResearchable ? false : true;
            }

            /// <summary>
            /// Determines whether the item has skins.
            /// </summary>
            /// <returns> True if the item can be skinned, false otherwise. </returns>
            public bool CanBeSkinned()
            {
                return !itemDefinition.HasSkins ? false : true;
            }

            /// <summary>
            /// Determines whether the item can be repaired.
            /// </summary>
            /// <returns> True if the item can be repaired, false otherwise. </returns>
            public bool CanBeRepaired()
            {
                return !itemDefinition.condition.repairable ? false : true; // !item.hasCondition
            }
        }

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                Version = Version.ToString(),

                SpawnPoint = new SpawnPointConfig
                {
                    MaximumAttemptsToFindSpawnPoints = 1500,
                    SafeAreaRadius = 3f,
                    EntityDetectionRadius = 25f,
                    PlayerDetectionRadius = 25f
                },

                AutomatedTrap = new AutomatedTrapConfig
                {
                    MaximumTrapsToSpawn = 50,
                    DestroyRevealedTrapAfterMinutes = 2,
                    ReplaceRevealedTrap = true,
                    DummySleepingBag = new DummySleepingBagConfig
                    {
                        SpawnAlong = false,
                        SpawnProximityToStash = 0.90f,
                        SpawnChance = 50,
                        RandomizedSkinChance = 40,
                        RandomizedNiceNameChance = 60
                    }
                },

                Violation = new ViolationConfig
                {
                    ResetOnWipe = true,
                    CanTeammateIgnore = false,
                    CanClanmateIgnore = false
                },

                Moderation = new ModerationConfig
                {
                    AutomaticBan = false,
                    ViolationsTolerance = 3,
                    BanDelaySeconds = 60,
                    BanReason = "Cheat Detected!"
                },

                Notification = new NotificationConfig
                {
                    Prefix = "<color=#F2C94C>Automated Stash Trap</color>:",
                    EnableConsoleReport = true,
                    StashReportFilter = 2
                },

                Discord = new DiscordConfig
                {
                    PostIntoDiscord = false,
                    WebhookUrl = string.Empty,
                    ReportInterval = 60f,
                    Message = "Cheater, cheater, pumpkin eater! Looks like someone's been caught breaking the rules!",
                    EmbedTitle = "A cheater has been spotted",
                    EmbedColor = "#FFFFFF",
                    EmbedFooter = string.Empty,
                    EmbedFields = new List<DiscordWebhook.EmbedField>()
                    {
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Player Name",
                            Value = "$Player.Name",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Id",
                            Value = "$Player.Id",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Violations Count",
                            Value = "$Player.Violations",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Revealed Stash Type",
                            Value = "$Stash.Type",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Stash Id",
                            Value = "$Stash.Id",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Grid",
                            Value = "$Stash.Position.Grid",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Reveal Method",
                            Value = "$Stash.Reveal.Method",
                            Inline = false
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Stash Owner Name",
                            Value = "$Stash.Owner.Name",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Stash Owner Id",
                            Value = "$Stash.Owner.Id",
                            Inline = true
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Team Info",
                            Value = "$Player.Team",
                            Inline = false
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Player Connection Time",
                            Value = "$Player.Connection.Time",
                            Inline = false
                        },
                        new DiscordWebhook.EmbedField
                        {
                            Name = "Server",
                            Value = "$Server.Name $Server.Address",
                            Inline = false
                        },
                    }
                },

                StashLoot = new StashLootConfig
                {
                    MinimumLootSpawnSlots = 1,
                    MaximumLootSpawnSlots = 6,
                    SpawnChanceAsBlueprint = 10,
                    SpawnChanceWithSkin = 50,
                    SpawnChanceAsDamaged = 30,
                    MinimumConditionLoss = 5f,
                    MaximumConditionLoss = 95f,
                    SpawnChanceAsRepaired = 15,
                    SpawnChanceAsBroken = 5,
                    LootTable = new List<ItemInfo>()
                    {
                        new ItemInfo
                        {
                            ShortName = "scrap",
                            MinimumSpawnAmount = 25,
                            MaximumSpawnAmount = 125,
                        },
                        new ItemInfo
                        {
                            ShortName = "metal.refined",
                            MinimumSpawnAmount = 15,
                            MaximumSpawnAmount = 40,
                        },
                        new ItemInfo
                        {
                            ShortName = "cloth",
                            MinimumSpawnAmount = 60,
                            MaximumSpawnAmount = 200,
                        },
                       new ItemInfo
                        {
                            ShortName = "cctv.camera",
                            MinimumSpawnAmount = 1,
                            MaximumSpawnAmount = 2,
                        },
                        new ItemInfo
                        {
                            ShortName = "riflebody",
                            MinimumSpawnAmount = 1,
                            MaximumSpawnAmount = 3,
                        },
                        new ItemInfo
                        {
                            ShortName = "techparts",
                            MinimumSpawnAmount = 1,
                            MaximumSpawnAmount = 6,
                        }
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();

            if (string.Compare(_config.Version, Version.ToString()) < 0)
                UpdateConfig();

            ValidateConfigValues();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config, true);
        }

        private void UpdateConfig()
        {
            PrintWarning("Detected changes in configuration! Updating...");

            Configuration defaultConfig = GetDefaultConfig();

            if (string.Compare(_config.Version, "1.0.0") < 0)
                _config = defaultConfig;

            if (string.Compare(_config.Version, "1.1.0") < 0)
            {
                _config.Violation = defaultConfig.Violation;
                _config.Moderation = defaultConfig.Moderation;
            }

            if (string.Compare(_config.Version, "1.3.0") < 0)
            {
                _config.Discord.ReportInterval = defaultConfig.Discord.ReportInterval;
            }

            if (string.Compare(_config.Version, "1.4.0") < 0)
            {
                _config.Notification = defaultConfig.Notification;
                _config.AutomatedTrap.DummySleepingBag.SpawnProximityToStash = defaultConfig.AutomatedTrap.DummySleepingBag.SpawnProximityToStash;
            }

            if (string.Compare(_config.Version, "1.5.0") < 0)
            {
                _config.Notification.StashReportFilter = defaultConfig.Notification.StashReportFilter;
            }

            PrintWarning("Configuration update complete! Updated from version " + _config.Version + " to " + Version.ToString());
            _config.Version = Version.ToString();
        }

        private void ValidateConfigValues()
        {
            PrintWarning("Validating configuration values...");

            if (_config.AutomatedTrap.DestroyRevealedTrapAfterMinutes <= 0)
            {
                PrintError("Invalid trap removal time value. To avoid potential entity leaks, this value must be greater than 0. Default value of 5 will be applied.");
                _config.AutomatedTrap.DestroyRevealedTrapAfterMinutes = 5;
            }

            if (_config.AutomatedTrap.DummySleepingBag.SpawnProximityToStash <= 0.0f || _config.AutomatedTrap.DummySleepingBag.SpawnProximityToStash > 1.0f)
            {
                PrintError("Invalid sleeping bag spawn proximity. The value must be greater than 0.0 and less than or equal to 1.0. Default value of 0.9 will be applied.");
                _config.AutomatedTrap.DummySleepingBag.SpawnProximityToStash = 0.90f;
            }

            if (_config.Notification.StashReportFilter < 0 || _config.Notification.StashReportFilter > 2)
            {
                PrintError("Invalid stash report filter value. The value must be 0, 1, or 2. Default value of 2 will be applied.");
                _config.Notification.StashReportFilter = 2;
            }

            if (_config.Discord.PostIntoDiscord)
            {
                if (string.IsNullOrWhiteSpace(_config.Discord.WebhookUrl))
                {
                    PrintError("Invalid webhook url provided. Please provide a valid webhook url to post into Discord.");
                    _config.Discord.PostIntoDiscord = false;
                }

                if (string.IsNullOrWhiteSpace(_config.Discord.EmbedColor) || !_config.Discord.EmbedColor.StartsWith("#"))
                {
                    PrintError("Invalid color provided. The color must be a valid hex color code. Default color of #FFFFFF will be applied.");
                    _config.Discord.EmbedColor = "#FFFFFF";
                }
            }

            if (_config.StashLoot.MinimumLootSpawnSlots < 1)
            {
                PrintError("Invalid minimum loot spawn slots value. Default value of 1 will be applied.");
                _config.StashLoot.MinimumLootSpawnSlots = 1;
            }

            if (_config.StashLoot.MaximumLootSpawnSlots > 6)
            {
                PrintError("Invalid maximum loot spawn slots value. Default value of 6 will be applied.");
                _config.StashLoot.MaximumLootSpawnSlots = 6;
            }

            List<ItemInfo> invalidItems = _config.StashLoot.LootTable.Where(item => item.GetItemDefinition() == null).ToList();
            foreach (ItemInfo invalidItem in invalidItems)
            {
                _config.StashLoot.LootTable.Remove(invalidItem);
                PrintError("Invalid item '" + invalidItem.ShortName + "' removed from the loot table.");
            }

            foreach (ItemInfo item in _config.StashLoot.LootTable)
            {
                if (item.MinimumSpawnAmount <= 0)
                {
                    PrintError("Invalid minimum spawn amount for item '" + item.ShortName + "'. Default value of 1 will be applied.");
                    item.MinimumSpawnAmount = 1;
                }

                if (item.MaximumSpawnAmount < item.MinimumSpawnAmount)
                {
                    PrintError("Invalid maximum spawn amount for item '" + item.ShortName + "'. Default value of " + item.MinimumSpawnAmount + " will be applied.");
                    item.MaximumSpawnAmount = item.MinimumSpawnAmount;
                }
            }

            PrintWarning("Configuration validation complete!");
        }

        #endregion

        #region Data

        private class Data
        {
            [JsonProperty("Violations")]
            public Dictionary<ulong, int> Violations { get; set; } = new Dictionary<ulong, int>();

            [JsonProperty("Automated Traps")]
            public Dictionary<ulong, AutomatedTrapData> AutomatedTraps { get; set; } = new Dictionary<ulong, AutomatedTrapData>();

            public static Data Load()
            {
                return Interface.Oxide.DataFileSystem.ReadObject<Data>(_instance.Name) ?? new Data();
            }

            public Data Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(_instance.Name, this);
                return this;
            }

            public static Data Clear()
            {
                return new Data().Save();
            }

            public void RemovePlayerData(BasePlayer player)
            {
                if (Violations.ContainsKey(player.userID))
                    Violations.Remove(player.userID);
            }

            public void CreateOrUpdatePlayerData(BasePlayer player)
            {
                int revealedTraps;

                Violations.TryGetValue(player.userID, out revealedTraps);
                Violations[player.userID] = revealedTraps + 1;
            }

            public int GetPlayerRevealedTrapsCount(BasePlayer player)
            {
                int revealedTraps;
                return Violations.TryGetValue(player.userID, out revealedTraps) ? revealedTraps : 0;
            }

            public void CreateTrapData(StashContainer stash, SleepingBag sleepingBag = null)
            {
                AutomatedTraps[stash.net.ID.Value] = new AutomatedTrapData
                {
                    DummyStash = new DummyStashData
                    {
                        Hidden = true,
                        Id = stash.net.ID.Value,
                        Position = stash.ServerPosition
                    }
                };

                if (sleepingBag != null)
                    AutomatedTraps[stash.net.ID.Value].DummySleepingBag = new DummySleepingBagData
                    {
                        Id = sleepingBag.net.ID.Value,
                        NiceName = sleepingBag.niceName,
                        SkinId = sleepingBag.skinID,
                        Position = sleepingBag.ServerPosition
                    };
            }

            public AutomatedTrapData GetTrapData(ulong trapId)
            {
                AutomatedTrapData trapData;
                return AutomatedTraps.TryGetValue(trapId, out trapData) ? trapData : null;
            }

            public void UpdateTrapData(AutomatedTrapData trap)
            {
                trap.DummyStash.Hidden = false;
            }
        }

        private class AutomatedTrapData
        {
            [JsonProperty("Dummy Stash")]
            public DummyStashData DummyStash { get; set; }

            [JsonProperty("Dummy Sleeping Bag")]
            public DummySleepingBagData DummySleepingBag { get; set; }
        }

        private class DummyStashData
        {
            [JsonProperty("Hidden")]
            public bool Hidden { get; set; }

            [JsonProperty("Id")]
            public ulong Id { get; set; }

            [JsonProperty("Position")]
            public Vector3 Position { get; set; }
        }

        private class DummySleepingBagData
        {
            [JsonProperty("Id")]
            public ulong Id { get; set; }

            [JsonProperty("Nice Name")]
            public string NiceName { get; set; }

            [JsonProperty("Skin Id")]
            public ulong SkinId { get; set; }

            [JsonProperty("Position")]
            public Vector3 Position { get; set; }
        }

        #endregion

        #region Oxide Hooks

        /// <summary>
        /// Hook: Called when a plugin is being initialized.
        /// </summary>
        private void Init()
        {
            _instance = this;
            _skinManager = new SkinManager();
            _webhook = new DiscordWebhook();
            _spawnPointManager = new SpawnPointManager();

            _data = Data.Load();
            PermissionUtils.Register();
        }

        /// <summary>
        /// Hook: Called after server startup is complete and awaits connections or when a plugin is hotloaded while the server is running.
        /// </summary>
        private void OnServerInitialized()
        {
            StartSpawnCoroutine();
        }

        /// <summary>
        /// Hook: Called when a plugin is being unloaded.
        /// </summary>
        private void Unload()
        {
            CleanupTraps();
            StopSpawnCoroutine();
            _spawnPointManager.ClearAvailableSpawnPoints();

            _lastRevealedStashPosition = Vector3.zero;
            _reportScheduler?.Destroy();

            _instance = null;
            _config = null;
            _data = null;
        }

        /// <summary>
        /// Hook: Called when a new save file is created.
        /// </summary>
        private void OnNewSave()
        {
            if (_config.Violation.ResetOnWipe)
                Data.Clear();
        }

        /// <summary>
        /// Hook: Called when any entity is built or deployed.
        /// </summary>
        /// <param name="planner"> The building planner held by the player. </param>
        /// <param name="gameObject"> Contains information about the built entity. </param>
        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            StashContainer stash = gameObject?.ToBaseEntity() as StashContainer;
            if (!stash)
                return;

            BasePlayer deployingPlayer = planner?.GetOwnerPlayer();
            if (!deployingPlayer)
                return;

            if (!_manualTrapDeployers.Contains(deployingPlayer))
                return;

            PopulateLoot(stash);
            stash.SetHidden(true);
            _manualTrapDeployers.Remove(deployingPlayer);

            ReplyToPlayer(deployingPlayer, GetLang(Lang.TRAP_SETUP, deployingPlayer.UserIDString));

            Draw.Sphere(deployingPlayer, 60f, ParseColor("#BDBDBD", Color.white), stash.transform.position, 0.5f);
            Draw.Text(deployingPlayer, 60f, ParseColor("#F2C94C", Color.white), stash.transform.position + new Vector3(0, 0.7f, 0), $"<size=30>{stash.net.ID}</size>");
        }

        /// <summary>
        /// Hook: Called when the player stops looting.
        /// </summary>
        /// <param name="inventory"> The inventory that the player was looting. </param>
        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            CloseLootEditor(inventory);
        }

        /// <summary>
        /// Hook: Called when an entity is destroyed.
        /// </summary>
        /// <param name="stash"> The stash container that has been destroyed. </param>
        private void OnEntityKill(StashContainer stash)
        {
            if (stash.IsValid())
                HandleDestroyedStash(stash);
        }

        /// <summary>
        /// Hook: Called when a player reveals a hidden stash.
        /// </summary>
        /// <param name="stash"> The stash that was revealed. </param>
        /// <param name="player"> The player who revealed the stash. </param>
        private void OnStashExposed(StashContainer stash, BasePlayer player)
        {
            if (PermissionUtils.Verify(player, PermissionUtils.IGNORE))
                return;

            OnStashTriggered(stash, player, false);
        }

        /// <summary>
        /// Hook: Called when a player hides a stash.
        /// </summary>
        /// <param name="stash"> The stash that was hidden. </param>
        /// <param name="player"> The player who buried the stash. </param>
        private void OnStashHidden(StashContainer stash, BasePlayer player)
        {
            if (PlayerIsStashOwner(stash, player))
                return;
            else if (!PlayerExistsInOwnerTeam(stash.OwnerID, player))
                _revealedOwnedStashes.Add(stash.net.ID.Value);
        }

        #endregion Oxide Hooks

        #region Spawn Coroutine

        /// <summary>
        /// Starts a coroutine that gradually spawns automated traps over time.
        /// </summary>
        private void StartSpawnCoroutine()
        {
            // Hold a reference to the coroutine that is currently running.
            _spawnCoroutine = ServerMgr.Instance.StartCoroutine(SpawnTraps());
        }

        /// <summary>
        /// Stops the periodic spawning of automated traps if it is currently running.
        /// </summary>
        private void StopSpawnCoroutine()
        {
            // Proceed if the coroutine is currently running.
            if (!_spawnCoroutine.IsUnityNull())
            {
                // Stop the execution of the coroutine and release it to be garbage collected.
                ServerMgr.Instance.StopCoroutine(_spawnCoroutine);
                _spawnCoroutine = null;
            }
        }

        #endregion Spawn Coroutine

        #region Trap Creation

        /// <summary>
        /// Spawns a specified number of automated traps, consisting of a stash and, optionally, a dummy sleeping bag.
        /// </summary>
        /// <returns> The number of traps that were spawned. </returns>
        private IEnumerator SpawnTraps()
        {
            // Keep track of the number of traps that have been spawned.
            int spawnedTraps = 0;
            // Calculate the number of traps that need to be spawned.
            int trapsToSpawn = _config.AutomatedTrap.MaximumTrapsToSpawn - _data.AutomatedTraps.Where(trapData => trapData.Value.DummyStash.Hidden).Count();
            // If there are no traps to spawn, exit early.
            if (trapsToSpawn <= 0)
                yield break;

            // Determine the wait duration for the coroutine based on the current frame rate limit.
            WaitForSeconds waitDuration = ConVar.FPS.limit > 80 ? CoroutineEx.waitForSeconds(0.01f) : null;

            // If there are not enough available spawn points, generate more until there are enough.
            if (_spawnPointManager.AvailableSpawnPointsCount < trapsToSpawn)
            {
                int spawnPointsToGenerate = trapsToSpawn - _spawnPointManager.AvailableSpawnPointsCount;
                yield return ServerMgr.Instance.StartCoroutine(_spawnPointManager.GenerateSpawnPoints(spawnPointsToGenerate));
            }

            // Begin spawning traps until the required number has been reached.
            for (int i = 0; i < trapsToSpawn; i++)
            {
                // Get a random spawn point.
                Tuple<Vector3, Quaternion> spawnPoint = _spawnPointManager.GetRandomSpawnPoint();

                // Create a stash container entity at the spawn point and populate it with loot.
                StashContainer stash = CreateStashEntity(STASH_PREFAB, spawnPoint.Item1, spawnPoint.Item2);
                PopulateLoot(stash);

                // Initialize a sleeping bag entity, which may be spawned if the configuration allows it.
                SleepingBag sleepingBag = null;
                if (_config.AutomatedTrap.DummySleepingBag.SpawnAlong && ChanceSucceeded(_config.AutomatedTrap.DummySleepingBag.SpawnChance))
                {
                    // Find a nearby spawn point and create a sleeping bag at it.
                    Tuple<Vector3, Quaternion> nearbySpawnPoint = _spawnPointManager.FindChildSpawnPoint(spawnPoint.Item1);
                    sleepingBag = CreateSleepingBagEntity(SLEEPING_BAG_PREFAB, nearbySpawnPoint.Item1, nearbySpawnPoint.Item2);
                }

                _data.CreateTrapData(stash, sleepingBag);
                spawnedTraps++;

                // Wait for a set duration to prevent overloading the server with spawning actions.
                yield return waitDuration;
            }

            // Output the total number of spawned traps to the console.
            Puts("Spawned " + spawnedTraps + " traps.");
            // Save the trap _data and set the coroutine to null to be garbage collected.
            _data.Save();
        }

        /// <summary>
        /// Creates a stash entity from the specified prefab at the given position and rotation.
        /// </summary>
        /// <param name="prefabPath"> The path to the prefab to use for the stash entity. </param>
        /// <param name="position"> The position to spawn the stash entity at. </param>
        /// <param name="rotation"> The rotation to spawn the stash entity with. </param>
        /// <returns> The created stash entity, or null if the entity could not be created. </returns>
        private StashContainer CreateStashEntity(string prefabPath, Vector3 position, Quaternion rotation)
        {
            // Create the entity from the specified prefab.
            BaseEntity entity = GameManager.server.CreateEntity(prefabPath, position, rotation);
            // Don't proceed if the entity could not be created.
            if (entity == null)
                return null;

            // Convert the entity to a StashContainer.
            StashContainer stash = entity as StashContainer;
            if (stash == null)
            {
                // Destroy the entity if it could not be converted.
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            // Initialize the stash by spawning and hiding it underground.
            stash.Spawn();
            stash.SetHidden(true);
            // Cancel the decay invoke, so the stash does not decay over time.
            stash.CancelInvoke(stash.Decay);

            return stash;
        }

        /// <summary>
        /// Creates a sleeping bag entity from the specified prefab at the given position and rotation.
        /// </summary>
        /// <param name="prefabPath"> The path to the prefab to use for the sleeping bag entity. </param>
        /// <param name="position"> The position to spawn the sleeping bag entity at. </param>
        /// <param name="rotation"> The rotation to spawn the sleeping bag entity with. </param>
        /// <returns> The created sleeping bag entity, or null if the entity could not be created. </returns>
        private SleepingBag CreateSleepingBagEntity(string prefabPath, Vector3 position, Quaternion rotation)
        {
            // Create the entity from the specified prefab.
            BaseEntity entity = GameManager.server.CreateEntity(prefabPath, position, rotation);
            // Don't proceed if the entity could not be created.
            if (entity == null)
                return null;

            // Convert the entity to a SleepingBag.
            SleepingBag sleepingBag = entity as SleepingBag;
            if (sleepingBag == null)
            {
                // Destroy the entity if it could not be converted.
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            UnityEngine.Object.DestroyImmediate(sleepingBag.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(sleepingBag.GetComponent<GroundWatch>());

            // Set a random skin for the sleeping bag.
            if (_config.AutomatedTrap.DummySleepingBag.RandomizedSkinChance > 0 && ChanceSucceeded(_config.AutomatedTrap.DummySleepingBag.RandomizedSkinChance))
                sleepingBag.skinID = _skinManager.GetSkinsForItem(ItemManager.FindItemDefinition("sleepingbag")).GetRandom();

            // Set a random nice name for the sleeping bag.
            if (_config.AutomatedTrap.DummySleepingBag.RandomizedNiceNameChance > 0 && ChanceSucceeded(_config.AutomatedTrap.DummySleepingBag.RandomizedNiceNameChance))
                sleepingBag.niceName = RandomUsernames.Get(Random.Range(0, 5000));

            // Spawn the sleeping bag.
            sleepingBag.Spawn();
            return sleepingBag;
        }

        private void PopulateLoot(StashContainer stash)
        {
            List<ItemInfo> itemsToSpawn = new List<ItemInfo>(_config.StashLoot.LootTable);
            int lootSpawnSlots = Random.Range(_config.StashLoot.MinimumLootSpawnSlots, _config.StashLoot.MaximumLootSpawnSlots);

            if (lootSpawnSlots > itemsToSpawn.Count)
                lootSpawnSlots = itemsToSpawn.Count;

            stash.inventory.Clear();

            for (int i = 0; i < lootSpawnSlots; i++)
            {
                Item item;
                ItemInfo randomItem = itemsToSpawn.GetRandom();
                ItemDefinition itemDefinition = randomItem.GetItemDefinition();

                if (itemDefinition == null)
                    continue;

                if (_config.StashLoot.SpawnChanceAsBlueprint > 0 && randomItem.CanBeResearched() && ChanceSucceeded(_config.StashLoot.SpawnChanceAsBlueprint))
                {
                    item = ItemManager.CreateByName(BLUEPRINT_TEMPLATE);
                    item.blueprintTarget = itemDefinition.itemid;
                }
                else
                {
                    int spawnAmount = Random.Range(randomItem.MinimumSpawnAmount, randomItem.MaximumSpawnAmount + 1);
                    ulong skin = 0;

                    if (_config.StashLoot.SpawnChanceWithSkin > 0 && randomItem.CanBeSkinned() && ChanceSucceeded(_config.StashLoot.SpawnChanceWithSkin))
                        skin = _instance._skinManager.GetSkinsForItem(itemDefinition).GetRandom();

                    item = ItemManager.CreateByName(randomItem.ShortName, spawnAmount, skin);

                    if (_config.StashLoot.SpawnChanceAsDamaged > 0 && randomItem.CanBeRepaired())
                        RandomizeItemCondition(item);
                }

                // Remove the item if it wasn't added successfully to avoid any potential entity leak.
                if (!item.MoveToContainer(stash.inventory))
                    item.Remove();

                item.MarkDirty();
                itemsToSpawn.Remove(randomItem);
            }

            Pool.FreeList(ref itemsToSpawn);
        }

        private void RandomizeItemCondition(Item item)
        {
            if (ChanceSucceeded(_config.StashLoot.SpawnChanceAsDamaged))
            {
                float conditionLoss = Random.Range(_config.StashLoot.MinimumConditionLoss, _config.StashLoot.MaximumConditionLoss);
                item.conditionNormalized = conditionLoss / 100;
            }

            if (ChanceSucceeded(_config.StashLoot.SpawnChanceAsRepaired))
            {
                float repairAmount = Random.Range(1f, 0.8f);
                item.DoRepair(repairAmount);
            }
            else if (ChanceSucceeded(_config.StashLoot.SpawnChanceAsBroken))
            {
                item.condition = 0f;
            }
        }

        #endregion Trap Creation

        #region Trap Removal

        /// <summary>
        /// Removes all automated traps from the world and their associated entities.
        /// </summary>
        /// <returns> The number of removed traps. </returns>
        private void CleanupTraps()
        {
            // Keep track of the number of removed traps.
            int removedTraps = 0;
            // Process all traps one by one.
            foreach (ulong trapId in _data.AutomatedTraps.Keys)
            {
                // Retrieve the _data for the current trap.
                AutomatedTrapData trap = _data.GetTrapData(trapId);
                // Skip the trap if its _data cannot be found and move on to the next one.
                if (trap == null)
                    continue;

                // Find the stash for the current trap and kill it if found.
                StashContainer stash = FindEntityById(trap.DummyStash.Id) as StashContainer;
                stash?.Kill();

                // Find the dummy sleeping bag associated with the trap and kill it if found.
                if (trap.DummySleepingBag != null)
                {
                    SleepingBag sleepingBag = FindEntityById(trap.DummySleepingBag.Id) as SleepingBag;
                    sleepingBag?.Kill();
                }

                // Increment the number of successfully removed traps.
                removedTraps++;
            }

            Puts("Cleaned up " + removedTraps + " traps.");
            _data.AutomatedTraps.Clear();
            _data.Save();
        }

        /// <summary>
        /// Schedules the destruction of an automated trap and, optionally, replaces it with a new one.
        /// </summary>
        /// <param name="trap"> The AutomatedTrapData object containing information about the trap to be destroyed and replaced. </param>
        private void TryDestroyAndReplaceTrap(AutomatedTrapData trap)
        {
            // Schedule the trap for destruction after the specified time interval.
            timer.Once(_config.AutomatedTrap.DestroyRevealedTrapAfterMinutes * 60, () =>
            {
                // Find the dummy stash associated with the trap and destroy it if found.
                StashContainer stash = FindEntityById(trap.DummyStash.Id) as StashContainer;
                stash?.Kill();

                // Find the dummy sleeping bag associated with the trap and destroy it if found.
                if (trap.DummySleepingBag != null)
                {
                    SleepingBag sleepingBag = FindEntityById(trap.DummySleepingBag.Id) as SleepingBag;
                    sleepingBag?.Kill();
                }

                // Remove the trap from the AutomatedTraps list.
                _data.AutomatedTraps.Remove(trap.DummyStash.Id);
                // If specified in the _config, spawn a new automated trap after the old one has been destroyed.
                if (_config.AutomatedTrap.ReplaceRevealedTrap)
                    StartSpawnCoroutine();
            });
        }

        #endregion Trap Removal

        #region Trap Trigger

        private void OnStashTriggered(StashContainer stash, BasePlayer player, bool stashWasDestroyed)
        {
            AutomatedTrapData trap = _data.GetTrapData(stash.net.ID.Value);
            if (trap != null)
            {
                if (_config.Notification.StashReportFilter != 0 && _config.Notification.StashReportFilter != 2)
                    return;

                if (!trap.DummyStash.Hidden)
                    return;

                _data.UpdateTrapData(trap);
                TryDestroyAndReplaceTrap(trap);
            }

            else if (StashIsOwned(stash))
            {
                if (_config.Notification.StashReportFilter != 1 && _config.Notification.StashReportFilter != 2)
                    return;

                if (_revealedOwnedStashes.Contains(stash.net.ID.Value))
                    return;

                if (PlayerIsStashOwner(stash, player))
                    return;

                if (_config.Violation.CanTeammateIgnore && PlayerExistsInOwnerTeam(stash.OwnerID, player))
                    return;

                if (_config.Violation.CanClanmateIgnore && PlayerExistsInOwnerClan(stash.OwnerID, player))
                    return;

                if (!stashWasDestroyed)
                    _revealedOwnedStashes.Add(stash.net.ID.Value);
            }

            _lastRevealedStashPosition = stash.ServerPosition;
            _data.CreateOrUpdatePlayerData(player);
            _data.Save();

            int violations = _data.GetPlayerRevealedTrapsCount(player);
            if (_config.Moderation.AutomaticBan && violations >= _config.Moderation.ViolationsTolerance)
                IssueBan(player);


            if (_config.Notification.EnableConsoleReport)
            {
                string report = ConstructConsoleReport(stash, player);
                Puts(report);
            }

            if (_config.Discord.PostIntoDiscord)
            {
                DiscordWebhook.Message message = ConstructDiscordReport(stash, player, stashWasDestroyed);
                _queuedDiscordReports.Enqueue(message);

                if (_reportScheduler == null)
                {
                    _reportScheduler = timer.Once(_config.Discord.ReportInterval, () =>
                    {
                        PushQueuedDiscordReports();
                        _reportScheduler = null;
                    });
                }
            }

            foreach (BasePlayer admin in BasePlayer.activePlayerList.Where(p => PermissionUtils.Verify(p)))
            {
                ReplyToPlayer(admin, GetLang(Lang.TRAP_REVEAL, admin.UserIDString), player.displayName, GetGrid(stash.ServerPosition));

                Draw.Sphere(admin, 60f, Color.black, _lastRevealedStashPosition, 0.5f);
                Draw.Arrow(admin, 60f, Color.black, _lastRevealedStashPosition + new Vector3(0, 390f, 0), _lastRevealedStashPosition, 0.50f);
                Draw.Text(admin, 60f, ParseColor("#F2C94C", Color.white), _lastRevealedStashPosition + new Vector3(0, 390.1f, 0), $"<size=25>{player.displayName}</size>");
            }
        }

        private string ConstructConsoleReport(StashContainer stash, BasePlayer player)
        {
            StringBuilder reportBuilder = new StringBuilder();
            reportBuilder.AppendLine("A cheater has been spotted");
            reportBuilder.AppendLine("{");
            reportBuilder.AppendLine("  Player: " + player.displayName);
            reportBuilder.AppendLine("  Player Id: " + player.userID);
            reportBuilder.AppendLine("  Stash Position: " + GetGrid(stash.ServerPosition));
            reportBuilder.AppendLine("  Stash Type: " + (StashIsOwned(stash) ? "Player owned stash" : "Automated trap"));

            if (StashIsOwned(stash))
            {
                reportBuilder.AppendLine("  Stash Owner: " + FormatPlayerName(FindPlayerById(stash.OwnerID)));
                reportBuilder.AppendLine("  Stash Id: " + stash.net.ID);
            }

            reportBuilder.AppendLine("}");
            return reportBuilder.ToString();
        }

        private void HandleDestroyedStash(StashContainer stash)
        {
            // Find all building blocks within a certain radius of the stash position and add them to the list.
            List<BuildingBlock> nearbyBuildingBlocks = Pool.GetList<BuildingBlock>();
            Vis.Entities(stash.transform.position, 2.5f, nearbyBuildingBlocks, LayerMask.GetMask("Construction"), QueryTriggerInteraction.Ignore);

            // Skip early if no building blocks are found.
            if (!nearbyBuildingBlocks.Any())
                return;

            // Find the first building block whose owner can be found.
            BuildingBlock buildingBlock = nearbyBuildingBlocks.FirstOrDefault(b => FindPlayerById(b.OwnerID) != null);
            // Proceed if a building block with a known owner was found.
            if (buildingBlock != null)
            {
                BasePlayer buildingBlockOwner = FindPlayerById(buildingBlock.OwnerID);
                if (PermissionUtils.Verify(buildingBlockOwner, PermissionUtils.IGNORE))
                    return;

                OnStashTriggered(stash, buildingBlockOwner, true);
            }

            // Free the memory used by the 'nearbyBuildingBlocks' list and release it back to the pool.
            Pool.FreeList(ref nearbyBuildingBlocks);
        }

        private void IssueBan(BasePlayer player)
        {
            timer.Once(_config.Moderation.BanDelaySeconds, () =>
            {
                player.IPlayer.Ban(_config.Moderation.BanReason);
                _data.RemovePlayerData(player);
                _data.Save();
            });
        }

        #endregion Trap Trigger

        #region Api

        private bool StashIsAutomatedTrap(StashContainer stash)
        {
            AutomatedTrapData trap = _data.GetTrapData(stash.net.ID.Value);
            if (trap != null)
                return true;

            return false;
        }

        #endregion Api

        #region Spawn Point Management

        /// <summary>
        /// Generates and manages spawn points for automated traps.
        /// </summary>
        public class SpawnPointManager
        {
            private HashSet<Tuple<Vector3, Quaternion>> availableSpawnPoints = new HashSet<Tuple<Vector3, Quaternion>>();

            /// <summary>
            /// Gets the count of available spawn points.
            /// </summary>
            public int AvailableSpawnPointsCount
            {
                get
                {
                    return availableSpawnPoints.Count;
                }
            }

            /// <summary>
            /// Generates random positions and creates spawn points for them.
            /// </summary>
            public IEnumerator GenerateSpawnPoints(int spawnPointsToGenerate)
            {
                // Determine the wait duration for the coroutine based on the current frame rate limit.
                WaitForSeconds waitDuration = ConVar.FPS.limit > 80 ? CoroutineEx.waitForSeconds(0.01f) : null;

                // Calculate the half size of the world.
                int halfWorldSize = ConVar.Server.worldsize / 2;
                // Keep track of the number of spawn points that were successfully generated.
                int successfullyGenerated = 0;
                // Keep track of the number of failed attempts to generate a spawn point.
                int failedAttempts = 0;

                // Attempt to find valid spawn points up to the specified number of times.
                for (int i = 0; i < _config.SpawnPoint.MaximumAttemptsToFindSpawnPoints; i++)
                {
                    // Halt the generation of spawn points once the desired number is reached.
                    if (successfullyGenerated == spawnPointsToGenerate)
                    {
                        // Output the total number of generated spawn points to the console.
                        _instance.Puts("Generated " + AvailableSpawnPointsCount + " spawn points.");
                        yield break;
                    }

                    // Generate a random position.
                    Vector3 randomPosition = Vector3.zero;
                    randomPosition.x = Random.Range(-halfWorldSize, halfWorldSize);
                    randomPosition.z = Random.Range(-halfWorldSize, halfWorldSize);
                    // Retrieve the height of the terrain at the given position.
                    randomPosition.y = TerrainMeta.HeightMap.GetHeight(randomPosition);

                    // Skip the position if it is not valid.
                    if (!PositionIsValid(randomPosition))
                    {
                        failedAttempts++;
                        continue;
                    }

                    // Create a spawn point for the position.
                    Tuple<Vector3, Quaternion> spawnPoint = FinalizeSpawnPoint(randomPosition);
                    availableSpawnPoints.Add(spawnPoint);

                    // Increment the number of successfully generated spawn points.
                    successfullyGenerated++;
                    // Wait for a set duration to prevent overloading the server with generating actions.
                    yield return waitDuration;
                }

                // Output the total number of generated spawn points to the console.
                _instance.Puts("Generated " + AvailableSpawnPointsCount + " spawn points.");
                yield break;
            }

            /// <summary>
            /// Returns a random spawn point from the list of available spawn points.
            /// </summary>
            /// <returns> A tuple containing the position and rotation of the selected spawn point. </returns>
            public Tuple<Vector3, Quaternion> GetRandomSpawnPoint()
            {
                // Check if any spawn points are available and stop as soon as one is found.
                if (availableSpawnPoints.Any())
                {
                    // Select a random index from 0 to the number of available spawn points.
                    int randomSpawnPoint = Random.Range(0, AvailableSpawnPointsCount);
                    // Get the spawn point at the random index and remove it from the list to prevent it from being chosen again.
                    Tuple<Vector3, Quaternion> spawnPoint = availableSpawnPoints.ElementAt(randomSpawnPoint);
                    availableSpawnPoints.Remove(spawnPoint);

                    // Return the chosen spawn point.
                    return spawnPoint;
                }

                // If there are no spawn points available, return the default value of (0, 0, 0) for the position and the identity quaternion for the rotation.
                return Tuple.Create(Vector3.zero, Quaternion.identity);
            }

            /// <summary>
            /// Finds a child spawn point relative to the given spawn point.
            /// </summary>
            /// <param name="parentSpawnPoint"> The position of the parent spawn point. </param>
            /// <returns> A tuple containing the position and rotation of the child spawn point. </returns>
            public Tuple<Vector3, Quaternion> FindChildSpawnPoint(Vector3 parentPosition)
            {
                // Generate a random point within a certain distance from the given spawn point.
                Vector2 randomPointInRange = Random.insideUnitCircle * _config.AutomatedTrap.DummySleepingBag.SpawnProximityToStash * _config.SpawnPoint.SafeAreaRadius;
                // Shift the random point to be relative to the parent spawn point, and adjust its height to match the terrain height at that spawn point.
                Vector3 childPosition = new Vector3(parentPosition.x + randomPointInRange.x, parentPosition.y, parentPosition.z + randomPointInRange.y);
                childPosition.y = TerrainMeta.HeightMap.GetHeight(childPosition);

                // Adjust the rotation.
                Tuple<Vector3, Quaternion> childSpawnPoint = FinalizeSpawnPoint(childPosition);
                return childSpawnPoint;
            }

            /// <summary>
            /// Clears the list of available spawn points.
            /// </summary>
            public void ClearAvailableSpawnPoints()
            {
                availableSpawnPoints.Clear();
            }

            /// <summary>
            /// Finalizes the position and rotation of a spawn point.
            /// </summary>
            /// <param name="position"> The position of the spawn point. </param>
            /// <returns> A tuple containing the final position and rotation of the spawn point. </returns>
            private Tuple<Vector3, Quaternion> FinalizeSpawnPoint(Vector3 position)
            {
                // Store the result of the linecast.
                RaycastHit hitInfo;
                // The start and end positions of the linecast.
                Vector3 linecast = new Vector3(0, 10f, 0);

                // Perform a linecast between the start and end positions.
                Physics.Linecast(position + linecast, position - linecast, out hitInfo, LayerMask.GetMask("Terrain"));

                // Calculate the rotation of the spawn point based on the linecast result.
                Quaternion rotation = Quaternion.FromToRotation(Vector3.up, hitInfo.normal) * Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
                // Return the final position and rotation of the spawn point.
                return Tuple.Create(position, rotation);
            }

            /// <summary>
            /// Determines if a position is a valid spawn point.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is a valid spawn point, false otherwise. </returns>
            private bool PositionIsValid(Vector3 position)
            {
                if (PositionIsInWater(position) || !PositionIsOnTerrain(position))
                    return false;

                if (PositionIsInRestrictedBuildingZone(position) || PositionIsOnRoadOrRail(position))
                    return false;

                if (PositionIsOnCliff(position) || PositionIsOnRock(position) || PositionIsOnIce(position))
                    return false;

                if (PositionHasEntityNearby(position) || PositionHasPlayerInRange(position))
                    return false;

                return true;
            }

            /// <summary>
            /// Determines if a position is on terrain.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is on terrain, false otherwise. </returns>
            private bool PositionIsOnTerrain(Vector3 position)
            {
                // Check if a sphere at the position intersects with the Terrain layer.
                return Physics.CheckSphere(position, _config.SpawnPoint.SafeAreaRadius, LayerMask.GetMask("Terrain"), QueryTriggerInteraction.Ignore);
            }

            /// <summary>
            /// Determines if a position is in a restricted building zone.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is in a restricted building zone, false otherwise. </returns>
            private bool PositionIsInRestrictedBuildingZone(Vector3 position)
            {
                // Check if a sphere at the position intersects with the Prevent Building layer.
                return Physics.CheckSphere(position, _config.SpawnPoint.SafeAreaRadius, LayerMask.GetMask("Prevent Building"));
            }

            /// <summary>
            /// Determines if a position is on a road.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is on a road, false otherwise. </returns>
            private bool PositionIsOnRoadOrRail(Vector3 position)
            {
                // Get the terrain topology map.
                TerrainTopologyMap topology = TerrainMeta.TopologyMap;
                // Check if the position has road or roadside topology.
                if (topology.GetTopology(position, TerrainTopology.ROAD) || topology.GetTopology(position, TerrainTopology.ROADSIDE))
                    return true;

                if (topology.GetTopology(position, TerrainTopology.RAIL) || topology.GetTopology(position, TerrainTopology.RAILSIDE))
                    return true;

                return false;
            }

            /// <summary>
            /// Determines if a position is on a cliff.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is on a cliff, false otherwise. </returns>
            private bool PositionIsOnCliff(Vector3 position)
            {
                // Get the terrain topology map.
                TerrainTopologyMap topology = TerrainMeta.TopologyMap;
                // Check if the position has cliff or cliffside topology.
                if (topology.GetTopology(position, TerrainTopology.CLIFF) || topology.GetTopology(position, TerrainTopology.CLIFFSIDE))
                    return true;

                return false;
            }

            /// <summary>
            /// Determines if a position is in water.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is in water, false otherwise. </returns>
            private bool PositionIsInWater(Vector3 position)
            {
                // Check if the position is within the water level.
                return WaterLevel.Test(position, false, false);
            }

            /// <summary>
            /// Determines if a position is on an ice lake or sheet.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is on ice, false otherwise. </returns>
            private bool PositionIsOnIce(Vector3 position)
            {
                // Get a list of colliders in a sphere around the given position.
                List<Collider> colliders = Pool.GetList<Collider>();
                Vis.Colliders(position, _config.SpawnPoint.SafeAreaRadius, colliders, LayerMask.GetMask("World"), QueryTriggerInteraction.Ignore);

                // The result flag. Set to false by default.
                bool result = false;

                // Process each collider in the list one by one.
                if (colliders.Any())
                    foreach (Collider collider in colliders)
                    {
                        // Get the name of the collider.
                        string colliderName = collider.name.ToLower();
                        // Check if the collider is on an ice lake or ice sheet.
                        if (colliderName.Contains("ice_lake") || colliderName.Contains("ice_sheet"))
                        {
                            // Set the result flag to true if the collider is on an ice lake or ice sheet.
                            result = true;
                            break;
                        }
                    }

                // Free the memory used by the 'colliders' list and release it back to the pool.
                Pool.FreeList(ref colliders);
                return result;
            }

            /// <summary>
            /// Determines if the given position is on a rock formation.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position is on rock formation, false otherwise. </returns>
            private bool PositionIsOnRock(Vector3 position)
            {
                // Get a list of colliders in a sphere around the given position.
                List<Collider> colliders = Pool.GetList<Collider>();
                Vis.Colliders(position, _config.SpawnPoint.SafeAreaRadius, colliders, LayerMask.GetMask("World"), QueryTriggerInteraction.Ignore);

                // The result flag. Set to false by default.
                bool result = false;

                // Process each collider in the list one by one.
                if (colliders.Any())
                    foreach (Collider collider in colliders)
                    {
                        // Get the name of the collider.
                        string colliderName = collider.name.ToLower();
                        // Check if the collider is on a rock or cliff-like formation.
                        if (colliderName.Contains("rock") || colliderName.Contains("cliff") || colliderName.Contains("formation"))
                        {
                            result = true;
                            break;
                        }
                    }

                // Free the memory used by the 'colliders' list and release it back to the pool.
                Pool.FreeList(ref colliders);
                return result;
            }

            /// <summary>
            /// Determines if there are any entities within the specified radius of the given position.
            /// </summary>
            /// <param name="position"> The position to check. </param>
            /// <returns> True if the position has entities nearby, false otherwise. </returns>
            private bool PositionHasEntityNearby(Vector3 position)
            {
                // Get a list of entities within a given radius around the given position.
                List<BaseEntity> nearbyEntities = Pool.GetList<BaseEntity>();
                Vis.Entities(position, _config.SpawnPoint.EntityDetectionRadius, nearbyEntities, LayerMask.GetMask("Construction", "Deployable", "Deployed"), QueryTriggerInteraction.Ignore);

                // Check if there are any entities in the list.
                bool result = nearbyEntities.Count > 0;
                Pool.FreeList(ref nearbyEntities);

                return result;
            }

            /// <summary>
            /// Determines if there are any players within a given radius around the given position.
            /// </summary>
            /// <param name="position"> The position to check for players around. </param>
            /// <returns>  True if there are players around the given position, false otherwise. </returns>
            private bool PositionHasPlayerInRange(Vector3 position)
            {
                // Get a list of players within a given radius around the given position.
                List<BasePlayer> nearbyPlayers = Pool.GetList<BasePlayer>();
                Vis.Entities(position, _config.SpawnPoint.PlayerDetectionRadius, nearbyPlayers, LayerMask.GetMask("Player (Server)"), QueryTriggerInteraction.Ignore);

                // Result flag.
                bool result = false;

                // Go through each player in the list.
                if (nearbyPlayers.Any())
                    foreach (BasePlayer player in nearbyPlayers)
                    {
                        // Check if the player is not sleeping, is alive, and has a valid Steam id.
                        if (!player.IsSleeping() && player.IsAlive() && player.userID.IsSteamId())
                        {
                            result = true;
                            break;
                        }
                    }

                Pool.FreeList(ref nearbyPlayers);
                return result;
            }
        }

        #endregion Spawn Point Management

        #region Skin Management

        /// <summary>
        /// Provides utility methods for accessing and extracting the approved skins for a given item.
        /// </summary>
        public class SkinManager
        {
            // Stores the extracted skins of items, with the item's short name as the key and the skins as the value.
            private Dictionary<string, List<ulong>> extractedSkins = new Dictionary<string, List<ulong>>();

            // Inspired by nivex.
            /// <summary>
            /// Returns a list of approved skins for the specified item.
            /// </summary>
            /// <param name="itemDefinition"> The item to get the approved skins for. </param>
            /// <returns> The list of approved skins for the item. </returns>
            public List<ulong> GetSkinsForItem(ItemDefinition itemDefinition)
            {
                List<ulong> skins;
                string itemShortName = itemDefinition.shortname;

                if (!extractedSkins.TryGetValue(itemShortName, out skins))
                    skins = ExtractApprovedSkins(itemDefinition, skins);

                return skins;
            }

            /// <summary>
            /// Retrieves the workshop ids of approved skins for a given item.
            /// </summary>
            /// <param name="itemDefinition"> The item definition for which to extract approved skins. </param>
            /// <param name="skins"> An optional list of skins to append the extracted skins to. If not provided, a new list will be created and returned. </param>
            /// <returns> A list of workshop ids for the approved skins for the given item. </returns>
            private List<ulong> ExtractApprovedSkins(ItemDefinition itemDefinition, List<ulong> skins)
            {
                skins = new List<ulong>();
                string itemShortName = itemDefinition.shortname;

                foreach (ApprovedSkinInfo skin in Approved.All.Values)
                {
                    if (skin.Skinnable.ItemName != itemShortName)
                        continue;

                    ulong skinId = skin.WorkshopdId;
                    skins.Add(skinId);
                }

                extractedSkins[itemShortName] = skins;
                return skins;
            }
        }

        #endregion Skin Management

        #region Discord Integration

        private void PushQueuedDiscordReports()
        {
            while (_queuedDiscordReports.Count > 0)
            {
                DiscordWebhook.Message message = _queuedDiscordReports.Dequeue();
                _webhook.SendRequest(_config.Discord.WebhookUrl, message);

                if (_queuedDiscordReports.Count > 0)
                {
                    timer.Once(0.5f, () =>
                    {
                        PushQueuedDiscordReports();
                    });
                    return;
                }
            }
        }

        private DiscordWebhook.Message ConstructDiscordReport(StashContainer stash, BasePlayer player, bool stashWasKilled)
        {
            DiscordWebhook.Message message = new DiscordWebhook.Message();
            if (_queuedDiscordReports.Count == 0)
                message.Content = _config.Discord.Message;
            else
                message.Content = null;

            DiscordWebhook.Embed embed = new DiscordWebhook.Embed
            {
                Color = _config.Discord.GetColor(),
                Title = _config.Discord.EmbedTitle,
                Footer = new DiscordWebhook.EmbedFooter
                {
                    Text = _config.Discord.EmbedFooter,
                },

                EmbedFields = new List<DiscordWebhook.EmbedField>()
            };

            foreach (DiscordWebhook.EmbedField field in _config.Discord.EmbedFields)
            {
                DiscordWebhook.EmbedField fieldToAdd = new DiscordWebhook.EmbedField()
                {
                    Name = field.Name,
                    Inline = field.Inline,
                    Value = Placeholder.ReplacePlaceholders(field.Value, player, stash, stashWasKilled)
                };
                embed.EmbedFields.Add(fieldToAdd);
            }

            message.Embeds.Add(embed);
            return message;
        }

        private class DiscordWebhook
        {
            /// <summary>
            /// Sends a request to the Discord _webhook url with the json-serialized message object.
            /// </summary>
            /// <param name="webhookUrl"> The url of the Discord _webhook to send the message to. </param>
            /// <param name="message"> The message object to be serialized and sent as the body of the request. </param>
            public void SendRequest(string webhookUrl, Message message)
            {
                _instance.webrequest.Enqueue(webhookUrl, message.ToString(), HandleRequestResponse, _instance, RequestMethod.POST, new Dictionary<string, string> { { "Content-Type", "application/json" } });
            }

            /// <summary>
            /// Represents a message that can be sent to a Discord channel.
            /// </summary>
            public class Message
            {
                /// <summary>
                /// The username of the Discord that will be displayed in the Discord channel.
                /// </summary>
                [JsonProperty("username")]
                public string Username { get; set; }

                /// <summary>
                /// The avatar url of the Discord that will be displayed in the Discord channel.
                /// </summary>
                [JsonProperty("icon_url")]
                public string IconUrl { get; set; }

                /// <summary>
                /// The content of the message that will be sent to the Discord channel.
                /// </summary>
                [JsonProperty("content")]
                public string Content { get; set; }

                /// <summary>
                /// The embedded content that will be displayed in the Discord channel.
                /// </summary>
                [JsonProperty("embeds")]
                public List<Embed> Embeds { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="Message"/> class with default property values.
                /// </summary>
                public Message()
                {
                    /*
                    Username = string.Empty;
                    IconUrl = string.Empty;
                    */
                    Content = string.Empty;
                    Embeds = new List<Embed>();
                }

                /// <summary>
                /// Adds the specified embed object to this message object.
                /// </summary>
                /// <param name="embed"> The embed object to be added to this message object. </param>
                public void AddEmbed(Embed embed)
                {
                    Embeds.Add(embed);
                }

                /// <summary>
                /// Converts the Discord message into a json format.
                /// </summary>
                /// <returns> A json-serialized string representation of the message. </returns>
                public override string ToString()
                {
                    return JsonConvert.SerializeObject(this, new JsonSerializerSettings
                    {
                        NullValueHandling = NullValueHandling.Ignore,
                        DefaultValueHandling = DefaultValueHandling.Ignore
                    });
                }
            }

            /// <summary>
            /// Represents an embedded object that can be added to a Discord message.
            /// </summary>
            public class Embed
            {
                /// <summary>
                /// The title of the embedded content.
                /// </summary>
                [JsonProperty("title")]
                public string Title { get; set; }

                /// <summary>
                /// The description of the embedded content.
                /// </summary>
                [JsonProperty("description")]
                public string Description { get; set; }

                /// <summary>
                /// The url that will be linked to the title of the embedded content.
                /// </summary>
                [JsonProperty("url")]
                public string Url { get; set; }

                /// <summary>
                /// The color that will be used for the border of the embedded content.
                /// </summary>
                [JsonProperty("color")]
                public int Color { get; set; }

                /// <summary>
                /// The timestamp of when the embedded content was created.
                /// </summary>
                [JsonProperty("timestamp")]
                public string Timestamp { get; set; }

                /// <summary>
                /// The thumbnail image that will be displayed in the embedded content.
                /// </summary>
                [JsonProperty("thumbnail")]
                public EmbedThumbnail Thumbnail { get; set; }

                /// <summary>
                /// The author of the embedded content.
                /// </summary>
                [JsonProperty("author")]
                public EmbedAuthor Author { get; set; }

                /// <summary>
                /// The footer text and icon that will be displayed at the bottom of the embedded content.
                /// </summary>
                [JsonProperty("footer")]
                public EmbedFooter Footer { get; set; }

                /// <summary>
                /// The image that will be displayed in the embedded content.
                /// </summary>
                [JsonProperty("image")]
                public EmbedImage Image { get; set; }

                /// <summary>
                /// A list of fields that will be displayed in the embedded content.
                /// Each field consists of a title, value, and inline flag.
                /// </summary>
                [JsonProperty("fields")]
                public List<EmbedField> EmbedFields { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="Embed"/> class with default property values.
                /// </summary>
                public Embed()
                {
                    // Set the default values for the properties.
                    Title = string.Empty;
                    Description = string.Empty;
                    Url = string.Empty;
                    Color = 0;
                    Timestamp = string.Empty;
                    Thumbnail = new EmbedThumbnail();
                    Author = new EmbedAuthor();
                    Footer = new EmbedFooter();
                    Image = new EmbedImage();
                    EmbedFields = new List<EmbedField>();
                }

                /// <summary>
                /// Adds the specified field to the embedded content.
                /// </summary>
                /// <param name="field"> The field to be added. </param>
                public void AddField(EmbedField field)
                {
                    EmbedFields.Add(field);
                }
            }

            /// <summary>
            /// Represents a field that can be added to a Discord embed.
            /// Each field consists of a title, value, and inline flag.
            /// </summary>
            public class EmbedField
            {
                /// <summary>
                /// The title of the field, which will be displayed above the value in the embedded content.
                /// </summary>
                [JsonProperty("name")]
                public string Name { get; set; }

                /// <summary>
                /// The value of the field, which will be displayed below the title in the embedded content.
                /// </summary>
                [JsonProperty("value")]
                public string Value { get; set; }

                /// <summary>
                /// A flag indicating whether the field should be displayed inline with other fields in the embedded content.
                /// If set to true, the field will be displayed inline. If set to false, the field will be displayed on a new line.
                /// </summary>
                [JsonProperty("inline")]
                public bool Inline { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="EmbedField"/> class with default property values.
                /// </summary>
                public EmbedField()
                {
                    // Set the default values for the properties.
                    Name = string.Empty;
                    Value = string.Empty;
                    Inline = false;
                }
            }

            /// <summary>
            /// Represents a thumbnail image in a Discord embed.
            /// </summary>
            public class EmbedThumbnail
            {
                /// <summary>
                /// The url of the thumbnail image.
                /// </summary>
                [JsonProperty("url")]
                public string AvatarUrl { get; set; }

                /// <summary>
                /// The width of the thumbnail image.
                /// </summary>
                [JsonProperty("width")]
                public int Width { get; set; }

                /// <summary>
                /// The height of the thumbnail image.
                /// </summary>
                [JsonProperty("height")]
                public int Height { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="EmbedThumbnail"/> class with default property values.
                /// </summary>
                public EmbedThumbnail()
                {
                    // Set the default values for the properties.
                    AvatarUrl = string.Empty;
                    Width = 0;
                    Height = 0;
                }
            }

            /// <summary>
            /// Represents an author in a Discord embed.
            /// </summary>
            public class EmbedAuthor
            {
                /// <summary>
                /// The name of the author.
                /// </summary>
                [JsonProperty("name")]
                public string Name { get; set; }

                /// <summary>
                /// The url of the author.
                /// </summary>
                [JsonProperty("url")]
                public string Url { get; set; }

                /// <summary>
                /// The url of the author's avatar.
                /// </summary>
                [JsonProperty("icon_url")]
                public string IconUrl { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="EmbedAuthor"/> class with default property values.
                /// </summary>
                public EmbedAuthor()
                {
                    // Set the default values for the properties.
                    Name = string.Empty;
                    Url = string.Empty;
                    IconUrl = string.Empty;
                }
            }

            /// <summary>
            /// Represents an image that can be added to a Discord embed.
            /// </summary>
            public class EmbedImage
            {
                // The url of the image that will be displayed in the embedded content.
                [JsonProperty("url")]
                public string AvatarUrl { get; set; }

                /// <summary>
                /// The width of the image.
                /// </summary>
                [JsonProperty("width")]
                public int Width { get; set; }

                /// <summary>
                /// The height of the image.
                /// </summary>
                [JsonProperty("height")]
                public int Height { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="EmbedImage"/> class with default values for its properties.
                /// </summary>
                public EmbedImage()
                {
                    // Set the default value for the url property.
                    AvatarUrl = string.Empty;
                    Width = 0;
                    Height = 0;
                }
            }

            /// <summary>
            /// Represents the footer text and icon that can be added to a Discord embed.
            /// </summary>
            public class EmbedFooter
            {
                /// <summary>
                /// The text that will be displayed at the bottom of the embedded content.
                /// </summary>
                [JsonProperty("text")]
                public string Text { get; set; }

                /// <summary>
                /// The url that will be linked to the footer text in the embedded content.
                /// </summary>
                [JsonProperty("icon_url")]
                public string IconUrl { get; set; }

                /// <summary>
                /// Initializes a new _instance of the <see cref="EmbedFooter"/> class with default property values.
                /// </summary>
                public EmbedFooter()
                {
                    // Set the default values for the properties.
                    Text = string.Empty;
                    IconUrl = string.Empty;
                }
            }

            /// <summary>
            /// Handles the response received from the Discord _webhook after sending a request.
            /// </summary>
            /// <param name="headerCode"> The http status code of the response. </param>
            /// <param name="headerResult"> The result message of the response. </param>
            private void HandleRequestResponse(int headerCode, string headerResult)
            {
                if (headerCode >= 200 && headerCode <= 204)
                    _instance.Puts("Discord report sent successfully.");
                else
                {
                    switch (headerCode)
                    {
                        case 400:
                            _instance.PrintError("Error: Bad request");
                            break;
                        case 401:
                            _instance.PrintError("Error: Unauthorized");
                            break;
                        case 403:
                            _instance.PrintError("Error: Forbidden");
                            break;
                        case 404:
                            _instance.PrintError("Error: Not found");
                            break;
                        case 429:
                            _instance.PrintError("Error: Rate limit reached");
                            break;
                        case 500:
                            _instance.PrintError("Error: Internal server error");
                            break;
                        case 503:
                            _instance.PrintError("Error: Service unavailable");
                            break;
                        default:
                            _instance.PrintError("Error: " + headerResult);
                            break;
                    }
                }
            }
        }

        #endregion Discord Integration

        #region Placeholders

        public static class Placeholder
        {
            public const string PLAYER_NAME = "$Player.Name";
            public const string PLAYER_ID = "$Player.Id";
            public const string PLAYER_ADDRESS = "$Player.Address";
            public const string PLAYER_VIOLATIONS = "$Player.Violations";
            public const string PLAYER_TEAM = "$Player.Team";
            public const string PLAYER_CONNECTION_TIME = "$Player.Connection.Time";
            public const string PLAYER_COMBAT_ID = "$Player.Combat.Id";
            public const string STASH_TYPE = "$Stash.Type";
            public const string STASH_ID = "$Stash.Id";
            public const string STASH_OWNER_NAME = "$Stash.Owner.Name";
            public const string STASH_OWNER_ID = "$Stash.Owner.Id";
            public const string STASH_REVEAL_METHOD = "$Stash.Reveal.Method";
            public const string STASH_POSITION_COORDINATES = "$Stash.Position.Coordinates";
            public const string STASH_POSITION_GRID = "$Stash.Position.Grid";
            public const string STASH_ITEMS = "$Stash.Items";
            public const string SERVER_NAME = "$Server.Name";
            public const string SERVER_ADDRESS = "$Server.Address";

            /// <summary>
            /// Replaces the placeholders in the given text with their corresponding values.
            /// </summary>
            /// <param name="text"> The text containing placeholders to be replaced. </param>
            /// <returns></returns>
            public static string ReplacePlaceholders(string text, BasePlayer player, StashContainer stash, bool stashWasKilled)
            {
                text = text.Replace(PLAYER_NAME, _instance.FormatPlayerName(player));
                text = text.Replace(PLAYER_ID, player.userID.ToString());
                text = text.Replace(PLAYER_ADDRESS, player.net.connection.ipaddress);
                text = text.Replace(PLAYER_VIOLATIONS, _data.GetPlayerRevealedTrapsCount(player).ToString());
                text = text.Replace(STASH_OWNER_NAME, _instance.StashIsOwned(stash) ? _instance.FormatPlayerName(_instance.FindPlayerById(stash.OwnerID)) : "Server");
                text = text.Replace(STASH_OWNER_ID, _instance.StashIsOwned(stash) ? stash.OwnerID.ToString() : "0");
                text = text.Replace(STASH_TYPE, _instance.StashIsOwned(stash) ? "Player owned stash" : "Automated trap");
                text = text.Replace(STASH_REVEAL_METHOD, stashWasKilled ? "Killed by placing a building block on top of it" : "Revealed normally");
                text = text.Replace(STASH_ID, stash.net.ID.ToString());
                text = text.Replace(STASH_POSITION_COORDINATES, stash.ServerPosition.ToString());
                text = text.Replace(STASH_POSITION_GRID, _instance.GetGrid(stash.ServerPosition));
                text = text.Replace(PLAYER_TEAM, _instance.FormatTeam(player));
                text = text.Replace(PLAYER_COMBAT_ID, player.net.ID.ToString());
                text = text.Replace(PLAYER_CONNECTION_TIME, _instance.FormatConnectionTime(player));
                text = text.Replace(SERVER_NAME, _instance.covalence.Server.Name);
                text = text.Replace(SERVER_ADDRESS, _instance.covalence.Server.Address + ":" + _instance.covalence.Server.Port);

                return text;
            }
        }

        #endregion Placeholders

        #region Loot Editor

        /// <summary>
        /// Opens the loot editor for the given player and fills it with the current stash loot table.
        /// </summary>
        /// <param name="player"> The player to open the loot editor for. </param>
        private void OpenLootEditor(BasePlayer player)
        {
            // Verify the player is not already editing the stash loot table, and remove them if they are.
            StorageContainer storageContainer;
            if (_activeLootEditors.TryGetValue(player, out storageContainer))
                RemoveLooter(player, storageContainer);

            // Create a new storage container for the player to use as a loot editor.
            storageContainer = CreateStorageEntity(STORAGE_PREFAB);
            // Add the player mapped to the storage container to the '_activeLootEditors' dictionary.
            _activeLootEditors.Add(player, storageContainer);

            // If the current loot table isn't empty, fill the storage container with its items.         
            if (_config.StashLoot.LootTable != null)
                foreach (ItemInfo itemInfo in _config.StashLoot.LootTable)
                {
                    Item item = ItemManager.CreateByName(itemInfo.ShortName, itemInfo.MaximumSpawnAmount);
                    // Skip the item if it couldn't be created.
                    if (item == null)
                        continue;

                    if (!item.MoveToContainer(storageContainer.inventory))
                        item.Remove();
                }

            // Finally, open the storage container's loot panel for the player after a short delay.
            player.Command("gametip.showgametip", "Update the loot table by dragging items from your inventory to the container. Stop looting to save your changes.");
            timer.Once(5.0f, () =>
            {
                storageContainer.PlayerOpenLoot(player, doPositionChecks: false);
                Subscribe(nameof(OnPlayerLootEnd));
                player?.Command("gametip.hidegametip");
            });
        }

        /// <summary>
        /// Closes the loot editor for the given player and updates the stash loot table.
        /// </summary>
        /// <param name="inventory"> The inventory that the player is interacting with. </param>
        private void CloseLootEditor(PlayerLoot inventory)
        {
            // Obtain the player from the given inventory.
            BasePlayer player = inventory.GetComponent<BasePlayer>();

            // Try to obtain the storage container associated with the player.
            StorageContainer storageContainer;
            if (!_activeLootEditors.TryGetValue(player, out storageContainer))
                return;

            // Verify the inventory source belongs to the storage container.
            if (inventory.entitySource == null || inventory.entitySource != storageContainer)
                return;

            // Update the stash loot table with the items in the storage container.
            UpdateStashLootTable(storageContainer, player);
            // Remove the player from the '_activeLootEditors' dictionary and destroy the storage container.
            RemoveLooter(player, storageContainer);
            Unsubscribe(nameof(OnPlayerLootEnd));
        }

        /// <summary>
        /// Updates the stash loot table based on the items in the given storage container.
        /// </summary>
        /// <param name="storageContainer"> The storage container containing the items to update the stash loot table with. </param>
        private void UpdateStashLootTable(StorageContainer storageContainer, BasePlayer player)
        {
            // Obtain a list of the items in the storage container.
            List<Item> containerItems = Pool.GetList<Item>();
            containerItems = storageContainer.inventory.itemList;

            // Initialize a list to store the updated stash loot table.
            List<ItemInfo> updatedLootTable = new List<ItemInfo>();
            for (int i = 0; i < containerItems.Count; i++)
            {
                // Get the current item that's being processed.
                Item item = containerItems[i];

                // Verify whether the item has already been added to the 'updatedLootTable' list.
                ItemInfo duplicateItem = updatedLootTable.FirstOrDefault(t => t.ShortName == item.info.shortname);
                // Skip the item if it has already been added.
                if (duplicateItem != null)
                    continue;
                // Otherwise, proceed to update the stash loot table with the item.
                else
                {
                    // Verify whether the item already exists in the current stash loot table.
                    ItemInfo existingItem = _config.StashLoot.LootTable.FirstOrDefault(t => t.ShortName == item.info.shortname);
                    // If the item already exists, update its maximum and minimum spawn amounts.
                    if (existingItem != null)
                    {
                        existingItem.MinimumSpawnAmount = item.amount / 4;
                        existingItem.MaximumSpawnAmount = item.amount;
                    }

                    // Add the item to the 'updatedLootTable' list.
                    updatedLootTable.Add(new ItemInfo
                    {
                        ShortName = item.info.shortname,
                        MinimumSpawnAmount = item.amount < 4 ? 1 : item.amount / 4,
                        MaximumSpawnAmount = item.amount
                    });
                }
            }

            // Free the memory used by the 'containerItems' list and release it back to the pool.
            Pool.FreeList(ref containerItems);
            // Update the stash loot table with the new one.
            _config.StashLoot.LootTable = new List<ItemInfo>(updatedLootTable);
            SaveConfig();

            ReplyToPlayer(player, GetLang(Lang.TRAP_LOOT, player.UserIDString), updatedLootTable.Count());
        }

        /// <summary>
        /// Revokes the given player's privilege as a loot editor and destroys the associated storage container.
        /// </summary>
        /// <param name="player"> The player to remove. </param>
        /// <param name="storageContainer"> The storage container belonging to the player. </param>
        private void RemoveLooter(BasePlayer player, StorageContainer storageContainer)
        {
            // Remove the player from the '_activeLootEditors' dictionary.
            _activeLootEditors.Remove(player);

            // If the storage container exists, clear its inventory and destroy it.
            if (storageContainer != null)
            {
                storageContainer.inventory.Clear();
                storageContainer.Kill();
            }
        }

        /// <summary>
        /// Creates a storage entity from the specified prefab.
        /// </summary>
        /// <param name="prefabPath"> The path to the prefab to use for the storage entity. </param>
        /// <returns> The created storage entity, or null if the entity could not be created. </returns>
        private StorageContainer CreateStorageEntity(string prefabPath)
        {
            // Create the entity from the specified prefab.
            BaseEntity entity = GameManager.server.CreateEntity(prefabPath);
            // Don't proceed if the entity could not be created.
            if (entity == null)
                return null;

            // Convert the entity to a StorageContainer.
            StorageContainer storageContainer = entity as StorageContainer;
            if (storageContainer == null)
            {
                // Destroy the entity if it couldn't be converted.
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            // Remove unnecessary components that would destroy the storage container when it's no longer supported by the ground.
            UnityEngine.Object.DestroyImmediate(storageContainer.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(storageContainer.GetComponent<GroundWatch>());

            // Disable networking and saving.
            storageContainer.limitNetworking = true;
            storageContainer.EnableSaving(false);
            // Spawn the storage container.
            storageContainer.Spawn();

            return storageContainer;
        }

        #endregion Loot Editor

        #region Draw Traps

        private void DrawTraps(BasePlayer player, int drawDuration)
        {
            drawDuration = drawDuration == 0 ? 30 : drawDuration;
            if (!_data.AutomatedTraps.Any())
                return;

            foreach (AutomatedTrapData trap in _data.AutomatedTraps.Values)
            {
                Vector3 stashPosition = trap.DummyStash.Position;

                Draw.Sphere(player, drawDuration, ParseColor("#BDBDBD", Color.white), stashPosition, _config.SpawnPoint.SafeAreaRadius);
                Draw.Sphere(player, drawDuration, ParseColor("#BDBDBD", Color.white), stashPosition, 0.5f);
                Draw.Text(player, drawDuration, ParseColor("#F2C94C", Color.white), stashPosition + new Vector3(0, 0.7f, 0), $"<size=30>{trap.DummyStash.Id}</size>");

                if (trap.DummySleepingBag != null)
                {
                    Vector3 sleepingBagPosition = trap.DummySleepingBag.Position;

                    Draw.Sphere(player, drawDuration, ParseColor("#BDBDBD", Color.white), sleepingBagPosition, 1.3f);
                    Draw.Text(player, drawDuration, ParseColor("#F2994A", Color.white), sleepingBagPosition + new Vector3(0, 1.5f, 0), $"<size=30>{trap.DummySleepingBag.Id}</size>");

                    Draw.Arrow(player, drawDuration, ParseColor("#BDBDBD", Color.white), stashPosition, sleepingBagPosition, 0.50f);
                    Draw.Arrow(player, drawDuration, ParseColor("#BDBDBD", Color.white), sleepingBagPosition, stashPosition, 0.50f);
                }
            }
        }

        // Inspired by WhiteThunder.
        private static class Draw
        {
            public static void Sphere(BasePlayer player, float duration, Color color, Vector3 originPosition, float radius)
            {
                player.SendConsoleCommand("ddraw.sphere", duration, color, originPosition, radius);
            }

            public static void Line(BasePlayer player, float duration, Color color, Vector3 originPosition, Vector3 targetPosition)
            {
                player.SendConsoleCommand("ddraw.line", duration, color, originPosition, targetPosition);
            }

            public static void Arrow(BasePlayer player, float duration, Color color, Vector3 originPosition, Vector3 targetPosition, float headSize)
            {
                player.SendConsoleCommand("ddraw.arrow", duration, color, originPosition, targetPosition, headSize);
            }

            public static void Text(BasePlayer player, float duration, Color color, Vector3 originPosition, string text)
            {
                player.SendConsoleCommand("ddraw.text", duration, color, originPosition, text);
            }
        }

        #endregion Draw Traps

        #region Helper Functions

        #region Stash Related

        /// <summary>
        /// Searches the map for an entity by its id.
        /// </summary>
        /// <param name="entityId"> The id of the entity to find. </param>
        /// <returns> The BaseEntity object with the specified id, or null if no such entity exists in the world or is valid. </returns>
        private BaseEntity FindEntityById(ulong entityId)
        {
            NetworkableId id = new NetworkableId(entityId);
            BaseEntity entity = BaseNetworkable.serverEntities.Find(id) as BaseEntity;
            return !entity.IsValid() || entity.IsDestroyed ? null : entity;
        }

        /// <summary>
        /// Determines if the given stash container is owned by someone.
        /// </summary>
        /// <param name="stash"> The stash container to check ownership of. </param>
        /// <returns> True if the stash container is owned, false otherwise. </returns>
        private bool StashIsOwned(StashContainer stash)
        {
            return stash?.OwnerID != 0 ? true : false;
        }

        /// <summary>
        /// Determines if the given player is the owner of the given stash container.
        /// </summary>
        /// <param name="stash"> The stash container to check ownership of. </param>
        /// <param name="player"> The player to check if they are the owner. </param>
        /// <returns> True if the player is the owner of the stash container, false otherwise. </returns>
        private bool PlayerIsStashOwner(StashContainer stash, BasePlayer player)
        {
            return stash?.OwnerID > 0 && player.userID == stash.OwnerID ? true : false;
        }

        /// <summary>
        /// Converts a Vector3 position to its corresponding grid coordinates.
        /// </summary>
        /// <param name="position"> The Vector3 position to convert to grid coordinates. </param>
        /// <returns> The grid coordinates of the specified position. </returns>
        private string GetGrid(Vector3 position)
        {
            Vector2i gridPosition = MapHelper.PositionToGrid(position);
            return MapHelper.GridToString(gridPosition);
        }

        #endregion Stash Related

        #region Player Related

        /// <summary>
        /// Finds a player by their unique player id and returns the BasePlayer object.
        /// </summary>
        /// <param name="playerId"> The  id of the player to find. </param>
        /// <returns> The BasePlayer object of the player with the specified id, or null if not found. </returns>
        private BasePlayer FindPlayerById(ulong playerId)
        {
            return RelationshipManager.FindByID(playerId) ?? null;
        }

        /// <summary>
        /// Determines if the given player is a member of the team that owns the given stash container.
        /// </summary>
        /// <param name="stashOwnerId"> The id of the owner of the stash container. </param>
        /// <param name="player"> The player to check if they are part of the owner's team. </param>
        /// <returns> True if the player is part of the owner's team, false otherwise. </returns>
        private bool PlayerExistsInOwnerTeam(ulong stashOwnerId, BasePlayer targetPlayer)
        {
            return targetPlayer.Team != null && targetPlayer.Team.members.Contains(stashOwnerId) ? true : false;
        }

        /// <summary>
        /// Check if the target player is a member of the clan the stash owner belongs to.
        /// </summary>
        /// <param name="stashOwnerId"> The user id of the stash owner. </param>
        /// <param name="targetPlayer"> The target player to check. </param>
        /// <returns> True if the target player is a member of the stash owner's clan, false otherwise. </returns>
        private bool PlayerExistsInOwnerClan(ulong stashOwnerId, BasePlayer targetPlayer)
        {
            if (PluginIsLoaded(Clans))
                return Clans.Call<bool>("IsClanMember", stashOwnerId.ToString(), targetPlayer.UserIDString);
            else
                PrintError("Clanmates are set to ignore violations, but the Clans plugin is not loaded. Load the plugin or update the config.");
            return false;
        }

        /// <summary>
        /// Retrieves the leader and teammates of the specified player.
        /// </summary>
        /// <param name="player"> The player to retrieve the team for. </param>
        /// <param name="teammates"> A list of teammates that will be populated with the player's teammates' ids. </param>
        /// <param name="leader">  A variable that will be set to the team leader's id. </param>
        private void GetTeam(BasePlayer player, List<ulong> teammates, out ulong leader)
        {
            RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindPlayersTeam(player.userID);
            if (team == null)
            {
                leader = 0;
                return;
            }

            leader = team.teamLeader;
            teammates.AddRange(team.members);
        }

        #endregion Player Related

        #region Webhook Related

        /// <summary>
        /// Formats the specified player's name and Steam profile link.
        /// </summary>
        /// <param name="player"> The player whose name and profile link should be formatted. </param>
        /// <returns> A string containing the formatted player name and profile link, or a default value if the player is invalid. </returns>
        private string FormatPlayerName(BasePlayer player)
        {
            if (!player.IsValid())
                return "Unknown";
            else
                return $"[{player.displayName}](https://steamcommunity.com/profiles/{player.userID})";
        }

        /// <summary>
        /// Returns a string containing information about a player's team, including team leader and teammates' online status.
        /// </summary>
        /// <param name="player"> The player to retrieve team information for. </param>
        /// <returns> A string containing information about the player's team. </returns>
        private string FormatTeam(BasePlayer player)
        {
            ulong leader;
            List<ulong> teammates = Pool.GetList<ulong>();
            GetTeam(player, teammates, out leader);

            StringBuilder formattedTeamText = new StringBuilder();

            if (teammates.Count > 0)
            {
                foreach (ulong memberId in teammates)
                {
                    BasePlayer member = FindPlayerById(memberId);
                    if (member != null)
                    {
                        string onlineStatus = member.IsConnected ? "Online" : "Offline";
                        string isLeader = memberId == leader ? "(Leader)" : "";
                        formattedTeamText.AppendLine($"{FormatPlayerName(member)} {member.UserIDString} {onlineStatus} {isLeader}");
                    }
                }
            }
            else
            {
                formattedTeamText.AppendLine("Player is not in a team.");
            }
            Pool.FreeList(ref teammates);
            return formattedTeamText.ToString();
        }

        /// <summary>
        /// Formats the connection time of the player in a human-readable format.
        /// </summary>
        /// <param name="player"> The player to format the connection time for. </param>
        /// <returns> The player's connection time in a human-readable format. </returns>
        private string FormatConnectionTime(BasePlayer player)
        {
            // Get the number of seconds that have passed since the player connected.
            float secondsConnected = player.Connection.GetSecondsConnected();
            // Check if the player has just connected.
            if (secondsConnected < 60)
                return "Just now";

            // Get the number of minutes that have passed.
            int minutesConnected = Mathf.FloorToInt(secondsConnected / 60);
            // Check if the player has been connected for less than an hour.
            if (minutesConnected < 60)
            {
                if (minutesConnected < 15)
                    return "Just now";
                else if (minutesConnected < 30)
                    return "About 15 min";
                else if (minutesConnected < 45)
                    return "About 30 min";
                else
                    return "About 45 min";
            }

            // Get the number of hours that have passed.
            int hoursConnected = Mathf.FloorToInt(minutesConnected / 60);
            // Check if the player has been connected for less than a day.
            if (hoursConnected < 24)
            {
                if (minutesConnected % 60 < 15)
                    return $"About {hoursConnected} hour{(hoursConnected > 1 ? "s" : "")}";
                else if (minutesConnected % 60 < 30)
                    return $"About {hoursConnected} hour{(hoursConnected > 1 ? "s" : "")} and 15 min";
                else if (minutesConnected % 60 < 45)
                    return $"About {hoursConnected} hour{(hoursConnected > 1 ? "s" : "")} and 30 min";
                else
                    return $"About {hoursConnected} hour{(hoursConnected > 1 ? "s" : "")} and 45 min";
            }

            // Get the number of days that have passed.
            int daysConnected = Mathf.FloorToInt(hoursConnected / 24);
            // Return the number of days and hours that have passed.
            return $"{daysConnected} day{(daysConnected > 1 ? "s" : "")} and {hoursConnected % 24} hour{((hoursConnected % 24) > 1 ? "s" : "")}";
        }

        #endregion Webhook Related

        /// <summary>
        /// Checks if a plugin is present and loaded.
        /// </summary>
        /// <param name="plugin"> The plugin to check. </param>
        /// <returns> True if the plugin is loaded, false otherwise. </returns>
        private bool PluginIsLoaded(Plugin plugin)
        {
            return plugin != null && plugin.IsLoaded ? true : false;
        }

        /// <summary>
        /// Determines whether a chance with the given probability has succeeded.
        /// </summary>
        /// <param name="chance"> The probability of the chance. </param>
        /// <returns> True if the chance has succeeded, or false if it has failed. </returns>
        private bool ChanceSucceeded(int chance)
        {
            return Random.Range(0, 100) < chance ? true : false;
        }

        /// <summary>
        /// Attempts to parse a color from a given hexadecimal string and returns it. If parsing fails, returns the default color provided.
        /// </summary>
        /// <param name="hexadecimalColor"> The hexadecimal string representation of the color to parse. </param>
        /// <param name="defaultColor"> The default color to return in case of parsing failure. </param>
        /// <returns> The parsed color or the default color if parsing fails. </returns>
        private Color ParseColor(string hexadecimalColor, Color defaultColor)
        {
            Color color;
            return ColorUtility.TryParseHtmlString(hexadecimalColor, out color) ? color : defaultColor;
        }

        #endregion Helper Functions

        #region Helper Classes

        private static class PermissionUtils
        {
            public const string ADMIN = "automatedstashtraps.admin";
            public const string IGNORE = "automatedstashtraps.ignore";

            public static void Register()
            {
                _instance.permission.RegisterPermission(ADMIN, _instance);
                _instance.permission.RegisterPermission(IGNORE, _instance);
            }

            public static bool Verify(BasePlayer player, string permissionName = ADMIN)
            {
                return _instance.permission.UserHasPermission(player.UserIDString, permissionName);
            }
        }

        #endregion Helper Classes

        #region Commands

        private static class Command
        {
            public const string GIVE = "trap.give";
            public const string LOOT = "trap.loot";
            public const string DRAW = "trap.draw";
            public const string TELEPORT = "trap.teleport";
        }

        [ConsoleCommand(Command.GIVE)]
        private void cmdGive(ConsoleSystem.Arg conArgs)
        {
            // Get the player who issued the command, and don't proceed if he is invalid.
            BasePlayer player = conArgs?.Player();
            if (!player.IsValid())
                return;

            // Don't proceed if the player does not have permission to use the command.
            if (!PermissionUtils.Verify(player))
            {
                ReplyToPlayer(player, GetLang(Lang.ERROR_PERMISSION, player.UserIDString));
                return;
            }

            // Create the stash item with the specified amount.
            Item item = ItemManager.CreateByName("stash.small", 1);
            // Proceed if the item was created successfully.
            if (item != null)
            {
                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                _manualTrapDeployers.Add(player);

                ReplyToPlayer(player, GetLang(Lang.TRAP_GIVE, player.UserIDString));
            }
        }

        [ChatCommand(Command.LOOT)]
        private void cmdLoot(BasePlayer player, string cmd, string[] args)
        {
            if (!PermissionUtils.Verify(player))
            {
                ReplyToPlayer(player, GetLang(Lang.ERROR_PERMISSION, player.UserIDString));
                return;
            }

            OpenLootEditor(player);
        }

        [ConsoleCommand(Command.DRAW)]
        private void cmdDraw(ConsoleSystem.Arg conArgs)
        {
            BasePlayer player = conArgs?.Player();
            if (!player.IsValid())
                return;

            if (!PermissionUtils.Verify(player))
            {
                ReplyToPlayer(player, GetLang(Lang.ERROR_PERMISSION, player.UserIDString));
                return;
            }

            int drawDuration = 0;
            if (conArgs.HasArgs())
                drawDuration = conArgs.GetInt(0);

            ReplyToPlayer(player, GetLang(Lang.TRAP_DRAW, player.UserIDString), _data.AutomatedTraps.Count());
            DrawTraps(player, drawDuration);
        }

        [ConsoleCommand(Command.TELEPORT)]
        private void cmdTeleport(ConsoleSystem.Arg conArgs)
        {
            BasePlayer player = conArgs?.Player();
            if (!player.IsValid())
                return;

            if (!PermissionUtils.Verify(player))
            {
                ReplyToPlayer(player, GetLang(Lang.ERROR_PERMISSION, player.UserIDString));
                return;
            }

            if (_lastRevealedStashPosition != Vector3.zero)
                player.Teleport(_lastRevealedStashPosition);
        }

        #endregion Commands

        #region Localization

        private class Lang
        {
            public const string ERROR_PERMISSION = "Error.Permission";
            public const string TRAP_REVEAL = "Trap.Reveal";
            public const string TRAP_LOOT = "Trap.Loot";
            public const string TRAP_DRAW = "Trap.Draw";
            public const string TRAP_GIVE = "Trap.Give";
            public const string TRAP_SETUP = "Trap.Setup";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ERROR_PERMISSION] = "You do not have the necessary permission to use this command.",
                [Lang.TRAP_REVEAL] = "Hidden stash was found by <color=#F2C94C>{0}</color> at <color=#F2C94C>{1}</color>. Don't waste any time! Use <color=#F2994A>trap.teleport</color> to quickly jump to the site.",
                [Lang.TRAP_LOOT] = "Stash loot table has been updated with a total of <color=#F2C94C>{0}</color> items.",
                [Lang.TRAP_DRAW] = "Highlighting <color=#F2C94C>{0}</color> deployed traps on the map.",
                [Lang.TRAP_GIVE] = "You have received a stash trap. Simply place it on the ground to set it up.",
                [Lang.TRAP_SETUP] = "Trap has been set up and filled with loot.",
            }, this, "en");
        }

        private string GetLang(string langKey, string playerId = null)
        {
            return lang.GetMessage(langKey, this, playerId);
        }

        private void ReplyToPlayer(BasePlayer player, string message, params object[] args)
        {
            if (args.Length > 0)
                message = string.Format(message, args);

            SendReply(player, $"{_config.Notification.Prefix} {message}");
        }

        #endregion Localization
    }
}

// --- End of file: AutomatedStashTraps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-fuel ---
// --- Original File Path: A/AutoFuel/AutoFuel.cs ---

﻿using System;
using System.Collections.Generic;

using Newtonsoft.Json;

/*
 * == 2.1.1 ==
 * - Compile fix for 4th May 2023 Rust update.
 */

namespace Oxide.Plugins
{
    [Info("Auto Fuel", "0x89A", "2.1.1")]
    [Description("Automatically fuels lights using fuel from the tool cupboard's inventory")]
    class AutoFuel : RustPlugin
    {
        private Configuration _config;

        private const string _usePerm = "autofuel.use";

        private readonly Dictionary<ulong, BuildingPrivlidge> _cachedToolCupboards = new Dictionary<ulong, BuildingPrivlidge>();

        private const int _woodItemId = -151838493;
        private const int _lowGradeItemId = -946369541;

        private void Init()
        {
            permission.RegisterPermission(_usePerm, this);
        }

        #region -Oxide Hooks-

        private void OnItemUse(Item item, int amountToUse)
        {
            if (item.amount - amountToUse > 0)
            {
                return;
            }
            
            BaseEntity parentEntity = item.GetRootContainer()?.entityOwner;

            if (parentEntity == null || !_config.AllowedEntities.Contains(parentEntity.ShortPrefabName))
            {
                return;
            }

            BuildingPrivlidge toolCupboard = null;
            if (!GetToolCupboard(parentEntity, ref toolCupboard))
            {
                return; //Ignore if ent has no TC
            }

            ItemContainer inventory = null;
            
            if (parentEntity is FuelGenerator) //Small fuel generator
            {
                inventory = (parentEntity as FuelGenerator).inventory;
            }
            else if (parentEntity is FogMachine) //Snow and fog machines
            {
                inventory = (parentEntity as FogMachine).inventory;
            }

            if (inventory == null)
            {
                return;
            }
            
            TryRefill(item.info.itemid, parentEntity, inventory, toolCupboard, amountToUse);
        }

        private void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            BuildingPrivlidge toolCupboard = null;
            if (GetToolCupboard(oven, ref toolCupboard) && fuel.amount - 1 <= 0) 
            {
                TryRefill(fuel.info.itemid, oven, oven.inventory, toolCupboard);
            }
        }

        //If activated and has no fuel, fetch from TC
        private void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            OnToggle(oven, oven.inventory, oven.fuelType?.itemid ?? _woodItemId);
        }

        //If activated and has no fuel, fetch from TC
        private void OnSwitchToggle(FuelGenerator generator, BasePlayer player)
        {
            OnToggle(generator, generator.inventory, _lowGradeItemId);
        }

        #endregion

        private void TryRefill(int itemToFind, BaseEntity ent, ItemContainer container, BuildingPrivlidge toolCupboard, int amount = 1)
        {
            if (!IsAllowed(toolCupboard, ent) || !_config.AllowedEntities.Contains(ent.ShortPrefabName))
            {
                return;
            }

            List<Item> items = toolCupboard.inventory.FindItemsByItemID(itemToFind);

            int numRequired = amount;
            foreach (Item item in items)
            {
                if (numRequired <= 0)
                {
                    break;
                }

                if (item == null)
                {
                    continue;
                }

                if (item.amount > numRequired)
                {
                    item.amount -= numRequired;
                    item.MarkDirty();

                    container.AddItem(item.info, numRequired, item.skin);
                    break;
                }

                numRequired -= item.amount;
                item.MoveToContainer(container);
            }
        }

        private void OnToggle(BaseEntity entity, ItemContainer container, int itemid)
        {
            if (container.FindItemByItemID(itemid) != null) //Has fuel
            {
                return;
            }

            BuildingPrivlidge toolCupboard = null;
            if (GetToolCupboard(entity, ref toolCupboard))
            {
                TryRefill(itemid, entity, container, toolCupboard);
            }
        }

        #region -Helpers-

        private bool GetToolCupboard(BaseEntity entity, ref BuildingPrivlidge toolCupboard)
        {
            if (entity.net == null)
            {
                return false;
            }

            ulong netId = entity.net.ID.Value;

            if (_cachedToolCupboards.TryGetValue(netId, out toolCupboard) && toolCupboard != null)
            {
                return true;
            }

            toolCupboard = entity.GetBuildingPrivilege();
            
            _cachedToolCupboards[netId] = toolCupboard;

            return toolCupboard != null;
        }

        private bool IsAllowed(BuildingPrivlidge privlidge, BaseEntity ent)
        {
            if (!_config.CheckForPerm)
            {
                return false;
            }

            if (_config.CheckEntityForPerm && permission.UserHasPermission(ent.OwnerID.ToString(), _usePerm))
            {
                return true;
            }

            if (_config.AnyoneOnTC)
            {
                foreach (var player in privlidge.authorizedPlayers)
                {
                    if (permission.UserHasPermission(player.userid.ToString(), _usePerm))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        #endregion

        #region -Configuration-

        private class Configuration
        {
            [JsonProperty("Allowed Entities")]
            public List<string> AllowedEntities = new List<string>();

            [JsonProperty("Check entity owner for permission")]
            public bool CheckEntityForPerm = false;

            [JsonProperty("Anyone on tool cupboard has permission")]
            public bool AnyoneOnTC = true;

            [JsonIgnore]
            public bool CheckForPerm => CheckEntityForPerm || AnyoneOnTC;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                if (!_config.CheckEntityForPerm && !_config.AnyoneOnTC)
                {
                    PrintWarning("Both 'Check entity owner for permission' and 'Anyone on tool cupboard has permission' are set to false, permissions will not be checked");
                }

                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                AllowedEntities = new List<string>
                {
                    "bbq.deployed",
                    "campfire",
                    "ceilinglight.deployed",
                    "fireplace.deployed",
                    "furnace",
                    "furnace.large",
                    "jackolantern.angry",
                    "jackolantern.happy",
                    "lantern.deployed",
                    "refinery_small_deployed",
                    "searchlight.deployed",
                    "skull_fire_pit",
                    "tunalight.deployed",
                    "fogmachine",
                    "snowmachine",
                    "chineselantern.deployed",
                    "hobobarrel.deployed",
                    "small_fuel_generator.deployed"
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}

// --- End of file: AutoFuel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-entity ---
// --- Original File Path: A/AntiEntity/AntiEntity.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Anti Entity", "birthdates", "1.0.1")]
    [Description("Deny certain entities from spawning")]
    public class AntiEntity : RustPlugin
    {
        #region Hooks
        private void Init()
        {
            LoadConfig();
        }

        void OnServerInitialized()
        {
            CleanupNonPrefabs();
            CleanupExisting();
        }

        void CleanupNonPrefabs()
        {
            for (var z = 0; z < _config.noSpawn.Count; z++)
            {
                var e = _config.noSpawn[z];
                if (!IsPrefab(e))
                {
                    PrintError(e + " is not a valid prefab! Removing...");
                    _config.noSpawn.Remove(e);
                }
            }
            SaveConfig();
        }

        bool IsPrefab(string pref)
        {
            if (!StringPool.toNumber.ContainsKey(pref))
            {
                return false;
            }
            return true;
        }

        void CleanupExisting()
        {
            var entities = BaseNetworkable.serverEntities.ToList().Where(x => _config.noSpawn.Contains(x.PrefabName)).ToList();
            for (var z = 0; z < entities.Count; z++)
            {
                var x = entities[z];
                if (!x.IsDestroyed) x.Kill();
            }
        }

        void OnEntitySpawned(BaseNetworkable x)
        {
            if (!(x is BaseEntity)) return;
            if (!_config.noSpawn.Contains(x.PrefabName)) return;
            if (!x.IsDestroyed)
            {
                //Timer for anything wanting this as a parent
                timer.In(0.05f, () => x.Kill());
            }
        }


        [ConsoleCommand("antientity")]
        void ConsoleCMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            
            var Id = arg.Connection?.userid.ToString();
            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith(lang.GetMessage("InvalidArgs", this, Id));
                return;
            }
            var args = arg.Args;
            var pref = args[1];
            switch (args[0].ToLower())
            {
                case "add":
                    if (!IsPrefab(pref))
                    {
                        arg.ReplyWith(lang.GetMessage("NotAPrefab", this, Id));
                        return;
                    }
                    _config.noSpawn.Add(pref);
                    SaveConfig();
                    arg.ReplyWith(string.Format(lang.GetMessage("SuccessAdd", this, Id), pref));
                    break;
                case "remove":
                    if (!_config.noSpawn.Contains(pref))
                    {
                        arg.ReplyWith(lang.GetMessage("DoesntExist", this, Id));
                        break;
                    }
                    _config.noSpawn.Remove(pref);
                    SaveConfig();
                    arg.ReplyWith(string.Format(lang.GetMessage("SuccessRemove", this, Id), pref));
                    break;
                default:
                    arg.ReplyWith(lang.GetMessage("InvalidArgs", this, Id));
                    break;
            }
        }
        #endregion

        #region Configuration & Language
        public ConfigFile _config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"InvalidArgs", "antientity remove|add <prefab>"},
                {"SuccessRemove", "You have successfully removed the prefab {0}"},
                {"SuccessAdd", "You have successfully added the prefab {0}"},
                {"DoesntExist", "That prefab is not in the list!"},
                {"NotAPrefab", "That is not a valid prefab."}
            }, this);
        }

        public class ConfigFile
        {
            [JsonProperty("Entities that are denied from spawning (cant spawn, long prefab names accepted)")]
            public List<string> noSpawn;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    noSpawn = new List<string>
                    {
                        "assets/content/vehicles/boats/rowboat/rowboat.prefab"
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
            CleanupExisting();
        }
        #endregion 
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: AntiEntity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-chatroom ---
// --- Original File Path: A/AdminChatroom/AdminChatroom.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Admin Chatroom", "austinv900", "1.0.2")]
    [Description("Allows admins to send messages back and forth between other admins")]
    class AdminChatroom : CovalencePlugin
    {
        HashSet<IPlayer> AdminChat = new HashSet<IPlayer>();

        #region Oxide Hooks
        void Init()
        {
            LoadDefaultConfig();
            LoadMessages();
            foreach (var pl in players.All)
            {
                if (pl.IsConnected && IsAdmin(pl)) AdminChat.Add(pl);
            }

            permission.RegisterPermission(Permission, this);
        }
        void OnUserConnected(IPlayer player)
        {
            if (IsAdmin(player) && !AdminChat.Contains(player)) AdminChat.Add(player);
        }
        void OnUserDisconnected(IPlayer player)
        {
            if (AdminChat.Contains(player)) AdminChat.Remove(player);
        }
        #endregion

        #region Configuration
        string Permission = "adminchatroom.";
        protected override void LoadDefaultConfig()
        {
            SetConfig("General", "Allowed To Join Permission 'adminchatroom.'", $"allowed");
            SaveConfig();
            Permission += GetConfig($"allowed", "General", "Allowed To Join Permission 'adminchatroom.'");
        }
        #endregion

        #region Localization
        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["ChatFormat"] = "[AdminChat] {0}: {1}",
                ["NotInvited"] = "You have not have access to this chatroom",
                ["PlayerAdded"] = "{0} has been added to the admin chat",
                ["PlayerRemoved"] = "{0} has been kicked from the chatroom",
                ["SendCommandInfo"] = "You have been invited to the admin chatroom. please use /{0} msg - To chat",
                ["InviteFailed"] = "Failed to invite {0} to the chat. Is he already present?"
            }, this);
        }
        #endregion

        #region Plugin WorkBench
        [Command("a")]
        void cmdAdminChat(IPlayer player, string command, string[] args)
        {
            if (!AdminChat.Contains(player)) { player.Reply(Lang("NotInvited", player.Id)); return; }

            if (args.Length == 0) return;

            if (IsAdmin(player) && args.Length == 2 && args[0].ToLower().Contains("invite") || args[0].ToLower().Contains("kick"))
            {
                switch (args[0].ToLower())
                {
                    case "invite":
                        var targ = FindConnectedPlayer(args[1]);
                        if (targ == null) { player.Reply(Lang("InviteFailed", player.Id, args[1])); return; }
                        if (AdminChat.Contains(targ)) { player.Reply(Lang("InviteFailed", player.Id, targ.Name)); return; }
                        if (!AdminChat.Contains(targ)) { AdminChat.Add(targ); SendRoomMessage("ChatRoom", Lang("PlayerAdded", player.Id, targ.Name)); targ.Reply(Lang("SendCommandInfo", targ.Id, command)); return; }
                        break;

                    case "kick":
                        var target = FindConnectedPlayer(args[1]);
                        if (target != null && AdminChat.ToList().Contains(target)) { AdminChat.Remove(target); SendRoomMessage("ChatRoom", Lang("PlayerRemoved", player.Id, target.Name)); return; }
                        break;
                }
            }

            else
            {
                SendRoomMessage(player.Name, string.Join(" ", args));
                return;
            }
        }

        void SendRoomMessage(string name, string message)
        {
            foreach (var pl in AdminChat)
            {
                pl.Reply(Lang("ChatFormat", pl.Id, name, message));
            }
        }
        #endregion

        #region Helpers
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        bool IsAdmin(IPlayer player) => permission.UserHasGroup(player.Id, "admin") || permission.UserHasPermission(player.Id, Permission) || player.IsAdmin;
        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());
        void SetConfig(params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); stringArgs.RemoveAt(args.Length - 1); if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args); }
        T GetConfig<T>(T defaultVal, params object[] args) { List<string> stringArgs = (from arg in args select arg.ToString()).ToList(); if (Config.Get(stringArgs.ToArray()) == null) { PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin."); return defaultVal; } return (T)System.Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T)); }
        IPlayer FindConnectedPlayer(string var) { var pl = players.All.Where(p => p.Id == var || p.Name.ToLower().Contains(var.ToLower()) && p.IsConnected).ToArray(); if (pl.Count() > 1 || pl.Count() == 0) return null; return pl[0]; }
        #endregion
    }
}


// --- End of file: AdminChatroom.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-broadcast ---
// --- Original File Path: A/AutoBroadcast/AutoBroadcast.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Auto Broadcast", "Wulf", "1.0.9")]
    [Description("Sends randomly configured chat messages every X amount of seconds")]

    class AutoBroadcast : CovalencePlugin
    {
        #region Initialization

        const string permBroadcast = "autobroadcast.broadcast";
        bool random;
        int interval;
        int nextKey;

        protected override void LoadDefaultConfig()
        {
            Config["Randomize Messages (true/false)"] = random = GetConfig("Randomize Messages (true/false)", false);
            Config["Broadcast Interval (Seconds)"] = interval = GetConfig("Broadcast Interval (Seconds)", 300);
            SaveConfig();
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(permBroadcast, this);

            if (lang.GetLanguages(this).Length == 0 || lang.GetMessages(lang.GetServerLanguage(), this)?.Count == 0)
            {
                lang.RegisterMessages(new Dictionary<string, string>
                {
                    ["ExampleMessage"] = "This is an example. Change it, remove it, translate it, whatever!",
                    ["AnotherExample"] = "This is another example, notice the comma at the end of the line above..."
                }, this, lang.GetServerLanguage());
            }
            else
            {
                foreach (var language in lang.GetLanguages(this))
                {
                    var messages = new Dictionary<string, string>();
                    foreach (var message in lang.GetMessages(language, this)) messages.Add(message.Key, message.Value);
                    lang.RegisterMessages(messages, this, language);
                }
            }
            Broadcast();
        }

        #endregion

        #region Broadcasting

        void Broadcast()
        {
            if (lang.GetLanguages(this) == null || lang.GetMessages(lang.GetServerLanguage(), this).Count == 0) return;

            timer.Every(interval, () =>
            {
                if (players.Connected.Count() <= 0) return;

                Dictionary<string, string> messages = null;
                foreach (var player in players.Connected)
                {
                    messages = lang.GetMessages(lang.GetLanguage(player.Id), this) ?? lang.GetMessages(lang.GetServerLanguage(), this);

                    if (messages == null || messages.Count == 0)
                    {
                        LogWarning($"No messages found for {player.Name} in {lang.GetLanguage(player.Id)} or {lang.GetServerLanguage()}");
                        continue;
                    }

                    var message = random ? messages.ElementAt(new Random().Next(0, messages.Count - 1)) : messages.ElementAt(nextKey);
                    if (message.Key != null) player.Message(Lang(message.Key, player.Id));
                }
                nextKey = nextKey + 1 == messages.Count ? 0 : nextKey + 1; // TODO: Don't assume that all languages have same count
            });
        }

        #endregion

        #region Commands

        [Command("broadcast")]
        void CmdChatBroadcast(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1 || !player.HasPermission(permBroadcast)) return;

            foreach (var target in players.Connected)
            {
                var message = lang.GetMessage(args[0], this, target.Id);
                if (!string.IsNullOrEmpty(message))
                {
                    target.Message(message);
                }
            }
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: AutoBroadcast.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/attachment-blocker ---
// --- Original File Path: A/AttachmentBlocker/AttachmentBlocker.cs ---

﻿using System;
using System.Collections.Generic;

using UnityEngine;
using System.Linq;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Attachment Blocker", "0x89A", "1.0.1")]
    [Description("Block application of specific attachments per weapon")]
    class AttachmentBlocker : RustPlugin
    {
        private Configuration config;

        private const string bypassPerm = "attachmentblocker.bypass";

        void Init() => permission.RegisterPermission(bypassPerm, this);

        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            Item parentItem = container.parent;

            if (parentItem != null && config.blockedItems.ContainsKey(parentItem.info.shortname))
            {
                BasePlayer player = parentItem.GetOwnerPlayer() ?? item.GetOwnerPlayer();
                if (player != null && permission.UserHasPermission(player.UserIDString, bypassPerm)) return null;

                List<string> list = config.blockedItems[parentItem.info.shortname];

                if (list.Contains(item.info.itemid.ToString()) || list.Contains(item.info.shortname)) 
                    return ItemContainer.CanAcceptResult.CannotAccept;
            }

            return null;
        }

        #region -Configuration-

        private class Configuration
        {
            [JsonProperty(PropertyName = "Blocked Items")]
            public Dictionary<string, List<string>> blockedItems = new Dictionary<string, List<string>>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Failed to load config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();

            foreach (ItemDefinition itemdef in ItemManager.GetItemDefinitions())
            {
                if (HasInventory(itemdef)) config.blockedItems.Add(itemdef.shortname, new List<string>());
            }
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        private bool HasInventory(ItemDefinition itemdef)
        {
            foreach (ItemMod mod in itemdef.itemMods)
            {
                if ((mod as ItemModContainer)?.availableSlots.Count > 0) return true;
            }

            return false;
        }

        #endregion
    }
}


// --- End of file: AttachmentBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/arkan ---
// --- Original File Path: A/Arkan/Arkan.cs ---

using System;
using System.Collections.Generic;
using ProtoBuf;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Globalization;
using Newtonsoft.Json;
using UnityEngine;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Arkan", "Antidote", "1.0.21")]
    [Description("Player shot analysis tool for Admins")]
    class Arkan : RustPlugin
    {
        [PluginReference]
        private Plugin DiscordMessages;
		
        #region Fields
		
		private const string permName = "arkan.allowed";
		private const string permNRDrawViolation = "arkan.nr.draw";
		private const string permAIMDrawViolation = "arkan.aim.draw";
		private const string permIRDrawViolation = "arkan.ir.draw";
		private const string permNRReportChat = "arkan.nr.reportchat";
		private const string permNRReportConsole = "arkan.nr.reportconsole";
		private const string permAIMReportChat = "arkan.aim.reportchat";
		private const string permAIMReportConsole = "arkan.aim.reportconsole";
		private const string permIRReportChat = "arkan.ir.reportchat";
		private const string permIRReportConsole = "arkan.ir.reportconsole";
		private const string permNRWhitelist = "arkan.nrwhitelist";
		private const string permNRBlacklist = "arkan.nrblacklist";
		private const string permAIMWhitelist = "arkan.aimwhitelist";
		private const string permAIMBlacklist = "arkan.aimblacklist";
		private const string permIRWhitelist = "arkan.irwhitelist";
		private const string permIRBlacklist = "arkan.irblacklist";

        private Dictionary<ulong, PlayerFiredProjectlesData> PlayersFiredProjectlesData = new Dictionary<ulong, PlayerFiredProjectlesData>();

        private PlayersViolationsData PlayersViolations = new PlayersViolationsData();
        private PlayersViolationsData tmpPlayersViolations = new PlayersViolationsData();
        private string serverTimeStamp;
        private bool isAttackShow = false; //for development purposes only
		private AdminConfig RconLog = new AdminConfig();
		
		private readonly int world_defaultLayer = LayerMask.GetMask("World", "Default");
		private readonly int world_terrainLayer = LayerMask.GetMask("World", "Terrain");
		private readonly int terrainLayer = LayerMask.GetMask("Terrain");
		private readonly string stringNullValueWarning = "Error: value is null";

        private Dictionary<BasePlayer, AdminConfig> AdminsConfig = new Dictionary<BasePlayer, AdminConfig>();
		
		private static Configuration _config;
		
		private class Configuration
		{
            public float NRProcessTimer = 4f;
            public float EPSILON = 0.005f;
            public float projectileTrajectoryForgiveness = 0.3f;
            public float hitDistanceForgiveness = 0.25f;
            public float minDistanceAIMCheck = 10.0f;			
	 		public float inRockCheckDistance = 200f;
            public bool isDetectAIM = true;
            public bool isDetectNR = true;
	 		public bool isDetectIR = true;
            public bool debugMessages = true;
            public bool autoSave = true;
			public bool isCheckAIMOnTargetNPC = true;
            public float drawTime = 60f;
            public float NRViolationAngle = 0.3f;
            public float NRViolationScreenDistance = 5f;
            public float playerEyesPositionToProjectileInitialPositionDistanceForgiveness = 10f;
			
			[JsonProperty(PropertyName = "The maximum allowed value for the physics.steps parameter")]
			public float minPhysicsStepsAllowed = 40f;	
			
			[JsonProperty(PropertyName = "Check players only on the blacklist")]
	 		public bool checkBlacklist = false;
			
			[JsonProperty(PropertyName = "Notify when a player has a high value of the physics.steps parameter")]
	 		public bool notifyPhysicsStepsWarning = false;
			
			[JsonProperty(PropertyName = "Enable Discord No Recoil Notifications")]
	 		public bool DiscordNRReportEnabled = false;
			
			[JsonProperty(PropertyName = "Enable Discord AIMBOT Notifications")]
	 		public bool DiscordAIMReportEnabled = false;
			
			[JsonProperty(PropertyName = "Enable Discord In Rock Notifications")]
	 		public bool DiscordIRReportEnabled = false;
			
			[JsonProperty(PropertyName = "Discord No Recoil Webhook URL")]
	 		public string DiscordNRWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
			
			[JsonProperty(PropertyName = "Discord AIMBOT Webhook URL")]
	 		public string DiscordAIMWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
			
			[JsonProperty(PropertyName = "Discord In Rock Webhook URL")]
	 		public string DiscordIRWebhookURL = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

			[JsonProperty(PropertyName = "AIMBodyParts", ObjectCreationHandling = ObjectCreationHandling.Replace)]		
			public List<string> AIMBodyParts = new List<string>()
			{
				"head",
				"chest"
			};

			[JsonProperty(PropertyName = "IRBodyParts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> IRBodyParts = new List<string>()
            {
                "body",
				"pelvis",
				"left knee",
				"left foot",
				"left toe",
				"groin",
				"hip",
				"right knee",
				"right foot",
				"right toe",
				"lower spine",
				"stomach",
				"chest",
				"left shoulder",
				"left arm",
				"left forearm",
				"left hand",
				"left ring finger",
				"left thumb",
				"left wrist",
				"neck",
				"head",
				"jaw",
				"left eye",
				"right eye",
				"right shoulder",
				"right arm",
				"right forearm",
				"right hand",
				"right ring finger",
				"right thumb",
				"right wrist"
            };
    
			[JsonProperty(PropertyName = "weaponsConfig")]
            public Dictionary<string, WeaponConfig> weaponsConfig = new Dictionary<string, WeaponConfig>() {
                {"rifle.ak", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"lmg.m249", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"pistol.nailgun", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.2", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.125f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.thompson", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"smg.mp5", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.0625f, weaponMaxTimeShotsInterval = 0.125f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}},
                {"bow.hunting", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
            //    {"bow.compound", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"crossbow", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.bolt", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.l96", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.m39", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.semiauto", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.m92", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.python", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.revolver", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"pistol.semiauto", new WeaponConfig() {NRDetectEnabled = false, AIMDetectEnabled = true}},
                {"rifle.lr300", new WeaponConfig() {NRDetectEnabled = true, AIMDetectEnabled = true, weaponMinTimeShotsInterval = 0.09375f, weaponMaxTimeShotsInterval = 0.15625f, NRMinShotsCountToCheck = 5, NRViolationProbability = 70f}}
            };
		}

        private class WeaponConfig
        {
            public bool NRDetectEnabled;
            public bool AIMDetectEnabled;
            public float weaponMinTimeShotsInterval;
            public float weaponMaxTimeShotsInterval;
            public int NRMinShotsCountToCheck;
            public float NRViolationProbability;
        }

        private class ViolationsLog
        {
            public ulong steamID;
            public int NoRecoilViolation;
            public int AIMViolation;
			public int InRockViolation;
        }

        private class AdminConfig
        {
            public ViolationsLog violationsLog = new ViolationsLog();
        }

        private class PlayersViolationsData
        {
            public int seed;
            public int mapSize;
            public string serverTimeStamp;
            public DateTime lastSaveTime;
            public DateTime lastChangeTime;
            public Dictionary<ulong, PlayerViolationsData> Players = new Dictionary<ulong, PlayerViolationsData>();
        }

        private class PlayerFiredProjectlesData
        {
            public ulong PlayerID;
            public string PlayerName;
            public float lastFiredTime;
			public float physicsSteps = 32f;
            public SortedDictionary<int, FiredProjectile> firedProjectiles = new SortedDictionary<int, FiredProjectile>();
            public SortedDictionary<ulong, MeleeThrown> melees = new SortedDictionary<ulong, MeleeThrown>();
            public bool isChecked;
        }

        private class PlayerViolationsData
        {
            public ulong PlayerID;
            public string PlayerName;
            public SortedDictionary<string, NoRecoilViolationData> noRecoilViolations = new SortedDictionary<string, NoRecoilViolationData>();
            public SortedDictionary<string, AIMViolationData> AIMViolations = new SortedDictionary<string, AIMViolationData>();
			public SortedDictionary<string, InRockViolationsData> inRockViolations = new SortedDictionary<string, InRockViolationsData>();
        }

        private class HitData
        {
            public ProjectileRicochet hitData;
            public Vector3 startProjectilePosition;
            public Vector3 startProjectileVelocity;
            public Vector3 hitPositionWorld;
            public Vector3 hitPointStart;
            public Vector3 hitPointEnd;
            public bool isHitPointNearProjectileTrajectoryLastSegmentEndPoint = true;
            public bool isHitPointOnProjectileTrajectory = true;
            public bool isProjectileStartPointAtEndReverseProjectileTrajectory = true;
            public bool isHitPointNearProjectilePlane = true;
            public bool isLastSegmentOnProjectileTrajectoryPlane = true;
            public float distanceFromHitPointToProjectilePlane = 0f;
            public int side;
			public Vector3 pointProjectedOnLastSegmentLine;
            public float travelDistance = 0f;
            public float delta = 1f;
            public Vector3 lastSegmentPointStart;
            public Vector3 lastSegmentPointEnd;
            public Vector3 reverseLastSegmentPointStart;
            public Vector3 reverseLastSegmentPointEnd;
        }

        private class AIMViolationData
        {
            public int projectileID;
            public int violationID;
			public DateTime firedTime;
            public Vector3 startProjectilePosition;
            public Vector3 startProjectileVelocity;
            public string hitInfoInitiatorPlayerName;
            public string hitInfoInitiatorPlayerUserID;
            public string hitInfoHitEntityPlayerName;
            public string hitInfoHitEntityPlayerUserID;
            public string hitInfoBoneName;
            public Vector3 hitInfoHitPositionWorld;
            public float hitInfoProjectileDistance;
            public Vector3 hitInfoPointStart;
            public Vector3 hitInfoPointEnd;
            public float hitInfoProjectilePrefabGravityModifier;
            public float hitInfoProjectilePrefabDrag;
            public string weaponShortName;
            public string ammoShortName;
            public string bodyPart;
            public float damage;
            public bool isEqualFiredProjectileData = true;
            public bool isPlayerPositionToProjectileStartPositionDistanceViolation = false;
            public float distanceDifferenceViolation = 0f;
            public float calculatedTravelDistance;
            public bool isAttackerMount = false;
            public bool isTargetMount = false;
            public string attackerMountParentName;
            public string targetMountParentName;
            public float firedProjectileFiredTime;
            public float firedProjectileTravelTime;
            public Vector3 firedProjectilePosition;
            public Vector3 firedProjectileVelocity;
            public Vector3 firedProjectileInitialPosition;
            public Vector3 firedProjectileInitialVelocity;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public bool hasFiredProjectile = false;
            public List<HitData> hitsData = new List<HitData>();
            public float gravityModifier;
            public float drag;
			public float forgivenessModifier = 1f;
			public float physicsSteps = 32f;
			public List<string> attachments = new List<string>();
        }

        private class NoRecoilViolationData
        {
            public int ShotsCnt;
            public int NRViolationsCnt;
            public float violationProbability;
            public bool isMounted;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
            public List<string> attachments = new List<string>();
            public string ammoShortName;
            public string weaponShortName;

            public Dictionary<int, SuspiciousProjectileData> suspiciousNoRecoilShots = new Dictionary<int, SuspiciousProjectileData>();
        }
		
		private class InRockViolationsData
        {
			public DateTime dateTime;
			
			public Dictionary<int, InRockViolationData> inRockViolationsData = new Dictionary<int, InRockViolationData>();
        }

		private class InRockViolationData
        {
			public DateTime dateTime;
            public float physicsSteps;
			public float targetHitDistance;
			public string targetName;
			public string targetID;
			public float targetDamage;
			public string targetBodyPart;
			public Vector3 targetHitPosition;
			public Vector3 rockHitPosition;
			public FiredProjectile firedProjectile;
			public int projectileID;
            public float drag;
            public float gravityModifier;
        }

        private struct SuspiciousProjectileData
        {
            public DateTime timeStamp;
            public int projectile1ID;
            public int projectile2ID;
            public float timeInterval;
            public Vector3 projectile1Position;
            public Vector3 projectile2Position;
            public Vector3 projectile1Velocity;
            public Vector3 projectile2Velocity;
            public Vector3 closestPointLine1;
            public Vector3 closestPointLine2;
            public Vector3 prevIntersectionPoint;
            public float recoilAngle;
            public float recoilScreenDistance;
            public bool isNoRecoil;
            public bool isShootedInMotion;
        }

        private class FiredShotsData
        {
            public string ammoShortName;
            public string weaponShortName;
            public List<string> attachments = new List<string>();
            public SortedDictionary<int, FiredProjectile> firedShots = new SortedDictionary<int, FiredProjectile>();
        }

        private class FiredProjectile
        {
            public DateTime firedTime;
            public Vector3 projectileVelocity;
            public Vector3 projectilePosition;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public bool isChecked;
            public string ammoShortName;
            public string weaponShortName;
            public ItemId weaponUID;
            public bool isMounted;
            public string mountParentName;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
            public List<ProjectileRicochet> hitsData = new List<ProjectileRicochet>();
            public List<string> attachments = new List<string>();
            public float NRProbabilityModifier = 1f;
        }

        private struct MeleeThrown
        {
            public DateTime firedTime;
            public Vector3 position;
            public Vector3 playerEyesLookAt;
            public Vector3 playerEyesPosition;
            public float projectileVelocity;
            public float drag;
            public float gravityModifier;
            public string meleeShortName;
            public ItemId meleeUID;
            public bool isMounted;
            public string mountParentName;
            public Vector3 mountParentPosition;
			public Vector4 mountParentRotation;
        }

        private struct ProjectileRicochet
        {
            public int projectileID;
            public Vector3 hitPosition;
            public Vector3 inVelocity;
            public Vector3 outVelocity;
        }
		
		private class TrajectorySegment
        {
			public Vector3 pointStart;
			public Vector3 pointEnd;
        }
		
		public class EmbedFieldList
        {
            public string name { get; set;}
            public string value { get; set; }
            public bool inline { get; set; }
        }

        #endregion Fields

        #region Localization		

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerAIMViolation"] = "<color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has possibly AIMBOT violation <color=yellow>#{2}</color>. Target <color=yellow>{3}/{4}</color></color>",
				["PlayerAIMViolationCon"] = "Player {0}/{1} has possibly AIMBOT violation #{2}. Target {3}/{4}",
				["PlayerIRViolation"] = "<color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has In Rock violation <color=yellow>#{2}</color>. Shots count <color=yellow>{3}</color></color>",
				["PlayerIRViolationCon"] = "<color=green>Arkan:</color> Player {0}/{1} has In Rock violation #{2}. Shots count <color=yellow>{3}</color></color>",
                ["InitPlgText1"] = "Arkan Init: map seed: {0}, map size: {1}, server timestamp: {2}",
                ["AIMText1"] = "AIMBOT probable violation\n",
                ["AIMText2"] = "HitPoint is located before line ProjectileTrajectoryLastSegment",
                ["AIMText3"] = "HitPoint is located behind line ProjectileTrajectoryLastSegment",
                ["AIMText4"] = "AIMBOT Violation: HitPoint is not located within line ProjectileTrajectoryLastSegment. \nBut HitPoint is located near the plane ProjectilePlane at a distance {0}. {1}, distance to {2} {3}",
                ["AIMText6"] = "AIMBOT Violation: ProjectileTrajectoryFirstSegments does not match calculated by FiredProjectile data: pointStart = {0} pointEnd = {1}, by HitInfo data: pointStart = {2} pointEnd = {3}\n",
                ["AIMText7"] = "AIMBOT Violation: HitPoint is not near the plane ProjectilePlane at a distance {0}\n",
                ["AIMText8"] = "AIMBOT Violation: ProjectileTrajectoryLastSegments does not match calculated by FiredProjectile data: pointStart = {0}, by HitInfo data: pointStart = {1} pointEnd = {2}\n",
				["ClearVD"] = "<color=red><color=green>Arkan:</color> Violations data cleared</color>",
                ["SaveVD1"] = "<color=red><color=green>Arkan:</color> Violation data saved in file <color=yellow>{0}</color></color>",
                ["LoadVD1"] = "<color=red><color=green>Arkan:</color> File <color=yellow>{0}</color> exist, saved data loaded</color>",
                ["LoadVD2"] = "Saved data map seed:{0} doesn't match map seed:{1}",
                ["LoadVD3"] = "Saved data map size:{0} doesn't match map size:{1}",
                ["LoadVD4"] = "<color=red><color=green>Arkan:</color> File <color=yellow>{0}</color> doesn't exist</color>",
				["LogText6"] = "     Distance difference {0}\n",
				["LogText7"] = "____Trajectory #{0} check data____",
				["LogText8"] = "____Trajectory #{0} data log end____",
				["VDataLog"] = "Violation data log",
				["ErrorText1"] = "Projectile data collect error: player {0}, missing projectileShoot data",
				["ErrorText2"] = "AIMBOT check error: attacker {0}, target {1}, missing ProjectileID: {2}",				
				["ShowLog1v1.0.13"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Commands in chat:\n" +
                    "<color=orange>/arkan</color> - Show all No Recoil/AIMBOT/In Rock violations\n" +
                    "<color=orange>/arkannr</color> - Show all No Recoil violations\n" +
                    "<color=orange>/arkannr SteamID/NAME</color> - Teleport to player's first/next No Recoil violation position\n" +
                    "<color=orange>/arkannr SteamID/NAME 0/num</color> - Teleport to player's first/specific No Recoil violation position\n" +
                    "<color=orange>/arkanaim</color> - Show all AIMBOT violations\n" +
                    "<color=orange>/arkanaim SteamID/NAME</color> - Teleport to player's first/next AIMBOT violation position\n" +
                    "<color=orange>/arkanaim SteamID/NAME 0/num</color> - Teleport to player's first/specific AIMBOT violation position\n" +
					"<color=orange>/arkanir</color> - Show all In Rock violations\n" +
                    "<color=orange>/arkanir SteamID/NAME</color> - Teleport to player's first/next In Rock violation position\n" +
                    "<color=orange>/arkanir SteamID/NAME 0/num</color> - Teleport to player's first/specific In Rock violation position\n" +
                    "<color=orange>/arkansave, /arkansave filename</color> - Saves all violations to datafile\n" +
                    "<color=orange>/arkanload, /arkanload filename</color> - Loads violations from datafile\n\n",
                ["ShowLog2"] = "<size=14><color=orange>Players violations list:</color>\n<color=red>",
                ["ShowLog3"] = "<size=14><color=orange>Players violations list empty",
				["ShowInfo"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Arkan commands info: <color=orange>/arkaninfo</color>\n\n",
                ["ShowNRLog2"] = "<size=14><color=orange>Players No Recoil violations list:</color>\n<color=red>",
                ["ShowNRLog3"] = "<size=14><color=orange>Players No Recoil violations list empty",
                ["ShowIRLog2"] = "<size=14><color=orange>Players In Rock violations list:</color>\n<color=red>",
                ["ShowIRLog3"] = "<size=14><color=orange>Players In Rock violations list empty",
				["ShowAIMLog2"] = "<size=14><color=orange>Players AIMBOT violations list:</color>\n<color=red>",	
                ["ShowAIMLog3"] = "<size=14><color=orange>Players AIMBOT violations list empty",
				["DrawIRVD1"] = "Player <color=yellow>{0}</color>\nIn Rock violation <color=gray>#{1}</color>\nEntity <color=gray>{2}</color>",
                ["DrawNRVD1"] = "Player <color=yellow>{0}</color>\nAmmo <color=gray>{1}</color>\nWeapon <color=gray>{2}</color>\nShots count <color=gray>{3}</color>\nViolation probability <color=gray>{4}</color>",
                ["DrawAIMVD3"] = "Target <color=yellow>{0}</color>\nBody part <color=gray>{1}</color>\nDamage <color=gray>{2}</color>",
                ["DrawAIMVD4"] = "Attacker <color=yellow>{0}</color>\nProjectileID <color=gray>{1}</color>\nAmmo <color=gray>{2}</color>\nWeapon <color=gray>{3}</color>\nDistance <color=gray>{4}</color>",
                ["DrawAIMVD5"] = "Attacker <color=yellow>{0}</color>, violation <color=gray>#{1}</color>\nPlayer position: <color=gray>{2}</color>\nProjectile start position: <color=gray>{3}</color>\nDistance: <color=gray>{4}</color>",
                ["ShowD1"] = "Clear current violation number",
                ["ShowD2"] = "Error. There is no such player in the logs",	
                ["ShowD3"] = "Player {0} has no more positive detections",
                ["NoMoreViolations"] = "<color=red>Player <color=yellow>{0}</color> has no more positive detections</color>",
                ["ShowNRD1"] = "Error. Player {0} has no No Recoil violation",
                ["ShowNRD2"] = "No Recoil violations count: <color=yellow>{0}</color>\n",
                ["ShowNRD3"] = "Current No Recoil violation number: <color=yellow>{0}</color>",
				["ShowIRD1"] = "Error. Player {0} has no In Rock violation",
                ["ShowIRD2"] = "In Rock violations count: <color=yellow>{0}</color>\n",
                ["ShowIRD3"] = "Current In Rock violation number: <color=yellow>{0}</color>",
                ["Player"] = "<color=green>Arkan:</color> <color=red>Player <color=yellow>{0}</color>\n",
                ["ShowAIMD1"] = "Error. Player {0} has no AIMBOT violation",
                ["ShowAIMD2"] = "AIMBOT violations count: <color=yellow>{0}</color>\n",
                ["ShowAIMD3"] = "Current AIMBOT violation number: <color=yellow>{0}</color></color>",
				["ClosestPoint"] = "Closest point 1: {0} Closest point 2: {1}, prev {2}",
				["StandingShooting"] = "Standing shooting position",
				["ShootingOnMove"] = "Shooting on the move",
				["FireTimeInterval"] = "Fire time interval {0}",
				["ProjectileID"] = "Projectile ID: {0}",
				["PlayerTxt"] = "Player",
				["Probability"] = "Probability",
				["ShotsCount"] = "Shots count",
				["AttachmentsCount"] = "Attachments count",
				["Attachment"] = "Attachment",
				["Weapon"] = "Weapon",
				["Ammo"] = "Ammo",
				["NoAttachments"] = "No attachments",
				["Attacker"] = "Attacker",
				["Target"] = "Target",
				["HitPart"] = "Hit part",
				["RecoilAngle"] = "Recoil angle: {0}",
				["Distance"] = "Distance",
				["Damage"] = "Damage",
				["NRDetection"] = "No Recoil probable violation",
				["IRDetection"] = "In Rock violation",
				["DistanceToFirstPoint"] = "Distance to first point: {0}",
				["ScreenCoords"] = "Screen coords point1: {0}, coords point2: {1}",
				["NRViolationNum"] = "NR violation #",
				["AIMViolationNum"] = "AIMBOT violation #",
				["IRViolationNum"] = "IR violation #",
				["AIMDetection"] = "AIMBOT probable violation",
				["DateTime"] = "Date/Time",
                ["MountedOn"] = "Attacker mounted on {0}",
				["RicochetsCount"] = "Ricochets count",
				["DistanceBetweenTwoPoints"] = "Distance between two points: {0}",
				["HighPhysicsStepsDetection"] = "Detected high value of the physics.steps parameter",
				["PhysicsStepsChangeWarning"] = "Player {0} probably changed the value of the physics.steps parameter to ~{1}({2}). The default value for physics.steps is 32.\nChanging the value of this parameter to a higher value allows the player to gain advantages over normal game play (allows jumping higher).",
				["Description"] = "Description",
				["DiscordWarning2"] = "Error: Discord reports enabled but plugin DiscordMessages not loaded!",
				["DiscordWarningNR"] = "Error: Discord No Recoil reports enabled but webhook for No Recoil violation is not configured!",
				["DiscordWarningAIM"] = "Error: Discord AIMBOT reports enabled but webhook for AIMBOT violation is not configured!",
				["DiscordWarningIR"] = "Error: Discord In Rock reports enabled but webhook for In Rock violation is not configured!",
                ["PlayerNRViolation"] = "<size=14><color=red><color=green>Arkan:</color> Player <color=yellow>{0}/{1}</color> has possibly No Recoil violation <color=yellow>#{2}</color>\ntotal shots cnt: <color=yellow>{3}</color> | shots with low recoil cnt: <color=yellow>{4}</color>\nprobability: <color=yellow>{5}%</color></color></size>",
				["PlayerNRViolationCon"] = "Arkan: Player {0}/{1} has possibly No Recoil violation #{2}\ntotal shots cnt: {3} | shots with low recoil cnt: {4}\nprobability: {5}",
            }, this, "en");
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PlayerAIMViolation"] = "<color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено возможное нарушение AIM <color=yellow>#{2}</color>. Жертва <color=yellow>{3}/{4}</color></color>",
				["PlayerAIMViolationCon"] = "У игрока {0}/{1} обнаружено возможное нарушение AIM #{2}. Жертва {3}/{4}",
				["PlayerIRViolation"] = "<color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено нарушение In Rock <color=yellow>#{2}</color>. Количество выстрелов <color=yellow>{3}</color></color>",
				["PlayerIRViolationCon"] = "<color=green>Arkan:</color> У игрока {0}/{1} обнаружено нарушение In Rock #{2}. Количество выстрелов <color=yellow>{3}</color></color>",
                ["InitPlgText1"] = "Arkan Init: сид карты: {0}, размер карты: {1}, timestamp сервера: {2}",
                ["AIMText1"] = "Вероятное нарушение AIMBOT\n",
                ["AIMText2"] = "HitPoint расположен перед сегментом траектории ProjectileTrajectoryLastSegment",
                ["AIMText3"] = "HitPoint расположен за сегментом траектории ProjectileTrajectoryLastSegment",
                ["AIMText4"] = "AIMBOT Нарушение: HitPoint расположен вне сегмента траектории ProjectileTrajectoryLastSegment. \nНо HitPoint расположен недалеко от плоскости ProjectilePlane на расстоянии {0}. {1}, дистанция к {2} {3}",
                ["AIMText6"] = "AIMBOT Нарушение: ProjectileTrajectoryFirstSegments не соответствует рассчитанным данным FiredProjectile: pointStart = {0} pointEnd = {1}, по данным HitInfo: pointStart = {2} pointEnd = {3}\n",
                ["AIMText7"] = "AIMBOT Нарушение: HitPoint расположен слишком далеко от плоскости ProjectilePlane на расстоянии {0}\n",
                ["AIMText8"] = "AIMBOT Нарушение: ProjectileTrajectoryLastSegments не соответствует рассчитанным данным FiredProjectile: pointStart = {0}, по данным HitInfo: pointStart = {1} pointEnd = {2}\n",
				["ClearVD"] = "<color=red><color=green>Arkan:</color> Данные нарушений очищены</color>",
                ["SaveVD1"] = "<color=red><color=green>Arkan:</color> Данные нарушений сохранены в файл <color=yellow>{0}</color></color>",
                ["LoadVD1"] = "<color=red><color=green>Arkan:</color> Файл <color=yellow>{0}</color> существует, сохранненые в нем данные загружены</color>",
                ["LoadVD2"] = "В загружаемом лог-файле сид карты:{0} не соответствует сиду карты на сервере:{1}",
                ["LoadVD3"] = "В загружаемом лог-файле размер карты:{0} не соответствует размеру карты на сервере:{1}",
                ["LoadVD4"] = "<color=red><color=green>Arkan:</color> Файл <color=yellow>{0}</color> не существует</color>",
				["LogText6"] = "     Разница расстояния {0}\n",
				["LogText7"] = "____Данные проверки траектории #{0}____",
				["LogText8"] = "____Конец данных лога проверки траектории #{0}____",
				["VDataLog"] = "Лог данных нарушения",
				["ErrorText1"] = "Ошибка при сборе данных снаряда: игрок {0}, отсутствуют данные projectileShoot",
				["ErrorText2"] = "Ошибка при проверке AIMBOT: атакующий {0}, жертва {1}, пропущен ProjectileID: {2}",
                ["ShowLog1v1.0.13"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Команды в чат:\n" +
                    "<color=orange>/arkan</color> - Показывает список всех No Recoil/AIMBOT/In Rock нарушений\n" +
                    "<color=orange>/arkannr</color> - Показывает список всех No Recoil нарушений\n" +
                    "<color=orange>/arkannr SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkannr SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkanaim</color> - Показывает список всех AIMBOT нарушений\n" +
                    "<color=orange>/arkanaim SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения AIMBOT игрока\n" +
                    "<color=orange>/arkanaim SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения AIMBOT игрока\n" +
					"<color=orange>/arkanir</color> - Показывает список всех In Rock нарушений\n" +
                    "<color=orange>/arkanir SteamID/NAME</color> - Телепортирует на первую/следующую позицию нарушения In Rock игрока\n" +
                    "<color=orange>/arkanir SteamID/NAME 0/num</color> - Телепортирует на первую/определенную позицию нарушения No Recoil игрока\n" +
                    "<color=orange>/arkansave, /arkansave filename</color> - Сохраняет все данные нарушений в файл\n" +
                    "<color=orange>/arkanload, /arkanload filename</color> - Загружает сохраненные данные нарушений из файла\n\n",
                ["ShowLog2"] = "<size=14><color=orange>Список нарушений игроков:</color>\n<color=red>",
                ["ShowLog3"] = "<size=14><color=orange>Список нарушений игрока пуст",
				["ShowInfo"] = "<size=14><color=orange><color=green>Arkan</color> by Antidote</color></size>\n" +
                    "Инфо по командам Arkan: <color=orange>/arkaninfo</color>\n\n",
                ["ShowNRLog2"] = "<size=14><color=orange>Список нарушений No Recoil игроков:</color>\n<color=red>",
                ["ShowNRLog3"] = "<size=14><color=orange>Список нарушений No Recoil игрока пуст",
                ["ShowIRLog2"] = "<size=14><color=orange>Список нарушений In Rock игроков:</color>\n<color=red>",
                ["ShowIRLog3"] = "<size=14><color=orange>Список нарушений In Rock игрока пуст",
				["ShowAIMLog2"] = "<size=14><color=orange>Список нарушений AIMBOT игроков:</color>\n<color=red>",
                ["ShowAIMLog3"] = "<size=14><color=orange>Список нарушений AIMBOT игрока пуст",
				["DrawIRVD1"] = "Игрок <color=yellow>{0}</color>\nIn Rock нарушение <color=gray>#{1}</color>\nОбъект <color=gray>{2}</color>",
                ["DrawNRVD1"] = "Игрок <color=yellow>{0}</color>\nАммо <color=gray>{1}</color>\nОружие <color=gray>{2}</color>\nКоличество выстрелов <color=gray>{3}</color>\nВероятность нарушения <color=gray>{4}</color>",
                ["DrawAIMVD3"] = "Жертва <color=yellow>{0}</color>\nЧасть тела <color=gray>{1}</color>\nПовреждение <color=gray>{2}</color>",
                ["DrawAIMVD4"] = "Атакующий <color=yellow>{0}</color>\nProjectileID <color=gray>{1}</color>\nАммо <color=gray>{2}</color>\nОружие <color=gray>{3}</color>\nРасстояние <color=gray>{4}</color>",
                ["DrawAIMVD5"] = "Атакующий <color=yellow>{0}</color>, нарушение <color=gray>#{1}</color>\nПозиция игрока: <color=gray>{2}</color>\nТочка старта снаряда: <color=gray>{3}</color>\nРасстояние: <color=gray>{4}</color>",
                ["ShowD1"] = "Номер текущего нарушения сброшен",
                ["ShowD2"] = "Ошибка. Такого игрока нет в логах",
                ["ShowD3"] = "У игрока {0} нет больше нарушений",
                ["NoMoreViolations"] = "<color=red>У игрока <color=yellow>{0}</color> нет больше нарушений</color>",
                ["ShowNRD1"] = "Ошибка. У игрока {0} нет нарушения No Recoil",
                ["ShowNRD2"] = "Количество нарушений No Recoil: <color=yellow>{0}</color>\n",
                ["ShowNRD3"] = "Номер текущего нарушения No Recoil: <color=yellow>{0}</color>",
				["ShowIRD1"] = "Ошибка. У игрока {0} нет нарушения In Rock",
                ["ShowIRD2"] = "Количество нарушений In Rock: <color=yellow>{0}</color>\n",
                ["ShowIRD3"] = "Номер текущего нарушения In Rock: <color=yellow>{0}</color>",
                ["Player"] = "<color=green>Arkan:</color> <color=red>Игрок <color=yellow>{0}</color>\n",
                ["ShowAIMD1"] = "Ошибка. У игрока {0} нет нарушения AIMBOT",
                ["ShowAIMD2"] = "Количество нарушений AIMBOT: <color=yellow>{0}</color>\n",
                ["ShowAIMD3"] = "Номер текущего нарушения AIMBOT: <color=yellow>{0}</color></color>",
				["ClosestPoint"] = "Ближайшая точка 1: {0} Ближайшая точка 2: {1}, Предыдущая ближайшая точка {2}",
				["StandingShooting"] = "Стрельба из положения стоя",
				["ShootingOnMove"] = "Стрельба в движении",
				["FireTimeInterval"] = "Интервал между выстрелами {0}",
				["ProjectileID"] = "ID снаряда: {0}",
				["PlayerTxt"] = "Игрок",
				["Probability"] = "Вероятность",
				["ShotsCount"] = "Количество выстрелов",
				["Weapon"] = "Оружие",
				["Ammo"] = "Боеприпас",
				["AttachmentsCount"] = "Количество навески",
				["Attachment"] = "Навеска",
				["NoAttachments"] = "Нет навески",
				["Attacker"] = "Атакующий",
				["Target"] = "Жертва",
				["HitPart"] = "Место попадания",
				["RecoilAngle"] = "Угол отдачи: {0}",
				["Distance"] = "Расстояние",
				["Damage"] = "Урон",
				["NRDetection"] = "Вероятное нарушение No Recoil",
				["IRDetection"] = "Нарушение In Rock",
				["DistanceToFirstPoint"] = "Расстояние до первой точки: {0}",
				["ScreenCoords"] = "Экранные координаты точки point1: {0}, экранные координаты точки point2: {1}",
				["NRViolationNum"] = "Нарушение NR #",
				["AIMViolationNum"] = "Нарушение AIMBOT #",
				["IRViolationNum"] = "Нарушение IR #",
				["AIMDetection"] = "Вероятное нарушение AIMBOT",
				["DateTime"] = "Дата/Время",
                ["MountedOn"] = "Атакующий состыкован с {0}",
				["RicochetsCount"] = "Количество рикошетов",
				["DistanceBetweenTwoPoints"] = "Расстояние между двумя точками: {0}",
				["HighPhysicsStepsDetection"] = "Обнаружено высокое значение параметра physics.steps",
				["PhysicsStepsChangeWarning"] = "Игрок {0} вероятно изменил значение параметра physics.steps на ~{1}({2}). Значение по умолчанию для physics.steps 32.\nИзменение значения этого параметра на более высокое значение позволяет игроку получить преимущества по сравнению с обычной игрой (позволяет прыгать выше).",
				["Description"] = "Описание",
				["DiscordWarning2"] = "Ошибка: Отправка отчетов в дискорд включена, только плагин DiscordMessages не загружен!",
				["DiscordWarningNR"] = "Ошибка: Отправка отчетов No Recoil в дискорд включена, только webhook дискорда для нарушения No Recoil не настроен!",
				["DiscordWarningAIM"] = "Ошибка: Отправка отчетов AIMBOT в дискорд включена, только webhook дискорда для нарушения AIMBOT не настроен!",
				["DiscordWarningIR"] = "Ошибка: Отправка отчетов In Rock в дискорд включена, только webhook дискорда для нарушения In Rock не настроен!",
                ["PlayerNRViolation"] = "<size=14><color=red><color=green>Arkan:</color> У игрока <color=yellow>{0}/{1}</color> обнаружено возможное нарушение No Recoil <color=yellow>#{2}</color>\nобщее количество выстрелов: <color=yellow>{3}</color> | количество выстрелов с низкой отдачей: <color=yellow>{4}</color>\nвероятность: <color=yellow>{5}%</color></color></size>",
				["PlayerNRViolationCon"] = "У игрока {0}/{1} обнаружено возможное нарушение No Recoil #{2}\nобщее количество выстрелов: {3} | количество выстрелов с низкой отдачей: {4}\nвероятность: {5}",
            }, this, "ru");			
        }

        #endregion Localization

        #region Initialization & Loading
		
        private void Init()
        {
            //LoadVariables();
			LoadConfig();
		
			Unsubscribe(nameof(OnPlayerAttack));
			Unsubscribe(nameof(OnMeleeThrown));
			Unsubscribe(nameof(OnProjectileRicochet));
			Unsubscribe(nameof(OnWeaponFired));
			Unsubscribe(nameof(OnEntityTakeDamage));
			Unsubscribe(nameof(OnItemPickup));
			
			if (_config.DiscordNRWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordNRReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningNR", null));
                _config.DiscordNRReportEnabled = false;
            }			

			if (_config.DiscordAIMWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordAIMReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningAIM", null));
                _config.DiscordAIMReportEnabled = false;
            }			

			if (_config.DiscordIRWebhookURL == "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" && _config.DiscordIRReportEnabled)
            {
                PrintWarning(Lang("DiscordWarningIR", null));
                _config.DiscordIRReportEnabled = false;
            }						
        }

        private void OnServerInitialized()
        {
			if (_config.isDetectNR)
				Subscribe(nameof(OnWeaponFired));
			
			if (_config.isDetectAIM)
			{
				Subscribe(nameof(OnPlayerAttack));
				Subscribe(nameof(OnMeleeThrown));
				Subscribe(nameof(OnProjectileRicochet));
				Subscribe(nameof(OnWeaponFired));
				Subscribe(nameof(OnEntityTakeDamage));	
				Subscribe(nameof(OnItemPickup));				
			}
						
            DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
            serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
            PlayersViolations.seed = ConVar.Server.seed;
            PlayersViolations.mapSize = ConVar.Server.worldsize;
            PlayersViolations.serverTimeStamp = serverTimeStamp;

            LoadViolationsData(null, null, null);
			
            Puts(Lang("InitPlgText1", null, PlayersViolations.seed, PlayersViolations.mapSize, PlayersViolations.serverTimeStamp));

            foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
				AdminLogInit(_player);	

			if ((_config.DiscordNRReportEnabled || _config.DiscordAIMReportEnabled || _config.DiscordIRReportEnabled) && DiscordMessages == null)
				PrintWarning(Lang("DiscordWarning2", null));
        }

        void OnPlayerConnected(BasePlayer player)
        {
			if (player != null)
			{
				if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, permName))
					return;
			
				AdminLogInit(player);
			}
        }

        #endregion Initialization & Loading

        #region Helpers
		
		private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
		
		public string RemoveFormatting(string source) => source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;

        #endregion Helpers

        #region Oxide Hooks

        private void Unload()
        {
            if (PlayersViolations.lastChangeTime > PlayersViolations.lastSaveTime)
                SaveViolationsData(null, null, null);
			
			PlayersFiredProjectlesData.Clear();
			AdminsConfig.Clear();
			_config.weaponsConfig.Clear();
			_config.AIMBodyParts.Clear();
			_config.IRBodyParts.Clear();
			
			_config = null;
        }

        private void Loaded()
        {
			permission.RegisterPermission(permName, this);
			permission.RegisterPermission(permNRDrawViolation, this);
			permission.RegisterPermission(permAIMDrawViolation, this);
			permission.RegisterPermission(permIRDrawViolation, this);
			permission.RegisterPermission(permNRReportChat, this);
			permission.RegisterPermission(permNRReportConsole, this);
			permission.RegisterPermission(permAIMReportChat, this);
			permission.RegisterPermission(permAIMReportConsole, this);
			permission.RegisterPermission(permIRReportChat, this);
			permission.RegisterPermission(permIRReportConsole, this);
			permission.RegisterPermission(permNRWhitelist, this);
			permission.RegisterPermission(permNRBlacklist, this);
			permission.RegisterPermission(permAIMWhitelist, this);
			permission.RegisterPermission(permAIMBlacklist, this);
			permission.RegisterPermission(permIRWhitelist, this);
			permission.RegisterPermission(permIRBlacklist, this);

            LoadViolationsData(null, null, null);
        }

        private void OnServerSave()
        {
            if (_config.autoSave && PlayersViolations.lastChangeTime > PlayersViolations.lastSaveTime)
                SaveViolationsData(null, null, null);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || info.Weapon == null)
                return;
				
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(attacker.UserIDString, permNRBlacklist) || permission.UserHasPermission(attacker.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(attacker.UserIDString, permNRWhitelist) || permission.UserHasPermission(attacker.UserIDString, permAIMWhitelist))
                    return;

            if (PlayersFiredProjectlesData.ContainsKey(attacker.userID))
            {
                if (PlayersFiredProjectlesData[attacker.userID].firedProjectiles.ContainsKey(info.ProjectileID))
                {
                    PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData.Add(new ProjectileRicochet());
                    ProjectileRicochet pr;
                    pr.projectileID = info.ProjectileID;
                    pr.hitPosition = info.HitPositionWorld;
                    pr.inVelocity = (info.PointEnd - info.PointStart) * PlayersFiredProjectlesData[attacker.userID].physicsSteps;
                    pr.outVelocity = info.ProjectileVelocity;
                    PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData[PlayersFiredProjectlesData[attacker.userID].firedProjectiles[info.ProjectileID].hitsData.Count - 1] = pr;
                }
            }

            //for development purposes only
            if (isAttackShow)
            {
                BaseMelee component = info.Weapon.GetComponent<BaseMelee>();

                FiredProjectile fp;
				
                if (component == null)
                {
					foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                        foreach (KeyValuePair<ulong, PlayerFiredProjectlesData> list in PlayersFiredProjectlesData)
                            if (PlayersFiredProjectlesData[list.Key].firedProjectiles.TryGetValue(info.ProjectileID, out fp))
                                DrawProjectileTrajectory2(_player, _config.drawTime, fp, info, Color.blue, PlayersFiredProjectlesData[list.Key].physicsSteps);
                }
            }
        }

        private void OnMeleeThrown(BasePlayer player, Item item)
        {
            if (player == null || item == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();

            if (component != null)
            {
                if (component.projectileObject != null)
                {
                    GameObject gameObject = component.projectileObject.Get();
                    if (gameObject != null)
                    {
                        Projectile component1 = gameObject.GetComponent<Projectile>();
                        if (component1 != null)
                        {
                            if (!PlayersFiredProjectlesData.ContainsKey(player.userID))
                            {
                                PlayersFiredProjectlesData.Add(player.userID, new PlayerFiredProjectlesData());
                                PlayersFiredProjectlesData[player.userID].PlayerID = player.userID;
                                PlayersFiredProjectlesData[player.userID].PlayerName = player.displayName;
                            }

                            MeleeThrown _melee = new MeleeThrown();

                            ulong meleeID = item.uid.Value;

							if (!PlayersFiredProjectlesData[player.userID].melees.ContainsKey(meleeID))
                                PlayersFiredProjectlesData[player.userID].melees.Add(meleeID, new MeleeThrown());
							else
							{
								Puts($"Error: OnMeleeThrown(), duplicate meleeID ({meleeID}), player ({player.displayName}/{player.userID})");
								return;
							}

                            _melee.firedTime = DateTime.Now;
                            _melee.projectileVelocity = component.projectileVelocity;
                            _melee.playerEyesLookAt = player.eyes.HeadForward();
                            _melee.playerEyesPosition = player.eyes.position;
							//	_melee.playerEyesPosition = player.eyes.position - player.eyes.HeadForward().normalized * (_config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness * 2f); //uncomment this line to get AIMBOT false positives for testing purposes
                            _melee.drag = component1.drag;
                            _melee.gravityModifier = component1.gravityModifier;
                            _melee.position = player.eyes.position;
							_melee.meleeShortName = item.info.shortname;
                            _melee.meleeUID = item.uid;

                            if (player.GetParentEntity() != null)
                            {
                                _melee.isMounted = true;
                                BaseEntity parentEntity = player.GetParentEntity();
                                _melee.mountParentName = parentEntity._name;
                                _melee.mountParentPosition = parentEntity.ServerPosition;
								_melee.mountParentRotation.x = parentEntity.ServerRotation.x;
								_melee.mountParentRotation.y = parentEntity.ServerRotation.y;
								_melee.mountParentRotation.z = parentEntity.ServerRotation.z;
								_melee.mountParentRotation.w = parentEntity.ServerRotation.w;
                            }

                            PlayersFiredProjectlesData[player.userID].melees[meleeID] = _melee;

                            PlayersFiredProjectlesData[player.userID].lastFiredTime = UnityEngine.Time.realtimeSinceStartup;

                            timer.Once(9f, () => CleanupExpiredProjectiles(player));
                        }
                    }
                }
            }
        }
		
		private void OnItemPickup(Item item, BasePlayer player)
		{
			if (player == null || item == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;
		
			if (PlayersFiredProjectlesData.ContainsKey(player.userID))
				if (PlayersFiredProjectlesData[player.userID].melees.ContainsKey(item.uid.Value))
					PlayersFiredProjectlesData[player.userID].melees.Remove(item.uid.Value);
		}

        private void OnProjectileRicochet(BasePlayer player, PlayerProjectileRicochet playerProjectileRicochet)
        {
            if (player == null || playerProjectileRicochet == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            if (PlayersFiredProjectlesData.ContainsKey(player.userID))
            {
                if (PlayersFiredProjectlesData[player.userID].firedProjectiles.ContainsKey(playerProjectileRicochet.projectileID))
                {
                    PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData.Add(new ProjectileRicochet());
                    ProjectileRicochet pr;
                    pr.projectileID = playerProjectileRicochet.projectileID;
                    pr.hitPosition = playerProjectileRicochet.hitPosition;
                    pr.inVelocity = playerProjectileRicochet.inVelocity;
                    pr.outVelocity = playerProjectileRicochet.outVelocity;
                    PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData[PlayersFiredProjectlesData[player.userID].firedProjectiles[playerProjectileRicochet.projectileID].hitsData.Count - 1] = pr;
                }
            }
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot)
        {
            if (player == null || projectile == null || mod == null || projectileShoot == null)
                return;
			
			if (_config.checkBlacklist)
			{
				if (!(permission.UserHasPermission(player.UserIDString, permNRBlacklist) || permission.UserHasPermission(player.UserIDString, permAIMBlacklist)))
                    return;
			}
			else
				if (permission.UserHasPermission(player.UserIDString, permNRWhitelist) || permission.UserHasPermission(player.UserIDString, permAIMWhitelist))
                    return;

            if (projectileShoot.projectiles[0] == null)
            {
                Puts(Lang("ErrorText1", player.UserIDString, player.displayName));
                return;
            }

            Item item = player.GetActiveItem();
			
			if (item == null)
                return;

            WeaponConfig _WeaponConfig;
		
            if (!_config.weaponsConfig.TryGetValue(item.info.shortname, out _WeaponConfig))
                return;

            if (!(_WeaponConfig.NRDetectEnabled || _WeaponConfig.AIMDetectEnabled))
                return;

            if (!PlayersFiredProjectlesData.ContainsKey(player.userID))
            {
                PlayersFiredProjectlesData.Add(player.userID, new PlayerFiredProjectlesData());
                PlayersFiredProjectlesData[player.userID].PlayerID = player.userID;
                PlayersFiredProjectlesData[player.userID].PlayerName = player.displayName;
            }

            float _velocity = mod.projectileVelocity;
            float NRProbabilityModifier = 1f;
            List<string> attachments = new List<string>();

            if (item.contents != null)
                foreach (Item attachment in item.contents.itemList)
                {
					if (attachment == null)
						return;
					
                    attachments.Add(attachment.info.shortname);
                    switch (attachment.info.shortname)
                    {
                        case "weapon.mod.muzzleboost":
                            _velocity -= (_velocity / 100f) * 10f;
                            break;
                        case "weapon.mod.muzzlebrake":
                            _velocity -= (_velocity / 100f) * 20f;
                            NRProbabilityModifier -= 0.1f;
                            break;
                        case "weapon.mod.silencer":
                            _velocity -= (_velocity / 100f) * 25f;
                            NRProbabilityModifier -= 0.05f;
                            break;
                    }
                }

            switch (item.info.shortname)
            {
                case "smg.2":
                    _velocity -= (_velocity / 100f) * 20f;
                    break;
                case "smg.mp5":
                    _velocity -= (_velocity / 100f) * 20f;
                    break;
                case "rifle.bolt":
                    _velocity += (_velocity / 100f) * 75f;
                    break;
                case "rifle.l96":
                    _velocity += (_velocity / 100f) * 200f;
                    break;
                case "rifle.m39":
                    _velocity += (_velocity / 100f) * 25f;
                    break;
                case "lmg.m249":
                    _velocity += (_velocity / 100f) * 30f;
                    break;
                case "crossbow":
                    _velocity += (_velocity / 100f) * 50f;
                    break;
                case "bow.compound":
                    Projectile.Modifier pm = projectile.GetProjectileModifier();
					//SendReply(player, $"bow.compound pm.distanceScale: {pm.distanceScale}, _velocity * pm.distanceScale: {_velocity * pm.distanceScale}, damageScale: {pm.damageScale}, damageOffset: {pm.damageOffset}, distanceOffset: {pm.distanceOffset}");
                    _velocity *= Mathf.Clamp(pm.distanceScale, 1f, 2f);
                    break;
            }

            if (player.modelState.aiming)
                NRProbabilityModifier -= 0.05f;

            if (player.IsDucked())
                NRProbabilityModifier -= 0.05f;

            FiredProjectile fp = new FiredProjectile();

            int projectileID = projectileShoot.projectiles[0].projectileID;

            if (!PlayersFiredProjectlesData[player.userID].firedProjectiles.ContainsKey(projectileID))
                PlayersFiredProjectlesData[player.userID].firedProjectiles.Add(projectileID, new FiredProjectile());
			else
			{
				Puts($"Error: OnWeaponFired(), duplicate projectileID ({projectileID}), player ({player.displayName}/{player.userID})");
				return;
			}	
			
			fp.firedTime = DateTime.Now;
            fp.projectileVelocity = projectileShoot.projectiles[0].startVel.normalized * _velocity;		
            fp.projectilePosition = projectileShoot.projectiles[0].startPos;
            fp.playerEyesLookAt = player.eyes.HeadForward();
            fp.playerEyesPosition = player.eyes.position;
            //	fp.playerEyesPosition = player.eyes.position - player.eyes.HeadForward().normalized * (_config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness * 2f); //uncomment this line to get AIMBOT false positives for testing purposes
            fp.weaponShortName = item.info.shortname;
            fp.weaponUID = item.uid;
            fp.ammoShortName = projectile.primaryMagazine.ammoType.shortname;
            fp.NRProbabilityModifier = NRProbabilityModifier;
            fp.attachments = attachments;

            if (player.GetParentEntity() != null)
            {
                fp.isMounted = true;
                BaseEntity parentEntity = player.GetParentEntity();
                fp.mountParentName = parentEntity.ShortPrefabName;
                fp.mountParentPosition = parentEntity.ServerPosition;
				fp.mountParentRotation.x = parentEntity.ServerRotation.x;
				fp.mountParentRotation.y = parentEntity.ServerRotation.y;
				fp.mountParentRotation.z = parentEntity.ServerRotation.z;
				fp.mountParentRotation.w = parentEntity.ServerRotation.w;
            }
			else				
				if (player.isMounted)
				{
					BaseMountable parentMount = player.GetMounted(); 
					if (parentMount != null)
					{
						BaseEntity _parentEntity = parentMount.GetParentEntity();
						if (_parentEntity != null)
						{
							fp.isMounted = true;
                            fp.mountParentName = _parentEntity.ShortPrefabName;
                            fp.mountParentPosition = _parentEntity.ServerPosition;
							fp.mountParentRotation.x = _parentEntity.ServerRotation.x;
							fp.mountParentRotation.y = _parentEntity.ServerRotation.y;
							fp.mountParentRotation.z = _parentEntity.ServerRotation.z;
							fp.mountParentRotation.w = _parentEntity.ServerRotation.w;
						}
					}
				}
			
            PlayersFiredProjectlesData[player.userID].firedProjectiles[projectileID] = fp;

            PlayersFiredProjectlesData[player.userID].lastFiredTime = UnityEngine.Time.realtimeSinceStartup;
            PlayersFiredProjectlesData[player.userID].isChecked = false;

            if (_config.isDetectNR)
				if (_config.checkBlacklist)
				{
					if (permission.UserHasPermission(player.UserIDString, permNRBlacklist))
						timer.Once(_config.NRProcessTimer, () => ProcessShots(player));
				}
				else
					if (!permission.UserHasPermission(player.UserIDString, permNRWhitelist))
                        timer.Once(_config.NRProcessTimer, () => ProcessShots(player));

            timer.Once(9f, () => CleanupExpiredProjectiles(player));
        }

        private void OnEntityTakeDamage(BasePlayer entity, HitInfo info)
        {
            if (_config.isDetectAIM || _config.isDetectIR)
            {				
                if (entity == null) return;
				
                if (info == null) return;
				
                if (info.Initiator == null) return;
				
                if (!(info.Initiator is BasePlayer)) return;
				
                BasePlayer attacker = info.Initiator.ToPlayer();
				
                if (attacker == null) return;
				
                if (attacker is NPCPlayer) return;
				
                if (IsNPC(attacker)) return;

				if (_config.checkBlacklist)
				{
					if (!permission.UserHasPermission(attacker.UserIDString, permAIMBlacklist))
						return;
				}
				else
					if (permission.UserHasPermission(attacker.UserIDString, permAIMWhitelist))
                        return;

                if (!PlayersFiredProjectlesData.ContainsKey(attacker.userID))
                    return;

                if (info.HitBone == null) return;
				
                var _bodyPart = entity?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";

                if (_bodyPart == null) return;
				
				bool isAIMBodyPart = _config.AIMBodyParts.Contains(_bodyPart);
				bool isIRBodyPart = _config.IRBodyParts.Contains(_bodyPart);
				
				if (isAIMBodyPart || isIRBodyPart)
                {
					if (info.HitEntity == null) return; 
					
                    BasePlayer target = info.HitEntity.ToPlayer();
					
                    if (target == null) return;
					
					if (!_config.isCheckAIMOnTargetNPC)
					{					
						if (target is NPCPlayer) return;
						if (IsNPC(target)) return;
					}
					
                    if (info.Weapon == null) return;

                    BaseMelee component = info.Weapon.GetComponent<BaseMelee>();
                    FiredProjectile fp = new FiredProjectile();
					bool isAttackerMount = false;
					bool isTargetMount = false;
					bool isMelee = false;
                    string attackerMountParentName = "";
					string targetMountParentName = "";

                    if (attacker.GetParentEntity() != null)
                    {
                        isAttackerMount = true;
                        BaseEntity attackerParentEntity = attacker.GetParentEntity();
                        attackerMountParentName = attackerParentEntity.ShortPrefabName;
                    }
					else				
						if (attacker.isMounted)
						{
							BaseMountable parentMount = attacker.GetMounted(); 
							if (parentMount != null)
							{
								BaseEntity _parentEntity = parentMount.GetParentEntity();
								if (_parentEntity != null)
								{
									isAttackerMount = true;
									attackerMountParentName = _parentEntity.ShortPrefabName;
								}
							}
						}

                    if (entity.GetParentEntity() != null)
                    {
                        isTargetMount = true;
                        BaseEntity targetParentEntity1 = entity.GetParentEntity();
                        targetMountParentName = targetParentEntity1.ShortPrefabName;
                    }
					else				
						if (entity.isMounted)
						{
							BaseMountable parentMount1 = entity.GetMounted(); 
							if (parentMount1 != null)
							{
								BaseEntity _parentEntity1 = parentMount1.GetParentEntity();
								if (_parentEntity1 != null)
								{
									isAttackerMount = true;
									attackerMountParentName = _parentEntity1.ShortPrefabName;
								}
							}
						}

					if (info.ProjectileID == 0)
					{
					//	Puts($"Error: info.ProjectileID = {info.ProjectileID} is zero. Attacker {attacker.UserIDString}/{attacker.userID} ");
					}
                    
					if (component != null)
                    {
						isMelee = true;

                        MeleeThrown _melee;

                        if (PlayersFiredProjectlesData[attacker.userID].melees.TryGetValue((info.Weapon.ownerItemUID.Value), out _melee))
                        {
                            fp.firedTime = _melee.firedTime;
                            //	fp.projectileVelocity = Vector3.Normalize(_melee.playerEyesLookAt) * _melee.projectileVelocity;
                            fp.projectileVelocity = Vector3.Normalize(attacker.firedProjectiles[info.ProjectileID].initialVelocity) * _melee.projectileVelocity;
                            //	fp.projectilePosition = _melee.position;
                            fp.projectilePosition = attacker.firedProjectiles[info.ProjectileID].initialPosition;
                            fp.playerEyesPosition = _melee.playerEyesPosition;
                            fp.playerEyesLookAt = _melee.playerEyesLookAt;
                            fp.ammoShortName = _melee.meleeShortName;
                            fp.weaponShortName = _melee.meleeShortName;
                            fp.weaponUID = _melee.meleeUID;
                            fp.isMounted = _melee.isMounted;
                            fp.mountParentName = _melee.mountParentName;
                            fp.mountParentPosition = _melee.mountParentPosition;
                            fp.mountParentRotation = _melee.mountParentRotation;
                        }
                        else
						{
						//	Puts($"Error: Melee info.ProjectileID = {info.ProjectileID} not found. Attacker {attacker.UserIDString}/{attacker.userID} ");
                            return;
						}
                    }
                    else
                        if (!PlayersFiredProjectlesData[attacker.userID].firedProjectiles.TryGetValue(info.ProjectileID, out fp))
						{
						//	Puts($"Error: Projectile info.ProjectileID = {info.ProjectileID} not found. Attacker {attacker.UserIDString}/{attacker.userID} ");
							return;
						}
					
					if (_config.isDetectIR && isIRBodyPart)
						if (!isAttackerMount && fp.hitsData.Count <= 1)
							ShootingInRockCheck(attacker, fp, info, _bodyPart, PlayersFiredProjectlesData[attacker.userID].physicsSteps);	
						
					if (_config.isDetectAIM && isAIMBodyPart && info.Initiator.Distance(entity.transform.position) > _config.minDistanceAIMCheck)
					{
						if (fp.hitsData.Count > 1) return; // Temporary fix for 5th March update
						
						AIMViolationData aimvd = new AIMViolationData();
						bool AIMViolation = false;
						List<TrajectorySegment> trajectorySegments = new List<TrajectorySegment>();
						List<TrajectorySegment> trajectorySegmentsRev = new List<TrajectorySegment>();
						
						if (isMelee)
							aimvd.forgivenessModifier = 1.5f;

                        if (attacker.HasFiredProjectile(info.ProjectileID))
                        {
                            aimvd.firedProjectileFiredTime = attacker.firedProjectiles[info.ProjectileID].firedTime;
                            aimvd.firedProjectileTravelTime = attacker.firedProjectiles[info.ProjectileID].travelTime;
                            aimvd.firedProjectilePosition = attacker.firedProjectiles[info.ProjectileID].position;
                            aimvd.firedProjectileVelocity = attacker.firedProjectiles[info.ProjectileID].velocity;
                            aimvd.firedProjectileInitialPosition = attacker.firedProjectiles[info.ProjectileID].initialPosition;
                            aimvd.firedProjectileInitialVelocity = attacker.firedProjectiles[info.ProjectileID].initialVelocity;
                            aimvd.hasFiredProjectile = true;
                
                            if (fp.weaponShortName == "bow.compound")
                                if (attacker.firedProjectiles[info.ProjectileID].initialVelocity.magnitude - fp.projectileVelocity.magnitude < (attacker.firedProjectiles[info.ProjectileID].initialVelocity.magnitude / 100f) * 10f)
                                    fp.projectileVelocity = attacker.firedProjectiles[info.ProjectileID].initialVelocity;
                
                            if (!(attacker.firedProjectiles[info.ProjectileID].initialPosition == fp.projectilePosition) && !(attacker.firedProjectiles[info.ProjectileID].initialVelocity == fp.projectileVelocity))
                            {
                                aimvd.isEqualFiredProjectileData = false;
                                AIMViolation = true;
                            }
                        }
                        else
                        {
                            Puts(Lang("ErrorText2", null, attacker.displayName, target.displayName, info.ProjectileID));
                            return;
                        }
                
                        if (fp.hitsData.Count > 0 && fp.hitsData[fp.hitsData.Count - 1].hitPosition == info.HitPositionWorld)
                            fp.hitsData.RemoveAt(fp.hitsData.Count - 1);
                
                        HitData hitData = new HitData();
                        hitData.startProjectilePosition = fp.projectilePosition;
                        hitData.startProjectileVelocity = fp.projectileVelocity;
                        hitData.hitPositionWorld = info.HitPositionWorld;
                        hitData.hitPointStart = info.PointStart;
                        hitData.hitPointEnd = info.PointEnd;
                
                        aimvd.hitsData.Add(hitData);
                
                        if (fp.hitsData.Count > 0)
                            for (int i = 0; i < fp.hitsData.Count; i++)
                            {
                                hitData = new HitData();
                                hitData.hitData = fp.hitsData[i];
                
                                hitData.startProjectilePosition = fp.hitsData[i].hitPosition;
                                hitData.startProjectileVelocity = fp.hitsData[i].outVelocity;
                                hitData.hitPositionWorld = info.HitPositionWorld;
                                hitData.hitPointStart = info.PointStart;
                                hitData.hitPointEnd = info.PointEnd;
                                aimvd.hitsData.Add(hitData);
                                aimvd.hitsData[i].hitPositionWorld = fp.hitsData[i].hitPosition;
                                aimvd.hitsData[i].hitPointStart = fp.hitsData[i].hitPosition - (fp.hitsData[i].inVelocity / PlayersFiredProjectlesData[attacker.userID].physicsSteps);
                                aimvd.hitsData[i].hitPointEnd = fp.hitsData[i].hitPosition;
                            }
							
						if (fp.ammoShortName.Contains("arrow."))
							aimvd.forgivenessModifier = 1.5f;
						
						aimvd.physicsSteps = PlayersFiredProjectlesData[attacker.userID].physicsSteps;
						
                        AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, info.ProjectilePrefab.gravityModifier, info.ProjectilePrefab.drag);
						
						if (AIMViolation && aimvd.hitsData.Count == 1 && trajectorySegments.Count > 0 && trajectorySegmentsRev.Count > 0)
						{
							float lengthLastSegmentProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].lastSegmentPointEnd, aimvd.hitsData[0].lastSegmentPointStart);
							float lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].hitPointEnd, aimvd.hitsData[0].hitPointStart);
							
							Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointStart);
							Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointEnd);
                
							if (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[0].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[0].hitPointEnd)) > 0.05f)
							{
								HitData hitData1 = new HitData();
								HitData hitData2 = new HitData();
								if (IsRicochet(trajectorySegments, trajectorySegmentsRev, out hitData1, out hitData2, aimvd.physicsSteps))
								{
									hitData1.startProjectilePosition = aimvd.hitsData[0].startProjectilePosition;
									hitData1.startProjectileVelocity = aimvd.hitsData[0].startProjectileVelocity;
                        
									hitData2.hitPositionWorld = info.HitPositionWorld;
									hitData2.hitPointStart = info.PointStart;
									hitData2.hitPointEnd = info.PointEnd;	
														
									aimvd.hitsData.Clear();
							
									aimvd.hitsData.Add(hitData1);
									aimvd.hitsData.Add(hitData2);
                      
									AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, info.ProjectilePrefab.gravityModifier, info.ProjectilePrefab.drag);
								}							
							}
						}
						
						if (!AIMViolation && Mathf.Abs(PlayersFiredProjectlesData[attacker.userID].physicsSteps - aimvd.physicsSteps) > PlayersFiredProjectlesData[attacker.userID].physicsSteps * 0.063f)
						{
							if (_config.notifyPhysicsStepsWarning)
							{
								if (aimvd.physicsSteps > _config.minPhysicsStepsAllowed)
								{
									if (_config.DiscordAIMReportEnabled)
										if (DiscordMessages == null)
											PrintWarning(Lang("DiscordWarning2", null));
										else
										{
											List<EmbedFieldList> fields = new List<EmbedFieldList>();
											
											string dmAttacker = $"[{attacker.displayName}\n{attacker.UserIDString}](https://steamcommunity.com/profiles/{attacker.UserIDString})";
											if (dmAttacker.Length == 0) dmAttacker = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("PlayerTxt", null),
												inline = true,
												value = dmAttacker
											});
											
											string dmPhysicsSteps = $"{aimvd.physicsSteps}({Mathf.Round(aimvd.physicsSteps)})";
											if (dmPhysicsSteps.Length == 0) dmPhysicsSteps = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = "physics.steps",
												inline = true,
												value = dmPhysicsSteps
											});	
                        
											string dmDescription = Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps));
											if (dmDescription.Length == 0) dmDescription = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("Description", null),
												inline = false,
												value = dmDescription
											});	
                        
											var fieldsObject = fields.Cast<object>().ToArray();
											
											string json = JsonConvert.SerializeObject(fieldsObject);

											DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordAIMWebhookURL, "Arkan: " + Lang("HighPhysicsStepsDetection", null), 39423, json);
										}
										
									foreach (var _player in BasePlayer.activePlayerList.Where(x => permission.UserHasPermission(x.UserIDString, permName) && x.IsAdmin))
									{	
										if (permission.UserHasPermission(_player.UserIDString, permAIMReportChat))
											SendReply(_player, "<color=green>Arkan: </color>" + "<color=red>" + Lang("HighPhysicsStepsDetection", _player.UserIDString) + "\n" + Lang("PhysicsStepsChangeWarning", null, "<color=yellow>" + attacker.displayName + "/" + attacker.UserIDString + "</color>", $"<color=yellow>{aimvd.physicsSteps}</color>", $"<color=yellow>{Mathf.Round(aimvd.physicsSteps)}</color>") + "</color>");
										
										if (permission.UserHasPermission(_player.UserIDString, permAIMReportConsole))
											_player.ConsoleMessage("<color=green>Arkan: </color>" + "<color=red>" + Lang("HighPhysicsStepsDetection", _player.UserIDString) + "</color>\n" + Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps)));
									}
								
									Puts(Lang("PhysicsStepsChangeWarning", null, attacker.displayName + "/" + attacker.UserIDString, aimvd.physicsSteps, Mathf.Round(aimvd.physicsSteps)));
								}
							}													
							PlayersFiredProjectlesData[attacker.userID].physicsSteps = aimvd.physicsSteps;
						}
						
                        if (Vector3.Distance(fp.playerEyesPosition, fp.projectilePosition) > _config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness)// && !fp.isMounted)
                        {
                            AIMViolation = true;
                            aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation = true;
                            aimvd.distanceDifferenceViolation = Vector3.Distance(fp.playerEyesPosition, fp.projectilePosition);
                        }
                
                        if (AIMViolation)
                        {
                            aimvd.projectileID = info.ProjectileID;
							aimvd.firedTime = fp.firedTime;
                            aimvd.startProjectilePosition = fp.projectilePosition;
                            aimvd.startProjectileVelocity = fp.projectileVelocity;
                            aimvd.weaponShortName = fp.weaponShortName;
                            aimvd.ammoShortName = fp.ammoShortName;
                            aimvd.hitInfoInitiatorPlayerName = info.Initiator.ToPlayer().displayName;
                            aimvd.hitInfoInitiatorPlayerUserID = info.Initiator.ToPlayer().userID.ToString();
                            aimvd.hitInfoHitEntityPlayerName = info.HitEntity.ToPlayer().displayName;
                            aimvd.hitInfoHitEntityPlayerUserID = info.HitEntity.ToPlayer().userID.ToString();
                            aimvd.hitInfoBoneName = info.boneName;
                            aimvd.hitInfoHitPositionWorld = info.HitPositionWorld;
                            aimvd.hitInfoProjectileDistance = info.ProjectileDistance;
                            aimvd.hitInfoPointStart = info.PointStart;
                            aimvd.hitInfoPointEnd = info.PointEnd;
                            aimvd.hitInfoProjectilePrefabGravityModifier = info.ProjectilePrefab.gravityModifier;
                            aimvd.hitInfoProjectilePrefabDrag = info.ProjectilePrefab.drag;
                            aimvd.isAttackerMount = isAttackerMount;
                            aimvd.isTargetMount = isTargetMount;
                            aimvd.attackerMountParentName = attackerMountParentName;
                            aimvd.targetMountParentName = targetMountParentName;
                            aimvd.bodyPart = _bodyPart;
                            aimvd.damage = info.damageTypes.Total();
                            aimvd.gravityModifier = info.ProjectilePrefab.gravityModifier;
                            aimvd.drag = info.ProjectilePrefab.drag;
                            aimvd.playerEyesLookAt = fp.playerEyesLookAt;
                            aimvd.playerEyesPosition = fp.playerEyesPosition;
							aimvd.attachments = fp.attachments;
							
                            if (PlayersViolations.Players.ContainsKey(attacker.userID))
                                aimvd.violationID = PlayersViolations.Players[attacker.userID].AIMViolations.Count + 1;
                            else
                                aimvd.violationID = 1;
                
                            AddAIMViolationToPlayer(attacker, aimvd);
							
							int AIMViolationsCnt = PlayersViolations.Players[attacker.userID].AIMViolations.Count;
				
							if (Interface.CallHook("API_ArkanOnAimbotViolation", attacker, AIMViolationsCnt, JsonConvert.SerializeObject(aimvd)) != null)
							{
								return;
							}
                
							foreach (var _player in BasePlayer.activePlayerList.Where(x => permission.UserHasPermission(x.UserIDString, permName) && x.IsAdmin))
							{	
								if (permission.UserHasPermission(_player.UserIDString, permAIMReportChat))
									SendReply(_player, Lang("PlayerAIMViolation", _player.UserIDString, attacker.displayName, attacker.userID, PlayersViolations.Players[attacker.userID].AIMViolations.Count, target.displayName, target.userID));
								
								if (permission.UserHasPermission(_player.UserIDString, permAIMReportConsole))
									_player.ConsoleMessage("<color=green>Arkan:</color> " + Lang("PlayerAIMViolationCon", _player.UserIDString, attacker.displayName, attacker.userID, PlayersViolations.Players[attacker.userID].AIMViolations.Count, target.displayName, target.userID));
							}
							
                            if (_config.debugMessages)
                            {
                                string txt = Lang("AIMText1", null);
								string txt1 = "";
								string logTxt = "";
								Dictionary<int, string> logList = new Dictionary<int, string>();
                
                                txt += Lang("Attacker", null) + ": " + (aimvd.hitInfoInitiatorPlayerName ?? aimvd.hitInfoInitiatorPlayerUserID) + "\n" + Lang("AIMViolationNum", null) + PlayersViolations.Players[attacker.userID].AIMViolations.Count + "\n" + Lang("Weapon", null) + ": " + aimvd.weaponShortName + "\n" + Lang("Ammo", null) + ": " + aimvd.ammoShortName + "\n" + Lang("Distance", null) + ": " + aimvd.hitInfoProjectileDistance + "\n";
                                txt += Lang("Target", null) + ": " + (aimvd.hitInfoHitEntityPlayerName ?? aimvd.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", null) + ": " + aimvd.hitInfoBoneName + "\n";
								txt += Lang("DateTime", null) + ": " + aimvd.firedTime + "\n\n";
								
								if (aimvd.isAttackerMount && aimvd.attackerMountParentName != null)
									txt += Lang("MountedOn", null, aimvd.attackerMountParentName) + "\n\n";
								
								txt += Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count + "\n";
                
								if (aimvd.attachments.Count > 0)
									for (int ii = 0; ii < aimvd.attachments.Count; ii++)
										txt += Lang("Attachment", null) + " - " + aimvd.attachments[ii] + "\n";
									
                                txt += Lang("RicochetsCount", null) + " = " + (aimvd.hitsData.Count - 1) + "\n";
                                txt += $"isEqualFiredProjectileData = {aimvd.isEqualFiredProjectileData}\n";
                                txt += $"isPlayerPositionToProjectileStartPositionDistanceViolation = {aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
								
								logTxt = $"isEqualFiredProjectileData = {aimvd.isEqualFiredProjectileData}\nisPlayerPositionToProjectileStartPositionDistanceViolation = {aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
                                
								if (aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation)
								{
                                    txt += Lang("LogText6", null, aimvd.distanceDifferenceViolation);
									logTxt += Lang("LogText6", null, aimvd.distanceDifferenceViolation);
								}
                
                                for (int j = 0; j < aimvd.hitsData.Count; j++)
                                {
                                    txt += $"-\n" + Lang("LogText7", null, j + 1) + "\n";
                                    txt1 = $"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}\n";
                                    
									if (!aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && aimvd.hitsData[j].side > 0)
                                        if (aimvd.hitsData[j].side == 1)
                                            txt1 += "     " + Lang("AIMText4", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", null), "StartPoint", Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, aimvd.hitsData[j].hitPointStart)) + "\n";
                                        else
                                            txt1 += "     " + Lang("AIMText4", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", null), "EndPoint", Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, aimvd.hitsData[j].hitPointEnd)) + "\n";
                                    
									txt1 += $"isHitPointOnProjectileTrajectory = {aimvd.hitsData[j].isHitPointOnProjectileTrajectory}\n";
                
                                    txt1 += $"isProjectileStartPointAtEndReverseProjectileTrajectory = {aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}\n";
                                    
									if (!aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
                                        txt1 += "     " + Lang("AIMText6", null, aimvd.hitsData[j].lastSegmentPointStart, aimvd.hitsData[j].lastSegmentPointEnd, aimvd.hitsData[j].startProjectilePosition, aimvd.hitsData[j].startProjectilePosition + aimvd.hitsData[j].startProjectileVelocity);
                
                                    txt1 += $"isHitPointNearProjectilePlane = {aimvd.hitsData[j].isHitPointNearProjectilePlane}\n";
                                    
									if (!aimvd.hitsData[j].isHitPointNearProjectilePlane)
                                        txt1 += "     " + Lang("AIMText7", null, aimvd.hitsData[j].distanceFromHitPointToProjectilePlane);
                
                                    txt1 += $"isLastSegmentOnProjectileTrajectoryPlane = {aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}\n";
                                    
									if (!aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
                                        txt1 += "     " + Lang("AIMText8", null, aimvd.hitsData[j].lastSegmentPointStart, aimvd.hitsData[j].startProjectilePosition, aimvd.hitsData[j].startProjectilePosition + aimvd.hitsData[j].startProjectileVelocity);
                
                                    txt += txt1 + Lang("LogText8", null, j + 1) + "\n";
									
									logList.Add(logList.Count, txt1);
                                }
                
                                Puts(txt);
								
								if (_config.DiscordAIMReportEnabled)
									if (DiscordMessages == null)
										PrintWarning(Lang("DiscordWarning2", null));
									else
									{
										List<EmbedFieldList> fields = new List<EmbedFieldList>();
										
										string dmAttacker = $"[{attacker.displayName}\n{attacker.UserIDString}](https://steamcommunity.com/profiles/{attacker.UserIDString})";
										if (dmAttacker.Length == 0) dmAttacker = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Attacker", null),
											inline = true,
											value = dmAttacker
										});
										
										string dmAIMViolationNum = $"{PlayersViolations.Players[attacker.userID].AIMViolations.Count}";
										if (dmAIMViolationNum.Length == 0) dmAIMViolationNum = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("AIMViolationNum", null),
											inline = true,
											value = dmAIMViolationNum
										});	
										
										string dmDateTime = $"{aimvd.firedTime}";
										if (dmDateTime.Length == 0) dmDateTime = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("DateTime", null),
											inline = true,
											value = dmDateTime
										});	
                
										string dmWeapon = $"{aimvd.weaponShortName}";
										if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Weapon", null),
											inline = true,
											value = dmWeapon
										});	
                
										string dmAmmo = $"{aimvd.ammoShortName}";
										if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Ammo", null),
											inline = true,
											value = dmAmmo
										});
										
										if (aimvd.attachments.Count == 0)
										{
											fields.Add(new EmbedFieldList()
											{
												name = Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count,
												inline = true,
												value = Lang("NoAttachments", null)
											});
										}
										else
										{
											string dmAttachmentsList = "";
											for (int j = 0; j < aimvd.attachments.Count; j++)
												dmAttachmentsList += aimvd.attachments[j] + "\n";
											
											if (dmAttachmentsList.Length == 0) dmAttachmentsList = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("AttachmentsCount", null) + " = " + aimvd.attachments.Count,
												inline = true,
												value = dmAttachmentsList
											});
										}
										
										string targetVal = "";
										if (IsNPC(target))
											targetVal = aimvd.hitInfoHitEntityPlayerName ?? aimvd.hitInfoHitEntityPlayerUserID;
										else
											targetVal = $"[{target.displayName}](https://steamcommunity.com/profiles/{target.UserIDString})";										
                
										if (targetVal.Length == 0) targetVal = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Target", null),
											inline = true,
											value = targetVal
										});	
                
										string dmHitPart = $"{aimvd.hitInfoBoneName}";
										if (dmHitPart.Length == 0) dmHitPart = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("HitPart", null),
											inline = true,
											value = dmHitPart
										});											
                
										string dmDistance = $"{aimvd.hitInfoProjectileDistance}";
										if (dmDistance.Length == 0) dmDistance = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("Distance", null),
											inline = true,
											value = dmDistance
										});	
										
										string dmRicochetsCount = $"{aimvd.hitsData.Count - 1}";
										if (dmRicochetsCount.Length == 0) dmRicochetsCount = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("RicochetsCount", null),
											inline = false,
											value = dmRicochetsCount
										});	
										
										if (logTxt.Length == 0) logTxt = stringNullValueWarning;
										fields.Add(new EmbedFieldList()
										{
											name = Lang("VDataLog", null),
											inline = false,
											value = logTxt
										});		
										
										string dmLogData = "";
										for (int k = 0; k < logList.Count; k++)
										{
											dmLogData = logList[k];
											if (dmLogData.Length == 0) dmLogData = stringNullValueWarning;
											fields.Add(new EmbedFieldList()
											{
												name = Lang("LogText7", null, k + 1),
												inline = false,
												value = dmLogData
											});				
											
											fields.Add(new EmbedFieldList()
											{
												name = Lang("LogText8", null, k + 1),
												inline = false,
												value = "-"
											});			
										}
								
										var fieldsObject = fields.Cast<object>().ToArray();
										
										string json = JsonConvert.SerializeObject(fieldsObject);

										DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordAIMWebhookURL, "Arkan: " + Lang("AIMDetection", null), 39423, json);
									}
                
                                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName) && permission.UserHasPermission(x.UserIDString, permAIMDrawViolation)))
                                {
                                    DrawProjectileTrajectory(_player, _config.drawTime, aimvd, Color.blue);
                                    DrawReverseProjectileTrajectory(_player, _config.drawTime, aimvd, Color.green);
                
                                    if (aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation)
                                    {
                                        DDrawSphereToAdmin(_player, _config.drawTime, Color.red, aimvd.playerEyesPosition, 0.05f);
                                        DDrawTextToAdmin(_player, _config.drawTime, Color.cyan, aimvd.playerEyesPosition + Vector3.up, Lang("DrawAIMVD5", null, aimvd.hitInfoInitiatorPlayerName ?? aimvd.hitInfoInitiatorPlayerUserID, aimvd.violationID, aimvd.playerEyesPosition, aimvd.startProjectilePosition, Vector3.Distance(aimvd.playerEyesPosition, aimvd.startProjectilePosition)));
										DDrawArrowToAdmin(_player, _config.drawTime, Color.red, aimvd.playerEyesPosition, aimvd.playerEyesPosition + aimvd.playerEyesLookAt.normalized, 0.05f);
									}
                                }
                            }
                        }
					}
                }               
            }
        }
		
        #endregion Hooks

        #region Config
		
		protected override void LoadConfig()
		{
		    base.LoadConfig();
		    try
		    {
		        _config = Config.ReadObject<Configuration>();
		        if (_config == null) throw new Exception();
		        SaveConfig();
            }
		    catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
            }
		}
        
		protected override void SaveConfig() => Config.WriteObject(_config);

		protected override void LoadDefaultConfig() => _config = new Configuration();	
		
        #endregion Config

        #region Commands

		[ConsoleCommand("arkan")]
		private void ConsoleShowLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                if (PlayersViolations.Players.Count > 0)
                {
					string txtConsole = RemoveFormatting(Lang("ShowLog2", null));
					
                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
					{
						txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} -";
						
						if (PlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
							txtConsole += $" NR({PlayersViolations.Players[list.Key].noRecoilViolations.Count})";
						
						if (PlayersViolations.Players[list.Key].AIMViolations.Count > 0)
							txtConsole += $" AIM({PlayersViolations.Players[list.Key].AIMViolations.Count})";
						
						if (PlayersViolations.Players[list.Key].inRockViolations.Count > 0)
							txtConsole += $" IR({PlayersViolations.Players[list.Key].inRockViolations.Count})";

						txtConsole += "; ";
					}
					
					Puts(txtConsole);
                }
                else
					Puts(RemoveFormatting(Lang("ShowLog3")));
			}
		}
		
		[ConsoleCommand("arkan.nr")]
		private void ConsoleShowNoRecoilLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int nrCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].noRecoilViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - NR({PlayersViolations.Players[list.Key].noRecoilViolations.Count}); ";   
							
							nrCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (nrCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowNRLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog = new AdminConfig();
                    }
                    else
                        s = arg.Args[1];
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;
        
                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                {
                    if (PlayersViolations.Players[playerID].noRecoilViolations.Count == 0)
						txtConsole += Lang("ShowNRD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                    else
                    {
						if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                        {
							RconLog.violationsLog.NoRecoilViolation = 1;
							RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                        }
                        else
                            if (s == null)
								if (PlayersViolations.Players[playerID].noRecoilViolations.Count >= RconLog.violationsLog.NoRecoilViolation + 1)
									RconLog.violationsLog.NoRecoilViolation++;
                                else
                                {
									txtConsole += Lang("NoMoreViolations", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
									RconLog.violationsLog = new ViolationsLog();
									Puts(txtConsole);
                                    return;
                                }
        
                        int result;
                        int.TryParse(s, out result);
        
                        if (result == 0)
                            result = RconLog.violationsLog.NoRecoilViolation;
        
                        int i = 1;
                        foreach (KeyValuePair<string, NoRecoilViolationData> list in PlayersViolations.Players[playerID].noRecoilViolations)
                        {
                            if (i == result)
                            {
                                NoRecoilViolationData violationData = PlayersViolations.Players[playerID].noRecoilViolations[list.Key];

								txtConsole += "\n" + Lang("PlayerTxt", null) + " " + PlayersViolations.Players[playerID].PlayerName + "\n" + Lang("NRViolationNum", null) + result + "\n" + Lang("ShotsCount", null) + " " + violationData.ShotsCnt + "\n" + Lang("Probability", null) + " " + violationData.violationProbability + "%\n";
								if (violationData.suspiciousNoRecoilShots.ContainsKey(1))
									txtConsole += Lang("DateTime", null) + ": " + violationData.suspiciousNoRecoilShots[1].timeStamp + "\n\n";
								txtConsole += Lang("AttachmentsCount", null) + " = " + violationData.attachments.Count + "\n";
        
                                if (violationData.attachments.Count > 0)
                                    for (int ii = 0; ii < violationData.attachments.Count; ii++)
										txtConsole += Lang("Attachment", null) + " - " + violationData.attachments[ii] + "\n";

								txtConsole += Lang("Weapon", null) + " - " + violationData.weaponShortName + "\n";
								txtConsole += Lang("Ammo", null) + " - " + violationData.ammoShortName + "\n";
								txtConsole += Lang("Probability", null) + " - " + violationData.violationProbability + "%\n";
        
                                int j = 1;
								
                                foreach (KeyValuePair<int, SuspiciousProjectileData> suspiciusProjectile in violationData.suspiciousNoRecoilShots.ToArray())
                                {
                                    SuspiciousProjectileData sp = violationData.suspiciousNoRecoilShots[suspiciusProjectile.Key];
                                    if (sp.isNoRecoil)
                                    {
                                        if (sp.isShootedInMotion)
											txtConsole += Lang("ProjectileID", null, sp.projectile2ID) + " | " + Lang("ShootingOnMove", null) +  " | " + Lang("ClosestPoint", null, sp.closestPointLine1, sp.closestPointLine2, sp.prevIntersectionPoint) + " | " + Lang("FireTimeInterval", null, sp.timeInterval) + "\n";
                                        else
											txtConsole += Lang("ProjectileID", null, sp.projectile2ID) + " | " + Lang("StandingShooting", null) + " | " + Lang("RecoilAngle", null, sp.recoilAngle) + " | " + Lang("FireTimeInterval", null, sp.timeInterval) + "\n";
                                    }
                                    j++;
                                }

								txtConsole += "\n\n.";
                                break;
                            }
                            i++;
                        }
                    }
                }
				Puts(txtConsole);
			}
		}

		[ConsoleCommand("arkan.aim")]
		private void ConsoleShowAIMLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int aimCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - AIM({PlayersViolations.Players[list.Key].AIMViolations.Count}); ";   
							
							aimCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (aimCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowAIMLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                {
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog.violationsLog = new ViolationsLog();
                    }
                    else
                        s = arg.Args[1];
                }
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;

                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                    if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
						txtConsole += Lang("ShowAIMD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                else
                {
					if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
						RconLog.violationsLog.AIMViolation = 1;
						RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    }
                    else if (s == null)
                        if (PlayersViolations.Players[playerID].AIMViolations.Count >= RconLog.violationsLog.AIMViolation + 1)
							RconLog.violationsLog.AIMViolation++;
                        else
                        {
							txtConsole += Lang("ShowD3", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
							RconLog.violationsLog = new ViolationsLog();
							Puts(txtConsole);
                            return;
                        }
        
                    int result;
                    int.TryParse(s, out result);
        
                    if (result == 0)
						result = RconLog.violationsLog.AIMViolation;
        
                    int i = 1;
                    
					foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                    {
                        if (i == result)
                        {
							AIMViolationData violationData = PlayersViolations.Players[playerID].AIMViolations[list.Key];

							txtConsole += Lang("Attacker", null) + ": " + (violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID) + "\n" + Lang("AIMViolationNum", null) + violationData.violationID + "\n" + Lang("Weapon", null) + ": " + violationData.weaponShortName + "\n" + Lang("Ammo", null) + ": " + violationData.ammoShortName + "\n" + Lang("Distance", null) + ": " + violationData.hitInfoProjectileDistance + "\n";
							txtConsole += Lang("Target", null) + ": " + (violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", null) + ": " + violationData.hitInfoBoneName + "\n";
							txtConsole += Lang("DateTime", null) + ": " + violationData.firedTime + "\n\n";
							
							txtConsole += Lang("AttachmentsCount", null) + " = " + violationData.attachments.Count + "\n";
    
                            if (violationData.attachments.Count > 0)
                                for (int ii = 0; ii < violationData.attachments.Count; ii++)
									txtConsole += Lang("Attachment", null) + " - " + violationData.attachments[ii] + "\n";
							
							if (violationData.isAttackerMount && violationData.attackerMountParentName != null)
								txtConsole += Lang("MountedOn", null, violationData.attackerMountParentName) + "\n\n";
                            
							txtConsole += Lang("RicochetsCount", null) + " + " + (violationData.hitsData.Count - 1) + "\n\n";
							txtConsole += $"isEqualFiredProjectileData = {violationData.isEqualFiredProjectileData}\n";
							txtConsole += $"isPlayerPositionToProjectileStartPositionDistanceViolation = {violationData.isPlayerPositionToProjectileStartPositionDistanceViolation}\n";
                            
							if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
								txtConsole += Lang("LogText6", null, violationData.distanceDifferenceViolation);
    
                            for (int j = 0; j < violationData.hitsData.Count; j++)
                            {
								txtConsole += $".\n" + Lang("LogText7", null, j + 1) + "\n";
								txtConsole += $"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}" + "\n";
                                
								if (!violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && violationData.hitsData[j].side > 0)
                                    if (violationData.hitsData[j].side == 1)
										txtConsole += "     " + Lang("AIMText4", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", null), "StartPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointStart)) + "\n";
                                    else
										txtConsole += "     " + Lang("AIMText4", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", null), "EndPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointEnd)) + "\n";
    
								txtConsole += $"isHitPointOnProjectileTrajectory = {violationData.hitsData[j].isHitPointOnProjectileTrajectory}" + "\n";
								txtConsole += $"isProjectileStartPointAtEndReverseProjectileTrajectory = {violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}" + "\n";
                                
								if (!violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
									txtConsole += "     " + Lang("AIMText6", null, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].lastSegmentPointEnd, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity) + "\n";
    
								txtConsole += $"isHitPointNearProjectilePlane = {violationData.hitsData[j].isHitPointNearProjectilePlane}" + "\n";
                                
								if (!violationData.hitsData[j].isHitPointNearProjectilePlane)
									txtConsole += "     " + Lang("AIMText7", null, violationData.hitsData[j].distanceFromHitPointToProjectilePlane) + "\n";
    
								txtConsole += $"isLastSegmentOnProjectileTrajectoryPlane = {violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}" + "\n";
                                
								if (!violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
									txtConsole += "     " + Lang("AIMText8", null, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity) + "\n";
    
								txtConsole += Lang("LogText8", null, j + 1) + "\n";
                            }
    
							txtConsole += "\n.";				
							
                            break;
                        }
                        i++;
                    }
                }
				Puts(txtConsole);
			}
		}

		[ConsoleCommand("arkan.ir")]
		private void ConsoleShowInRockLog(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();
			string txtConsole = "";

			if (player == null)
			{
				if (!arg.HasArgs())
				{
					txtConsole = RemoveFormatting(Lang("ShowNRLog2", null));
                    int nrCnt = 0;
					
					if (PlayersViolations.Players.Count > 0)
					{
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].inRockViolations.Count > 0)))
						{
							txtConsole += $"{PlayersViolations.Players[list.Key].PlayerName} - IR({PlayersViolations.Players[list.Key].inRockViolations.Count}); ";
							
							nrCnt++;
						}

						Puts(txtConsole);
					}	
					
					if (nrCnt == 0)
                        Puts(RemoveFormatting(Lang("ShowIRLog3", null)));

					return;
				}
				
                string s = null;
				txtConsole = "";
                ulong id = 0;
				ulong playerID = 0;
        
                if (arg.Args.Length == 2)
                    if (arg.Args[1] == "0")
                    {
						txtConsole += Lang("ShowD1", null) + "\n";
						RconLog = new AdminConfig();
                    }
                    else
                        s = arg.Args[1];
        
                string user = arg.Args[0];
        
                if (user.Contains("765"))
                    ulong.TryParse(arg.Args[0], out id);
        
                foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                    if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                        playerID = PlayersViolations.Players[list.Key].PlayerID;
        
                if (playerID == 0)
					txtConsole += Lang("ShowD2", null) + "\n";
                else
                {
                    if (PlayersViolations.Players[playerID].inRockViolations.Count == 0)
						txtConsole += Lang("ShowIRD1", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
                    else
                    {
						if ((long)RconLog.violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                        {
							RconLog.violationsLog.InRockViolation = 1;
							RconLog.violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                        }
                        else
                            if (s == null)
								if (PlayersViolations.Players[playerID].inRockViolations.Count >= RconLog.violationsLog.InRockViolation + 1)
									RconLog.violationsLog.InRockViolation++;
                                else
                                {
									txtConsole += Lang("NoMoreViolations", null, PlayersViolations.Players[playerID].PlayerName) + "\n";
									RconLog.violationsLog = new ViolationsLog();
									Puts(txtConsole);
                                    return;
                                }

                        int result;
                        int.TryParse(s, out result);
        
                        if (result == 0)
                            result = RconLog.violationsLog.InRockViolation;
        
                        int i = 1;
                        foreach (KeyValuePair<string, InRockViolationsData> list in PlayersViolations.Players[playerID].inRockViolations)
                        {
                            if (i == result)
                            {
                                InRockViolationsData violationData = PlayersViolations.Players[playerID].inRockViolations[list.Key];

								txtConsole += "\n" + Lang("Attacker", null) + ": " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID + "\n" + Lang("IRViolationNum", null) + result + "\n" + Lang("Weapon", null) + ": " + violationData.inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", null) + ": " + violationData.inRockViolationsData[1].firedProjectile.ammoShortName + "\n" + Lang("ShotsCount", null) + ": " + violationData.inRockViolationsData.Count + "\n";

								for (int j = 1; j <= violationData.inRockViolationsData.Count; j++)
								{
									txtConsole += Lang("ProjectileID", null, j) + " | " + Lang("Target", null) + ": " + violationData.inRockViolationsData[j].targetName + "/" + violationData.inRockViolationsData[j].targetID + " | " + Lang("HitPart", null) + ": " + violationData.inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", null) + ": " + violationData.inRockViolationsData[j].targetDamage;
								}
                                break;
                            }
                            i++;
                        }
                    }
                }
				Puts(txtConsole);
			}
		}
		
		[ConsoleCommand("arkan.clear")]
		private void ConsoleClearViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
				PlayersViolations.Players.Clear();
                DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
                PlayersViolations.seed = ConVar.Server.seed;
                PlayersViolations.mapSize = ConVar.Server.worldsize;
                PlayersViolations.serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
        
                foreach (KeyValuePair<BasePlayer, AdminConfig> list in AdminsConfig)
                    AdminsConfig[list.Key].violationsLog = new ViolationsLog();
        
                SaveViolationsData(null, null, null);
				Puts(RemoveFormatting(Lang("ClearVD", null)));
			}
		}		
		
		[ConsoleCommand("arkan.save")]
		private void ConsoleSaveViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                string fileName = serverTimeStamp;
        
                if (arg.HasArgs(1))
                    fileName = arg.Args[0];
        
                PlayersViolations.lastSaveTime = DateTime.Now;
                Interface.Oxide.DataFileSystem.WriteObject("Arkan/" + fileName, PlayersViolations);

				Puts(RemoveFormatting(Lang("SaveVD1", null, fileName)));
			}
		}			

		[ConsoleCommand("arkan.load")]
		private void ConsoleLoadViolationsData(ConsoleSystem.Arg arg)
        {			
			var player = arg.Player();

			if (player == null)
			{
                string fileName = serverTimeStamp;
        
                if (arg.HasArgs(1))
                    fileName = arg.Args[0];
        
                if (Interface.Oxide.DataFileSystem.ExistsDatafile("Arkan/" + fileName))
                {
                    tmpPlayersViolations = null;
                    tmpPlayersViolations = Interface.Oxide.DataFileSystem.ReadObject<PlayersViolationsData>("Arkan/" + fileName);
					
                    if (tmpPlayersViolations.seed != ConVar.Server.seed)
                    {
                        Puts(Lang("LoadVD2", null, tmpPlayersViolations.seed, ConVar.Server.seed));
                        return;
                    }
        
                    if (tmpPlayersViolations.mapSize != ConVar.Server.worldsize)
                    {
                        Puts(Lang("LoadVD3", null, tmpPlayersViolations.mapSize, ConVar.Server.worldsize));
                        return;
                    }
        
                    if (tmpPlayersViolations.Players.Count > 0)
                    {
                        bool isChanged = false;
                        PlayerViolationsData playerViolationsData;
                        NoRecoilViolationData nrvd;
                        AIMViolationData aimvd;
						InRockViolationsData irvd;
        
                        foreach (KeyValuePair<ulong, PlayerViolationsData> list in tmpPlayersViolations.Players)
                        {
                            if (!PlayersViolations.Players.TryGetValue(tmpPlayersViolations.Players[list.Key].PlayerID, out playerViolationsData))
                            {
                                PlayersViolations.Players.Add(list.Key, playerViolationsData = new PlayerViolationsData());
                                PlayersViolations.Players[list.Key].PlayerID = tmpPlayersViolations.Players[list.Key].PlayerID;
                                PlayersViolations.Players[list.Key].PlayerName = tmpPlayersViolations.Players[list.Key].PlayerName;
                                isChanged = true;
                            }
        
                            if (tmpPlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
                                foreach (KeyValuePair<string, NoRecoilViolationData> nrlist in tmpPlayersViolations.Players[list.Key].noRecoilViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].noRecoilViolations.TryGetValue(nrlist.Key, out nrvd))
                                    {
                                        PlayersViolations.Players[list.Key].noRecoilViolations.Add(nrlist.Key, nrvd = new NoRecoilViolationData());
                                        PlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key] = tmpPlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key];
                                        isChanged = true;
                                    }
        
                            if (tmpPlayersViolations.Players[list.Key].AIMViolations.Count > 0)
                                foreach (KeyValuePair<string, AIMViolationData> aimlist in tmpPlayersViolations.Players[list.Key].AIMViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].AIMViolations.TryGetValue(aimlist.Key, out aimvd))
                                    {
                                        PlayersViolations.Players[list.Key].AIMViolations.Add(aimlist.Key, aimvd = new AIMViolationData());
                                        PlayersViolations.Players[list.Key].AIMViolations[aimlist.Key] = tmpPlayersViolations.Players[list.Key].AIMViolations[aimlist.Key];
                                        isChanged = true;
                                    }
						
							if (tmpPlayersViolations.Players[list.Key].inRockViolations.Count > 0)
                                foreach (KeyValuePair<string, InRockViolationsData> irlist in tmpPlayersViolations.Players[list.Key].inRockViolations)
                                    if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].inRockViolations.TryGetValue(irlist.Key, out irvd))
                                    {
                                        PlayersViolations.Players[list.Key].inRockViolations.Add(irlist.Key, irvd = new InRockViolationsData());
                                        PlayersViolations.Players[list.Key].inRockViolations[irlist.Key] = tmpPlayersViolations.Players[list.Key].inRockViolations[irlist.Key];
                                        isChanged = true;
                                    }
                        }
						
                        if (isChanged)
                        {
                            PlayersViolations.lastChangeTime = DateTime.Now;
                            PlayersViolations.lastSaveTime = DateTime.Now;
                        }
						
                        tmpPlayersViolations.Players = null;
        
                        Puts(RemoveFormatting(Lang("LoadVD1", null, fileName)));
                    }
                }
                else
					Puts(RemoveFormatting(Lang("LoadVD4", null, fileName)));
			}
		}	

        [ChatCommand("arkanclear")]
		private void ClearViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;

				AdminLogInit(player);

                PlayersViolations.Players.Clear();
                DateTime currentDate = DateTime.Now.AddSeconds(-UnityEngine.Time.realtimeSinceStartup);
                PlayersViolations.seed = ConVar.Server.seed;
                PlayersViolations.mapSize = ConVar.Server.worldsize;
                PlayersViolations.serverTimeStamp = currentDate.Year + "." + currentDate.Month + "." + currentDate.Day + "." + currentDate.Hour + "." + currentDate.Minute;
        
                foreach (KeyValuePair<BasePlayer, AdminConfig> list in AdminsConfig)
                    AdminsConfig[list.Key].violationsLog = new ViolationsLog();

				SaveViolationsData(null, null, null);
                SendReply(player, Lang("ClearVD", player.UserIDString));
			}
        }

        [ChatCommand("arkansave")]
		private void SaveViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;
				
				AdminLogInit(player);
			}

            string fileName = serverTimeStamp;

            if (args != null)
                if (args.Length > 0)
                    fileName = args[0];

            PlayersViolations.lastSaveTime = DateTime.Now;
            Interface.Oxide.DataFileSystem.WriteObject("Arkan/" + fileName, PlayersViolations);

            if (player != null)
                SendReply(player, Lang("SaveVD1", player.UserIDString, fileName));
        }

        [ChatCommand("arkanload")]
		private void LoadViolationsData(BasePlayer player, string command, string[] args)
        {
            if (player != null)
			{	
                if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
                    return;

				AdminLogInit(player);
			}

            string fileName = serverTimeStamp;

            if (args != null)
                if (args.Length > 0)
                    fileName = args[0];

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Arkan/" + fileName))
            {
                tmpPlayersViolations = null;
                tmpPlayersViolations = Interface.Oxide.DataFileSystem.ReadObject<PlayersViolationsData>("Arkan/" + fileName);
				
                if (tmpPlayersViolations.seed != ConVar.Server.seed)
                {
                    SendReply(player, "<color=green>Arkan: </color><color=red>" + Lang("LoadVD2", player.UserIDString, "<color=yellow>" + tmpPlayersViolations.seed + "</color>", "<color=yellow>" + ConVar.Server.seed + "</color>") + "</color>");
                    Puts(Lang("LoadVD2", player.UserIDString, tmpPlayersViolations.seed, ConVar.Server.seed));
                    return;
                }

                if (tmpPlayersViolations.mapSize != ConVar.Server.worldsize)
                {
                    SendReply(player, "<color=green>Arkan: </color><color=red>" + Lang("LoadVD3", player.UserIDString, "<color=yellow>" + tmpPlayersViolations.mapSize + "</color>", "<color=yellow>" + ConVar.Server.worldsize + "</color>") + "</color>");
                    Puts(Lang("LoadVD3", player.UserIDString, tmpPlayersViolations.mapSize, ConVar.Server.worldsize));
                    return;
                }

                if (tmpPlayersViolations.Players.Count > 0)
                {
                    bool isChanged = false;
                    PlayerViolationsData playerViolationsData;
                    NoRecoilViolationData nrvd;
                    AIMViolationData aimvd;
					InRockViolationsData irvd;

                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in tmpPlayersViolations.Players)
                    {
                        if (!PlayersViolations.Players.TryGetValue(tmpPlayersViolations.Players[list.Key].PlayerID, out playerViolationsData))
                        {
                            PlayersViolations.Players.Add(list.Key, playerViolationsData = new PlayerViolationsData());
                            PlayersViolations.Players[list.Key].PlayerID = tmpPlayersViolations.Players[list.Key].PlayerID;
                            PlayersViolations.Players[list.Key].PlayerName = tmpPlayersViolations.Players[list.Key].PlayerName;
                            isChanged = true;
                        }

                        if (tmpPlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
                            foreach (KeyValuePair<string, NoRecoilViolationData> nrlist in tmpPlayersViolations.Players[list.Key].noRecoilViolations)
                                if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].noRecoilViolations.TryGetValue(nrlist.Key, out nrvd))
                                {
                                    PlayersViolations.Players[list.Key].noRecoilViolations.Add(nrlist.Key, nrvd = new NoRecoilViolationData());
                                    PlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key] = tmpPlayersViolations.Players[list.Key].noRecoilViolations[nrlist.Key];
                                    isChanged = true;
                                }

                        if (tmpPlayersViolations.Players[list.Key].AIMViolations.Count > 0)
                            foreach (KeyValuePair<string, AIMViolationData> aimlist in tmpPlayersViolations.Players[list.Key].AIMViolations)
                                if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].AIMViolations.TryGetValue(aimlist.Key, out aimvd))
                                {
                                    PlayersViolations.Players[list.Key].AIMViolations.Add(aimlist.Key, aimvd = new AIMViolationData());
                                    PlayersViolations.Players[list.Key].AIMViolations[aimlist.Key] = tmpPlayersViolations.Players[list.Key].AIMViolations[aimlist.Key];
                                    isChanged = true;
                                }
						
						if (tmpPlayersViolations.Players[list.Key].inRockViolations.Count > 0)
                            foreach (KeyValuePair<string, InRockViolationsData> irlist in tmpPlayersViolations.Players[list.Key].inRockViolations)
								if (!PlayersViolations.Players[tmpPlayersViolations.Players[list.Key].PlayerID].inRockViolations.TryGetValue(irlist.Key, out irvd))
                                {
                                    PlayersViolations.Players[list.Key].inRockViolations.Add(irlist.Key, irvd = new InRockViolationsData());
                                    PlayersViolations.Players[list.Key].inRockViolations[irlist.Key] = tmpPlayersViolations.Players[list.Key].inRockViolations[irlist.Key];
                                    isChanged = true;
                                }
                    }
					
                    if (isChanged)
                    {
                        PlayersViolations.lastChangeTime = DateTime.Now;
                        PlayersViolations.lastSaveTime = DateTime.Now;
                    }
					
                    tmpPlayersViolations.Players = null;

                    if (player != null)
                        SendReply(player, Lang("LoadVD1", player.UserIDString, fileName));
                }
            }
            else
				if (player != null)
					SendReply(player, Lang("LoadVD4", player.UserIDString, fileName));
        }

		[ChatCommand("arkan")]
        private void ShowLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;
				
				AdminLogInit(player);

                string txt = Lang("ShowInfo", player.UserIDString);
        
                if (PlayersViolations.Players.Count > 0)
                {
                    txt += Lang("ShowLog2", player.UserIDString) + "\n";
					string txtTmp = "";
					string txtConsole = "<color=green>Arkan: </color>" + Lang("ShowLog2");
					int i = 1;
					
                    foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
					{
						txtTmp = "";
						txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> -";
						txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> -";
						
						if (PlayersViolations.Players[list.Key].noRecoilViolations.Count > 0)
							txtTmp += $" NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>)";
						
						if (PlayersViolations.Players[list.Key].AIMViolations.Count > 0)
							txtTmp += $" AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>)";
						
						if (PlayersViolations.Players[list.Key].inRockViolations.Count > 0)
							txtTmp += $" IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>)";
						
						txtConsole += txtTmp + "; ";
                        txt += txtTmp + "; </size>";

						i++;

						if (i == 5)
						{
							txtConsole += "\n";
							i = 1;
						}								
					}
					
					player.ConsoleMessage(txtConsole + "</color></size>");
                }
                else
				{
                    txt += Lang("ShowLog3", player.UserIDString);
					player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowLog3", player.UserIDString) + "</color></size>");
				}
        
                SendReply(player, txt + "</color></size>");
                return;
            }
        }

		[ChatCommand("arkaninfo")]
        private void ShowInfo(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;
				
				AdminLogInit(player);

                SendReply(player, Lang("ShowLog1v1.0.13", player.UserIDString));
            }
        }

        [ChatCommand("arkannr")]
		private void ShowNoRecoilLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].noRecoilViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
							{
                                txt += Lang("ShowNRLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowNRLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - NR(<color=yellow>{PlayersViolations.Players[list.Key].noRecoilViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							nrCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (nrCnt == 0)
					{
                        txt += Lang("ShowNRLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowNRLog3", player.UserIDString) + "</color></size>");
					}
					
                    SendReply(player, txt + "</color></size>");
                    return;
                }

				ShowNoRecoilViolations(player, args);
			}
        }

        [ChatCommand("arkanaim")]
		private void ShowAIMLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int aimCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
                        {
                            if (aimCnt == 0)
							{
                                txt += Lang("ShowAIMLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowAIMLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							aimCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (aimCnt == 0)
					{
                        txt += Lang("ShowAIMLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowAIMLog3", player.UserIDString) + "</color></size>");
					}
        
                    SendReply(player, txt + "</color></size>");
                    return;
                }
        
                ShowAIMViolations(player, args);
			}
        }

        [ChatCommand("arkanaimr")]
		private void ShowAIMLogRecalc(BasePlayer player, string command, string[] args) //for development purposes only
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
        
                    if (PlayersViolations.Players.Count > 0)
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].AIMViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
                                txt += Lang("ShowAIMLog2", player.UserIDString);
        
                            txt += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - AIM(<color=yellow>{PlayersViolations.Players[list.Key].AIMViolations.Count}</color>); ";
                            nrCnt++;
                        }
        
                    if (nrCnt == 0)
                        txt += Lang("ShowAIMLog3", player.UserIDString);
        
                    SendReply(player, txt + "</color></size>");
                    return;
                }
        
                ShowAIMViolationsRecalc(player, args);
			}			
        }

		[ChatCommand("arkanir")]
		private void ShowInRocklLog(BasePlayer player, string command, string[] args)
        {
			if (player != null)
			{	
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				AdminLogInit(player);

                if (args.Length == 0)
                {
                    int nrCnt = 0;
                    string txt = Lang("ShowInfo", player.UserIDString);
					string txtConsole = "";
        
                    if (PlayersViolations.Players.Count > 0)
					{
						int i = 1;
						foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players.Where(x => (PlayersViolations.Players[x.Key].inRockViolations.Count > 0)))
                        {
                            if (nrCnt == 0)
							{
                                txt += Lang("ShowIRLog2", player.UserIDString) + "\n";
								txtConsole = "<color=green>Arkan: </color>" + Lang("ShowIRLog2", player.UserIDString);
							}
        
                            txt += $"<size=10><color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>); </size>";
                            txtConsole += $"<color=green>{PlayersViolations.Players[list.Key].PlayerName}</color> - IR(<color=yellow>{PlayersViolations.Players[list.Key].inRockViolations.Count}</color>); ";
							
							i++;
							
							if (i == 5)
							{
								txtConsole += "\n";
								i = 1;
							}   
							
							nrCnt++;
                        }
						
						player.ConsoleMessage(txtConsole + "</color></size>");
					}
        
                    if (nrCnt == 0)
					{
                        txt += Lang("ShowIRLog3", player.UserIDString);
						player.ConsoleMessage("<color=green>Arkan: </color>" + Lang("ShowIRLog3", player.UserIDString) + "</color></size>");
					}
					
                    SendReply(player, txt + "</color></size>");
                    return;
                }

				ShowInRockViolations(player, args);
			}
        }
		
        #endregion Commands

        #region Functions
		
		private string API_ArkanGetPlayersViolationsData()
        {
			if(PlayersViolations != null)
			{
				return JsonConvert.SerializeObject(PlayersViolations);
			}
			return null;
		}		

        private void CleanupExpiredProjectiles(BasePlayer player)
        {
			if (player != null)
				if (PlayersFiredProjectlesData.ContainsKey(player.userID))
					if (PlayersFiredProjectlesData[player.userID].lastFiredTime < UnityEngine.Time.realtimeSinceStartup - 8f && (PlayersFiredProjectlesData[player.userID].firedProjectiles.Count > 0 || PlayersFiredProjectlesData[player.userID].melees.Count > 0))
					{
						PlayersFiredProjectlesData[player.userID].firedProjectiles.Clear();
						PlayersFiredProjectlesData[player.userID].melees.Clear();
					}
        }

        private void DDrawArrowToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 startPosition, Vector3 endPosition, float arrowHeadSize)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.arrow", _drawTime, color, startPosition, endPosition, arrowHeadSize);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.arrow", _drawTime, color, startPosition, endPosition, arrowHeadSize);
        }

        private void DDrawSphereToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 Position, float sphereSize)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.sphere", _drawTime, color, Position, sphereSize);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.sphere", _drawTime, color, Position, sphereSize);
        }

        private void DDrawTextToAdmin(BasePlayer player, float _drawTime, Color color, Vector3 Position, string text)
        {
            if (player != null)
            {
                if (player.IsAdmin && permission.UserHasPermission(player.UserIDString, permName))
                    player.SendConsoleCommand("ddraw.text", _drawTime, color, Position, text);
            }
            else
                foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
                    _player.SendConsoleCommand("ddraw.text", _drawTime, color, Position, text);
        }
		
		private void DrawInRockViolationsData(BasePlayer player, string suspectPlayerName, string suspectPlayerID, int vsCnt, InRockViolationsData violationData, bool isTeleport)
        {
            if (player != null && violationData != null)
            {                
                if (isTeleport)
                {
                    Vector3 startPos = violationData.inRockViolationsData[1].firedProjectile.projectilePosition;
                    Vector3 tempPos = player.eyes.HeadForward();
                    Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                    player.Teleport(teleportPos);
                }
				
				DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.inRockViolationsData[1].firedProjectile.projectilePosition + Vector3.up * 0.3f, Lang("PlayerTxt", player.UserIDString) + ": <color=yellow>" + suspectPlayerName + "/" +suspectPlayerID + "</color>\n" + Lang("IRViolationNum", player.UserIDString) + ": <color=white>" + vsCnt + "</color>\n" + Lang("Weapon", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData[1].firedProjectile.weaponShortName + "</color>\n" + Lang("Ammo", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData[1].firedProjectile.ammoShortName + "</color>\n" + Lang("ShotsCount", player.UserIDString) + ": <color=white>" + violationData.inRockViolationsData.Count + "</color>");
				DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.inRockViolationsData[1].firedProjectile.projectilePosition, 0.04f);
				
				for (int i = 1; i <= violationData.inRockViolationsData.Count; i++)
                {					
					float physicsSteps = violationData.inRockViolationsData[i].physicsSteps;
					float fixedDeltaTime = 1f / physicsSteps;
                    Vector3 position = violationData.inRockViolationsData[i].firedProjectile.projectilePosition;
                    Vector3 vector1 = violationData.inRockViolationsData[i].firedProjectile.projectileVelocity / physicsSteps;
                    float distance = violationData.inRockViolationsData[i].targetHitDistance;
					float hitInfoDistance = violationData.inRockViolationsData[i].targetHitDistance;
                    float gravityModifier = violationData.inRockViolationsData[i].gravityModifier;
                    float drag = violationData.inRockViolationsData[i].drag;
                    Vector3 hitPoint = violationData.inRockViolationsData[i].targetHitPosition;
                    Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;

                    float single1 = drag * fixedDeltaTime;
                    float dist = 0.0f;
					int segmentsCnt = (int)(physicsSteps * 8);
            
                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, hitPoint, 0.04f);
					DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.inRockViolationsData[i].rockHitPosition, 0.04f);
            
                    for (int j = 0; j < segmentsCnt; j++)
                    {                        
                        DDrawArrowToAdmin(player, _config.drawTime, Color.yellow, position, position + vector1, 0.05f);
            
                        if ((distance - dist) <= (vector1.magnitude))
                            break;
            
                        dist += vector1.magnitude;
                        position += vector1;
            
                        vector1 += vector2;
                        vector1 -= (vector1 * single1);
                    }					
				}
            }
        }

        private void DrawNoRecoilViolationsData(BasePlayer player, string suspectPlayerName, NoRecoilViolationData violationData, bool isTeleport)
        {
            if (player != null)
            {
                if (violationData.isMounted)
                {
                    Matrix4x4 viewMatrix;
					Quaternion q = new Quaternion(violationData.mountParentRotation.x, violationData.mountParentRotation.y, violationData.mountParentRotation.z, violationData.mountParentRotation.w);
					viewMatrix = Matrix4x4.LookAt(violationData.mountParentPosition, violationData.mountParentPosition + (q * Vector3.forward), Vector3.up);

                    if (isTeleport)
                    {
                        Vector3 startPos = viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[1].projectile2Position - player.eyes.offset);
                        Vector3 tempPos = player.eyes.HeadForward();
                        Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                        player.Teleport(teleportPos);
                    }

                    foreach (KeyValuePair<int, SuspiciousProjectileData> list in violationData.suspiciousNoRecoilShots.ToArray())
                    {
                        DDrawSphereToAdmin(player, _config.drawTime, Color.green, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), 0.01f);
                        
						if (violationData.suspiciousNoRecoilShots[list.Key].isNoRecoil)
                        {
                            DDrawArrowToAdmin(player, _config.drawTime, Color.blue, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                            
							if (violationData.suspiciousNoRecoilShots[list.Key].isShootedInMotion)
                            {
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].closestPointLine1), 0.1f);
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].closestPointLine2), 0.1f);
                            }
                        }
                        else
                            DDrawArrowToAdmin(player, _config.drawTime, Color.green, viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position), viewMatrix.MultiplyPoint(violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                    }
                }
                else
                {
                    if (isTeleport)
                    {
                        Vector3 startPos = violationData.suspiciousNoRecoilShots[1].projectile2Position - player.eyes.offset;
                        Vector3 tempPos = player.eyes.HeadForward();
                        Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                        player.Teleport(teleportPos);
                    }

                    DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.suspiciousNoRecoilShots[1].projectile2Position + Vector3.up * 0.3f, Lang("DrawNRVD1", player.UserIDString, suspectPlayerName, violationData.ammoShortName, violationData.weaponShortName, violationData.suspiciousNoRecoilShots.Count(), violationData.violationProbability));

                    foreach (KeyValuePair<int, SuspiciousProjectileData> list in violationData.suspiciousNoRecoilShots.ToArray())
                    {
                        DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, 0.01f);
                        
						if (violationData.suspiciousNoRecoilShots[list.Key].isNoRecoil)
                        {
                            DDrawArrowToAdmin(player, _config.drawTime, Color.blue, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, (violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                            
							if (violationData.suspiciousNoRecoilShots[list.Key].isShootedInMotion)
                            {
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.suspiciousNoRecoilShots[list.Key].closestPointLine1, 0.1f);
                                DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.suspiciousNoRecoilShots[list.Key].closestPointLine2, 0.1f);
                            }
                        }
                        else
                            DDrawArrowToAdmin(player, _config.drawTime, Color.green, violationData.suspiciousNoRecoilShots[list.Key].projectile2Position, (violationData.suspiciousNoRecoilShots[list.Key].projectile2Position + violationData.suspiciousNoRecoilShots[list.Key].projectile2Velocity.normalized * 450f), 0.2f);
                    }
                }
            }
        }

        private void DrawAIMViolationsData(BasePlayer player, AIMViolationData violationData, bool isTeleport)
        {
            if (player != null)
            {
                if (isTeleport)
                {
                    Vector3 startPos = violationData.startProjectilePosition - player.eyes.offset;
                    Vector3 tempPos = player.eyes.HeadForward();
                    Vector3 teleportPos = new Vector3(startPos.x - tempPos.x, startPos.y + 0.1f, startPos.z - tempPos.z);
                    player.Teleport(teleportPos);
                }

                player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("Attacker", player.UserIDString) + ": " + violationData.hitInfoInitiatorPlayerName + "/" + violationData.hitInfoInitiatorPlayerUserID + "\n" + Lang("AIMViolationNum", player.UserIDString) + violationData.violationID + "\n" + Lang("Weapon", player.UserIDString) + ": " + violationData.weaponShortName + "\n" + Lang("Ammo", player.UserIDString) + ": " + violationData.ammoShortName + "\n" + Lang("Distance", player.UserIDString) + ": " + violationData.hitInfoProjectileDistance);
				player.ConsoleMessage(Lang("Target", player.UserIDString) + ": " + (violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID) + "\n" + Lang("HitPart", player.UserIDString) + ": " + violationData.hitInfoBoneName);
				player.ConsoleMessage(Lang("DateTime", player.UserIDString) + ": " + violationData.firedTime);
				
				player.ConsoleMessage(Lang("AttachmentsCount", player.UserIDString) + " = " + violationData.attachments.Count);

                if (violationData.attachments.Count > 0)
                    for (int ii = 0; ii < violationData.attachments.Count; ii++)
                        player.ConsoleMessage(Lang("Attachment", player.UserIDString) + " - " + violationData.attachments[ii]);
				
				if (violationData.isAttackerMount && violationData.attackerMountParentName != null)
					player.ConsoleMessage(Lang("MountedOn", player.UserIDString, violationData.attackerMountParentName) + "\n");	
                
				player.ConsoleMessage(Lang("RicochetsCount", player.UserIDString) + " = " + (violationData.hitsData.Count - 1) + "\n");
                player.ConsoleMessage($"isEqualFiredProjectileData = {violationData.isEqualFiredProjectileData}\n");
                player.ConsoleMessage($"isPlayerPositionToProjectileStartPositionDistanceViolation = {violationData.isPlayerPositionToProjectileStartPositionDistanceViolation}\n");
                
				if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
                    player.ConsoleMessage(Lang("LogText6", player.UserIDString, violationData.distanceDifferenceViolation));

                for (int j = 0; j < violationData.hitsData.Count; j++)
                {
                    player.ConsoleMessage($".\n" + Lang("LogText7", player.UserIDString, j + 1));
                    player.ConsoleMessage($"isHitPointNearProjectileTrajectoryLastSegmentEndPoint = {violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint}");
                    
					if (!violationData.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint && violationData.hitsData[j].side > 0)
                        if (violationData.hitsData[j].side == 1)
                            player.ConsoleMessage("     " + Lang("AIMText4", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText2", player.UserIDString), "StartPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointStart)));
                        else
                            player.ConsoleMessage("     " + Lang("AIMText4", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane, Lang("AIMText3", player.UserIDString), "EndPoint", Vector3.Distance(violationData.hitsData[j].hitPositionWorld, violationData.hitsData[j].hitPointEnd)));

                    player.ConsoleMessage($"isHitPointOnProjectileTrajectory = {violationData.hitsData[j].isHitPointOnProjectileTrajectory}");
                    player.ConsoleMessage($"isProjectileStartPointAtEndReverseProjectileTrajectory = {violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory}");
                    
					if (!violationData.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory)
                        player.ConsoleMessage("     " + Lang("AIMText6", player.UserIDString, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].lastSegmentPointEnd, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity));

                    player.ConsoleMessage($"isHitPointNearProjectilePlane = {violationData.hitsData[j].isHitPointNearProjectilePlane}");
                    
					if (!violationData.hitsData[j].isHitPointNearProjectilePlane)
                        player.ConsoleMessage("     " + Lang("AIMText7", player.UserIDString, violationData.hitsData[j].distanceFromHitPointToProjectilePlane));

                    player.ConsoleMessage($"isLastSegmentOnProjectileTrajectoryPlane = {violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane}");
                    
					if (!violationData.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane)
                        player.ConsoleMessage("     " + Lang("AIMText8", player.UserIDString, violationData.hitsData[j].lastSegmentPointStart, violationData.hitsData[j].startProjectilePosition, violationData.hitsData[j].startProjectilePosition + violationData.hitsData[j].startProjectileVelocity));

                    player.ConsoleMessage(Lang("LogText8", player.UserIDString, j + 1));

                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.hitsData[j].startProjectilePosition, 0.05f);
                    DDrawSphereToAdmin(player, _config.drawTime, Color.green, violationData.hitsData[j].lastSegmentPointStart, 0.04f);
                }

                DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.hitInfoHitPositionWorld + new Vector3(0f, 1f, 0f), Lang("DrawAIMVD3", player.UserIDString, violationData.hitInfoHitEntityPlayerName ?? violationData.hitInfoHitEntityPlayerUserID, violationData.hitInfoBoneName, violationData.damage));
                DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.hitsData[0].startProjectilePosition + new Vector3(0f, 1f, 0f), Lang("DrawAIMVD4", player.UserIDString, violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID, violationData.projectileID, violationData.ammoShortName, violationData.weaponShortName, violationData.hitInfoProjectileDistance));

                DrawProjectileTrajectory(player, _config.drawTime, violationData, Color.blue);
                DrawReverseProjectileTrajectory(player, _config.drawTime, violationData, Color.green);
				DDrawSphereToAdmin(player, _config.drawTime, Color.white, violationData.hitInfoPointStart, 0.04f);
				DDrawSphereToAdmin(player, _config.drawTime, Color.white, violationData.hitInfoPointEnd, 0.04f);
				
                if (violationData.isPlayerPositionToProjectileStartPositionDistanceViolation)
                {
                    DDrawSphereToAdmin(player, _config.drawTime, Color.red, violationData.playerEyesPosition, 0.05f);
                    DDrawTextToAdmin(player, _config.drawTime, Color.cyan, violationData.playerEyesPosition + Vector3.up, Lang("DrawAIMVD5", player.UserIDString, violationData.hitInfoInitiatorPlayerName ?? violationData.hitInfoInitiatorPlayerUserID, violationData.violationID, violationData.playerEyesPosition, violationData.startProjectilePosition, Vector3.Distance(violationData.playerEyesPosition, violationData.startProjectilePosition)));
					DDrawArrowToAdmin(player, _config.drawTime, Color.red, violationData.playerEyesPosition, violationData.playerEyesPosition + violationData.playerEyesLookAt.normalized, 0.05f);
                }
            }
        }

        private void ShowNoRecoilViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
            {
                if (PlayersViolations.Players[playerID].noRecoilViolations.Count == 0)
                    player.ChatMessage(Lang("ShowNRD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                else
                {
                    adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                    if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
                        AdminsConfig[player].violationsLog.NoRecoilViolation = 1;
                        AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;

                        adminMsg += Lang("ShowNRD2", player.UserIDString, PlayersViolations.Players[playerID].noRecoilViolations.Count);
                    }
                    else
                        if (s == null)
                            if (PlayersViolations.Players[playerID].noRecoilViolations.Count >= AdminsConfig[player].violationsLog.NoRecoilViolation + 1)
                                AdminsConfig[player].violationsLog.NoRecoilViolation++;
                            else
                            {
                                player.ChatMessage(Lang("NoMoreViolations", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                                AdminsConfig[player].violationsLog = new ViolationsLog();
                                return;
                            }

                    int result;
                    int.TryParse(s, out result);

                    if (result == 0)
                        result = AdminsConfig[player].violationsLog.NoRecoilViolation;

                    adminMsg += Lang("ShowNRD3", player.UserIDString, result);
                    player.ChatMessage(adminMsg + "\n");

                    int i = 1;
                    foreach (KeyValuePair<string, NoRecoilViolationData> list in PlayersViolations.Players[playerID].noRecoilViolations)
                    {
                        if (i == result)
                        {
                            DrawNoRecoilViolationsData(player, PlayersViolations.Players[playerID].PlayerName, PlayersViolations.Players[playerID].noRecoilViolations[list.Key], true);

                            NoRecoilViolationData violationData = PlayersViolations.Players[playerID].noRecoilViolations[list.Key];

							player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("PlayerTxt", player.UserIDString) + " " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID +"\n" + Lang("NRViolationNum", player.UserIDString) + result + "\n" + Lang("ShotsCount", player.UserIDString) + " " + violationData.ShotsCnt + "\n" + Lang("Probability", player.UserIDString) + " " + violationData.violationProbability + "%");
							if (violationData.suspiciousNoRecoilShots.ContainsKey(1))
								player.ConsoleMessage(Lang("DateTime", player.UserIDString) + ": " + violationData.suspiciousNoRecoilShots[1].timeStamp);
                            player.ConsoleMessage(Lang("AttachmentsCount", player.UserIDString) + " = " + violationData.attachments.Count);

                            if (violationData.attachments.Count > 0)
                                for (int ii = 0; ii < violationData.attachments.Count; ii++)
                                    player.ConsoleMessage(Lang("Attachment", player.UserIDString) + " - " + violationData.attachments[ii]);

                            player.ConsoleMessage(Lang("Weapon", player.UserIDString) + " - " + violationData.weaponShortName);
                            player.ConsoleMessage(Lang("Ammo", player.UserIDString) + " - " + violationData.ammoShortName);
							player.ConsoleMessage(Lang("Probability", player.UserIDString) + " - " + violationData.violationProbability + "%");

                            int j = 1;
							
                            foreach (KeyValuePair<int, SuspiciousProjectileData> suspiciusProjectile in violationData.suspiciousNoRecoilShots.ToArray())
                            {
                                SuspiciousProjectileData sp = violationData.suspiciousNoRecoilShots[suspiciusProjectile.Key];
                                if (sp.isNoRecoil)
                                {
                                    if (sp.isShootedInMotion)
										player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, sp.projectile2ID) + " | " + Lang("ShootingOnMove", player.UserIDString) +  " | " + Lang("ClosestPoint", player.UserIDString, sp.closestPointLine1, sp.closestPointLine2, sp.prevIntersectionPoint) + " | " + Lang("FireTimeInterval", player.UserIDString, sp.timeInterval));
									else
										player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, sp.projectile2ID) + " | " + Lang("StandingShooting", player.UserIDString) + " | " + Lang("RecoilAngle", player.UserIDString, sp.recoilAngle) + " | " + Lang("FireTimeInterval", player.UserIDString, sp.timeInterval));
                                }
                                j++;
                            }
                            break;
                        }
                        i++;
                    }
                }
            }
        }

        private void ShowAIMViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
            {
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];
            }

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
                if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
					player.ChatMessage(Lang("ShowAIMD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
            else
            {
                adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                {
                    AdminsConfig[player].violationsLog.AIMViolation = 1;
                    AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    adminMsg += Lang("ShowAIMD2", player.UserIDString, PlayersViolations.Players[playerID].AIMViolations.Count);
                }
                else if (s == null)
                    if (PlayersViolations.Players[playerID].AIMViolations.Count >= AdminsConfig[player].violationsLog.AIMViolation + 1)
                        AdminsConfig[player].violationsLog.AIMViolation++;
                    else
                    {
                        player.ChatMessage(Lang("ShowD3", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                        AdminsConfig[player].violationsLog = new ViolationsLog();
                        return;
                    }

                int result;
                int.TryParse(s, out result);

                if (result == 0)
                    result = AdminsConfig[player].violationsLog.AIMViolation;

                adminMsg += Lang("ShowAIMD3", player.UserIDString, result);
                player.ChatMessage(adminMsg);

                int i = 1;
                
				foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                {
                    if (i == result)
                    {
                        DrawAIMViolationsData(player, PlayersViolations.Players[playerID].AIMViolations[list.Key], true);
                        break;
                    }
                    i++;
                }
            }
        }

        private void ShowAIMViolationsRecalc(BasePlayer player, string[] args) //for development purposes only
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
                if (PlayersViolations.Players[playerID].AIMViolations.Count == 0)
					player.ChatMessage(Lang("ShowAIMD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
            else
            {
                adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                {
                    AdminsConfig[player].violationsLog.AIMViolation = 1;
                    AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;
                    adminMsg += Lang("ShowAIMD2", player.UserIDString, PlayersViolations.Players[playerID].AIMViolations.Count);
                }
                else
                    if (s == null)
                        if (PlayersViolations.Players[playerID].AIMViolations.Count >= AdminsConfig[player].violationsLog.AIMViolation + 1)
                            AdminsConfig[player].violationsLog.AIMViolation++;
                        else
                        {
                            player.ChatMessage(Lang("ShowD3", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                            AdminsConfig[player].violationsLog = new ViolationsLog();
                            return;
                        }

                int result;
                int.TryParse(s, out result);

                if (result == 0)
                    result = AdminsConfig[player].violationsLog.AIMViolation;

                adminMsg += Lang("ShowAIMD3", player.UserIDString, result);
                player.ChatMessage(adminMsg);

                int i = 1;
                
				foreach (KeyValuePair<string, AIMViolationData> list in PlayersViolations.Players[playerID].AIMViolations)
                {
                    if (i == result)
                    {
                        AIMViolationData aimvd = new AIMViolationData();
                        aimvd = PlayersViolations.Players[playerID].AIMViolations[list.Key];
                        Vector3 projectilePosition = PlayersViolations.Players[playerID].AIMViolations[list.Key].startProjectilePosition;
                        Vector3 projectileVelocity = PlayersViolations.Players[playerID].AIMViolations[list.Key].startProjectileVelocity;
                        Vector3 PointStart = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoPointStart;
                        Vector3 PointEnd = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoPointEnd;
                        Vector3 HitPositionWorld = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoHitPositionWorld;

                        float gravityModifier = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoProjectilePrefabGravityModifier;
                        float drag = PlayersViolations.Players[playerID].AIMViolations[list.Key].hitInfoProjectilePrefabDrag;
                        string putsmsg = "";
                        bool AIMViolation = false;
						List<TrajectorySegment> trajectorySegments = new List<TrajectorySegment>();
						List<TrajectorySegment> trajectorySegmentsRev = new List<TrajectorySegment>();
						
						aimvd.hitsData[0].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = true;
						aimvd.hitsData[0].isHitPointOnProjectileTrajectory = true;
						aimvd.hitsData[0].isProjectileStartPointAtEndReverseProjectileTrajectory = true;
						aimvd.hitsData[0].isHitPointNearProjectilePlane = true;
						aimvd.hitsData[0].isLastSegmentOnProjectileTrajectoryPlane = true;

						if (aimvd.hitsData.Count == 2)
						{
							aimvd.hitsData[0].hitPositionWorld = aimvd.hitsData[1].hitPositionWorld;
							aimvd.hitsData[0].hitPointStart = aimvd.hitsData[1].hitPointStart;
							aimvd.hitsData[0].hitPointEnd = aimvd.hitsData[1].hitPointEnd;
							aimvd.hitsData.RemoveAt(1);
						}
						
                        AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, gravityModifier, drag);

						Puts($"Player {PlayersViolations.Players[playerID].PlayerName} physicsSteps={aimvd.physicsSteps}");

						if (AIMViolation && aimvd.hitsData.Count == 1 && trajectorySegments.Count > 0 && trajectorySegmentsRev.Count > 	0)
						{
							float lengthLastSegmentProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].lastSegmentPointEnd, aimvd.hitsData[0].lastSegmentPointStart);
							float lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[0].hitPointEnd, aimvd.hitsData[0].hitPointStart);
							
							Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointStart);
							Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(aimvd.hitsData[0].lastSegmentPointStart, (aimvd.hitsData[0].lastSegmentPointEnd - aimvd.hitsData[0].lastSegmentPointStart).normalized, aimvd.hitsData[0].hitPointEnd);
	
							if (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[0].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[0].hitPointEnd)) > 0.05f)
							{								
								HitData hitData1 = new HitData();
								HitData hitData2 = new HitData();
								if (IsRicochet(trajectorySegments, trajectorySegmentsRev, out hitData1, out hitData2, aimvd.physicsSteps))
								{
									hitData1.startProjectilePosition = aimvd.hitsData[0].startProjectilePosition;
									hitData1.startProjectileVelocity = aimvd.hitsData[0].startProjectileVelocity;
                        
									hitData2.hitPositionWorld = HitPositionWorld;
									hitData2.hitPointStart = PointStart;
									hitData2.hitPointEnd = PointEnd;	
														
									aimvd.hitsData.Clear();
								
									aimvd.hitsData.Add(hitData1);
									aimvd.hitsData.Add(hitData2);
                        
									putsmsg = "";
									AIMViolation = ProcessProjectileTrajectory(out aimvd, aimvd, out trajectorySegments, out trajectorySegmentsRev, gravityModifier, drag);
								}	
							}							
						}

                        if (Vector3.Distance(aimvd.playerEyesPosition, aimvd.startProjectilePosition) > _config.playerEyesPositionToProjectileInitialPositionDistanceForgiveness)
                        {
                        	AIMViolation = true;
                        	aimvd.isPlayerPositionToProjectileStartPositionDistanceViolation = true;
                        }

                    //  DrawProjectileTrajectory(player, _config.drawTime, aimvd, Color.blue);
                    //  DrawReverseProjectileTrajectory(player, _config.drawTime, aimvd, Color.green);

                        player.ConsoleMessage($"aimvd.calculatedTravelDistance = {aimvd.calculatedTravelDistance}");

                        player.ConsoleMessage($"\n{putsmsg}");
                        player.ConsoleMessage($"____end log____1");

                        DrawAIMViolationsData(player, aimvd, false);

                        DDrawSphereToAdmin(null, 60f, Color.red, HitPositionWorld, 0.02f);
					
                        break;
                    }
                    i++;
                }
            }
        }

        private void ShowInRockViolations(BasePlayer player, string[] args)
        {
            if (player == null)
                return;

            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName) || !AdminsConfig.ContainsKey(player))
                return;

            string s = null;
			string adminMsg;
            ulong id = 0;
			ulong playerID = 0;

            if (args.Length == 2)
                if (args[1] == "0")
                {
                    player.ChatMessage(Lang("ShowD1", player.UserIDString));
                    AdminsConfig[player].violationsLog = new ViolationsLog();
                }
                else
                    s = args[1];

            string user = args[0];

            if (user.Contains("765"))
                ulong.TryParse(args[0], out id);

            foreach (KeyValuePair<ulong, PlayerViolationsData> list in PlayersViolations.Players)
                if (PlayersViolations.Players[list.Key].PlayerID == id || PlayersViolations.Players[list.Key].PlayerName.Contains(user, CompareOptions.IgnoreCase))
                    playerID = PlayersViolations.Players[list.Key].PlayerID;

            if (playerID == 0)
                player.ChatMessage(Lang("ShowD2", player.UserIDString));
            else
            {
                if (PlayersViolations.Players[playerID].inRockViolations.Count == 0)
                    player.ChatMessage(Lang("ShowIRD1", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                else
                {
                    adminMsg = Lang("Player", player.UserIDString, PlayersViolations.Players[playerID].PlayerName);

                    if ((long)AdminsConfig[player].violationsLog.steamID != (long)PlayersViolations.Players[playerID].PlayerID)
                    {
                        AdminsConfig[player].violationsLog.InRockViolation = 1;
                        AdminsConfig[player].violationsLog.steamID = PlayersViolations.Players[playerID].PlayerID;

                        adminMsg += Lang("ShowIRD2", player.UserIDString, PlayersViolations.Players[playerID].inRockViolations.Count);
                    }
                    else
                        if (s == null)
                            if (PlayersViolations.Players[playerID].inRockViolations.Count >= AdminsConfig[player].violationsLog.InRockViolation + 1)
                                AdminsConfig[player].violationsLog.InRockViolation++;
                            else
                            {
                                player.ChatMessage(Lang("NoMoreViolations", player.UserIDString, PlayersViolations.Players[playerID].PlayerName));
                                AdminsConfig[player].violationsLog = new ViolationsLog();
                                return;
                            }

                    int result;
                    int.TryParse(s, out result);

                    if (result == 0)
                        result = AdminsConfig[player].violationsLog.InRockViolation;

                    adminMsg += Lang("ShowIRD3", player.UserIDString, result);
                    player.ChatMessage(adminMsg + "\n");

                    int i = 1;
                    foreach (KeyValuePair<string, InRockViolationsData> list in PlayersViolations.Players[playerID].inRockViolations)
                    {
                        if (i == result)
                        {
							DrawInRockViolationsData(player, PlayersViolations.Players[playerID].PlayerName, $"{playerID}", i, PlayersViolations.Players[playerID].inRockViolations[list.Key], true);
                            player.ConsoleMessage("<color=green>Arkan:</color>\n" + Lang("Attacker", player.UserIDString) + ": " + PlayersViolations.Players[playerID].PlayerName + "/" + PlayersViolations.Players[playerID].PlayerID + "\n" + Lang("IRViolationNum", player.UserIDString) + result + "\n" + Lang("Weapon", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[1].firedProjectile.ammoShortName + "\n");

							for (int j = 1; j <= PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData.Count; j++)
							{
								player.ConsoleMessage(Lang("ProjectileID", player.UserIDString, j) + " | " + Lang("Target", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetName + "/" + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetID + " | " + Lang("HitPart", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", player.UserIDString) + ": " + PlayersViolations.Players[playerID].inRockViolations[list.Key].inRockViolationsData[j].targetDamage);
							}
							
							break;
                        }
                        i++;
                    }
                }
            }
        }

        //Two non-parallel lines which may or may not touch each other have a point on each line which are closest
        //to each other. This function finds those two points. If the lines are not parallel, the function 
        //outputs true, otherwise false.
        private bool ClosestPointsOnTwoLines(out Vector3 closestPointLine1, out Vector3 closestPointLine2, Vector3 linePoint1, Vector3 lineVec1, Vector3 linePoint2, Vector3 lineVec2)
        {
            closestPointLine1 = Vector3.zero;
            closestPointLine2 = Vector3.zero;

            float a = Vector3.Dot(lineVec1, lineVec1);
            float b = Vector3.Dot(lineVec1, lineVec2);
            float e = Vector3.Dot(lineVec2, lineVec2);

            float d = a * e - b * b;

            //lines are not parallel
            if (d != 0.0f)
            {
                Vector3 r = linePoint1 - linePoint2;
                float c = Vector3.Dot(lineVec1, r);
                float f = Vector3.Dot(lineVec2, r);

                float s = (b * f - c * e) / d;
                float t = (a * f - c * b) / d;

                closestPointLine1 = linePoint1 + lineVec1 * s;
                closestPointLine2 = linePoint2 + lineVec2 * t;

                return true;
            }
            else
                return false;
        }

        //This function returns a point which is a projection from a point to a line.
        //The line is regarded infinite. If the line is finite, use ProjectPointOnLineSegment() instead.
        private Vector3 ProjectPointOnLine(Vector3 linePoint, Vector3 lineVec, Vector3 point)
        {
            //get vector from point on line to point in space
            Vector3 linePointToPoint = point - linePoint;

            float t = Vector3.Dot(linePointToPoint, lineVec);

            return linePoint + lineVec * t;
        }

        //This function returns a point which is a projection from a point to a line segment.
        //If the projected point lies outside of the line segment, the projected point will 
        //be clamped to the appropriate line edge.
        //If the line is infinite instead of a segment, use ProjectPointOnLine() instead.
        private Vector3 ProjectPointOnLineSegment(Vector3 linePoint1, Vector3 linePoint2, Vector3 point, out int side)
        {
            Vector3 vector = linePoint2 - linePoint1;

            Vector3 projectedPoint = ProjectPointOnLine(linePoint1, vector.normalized, point);

            side = PointOnWhichSideOfLineSegment(linePoint1, linePoint2, projectedPoint);

            //The projected point is on the line segment
            if (side == 0)
                return projectedPoint;

            if (side == 1)
                return linePoint1;

            if (side == 2)
                return linePoint2;

            //output is invalid
            return Vector3.zero;
        }

        //This function finds out on which side of a line segment the point is located.
        //The point is assumed to be on a line created by linePoint1 and linePoint2. If the point is not on
        //the line segment, project it on the line using ProjectPointOnLine() first.
        //Returns 0 if point is on the line segment.
        //Returns 1 if point is outside of the line segment and located on the side of linePoint1.
        //Returns 2 if point is outside of the line segment and located on the side of linePoint2.
        private int PointOnWhichSideOfLineSegment(Vector3 linePoint1, Vector3 linePoint2, Vector3 point)
        {
            Vector3 lineVec = linePoint2 - linePoint1;
            Vector3 pointVec = point - linePoint1;

            float dot = Vector3.Dot(pointVec, lineVec);

            //point is on side of linePoint2, compared to linePoint1
            if (dot > 0)
            {
                //point is on the line segment
                if (pointVec.magnitude <= lineVec.magnitude)
                    return 0;

                //point is not on the line segment and it is on the side of linePoint2
                else
                    return 2;
            }

            //Point is not on side of linePoint2, compared to linePoint1.
            //Point is not on the line segment and it is on the side of linePoint1.
            else
                return 1;
        }

		private bool IsPointInRock(Vector3 pointPosition, float distance, out int rocksUnderPoint)
		{
			rocksUnderPoint = 0;
			
			RaycastHit[] hits = Physics.RaycastAll(new Ray(pointPosition + Vector3.down * distance, Vector3.up), distance, world_defaultLayer);
			foreach (RaycastHit hit in hits)
            {
                MeshCollider collider = hit.collider.GetComponent<MeshCollider>();
                if (collider == null || !collider.sharedMesh.name.StartsWith("rock_"))
                    continue;
				
				RaycastHit hitInfo;
				if (!hit.collider.Raycast(new Ray(pointPosition, Vector3.down), out hitInfo, distance))
					return true;
				else
					rocksUnderPoint += 1;
            }

			return false;			
		}
		
        private void ProcessShots(BasePlayer player)
        {
            if (player != null)
				if (PlayersFiredProjectlesData.ContainsKey(player.userID))
                    if (UnityEngine.Time.realtimeSinceStartup - PlayersFiredProjectlesData[player.userID].lastFiredTime >= 2f && !PlayersFiredProjectlesData[player.userID].isChecked)
                    {
						int firedShotsDataCnt = 0;
						ItemId curWeaponUID = default(ItemId);
						string curAmmoName = "";
						double curFiredTime = 0;
						float timeIntervalBetweenShots;
						float maxTimeIntervalBetweenShots = 0f;
						float NRProbabilityModifier = 1f;
						bool isFirstShot = true;
						
                        Dictionary<int, FiredShotsData> firedShotsData = new Dictionary<int, FiredShotsData>();
                        FiredShotsData fsd;
                        firedShotsDataCnt++;
                        FiredProjectile curFiredProjectile;
        
                        foreach (KeyValuePair<int, FiredProjectile> list in PlayersFiredProjectlesData[player.userID].firedProjectiles.ToArray())
                        {
                            curFiredProjectile = PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key];
        
                            if (!curFiredProjectile.isChecked)
                            {
                                if (!_config.weaponsConfig[curFiredProjectile.weaponShortName].NRDetectEnabled)
                                {
                                    curFiredProjectile.isChecked = true;
                                    continue;
                                }
        
                                if (isFirstShot)
                                {
                                    curFiredProjectile.isChecked = true;
                                    PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                    firedShotsData.Add(firedShotsData.Count + 1, fsd = new FiredShotsData());
                                    firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                    curWeaponUID = curFiredProjectile.weaponUID;
                                    curAmmoName = curFiredProjectile.ammoShortName;
                                    curFiredTime = curFiredProjectile.firedTime.Ticks;
                                    maxTimeIntervalBetweenShots = _config.weaponsConfig[curFiredProjectile.weaponShortName].weaponMaxTimeShotsInterval;
                                    firedShotsData[firedShotsData.Count].weaponShortName = curFiredProjectile.weaponShortName;
                                    firedShotsData[firedShotsData.Count].ammoShortName = curFiredProjectile.ammoShortName;
                                    firedShotsData[firedShotsData.Count].attachments = curFiredProjectile.attachments;
                                    isFirstShot = false;
                                    NRProbabilityModifier = curFiredProjectile.NRProbabilityModifier;
                                    continue;
                                }
        
                                timeIntervalBetweenShots = (float)(curFiredProjectile.firedTime.Ticks - curFiredTime) / 10000000f;
                                
								if (!(curFiredProjectile.weaponUID == curWeaponUID) || !(curFiredProjectile.ammoShortName == curAmmoName) || timeIntervalBetweenShots > maxTimeIntervalBetweenShots)
                                {
                                    firedShotsDataCnt++;
                                    firedShotsData.Add(firedShotsDataCnt, fsd = new FiredShotsData());
                                    curFiredProjectile.isChecked = true;
                                    PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                    firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                    curWeaponUID = curFiredProjectile.weaponUID;
                                    curAmmoName = curFiredProjectile.ammoShortName;
                                    curFiredTime = curFiredProjectile.firedTime.Ticks;
                                    maxTimeIntervalBetweenShots = _config.weaponsConfig[curFiredProjectile.weaponShortName].weaponMaxTimeShotsInterval;
                                    firedShotsData[firedShotsData.Count].weaponShortName = curFiredProjectile.weaponShortName;
									if (firedShotsData[firedShotsData.Count].attachments.Count < curFiredProjectile.attachments.Count) 
										firedShotsData[firedShotsData.Count].attachments = curFiredProjectile.attachments;
                                    continue;
                                }
								
                                curFiredProjectile.isChecked = true;
                                PlayersFiredProjectlesData[player.userID].firedProjectiles[list.Key] = curFiredProjectile;
                                firedShotsData[firedShotsData.Count].firedShots.Add(list.Key, curFiredProjectile);
                                curFiredTime = curFiredProjectile.firedTime.Ticks;
                            }
                        }
        
                        PlayersFiredProjectlesData[player.userID].isChecked = true;
        
                        if (firedShotsData != null)
							foreach (KeyValuePair<int, FiredShotsData> list in firedShotsData.ToArray().Where(x => (firedShotsData[x.Key].firedShots.Count >= _config.weaponsConfig[firedShotsData[firedShotsData.Count].weaponShortName].NRMinShotsCountToCheck)))
								ProcessFiredShotsBlock(player, firedShotsData[list.Key], NRProbabilityModifier);
                    }
        }

        private void ProcessFiredShotsBlock(BasePlayer player, FiredShotsData fsd, float NRProbabilityModifier)
        {
            if (player != null && fsd != null)
            {
                int shotsCnt = 0;
                int violationProbabilityForgiveness = 0;
                int prevKey = 0;
                int curKey;
                int NoRecoilViolationsCnt = 0;
                int MoveCntShot = 0;
                int firstKey = 0;
                float angleBetweenShots = 0f;
				float angleWithVectorUpSum = 0f;
                float recoilScreenDistance = 0f;
                string _text = "";
				string shotDataTxt = "";
                bool isNoRecoil = false;
                bool isPrevNoRecoilViolation = false;
                bool isShootedInMotion = false;
                Vector2 scrPoint1 = new Vector2(500, 500);
                Vector2 scrPoint2 = new Vector2();
                Vector3 closestPointLine1 = new Vector3();
                Vector3 closestPointLine2 = new Vector3();
                Vector3 prevIntersectionPoint = new Vector3();
                Vector3 prevIPoint = new Vector3();
                Vector3 point1 = new Vector3();
                Vector3 point2 = new Vector3();
                Matrix4x4 viewMatrix = new Matrix4x4();
                Matrix4x4 perspectiveMatrix = new Matrix4x4();
                Matrix4x4 worldMatrix = Matrix4x4.identity;
                NoRecoilViolationData violationData = new NoRecoilViolationData();
                FiredProjectile prevFiredProjectile = new FiredProjectile();
                FiredProjectile curFiredProjectile = new FiredProjectile();
                SuspiciousProjectileData spd = new SuspiciousProjectileData();
				Dictionary<int, string> shotsList = new Dictionary<int, string>();

                foreach (KeyValuePair<int, FiredProjectile> list in fsd.firedShots.ToArray())
                {
                    curFiredProjectile = fsd.firedShots[list.Key];

                    if (curFiredProjectile.isMounted)
                    {
                        violationData.isMounted = true;
						Quaternion q = new Quaternion(curFiredProjectile.mountParentRotation.x, curFiredProjectile.mountParentRotation.y, curFiredProjectile.mountParentRotation.z, curFiredProjectile.mountParentRotation.w); 
                        viewMatrix = Matrix4x4.LookAt(curFiredProjectile.mountParentPosition, curFiredProjectile.mountParentPosition + (q * Vector3.forward), Vector3.up).inverse;
                        curFiredProjectile.projectileVelocity = viewMatrix.MultiplyPoint(curFiredProjectile.projectilePosition + curFiredProjectile.projectileVelocity);
                        curFiredProjectile.projectilePosition = viewMatrix.MultiplyPoint(curFiredProjectile.projectilePosition);
                        curFiredProjectile.projectileVelocity -= curFiredProjectile.projectilePosition;
                    }

                    curKey = list.Key;
                    isNoRecoil = false;
                    violationData.ShotsCnt++;
                    shotsCnt++;
					
					angleWithVectorUpSum += Vector3.Angle(Vector3.Normalize(curFiredProjectile.projectileVelocity), Vector3.up);

                    if (shotsCnt == 1)
                    {
                        firstKey = list.Key;
                        prevFiredProjectile = curFiredProjectile;
                        prevKey = curKey;
                        spd = new SuspiciousProjectileData();
                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        violationData.ammoShortName = curFiredProjectile.ammoShortName;
                        violationData.weaponShortName = curFiredProjectile.weaponShortName;
                        spd.timeStamp = curFiredProjectile.firedTime;
                        spd.isNoRecoil = false;
                        spd.isShootedInMotion = false;
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;
                        continue;
                    }

                    float timeInterval = (float)(curFiredProjectile.firedTime.Ticks - prevFiredProjectile.firedTime.Ticks) / 10000000f;

                    if (Vector3.Distance(prevFiredProjectile.projectilePosition, curFiredProjectile.projectilePosition) <= _config.EPSILON)
                    {
                        MoveCntShot = 0;
                        isShootedInMotion = false;
                        angleBetweenShots = Vector3.Angle(Vector3.Normalize(curFiredProjectile.projectileVelocity), Vector3.Normalize(prevFiredProjectile.projectileVelocity));

						shotDataTxt = Lang("StandingShooting", null) + " | " + Lang("RecoilAngle", null, angleBetweenShots) + " | " + Lang("FireTimeInterval", null, timeInterval);

                        if (angleBetweenShots < _config.NRViolationAngle)
                        {
                            isNoRecoil = true;
                            isPrevNoRecoilViolation = true;
                        }
                    }
                    else
                    {
                        MoveCntShot++;
                        isShootedInMotion = true;
                        
						if (ClosestPointsOnTwoLines(out closestPointLine1, out closestPointLine2, prevFiredProjectile.projectilePosition, prevFiredProjectile.projectileVelocity, curFiredProjectile.projectilePosition, curFiredProjectile.projectileVelocity))
                        {
							shotDataTxt = Lang("ShootingOnMove", null) + "\n" + Lang("ClosestPoint", null, closestPointLine1, closestPointLine2, prevIntersectionPoint) + "\n" + Lang("FireTimeInterval", null, timeInterval);

                            viewMatrix = Matrix4x4.LookAt(curFiredProjectile.projectilePosition, curFiredProjectile.projectilePosition + curFiredProjectile.projectileVelocity, Vector3.up).inverse;

                            perspectiveMatrix = Matrix4x4.Perspective(70f, 1.0f, 0.01f, 1000f);

                            point1 = viewMatrix.MultiplyPoint(closestPointLine1);

                            if (point1.z > 1)
                            {
                                if (MoveCntShot == 1)
                                    point2 = viewMatrix.MultiplyPoint(closestPointLine1);
                                else
                                    point2 = viewMatrix.MultiplyPoint(prevIntersectionPoint);

                                point2 = perspectiveMatrix.MultiplyPoint(point2);

                                scrPoint2.x = ((point2.x + 1.0f) / 2.0f) * 1000;
                                scrPoint2.y = ((point2.y + 1.0f) / 2.0f) * 1000;

                                angleBetweenShots = Vector3.Angle(curFiredProjectile.projectileVelocity, closestPointLine1 - curFiredProjectile.projectilePosition);
                                recoilScreenDistance = Vector2.Distance(scrPoint1, scrPoint2);

								shotDataTxt += "\n" + Lang("RecoilAngle", null, angleBetweenShots);

                                if (angleBetweenShots < _config.NRViolationAngle && recoilScreenDistance < _config.NRViolationScreenDistance)
                                {
                                    isNoRecoil = true;
                                    isPrevNoRecoilViolation = true;
                                }

                                if (MoveCntShot > 0 && isNoRecoil == false)
                                    MoveCntShot = 0;
                            }

                            prevIPoint = prevIntersectionPoint;
                            prevIntersectionPoint = closestPointLine2;

							shotDataTxt += "\n" + Lang("ScreenCoords", null, scrPoint1, scrPoint2) + "\n" + Lang("DistanceBetweenTwoPoints", null, recoilScreenDistance) + "\n";
                        }
                    }

                    if (isPrevNoRecoilViolation && !isNoRecoil)
                    {
                        isPrevNoRecoilViolation = false;
                        violationProbabilityForgiveness++;
                    }

                    curFiredProjectile.isChecked = true;

                    if (isNoRecoil)
                    {
                        violationData.NRViolationsCnt++;
                        NoRecoilViolationsCnt++;
                        spd = new SuspiciousProjectileData();

                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        spd.closestPointLine1 = closestPointLine1;
                        spd.closestPointLine2 = closestPointLine2;
                        spd.recoilAngle = angleBetweenShots;
                        spd.recoilScreenDistance = recoilScreenDistance;
                        spd.isNoRecoil = true;
                        spd.isShootedInMotion = isShootedInMotion;
                        spd.timeInterval = timeInterval;
                        spd.timeStamp = curFiredProjectile.firedTime;
                        spd.prevIntersectionPoint = prevIPoint;

                        angleBetweenShots = 0f;
                        recoilScreenDistance = 0f;

                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;

                        if (!violationData.suspiciousNoRecoilShots[shotsCnt - 1].isNoRecoil)
                        {
                            NoRecoilViolationsCnt++;
                            spd = violationData.suspiciousNoRecoilShots[shotsCnt - 1];
                            spd.isNoRecoil = true;
                            violationData.suspiciousNoRecoilShots[shotsCnt - 1] = spd;
                        }
                    }
                    else
                    {
                        violationData.NRViolationsCnt++;
                        spd = new SuspiciousProjectileData();

                        spd.projectile1ID = prevKey;
                        spd.projectile2ID = curKey;
                        spd.projectile1Position = prevFiredProjectile.projectilePosition;
                        spd.projectile1Velocity = prevFiredProjectile.projectileVelocity;
                        spd.projectile2Position = curFiredProjectile.projectilePosition;
                        spd.projectile2Velocity = curFiredProjectile.projectileVelocity;
                        spd.isNoRecoil = false;
                        spd.timeInterval = timeInterval;
                        spd.timeStamp = curFiredProjectile.firedTime;

                        violationData.suspiciousNoRecoilShots.Add(shotsCnt, new SuspiciousProjectileData());
                        violationData.suspiciousNoRecoilShots[shotsCnt] = spd;
                    }

                    prevFiredProjectile = curFiredProjectile;
                    prevKey = curKey;
					shotsList.Add(list.Key, shotDataTxt);
                }

                float violationProbability = ((NoRecoilViolationsCnt * 100f) / (fsd.firedShots.Count + violationProbabilityForgiveness)) * NRProbabilityModifier;

                if (violationProbability > _config.weaponsConfig[fsd.weaponShortName].NRViolationProbability && (angleWithVectorUpSum/fsd.firedShots.Count) > 30f)
                {
                    _text = "\n" + Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count;
                    
					if (fsd.attachments.Count > 0)
                        for (int j = 0; j < fsd.attachments.Count; j++)
                            _text += "\n" + Lang("Attachment", null) + " - " + fsd.attachments[j];

                    violationData.mountParentPosition = fsd.firedShots[firstKey].mountParentPosition;
                    violationData.mountParentRotation = fsd.firedShots[firstKey].mountParentRotation;
                    violationData.violationProbability = violationProbability;
                    violationData.attachments = fsd.attachments;

                    AddNoRecoilViolationToPlayer(player, violationData);
					
                    int NRViolationsCnt = PlayersViolations.Players[player.userID].noRecoilViolations.Count;
					
			        if (Interface.CallHook("API_ArkanOnNoRecoilViolation", player, NRViolationsCnt, JsonConvert.SerializeObject(violationData)) != null)
					{
						return;
					}
					
                    string conText = Lang("NRDetection", null) + "\n" + Lang("PlayerTxt", null) + " " + player.displayName + "/" + player.userID + "\n" + Lang("NRViolationNum", null) + PlayersViolations.Players[player.userID].noRecoilViolations.Count + "\n" + Lang("ShotsCount", null) + " " + violationData.suspiciousNoRecoilShots.Count + "\n" + Lang("Probability", null) + " " + violationProbability + "%" + _text + "\n" + Lang("Weapon", null) + " - " + violationData.weaponShortName + " \n" + Lang("Ammo", null) + " - " + violationData.ammoShortName;

					foreach (KeyValuePair<int, string> list in shotsList.ToArray())
						conText += "\n" + Lang("ProjectileID", null, list.Key) + " | " + shotsList[list.Key];

                    Puts(conText);
					 
					if (_config.DiscordNRReportEnabled)
						if (DiscordMessages == null)
							PrintWarning(Lang("DiscordWarning2", null));
						else
						{
							List<EmbedFieldList> fields = new List<EmbedFieldList>();
							
							string dmPlayer = $"[{player.displayName}\n{player.UserIDString}](https://steamcommunity.com/profiles/{player.UserIDString})";
							if (dmPlayer.Length == 0) dmPlayer = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("PlayerTxt", null),
								inline = false,
								value = dmPlayer
							});
							
							string dmVNum = $"{PlayersViolations.Players[player.userID].noRecoilViolations.Count}";
							if (dmVNum.Length == 0) dmVNum = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("NRViolationNum", null),
								inline = true,
								value = dmVNum
							});
							
							string dmProbability = $"{violationProbability}%";
							if (dmProbability.Length == 0) dmProbability = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Probability", null),
								inline = true,
								value = dmProbability
							});
							
							string dmShotsCount = $"{violationData.suspiciousNoRecoilShots.Count}";
							if (dmShotsCount.Length == 0) dmShotsCount = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("ShotsCount", null),
								inline = true,
								value = dmShotsCount
							});
							
							string dmWeapon = violationData.weaponShortName;
							if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Weapon", null),
								inline = true,
								value = dmWeapon
							});
							
							string dmAmmo = violationData.ammoShortName;
							if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
							fields.Add(new EmbedFieldList()
							{
								name = Lang("Ammo", null),
								inline = true,
								value = dmAmmo
							});
							
							if (fsd.attachments.Count == 0)
							{
								fields.Add(new EmbedFieldList()
								{
									name = Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count,
									inline = true,
									value = Lang("NoAttachments", null)
								});
							}
							else
							{
								string dmAttachmentsList = "";
								for (int j = 0; j < fsd.attachments.Count; j++)
									dmAttachmentsList += fsd.attachments[j] + "\n";
								
								if (dmAttachmentsList.Length == 0) dmAttachmentsList = stringNullValueWarning;								
								fields.Add(new EmbedFieldList()
								{
									name = Lang("AttachmentsCount", null) + " = " + fsd.attachments.Count,
									inline = true,
									value = dmAttachmentsList
								});
							}
							
							string dmProjectileData = "";
							foreach (KeyValuePair<int, string> list in shotsList.ToArray())
							{
								dmProjectileData = shotsList[list.Key];
								if (dmProjectileData.Length == 0) dmProjectileData = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("ProjectileID", null, list.Key),
									inline = false,
									value = dmProjectileData
								});
							}
							
							var fieldsObject = fields.Cast<object>().ToArray();
							
							string json = JsonConvert.SerializeObject(fieldsObject);

							DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordNRWebhookURL, "Arkan: " + Lang("NRDetection", null), 39423, json);
						}

                    foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
					{
						if (permission.UserHasPermission(_player.UserIDString, permNRReportChat))
							SendReply(_player, Lang("PlayerNRViolation", _player.UserIDString, player.displayName, player.userID, NRViolationsCnt, fsd.firedShots.Count, NoRecoilViolationsCnt, violationProbability));
						
						if (permission.UserHasPermission(_player.UserIDString, permNRReportConsole))
							_player.ConsoleMessage("<color=green>Arkan:</color> " + Lang("PlayerNRViolationCon", _player.UserIDString, player.displayName, player.userID, NRViolationsCnt, fsd.firedShots.Count, NoRecoilViolationsCnt, violationProbability));
						
                        if (permission.UserHasPermission(_player.UserIDString, permNRDrawViolation))
							DrawNoRecoilViolationsData(_player, player.displayName, violationData, false);
					}
                }
            }
        }
		
		private void ShootingInRockCheck(BasePlayer player, FiredProjectile fp, HitInfo info, string bodyPart, float physicsSteps)
		{			
			if (player != null && fp != null && info != null)
			{					
				if (_config.checkBlacklist)
				{
					if (!permission.UserHasPermission(player.UserIDString, permIRBlacklist))
						return;
				}
				else
					if (permission.UserHasPermission(player.UserIDString, permIRWhitelist))
						return;
				
				RaycastHit hit = new RaycastHit();
				int rocksUnderPoint = 0;
				bool isColliderTerrain = Physics.Raycast(fp.projectilePosition + Vector3.up * 250f, Vector3.down, out hit, 250f, terrainLayer);
				bool isPointInRock = IsPointInRock(fp.projectilePosition, _config.inRockCheckDistance, out rocksUnderPoint);

				if (!isPointInRock && !isColliderTerrain)
					return;	

				RaycastHit worldHit = new RaycastHit();
				bool isHit = false;
				float totalDistance = info.ProjectileDistance;
				float dist = 0;
				Vector3 pointStart = new Vector3();
				Vector3 pointEnd = new Vector3();
				
				float fixedDeltaTime = 1f / physicsSteps;
				Vector3 position = fp.projectilePosition;
				Vector3 vector1 = fp.projectileVelocity / physicsSteps;
				Vector3 vector2 = ((Physics.gravity * info.ProjectilePrefab.gravityModifier) / physicsSteps) * fixedDeltaTime;
				float single1 = info.ProjectilePrefab.drag * fixedDeltaTime;
				int segmentsCnt = (int)(physicsSteps * 8);
				
				string lastKey = "";
				int vsCnt = 0;
				int sCnt = 0;
				int layer = 0;

				if (isColliderTerrain && !isPointInRock)
					layer = world_terrainLayer;
				else
					layer = world_defaultLayer;
				
				for (int j = 0; j < segmentsCnt; j++)
                {						
					pointStart = position + vector1;
					pointEnd = position;					
					dist = vector1.magnitude;	
					
					if (totalDistance < dist)
					{
						dist = totalDistance;
						pointStart = pointEnd + ((pointStart - pointEnd).normalized * dist);
					}
					
					isHit = Physics.Raycast(pointStart, (pointEnd - pointStart).normalized, out hit, dist, layer);
					if (isHit)
					{
						if (!isColliderTerrain)
						{
							MeshCollider collider = hit.collider.GetComponent<MeshCollider>();
							if (collider is MeshCollider)
							if (collider == null || !collider.sharedMesh.name.StartsWith("rock_"))
								break;	
						}
						else
						{
							if(Physics.Raycast(fp.projectilePosition + Vector3.up * 0.1f, Vector3.down, out worldHit, 50f, world_defaultLayer))
							{
								MeshCollider worldCollider = worldHit.collider.GetComponent<MeshCollider>();
								if (worldCollider != null)
								{
									if(!worldCollider.sharedMesh.name.StartsWith("rock_") && !isPointInRock)
										break;	
									else
									{
										if (rocksUnderPoint > 0 && !isPointInRock)
											break;
									}
								}
							}
						}
						
						InRockViolationData irvd = new InRockViolationData();
						
						irvd.dateTime = DateTime.Now;
						irvd.physicsSteps = physicsSteps;
						irvd.targetHitDistance = info.ProjectileDistance;
						irvd.targetHitPosition = info.HitPositionWorld;
						irvd.firedProjectile = fp;
						irvd.rockHitPosition = hit.point;
						irvd.targetName = info.HitEntity.ToPlayer().displayName;
                        irvd.targetID = info.HitEntity.ToPlayer().userID.ToString();
						irvd.targetDamage = info.damageTypes.Total();
						irvd.targetBodyPart = bodyPart;
						irvd.projectileID = info.ProjectileID;
						irvd.drag = info.ProjectilePrefab.drag;
						irvd.gravityModifier = info.ProjectilePrefab.gravityModifier;						
												
						if (PlayersViolations.Players.ContainsKey(player.userID))
							if (PlayersViolations.Players[player.userID].inRockViolations.Count > 0)
							{
								lastKey = PlayersViolations.Players[player.userID].inRockViolations.Keys.Last();
								sCnt = PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Count;
								vsCnt = PlayersViolations.Players[player.userID].inRockViolations.Count;
								
								if (PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].firedProjectile.weaponShortName == fp.weaponShortName)
									if (PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].firedProjectile.ammoShortName == fp.ammoShortName)
									{									
										float timeIntervalBetweenShots = (float)(irvd.dateTime.Ticks - PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt].dateTime.Ticks) / 10000000f;
							
										if (timeIntervalBetweenShots < 0.15625f)								
										{
											PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Add(sCnt + 1, new InRockViolationData());
											PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData[sCnt + 1] = irvd;
											
											timer.Once(0.5f, () => InRockNotification(player, lastKey, vsCnt, sCnt + 1));
											
											break;
										}
									}
							}
						
						InRockViolationsData violationData = new InRockViolationsData();
						violationData.dateTime = irvd.dateTime;
						int index = 1;
						violationData.inRockViolationsData.Add(index, new InRockViolationData());
						violationData.inRockViolationsData[index] = irvd;						
	
						AddInRockViolationToPlayer(player, violationData);
						
						lastKey = PlayersViolations.Players[player.userID].inRockViolations.Keys.Last();
						vsCnt = PlayersViolations.Players[player.userID].inRockViolations.Count;
						sCnt = PlayersViolations.Players[player.userID].inRockViolations[lastKey].inRockViolationsData.Count;
						
						timer.Once(0.5f, () => InRockNotification(player, lastKey, vsCnt, sCnt));
						
						break;
					}
					
					position += vector1;

					vector1 += vector2;
					vector1 -= (vector1 * single1);
					
					totalDistance -= dist;
					if (totalDistance < 0f)
						break;
				}
			}
		}	

		private void InRockNotification(BasePlayer player, string key, int vsCnt, int sCnt)
        {
			if (PlayersViolations.Players.ContainsKey(player.userID))
				if (PlayersViolations.Players[player.userID].inRockViolations.ContainsKey(key))
					if (PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count == sCnt)
					{
						string pTxt = Lang("IRDetection", null) + "\n" + Lang("PlayerTxt", null) + " " + player.displayName + "/" + player.userID + "\n" + Lang("IRViolationNum", null) + vsCnt + " " + key + "\n" + Lang("Weapon", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.weaponShortName + "\n" + Lang("Ammo", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.ammoShortName + "\n" + Lang("ShotsCount", null) + " " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count + "\n";
						for (int j = 1; j <= PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count; j++)
						{
							pTxt += Lang("ProjectileID", null, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].projectileID) + " | " + Lang("Target", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetName + "/" + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetID + " | " + Lang("HitPart", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetBodyPart + " | " + Lang("Damage", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[j].targetDamage + "\n";
						}

						Puts(pTxt);

						if (Interface.CallHook("API_ArkanOnInRockViolation", player, vsCnt, JsonConvert.SerializeObject(PlayersViolations.Players[player.userID].inRockViolations[key])) != null)
						{
							return;
						}
						
						foreach (var _player in BasePlayer.activePlayerList.Where(x => x.IsAdmin && permission.UserHasPermission(x.UserIDString, permName)))
						{
							if (permission.UserHasPermission(_player.UserIDString, permIRReportChat))
								SendReply(_player, Lang("PlayerIRViolation", _player.UserIDString, player.displayName, player.userID, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count));
							
							if (permission.UserHasPermission(_player.UserIDString, permIRReportConsole))
								_player.ConsoleMessage(Lang("PlayerIRViolationCon", _player.UserIDString, player.displayName, player.userID, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count));
							
                            if(permission.UserHasPermission(_player.UserIDString, permIRDrawViolation))
								DrawInRockViolationsData(_player, player.displayName, player.UserIDString, vsCnt, PlayersViolations.Players[player.userID].inRockViolations[key], false);
						}	

						if (_config.DiscordIRReportEnabled)
							if (DiscordMessages == null)
								PrintWarning(Lang("DiscordWarning2", null));
							else
							{
								List<EmbedFieldList> fields = new List<EmbedFieldList>();
								
								string dmPlayer = $"[{player.displayName}\n{player.UserIDString}](https://steamcommunity.com/profiles/{player.UserIDString})";
								if (dmPlayer.Length == 0) dmPlayer = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("PlayerTxt", null),
									inline = true,
									value = dmPlayer
								});
								
								string dmVNum = $"{vsCnt}";
								if (dmVNum.Length == 0) dmVNum = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("IRViolationNum", null),
									inline = true,
									value = dmVNum
								});

								string dmShotsCnt = $"{sCnt}";
								if (dmShotsCnt.Length == 0) dmShotsCnt = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("ShotsCount", null),
									inline = true,
									value = dmShotsCnt
								});
								
								string dmWeapon = $"{PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.weaponShortName}";
								if (dmWeapon.Length == 0) dmWeapon = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("Weapon", null),
									inline = true,
									value = dmWeapon
								});
								
								string dmAmmo = $"{PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[1].firedProjectile.ammoShortName}";
								if (dmAmmo.Length == 0) dmAmmo = stringNullValueWarning;
								fields.Add(new EmbedFieldList()
								{
									name = Lang("Ammo", null),
									inline = true,
									value = dmAmmo
								});								
								
								string dmLogData = "";
								for (int k = 1; k <= PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData.Count; k++)
								{
									dmLogData = Lang("Target", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetName + "/" + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetID + ", " + Lang("HitPart", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetBodyPart + ", " + Lang("Damage", null) + ": " + PlayersViolations.Players[player.userID].inRockViolations[key].inRockViolationsData[k].targetDamage;
									if (dmLogData.Length == 0) dmLogData = stringNullValueWarning;
									fields.Add(new EmbedFieldList()
									{
										name = Lang("ProjectileID", null, k),
										inline = false,
										value = dmLogData
									});				
								}
																															
								var fieldsObject = fields.Cast<object>().ToArray();
								
								string json = JsonConvert.SerializeObject(fieldsObject);

								DiscordMessages?.Call("API_SendFancyMessage", _config.DiscordIRWebhookURL, "Arkan: " + Lang("IRDetection", null), 39423, json);
							}	
					}
		}			

        private bool ProcessProjectileTrajectory(out AIMViolationData aimvd, AIMViolationData aimvdIn, out List<TrajectorySegment> trajectorySegments, out List<TrajectorySegment> trajectorySegmentsRev, float gravityModifier, float drag)
        {
            Vector3 lsVecStart;
			Vector3 lsVecEnd;
			Vector3 lsVecStartRev;
			Vector3 lsVecEndRev;
            bool isLastSegmentOnProjectileTrajectoryPlane;
			bool isHitPointOnProjectileTrajectory;
			bool isProjectileStartPointAtEndReverseProjectileTrajectory;
			bool AIMViolation = false;
            float distanceFromHitPointToProjectilePlane;
			float projectileForgiveness = _config.projectileTrajectoryForgiveness * aimvdIn.forgivenessModifier;
			float _hitDistanceForgiveness = _config.hitDistanceForgiveness * aimvdIn.forgivenessModifier;
			float lengthLastSegmentProjectileTrajectory;
			float lengthLastSegmentReverseProjectileTrajectory;
            int side;
			trajectorySegments = new List<TrajectorySegment>();
			trajectorySegmentsRev = new List<TrajectorySegment>();
						
            aimvd = aimvdIn;
			aimvd.calculatedTravelDistance = 0f;
			
            for (int j = 0; j < aimvd.hitsData.Count; j++)
            {
                isLastSegmentOnProjectileTrajectoryPlane = IsLastSegmentCloseToProjectileTrajectoryPlane(aimvd.hitsData[j], projectileForgiveness, out distanceFromHitPointToProjectilePlane);
                isHitPointOnProjectileTrajectory = IsHitPointCloseToProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStart, out lsVecEnd, out aimvd.calculatedTravelDistance, out trajectorySegments, aimvd.physicsSteps);

				lengthLastSegmentProjectileTrajectory = Vector3.Distance(lsVecEnd, lsVecStart);
				lengthLastSegmentReverseProjectileTrajectory = Vector3.Distance(aimvd.hitsData[j].hitPointEnd, aimvd.hitsData[j].hitPointStart);

				if (Mathf.Abs(lengthLastSegmentProjectileTrajectory - lengthLastSegmentReverseProjectileTrajectory) > lengthLastSegmentProjectileTrajectory * 0.05f)
				{						
					Vector3 pointStartProjectedOnLastSegment = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPointStart);
					Vector3 pointEndProjectedOnLastSegment = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPointEnd);
					
					if (Vector3.Distance(aimvd.hitsData[j].hitPointStart, pointStartProjectedOnLastSegment) < _config.projectileTrajectoryForgiveness && Vector3.Distance(aimvd.hitsData[j].hitPointEnd, pointEndProjectedOnLastSegment) < _config.projectileTrajectoryForgiveness && (Mathf.Abs(Vector3.Distance(pointEndProjectedOnLastSegment, pointStartProjectedOnLastSegment)) - lengthLastSegmentReverseProjectileTrajectory) < lengthLastSegmentReverseProjectileTrajectory * 0.02f && (Mathf.Abs(Vector3.Distance(pointStartProjectedOnLastSegment, aimvd.hitsData[j].hitPointStart) - Vector3.Distance(pointEndProjectedOnLastSegment, aimvd.hitsData[j].hitPointEnd)) < 0.05f))
					{
						aimvd.physicsSteps = Mathf.Clamp((float)Math.Round((lengthLastSegmentProjectileTrajectory / lengthLastSegmentReverseProjectileTrajectory) * aimvd.physicsSteps, 1), 30f, 60f);
						isHitPointOnProjectileTrajectory = IsHitPointCloseToProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStart, out lsVecEnd, out aimvd.calculatedTravelDistance, out trajectorySegments, aimvd.physicsSteps);
					}
				}

                if (j != aimvd.hitsData.Count - 1)
                {
                    aimvd.hitsData[j].hitPointStart = lsVecStart;
                    aimvd.hitsData[j].hitPointEnd = lsVecEnd;
                }
				
                isProjectileStartPointAtEndReverseProjectileTrajectory = IsProjectileStartPointCloseToAtEndReverseProjectileTrajectory(aimvd.hitsData[j], gravityModifier, drag, projectileForgiveness, out lsVecStartRev, out lsVecEndRev, out trajectorySegmentsRev, aimvd.physicsSteps);

                aimvd.hitsData[j].lastSegmentPointStart = lsVecStart;
                aimvd.hitsData[j].lastSegmentPointEnd = lsVecEnd;
                aimvd.hitsData[j].reverseLastSegmentPointStart = lsVecStartRev;
                aimvd.hitsData[j].reverseLastSegmentPointEnd = lsVecEndRev;

                if (aimvd.hitsData.Count > 1 && j < aimvd.hitsData.Count - 1)
                {
                    float single3 = Vector3.Distance(lsVecStart, aimvd.hitsData[j].hitPositionWorld);
                    float single2 = aimvd.hitsData[j + 1].hitData.inVelocity.magnitude / aimvd.physicsSteps;
                    aimvd.hitsData[j + 1].delta = 1f - single3 * (1f / single2);
                    aimvd.hitsData[j + 1].travelDistance = aimvd.calculatedTravelDistance;
                }

                aimvd.hitsData[j].distanceFromHitPointToProjectilePlane = distanceFromHitPointToProjectilePlane;

                if (isLastSegmentOnProjectileTrajectoryPlane)
                {
                    if (distanceFromHitPointToProjectilePlane < _hitDistanceForgiveness)
                    {
						aimvd.hitsData[j].pointProjectedOnLastSegmentLine = ProjectPointOnLine(lsVecStart, (lsVecEnd - lsVecStart).normalized, aimvd.hitsData[j].hitPositionWorld);
						side = PointOnWhichSideOfLineSegment(lsVecStart, lsVecEnd, aimvd.hitsData[j].pointProjectedOnLastSegmentLine);
	
                        aimvd.hitsData[j].side = side;

                        if (side > 0)
                        {
							if (side == 1)
                            {
								if (Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, lsVecStart) > (_config.projectileTrajectoryForgiveness))	
                                {
                                    AIMViolation = true;
                                    aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = false;
                                }
                            }
                            else
                            {
								if (Vector3.Distance(aimvd.hitsData[j].hitPositionWorld, lsVecEnd) > (_config.projectileTrajectoryForgiveness))
                                {
                                    AIMViolation = true;
                                    aimvd.hitsData[j].isHitPointNearProjectileTrajectoryLastSegmentEndPoint = false;
                                }
                            }
                        }

                        if (!isHitPointOnProjectileTrajectory)
                        {
                            AIMViolation = true;
                            aimvd.hitsData[j].isHitPointOnProjectileTrajectory = false;
                        }

                        if (!isProjectileStartPointAtEndReverseProjectileTrajectory)
                        {
                            AIMViolation = true;
                            aimvd.hitsData[j].isProjectileStartPointAtEndReverseProjectileTrajectory = false;
                        }
                    }
                    else
                    {
                        AIMViolation = true;
                        aimvd.hitsData[j].isHitPointNearProjectilePlane = false;
                    }
                }
                else
                {
                    AIMViolation = true;
                    aimvd.hitsData[j].isLastSegmentOnProjectileTrajectoryPlane = false;
                }
            }

            return AIMViolation;
        }		
		
        private void AddNoRecoilViolationToPlayer(BasePlayer player, NoRecoilViolationData noRecoilViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = serverTimeStamp + "_" + DateTime.Now.Ticks + "_" + noRecoilViolationData.suspiciousNoRecoilShots[1].projectile2ID + "." + noRecoilViolationData.suspiciousNoRecoilShots[noRecoilViolationData.suspiciousNoRecoilShots.Count].projectile2ID;
                PlayersViolations.Players[player.userID].noRecoilViolations.Add(indexStr, new NoRecoilViolationData());
                PlayersViolations.Players[player.userID].noRecoilViolations[indexStr] = noRecoilViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private void AddAIMViolationToPlayer(BasePlayer player, AIMViolationData _AIMViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = DateTime.Now.Ticks + "_" + _AIMViolationData.projectileID;
                PlayersViolations.Players[player.userID].AIMViolations.Add(indexStr, new AIMViolationData());
                PlayersViolations.Players[player.userID].AIMViolations[indexStr] = _AIMViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private void AddInRockViolationToPlayer(BasePlayer player, InRockViolationsData InRockViolationData)
        {
            if (player != null)
            {
                if (!PlayersViolations.Players.ContainsKey(player.userID))
                {
                    PlayersViolations.Players.Add(player.userID, new PlayerViolationsData());
                    PlayersViolations.Players[player.userID].PlayerID = player.userID;
                    PlayersViolations.Players[player.userID].PlayerName = player.displayName;
                }

                string indexStr = serverTimeStamp + "_" + DateTime.Now.Ticks;
                PlayersViolations.Players[player.userID].inRockViolations.Add(indexStr, new InRockViolationsData());
                PlayersViolations.Players[player.userID].inRockViolations[indexStr] = InRockViolationData;
                PlayersViolations.lastChangeTime = DateTime.Now;
            }
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
			
            if (player is NPCPlayer) return true;
			
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
			
            return false;
        }

		private void AdminLogInit(BasePlayer player)
        {		
 			if (player != null)
			{
				if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, permName))
					return;

				if (!AdminsConfig.ContainsKey(player))
                {
                    AdminsConfig.Add(player, new AdminConfig());
                }
			}
		}

        private bool IsLastSegmentCloseToProjectileTrajectoryPlane(HitData hitData, float projectileForgiveness, out float distance)
        {
            Vector3 projectileStartPoint = hitData.startProjectilePosition;
            Vector3 projectileVelocity = hitData.startProjectileVelocity;
            Vector3 pointStart = hitData.hitPointStart;
            Vector3 pointEnd = hitData.hitPointEnd;
            Vector3 hitPoint = hitData.hitPositionWorld;

            Plane projectileTrajectoryPlane = new Plane(projectileStartPoint, projectileStartPoint + Vector3.up, projectileStartPoint + projectileVelocity);
            distance = Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(hitPoint));
			
            if (Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(pointStart)) <= projectileForgiveness && Math.Abs(projectileTrajectoryPlane.GetDistanceToPoint(pointEnd)) <= projectileForgiveness)
                return true;
			
            return false;
        }

        private bool IsHitPointCloseToProjectileTrajectory(HitData hitData, float gravityModifier, float drag, float projectileForgiveness, out Vector3 lsVecStart, out Vector3 lsVecEnd, out float travelDistance, out List<TrajectorySegment> trajectorySegments, float physicsSteps)
        {
            Vector3 hitPositionWorld = hitData.hitPositionWorld;
            Vector3 position = hitData.startProjectilePosition;
			float fixedDeltaTime = 1f / physicsSteps;
			Vector3 vector1 = hitData.startProjectileVelocity / physicsSteps;
			Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            float single1 = drag * fixedDeltaTime;
            float dist = 0.0f;
            int side;
			int segmentsCnt = (int)(physicsSteps * 8);
            Vector3 pointProjectedOnLine;
            float distanceFromHitPointToLastSegment;
			trajectorySegments = new List<TrajectorySegment>();
			
            if (hitData.delta != 1f)
            {
                float single4 = vector1.magnitude * hitData.delta;
                Vector3 vector3 = hitData.hitData.outVelocity.normalized * single4;
                position += vector3;

				pointProjectedOnLine = ProjectPointOnLine(position - vector3, vector3.normalized, hitPositionWorld);
				side = PointOnWhichSideOfLineSegment(position - vector3, position, pointProjectedOnLine);

                distanceFromHitPointToLastSegment = Vector3.Distance(hitPositionWorld, pointProjectedOnLine);
                dist += vector3.magnitude;

                if (side == 0 && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
                    lsVecStart = position - vector3;
                    lsVecEnd = position;
                    travelDistance = hitData.travelDistance + Vector3.Distance(hitData.startProjectilePosition, hitPositionWorld);

					trajectorySegments.Add(new TrajectorySegment());
					trajectorySegments[trajectorySegments.Count -1].pointStart = position - vector3;
					trajectorySegments[trajectorySegments.Count -1].pointEnd = position;

                    return true;
                }
            }

            for (int j = 0; j < segmentsCnt; j++)
            {
				pointProjectedOnLine = ProjectPointOnLine(position, vector1.normalized, hitPositionWorld);
				side = PointOnWhichSideOfLineSegment(position, position + vector1, pointProjectedOnLine);
				
                distanceFromHitPointToLastSegment = Vector3.Distance(hitPositionWorld, pointProjectedOnLine);

				trajectorySegments.Add(new TrajectorySegment());
				trajectorySegments[trajectorySegments.Count -1].pointStart = position;
				trajectorySegments[trajectorySegments.Count -1].pointEnd = position + vector1;
				
				if (side == 0 && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
					
                    lsVecStart = position;
                    lsVecEnd = position + vector1;
                    travelDistance = hitData.travelDistance + dist + Vector3.Distance(position, hitPositionWorld);
                    return true;
                }

                dist += vector1.magnitude;
                position += vector1;
                vector1 += vector2;
                vector1 -= (vector1 * single1);
            }

            lsVecStart = position;
            lsVecEnd = position + vector1;
            travelDistance = hitData.travelDistance + dist + Vector3.Distance((position), hitPositionWorld);
			
			trajectorySegments.Add(new TrajectorySegment());
			trajectorySegments[trajectorySegments.Count -1].pointStart = position;
			trajectorySegments[trajectorySegments.Count -1].pointEnd = position + vector1;
			
            return false;
        }

        private bool IsProjectileStartPointCloseToAtEndReverseProjectileTrajectory(HitData hitData, float gravityModifier, float drag, float projectileForgiveness, out Vector3 lsVecStart, out Vector3 lsVecEnd, out List<TrajectorySegment> trajectorySegmentsRev, float physicsSteps)
        {
            Vector3 projectileStartPoint = hitData.startProjectilePosition;
            Vector3 pointStart = hitData.hitPointStart;
            Vector3 pointEnd = hitData.hitPointEnd;
            Vector3 position = pointEnd;
            Vector3 vector1 = pointStart - pointEnd;
			float fixedDeltaTime = 1f / physicsSteps;
            Vector3 vector2 = ((-Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            float single1 = 1f / (1f - (drag * fixedDeltaTime));
            int side;
			int segmentsCnt = (int)(physicsSteps * 8);
            Vector3 pointProjectedOnLine;
            float distanceFromHitPointToLastSegment;
			trajectorySegmentsRev = new List<TrajectorySegment>();
			
            for (int j = 0; j < segmentsCnt; j++)
            {
                pointProjectedOnLine = ProjectPointOnLineSegment(position, position + vector1, projectileStartPoint, out side);
                distanceFromHitPointToLastSegment = Vector3.Distance(projectileStartPoint, pointProjectedOnLine) + 0.05f;
				
				trajectorySegmentsRev.Add(new TrajectorySegment());
				trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointStart = position;
				trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointEnd = position + vector1;

                if ((side == 0 || Vector3.Distance(position + vector1, projectileStartPoint) < projectileForgiveness) && distanceFromHitPointToLastSegment <= projectileForgiveness)
                {
                    lsVecStart = position;
                    lsVecEnd = position + vector1;
                    return true;
                }

                position += vector1;
                vector1 *= single1;
                vector1 -= vector2;
            }

            lsVecStart = position;
            lsVecEnd = position + vector1;
			
			trajectorySegmentsRev.Add(new TrajectorySegment());
			trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointStart = position;
			trajectorySegmentsRev[trajectorySegmentsRev.Count -1].pointEnd = position + vector1;
			
            return false;
        }

        private void DrawProjectileTrajectory(BasePlayer player, float _drawTime, AIMViolationData aimvd, Color lineColor)
        {
            if (player != null)
            {
				float physicsSteps = aimvd.physicsSteps;
				float fixedDeltaTime = 1f / physicsSteps;
                Vector3 position = aimvd.startProjectilePosition;
                Vector3 vector1 = aimvd.startProjectileVelocity / physicsSteps;
                float distance = aimvd.calculatedTravelDistance;
				float hitInfoDistance = aimvd.hitInfoProjectileDistance;
                float gravityModifier = aimvd.gravityModifier;
                float drag = aimvd.drag;
                Vector3 hitPoint = aimvd.hitInfoHitPositionWorld;
                Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
                bool isRicochet = false;
                int ricochetCnt = 0;
                float single1 = drag * fixedDeltaTime;
                float dist = 0.0f;
				int segmentsCnt = (int)(physicsSteps * 8);

                DDrawSphereToAdmin(player, _drawTime, Color.red, hitPoint, 0.05f);

                if (aimvd.hitsData.Count > 1)
                {
                    isRicochet = true;
                    ricochetCnt = 1;
                }

                for (int j = 0; j < segmentsCnt; j++)
                {
                    if (isRicochet)
                        if (Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition) <= (vector1.magnitude))
                        {
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, aimvd.hitsData[ricochetCnt].hitData.hitPosition, 0.1f);

                            float single3 = Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition);
                            float single2 = vector1.magnitude;
                            float single4 = 1f - single3 * (1f / single2);
                            position = aimvd.hitsData[ricochetCnt].hitData.hitPosition;
                            vector1 = aimvd.hitsData[ricochetCnt].hitData.outVelocity * fixedDeltaTime;

                            float single5 = vector1.magnitude * single4;
                            Vector3 vector3 = aimvd.hitsData[ricochetCnt].hitData.outVelocity.normalized * single5;

                            vector1 += vector2;
                            vector1 -= (vector1 * single1);
                            DDrawArrowToAdmin(player, _drawTime, Color.green, position, position + vector3, 0.1f);
                            position += vector3;
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                            dist += single3 + single5;

                            if ((aimvd.hitsData.Count - 1) > ricochetCnt)
                                ricochetCnt++;
                            else
                                isRicochet = false;
                        }
                        else
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                    if ((distance - dist) <= (vector1.magnitude))
                        break;
					
					if ((hitInfoDistance - dist) <= (vector1.magnitude))
						lineColor = Color.red;

                    dist += vector1.magnitude;
                    position += vector1;

                    vector1 += vector2;
                    vector1 -= (vector1 * single1);
                }
            }
        }

        private void DrawReverseProjectileTrajectory(BasePlayer player, float _drawTime, AIMViolationData aimvd, Color lineColor)
        {
            if (player != null)
            {
                Vector3 pointStart = aimvd.hitInfoPointStart;
                Vector3 pointEnd = aimvd.hitInfoPointEnd;
                Vector3 hitPoint = aimvd.hitInfoHitPositionWorld;
                float distance = aimvd.hitInfoProjectileDistance;
                float gravityModifier = aimvd.gravityModifier;
                float drag = aimvd.drag;
				float physicsSteps = aimvd.physicsSteps;
				float fixedDeltaTime = 1f / physicsSteps;
                Vector3 position = pointEnd;
                Vector3 vector1 = pointStart - pointEnd;
                Vector3 vector2 = ((-Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
                bool isRicochet = false;
                int ricochetCnt = 0;
                float single1 = 1f / (1f - (drag * fixedDeltaTime));
                float dist = 0.0f;
				int segmentsCnt = (int)(physicsSteps * 8);

                if (aimvd.hitsData.Count > 0)
                {
                    isRicochet = true;
                    ricochetCnt = aimvd.hitsData.Count - 1;
                }

                for (int j = 0; j < segmentsCnt; j++)
                {
                    if (isRicochet)
                        if (Vector3.Distance(position, aimvd.hitsData[ricochetCnt].hitData.hitPosition) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                        {
                            DDrawArrowToAdmin(player, _drawTime, Color.yellow, position, aimvd.hitsData[ricochetCnt].hitData.hitPosition, 0.1f);
                            position = aimvd.hitsData[ricochetCnt - 1].lastSegmentPointEnd;
                            vector1 = (aimvd.hitsData[ricochetCnt - 1].lastSegmentPointStart - aimvd.hitsData[ricochetCnt - 1].lastSegmentPointEnd);
                            DDrawArrowToAdmin(player, _drawTime, lineColor, aimvd.hitsData[ricochetCnt].hitData.hitPosition, aimvd.hitsData[ricochetCnt - 1].lastSegmentPointStart, 0.1f);

                            if (ricochetCnt > 0)
                                ricochetCnt--;
                            else
                                isRicochet = false;
                        }
                        else
                            DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                    if ((distance - dist) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                        break;

                    if (j == 0)
                        dist = Vector3.Distance(pointStart, hitPoint);
                    else
                        dist += vector1.magnitude;

                    position += vector1;
                    vector1 = (vector1 * single1) - vector2;
                }
            }
        }

        private void DrawProjectileTrajectory2(BasePlayer player, float _drawTime, FiredProjectile fp, HitInfo info, Color lineColor, float physicsSteps)
        {
            Vector3 position = fp.projectilePosition;
            Vector3 projectileVelocity = fp.projectileVelocity;
            float distance = info.ProjectileDistance;
            float gravityModifier = info.ProjectilePrefab.gravityModifier;
            float drag = info.ProjectilePrefab.drag;
            Vector3 hitPoint = info.HitPositionWorld;
			float fixedDeltaTime = 1f / physicsSteps;

            Vector3 vector1 = projectileVelocity / physicsSteps;
            Vector3 vector2 = ((Physics.gravity * gravityModifier) / physicsSteps) * fixedDeltaTime;
            bool isRicochet = false;
            int ricochetCnt = 0;
            float single1 = drag * fixedDeltaTime;
            float dist = 0.0f;
			int segmentsCnt = (int)(physicsSteps * 8);

            if (fp.hitsData.Count > 0)
            {
                isRicochet = true;
                ricochetCnt = 1;
            }

            for (int j = 0; j < segmentsCnt; j++)
            {
                if (isRicochet)
                    if (Vector3.Distance(position, fp.hitsData[ricochetCnt - 1].hitPosition) <= (vector1.magnitude + _config.projectileTrajectoryForgiveness))
                    {
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, fp.hitsData[ricochetCnt - 1].hitPosition, 0.1f);

                        float single3 = Vector3.Distance(position, fp.hitsData[ricochetCnt - 1].hitPosition);
                        float single2 = vector1.magnitude;
                        float single4 = 1f - single3 * (1f / single2);
                        position = fp.hitsData[ricochetCnt - 1].hitPosition;
                        vector1 = fp.hitsData[ricochetCnt - 1].outVelocity * fixedDeltaTime;

                        DDrawSphereToAdmin(player, _drawTime, Color.red, hitPoint, 0.2f);

                        float single5 = vector1.magnitude * single4;
                        Vector3 vector3 = fp.hitsData[ricochetCnt - 1].outVelocity.normalized * single5;

                        vector1 += vector2;
                        vector1 -= (vector1 * single1);
                        DDrawArrowToAdmin(player, _drawTime, Color.green, position, position + vector3, 0.1f);
                        position += vector3;
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                        dist += single3 + single5;

                        if (fp.hitsData.Count > ricochetCnt)
                            ricochetCnt++;
                        else
                            isRicochet = false;
                    }
                    else
                        DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);
                else
                    DDrawArrowToAdmin(player, _drawTime, lineColor, position, position + vector1, 0.1f);

                if ((distance - dist) <= (vector1.magnitude))
                    break;

                dist += vector1.magnitude;
                position += vector1;

                vector1 += vector2;
                vector1 -= (vector1 * single1);
            }
        }

		private bool IsRicochet(List<TrajectorySegment> trajectorySegments, List<TrajectorySegment> trajectorySegmentsRev, out HitData hitData1, out HitData hitData2, float physicsSteps)
        {
			Vector3 intersectPoint1 = new Vector3();
			Vector3 intersectPoint2 = new Vector3();
			
			hitData1 = new HitData();
			hitData2 = new HitData();
			
			for (int j = 0; j < trajectorySegments.Count; j++)
			{
				for (int i = 0; i < trajectorySegmentsRev.Count; i++)
				{
					if (ClosestPointsOnTwoLines(out intersectPoint1, out intersectPoint2, trajectorySegments[j].pointStart, trajectorySegments[j].pointEnd - trajectorySegments[j].pointStart, trajectorySegmentsRev[i].pointStart, trajectorySegmentsRev[i].pointEnd - trajectorySegmentsRev[i].pointStart))
					{
						if (Vector3.Distance(trajectorySegments[j].pointStart, intersectPoint1) <= Vector3.Distance(trajectorySegments[j].pointStart, trajectorySegments[j].pointEnd) && Vector3.Distance(trajectorySegmentsRev[i].pointStart, intersectPoint2) <= Vector3.Distance(trajectorySegmentsRev[i].pointStart, trajectorySegmentsRev[i].pointEnd) && Vector3.Distance(intersectPoint1, intersectPoint2) <= _config.projectileTrajectoryForgiveness)
						{
							hitData1.hitPositionWorld = intersectPoint1;
							hitData1.hitPointStart = trajectorySegments[j].pointStart;		
							hitData1.hitPointEnd = trajectorySegments[j].pointEnd;
							hitData2.hitData.inVelocity = (intersectPoint1 - trajectorySegments[j].pointStart) * physicsSteps;
							hitData2.hitData.inVelocity = (trajectorySegments[j].pointEnd - trajectorySegments[j].pointStart) * physicsSteps;
							
							hitData2.startProjectilePosition = intersectPoint1;
							hitData2.startProjectileVelocity = (trajectorySegmentsRev[i].pointStart - trajectorySegmentsRev[i].pointEnd) * physicsSteps;	
							hitData2.hitData.outVelocity = (trajectorySegmentsRev[i].pointStart - trajectorySegmentsRev[i].pointEnd) * physicsSteps;	
							hitData2.hitData.hitPosition = intersectPoint1;	
							return true;							
						}
					}
				}
			}			
			return false;
		}
        #endregion Functions
    }
}

// --- End of file: Arkan.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/active-sort ---
// --- Original File Path: A/ActiveSort/ActiveSort.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Active Sort", "Mevent", "1.0.7")]
    [Description("Sorts furnace and refinery on click")]
    internal class ActiveSort : RustPlugin
    {
        #region Fields

        private static ActiveSort _instance;

        private readonly Dictionary<BasePlayer, ActiveSortUI> _components = new Dictionary<BasePlayer, ActiveSortUI>();

        private const string PermUse = "activesort.use";

        private const string Layer = "UI.ActiveSort";

        private enum FurnaceType
        {
            Furnace,
            Refinery
        }

        private readonly Dictionary<string, string> _furnaceItems = new Dictionary<string, string>
        {
            ["sulfur.ore"] = "sulfur",
            ["metal.ore"] = "metal.fragments",
            ["hq.metal.ore"] = "metal.refined"
        };

        private readonly Dictionary<string, string> _refineryItems = new Dictionary<string, string>
        {
            ["crude.oil"] = "lowgradefuel"
        };

        #endregion

        #region Config

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "ShowUI")]
            public bool ShowUI = true;

            [JsonProperty(PropertyName = "ButtonPositionOffset")]
            public Vector2 ButtonPositionOffset = new Vector2(0, 0);

            [JsonProperty(PropertyName = "ButtonSize")]
            public Vector2 ButtonSize = new Vector2(115, 30);

            [JsonProperty(PropertyName = "ButtonColorHex")]
            public string ButtonColorHex = "#6F8344";

            [JsonProperty(PropertyName = "ButtonCaptionColorHex")]
            public string ButtonCaptionColorHex = "#A5BA7A";

            [JsonProperty(PropertyName = "ButtonCaptionFontSize")]
            public int ButtonCaptionFontSize = 16;

            [JsonProperty(PropertyName = "ButtonCaptionIsBold")]
            public bool ButtonCaptionIsBold;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _instance = this;

            permission.RegisterPermission(PermUse, this);
            if (!_config.ShowUI)
            {
                Unsubscribe(nameof(OnPlayerLootEnd));
                Unsubscribe(nameof(OnLootEntity));
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

            _components.Values.ToList().ForEach(component =>
            {
                if (component != null)
                    component.Kill();
            });

            _instance = null;
            _config = null;
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (CanSort(player) && GetComponent(player) == null)
                player.gameObject.AddComponent<ActiveSortUI>();
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            if (inventory == null) return;

            var ui = inventory.GetComponent<ActiveSortUI>();
            if (ui == null) return;

            ui.Kill();
        }

        #endregion

        #region Commands

        [ConsoleCommand("activesort.sort")]
        private void HandlerSortLoot(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || GetComponent(player) == null) return;

            SortLoot(player);
        }

        #endregion

        #region Component

        private class ActiveSortUI : FacepunchBehaviour
        {
            private readonly Vector2 _buttonBasePosition = new Vector2(365, 85);

            private BasePlayer _player;

            private void Awake()
            {
                _player = GetComponent<BasePlayer>();

                _instance._components[_player] = this;

                RenderUI();
            }

            private void RenderUI()
            {
                CuiHelper.DestroyUi(_player, Layer);
                CuiHelper.AddUi(_player, new CuiElementContainer
                {
                    {
                        new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.0",
                                AnchorMax = "0.5 0.0",
                                OffsetMax =
                                    $"{_buttonBasePosition.x + _config.ButtonPositionOffset.x + _config.ButtonSize.x / 2} " +
                                    $"{_buttonBasePosition.y + _config.ButtonPositionOffset.y + _config.ButtonSize.y / 2}",
                                OffsetMin =
                                    $"{_buttonBasePosition.x + _config.ButtonPositionOffset.x - _config.ButtonSize.x / 2} " +
                                    $"{_buttonBasePosition.y + _config.ButtonPositionOffset.y - _config.ButtonSize.y / 2}"
                            },
                            Text =
                            {
                                Align = TextAnchor.MiddleCenter,
                                Color = HexToCuiColor(_config.ButtonCaptionColorHex),
                                Font = _config.ButtonCaptionIsBold
                                    ? "RobotoCondensed-Bold.ttf"
                                    : "robotocondensed-regular.ttf",
                                Text = _instance.Msg("BUTTON_CAPTION", _player.UserIDString),
                                FontSize = _config.ButtonCaptionFontSize
                            },
                            Button =
                            {
                                Color = HexToCuiColor(_config.ButtonColorHex),
                                Command = "activesort.sort"
                            }
                        },
                        "Overlay", Layer
                    }
                });
            }

            private void OnDestroy()
            {
                CuiHelper.DestroyUi(_player, Layer);

                _instance?._components?.Remove(_player);

                Destroy(this);
            }

            public void Kill()
            {
                DestroyImmediate(this);
            }
        }

        #endregion

        #region Utils

        private ActiveSortUI GetComponent(BasePlayer player)
        {
            ActiveSortUI sortUI;
            return _components.TryGetValue(player, out sortUI) ? sortUI : null;
        }

        private static string HexToCuiColor(string hex, float alpha = 100)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6) throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100f}";
        }

        private void PutToContainer(Dictionary<uint, int> data, Dictionary<string, Item> items, string shortname,
            ItemContainer container,
            BasePlayer player, ref int spaceLeft, bool reserve = false)
        {
            if (items.ContainsKey(shortname))
            {
                var stackToContainer = TakeStack(data, items[shortname]);
                if (stackToContainer != null)
                {
                    stackToContainer.MoveToContainer(container);
                    ReturnToPlayer(data, player, items[shortname]);
                }
                else
                {
                    items[shortname].MoveToContainer(container);
                    items.Remove(shortname);
                }
            }

            if (items.ContainsKey(shortname) || reserve) spaceLeft--;
        }

        private Item TakeStack(Dictionary<uint, int> data, Item item, int targetCount = -1)
        {
            int count;

            if (!data.TryGetValue(item.uid, out count)) count = item.MaxStackable();

            if (targetCount != -1) count = Math.Min(count, targetCount);
            if (item.amount > count) return item.SplitItem(count);

            return null;
        }

        private void FilterOnlyNotProcessed(Dictionary<uint, int> data, Dictionary<string, Item> items,
            BasePlayer player, ItemContainer container,
            FurnaceType type)
        {
            var allowedItems = type == FurnaceType.Furnace ? _furnaceItems : _refineryItems;
            foreach (var shortname in items.Keys.ToList())
                if (allowedItems.ContainsValue(shortname) &&
                    !items.ContainsKey(allowedItems.FirstOrDefault(x => x.Value == shortname).Key))
                {
                    ReturnToPlayer(data, player, items[shortname]);
                    items.Remove(shortname);
                }
        }

        private void FilterWhitelist(Dictionary<uint, int> data, Dictionary<string, Item> items, BasePlayer player,
            ItemContainer container,
            FurnaceType type)
        {
            var allowedItems = type == FurnaceType.Furnace ? _furnaceItems : _refineryItems;
            foreach (var shortname in items.Keys.ToList())
                if (!allowedItems.ContainsKey(shortname) && !allowedItems.ContainsValue(shortname))
                {
                    ReturnToPlayer(data, player, items[shortname]);
                    items.Remove(shortname);
                }
        }

        private void ReturnToPlayer(Dictionary<uint, int> data, BasePlayer player, Item item)
        {
            while (item != null)
            {
                var nextToGive = TakeStack(data, item);
                if (nextToGive == null)
                {
                    nextToGive = item;
                    item = null;
                }

                player.GiveItem(nextToGive);
            }
        }

        private readonly Dictionary<BasePlayer, Dictionary<uint, int>> _stackByItem =
            new Dictionary<BasePlayer, Dictionary<uint, int>>();

        private Dictionary<string, Item> CloneAndPackItems(ItemContainer container, Dictionary<uint, int> data)
        {
            var items = new Dictionary<string, Item>();
            foreach (var it in container.itemList)
                if (items.ContainsKey(it.info.shortname))
                {
                    items[it.info.shortname].amount += it.amount;
                }
                else
                {
                    var item = ItemManager.Create(it.info, it.amount, it.skin);

                    items[it.info.shortname] = item;

                    int stackable;
                    if (data.TryGetValue(it.uid, out stackable))
                    {
                        data[item.uid] = stackable;

                        data.Remove(it.uid);
                    }
                }

            return items;
        }

        private void ClearContainer(ItemContainer container)
        {
            while (container.itemList.Count > 0)
            {
                var item = container.itemList[0];
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        #endregion

        #region Lang

        private string Msg(string key, string userIDString)
        {
            return lang.GetMessage(key, this, userIDString);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BUTTON_CAPTION"] = "Sort"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BUTTON_CAPTION"] = "Сортировать"
            }, this, "ru");
        }

        #endregion

        #region API

        private void SortLoot(BasePlayer player)
        {
            if (!CanSort(player)) return;

            if (player.inventory.loot.containers == null || player.inventory.loot.containers.Count == 0) return;

            var container = player.inventory.loot.containers[0];
            var furnace = player.inventory.loot.entitySource.GetComponent<BaseOven>();
            var type = FurnaceType.Furnace;
            if (furnace.name.Contains("refinery")) type = FurnaceType.Refinery;
            var allowedItems = type == FurnaceType.Furnace ? _furnaceItems : _refineryItems;

            if (!_stackByItem.ContainsKey(player))
                _stackByItem.Add(player, new Dictionary<uint, int>());

            var data = _stackByItem[player];

            foreach (var it in container.itemList.ToList())
            {
                data[it.uid] = it.MaxStackable();
                if (it.info.shortname != "wood" && !allowedItems.ContainsKey(it.info.shortname))
                    ReturnToPlayer(data, player, it);
            }

            var items = CloneAndPackItems(container, data);
            ClearContainer(container);

            var spaceLeft = container.capacity;
            PutToContainer(data, items, "wood", container, player, ref spaceLeft, true);
            PutToContainer(data, items, "charcoal", container, player, ref spaceLeft, true);
            FilterWhitelist(data, items, player, container, type);
            FilterOnlyNotProcessed(data, items, player, container, type);

            while (true)
            {
                var toSortKinds = items.Keys.Count(shortname => allowedItems.ContainsKey(shortname));
                if (toSortKinds == 0)
                {
                    if (items.Count > 0)
                        items.Keys.ToList().ForEach(shortname => { ReturnToPlayer(data, player, items[shortname]); });
                    break;
                }

                if (toSortKinds * 2 > spaceLeft)
                {
                    var toCancel = items.Keys.ToList()[0];
                    ReturnToPlayer(data, player, items[toCancel]);
                    if (items.ContainsKey(allowedItems[toCancel]))
                        ReturnToPlayer(data, player, items[allowedItems[toCancel]]);

                    items.Remove(toCancel);
                    items.Remove(allowedItems[toCancel]);
                    continue;
                }

                var cellForEach = spaceLeft / toSortKinds;
                var cellAdditional = spaceLeft % toSortKinds;

                var cellCountByName = new Dictionary<string, int>();
                foreach (var shortname in items.Keys)
                    if (allowedItems.ContainsKey(shortname))
                    {
                        cellCountByName[shortname] = cellForEach;
                        if (cellAdditional > 0)
                        {
                            cellCountByName[shortname]++;
                            cellAdditional--;
                        }
                    }

                foreach (var shortname in cellCountByName.Keys)
                {
                    var cellAmount = items[shortname].amount / (cellCountByName[shortname] - 1);
                    if (cellAmount > 0)
                        for (var i = 0; i < cellCountByName[shortname] - 2; i++)
                        {
                            var entry = TakeStack(data, items[shortname], cellAmount);
                            entry.MoveToContainer(container, -1, false);
                        }

                    var lastPart = TakeStack(data, items[shortname]);
                    if (lastPart == null)
                        lastPart = items[shortname];
                    else
                        ReturnToPlayer(data, player, items[shortname]);

                    lastPart.MoveToContainer(container, -1, false);
                    if (items.ContainsKey(allowedItems[shortname]))
                    {
                        var processedToContainer = TakeStack(data, items[allowedItems[shortname]]);
                        if (processedToContainer == null)
                            processedToContainer = items[allowedItems[shortname]];
                        else
                            ReturnToPlayer(data, player, items[allowedItems[shortname]]);

                        processedToContainer.MoveToContainer(container);
                    }

                    items.Remove(shortname);
                    items.Remove(allowedItems[shortname]);
                }
            }

            var longestCookingTime = 0.0f;

            foreach (var it in container.itemList)
            {
                var cookable = it.info.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    var cookingTime = cookable.cookTime * it.amount;
                    if (cookingTime > longestCookingTime) longestCookingTime = cookingTime;
                }
            }

            var fuelAmount = furnace.fuelType.GetComponent<ItemModBurnable>().fuelAmount;
            var neededFuel = Mathf.CeilToInt(longestCookingTime * (furnace.cookingTemperature / 200.0f) / fuelAmount);

            foreach (var it in container.itemList)
                if (it.info.shortname == "wood")
                {
                    if (neededFuel == 0)
                    {
                        ReturnToPlayer(data, player, it);
                    }
                    else if (it.amount > neededFuel)
                    {
                        var unneded = it.SplitItem(it.amount - neededFuel);
                        ReturnToPlayer(data, player, unneded);
                    }

                    break;
                }

            _stackByItem.Remove(player);
        }

        private bool CanSort(BasePlayer player)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PermUse)) return false;

            var furnace = player.inventory?.loot?.entitySource?.GetComponent<BaseOven>();
            return furnace != null && (furnace.name.Contains("furnace") || furnace.name.Contains("refinery"));
        }

        #endregion
    }
}

// --- End of file: ActiveSort.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-ladder-and-twig ---
// --- Original File Path: A/AntiLadderandTwig/AntiLadderandTwig.cs ---

﻿//#define Debug
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Anti Ladder and Twig", "kaucsenta", "1.3.1")]
    [Description("Protect bases from ladder and twig frames")]
    class AntiLadderandTwig : RustPlugin
    {
        public PluginConfig config;
        [PluginReference]
        Plugin AbandonedBases;
        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null)
                return null;
            if (permission.UserHasPermission(player.UserIDString, "antiladderandtwig.bypass"))
                return null;
            bool raidabse_flag = true;
            bool abandonedbse_flag = false;
            if (prefab.fullName.Contains("floor.prefab") || prefab.fullName.Contains("ladder.wooden.wall") || prefab.fullName.Contains("floor.frame") || prefab.fullName.Contains("floor.triangle.frame") || prefab.fullName.Contains("floor.triangle") 
                || prefab.fullName.Contains("shopfront") || prefab.fullName.Contains("shutter") || prefab.fullName.Contains("neon") || prefab.fullName.Contains("sign"))
            {
                if(target.entity != null)
                {
                    if(target.entity is SimpleBuildingBlock || target.entity is BuildingBlock || target.entity is ShopFront || target.entity is StabilityEntity ||target.entity is NeonSign ||target.entity is Signage)
                    {
                        if (target.entity.GetBuildingPrivilege() != null)
                        {
#if Debug
                            Puts(target.player.userID.ToString());
#endif
                            foreach (var tmpplayer in target.entity.GetBuildingPrivilege().authorizedPlayers)
                            {
                                if (covalence.Players.FindPlayerById(tmpplayer.userid.ToString()) != null)
                                {
#if Debug
                                    Puts(covalence.Players.FindPlayerById(tmpplayer.userid.ToString()).Name);
#endif
                                    //if there is any valid player autorized, then it is a raided raidbase or not a raidbase
                                    raidabse_flag = false;
                                }
                                if (tmpplayer.userid == target.player.userID)
                                {
#if Debug
                                    Puts("Valid");
#endif
                                    return null;
                                }
                            }
                            if (System.Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", target.position)))
                            {
#if Debug
                                Puts("Abandoned Base entity detected");
#endif
                                //if the entity is abaddoned, then ladder can be placed like raidable bases
                                abandonedbse_flag = true;
                            }
                            
                            if (raidabse_flag)
                            {
#if Debug
                                Puts("Raidable Base");
#endif
                                return null;
                            }else if(abandonedbse_flag)
                            {
#if Debug
                                Puts("Abandoned Base");
#endif
                                return null;
                            }
                            else
                            {
#if Debug
                                Puts("Not Valid");
#endif
                                player.ChatMessage(lang.GetMessage("CantPlace", this, player.UserIDString));
                                return false;
                            }
                        }
#if Debug
                        else
                        {
                            Puts("Not Protected");
                        }
#endif
                    }
#if Debug
                    else
                    {
                        Puts("Not building or High Wall");
                    }
#endif
                }
#if Debug
                else
                {
                    Puts("Target is not valid");
                }
#endif
            }
            return null;
        }

        void SubscribeHooks(bool flag)
        {
            if (flag)
            {
                Unsubscribe(nameof(CanBuild));
            }
            else
            {
                Subscribe(nameof(CanBuild));
            }
        }
        private void Init()
        {
            LoadVariables();
            SubscribeHooks(config.disableplugin);
            permission.RegisterPermission("antiladderandtwig.bypass", this);

        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig(config);
        }
        private void LoadConfigVariables()
        {
            config = Config.ReadObject<PluginConfig>();
        }
        public class PluginConfig
        {
            [JsonProperty(PropertyName = "Disable plugin feature true/false")]
            public bool disableplugin = false;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            config = new PluginConfig
            {
                disableplugin = false,
            };
            SaveConfig(config);
        }
        void SaveConfig(PluginConfig config, string filename = null) => Config.WriteObject(config, true, filename);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantPlace"] = "You can't place this here."
            }, this);
        }
    }
}


// --- End of file: AntiLadderandTwig.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-purge ---
// --- Original File Path: A/AutoPurge/AutoPurge.cs ---

// #define DEBUG

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Time = Oxide.Core.Libraries.Time;

namespace Oxide.Plugins
{
    [Info("Auto Purge", "misticos", "2.1.3")]
    [Description("Remove entities if the owner becomes inactive")]
    public class AutoPurge : CovalencePlugin
    {
        #region Variables

        private static AutoPurge _ins;

        private Dictionary<string, bool> _canPurgeCache = new Dictionary<string, bool>();
        private HashSet<string> _logCache = new HashSet<string>();
        
        private HashSet<string> _deployables = new HashSet<string>();

        [PluginReference("PlaceholderAPI")]
        private Plugin _placeholderAPI = null;

        private Time _time = GetLibrary<Time>();

        private Timer _timerPurge;

        private const string CommandRunPurgeName = "autopurge.run";
        private const string PermissionRunPurge = "autopurge.run";

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Purge Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<PurgeSettings> Purges = new List<PurgeSettings> {new PurgeSettings()};

            [JsonProperty(PropertyName = "Purge Timer Frequency")]
            public float PurgeFrequency = 900f;

            [JsonProperty(PropertyName = "Purge On Startup")]
            public bool PurgeOnStartup = false;

            [JsonProperty(PropertyName = "Entities Per Step")]
            public int EntitiesPerStep = 512;

            [JsonProperty(PropertyName = "Purge Building Blocks")]
            public bool PurgeBuildingBlocks = true;

            [JsonProperty(PropertyName = "Purge Deployables")]
            public bool PurgeDeployables = true;

            [JsonProperty(PropertyName = "Purge Sleepers")]
            public bool PurgeSleepers = true;

            [JsonProperty(PropertyName = "Use Logs")]
            public bool UseLogs = true;

            public class PurgeSettings
            {
                [JsonProperty(PropertyName = "Permission")]
                public string Permission = "";

                [JsonProperty(PropertyName = "Lifetime")]
                public string LifetimeRaw = "none";

                [JsonIgnore]
                public uint Lifetime = 0;

                [JsonIgnore]
                public bool NoPurge = false;

                public static PurgeSettings Find(string playerId)
                {
                    PurgeSettings best = null;

                    for (var i = 0; i < _ins._config.Purges.Count; i++)
                    {
                        var purge = _ins._config.Purges[i];
                        if (!string.IsNullOrEmpty(purge.Permission) &&
                            !_ins.permission.UserHasPermission(playerId, purge.Permission))
                            continue;

                        if (purge.NoPurge)
                            return purge;

                        if (best == null || best.Lifetime < purge.Lifetime)
                            best = purge;
                    }

                    return best;
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Work with Data

        private PluginData _data;

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        // ReSharper disable MemberCanBePrivate.Local
        private class PluginData
        {
            [JsonProperty("Users", NullValueHandling = NullValueHandling.Ignore,
                DefaultValueHandling = DefaultValueHandling.Ignore)]
#pragma warning disable 414
            public List<UserData> Users = null;

            // ReSharper disable once ClassNeverInstantiated.Local
            public class UserData
            {
                public string Id = "";

                public uint LastSeen = 0;
            }
#pragma warning restore 414

            public Dictionary<string, uint> LastSeen = new Dictionary<string, uint>();
        }
        // ReSharper restore MemberCanBePrivate.Local

        #endregion

        #region Commands

        private void CommandRunPurge(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionRunPurge))
            {
                player.Reply(GetMsg("No Permission", player.Id));
                return;
            }

            RunPurge(player);
        }

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have enough permissions"},
                {"Purge: Started", "The purge has been started."},
                {"Purge: Ended", "The purge has been completed. Purged entities: {purged}."}
            }, this);
        }

        private void Init()
        {
            _ins = this;
            LoadData();

            const string noPurgeLifetime = "none";

            for (var i = 0; i < _config.Purges.Count; i++)
            {
                var purge = _config.Purges[i];
                if (!string.IsNullOrEmpty(purge.Permission))
                    permission.RegisterPermission(purge.Permission, this);

                var isNoPurge = purge.LifetimeRaw.Equals(noPurgeLifetime, StringComparison.CurrentCultureIgnoreCase);
                if (!isNoPurge && !ConvertToSeconds(purge.LifetimeRaw, out purge.Lifetime))
                {
                    PrintWarning(
                        $"Unable to parse {purge.LifetimeRaw} value as Lifetime. Disabling purge for this purge setup");
                    purge.NoPurge = true;
                }

                if (isNoPurge)
                    purge.NoPurge = true;
            }

            if (_data.Users != null)
            {
                foreach (var user in _data.Users)
                    _data.LastSeen[user.Id] = user.LastSeen;

                _data.Users = null;
                SaveData();
            }

            permission.RegisterPermission(PermissionRunPurge, this);

            AddCovalenceCommand(CommandRunPurgeName, nameof(CommandRunPurge));
        }

        private void OnServerInitialized()
        {
            UpdateLastSeen(_time.GetUnixTimestamp());

            foreach (var item in ItemManager.itemList)
            {
                var deployable = item.GetComponent<ItemModDeployable>();
                if (deployable == null)
                    continue;

                _deployables.Add(deployable.entityPrefab.resourcePath);
            }

            if (_config.PurgeOnStartup)
                RunPurge();

            if (_config.PurgeFrequency > 0f)
                _timerPurge = timer.Every(_config.PurgeFrequency, () => RunPurge());
        }

        private void Unload()
        {
            _timerPurge?.Destroy();

            SaveData();

            _ins = null;
        }

        private void OnUserConnected(IPlayer player) => _data.LastSeen[player.Id] = _time.GetUnixTimestamp();

        private void OnUserDisconnected(IPlayer player) => _data.LastSeen[player.Id] = _time.GetUnixTimestamp();

        private void OnPlaceholderAPIReady()
        {
            _placeholderAPI?.CallHook("AddPlaceholder", this, "autopurge.lastseen",
                new Func<IPlayer, string, object>((p, o) =>
                {
                    uint lastSeen;
                    return !string.IsNullOrEmpty(p?.Id) && _data.LastSeen.TryGetValue(p.Id, out lastSeen)
                        ? _time.GetDateTimeFromUnix(lastSeen)
                        : (object) null;
                }),
                $"Date the player was last seen within {Title}. Options: \"local\" to use local time offset, UTC (default)");

            _placeholderAPI?.CallHook("AddPlaceholder", this, "autopurge.inactivefor",
                new Func<IPlayer, string, object>((p, o) =>
                {
                    uint lastSeen;
                    return !string.IsNullOrEmpty(p?.Id) && _data.LastSeen.TryGetValue(p.Id, out lastSeen)
                        ? TimeSpan.FromSeconds(_time.GetUnixTimestamp() - lastSeen)
                        : (object) null;
                }), $"Time since the player was last seen within {Title}");

            _placeholderAPI?.CallHook("AddPlaceholder", this, "autopurge.next",
                new Func<IPlayer, string, object>((p, o) =>
                {
                    uint lastSeen;
                    if (string.IsNullOrEmpty(p?.Id) || !_data.LastSeen.TryGetValue(p.Id, out lastSeen))
                        return null;

                    var settings = Configuration.PurgeSettings.Find(p.Id);
                    if (settings.NoPurge)
                        return null;

                    return _time.GetDateTimeFromUnix(lastSeen + settings.Lifetime);
                }), "Next purge for the specified player", 15d);
        }

        #endregion

        #region Last Seen

        private void UpdateLastSeen(uint timestamp)
        {
            foreach (var player in players.Connected)
            {
                _data.LastSeen[player.Id] = timestamp;
            }

            SaveData();
        }

        #endregion

        #region Purge

        private void RunPurge(IPlayer caller = null)
        {
            // Run a coroutine so that nothing lags
            InvokeHandler.Instance.StartCoroutine(RunPurgeEnumerator(caller));
        }

        private static readonly WaitForFixedUpdate WaitForFixedUpdate = new WaitForFixedUpdate();

        private IEnumerator RunPurgeEnumerator(IPlayer caller)
        {
            if ((caller?.IsConnected ?? false) && !caller.IsServer)
                caller.Reply(GetMsg("Purge: Started", caller.Id));
            Puts(GetMsg("Purge: Started", string.Empty));

            var purged = 0;
            var timestamp = _time.GetUnixTimestamp();

            UpdateLastSeen(timestamp);

#if DEBUG
            var entitiesCount = BaseNetworkable.serverEntities.entityList.Values.Count;
            var stopwatch = Stopwatch.StartNew();
#endif

            var entities = BaseNetworkable.serverEntities.entityList.Get().Values;
            for (var i = entities.Count - 1; i >= 0; i--)
            {
                // Has to be here, what if the plugin unloads when it's still purging?
                if (!IsLoaded)
                    break;

#if DEBUG
                stopwatch.Stop();
#endif

                if (i % _config.EntitiesPerStep == 0)
                    yield return WaitForFixedUpdate;

#if DEBUG
                stopwatch.Start();
#endif

                var entity = entities[i] as BaseCombatEntity;

                // Skipping invalid entities
                if (entity == null || entity.IsDestroyed || entity.IsNpc)
                    continue;

                if (_config.PurgeSleepers && entity is BasePlayer)
                {
                    var player = entity as BasePlayer; // player should never be an NPC
                    if (!player.IsConnected && CanPurgeUser(player.UserIDString, timestamp))
                    {
                        player.Die();
                        purged++;
                    }
                }

                if (_config.PurgeDeployables && _deployables.Contains(entity.PrefabName) ||
                    _config.PurgeBuildingBlocks && entity is BuildingBlock)
                {
                    var decayEntity = entity as DecayEntity;
                    if (CanPurge(entity.OwnerID, decayEntity == null
                        ? entity.GetBuildingPrivilege() // Use the fastest way if possible
                        : decayEntity.GetBuilding()?.GetDominatingBuildingPrivilege(), timestamp))
                    {
                        entity.Die();
                        purged++;
                    }
                }
            }

#if DEBUG
            stopwatch.Stop();
            Interface.Oxide.LogDebug(
                $"Total: {stopwatch.Elapsed.TotalMilliseconds}ms / Per Entity: {stopwatch.Elapsed.TotalMilliseconds / entitiesCount}ms / Per Purged: {stopwatch.Elapsed.TotalMilliseconds / purged}ms");
#endif

            if (_logCache.Count > 0)
            {
                LogToFile("purged", string.Join(Environment.NewLine, _logCache), this);
                _logCache.Clear();
            }

            _canPurgeCache.Clear();

            if ((caller?.IsConnected ?? false) && !caller.IsServer)
                caller.Reply(GetMsg("Purge: Ended", caller.Id).Replace("{purged}", purged.ToString()));
            Puts(GetMsg("Purge: Ended", string.Empty).Replace("{purged}", purged.ToString()));
        }

        private bool CanPurge(ulong ownerId, BuildingPrivlidge privilege, uint timestamp)
        {
            if (!CanPurgeUser(ownerId.ToString(), timestamp))
                return false; // We CANNOT purge owner, no need to check further
            
            if (privilege == null)
                return true; // We CAN purge owner and there is NO privilege

            // TODO: Results cache per privilege
            foreach (var authorizedPlayer in privilege.authorizedPlayers)
            {
                if (!CanPurgeUser(authorizedPlayer.userid.ToString(), timestamp))
                    return false; // We CANNOT purge an authorized player
            }

            // We CAN purge owner and there are NO users authorized who we CANNOT purge
            return true;
        }

        private bool CanPurgeUser(string id, uint timestamp)
        {
            if (string.IsNullOrEmpty(id) || !id.IsSteamId())
                return false;

            bool result;
            if (_canPurgeCache.TryGetValue(id, out result))
                return result;

            if ((_canPurgeCache[id] = result = CanPurgeUserInternal(id, timestamp)) && _config.UseLogs)
            {
                _logCache.Add(
                    $"[{DateTime.UtcNow:T}] Marked {id} as suitable for purge (Last seen: {_time.GetDateTimeFromUnix(_data.LastSeen[id]):g})");
            }

            return result;
        }

        private bool CanPurgeUserInternal(string id, uint timestamp)
        {
            var purge = Configuration.PurgeSettings.Find(id);
            if (purge == null || purge.NoPurge)
                return false;

            uint lastSeen;
            if (!_data.LastSeen.TryGetValue(id, out lastSeen))
            {
                _data.LastSeen[id] = timestamp;
                return false;
            }

            return timestamp > lastSeen + purge.Lifetime;
        }

        #endregion

        #region Parsers

        private static readonly Regex RegexStringTime = new Regex(@"(\d+)([dhms])", RegexOptions.Compiled);

        private static bool ConvertToSeconds(string time, out uint seconds)
        {
            seconds = 0;
            if (time == "0" || string.IsNullOrEmpty(time)) return true;
            var matches = RegexStringTime.Matches(time);
            if (matches.Count == 0) return false;
            for (var i = 0; i < matches.Count; i++)
            {
                var match = matches[i];
                // ReSharper disable once SwitchStatementMissingSomeCases
                switch (match.Groups[2].Value)
                {
                    case "d":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 24 * 60 * 60;
                        break;
                    }
                    case "h":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60 * 60;
                        break;
                    }
                    case "m":
                    {
                        seconds += uint.Parse(match.Groups[1].Value) * 60;
                        break;
                    }
                    case "s":
                    {
                        seconds += uint.Parse(match.Groups[1].Value);
                        break;
                    }
                }
            }

            return true;
        }

        #endregion

        #region Helpers

        private string GetMsg(string key, string userId) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

// --- End of file: AutoPurge.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-time ---
// --- Original File Path: A/AdminTime/AdminTime.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using System.Linq;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Admin Time", "Rustic", "1.1.0")]
    [Description("Allows admins to use /day, /night, and /now to change their local time in game.")]

    internal class AdminTime : RustPlugin
    {
        #region General

        const string permAllowTimeChange = "AdminTime.use";

        void Init()
        {
            permission.RegisterPermission(permAllowTimeChange, this);
        }
        
        #endregion

        #region Config
        
        // Config Creation
		private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Day Value")]
            public int DayValue = 12;

            [JsonProperty(PropertyName = "Night Value")]
            public int NightValue = 1;
            
            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    throw new JsonException();
                }
                if (!configData.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration File invalid or outdated. Updated.");
                    SaveConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating Config File");
            configData = new ConfigData();
        }

        #endregion

        #region Commands

        [ChatCommand("day")]
        private void DayCommand(BasePlayer player)
        {
            ChangeTime(player, configData.DayValue);
        }

        [ChatCommand("night")]
        private void NightCommand(BasePlayer player)
        {
            ChangeTime(player, configData.NightValue);
        }

        [ChatCommand("now")]
        private void NowCommand(BasePlayer player)
        {
            ChangeTime(player, -1);
        }

        [ChatCommand("time")]
        private void TimeCommand(BasePlayer player, string command, string[] args)
        {
            int timevalue = Convert.ToInt32(args[0]);

            if (player.IsAdmin == false && !permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                SendReply(player, "Permission Denied.");
            } 

            if (player.IsAdmin == true || permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                if (timevalue > 23 | timevalue < 0)
                {
                    SendReply(player, "Invalid Time, please use 1-23");
                } else {
                    ChangeTime(player, timevalue);
                }
            }
        }

        void ChangeTime(BasePlayer player, int timevalue)
        {
            if (player.IsAdmin == false && !permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                SendReply(player, "Permission Denied.");
            } 

            if (player.IsAdmin == true || permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                if (player.IsAdmin == true) { player.SendConsoleCommand("admintime", timevalue); }

                if (player.IsAdmin == false && permission.UserHasPermission(player.UserIDString, permAllowTimeChange)) 
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true); 
                    player.SendNetworkUpdateImmediate();
                    player.SendConsoleCommand("admintime", timevalue); 
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false); 
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        #endregion
    }
}

// --- End of file: AdminTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/airdrop-without-parachute ---
// --- Original File Path: A/AirdropWithoutParachute/AirdropWithoutParachute.cs ---

﻿using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Airdrop Without Parachute", "Enforcer", "1.0.0")]
    [Description("Removes the parachute on Airdrops")]
    public class AirdropWithoutParachute : RustPlugin
    {
        #region Init

        private void Init()
        {
            LoadConfig();
        }

        private void Unload()
        {
            config = null;
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null)
                return;

            if (entity is SupplyDrop)
            {
                SupplyDrop supplyDrop = entity as SupplyDrop;
                var drop = supplyDrop.GetComponent<Rigidbody>();

                supplyDrop.RemoveParachute();
                drop.drag = config.airdropDrag;

            }
        }

        #endregion

        #region Configuration

        ConfigData config = new ConfigData();
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Airdrop drag")]
            public float airdropDrag { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++) PrintError($"{Name}.json is corrupted! Recreating a new configuration");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData()
            {
                airdropDrag = 5f,
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
    }
}

// --- End of file: AirdropWithoutParachute.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-demo-record-lite ---
// --- Original File Path: A/AutoDemoRecordLite/AutoDemoRecordLite.cs ---

﻿using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("Auto Demo Record Lite", "Pho3niX90", "1.0.82")]
    [Description("Automatic recording based on conditions.")]
    internal class AutoDemoRecordLite : RustPlugin
    {
        private List<ARReport> _reports = new List<ARReport>();
        private Dictionary<ulong, Timer> _timers = new Dictionary<ulong, Timer>();
        private ARConfig config;
        int lastSavedCount = 0;

        [PluginReference]
        Plugin DiscordApi, DiscordMessages;

        private void Loaded() {
            LoadData();
        }

        private void Unload() {
            SaveData();

            _reports.Clear();
            _reports = null;

            foreach (var player in BasePlayer.activePlayerList) {
                if (player.Connection.IsRecording)
                    player.Connection.StopRecording();
            }

            foreach (Timer timer in _timers.Values) {
                timer.Destroy();
            }

            _timers.Clear();
            _timers = null;
        }

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Recording Started"] = "Recording started for player {0}, eta is {1} mins",
                ["Recording Ended"] = "Recording finished for player {0}, player was recorded for {1} mins",
            }, this);
        }

        string GetMsg(string key) => lang.GetMessage(key, this);

        void OnPlayerReported(BasePlayer reporter, string targetName, string targetId, string subject, string message, string type) {
            ulong targetIdLong = 0;
            if (ulong.TryParse(targetId, out targetIdLong)) {
                var report = new ARReport(reporter.UserIDString, reporter.displayName, targetId, targetName, subject, message, type);
                _reports.Add(report);
                ProcessF7(targetIdLong, report);
            }
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args) {
            if (!command.ToLower().Equals("report") || args.Length < 2) return;

            var target = BasePlayer.Find(args[0]);
            if (target == null) return;

            List<string> reason = args.Skip(1).ToList();

            var report = new ARReport(player.UserIDString, player.displayName, target.UserIDString, target.displayName, "Report", string.Join(" ", reason), "Report");
            _reports.Add(report);
            ProcessF7(target.userID, report);
        }

        void ReportCommand(IPlayer reporter, IPlayer target, string reason) {
            var report = new ARReport(reporter.Id, reporter.Name, target.Id, target.Name, "DM Report", reason, "DM Report");
            _reports.Add(report);
            ProcessF7(ulong.Parse(target.Id), report);
        }

        private void OnDestroy() {
            foreach (Timer timer in _timers.Values) {
                timer.Destroy();
            }
            _timers.Clear();
            _reports.Clear();
        }

        void ProcessF7(ulong targetId, ARReport report = null) {
            BasePlayer accused = BasePlayer.FindByID(targetId);
            if (accused == null) return;
            if (accused.IsConnected) {
                // record player only if he has reaced the amount in the config. And only when there is no recording active. 
                if (CheckReports(accused) >= config.AR_Report) {
                    if (!_timers.ContainsKey(accused.userID)) {
                        StartRecording(accused, report);
                    }
                }
            }
        }

        void StartRecording(BasePlayer player, ARReport report = null) {
            var msg = string.Format(GetMsg("Recording Started"), player.UserIDString, config.AR_Report_Length);
            Puts(msg);

            if (config.AR_Discord_Notify_RecordStart) NotifyDiscord(player, msg, report, true);

            player.StartDemoRecording();
            if (config.AR_Report_Length > 0) {
                _timers[player.userID] = timer.Once(config.AR_Report_Length * 60, () => StopRecording(player, report));
            }
        }

        void StopRecording(BasePlayer player, ARReport report) {
            var msg = string.Format(GetMsg("Recording Ended"), player.UserIDString, config.AR_Report_Length);
            Puts(msg);
            if (config.AR_Discord_Notify_RecordStop) NotifyDiscord(player, msg, report, false);
            if (_timers.ContainsKey(player.userID)) {
                player.StopDemoRecording();
                if (config.AR_Clear_Counter) {
                    _reports.RemoveAll(x => x.targetId == player.UserIDString);
                }
                _timers.Remove(player.userID);
            }
        }

        int CheckReports(BasePlayer player) => config.AR_Report_Seconds > 0
                ? this._reports.Count(x => secondsAgo(x.created) <= config.AR_Report_Seconds && x.targetId == player.UserIDString)
                : this._reports.Count(x => x.targetId == player.UserIDString);


        int secondsAgo(DateTime timeFrom) => (int)Math.Round((DateTime.UtcNow - timeFrom).TotalSeconds);


        void NotifyDiscord(BasePlayer player, string msg, ARReport report, bool isStart) {
            if (!config.AR_Discord_Webhook.IsNullOrEmpty() && !config.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")
                && (config.AR_Discord_Notify_RecordStart || config.AR_Discord_Notify_RecordStop)) {
                List<EmbedFieldList> fields = new List<EmbedFieldList>();

                fields.Add(new EmbedFieldList() {
                    name = covalence.Server.Name,
                    value = $"[steam://connect/{covalence.Server.Address}:{covalence.Server.Port}](steam://connect/{covalence.Server.Address}:{covalence.Server.Port})",
                    inline = true
                });

                if (report != null &&
                    ((isStart && config.AR_Discord_Notify_RecordStartMsg) || (!isStart && config.AR_Discord_Notify_RecordStopMsg))) {
                    fields.Add(new EmbedFieldList() {
                        name = "Reporter",
                        value = $"{report.reporterName} ({report.reporterId})",
                        inline = false
                    });
                    fields.Add(new EmbedFieldList() {
                        name = "Report Subject",
                        value = $"{report.type}: {report.subject}",
                        inline = false
                    });
                    fields.Add(new EmbedFieldList() {
                        name = "Report Message",
                        value = report.message,
                        inline = false
                    });
                }

                fields.Add(new EmbedFieldList() {
                    name = player.displayName,
                    value = msg,
                    inline = false
                });

                string json = JsonConvert.SerializeObject(fields.ToArray());

                if (DiscordApi != null && DiscordApi.IsLoaded) {
                    DiscordApi?.Call("API_SendEmbeddedMessage", config.AR_Discord_Webhook, "Auto Demo Recorder", config.AR_Discord_Color, json);
                } else if (DiscordMessages != null && DiscordMessages.IsLoaded) {
                    DiscordMessages?.Call("API_SendFancyMessage", config.AR_Discord_Webhook, "Auto Demo Recorder", config.AR_Discord_Color, json);
                } else {
                    Puts("No discord API plugin loaded, will not publish to hook!");
                }
            }
        }

        #region Configuration
        private class ARConfig
        {
            // Config default vars
            public int AR_Report = 1;
            public int AR_Report_Length = 1;
            public bool AR_Clear_Counter = false;
            public string AR_Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
            public int AR_Discord_Color = 39423;
            public bool AR_Discord_Notify_RecordStart = false;
            public bool AR_Discord_Notify_RecordStop = false;
            public int AR_Report_Seconds = 0;
            public bool AR_Discord_Notify_RecordStartMsg = true;
            public bool AR_Discord_Notify_RecordStopMsg = false;
            public bool AR_Save_Reports = true;

            // Plugin reference
            private AutoDemoRecordLite plugin;
            public ARConfig(AutoDemoRecordLite plugin) {
                this.plugin = plugin;
                /**
                 * Load all saved config values
                 * */
                GetConfig(ref AR_Report, "Auto record after X reports");
                GetConfig(ref AR_Report_Length, "Auto record for X minutes");
                GetConfig(ref AR_Clear_Counter, "Clear report counter after recording?");
                GetConfig(ref AR_Discord_Webhook, "Discord Webhook");
                GetConfig(ref AR_Discord_Color, "Discord MSG Color");
                GetConfig(ref AR_Discord_Notify_RecordStart, "Discord: Notify if recording is started");
                GetConfig(ref AR_Discord_Notify_RecordStartMsg, "Discord: Include report with start message?");
                GetConfig(ref AR_Discord_Notify_RecordStop, "Discord: Notify if recording is stopped");
                GetConfig(ref AR_Discord_Notify_RecordStopMsg, "Discord: Include report with end message?");
                GetConfig(ref AR_Report_Seconds, "Only record when reports within X seconds");
                GetConfig(ref AR_Save_Reports, "Save/Load reports to datafile on reload");

                plugin.SaveConfig();
            }

            private void GetConfig<T>(ref T variable, params string[] path) {
                if (path.Length == 0) return;
                if (plugin.Config.Get(path) == null) {
                    SetConfig(ref variable, path);
                    plugin.PrintWarning($"Added new field to config: {string.Join("/", path)}");
                }
                variable = (T)Convert.ChangeType(plugin.Config.Get(path), typeof(T));
            }

            private void SetConfig<T>(ref T variable, params string[] path) => plugin.Config.Set(path.Concat(new object[] { variable }).ToArray());

        }
        protected override void LoadConfig() {
            base.LoadConfig();
            config = new ARConfig(this);
        }

        void LoadData() {
            if (!config.AR_Save_Reports) return;
            try {
                _reports = Interface.Oxide.DataFileSystem.ReadObject<List<ARReport>>(this.Name);
                lastSavedCount = _reports.Count();
            } catch (Exception e) {
                Puts(e.Message);
            }
        }

        void SaveData() {
            int recordsDiff = _reports.Count() - lastSavedCount;
            if (!config.AR_Save_Reports || recordsDiff == 0) return;
            try {
                Interface.Oxide.DataFileSystem.WriteObject(this.Name, _reports, true);
            } catch (Exception e) {
                Puts(e.Message);
            }
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file.");
        #endregion

        #region Classes 
        public class EmbedFieldList
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
        }

        public class ARReport
        {
            public string reporterName;
            public string reporterId;
            public string targetName;
            public string targetId;
            public string subject;
            public string message;
            public string type;
            public DateTime created;
            public ARReport() { }
            public ARReport(string reporterId, string reporterName, string targetId, string targetName, string subject, string message, string type) {
                this.reporterId = reporterId;
                this.reporterName = reporterName;
                this.targetId = targetId;
                this.targetName = targetName;
                this.subject = subject;
                this.message = message;
                this.type = type;
                this.created = DateTime.UtcNow;
            }
            public ARReport(string targetId, string targetName) {
                this.targetName = targetName;
                this.targetId = targetId;
            }
        }
        #endregion
    }
}


// --- End of file: AutoDemoRecordLite.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-key ---
// --- Original File Path: A/AdminKey/AdminKey.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Admin Key", "birthdates", "1.2.8")]
    [Description("Get admin from a key code instead of going into console")]
    public class AdminKey : RustPlugin
    {

        private void Init()
        {
            LoadConfig();
            if (_config.keys == null)
            {
                PrintError("Keys aren't setup correctly, please correct them or reset the config!");
            }
            else if (_config.keys.Count < 1)
            {
                PrintWarning("There are no admin keys!");
            }
            cmd.AddChatCommand("adminkey", this, AdminKeyCommand);
        }

        private ConfigFile _config;

        void RemoveAdmin(BasePlayer player)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            if (player.IsFlying)
            {
                player.ChatMessage(lang.GetMessage("NoClip", this, player.UserIDString));
                return;
            }
            RemoveAuth(player);
        }

        void RemoveAuth(BasePlayer player)
        {
            player.SendConsoleCommand("global.god false");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            player.Connection.authLevel = 1;
            ServerUsers.Set(player.userID, ServerUsers.UserGroup.None, player.displayName, "Removed Admin");
            ServerUsers.Save();
            SendReply(player, lang.GetMessage("AdminRemoved", this, player.UserIDString));
        }

        void AddAdmin(BasePlayer player)
        {
            // Begin edits by Death
            player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            player.Connection.authLevel = 2;
            ServerUsers.Set(player.userID, ServerUsers.UserGroup.Owner, player.displayName, "Owner from admin key"); //edit by birthdates to set group in cfg
            ServerUsers.Save();
        }

        public void AdminKeyCommand(BasePlayer player, string command, string[] args)
        {

            if (args.Length < 1)
            {
                SendReply(player, lang.GetMessage("InvalidKey", this, player.UserIDString));
            }
            else
            {
                if (!_config.keys.Contains(args[0]))
                {
                    SendReply(player, lang.GetMessage("InvalidKey", this, player.UserIDString));
                }
                else
                {
                    if (player.IsAdmin)
                    {
                        if (Interface.CallHook("CanRemoveAdmin", player) != null)
                        {
                            return;
                        }
                        RemoveAdmin(player);
                        Interface.CallHook("OnAdminRemoved", player);
                        return;
                    }
                    if (Interface.CallHook("CanAddAdmin", player) != null)
                    {
                        return;
                    }
                    AddAdmin(player);
                    Interface.CallHook("OnAdminAdded", player);
                    SendReply(player, lang.GetMessage("AdminGiven", this, player.UserIDString));
                }

            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"InvalidKey", "Invalid key!"},
                {"AdminGiven", "Success! You are now in the admin group!"},
                {"AlreadyAdmin", "You are already an admin"},
                {"AdminRemoved", "Success! You have been removed from the admin group!"},
                {"NoClip", "Turn off noclip to remove your admin."}
            }, this);
        }

        public class ConfigFile
        {
            [JsonProperty(PropertyName = "Admin keys")]
            public List<string> keys;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    keys = new List<string>()
                    {
                        "abc123",
                        "123abc"
                    }
                };
            }

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

    }
}


// --- End of file: AdminKey.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-lights-out ---
// --- Original File Path: A/AutoLightsOut/AutoLightsOut.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("AutoLightsOut", "DylanSMR", "1.0.3")]
    [Description("Turn off all lights at night, user must manually turn on again, this allows users on modded servers with lots of wood to find houses at night with players in them.")]

    class AutoLightsOut : RustPlugin
    {
        TOD_Sky sky;
        Configuration config;
        bool Activated;
        List<uint> TurnedOff = new List<uint>();

        public class Configuration
        {
            [JsonProperty(PropertyName = "Trigger : 1 = Turn off all at the same time, 2 = Turn off each one when they burn a piece of fuel. (Default=1)")]
            public int Trigger;

            [JsonProperty(PropertyName = "Trigger Interval : How often the plugin checks if it is night, only change for trigger type one. (Default=60) (SECONDS)")]
            public int TriggerTime = 60;

            [JsonProperty(PropertyName = "Camp Fires : If camp fires should be turned off. (Default=true)")]
            public bool CampFires;

            [JsonProperty(PropertyName = "Furnaces : If furnaces should be turned off. (Default=true)")]
            public bool Furnaces;

            [JsonProperty(PropertyName = "Lanterns : If lanterns should be turned off. (Default=true)")]
            public bool Lanterns;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            config = new Configuration()
            {
                CampFires = true,
                Furnaces = true,
                Lanterns = true,
                Trigger = 1,
                TriggerTime = 60
            };
            SaveConfig(config);
        }
        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }
        public void LoadConfigVars()
        {
            PrintWarning("Loading configuration.");
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config, true);
        }

        void Loaded()
        {
            sky = TOD_Sky.Instance;
            LoadConfigVars();

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NIGHTTIME_REACHED", "Your lights, camp fires, and furnaces have been turned off! Feel free to turn them on if needed."}
            }, this);

            if (config == null)
            {
                Interface.Oxide.ReloadPlugin("AutoLightsOut");
                return;
            }

            if (config.Trigger == 1)
            {
                timer.Every(config.TriggerTime, () =>
                {
                    if (sky.IsNight && !Activated)
                    {
                        Activated = true;
                        PrintToChat(lang.GetMessage("NIGHTTIME_REACHED", this));
                        Puts(lang.GetMessage("NIGHTTIME_REACHED", this));

                        BaseOven[] Ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
                        if (Ovens == null) return;

                        foreach (BaseOven oven in Ovens)
                        {
                            CheckOven(oven);
                        }
                    }
                    if (sky.IsDay && Activated)
                        Activated = false;
                });
            }
        }

        void CheckOven(BaseOven oven)
        {
            string pfn = oven.PrefabName.ToLower();
            if (pfn.Contains("campfire"))
            {
                if (config.CampFires)
                {
                    oven.StopCooking();
                    oven.SetFlag(BaseEntity.Flags.On, false);
                }
            }
            else if (pfn.Contains("furnace"))
            {
                if (config.Furnaces)
                {
                    oven.StopCooking();
                    oven.SetFlag(BaseEntity.Flags.On, false);
                }
            }
            else
            {
                if (config.Lanterns)
                {
                    oven.StopCooking();
                    oven.SetFlag(BaseEntity.Flags.On, false);
                }
            }
        }

        void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (config.Trigger != 2) return;
            if (oven == null) return;

            if (sky.IsNight)
            {
                if (TurnedOff.Contains(oven.net.ID)) return;
                else TurnedOff.Add(oven.net.ID);

                if (!Activated)
                    Activated = true;

                CheckOven(oven);
            }
            if (sky.IsDay)
            {
                Activated = false;
                TurnedOff.Clear();
            }
        }
    }
}

// --- End of file: AutoLightsOut.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-chat ---
// --- Original File Path: A/AdminChat/AdminChat.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Admin Chat", "LaserHydra", "2.0.4")]
    [Description("Allows admins to write in an admin-only chatroom")]
    internal class AdminChat : CovalencePlugin
    {
        private const string Permission = "adminchat.use";

        private Configuration _config;
        private List<string> _enabledUserIds = new List<string>();

        #region Hooks

        private object OnUserChat(IPlayer player, string message)
        {
            if (!player.HasPermission(Permission))
                return null;

            if (message.StartsWith(_config.Prefix))
            {
                SendAdminMessage(player, message.Substring(_config.Prefix.Length));
                return true;
            }

            if (HasAdminChatEnabled(player))
            {
                SendAdminMessage(player, message);
                return true;
            }

            return null;
        }

        private void OnBetterChat(Dictionary<string, object> data)
        {
            var player = data["Player"] as IPlayer;
            var message = data["Message"] as string;

            if (!player.HasPermission(Permission))
                return;

            if (message.StartsWith(_config.Prefix) || HasAdminChatEnabled(player))
            {
                data["CancelOption"] = 1;
            }
        }

        #endregion

        #region Command

        [Command("adminchat"), Permission(Permission)]
        private void AdminChatTogggleCommand(IPlayer player, string command, string[] args)
        {
            if (_enabledUserIds.Contains(player.Id))
            {
                _enabledUserIds.Remove(player.Id);
                player.Reply(lang.GetMessage("Disabled Admin Chat", this, player.Id));
            }
            else
            {
                _enabledUserIds.Add(player.Id);
                player.Reply(lang.GetMessage("Enabled Admin Chat", this, player.Id));
            }
        }

        #endregion

        #region Helper

        private void SendAdminMessage(IPlayer sender, string message)
        {
            Puts($"{sender.Name}: {message}");

            string formattedMessage = _config.Format
                .Replace("{name}", sender.Name)
                .Replace("{message}", message.Trim());

            foreach (var player in players.Connected.Where(p => p.HasPermission(Permission)))
            {
#if RUST
                (player.Object as BasePlayer).SendConsoleCommand("chat.add", new object[] { (int) ConVar.Chat.ChatChannel.Global, sender.Id, covalence.FormatText(formattedMessage) });
#else
                player.Message(formattedMessage);
#endif
            }

            Interface.Call("OnAdminChat", sender, message, formattedMessage);
        }

        private bool HasAdminChatEnabled(IPlayer player) => _enabledUserIds.Contains(player.Id);

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Enabled Admin Chat"] = "You are now talking in admin chat.",
                ["Disabled Admin Chat"] = "You are no longer talking in admin chat."
            }, this);
        }

        #endregion

        #region Configuratio