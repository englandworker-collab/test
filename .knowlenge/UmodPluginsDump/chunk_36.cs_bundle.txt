n

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Prefix (admin chat is used when message starts with this)")]
            public string Prefix { get; private set; } = "@";

            [JsonProperty("Format (how the message is formatted in chat)")]
            public string Format { get; private set; } = "[#red]Admin Chat[/#] [#grey]{name}[/#]: {message}";
        }

        #endregion
    }
}

// --- End of file: AdminChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/absolut-market ---
// --- Original File Path: A/AbsolutMarket/AbsolutMarket.cs ---

ï»¿using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AbsolutMarket", "Absolut", "1.8.4", ResourceId = 2118)]
    public class AbsolutMarket : RustPlugin
    {
        [PluginReference]
        private Plugin ServerRewards, Economics, ImageLibrary;

        private MarketData mData;
        private DynamicConfigFile MData;

        private string TitleColor = "<color=orange>";
        private string MsgColor = "<color=#A9A9A9>";
        private Vector3 eyesAdjust;
        private FieldInfo serverinput;

        private bool initialized;

        private List<ulong> MenuState = new List<ulong>();
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, List<AMItem>> PlayerBoxContents = new Dictionary<ulong, List<AMItem>>();
        private Dictionary<ulong, AMItem> SalesItemPrep = new Dictionary<ulong, AMItem>();
        private Dictionary<ulong, List<Item>> PlayerInventory = new Dictionary<ulong, List<Item>>();
        private Dictionary<ulong, List<Item>> ItemsToTransfer = new Dictionary<ulong, List<Item>>();
        private Dictionary<ulong, existence> UIInfo = new Dictionary<ulong, existence>();

        private class existence
        {
            public StorageContainer box = null;
            public int page;
            public Category cat = Category.All;
            public AMItem PurchaseItem = null;
        }

        #region Server Hooks

        private void Loaded()
        {
            MData = Interface.Oxide.DataFileSystem.GetFile("AbsolutMarket_Data");
            lang.RegisterMessages(messages, this);
        }

        private void Unload()
        {
            foreach (var entry in timers)
                entry.Value.Destroy();
            MenuState.Clear();
            timers.Clear();
            PlayerBoxContents.Clear();
            SalesItemPrep.Clear();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                DestroyMarketPanel(p);
                DestroyPurchaseScreen(p);
            }
            if (initialized)
                SaveData();
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
                MenuState.Remove(player.userID);
            if (mData.TradeBox.ContainsKey(player.userID))
            {
                StorageContainer box = null;
                if (UIInfo.ContainsKey(player.userID))
                    box = UIInfo[player.userID].box;
                else GetTradeBox(player.userID);
                if (box == null)
                {
                    Dictionary<uint, string> listings = new Dictionary<uint, string>();
                    foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID))
                        listings.Add(entry.Key, entry.Value.shortname);
                    foreach (var entry in listings)
                        RemoveListing(player.userID, entry.Value, entry.Key, "TradeBoxInvalid");
                    listings.Clear();
                    mData.TradeBox.Remove(player.userID);
                    GetSendMSG(player, "TradeBoxNoLongerValid");
                }
            }
            if (UIInfo.ContainsKey(player.userID))
                UIInfo.Remove(player.userID);
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                //player.Command($"bind {configData.MarketMenuKeyBinding} \"UI_ToggleMarketScreen\"");
                GetSendMSG(player, "AMInfo", configData.MarketMenuKeyBinding);
                if (!mData.names.ContainsKey(player.userID))
                    mData.names.Add(player.userID, player.displayName);
                else
                {
                    var length = player.displayName.Count();
                    if (length > 30)
                    {
                        mData.names[player.userID] = player.displayName.Substring(0, 30);
                    }
                    else mData.names[player.userID] = player.displayName;
                }
                SendMessages(player);
                if (!UIInfo.ContainsKey(player.userID))
                    UIInfo.Add(player.userID, new existence());
                if (mData.TradeBox.ContainsKey(player.userID))
                {
                    UIInfo[player.userID].box = GetTradeBox(player.userID);
                    if (UIInfo[player.userID].box == null)
                    {
                        Dictionary<uint, string> listings = new Dictionary<uint, string>();
                        foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID))
                            listings.Add(entry.Key, entry.Value.shortname);
                        foreach (var entry in listings)
                            RemoveListing(player.userID, entry.Value, entry.Key, "TradeBoxInvalid");
                        listings.Clear();
                        mData.TradeBox.Remove(player.userID);
                        GetSendMSG(player, "TradeBoxNoLongerValid");
                    }
                }
                SaveData();
            }
        }

        private void OnServerInitialized()
        {
            timer.Once(10, () =>
            {
                initialized = false;
                try
                {
                    ImageLibrary.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning($"ImageLibrary is missing. Unloading {Name} as it will not work without ImageLibrary.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
                LoadVariables();
                if (configData.ServerRewards && configData.Economics)
                {
                    PrintWarning($"You can not have Economics and Server Rewards enabled. Disable one and reload.");
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
                if (configData.ServerRewards)
                    try
                    {
                        ServerRewards.Call("isLoaded", null);
                    }
                    catch (Exception)
                    {
                        PrintWarning($"ServerRewards is missing. Unloading {Name} as it will not work without ServerRewards or change the config option to false.");
                        Interface.Oxide.UnloadPlugin(Name);
                        return;
                    }
                if (configData.Economics)
                    try
                    {
                        Economics.Call("isLoaded", null);
                    }
                    catch (Exception)
                    {
                        PrintWarning($"Economics is missing. Unloading {Name} as it will not work without Economics or change the config option to false.");
                        Interface.Oxide.UnloadPlugin(Name);
                        return;
                    }
                permission.RegisterPermission("AbsolutMarket.admin", this);
                LoadData();
                eyesAdjust = new Vector3(0f, 1.5f, 0f);
                timers.Add("info", timer.Once(configData.InfoInterval, () => InfoLoop()));
                timers.Add("save", timer.Once(600, () => SaveLoop()));
                timers.Add("listings", timer.Once(600, () => CheckListings()));
                SaveData();
                AddNeededImages();
                RefreshBackgrounds();
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                    OnPlayerInit(p);
            });
        }

        #endregion Server Hooks

        #region Player Hooks

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity is StorageContainer)
            {
                if (mData.TradeBox.ContainsKey(entity.OwnerID))
                {
                    if (entity.transform.localPosition == GetVector3(mData.TradeBox[entity.OwnerID]))
                    {
                        Dictionary<uint, string> listings = new Dictionary<uint, string>();
                        foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == entity.OwnerID))
                            listings.Add(entry.Key, entry.Value.shortname);
                        foreach (var entry in listings)
                            RemoveListing(entity.OwnerID, entry.Value, entry.Key, "TradeBoxDestroyed");
                        listings.Clear();
                        mData.TradeBox.Remove(entity.OwnerID);
                        if (UIInfo.ContainsKey(entity.OwnerID))
                            UIInfo[entity.OwnerID].box = null;
                        BasePlayer owner = BasePlayer.FindByID(entity.OwnerID);
                        if (BasePlayer.activePlayerList.Contains(owner))
                            GetSendMSG(owner, "TradeBoxDestroyed");
                    }
                    SaveData();
                }
                return;
            }
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player == null || !SalesItemPrep.ContainsKey(player.userID)) return null;
            if (arg.Args != null && !string.IsNullOrEmpty(string.Join(" ", arg.Args)) && arg.cmd?.FullName == "chat.say")
            {
                AMItem item;
                item = SalesItemPrep[player.userID];
                var args = string.Join(" ", arg.Args);
                if (args.Contains("quit"))
                {
                    CancelListing(player);
                    return false;
                }
                switch (item.stepNum)
                {
                    case 0:
                        var name = string.Join(" ", arg.Args);
                        item.name = name;
                        item.stepNum = 99;
                        SellItems(player, 1);
                        return false;
                }
                return false;
            }
            return null;
        }

        #endregion Player Hooks

        #region Functions

        private StorageContainer GetTradeBox(ulong Buyer)
        {
            List<StorageContainer> Containers = new List<StorageContainer>();
            if (mData.TradeBox.ContainsKey(Buyer))
            {
                Vector3 containerPos = GetVector3(mData.TradeBox[Buyer]);
                foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
                {
                    Vector3 ContPosition = Cont.transform.position;
                    if (ContPosition == containerPos)
                        return Cont;
                }
            }
            return null;
        }

        private Vector3 GetVector3(XYZ xyz)
        {
            return new Vector3 { x = xyz.x, y = xyz.y, z = xyz.z };
        }

        private bool GetTradeBoxContents(BasePlayer player, StorageContainer box)
        {
            if (player == null) return false;
            ulong seller = player.userID;
            bool EcoAllowed = false;
            if (Economics && configData.Economics && !mData.Blacklist.Contains("ECO")) EcoAllowed = true;
            bool SRAllowed = false;
            if (ServerRewards && configData.ServerRewards && !mData.Blacklist.Contains("SR")) SRAllowed = true;
            if (box != null)
            {
                if (GetItems(box.inventory).Count() == 0)
                {
                    if (!SRAllowed && !EcoAllowed)
                    {
                        GetSendMSG(player, "TradeBoxEmpty");
                        return false;
                    }
                    else
                    {
                        double amount = 0;
                        if (SRAllowed)
                            if (CheckPoints(player.userID) is int)
                                amount += (int)CheckPoints(player.userID);
                        if (EcoAllowed)
                            amount += CheckEco(player.userID);
                        if (amount == 0)
                        {
                            GetSendMSG(player, "TradeBoxEmptyNoSR");
                            return false;
                        }
                    }
                }
                if (PlayerBoxContents.ContainsKey(seller)) PlayerBoxContents.Remove(seller);
                PlayerBoxContents.Add(seller, new List<AMItem>());
                PlayerBoxContents[seller].AddRange(GetItems(box.inventory));
                var bl = 0;
                var c = 0;
                var listed = 0;
                foreach (var entry in PlayerBoxContents[seller])
                {
                    c++;
                    if (mData.Blacklist.Contains(entry.shortname))
                        bl++;
                    if (mData.MarketListings.ContainsKey(entry.ID))
                        listed++;
                    foreach (var cat in configData.Categorization.Where(k => k.Value.Contains(entry.shortname)))
                    {
                        entry.cat = cat.Key;
                        break;
                    }
                }
                if (bl == c)
                {
                    double amount = 0;
                    var msg = "";
                    if (SRAllowed)
                    {
                        msg = msg + GetMSG("SRInclusion", player);
                        if (CheckPoints(player.userID) is int)
                            amount += (int)CheckPoints(player.userID);
                    }
                    if (EcoAllowed)
                    {
                        msg = msg + GetMSG("ECOInclusion", player);
                        amount += CheckEco(player.userID);
                    }
                    if (amount <= 0)
                    {
                        GetSendMSG(player, "AllItemsAreBL", msg);
                        return false;
                    }
                }
                if (c == listed)
                {
                    bool alllisted = true;
                    var msg = "";
                    if (SRAllowed)
                    {
                        msg = msg + GetMSG("SRInclusionListed", player);
                        if (CheckPoints(player.userID) is int)
                        {
                            var total = (int)CheckPoints(player.userID);
                            var totalListed = 0;
                            foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID && kvp.Value.shortname == "SR"))
                                totalListed += entry.Value.amount;
                            if (totalListed < total)
                                alllisted = false;
                        }
                    }
                    if (EcoAllowed && alllisted)
                    {
                        msg = msg + GetMSG("ECOInclusionListed", player);
                        var total = CheckEco(player.userID);
                        var totalListed = 0;
                        foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID && kvp.Value.shortname == "ECO"))
                            totalListed += entry.Value.amount;
                        if (totalListed < total)
                            alllisted = false;
                    }
                    if (alllisted)
                    {
                        GetSendMSG(player, "AllItemsAreListed", msg);
                        return false;
                    }
                }
                return true;
            }
            else GetSendMSG(player, "NoTradeBox"); return false;
        }

        private bool BoxCheck(BasePlayer player, uint item)
        {
            if (player == null) return false;
            ulong seller = player.userID;
            StorageContainer box = UIInfo[player.userID].box;
            if (box != null)
            {
                if (GetItems(box.inventory).Count() == 0)
                {
                    GetSendMSG(player, "TradeBoxEmpty");
                    return false;
                }
                foreach (var entry in box.inventory.itemList)
                {
                    if (entry.uid == item)
                        return true;
                }
                return false;
            }
            else GetSendMSG(player, "NoTradeBox"); return false;
        }

        private void AddMessages(ulong player, string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            try
            {
                BasePlayer Online = BasePlayer.FindByID(player);
                if (BasePlayer.activePlayerList.Contains(Online))
                    GetSendMSG(Online, message, arg1, arg2, arg3, arg4);
            }
            catch
            {
                if (!mData.OutstandingMessages.ContainsKey(player))
                    mData.OutstandingMessages.Add(player, new List<Unsent>());
                mData.OutstandingMessages[player].Add(new Unsent { message = message, arg1 = arg1, arg2 = arg2, arg3 = arg3, arg4 = arg4 });
                SaveData();
            }
        }

        private void SendMessages(BasePlayer player)
        {
            if (mData.OutstandingMessages.ContainsKey(player.userID))
            {
                foreach (var entry in mData.OutstandingMessages[player.userID])
                {
                    GetSendMSG(player, entry.message, entry.arg1, entry.arg2, entry.arg3, entry.arg4);
                }
                mData.OutstandingMessages.Remove(player.userID);
            }
        }

        private string TryForImage(string shortname, ulong skin = 99)
        {
            if (shortname.Contains("http")) return shortname;
            if (skin == 99) skin = (ulong)ResourceId;
            return GetImage(shortname, skin, true);
        }

        public string GetImage(string shortname, ulong skin = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        public bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname.ToLower(), skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname.ToLower(), skin);
        public List<ulong> GetImageList(string shortname) => (List<ulong>)ImageLibrary.Call("GetImageList", shortname.ToLower());
        public bool isReady() => (bool)ImageLibrary?.Call("IsReady");

        private IEnumerable<AMItem> GetItems(ItemContainer container)
        {
            return container.itemList.Select(item => new AMItem
            {
                amount = item.amount,
                skin = item.skin,
                cat = Category.Other,
                pricecat = Category.Other,
                shortname = item.info.shortname,
                condition = item.condition,
                ID = item.uid,
            });
        }

        private IEnumerable<Item> GetItemsOnly(ItemContainer container)
        {
            return container.itemList;
        }

        //private void XferPurchase(ulong buyer, uint ID, ItemContainer from, ItemContainer to)
        //{
        //    foreach (Item item in from.itemList.Where(kvp => kvp.uid == ID))
        //    {
        //        item.MoveToContainer(to);
        //    }
        //}

        private void XferCost(uint item, BasePlayer player, uint Listing, ItemContainer SellerBox)
        {
            List<ItemContainer> containers = new List<ItemContainer> { player.inventory.containerMain, player.inventory.containerBelt, player.inventory.containerWear };
            if (mData.MarketListings[Listing].priceAmount > 0)
            {
                //Puts("TRying");
                foreach (var container in containers)
                    foreach (Item item1 in container.itemList.Where(k => k.uid == item))
                    {
                        //Puts("Item found)");
                        if (mData.MarketListings[Listing].priceAmount == 0) return;
                        if (mData.MarketListings[Listing].priceAmount >= item1.amount)
                        {
                            //Puts("1");
                            item1.MoveToContainer(SellerBox);
                            mData.MarketListings[Listing].priceAmount -= item1.amount;
                            //Puts($"{item1} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item1.amount}");
                        }
                        else
                        {
                            Item item2 = item1.SplitItem(mData.MarketListings[Listing].priceAmount);
                            item2.MoveToContainer(SellerBox);
                            mData.MarketListings[Listing].priceAmount = 0;
                            return;
                            //Puts($"SPLITTING: {item2} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item2.amount}");
                        }
                        break;
                    }
            }
        }

        private Item BuildCostItems(string shortname, int amount)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item1 = ItemManager.Create(definition, amount, 0);
                if (item1 != null)
                    return item1;
            }
            Puts("Error making purchase cost item(s)");
            return null;
        }

        private void OnItemRemovedFromContainer(ItemContainer cont, Item item)
        {
            if (mData.MarketListings == null || mData.MarketListings.Count < 1) return;
            if (mData.TradeBox == null || mData.TradeBox.Count < 1) return;
            if (cont.entityOwner != null)
                if (mData.TradeBox.ContainsKey(cont.entityOwner.OwnerID) && cont.entityOwner.transform.localPosition == GetVector3(mData.TradeBox[cont.entityOwner.OwnerID]))
                    if (mData.MarketListings.ContainsKey(item.uid))
                    {
                        var name = "";
                        if (configData.UseUniqueNames && item.name != "")
                            name = mData.MarketListings[item.uid].name;
                        else name = mData.MarketListings[item.uid].shortname;
                        RemoveListing(cont.entityOwner.OwnerID, name, item.uid, "FromBox");
                        mData.MarketListings.Remove(item.uid);
                    }
        }

        private void RemoveListing(ulong seller, string name, uint ID, string reason = "")
        {
            AddMessages(seller, "ItemRemoved", name.ToUpper(), reason);
            mData.MarketListings.Remove(ID);
        }

        private void CancelListing(BasePlayer player)
        {
            DestroyMarketPanel(player);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            if (PlayerBoxContents.ContainsKey(player.userID))
                PlayerBoxContents.Remove(player.userID);
            GetSendMSG(player, "ItemListingCanceled");
        }

        private void SRAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                ServerRewards?.Call("AddPoints", new object[] { ID, amount });
            if (action == "REMOVE")
                ServerRewards?.Call("TakePoints", new object[] { ID, amount });
        }

        private object CheckPoints(ulong ID) => ServerRewards?.Call("CheckPoints", ID);

        private void ECOAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                Economics.Call("Deposit", ID, amount);
            if (action == "REMOVE")
                Economics.Call("Withdraw", ID, amount);
        }

        private double CheckEco(ulong ID) => (double)Economics.Call("Balance", ID);

        private void NumberPad(BasePlayer player, string cmd)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.35 0.3", "0.65 0.7", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, UIColors["white"], GetMSG("Select Amount", player), 20, "0.1 0.85", "0.9 .98", TextAnchor.UpperCenter);
            var n = 1;
            var i = 0;
            while (n < 10)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n++;
            }
            while (n >= 10 && n < 25)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 5;
            }
            while (n >= 25 && n < 200)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 25;
            }
            while (n >= 200 && n <= 950)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 50;
            }
            while (n >= 1000 && n <= 10000)
            {
                CreateNumberPadButton(ref element, PanelMarket, i, n, cmd); i++; n += 500;
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Quit", player), 10, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, int i, int number, string command)
        {
            var pos = CalcNumButtonPos(i);
            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], number.ToString(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number}");
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3, arg4);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, BasePlayer player = null, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
        {
            string p = null;
            if (player != null)
                p = player.UserIDString;
            if (messages.ContainsKey(message))
                return string.Format(lang.GetMessage(message, this, p), arg1, arg2, arg3, arg4);
            else return message;
        }

        public void DestroyMarketPanel(BasePlayer player)
        {
            if (MenuState.Contains(player.userID))
                MenuState.Remove(player.userID);
            CuiHelper.DestroyUi(player, PanelMarket);
        }

        public void DestroyPurchaseScreen(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelPurchase);
        }

        private void ToggleMarketScreen(BasePlayer player)
        {
            if (configData.BanSteamIDs != null && configData.BanSteamIDs.Contains(player.userID))
            {
                OnScreen(player, "BanFromMarket");
                return;
            }
            if (MenuState.Contains(player.userID))
            {
                MenuState.Remove(player.userID);
                DestroyMarketPanel(player);
                DestroyPurchaseScreen(player);
                return;
            }
            MenuState.Add(player.userID);
            MarketMainScreen(player, 0, Category.All);
        }

        private bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2 && !permission.UserHasPermission(player.UserIDString, "AbsolutMarket.admin"))
                    return false;
            return true;
        }

        #endregion Functions

        #region UI Creation

        private string PanelMarket = "PanelMarket";
        private string PanelPurchase = "PanelPurchase";
        private string PanelOnScreen = "PanelOnScreen";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panel
                }
            };
                return NewElement;
            }
            static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer element, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                element.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer element, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string img, string aMin, string aMax)
            {
                if (img.StartsWith("http") || img.StartsWith("www"))
                {
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Url = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
                }
                else
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Png = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
            }

            static public void CreateTextOverlay(ref CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                element.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }
            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };

        #endregion UI Creation

        #region UI Panels

        private void MarketMainScreen(BasePlayer player, int page = 0, Category cat = Category.All)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            if (!mData.mode.ContainsKey(player.userID))
                mData.mode.Add(player.userID, false);
            var i = 0;
            var c = 0;
            bool seller = false;
            double count = 0;
            string Background = TryForImage("NEVERDELETE");
            if (cat == Category.All)
                count = mData.MarketListings.Count();
            else count = mData.MarketListings.Where(kvp => kvp.Value.cat == cat).Count();
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.2 0.15", "0.8 0.85", true);
            UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", "0 0", "1 1");
            int entriesallowed = 9;
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            if (mData.mode[player.userID] == false && !configData.ForceSimpleUI)
            {
                if (mData.background.ContainsKey(player.userID))
                    Background = TryForImage(mData.background[player.userID]);
                UI.LoadImage(ref element, PanelMarket, Background, "0 0", "1 1");
                if (page <= totalpages - 1)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("LAST"), "0.8 0.02", "0.85 0.06");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.8 0.02", "0.85 0.06", $"UI_MarketMainScreen {totalpages} {Enum.GetName(typeof(Category), cat)}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("NEXT"), "0.8 0.065", "0.85 0.105");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.8 0.065", "0.85 0.105", $"UI_MarketMainScreen {page + 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 0)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("BACK"), "0.74 0.065", "0.79 0.105");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.74 0.065", "0.79 0.105", $"UI_MarketMainScreen {page - 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 1)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("FIRST"), "0.74 0.02", "0.79 0.06");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 18, "0.74 0.02", "0.79 0.06", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), cat)}");
                }

                //UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetMSG("Filters"), 22, "0.14 0.08", "0.24 0.14");
                foreach (Category ct in Enum.GetValues(typeof(Category)))
                {
                    var loc = FilterButton(c);
                    if (cat == ct)
                    {
                        UI.LoadImage(ref element, PanelMarket, TryForImage("UFILTER"), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                        UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", TextAnchor.MiddleCenter);
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                        c++;
                    }
                    else
                    {
                        UI.LoadImage(ref element, PanelMarket, TryForImage("OFILTER"), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                        UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", TextAnchor.MiddleCenter);
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                        c++;
                    }
                }
                UI.LoadImage(ref element, PanelMarket, TryForImage("box.wooden.large", 0), $"0.05 0.9", "0.15 1");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], "", 12, $"0.05 0.9", "0.15 1", TextAnchor.MiddleCenter);

                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", GetMSG("TradeBoxAssignment", player), 12, $"0.05 0.9", "0.15 1", $"UI_SetTradeBox");

                UI.LoadImage(ref element, PanelMarket, TryForImage("SELL"), $"0.35 0.9", "0.65 1.0");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetMSG("ListItem", player), 12, $"0.35 0.9", "0.65 1.0", TextAnchor.MiddleCenter);
                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"0.35 0.9", "0.65 1.0", $"UI_MarketSellScreen {0}");

                UI.LoadImage(ref element, PanelMarket, TryForImage("OFILTER"), "0.66 0.9", "0.75 1");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetMSG("ChangeMode", player), 12, "0.66 0.9", "0.75 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.66 0.9", "0.75 1", $"UI_Mode {1}");

                UI.LoadImage(ref element, PanelMarket, TryForImage("OFILTER"), "0.76 0.9", "0.86 1");
                UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetMSG("ChangeTheme", player), 12, "0.76 0.9", "0.86 1", TextAnchor.MiddleCenter);
                UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.76 0.9", "0.86 1", $"UI_MarketBackgroundMenu {0}");

                if (isAuth(player))
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("UFILTER"), "0.87 0.9", "0.97 1");
                    UI.CreateLabel(ref element, PanelMarket, UIColors["dark"], GetMSG("AdminPanel", player), 12, "0.87 0.9", "0.97 1", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, "0.87 0.9", "0.97 1", $"UI_AdminPanel");
                }
                int shownentries = page * entriesallowed;
                int n = 0;
                if (cat == Category.All)
                {
                    foreach (var item in mData.MarketListings)
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButton(ref element, PanelMarket, player, item.Value, seller, n);

                            n++;
                        }
                    }
                }
                else
                    foreach (var item in mData.MarketListings.Where(kvp => kvp.Value.cat == cat))
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButton(ref element, PanelMarket, player, item.Value, seller, n);
                            n++;
                        }
                    }
            }
            else
            {
                UI.CreatePanel(ref element, PanelMarket, UIColors["dark"], "0. 0", "1 1");
                if (page <= totalpages - 1)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("Last", player), 12, "0.8 0.02", "0.85 0.06", $"UI_MarketMainScreen {totalpages} {Enum.GetName(typeof(Category), cat)}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("Next", player), 12, "0.8 0.065", "0.85 0.105", $"UI_MarketMainScreen {page + 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 0)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["red"], GetMSG("Back", player), 12, "0.74 0.065", "0.79 0.105", $"UI_MarketMainScreen {page - 1} {Enum.GetName(typeof(Category), cat)}");
                }
                if (page > 1)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["red"], GetMSG("First", player), 12, "0.74 0.02", "0.79 0.06", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), cat)}");
                }

                foreach (Category ct in Enum.GetValues(typeof(Category)))
                {
                    var loc = FilterButton(c);
                    if (cat == ct)
                    {
                        UI.CreateButton(ref element, PanelMarket, UIColors["red"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1] + .02f}", $"{loc[2]} {loc[3] + .02f}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                        c++;
                    }
                    else
                    {
                        UI.CreateButton(ref element, PanelMarket, UIColors["header"], Enum.GetName(typeof(Category), ct), 12, $"{loc[0]} {loc[1] + .02f}", $"{loc[2]} {loc[3] + .02f}", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), ct)}");
                        c++;
                    }
                }
                UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("TradeBoxAssignment", player), 12, $"0.05 0.92", "0.15 .98", $"UI_SetTradeBox");

                UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("ListItem", player), 12, $"0.35 0.92", "0.65 .98", $"UI_MarketSellScreen {0}");

                if (!configData.ForceSimpleUI)
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("ChangeMode", player), 12, "0.66 0.92", "0.75 .98", $"UI_Mode {0}");
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("ChangeTheme", player), 12, "0.76 0.92", "0.86 .98", $"UI_MarketBackgroundMenu {0}");
                }
                if (isAuth(player))
                {
                    UI.CreateButton(ref element, PanelMarket, UIColors["header"], GetMSG("AdminPanel", player), 12, "0.87 0.92", "0.97 .98", $"UI_AdminPanel");
                }
                int shownentries = page * entriesallowed;
                int n = 0;
                if (cat == Category.All)
                {
                    foreach (var item in mData.MarketListings)
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButtonSimple(ref element, PanelMarket, player, item.Value, seller, n);
                            n++;
                        }
                    }
                }
                else
                    foreach (var item in mData.MarketListings.Where(kvp => kvp.Value.cat == cat))
                    {
                        seller = false;
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            if (item.Value.seller == player.userID)
                            {
                                seller = true;
                            }
                            CreateMarketListingButtonSimple(ref element, PanelMarket, player, item.Value, seller, n);
                            n++;
                        }
                    }
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Close", player), 16, "0.87 0.02", "0.97 0.075", $"UI_DestroyMarketPanel");
            CuiHelper.AddUi(player, element);
        }

        private void CreateMarketListingButton(ref CuiElementContainer container, string panelName, BasePlayer player, AMItem item, bool seller, int num)
        {
            var pos = MarketEntryPos(num);
            var name = item.shortname;
            if (configData.UseUniqueNames && item.name != "")
                name = item.name;
            if (item.shortname == "SR")
            {
                name = "SR Points";
                item.skin = (ulong)ResourceId;
            }
            else if (item.shortname == "ECO")
            {
                name = "Economics";
                item.skin = (ulong)ResourceId;
            }
            UI.CreatePanel(ref container, panelName, UIColors["header"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");

            //SALE ITEM
            UI.LoadImage(ref container, panelName, TryForImage(item.shortname, item.skin), $"{pos[0] + 0.001f} {pos[3] - 0.125f}", $"{pos[0] + 0.1f} {pos[3] - 0.005f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + .1f} {pos[3] - .04f}", $"{pos[2] - .001f} {pos[3] - .001f}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", player, item.amount.ToString()), 12, $"{pos[0] + .1f} {pos[3] - .07f}", $"{pos[2] - .001f} {pos[3] - .041f}", TextAnchor.MiddleLeft);

            if (item.cat != Category.Money)
            {
                Item actual = BuildCostItems(item.shortname, 1);
                if (actual.condition != 0)
                {
                    var percent = System.Convert.ToDouble(item.condition / actual.condition);
                    var xMax = (pos[0] + .1f) + (.175f * percent);
                    var ymin = pos[3] - .11f;
                    var ymax = pos[3] - .08f;
                    UI.CreatePanel(ref container, panelName, UIColors["buttonbg"], $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}");
                    if (percent * 100 > 75)
                        UI.CreatePanel(ref container, panelName, UIColors["green"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    else if (percent * 100 > 25 && percent * 100 < 76)
                        UI.CreatePanel(ref container, panelName, UIColors["yellow"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    else if (percent * 100 > 0 && percent * 100 < 26)
                        UI.CreatePanel(ref container, panelName, UIColors["red"], $"{pos[0] + .1f} {ymin}", $"{xMax} {ymax}");
                    UI.CreateLabel(ref container, panelName, "1 1 1 1", GetMSG("ItemCondition", player, Math.Round(percent * 100).ToString()), 9, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                }
            }

            UI.LoadImage(ref container, PanelMarket, TryForImage("ARROW"), $"{pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("InExchange", player), 14, $"{ pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}", TextAnchor.UpperCenter);

            //COST ITEM
            if (item.priceItemshortname == "SR")
            {
                name = "SR Points";
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            else if (item.priceItemshortname == "ECO")
            {
                name = "Economics";
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            else
            {
                name = item.priceItemshortname;
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname, 0), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 8, $"{pos[0] + 0.005f} {pos[1] + 0.03f}", $"{pos[0] + 0.175f} {pos[1] + 0.06f}", TextAnchor.MiddleRight);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", player, item.priceAmount.ToString()), 8, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[0] + 0.175f} {pos[1] + 0.0299f}", TextAnchor.MiddleRight);
            if (mData.names.ContainsKey(item.seller))
                name = mData.names[item.seller];
            else name = "NONE";
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Seller", player, name), 12, $"{pos[0] + .001f} {pos[3] - .2f}", $"{pos[2] - .1f} {pos[3] - .14f}", TextAnchor.MiddleLeft);

            if (seller == true)
            {
                UI.LoadImage(ref container, PanelMarket, TryForImage("UFILTER"), $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}");
                UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("removelisting", player), 10, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", TextAnchor.MiddleCenter);
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 40, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", $"UI_RemoveListing {item.ID}");
            }
            else
            {
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BuyConfirm {item.ID}");
            }
        }

        private void CreateMarketListingButtonSimple(ref CuiElementContainer container, string panelName, BasePlayer player, AMItem item, bool seller, int num)
        {
            var pos = MarketEntryPos(num);
            var name = item.shortname;
            if (configData.UseUniqueNames && item.name != "")
                name = item.name;
            if (item.shortname == "SR")
            {
                name = "SR Points";
                item.skin = (ulong)ResourceId;
            }
            else if (item.shortname == "ECO")
            {
                name = "Economics";
                item.skin = (ulong)ResourceId;
            }
            UI.CreatePanel(ref container, panelName, UIColors["white"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");

            //SALE ITEM
            UI.LoadImage(ref container, panelName, TryForImage(item.shortname, item.skin), $"{pos[0] + 0.001f} {pos[3] - 0.125f}", $"{pos[0] + 0.1f} {pos[3] - 0.005f}");
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 12, $"{pos[0] + .1f} {pos[3] - .04f}", $"{pos[2] - .001f} {pos[3] - .001f}", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", player, item.amount.ToString()), 12, $"{pos[0] + .1f} {pos[3] - .07f}", $"{pos[2] - .001f} {pos[3] - .041f}", TextAnchor.MiddleLeft);

            if (item.cat != Category.Money)
            {
                Item actual = BuildCostItems(item.shortname, 1);
                if (actual.condition != 0)
                {
                    var percent = System.Convert.ToDouble(item.condition / actual.condition);
                    //var xMax = (pos[0] + .1f) + (.175f * percent);
                    var ymin = pos[3] - .12f;
                    var ymax = pos[3] - .07f;
                    if (percent * 100 > 75)
                        UI.CreateLabel(ref container, panelName, UIColors["green"], GetMSG("ItemCondition", player, Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                    else if (percent * 100 > 25 && percent * 100 < 76)
                        UI.CreateLabel(ref container, panelName, UIColors["yellow"], GetMSG("ItemCondition", player, Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                    else if (percent * 100 > 0 && percent * 100 < 26)
                        UI.CreateLabel(ref container, panelName, UIColors["red"], GetMSG("ItemCondition", player, Math.Round(percent * 100).ToString()), 12, $"{pos[0] + .1f} {ymin}", $"{pos[0] + .275f} {ymax}", TextAnchor.MiddleLeft);
                }
            }

            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("InExchange", player), 14, $"{ pos[0] + .08f} {pos[1] + .07f}", $"{pos[0] + .2f} {pos[1] + .135f}", TextAnchor.UpperCenter);

            //COST ITEM
            if (item.priceItemshortname == "SR")
            {
                name = "SR Points";
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            else if (item.priceItemshortname == "ECO")
            {
                name = "Economics";
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            else
            {
                name = item.priceItemshortname;
                UI.LoadImage(ref container, panelName, TryForImage(item.priceItemshortname, 0), $"{pos[2] - 0.11f} {pos[1] + 0.01f}", $"{pos[2] - 0.005f} {pos[1] + 0.11f}");
            }
            UI.CreateLabel(ref container, panelName, UIColors["dark"], name, 8, $"{pos[0] + 0.005f} {pos[1] + 0.03f}", $"{pos[0] + 0.175f} {pos[1] + 0.06f}", TextAnchor.MiddleRight);
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Amount", player, item.priceAmount.ToString()), 8, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[0] + 0.175f} {pos[1] + 0.0299f}", TextAnchor.MiddleRight);
            if (mData.names.ContainsKey(item.seller))
                name = mData.names[item.seller];
            else name = "NONE";
            UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("Seller", player, name), 12, $"{pos[0] + .001f} {pos[3] - .2f}", $"{pos[2] - .1f} {pos[3] - .14f}", TextAnchor.MiddleLeft);

            if (seller == true)
            {
                UI.LoadImage(ref container, PanelMarket, TryForImage("UFILTER"), $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}");
                UI.CreateLabel(ref container, panelName, UIColors["dark"], GetMSG("removelisting", player), 10, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", TextAnchor.MiddleCenter);
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 40, $"{pos[0] + .02f} {pos[3] - .15f}", $"{pos[0] + .08f} {pos[3] - .1f}", $"UI_RemoveListing {item.ID}");
            }
            else
            {
                UI.CreateButton(ref container, panelName, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BuyConfirm {item.ID}");
            }
        }

        private void MarketSellScreen(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            StorageContainer box = UIInfo[player.userID].box;
            if (box == null)
            {
                OnScreen(player, "YourNoTradeBoxBuying");
                MarketMainScreen(player);
                return;
            }
            float[] pos;
            var i = 0;
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.275 0.25", "0.725 0.75", true);
            //var count = PlayerBoxContents[player.userID].Count();
            UI.CreateTextOutline(ref element, PanelMarket, UIColors["white"], UIColors["black"], GetMSG("SelectItemToSell", player), 20, "0.05 .9", "1 1", TextAnchor.MiddleCenter);
            if (GetTradeBoxContents(player, box) == false)
            {
                MarketMainScreen(player);
                return;
            }
            else
            {
                foreach (AMItem item in PlayerBoxContents[player.userID].Where(bl => !mData.Blacklist.Contains(bl.shortname) && !mData.MarketListings.ContainsKey(bl.ID)))
                {
                    pos = CalcButtonPos(i);
                    UI.LoadImage(ref element, PanelMarket, TryForImage(item.shortname, item.skin), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    if (!HasImage(item.shortname, item.skin))
                        UI.CreateLabel(ref element, PanelMarket, UIColors["white"], item.shortname.ToUpper(), 16, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}", TextAnchor.LowerCenter);
                    if (item.amount > 9999)
                        UI.CreateLabel(ref element, PanelMarket, UIColors["white"], item.amount.ToString(), 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                    else if (item.amount > 1)
                        UI.CreateLabel(ref element, PanelMarket, UIColors["white"], item.amount.ToString(), 16, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectSalesItem {item.ID}"); i++;
                }
            }
            if (configData.ServerRewards && ServerRewards && !mData.Blacklist.Contains("SR"))
                if (CheckPoints(player.userID) is int && (int)CheckPoints(player.userID) > 0)
                {
                    pos = CalcButtonPos(i);
                    UI.CreatePanel(ref element, PanelMarket, "1 1 1 1", $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.LoadImage(ref element, PanelMarket, TryForImage("SR"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectMoney SR"); i++;
                }
            if (configData.Economics && Economics && !mData.Blacklist.Contains("ECO"))
                if (CheckEco(player.userID) > 0)
                {
                    pos = CalcButtonPos(i);
                    UI.CreatePanel(ref element, PanelMarket, "1 1 1 1", $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.LoadImage(ref element, PanelMarket, TryForImage("ECO"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectMoney ECO"); i++;
                }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Back", player), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void SellItems(BasePlayer player, int step = 0, int page = 0)
        {
            AMItem SalesItem;

            var i = 0;
            var name = "";
            var element = UI.CreateElementContainer(PanelMarket, "0 0 0 0", "0.275 0.25", "0.725 0.75");
            switch (step)
            {
                case 0:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    UI.CreateTextOutline(ref element, PanelMarket, UIColors["white"], UIColors["black"], GetMSG("SetName", player, SalesItem.shortname), 20, "0.05 0", ".95 1", TextAnchor.MiddleCenter);
                    break;

                case 1:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    if (configData.UseUniqueNames && SalesItem.name != "")
                        name = SalesItem.name;
                    else name = SalesItem.shortname;
                    double count = 0;
                    foreach (var item in ItemManager.itemList.Where(a => !mData.Blacklist.Contains(a.shortname)))
                        count++;
                    UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateTextOutline(ref element, PanelMarket, UIColors["white"], UIColors["black"], GetMSG("SetpriceItemshortname", player, name), 20, "0.05 .9", ".95 1", TextAnchor.MiddleCenter);
                    double entriesallowed = 30;
                    double remainingentries = count - (page * (entriesallowed - 1));
                    double totalpages = (Math.Floor(count / (entriesallowed - 1)));
                    {
                        if (page <= totalpages - 1)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("LAST"), "0.8 0.02", "0.85 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.8 0.02", "0.85 0.075", $"UI_SellItems {totalpages}");
                        }
                        if (remainingentries > entriesallowed)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("NEXT"), "0.74 0.02", "0.79 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.74 0.02", "0.79 0.075", $"UI_SellItems {page + 1}");
                        }
                        if (page > 0)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("BACK"), "0.68 0.02", "0.73 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.68 0.02", "0.73 0.075", $"UI_SellItems {page - 1}");
                        }
                        if (page > 1)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("FIRST"), "0.62 0.02", "0.67 0.075");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.62 0.02", "0.67 0.075", $"UI_SellItems {0}");
                        }
                    }
                    int n = 0;
                    var pos = CalcButtonPos(n);
                    double shownentries = page * entriesallowed;
                    if (page == 0)
                    {
                        if (configData.ServerRewards && ServerRewards)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("SR"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectpriceItemshortname SR");
                            n++;
                            i++;
                        }
                        if (configData.Economics && Economics)
                        {
                            UI.LoadImage(ref element, PanelMarket, TryForImage("ECO"), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectpriceItemshortname ECO");
                            n++;
                            i++;
                        }
                    }
                    foreach (var item in ItemManager.itemList.Where(a => !mData.Blacklist.Contains(a.shortname)))
                    {
                        i++;
                        if (i < shownentries + 1) continue;
                        else if (i <= shownentries + entriesallowed)
                        {
                            pos = CalcButtonPos(n);
                            UI.LoadImage(ref element, PanelMarket, TryForImage(item.shortname, 0), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            if (!HasImage(item.shortname, 0))
                                UI.CreateLabel(ref element, PanelMarket, UIColors["white"], item.shortname, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectpriceItemshortname {item.shortname}");
                            n++;
                        }
                    }
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Quit", player), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
                    break;

                default:
                    CuiHelper.DestroyUi(player, PanelMarket);
                    SalesItem = SalesItemPrep[player.userID];
                    if (SalesItem == null) return;
                    if (configData.UseUniqueNames && SalesItem.name != "")
                        name = SalesItem.name;
                    else name = SalesItem.shortname;
                    UI.CreatePanel(ref element, PanelMarket, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                    UI.CreateLabel(ref element, PanelMarket, UIColors["white"], GetMSG("NewItemInfo", player), 20, "0.05 .8", ".95 .95");
                    string ItemDetails = GetMSG("ItemDetails", player, SalesItem.amount.ToString(), name, SalesItem.priceAmount.ToString(), SalesItem.priceItemshortname);
                    UI.CreateLabel(ref element, PanelMarket, UIColors["white"], ItemDetails, 20, "0.1 0.1", "0.9 0.65", TextAnchor.MiddleLeft);
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetMSG("ListItem", player), 18, "0.2 0.05", "0.4 0.15", $"UI_ListItem", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("CancelListing", player), 18, "0.6 0.05", "0.8 0.15", $"UI_CancelListing");
                    break;
            }
            CuiHelper.AddUi(player, element);
        }

        private void PurchaseConfirmation(BasePlayer player, uint index)
        {
            CuiHelper.DestroyUi(player, PanelPurchase);
            AMItem purchaseitem = mData.MarketListings[index];
            var name = "";
            if (configData.UseUniqueNames && purchaseitem.name != "")
                name = purchaseitem.name;
            else name = purchaseitem.shortname;
            var element = UI.CreateElementContainer(PanelPurchase, UIColors["dark"], "0.425 0.35", "0.575 0.65", true);
            UI.CreatePanel(ref element, PanelPurchase, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelPurchase, MsgColor, GetMSG("PurchaseConfirmation", player, name, purchaseitem.amount.ToString()), 12, "0.05 0.75", "0.95 0.95");
            Vector2 position = new Vector2(0.25f, 0.3f);
            Vector2 dimensions = new Vector2(0.4f, 0.4f);
            Vector2 posMin = position;
            Vector2 posMax = posMin + dimensions;
            if (purchaseitem.shortname == "SR")
            {
                name = "SR Points";
                purchaseitem.skin = (ulong)ResourceId;
            }
            else if (purchaseitem.shortname == "ECO")
            {
                name = "Economics";
                purchaseitem.skin = (ulong)ResourceId;
            }
            if (!HasImage(purchaseitem.shortname, purchaseitem.skin)) UI.CreateLabel(ref element, PanelPurchase, UIColors["white"], purchaseitem.shortname, 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", TextAnchor.MiddleCenter);
            UI.LoadImage(ref element, PanelPurchase, TryForImage(purchaseitem.shortname, purchaseitem.skin), $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}");
            if (purchaseitem.amount > 1)
                UI.CreateLabel(ref element, PanelPurchase, UIColors["white"], $"x {purchaseitem.amount}", 14, $"{posMin.x} {posMin.y}", $"{posMax.x} {posMax.y}", TextAnchor.MiddleCenter);
            //if (mData.MarketListings[index].cat != Category.Money)
            //{
            //    Item item = BuildCostItems(mData.MarketListings[index].shortname, mData.MarketListings[index].amount);

            //    if (item.condition != 0)
            //    {
            //        var percent = System.Convert.ToDouble(purchaseitem.condition / item.condition);
            //        var xMax = .1f + (0.8f * percent);
            //        var ymin = 0.3;
            //        var ymax = 0.4;
            //        UI.CreatePanel(ref element, PanelPurchase, UIColors["buttonbg"], $"0.1 {ymin}", $"0.9 {ymax}");
            //        UI.CreatePanel(ref element, PanelPurchase, UIColors["green"], $"0.1 {ymin}", $"{xMax} {ymax}");
            //        UI.CreateLabel(ref element, PanelPurchase, "1 1 1 1", GetMSG("ItemCondition", Math.Round(percent * 100).ToString()), 20, $"0.1 {ymin}", $"0.9 {ymax}", TextAnchor.MiddleLeft);
            //    }
            //}
            UI.CreateButton(ref element, PanelPurchase, UIColors["buttongreen"], GetMSG("Yes", player), 14, "0.25 0.05", "0.45 0.2", $"UI_ProcessItem {index}");
            //else UI.CreateButton(ref element, PanelPurchase, UIColors["buttongreen"], GetMSG("Yes"), 14, "0.25 0.05", "0.45 0.2", $"UI_ProcessMoney {index}");
            UI.CreateButton(ref element, PanelPurchase, UIColors["buttonred"], GetMSG("No", player), 14, "0.55 0.05", "0.75 0.2", $"UI_DestroyPurchaseScreen");
            CuiHelper.AddUi(player, element);
        }

        private void AdminPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var i = 0;
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.275 0.25", "0.725 0.75", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, MsgColor, GetMSG("AdminPanel", player), 75, "0.05 0", "0.95 1");
            var loc = CalcButtonPos(i);
            UI.CreateButton(ref element, PanelMarket, UIColors["CSorange"], GetMSG("BlackListingADD", player), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_BlackList {0} add"); i++;
            loc = CalcButtonPos(i);
            UI.CreateButton(ref element, PanelMarket, UIColors["CSorange"], GetMSG("BlackListingREMOVE", player), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_BlackList {0} remove"); i++;
            i = 23;
            loc = CalcButtonPos(i);
            UI.CreateButton(ref element, PanelMarket, UIColors["CSorange"], GetMSG("ClearMarket", player), 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_ClearMarket"); i++;

            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Back", player), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void MarketBackgroundMenu(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            if (!mData.background.ContainsKey(player.userID))
                mData.background.Add(player.userID, "NONE");
            var i = 0;
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.275 0.25", "0.725 0.75", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelMarket, MsgColor, GetMSG("SelectTheme", player), 20, "0 .9", "1 1");
            var count = configData.CustomBackgrounds.Count();
            double entriesallowed = 30;
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            {
                if (page <= totalpages - 1)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("LAST"), "0.8 0.02", "0.85 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.8 0.02", "0.85 0.075", $"UI_MarketBackgroundMenu {totalpages}");
                }
                if (remainingentries > entriesallowed)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("NEXT"), "0.74 0.02", "0.79 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.74 0.02", "0.79 0.075", $"UI_MarketBackgroundMenu {page + 1}");
                }
                if (page > 0)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("BACK"), "0.68 0.02", "0.73 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.68 0.02", "0.73 0.075", $"UI_MarketBackgroundMenu {page - 1}");
                }
                if (page > 1)
                {
                    UI.LoadImage(ref element, PanelMarket, TryForImage("FIRST"), "0.62 0.02", "0.67 0.075");
                    UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 16, "0.62 0.02", "0.67 0.075", $"UI_MarketBackgroundMenu {0}");
                }
            }

            double shownentries = page * entriesallowed;
            int n = 0;
            foreach (var entry in configData.CustomBackgrounds)
            {
                i++;
                if (i < shownentries + 1) continue;
                else if (i <= shownentries + entriesallowed)
                {
                    var loc = CalcButtonPos(n);
                    if (mData.background[player.userID] != entry.Key)
                    {
                        UI.LoadImage(ref element, PanelMarket, TryForImage(entry.Key), $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}");
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{loc[0]} {loc[1]}", $"{loc[2]} {loc[3]}", $"UI_ChangeBackground {entry.Key}");
                        n++;
                    }
                }
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Back", player), 16, "0.03 0.02", "0.13 0.075", $"UI_MarketMainScreen {0} {Enum.GetName(typeof(Category), Category.All)}");
            CuiHelper.AddUi(player, element);
        }

        private void BlackListing(BasePlayer player, int page = 0, string action = "add")
        {
            CuiHelper.DestroyUi(player, PanelMarket);
            var i = 0;
            double count = ItemManager.itemList.Count();
            var element = UI.CreateElementContainer(PanelMarket, UIColors["dark"], "0.275 0.25", "0.725 0.75", true);
            UI.CreatePanel(ref element, PanelMarket, UIColors["light"], "0.01 0.02", "0.99 0.98");
            int entriesallowed = 30;
            int shownentries = page * entriesallowed;
            int n = 0;
            if (action == "add")
            {
                UI.CreateTextOutline(ref element, PanelMarket, UIColors["white"], UIColors["black"], GetMSG("SelectItemToBlacklist", player), 20, "0.05 0.9", ".95 1", TextAnchor.MiddleCenter);
                foreach (var entry in ItemManager.itemList.Where(bl => !mData.Blacklist.Contains(bl.shortname)).OrderBy(kvp => kvp.shortname))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        var pos = CalcButtonPos(n);
                        UI.LoadImage(ref element, PanelMarket, TryForImage(entry.shortname, 0), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                        if (!HasImage(entry.shortname, 0)) UI.CreateLabel(ref element, PanelMarket, UIColors["white"], entry.shortname, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BackListItem add {entry.shortname}");
                        n++;
                    }
                }
            }
            else if (action == "remove")
            {
                count = mData.Blacklist.Count();
                if (count == 0)
                {
                    OnScreen(player, "NoBlackListedItems");
                    AdminPanel(player);
                    return;
                }
                UI.CreateTextOutline(ref element, PanelMarket, UIColors["white"], UIColors["black"], GetMSG("SelectItemToUnBlacklist", player), 20, "0.05 0.9", ".95 1", TextAnchor.MiddleCenter);
                foreach (var entry in mData.Blacklist.OrderBy(kvp => kvp))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        var pos = CalcButtonPos(n);
                        UI.LoadImage(ref element, PanelMarket, TryForImage(entry, 0), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                        if (!HasImage(entry, 0)) UI.CreateLabel(ref element, PanelMarket, UIColors["white"], entry, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleCenter);
                        UI.CreateButton(ref element, PanelMarket, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_BackListItem remove {entry}");
                        n++;
                    }
                }
            }
            double remainingentries = count - (page * (entriesallowed - 1));
            double totalpages = (Math.Floor(count / (entriesallowed - 1)));
            {
                if (page <= totalpages - 1)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetMSG("Last", player), 16, "0.87 0.02", "0.97 0.075", $"UI_BlackList {totalpages} {action}");
                if (remainingentries > entriesallowed)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonbg"], GetMSG("Next", player), 16, "0.73 0.02", "0.83 0.075", $"UI_BlackList {page + 1} {action}");
                if (page > 0)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Back", player), 16, "0.59 0.02", "0.69 0.075", $"UI_BlackList {page - 1} {action}");
                if (page > 1)
                    UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("First", player), 16, "0.45 0.02", "0.55 0.075", $"UI_BlackList {0} {action}");
            }
            UI.CreateButton(ref element, PanelMarket, UIColors["buttonred"], GetMSG("Back", player), 16, "0.03 0.02", "0.13 0.075", $"UI_AdminPanel");
            CuiHelper.AddUi(player, element);
        }

        #endregion UI Panels

        #region UI Calculations

        private float[] MarketEntryPos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.66f);
            Vector2 dimensions = new Vector2(0.3f, 0.25f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 3)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            if (number > 2 && number < 6)
            {
                offsetX = 0.315f;
                offsetY = (-0.01f - dimensions.y) * (number - 3);
            }
            if (number > 5 && number < 9)
            {
                offsetX = 0.315f * 2;
                offsetY = (-0.01f - dimensions.y) * (number - 6);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] FilterButton(int number)
        {
            Vector2 position = new Vector2(0.01f, 0.0f);
            Vector2 dimensions = new Vector2(0.08f, 0.04f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 2)
            {
                offsetY = (0.005f + dimensions.y) * number;
            }
            if (number > 1 && number < 4)
            {
                offsetX = (0.01f + dimensions.x) * 1;
                offsetY = (0.005f + dimensions.y) * (number - 2);
            }
            if (number > 3 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * 2;
                offsetY = (0.005f + dimensions.y) * (number - 4);
            }
            if (number > 5 && number < 8)
            {
                offsetX = (0.01f + dimensions.x) * 3;
                offsetY = (0.005f + dimensions.y) * (number - 6);
            }
            if (number > 7 && number < 10)
            {
                offsetX = (0.01f + dimensions.x) * 4;
                offsetY = (0.005f + dimensions.y) * (number - 8);
            }
            if (number > 9 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * 5;
                offsetY = (0.005f + dimensions.y) * (number - 10);
            }
            if (number > 11 && number < 14)
            {
                offsetX = (0.01f + dimensions.x) * 6;
                offsetY = (0.005f + dimensions.y) * (number - 12);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] BackgroundButton(int number)
        {
            Vector2 position = new Vector2(0.3f, 0.97f);
            Vector2 dimensions = new Vector2(0.035f, 0.03f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.005f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.02f, 0.78f);
            Vector2 dimensions = new Vector2(0.11f, 0.14f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.05f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.05f + dimensions.x) * (number - 6);
                offsetY = (-0.025f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.05f + dimensions.x) * (number - 12);
                offsetY = (-0.025f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.05f + dimensions.x) * (number - 18);
                offsetY = (-0.025f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.05f + dimensions.x) * (number - 24);
                offsetY = (-0.025f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.09f, 0.10f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 9)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 8 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.01f + dimensions.x) * (number - 27);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 35 && number < 45)
            {
                offsetX = (0.01f + dimensions.x) * (number - 36);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 44 && number < 54)
            {
                offsetX = (0.01f + dimensions.x) * (number - 45);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        #endregion UI Calculations

        #region UI Commands

        [ConsoleCommand("UI_DestroyMarketPanel")]
        private void cmdUI_DestroyBoxConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
        }

        [ConsoleCommand("UI_DestroyPurchaseScreen")]
        private void cmdUI_DestroyPurchaseScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
        }

        [ConsoleCommand("UI_ToggleMarketScreen")]
        private void cmdUI_ToggleMarketScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ToggleMarketScreen(player);
        }

        [ConsoleCommand("UI_SelectSalesItem")]
        private void cmdUI_SelectSalesItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID))
                GetSendMSG(player, "INVALIDENTRY", arg.Args[0]);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            SalesItemPrep.Add(player.userID, new AMItem());
            foreach (var entry in PlayerBoxContents[player.userID].Where(k => k.ID == ID))
            {
                SalesItemPrep[player.userID] = entry;
            }
            PlayerBoxContents.Remove(player.userID);
            SalesItemPrep[player.userID].seller = player.userID;
            SalesItemPrep[player.userID].stepNum = 0;
            if (configData.UseUniqueNames)
                SellItems(player);
            else
                SellItems(player, 1);
        }

        [ConsoleCommand("UI_SelectMoney")]
        private void cmdUI_SelectMoney(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyMarketPanel(player);
            if (SalesItemPrep.ContainsKey(player.userID))
                SalesItemPrep.Remove(player.userID);
            SalesItemPrep.Add(player.userID, new AMItem());
            PlayerBoxContents.Remove(player.userID);
            SalesItemPrep[player.userID].cat = Category.Money;
            SalesItemPrep[player.userID].skin = 0;
            SalesItemPrep[player.userID].ID = GetRandomNumber();
            SalesItemPrep[player.userID].seller = player.userID;
            SalesItemPrep[player.userID].stepNum = 0;
            if (arg.Args[0] == "SR")
            {
                SalesItemPrep[player.userID].shortname = "SR";
                NumberPad(player, "UI_SRAmount");
                return;
            }
            if (arg.Args[0] == "ECO")
            {
                SalesItemPrep[player.userID].shortname = "ECO";
                NumberPad(player, "UI_ECOAmount");
                return;
            }
        }

        [ConsoleCommand("UI_SRAmount")]
        private void cmdUI_SRAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            var currentSRlisted = 0;
            if (CheckPoints(player.userID) is int)
                if ((int)CheckPoints(player.userID) >= amount)
                {
                    foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID && kvp.Value.shortname == "SR"))
                        currentSRlisted += entry.Value.amount;
                    if ((int)CheckPoints(player.userID) - currentSRlisted >= amount)
                    {
                        SalesItemPrep[player.userID].amount = amount;
                        DestroyMarketPanel(player);
                        if (configData.UseUniqueNames)
                        {
                            SellItems(player);
                            return;
                        }
                        else
                        {
                            SellItems(player, 1);
                            return;
                        }
                    }
                }
            GetSendMSG(player, "NotEnoughSRPoints");
        }

        [ConsoleCommand("UI_ECOAmount")]
        private void cmdUI_ECOAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            var ECOListedAmount = 0;
            if (CheckEco(player.userID) >= amount)
            {
                foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID && kvp.Value.shortname == "ECO"))
                    ECOListedAmount += entry.Value.amount;
                if (CheckEco(player.userID) - ECOListedAmount >= amount)
                {
                    SalesItemPrep[player.userID].amount = amount;
                    DestroyMarketPanel(player);
                    if (configData.UseUniqueNames)
                    {
                        SellItems(player);
                        return;
                    }
                    else
                    {
                        SellItems(player, 1);
                        return;
                    }
                }
            }
            GetSendMSG(player, "NotEnoughECOPoints");
        }

        [ConsoleCommand("UI_SelectpriceItemshortname")]
        private void cmdUI_SelectpriceItemshortname(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            string priceItemshortname = arg.Args[0];
            SalesItemPrep[player.userID].priceItemshortname = priceItemshortname;
            foreach (var cat in configData.Categorization)
            {
                if (cat.Value.Contains(priceItemshortname))
                {
                    SalesItemPrep[player.userID].pricecat = cat.Key;
                    break;
                }
                else
                {
                    SalesItemPrep[player.userID].pricecat = Category.Other;
                    continue;
                }
            }
            SalesItemPrep[player.userID].stepNum = 1;
            NumberPad(player, "UI_SelectPriceAmount");
        }

        [ConsoleCommand("UI_SelectPriceAmount")]
        private void cmdUI_SelectPriceAmount(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            SalesItemPrep[player.userID].priceAmount = amount;
            DestroyMarketPanel(player);
            SellItems(player, 99);
        }

        private uint GetRandomNumber()
        {
            var random = new System.Random();
            uint number = (uint)random.Next(0, int.MaxValue);
            return number;
        }

        [ConsoleCommand("UI_ListItem")]
        private void cmdUI_ListItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (SalesItemPrep[player.userID].cat != Category.Money)
            {
                StorageContainer box = UIInfo[player.userID].box;
                if (box == null || GetTradeBoxContents(player, box) == false) return;
                if (!mData.MarketListings.ContainsKey(SalesItemPrep[player.userID].ID))
                {
                    if (BoxCheck(player, SalesItemPrep[player.userID].ID))
                    {
                        var solditem = SalesItemPrep[player.userID].shortname;
                        mData.MarketListings.Add(SalesItemPrep[player.userID].ID, SalesItemPrep[player.userID]);
                        if (SalesItemPrep.ContainsKey(player.userID))
                            SalesItemPrep.Remove(player.userID);
                        if (PlayerBoxContents.ContainsKey(player.userID))
                            PlayerBoxContents.Remove(player.userID);
                        OnScreen(player, "NewItemListed", solditem);
                        DestroyMarketPanel(player);
                        MarketMainScreen(player);
                        return;
                    }
                    GetSendMSG(player, "ItemNotInBox");
                }
                GetSendMSG(player, "ItemAlreadyListed");
                CancelListing(player);
            }
            else
            {
                var money = "";
                mData.MarketListings.Add(SalesItemPrep[player.userID].ID, SalesItemPrep[player.userID]);
                if (SalesItemPrep[player.userID].shortname == "SR")
                    money = "Server Rewards Points";
                else if (SalesItemPrep[player.userID].shortname == "ECO")
                    money = "Economics";
                OnScreen(player, "NewMoneyListed", money, SalesItemPrep[player.userID].amount.ToString());
                if (SalesItemPrep.ContainsKey(player.userID))
                    SalesItemPrep.Remove(player.userID);
                if (PlayerBoxContents.ContainsKey(player.userID))
                    PlayerBoxContents.Remove(player.userID);
                DestroyMarketPanel(player);
                MarketMainScreen(player);
            }
        }

        [ConsoleCommand("UI_CancelListing")]
        private void cmdUI_CancelListing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CancelListing(player);
        }

        [ConsoleCommand("UI_ChangeBackground")]
        private void cmdUI_ChangeBackground(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            mData.background[player.userID] = arg.Args[0];
            MarketMainScreen(player);
        }

        [ConsoleCommand("UI_MarketMainScreen")]
        private void cmdUI_MainMarketScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            Category cat;
            cat = (Category)Enum.Parse(typeof(Category), arg.Args[1]);
            MarketMainScreen(player, page, cat);
        }

        [ConsoleCommand("UI_MarketBackgroundMenu")]
        private void cmdUI_MarketBackgroundMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            MarketBackgroundMenu(player, page);
        }

        [ConsoleCommand("UI_BlackList")]
        private void cmdUI_BlackList(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            var action = arg.Args[1];
            BlackListing(player, page, action);
        }

        [ConsoleCommand("UI_ClearMarket")]
        private void cmdUI_ClearMarket(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player))
                return;
            var count = mData.MarketListings.Count();
            mData.MarketListings.Clear();
            GetSendMSG(player, "MarketCleared", count.ToString());
        }

        [ConsoleCommand("UI_AdminPanel")]
        private void cmdUI_AdminPanel(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            AdminPanel(player);
        }

        [ConsoleCommand("UI_MarketSellScreen")]
        private void cmdUI_MarketSellScreen(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            MarketSellScreen(player, page);
        }

        [ConsoleCommand("UI_Mode")]
        private void cmdUI_Mode(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int action;
            if (!int.TryParse(arg.Args[0], out action)) return;
            if (action == 0)
                mData.mode[player.userID] = false;
            if (action == 1)
                mData.mode[player.userID] = true;
            MarketMainScreen(player);
        }

        [ConsoleCommand("UI_SetTradeBox")]
        private void cmdUI_SetBoxMode(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var hit = FindEntityFromRay(player);
            if (hit != null)
            {
                StorageContainer box = hit as StorageContainer;
                if (mData.TradeBox.ContainsKey(player.userID))
                {
                    Dictionary<uint, string> listings = new Dictionary<uint, string>();
                    foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == player.userID))
                        listings.Add(entry.Key, entry.Value.shortname);
                    foreach (var entry in listings)
                        RemoveListing(player.userID, entry.Value, entry.Key, "TradeBoxChanged");
                    listings.Clear();
                    mData.TradeBox.Remove(player.userID);
                }
                mData.TradeBox.Add(player.userID, new XYZ { x = box.transform.localPosition.x, y = box.transform.localPosition.y, z = box.transform.localPosition.z });
                if (!UIInfo.ContainsKey(player.userID))
                    UIInfo.Add(player.userID, new existence());
                UIInfo[player.userID].box = box;
                OnScreen(player, "NewTradeBox");
                SaveData();
            }
        }

        private object FindEntityFromRay(BasePlayer player)
        {
            var input = player.serverInput;
            Ray ray = new Ray(player.eyes.position, Quaternion.Euler(input.current.aimAngles) * Vector3.forward);
            RaycastHit hit;
            if (!Physics.Raycast(ray, out hit, 20))
                return null;
            var hitEnt = hit.collider.GetComponentInParent<StorageContainer>();
            if (hitEnt != null)
                if (hitEnt.OwnerID == player.userID)
                    return hitEnt as StorageContainer;
                else OnScreen(player, "NotyourBox");
            else OnScreen(player, "NoTradeBox");
            return null;
        }

        private void OnScreen(BasePlayer player, string msg, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            if (timers.ContainsKey(player.userID.ToString()))
            {
                timers[player.userID.ToString()].Destroy();
                timers.Remove(player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateOverlayContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.15 0.85", "0.85 .95", false);
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["white"], UIColors["black"], GetMSG(msg, player, arg1, arg2, arg3), 24, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timers.Add(player.userID.ToString(), timer.Once(4, () => CuiHelper.DestroyUi(player, PanelOnScreen)));
        }

        [ConsoleCommand("UI_BuyConfirm")]
        private void cmdUI_BuyConfirm(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            AMItem purchaseitem = mData.MarketListings[ID];
            var name = "";
            if (configData.UseUniqueNames && purchaseitem.name != "")
                name = purchaseitem.name;
            else name = purchaseitem.shortname;
            ulong buyer = player.userID;
            ulong seller = mData.MarketListings[ID].seller;
            if (PlayerInventory.ContainsKey(buyer))
                PlayerInventory.Remove(buyer);
            PlayerInventory.Add(buyer, new List<Item>());
            StorageContainer buyerbox = UIInfo[buyer].box;
            StorageContainer sellerbox = null;
            if (UIInfo.ContainsKey(seller))
                sellerbox = UIInfo[seller].box;
            else GetTradeBox(seller);
            if (sellerbox != null && buyerbox != null)
            {
                if (!buyerbox.inventory.IsFull() && !sellerbox.inventory.IsFull())
                {
                    if (mData.MarketListings[ID].cat != Category.Money)
                    {
                        var c = 0;
                        foreach (Item item in sellerbox.inventory.itemList.Where(kvp => kvp.uid == ID))
                        {
                            c += item.amount;
                            if (item.condition != purchaseitem.condition)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemCondChange");
                                MarketMainScreen(player);
                                return;
                            }
                            if (item.amount != purchaseitem.amount)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemQuantityChange");
                                MarketMainScreen(player);
                                return;
                            }
                            if (c < purchaseitem.amount)
                            {
                                RemoveListing(seller, name, purchaseitem.ID, "ItemGoneChange");
                                MarketMainScreen(player);
                                return;
                            }
                        }
                    }
                    else
                    {
                        if (purchaseitem.shortname == "SR" && (int)CheckPoints(purchaseitem.seller) < purchaseitem.amount)
                        {
                            RemoveListing(seller, name, purchaseitem.ID, "NotEnoughSRPoints");
                            MarketMainScreen(player);
                            return;
                        }
                        else if (purchaseitem.shortname == "ECO" && CheckEco(purchaseitem.seller) < purchaseitem.amount)
                        {
                            RemoveListing(seller, name, purchaseitem.ID, "NotEnoughECOPoints");
                            MarketMainScreen(player);
                            return;
                        }
                    }
                    if (mData.MarketListings[ID].pricecat != Category.Money)
                    {
                        var amount = 0;
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerWear));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerMain));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerBelt));
                        foreach (var entry in PlayerInventory[buyer].Where(kvp => kvp.info.shortname == purchaseitem.priceItemshortname))
                        {
                            amount += entry.amount;
                            if (amount >= purchaseitem.priceAmount)
                            {
                                PurchaseConfirmation(player, ID);
                                return;
                            }
                        }
                        GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                        return;
                    }
                    else
                    {
                        if (purchaseitem.priceItemshortname == "SR")
                        {
                            if ((int)CheckPoints(player.userID) >= purchaseitem.priceAmount)
                                PurchaseConfirmation(player, ID);
                            else
                                GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                            return;
                        }
                        else if (purchaseitem.priceItemshortname == "ECO")
                        {
                            if (CheckEco(player.userID) >= purchaseitem.priceAmount)
                                PurchaseConfirmation(player, ID);
                            else
                                GetSendMSG(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                            return;
                        }
                    }
                }
                else
                {
                    if (buyerbox.inventory.IsFull())
                        GetSendMSG(player, "YourTradeBoxFullBuying");
                    else if (sellerbox.inventory.IsFull())
                        GetSendMSG(player, "SellerTradeBoxFullBuying");
                }
            }
            else
            {
                if (buyerbox == null)
                    OnScreen(player, "YourNoTradeBoxBuying");
                else if (sellerbox == null)
                    GetSendMSG(player, "SellerNoTradeBoxBuying");
            }
        }

        [ConsoleCommand("UI_ProcessMoney")]
        private void cmdUI_ProcessMoney(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
        }

        [ConsoleCommand("UI_ProcessItem")]
        private void cmdUI_ProcessItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            DestroyPurchaseScreen(player);
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            AMItem purchaseitem = mData.MarketListings[ID];
            ulong buyer = player.userID;
            ulong seller = mData.MarketListings[ID].seller;
            if (PlayerInventory.ContainsKey(buyer))
                PlayerInventory.Remove(buyer);
            bool PlayerPurchaseApproval = false;
            List<Item> TransferableItems = new List<Item>();
            PlayerInventory.Add(buyer, new List<Item>());
            StorageContainer buyerbox = UIInfo[buyer].box;
            StorageContainer sellerbox = null;
            if (UIInfo.ContainsKey(seller))
                sellerbox = UIInfo[seller].box;
            else GetTradeBox(seller);
            if (sellerbox != null && buyerbox != null)
            {
                if (!buyerbox.inventory.IsFull() && !sellerbox.inventory.IsFull())
                {
                    if (purchaseitem.pricecat != Category.Money)
                    {
                        var amount = 0;
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerWear));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerMain));
                        PlayerInventory[buyer].AddRange(GetItemsOnly(player.inventory.containerBelt));
                        foreach (var entry in PlayerInventory[buyer].Where(kvp => kvp.info.shortname == purchaseitem.priceItemshortname))
                        {
                            amount += entry.amount;
                            Puts($"Item:{entry.uid} - {entry.amount}");
                            TransferableItems.Add(entry);
                            if (amount >= purchaseitem.priceAmount)
                            {
                                PlayerPurchaseApproval = true;
                                break;
                            }
                            else continue;
                        }
                    }
                    else
                    {
                        if (purchaseitem.priceItemshortname == "SR")
                        {
                            if ((int)CheckPoints(player.userID) >= purchaseitem.priceAmount)
                            {
                                PlayerPurchaseApproval = true;
                            }
                        }
                        else if (purchaseitem.priceItemshortname == "ECO")
                        {
                            if (CheckEco(player.userID) >= purchaseitem.priceAmount)
                            {
                                PlayerPurchaseApproval = true;
                            }
                        }
                    }
                    if (PlayerPurchaseApproval)
                    {
                        //if (ItemsToTransfer.ContainsKey(buyer))
                        //    ItemsToTransfer.Remove(buyer);
                        //ItemsToTransfer.Add(buyer, new List<Item>());
                        if (purchaseitem.pricecat != Category.Money)
                        {
                            int AmountRequired = purchaseitem.priceAmount;
                            foreach (var entry in TransferableItems)
                            {
                                Puts($"Item:{entry.uid} - {entry.amount}");
                                if (AmountRequired > 0)
                                {
                                    if (AmountRequired >= entry.amount)
                                    {
                                        //Puts("1");
                                        entry.MoveToContainer(sellerbox.inventory);
                                        Puts($"{AmountRequired} - Prior to Change");
                                        AmountRequired -= entry.amount;
                                        Puts($"{AmountRequired} - After Change");
                                        Puts($"Item:{entry.uid} - Moved");
                                        Puts($"{entry.amount}");
                                        //Puts($"{item1} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item1.amount}");
                                    }
                                    else
                                    {
                                        Item item2 = entry.SplitItem(AmountRequired);
                                        item2.MoveToContainer(sellerbox.inventory);
                                        AmountRequired = 0;
                                        //Puts($"SPLITTING: {item2} moved... price amount: {mData.MarketListings[Listing].priceAmount} item amount:{item2.amount}");
                                    }
                                }
                            }

                            //XferCost(entry, player, ID, sellerbox.inventory);
                            //foreach (Item item in ItemsToTransfer[buyer])
                            //    item.MoveToContainer(sellerbox.inventory);
                            //ItemsToTransfer[buyer].Clear();
                        }
                        else
                        {
                            if (purchaseitem.priceItemshortname == "SR")
                            {
                                SRAction(buyer, purchaseitem.priceAmount, "REMOVE");
                                SRAction(seller, purchaseitem.priceAmount, "ADD");
                            }
                            else if (purchaseitem.priceItemshortname == "ECO")
                            {
                                ECOAction(buyer, purchaseitem.priceAmount, "REMOVE");
                                ECOAction(seller, purchaseitem.priceAmount, "ADD");
                            }
                        }
                        if (purchaseitem.cat != Category.Money)
                        {
                            foreach (Item item in sellerbox.inventory.itemList.Where(kvp => kvp.uid == ID))
                            {
                                item.MoveToContainer(buyerbox.inventory);
                                break;
                            }
                        }
                        else
                        {
                            if (purchaseitem.shortname == "SR")
                            {
                                SRAction(seller, purchaseitem.amount, "REMOVE");
                                SRAction(buyer, purchaseitem.amount, "ADD");
                            }
                            else if (purchaseitem.shortname == "ECO")
                            {
                                ECOAction(buyer, purchaseitem.amount, "REMOVE");
                                ECOAction(seller, purchaseitem.amount, "ADD");
                            }
                        }
                        OnScreen(player, "NewPurchase", purchaseitem.shortname, purchaseitem.amount.ToString());
                        AddMessages(seller, "NewSale", purchaseitem.shortname, purchaseitem.amount.ToString());
                        mData.MarketListings.Remove(ID);
                        //if (ItemsToTransfer[buyer].Count > 0)
                        //    foreach (Item item in ItemsToTransfer[buyer])
                        //        item.MoveToContainer(buyerbox.inventory);
                        MarketMainScreen(player);
                    }
                    else
                    {
                        OnScreen(player, "NotEnoughPurchaseItem", purchaseitem.priceItemshortname, purchaseitem.priceAmount.ToString());
                    }
                }
                else
                {
                    if (buyerbox.inventory.IsFull())
                        OnScreen(player, "YourTradeBoxFullBuying");
                    else if (sellerbox.inventory.IsFull())
                        OnScreen(player, "SellerTradeBoxFullBuying");
                    MarketMainScreen(player);
                }
            }
            else
            {
                if (buyerbox == null)
                    OnScreen(player, "YourNoTradeBoxBuying");
                else if (sellerbox == null)
                    OnScreen(player, "SellerNoTradeBoxBuying");
            }
        }

        [ConsoleCommand("UI_RemoveListing")]
        private void cmdUI_RemoveListing(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            uint ID;
            if (!uint.TryParse(arg.Args[0], out ID)) return;
            var name = "";
            if (configData.UseUniqueNames && mData.MarketListings[ID].name != "")
                name = mData.MarketListings[ID].name;
            else name = mData.MarketListings[ID].shortname;
            RemoveListing(player.userID, name, ID, "SellerRemoval");
            MarketMainScreen(player);
        }

        [ConsoleCommand("UI_SellItems")]
        private void cmdUI_SellItems(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int page;
            if (!int.TryParse(arg.Args[0], out page)) return;
            SellItems(player, 1, page);
        }

        [ConsoleCommand("UI_BackListItem")]
        private void cmdUI_BackListItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var action = arg.Args[0];
            var item = arg.Args[1];
            if (action == "add")
                mData.Blacklist.Add(item);
            else if (action == "remove")
                mData.Blacklist.Remove(item);
            AdminPanel(player);
        }

        #endregion UI Commands

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "AMInfo", configData.MarketMenuKeyBinding);
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void CheckListings()
        {
            if (timers.ContainsKey("listings"))
            {
                timers["listings"].Destroy();
                timers.Remove("listings");
            }
            foreach (var boxentry in mData.TradeBox)
            {
                StorageContainer box = null;
                if (UIInfo.ContainsKey(boxentry.Key))
                    box = UIInfo[boxentry.Key].box;
                else box = GetTradeBox(boxentry.Key);
                if (box == null)
                {
                    Dictionary<uint, string> listings = new Dictionary<uint, string>();
                    foreach (var entry in mData.MarketListings.Where(kvp => kvp.Value.seller == boxentry.Key))
                        listings.Add(entry.Key, entry.Value.shortname);
                    foreach (var entry in listings)
                        RemoveListing(boxentry.Key, entry.Value, entry.Key, "TradeBoxInvalid");
                    listings.Clear();
                    mData.TradeBox.Remove(boxentry.Key);
                    BasePlayer owner = BasePlayer.FindByID(boxentry.Key);
                    if (BasePlayer.activePlayerList.Contains(owner))
                        GetSendMSG(owner, "TradeBoxNoLongerValid");
                }
            }
            SaveData();
            timers.Add("listings", timer.Once(600, () => CheckListings()));
        }

        private void SetBoxFullNotification(string ID)
        {
            timers.Add(ID, timer.Once(5 * 60, () => timers.Remove(ID)));
        }

        #endregion Timers

        #region Classes

        private class MarketData
        {
            public Dictionary<uint, AMItem> MarketListings = new Dictionary<uint, AMItem>();
            public Dictionary<ulong, XYZ> TradeBox = new Dictionary<ulong, XYZ>();
            public Dictionary<ulong, string> background = new Dictionary<ulong, string>();
            public Dictionary<ulong, bool> mode = new Dictionary<ulong, bool>();
            public Dictionary<ulong, List<Unsent>> OutstandingMessages = new Dictionary<ulong, List<Unsent>>();
            public List<string> Blacklist = new List<string>();
            public Dictionary<ulong, string> names = new Dictionary<ulong, string>();
        }

        private class XYZ
        {
            public float x;
            public float y;
            public float z;
        }

        private class Unsent
        {
            public string message;
            public string arg1;
            public string arg2;
            public string arg3;
            public string arg4;
        }

        private enum Category
        {
            Weapons,
            Armor,
            Attire,
            Ammunition,
            Medical,
            Tools,
            Building,
            Resources,
            Other,
            All,
            Food,
            Money,
            Components,
        }

        private class AMItem
        {
            public string name;
            public string shortname;
            public ulong skin;
            public uint ID;
            public Category cat;
            public bool approved;
            public Category pricecat;
            public string priceItemshortname;
            public int priceItemID;
            public int priceAmount;
            public int amount;
            public int stepNum;
            public ulong seller;
            public float condition;
        }

        #endregion Classes

        #region Backgrounds

        private void AddNeededImages()
        {
            foreach (var entry in UIElements)
                AddImage(entry.Value, entry.Key, (ulong)ResourceId);
        }

        private void RefreshBackgrounds()
        {
            var i = 0;
            foreach (var entry in configData.CustomBackgrounds)
            {
                if (!HasImage(entry.Key, (ulong)ResourceId)) i++;
                AddImage(entry.Value, entry.Key, (ulong)ResourceId);
            }
            if (i > 0)
                Puts(GetMSG("BckAdded", null, i.ToString()));
        }

        #endregion Backgrounds

        #region Absolut Market Data Management

        private Dictionary<string, string> UIElements = new Dictionary<string, string>
        {
            {"ARROW", "http://www.freeiconspng.com/uploads/red-arrow-curved-5.png" },
            {"FIRST", "http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/simple-black-square-icons-arrows/126517-simple-black-square-icon-arrows-double-arrowhead-left.png" },
            {"BACK", "https://image.freepik.com/free-icon/back-left-arrow-in-square-button_318-76403.png" },
            {"NEXT", "https://image.freepik.com/free-icon/right-arrow-square-button-outline_318-76302.png"},
            {"LAST","http://cdn.mysitemyway.com/etc-mysitemyway/icons/legacy-previews/icons/matte-white-square-icons-arrows/124577-matte-white-square-icon-arrows-double-arrowhead-right.png" },
            {"OFILTER", "https://pixabay.com/static/uploads/photo/2016/01/23/11/41/button-1157299_960_720.png" },
            {"UFILTER","https://pixabay.com/static/uploads/photo/2016/01/23/11/42/button-1157301_960_720.png" },
            {"ADMIN", "https://pixabay.com/static/uploads/photo/2016/01/23/11/26/button-1157269_960_720.png" },
            {"MISC","https://pixabay.com/static/uploads/photo/2015/07/25/07/55/the-button-859343_960_720.png" },
            {"SELL","https://pixabay.com/static/uploads/photo/2015/07/25/08/03/the-button-859350_960_720.png" },
            {"SR", "http://oxidemod.org/data/resource_icons/1/1751.jpg?1456924271" },
            {"ECO", "http://oxidemod.org/data/resource_icons/0/717.jpg?1465675504" },
        };

        private Dictionary<Category, List<string>> Categorization = new Dictionary<Category, List<string>>
        {
            {Category.Money, new List<string>
            {
                {"SR"},
                {"ECO" },
            }
            },
            {Category.Attire, new List<string>
            {
            {"tshirt"},
            {"pants"},
            {"shoes.boots"},
            {"tshirt.long"},
            {"mask.bandana"},
            {"mask.balaclava"},
            {"jacket.snow"},
            {"jacket"},
            {"hoodie"},
            {"hat.cap"},
            {"hat.beenie"},
            {"burlap.gloves"},
            {"burlap.shirt"},
            {"hat.boonie"},
            {"santahat"},
            {"hazmat.pants"},
            {"hazmat.jacket"},
            {"hazmat.helmet"},
            {"hazmat.gloves"},
            {"hazmat.boots"},
            {"hazmatsuit" },
            {"hat.miner"},
            {"hat.candle"},
            {"burlap.trousers"},
            {"burlap.shoes"},
            {"burlap.headwrap"},
            {"shirt.tanktop"},
            {"shirt.collared"},
            {"pants.shorts"},
            }
            },
            {Category.Armor, new List<string>
            {
            {"bucket.helmet"},
            {"wood.armor.pants"},
            {"wood.armor.jacket"},
            {"roadsign.kilt"},
            {"roadsign.jacket"},
            {"riot.helmet"},
            {"metal.plate.torso"},
            {"metal.facemask"},
            {"coffeecan.helmet"},
            {"bone.armor.suit"},
            {"attire.hide.vest"},
            {"attire.hide.skirt"},
            {"attire.hide.poncho"},
            {"attire.hide.pants"},
            {"attire.hide.helterneck"},
            {"attire.hide.boots"},
            {"deer.skull.mask"},
            }
            },
            {Category.Weapons, new List<string>
            {
            {"pistol.revolver"},
            {"pistol.semiauto"},
            {"rifle.ak"},
            {"rifle.bolt"},
            {"shotgun.pump"},
            {"shotgun.waterpipe"},
            {"rifle.lr300"},
            {"pistol.m92" },
            {"crossbow"},
            {"smg.thompson"},
            {"weapon.mod.small.scope"},
            {"weapon.mod.silencer"},
            {"weapon.mod.muzzlebrake"},
            {"weapon.mod.muzzleboost"},
            {"weapon.mod.lasersight"},
            {"weapon.mod.holosight"},
            {"weapon.mod.flashlight"},
            {"spear.wooden"},
            {"spear.stone"},
            {"smg.2"},
            {"shotgun.double"},
            {"salvaged.sword"},
            {"salvaged.cleaver"},
            {"rocket.launcher"},
            {"rifle.semiauto"},
            {"pistol.eoka"},
            {"machete"},
            {"mace"},
            {"longsword"},
            {"lmg.m249"},
            {"knife.bone"},
            {"flamethrower"},
            {"bow.hunting"},
            {"bone.club"},
            {"grenade.f1"},
            {"grenade.beancan"},
            }
            },
            {Category.Ammunition, new List<string>
            {
            {"ammo.handmade.shell"},
            {"ammo.pistol"},
             {"ammo.pistol.fire"},
            {"ammo.pistol.hv"},
            {"ammo.rifle"},
            {"ammo.rifle.explosive"},
            {"ammo.rifle.hv"},
            {"ammo.rifle.incendiary"},
            {"ammo.rocket.basic"},
            {"ammo.rocket.fire"},
            {"ammo.rocket.hv"},
            {"ammo.rocket.smoke"},
            {"ammo.shotgun"},
            {"ammo.shotgun.slug"},
            {"arrow.hv"},
            {"arrow.wooden"},
            }
            },

            {Category.Medical, new List<string>
            {
            {"bandage"},
            {"syringe.medical"},
            { "largemedkit"},
            { "antiradpills"},
            }
            },

            {Category.Building, new List<string>
            {
            {"bed"},
            {"box.wooden"},
            {"box.wooden.large"},
            {"ceilinglight"},
            {"door.double.hinged.metal"},
            {"door.double.hinged.toptier"},
            {"door.double.hinged.wood"},
            {"door.hinged.metal"},
            {"door.hinged.toptier"},
            {"door.hinged.wood"},
            {"floor.grill"},
            {"floor.ladder.hatch"},
            {"gates.external.high.stone"},
            {"gates.external.high.wood"},
            {"shelves"},
            {"shutter.metal.embrasure.a"},
            {"shutter.metal.embrasure.b"},
            {"shutter.wood.a"},
            {"sign.hanging"},
            {"sign.hanging.banner.large"},
            {"sign.hanging.ornate"},
            {"sign.pictureframe.landscape"},
            {"sign.pictureframe.portrait"},
            {"sign.pictureframe.tall"},
            {"sign.pictureframe.xl"},
            {"sign.pictureframe.xxl"},
            {"sign.pole.banner.large"},
            {"sign.post.double"},
            {"sign.post.single"},
            {"sign.post.town"},
            {"sign.post.town.roof"},
            {"sign.wooden.huge"},
            {"sign.wooden.large"},
            {"sign.wooden.medium"},
            {"sign.wooden.small"},
            {"jackolantern.angry"},
            {"jackolantern.happy"},
            {"ladder.wooden.wall"},
            {"lantern"},
            {"lock.code"},
            {"mining.quarry"},
            {"wall.external.high"},
            {"wall.external.high.stone"},
            {"wall.frame.cell"},
            {"wall.frame.cell.gate"},
            {"wall.frame.fence"},
            {"wall.frame.fence.gate"},
            {"wall.frame.shopfront"},
            {"wall.window.bars.metal"},
            {"wall.window.bars.toptier"},
            {"wall.window.bars.wood"},
            {"lock.key"},
            { "barricade.concrete"},
            {"barricade.metal"},
            { "barricade.sandbags"},
            { "barricade.wood"},
            { "barricade.woodwire"},
            { "barricade.stone"},
            }
            },

            {Category.Resources, new List<string>
            {
            {"charcoal"},
            {"cloth"},
            {"crude.oil"},
            {"fat.animal"},
            {"hq.metal.ore"},
            {"lowgradefuel"},
            {"metal.fragments"},
            {"metal.ore"},
            {"leather"},
            {"metal.refined"},
            {"wood"},
            {"seed.corn"},
            {"seed.hemp"},
            {"seed.pumpkin"},
            {"stones"},
            {"sulfur"},
            {"sulfur.ore"},
            {"gunpowder"},
            {"researchpaper"},
            {"explosives"},
            }
            },

            {Category.Tools, new List<string>
            {
            {"botabag"},
            {"box.repair.bench"},
            {"bucket.water"},
            {"explosive.satchel"},
            {"explosive.timed"},
            {"flare"},
            {"fun.guitar"},
            {"furnace"},
            {"furnace.large"},
            {"hatchet"},
            {"icepick.salvaged"},
            {"axe.salvaged"},
            {"pickaxe"},
            {"research.table"},
            {"small.oil.refinery"},
            {"stone.pickaxe"},
            {"stonehatchet"},
            {"supply.signal"},
            {"surveycharge"},
            {"target.reactive"},
            {"tool.camera"},
            {"water.barrel"},
            {"water.catcher.large"},
            {"water.catcher.small"},
            {"water.purifier"},
            {"torch"},
            {"stash.small"},
            {"sleepingbag"},
            {"hammer.salvaged"},
            {"hammer"},
            {"blueprintbase"},
            {"fishtrap.small"},
            {"building.planner"},
            }
            },

            {Category.Other, new List<string>
            {
            {"cctv.camera"},
            {"pookie.bear"},
            {"targeting.computer"},
            {"trap.bear"},
            {"trap.landmine"},
            {"autoturret"},
            {"spikes.floor"},
            {"note"},
            {"paper"},
            {"map"},
            {"campfire"},
            {"blueprintbase" },
            }
            },

            {Category.Components, new List<string>
            {
            {"bleach"},
            {"ducttape"},
            {"propanetank"},
            {"gears"},
            {"glue"},
            {"metalblade"},
            {"metalpipe"},
            {"metalspring"},
            {"riflebody"},
            {"roadsigns"},
            {"rope"},
            {"sewingkit"},
            {"sheetmetal"},
            {"smgbody"},
            {"sticks"},
            {"tarp"},
            {"techparts"},
            {"semibody" },
            }
            },

            {Category.Food, new List<string>
            {
            { "wolfmeat.cooked"},
            {"waterjug"},
            {"water.salt"},
            {"water"},
            {"smallwaterbottle"},
            {"pumpkin"},
            {"mushroom"},
            {"meat.pork.cooked"},
            {"humanmeat.cooked"},
            {"granolabar"},
            {"fish.cooked"},
            {"chocholate"},
            {"chicken.cooked"},
            {"candycane"},
            {"can.tuna"},
            {"can.beans"},
            {"blueberries"},
            {"black.raspberries"},
            {"bearmeat.cooked"},
            {"apple"},
            }
            }
        };

        private void SaveData()
        {
            MData.WriteObject(mData);
        }

        private void LoadData()
        {
            try
            {
                mData = MData.ReadObject<MarketData>();
                if (mData == null)
                    mData = new MarketData();
            }
            catch
            {
                Puts("Couldn't load the Absolut Market Data, creating a new datafile");
                mData = new MarketData();
            }
            if (mData.background == null)
                mData.background = new Dictionary<ulong, string>();
            if (mData.Blacklist == null)
                mData.Blacklist = new List<string>();
            if (mData.MarketListings == null)
                mData.MarketListings = new Dictionary<uint, AMItem>();
            if (mData.mode == null)
                mData.mode = new Dictionary<ulong, bool>();
            if (mData.names == null)
                mData.names = new Dictionary<ulong, string>();
            if (mData.OutstandingMessages == null)
                mData.OutstandingMessages = new Dictionary<ulong, List<Unsent>>();
            if (mData.TradeBox == null)
                mData.TradeBox = new Dictionary<ulong, XYZ>();
            initialized = true;
        }

        #endregion Absolut Market Data Management

        #region Config

        private ConfigData configData;

        private class ConfigData
        {
            public string MarketMenuKeyBinding { get; set; }
            public bool UseUniqueNames { get; set; }
            public bool ServerRewards { get; set; }
            public int InfoInterval { get; set; }
            public bool Economics { get; set; }
            public bool ForceSimpleUI { get; set; }
            public Dictionary<string, string> CustomBackgrounds { get; set; }
            public Dictionary<Category, List<string>> Categorization { get; set; }
            public List<ulong> BanSteamIDs { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            if (configData == null)
                LoadDefaultConfig();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                //MarketMenuKeyBinding = "b",
                UseUniqueNames = false,
                InfoInterval = 15,
                ServerRewards = false,
                Economics = false,
                ForceSimpleUI = false,
                BanSteamIDs = new List<ulong>(),
                CustomBackgrounds = new Dictionary<string, string>
        {
            { "NEVERDELETE", "http://www.intrawallpaper.com/static/images/r4RtXBr.png" },
            { "default2", "http://www.intrawallpaper.com/static/images/background-wallpapers-32_NLplhCS.jpg" },
            { "default3", "http://www.intrawallpaper.com/static/images/Light-Wood-Background-Wallpaper_JHG6qot.jpg" },
            { "default4", "http://www.intrawallpaper.com/static/images/White-Background-BD1.png" },
            { "default5", "http://www.intrawallpaper.com/static/images/Red_Background_05.jpg" },
            { "default6", "http://www.intrawallpaper.com/static/images/White-Background-BD1.png" },
            { "default7", "http://www.intrawallpaper.com/static/images/abstract-hd-wallpapers-1080p_gDn0G81.jpg" },
            { "default8", "http://www.intrawallpaper.com/static/images/Background-HD-High-Quality-C23.jpg" },
            { "default10", "http://www.intrawallpaper.com/static/images/wood_background_hd_picture_3_169844.jpg" },
            { "default11", "http://www.intrawallpaper.com/static/images/518079-background-hd.jpg" },
            { "default12", "http://www.intrawallpaper.com/static/images/special_flashy_stars_background_03_hd_pictures_170805.jpg" },
            { "default13", "http://www.intrawallpaper.com/static/images/maxresdefault_jKFJl8g.jpg" },
            { "default14", "http://www.intrawallpaper.com/static/images/maxresdefault15.jpg" },
                },
                Categorization = Categorization,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion Config

        #region Messages

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Absolut Market: " },
            {"AMInfo", "This server is running Absolut Market. Press '{0}' to access the Market Menu and to set a Trade Box. Happy Trading!"},
            {"NoTradeBox", "Error finding target Trade Box!" },
            {"TradeBoxDestroyed", "Your Trade Box has been destroyed!" },
            {"TradeBoxNoLongerValid", "Your Trade Box is no longer valid. All items that were listed in that box have been removed from the market." },
            {"TradeBoxInvalid", "TradeBox not found" },
            {"TradeBoxEmpty", "Your Trade Box is empty... place items in it to sell them" },
            {"TradeBoxEmptyNoSR", "Your Trade Box is empty and you have 0 Server Rewards Points...Load Items or Get Points to continue" },
            {"TradeBoxFull", "Your Trade Box is full! Clear room first." },
            {"NewTradeBox", "You have set a new Trade Box" },
            {"Yes", "Yes?" },
            {"No", "No?" },
            {"SetName", "Please Provide a Name for this Item: {0}" },
            {"SetpriceItemshortname", "Please Select an Item you want in return for {0}"  },
            {"SetPriceAmount", "Please type the amount of {0} required to buy the {1}" },
            {"ItemDetails", "You are listing: {0}: {1}\n          For {2} {3}" },
            {"ItemName", "" },
            {"SelectItemToSell", "Please select an Item from your Trade Box to sell..." },
            {"ListItem", "List Item?" },
            {"CancelListing", "Cancel Listing?" },
            {"ItemListingCanceled", "You have successfully canceled item listing!" },
            {"NewItemListed", "You have successfully listed {0}!" },
            {"NewMoneyListed", "You have successfully listed {1} {0}" },
            {"ItemNotInBox", "It appears the item you are trying to list is no longer in the Trade Box. Listing Canceled..." },
            {"NotEnoughPurchaseItem", "You do not have enough {0}. You need {1}!" },
            {"TradeBoxMode", "You are now in Trade Box Selection Mode. Place a large or small wooden box at anytime to make it your Trade Box. Type quit at anytime to leave this mode." },
            {"ExitedBoxMode", "You have successfully exited Trade Box Selection Mode." },
            {"TradeBoxAssignment", "Set\nTrade Box" },
            {"ItemBeingSold","For Sale" },
            {"Purchasecost", "Cost" },
            {"NewItemInfo", "Listing Item Details" },
            {"removelisting", "Remove?" },
            {"YourTradeBoxFullBuying","Your Trade Box is Full!"},
            {"SellerTradeBoxFullBuying", "Seller's Trade Box is Full!" },
            {"YourNoTradeBoxBuying","You do not have a Trade Box!" },
            {"SellerNoTradeBoxBuying","Seller does not have a Trade Box!" },
            {"NewPurchase", "You have successfully purchased {1} {0}" },
            {"NewSale", "You have successfully sold {1} {0}" },
            {"Next", "Next" },
            {"Back", "Back" },
            {"First", "First" },
            {"Last", "Last" },
            {"Close", "Close"},
            {"Quit", "Quit"},
            {"PurchaseConfirmation", "Would you like to purchase:\n({1}) {0}?" },
            {"ItemCondition", "Item Condition: {0}%" },
            {"ConditionWarning", "Some items do not have a condition and will reflect as 0" },
            {"ItemAlreadyListed", "This item already appears to be listed!" },
            {"ItemRemoved", "{0} has been removed from the Absolut Market because {1}" },
            {"FromBox", "it was removed from the Trade Box!" },
            {"ItemCondChange", "the condition of the item has changed." },
            {"ItemQuantityChange", "the quantity of the item has changed." },
            {"TradeBoxChanged", "you have set a new Trade Box." },
            {"ItemGoneChange", "the item is not in the Seller's box." },
            {"SelectItemToBlacklist", "Select an item to Blacklist..." },
            {"SelectItemToUnBlacklist", "Select an item to Remove from Blacklist..." },
            {"NoBlackListedItems", "There are no items currently Blacklisted" },
            {"AdminPanel", "Admin Menu" },
            {"BlackListingADD", "Add\nBacklist Item" },
            {"BlackListingREMOVE", "Remove\nBacklist Item" },
            {"ClearMarket", "Clear Market" },
            {"ChangeTheme", "Change Theme" },
            {"SelectTheme", "Select a Theme" },
            {"Amount", "Amount: {0}" },
            {"Name", "Name: {0}" },
            {"NotEnoughECOPoints", "You do not have enough Economics!" },
            {"NotEnoughSRPoints", "You do not have enough ServerReward Points!" },
            {"ImgReload", "Images have been wiped and reloaded!" },
            {"ImgRefresh", "Images have been refreshed !" },
            {"BckAdded", "{0} Background Images have been added!" },
            {"Seller", "         Seller\n{0}" },
            {"InExchange", "In Exchange\nFor" },
            {"SellerRemoval", "you removed it." },
            {"AllItemsAreBL", "All the items in your box are BlackListed{0}{1}" },
            {"SRInclusion", " and you have 0 Server Rewards Points" },
            {"ECOInclusion", " and you have 0 Economics" },
            {"AllItemsAreListed", "All the items in your box are already listed.{0}{1} Add more and try again." },
            {"SRInclusionListed", " You also have 0 Server Rewards Points or they are all listed." },
            {"ECOInclusionListed", " You also have 0 Economics or they are all listed." },
            {"ChangeMode", "Change Mode" },
            {"MarketCleared", "Market Cleared of {0} listings" },
            {"NotyourBox", "This box was not built by you. Unable to set it as your new Trade Box." },
            {"BanFromMarket", "You are not allowed to use the Market. Speak with an admin." }
        };

        #endregion Messages
    }
}

// --- End of file: AbsolutMarket.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/angry-promotion ---
// --- Original File Path: A/AngryPromotion/AngryPromotion.cs ---

ï»¿using System;
using System.Linq;
using System.Collections.Generic;

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("AngryPromotion", "Tori1157", "1.1.1", ResourceId = 2686)]
    [Description("Automatically add users to a group if they have a specific word/phrase in their steam name.")]

    class AngryPromotion : CovalencePlugin
    {
        #region Fields

        private bool Changed;
        private bool printToConsole;
        private bool informPlayer;
        private bool groupAdding;
        private bool useGroupInfo;
        private bool removeReward;
        private bool useThanksMessage;

        private string messagePrefix;
        private string messageColor;
        private string promotionKey;
        private string groupKey;
        private string groupInformation;
        private string thanksMessage;

        private float messageDelay;

        private const string AdminPermission = "angrypromotion.admin";

        #endregion

        #region Loaded

        private void Init()
        {
            permission.RegisterPermission(AdminPermission, this);

            LoadVariables();
            LoadData(ref promoters);
            SaveData(promoters);

            if (!permission.GroupExists(groupKey))
            {
                PrintWarning(lang.GetMessage("Group NonExistent", this).Replace("{group}", groupKey));
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            /// -- MESSAGING -- ///

            informPlayer = Convert.ToBoolean(GetConfig("Messaging Options", "Inform Player", true));
            messageColor = Convert.ToString(GetConfig("Messaging Options", "Message Color", "#ffa500"));
            messagePrefix = Convert.ToString(GetConfig("Messaging Options", "Message Prefix", "Angry Promotion"));
            printToConsole = Convert.ToBoolean(GetConfig("Messaging Options", "Print To Console", true));
            messageDelay = Convert.ToSingle(GetConfig("Messaging Options", "Chat Message Delay", 10));
            useThanksMessage = Convert.ToBoolean(GetConfig("Messaging Options", "Use Thanks Message", true));
            groupInformation = Convert.ToString(GetConfig("Messages", "Group Information", new List<string>
            {
                "As long as you have [#00ffff]{promotionkey}[/#] word/phrase in your name you will gain access to the items listed below, if you remove the phrase from your name you will lose access.\n",
                "//----------------------------//",
                "- [#ffa500]Remover Tool[/#]",
                "- [#ffa500]1.5% more SRP[/#]",
                "- [#008000]Colored Name[/#]",
                "//----------------------------//",
                "[#ff0000][i][+12]For more information contact an Administrator[/+][/i][/#]"
            }));
            thanksMessage = Convert.ToString(GetConfig("Messages", "Thanks Message", new List<string>
            {
                "[+18][#ffa500]Thank you {player}![/#][/+]\n",
                "As a thanks for having [#00ffff]{promotionkey}[/#] in your name, we're giving you access to [#00ffff]{groupkey}[/#] group.",
                "\nTo learn more about what this group gives, type [#ffa500]/promotion group.[/#]"
            }));


            /// -- OPTIONS -- ///

            groupKey = Convert.ToString(GetConfig("Options", "Group", "promoter"));
            groupAdding = Convert.ToBoolean(GetConfig("Options", "Group Adding", true));
            promotionKey = Convert.ToString(GetConfig("Options", "PromotionKey", "yourwebsite.com"));
            useGroupInfo = Convert.ToBoolean(GetConfig("Options", "Use Group Info", true));
            removeReward = Convert.ToBoolean(GetConfig("Options", "Toggle Phrase Check For Removal", true));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                /// -- ERROR -- ///

                ["No Permission"] = "[#add8e6]{player}[/#] you do not have permission to use the [#00ffff]{command}[/#] command.",

                ["SteamID Not Found Chat"] = "SteamID [#00ffff]{id}[/#] could not be found.",
                ["Player Not Found Chat"] = "Username [#00ffff]{player}[/#] could not be found.",
                ["Multiple Players Found"] = "Multiple users found!\n\n{matches}",

                ["Invalid Parameter Chat"] = "Parameter [#00ffff]{parameter}[/#] is invalid or written wrong.",
                ["Invalid Syntax Check"] = "Invalid Syntax!  |  /promotion check \"User Name\"",
                ["Invalid Syntax Remove"] ="Invalid Syntax!  |  /promotion remove \"User Name\"",

                ["Group NonExistent"] = "Group '{group}' does not exist! Therefor users will not get put into groups!",

                /// -- CONFIRM -- ///
                
                ["Player Added Group"] = "You have been added to the [#00ffff]{group}[/#] group.",
                ["Player Removed Group"] = "You have been removed from the [#00ffff]{group}[/#] group, since you removed [#00ffff]{promotionkey}[/#] from your name.",

                ["Admin Removed User"] = "You have successfully removed [#00ffff]{target}[/#] from [#00ffff]{group}[/#] group.",

                /// -- INFO -- ///

                ["Default Message Group"] = "By having [#00ffff]{promotionkey}[/#] in your name you will gain access to the [#00ffff]{group}[/#] group automatically when you join.\n\nTo learn more about what [#00ffff]{group}[/#] group gives access to, type the following into chat: [#ffa500]/promotion group[/#].",
                ["Default Message"] = "By having [#00ffff]{promotionkey}[/#] in your name you will gain access to the [#00ffff]{group}[/#] group automatically when you join.",

                ["Player Is Promoting"] = "[#00ffff]{player}[/#] is currently promoting your server.",
                ["Player Not Promoting"] = "[#00ffff]{player}[/#] is currently [#ff0000]not[/#] promoting your server.",

                ["Admin Help1"] = "- [#ffa500]/promotion check[/#] [i](Checks to see if user is promoting)[/i]\n- [#ffa500]/promotion help[/#] [i](Displays this message)[/i]\n- [#ffa500]/promotion group[/#] [i](Displays the information regarding the group)[/i]\n- [#ffa500]/promotion[/#] [i](Displays the information regarding the plugin)[/i]\n- [#ffa500]/promotion remove \"User Name\"[/#] [i](Removes player from promotion group)[/i]",
                ["Player Help"] = "- [#ffa500]/promotion help[/#] [i](Displays this message)[/i]\n- [#ffa500]/promotion group[/#] [i](Displays the information regarding the group)[/i]\n- [#ffa500]/promotion[/#] [i](Displays the information regarding the plugin)[/i]",

            }, this);
        }

        #endregion

        #region Commands

        [Command("promotion")]
        private void PromotionCommand(IPlayer player, string command, string[] args)
        {
            var HasPerm = (player.HasPermission(AdminPermission));

            #region Default

            if (args.Length == 0)
            {
                if (useGroupInfo == true)
                {
                    SendInfoMessage(player, lang.GetMessage("Default Message Group", this, player.Id).Replace("{promotionkey}", promotionKey).Replace("{group}", groupKey));
                    return;
                }

                SendInfoMessage(player, lang.GetMessage("Default Message", this, player.Id).Replace("{promotionkey}", promotionKey).Replace("{group}", groupKey));
                return;
            }

            #endregion

            var CommandArg = args[0].ToLower();
            var CommandInfo = (command + " " + args[0]);
            var CaseArgs = (new List<object>
            {
                "check", "help", "group", "remove"
            });

            if (!CaseArgs.Contains(CommandArg))
            {
                SendChatMessage(player, lang.GetMessage("Invalid Parameter Chat", this, player.Id).Replace("{parameter}", CommandArg));
                return;
            }

            switch (CommandArg)
            {
                #region Group
                case "group":

                    string message = "";
                    foreach (var messageText in Config["Messages", "Group Information"] as List<object>)
                        message = message + messageText + "\n";

                    SendInfoMessage(player, message.Replace("{promotionkey}", promotionKey));

                return;
                #endregion

                #region Check
                case "check":

                    if (!HasPerm && !player.IsServer)
                    {
                        SendChatMessage(player, lang.GetMessage("No Permission", this, player.Id).Replace("{player}", player.Name).Replace("{command}", CommandInfo));
                        return;
                    }

                    if (args.Length == 1)
                    {
                        SendChatMessage(player, lang.GetMessage("Invalid Syntax Check", this, player.Id));
                        return;
                    }

                    IPlayer target;
                    target = GetPlayer(args[1], player);

                    if (target == null) return;

                    if (PromotingInfo.IsPromoting(target))
                    {
                        SendChatMessage(player, lang.GetMessage("Player Is Promoting", this, player.Id).Replace("{player}", target.Name));
                        return;
                    }

                    SendChatMessage(player, lang.GetMessage("Player Not Promoting", this, player.Id).Replace("{player}", target.Name));
                return;
                #endregion

                #region Help
                case "help":

                    if (HasPerm)
                    {
                        SendInfoMessage(player, lang.GetMessage("Admin Help1", this, player.Id));
                        return;
                    }

                    SendInfoMessage(player, lang.GetMessage("Player Help", this, player.Id));

                return;

                #endregion

                #region Remove
                case "remove":

                    if (!HasPerm && !player.IsServer)
                    {
                        SendChatMessage(player, lang.GetMessage("No Permission", this, player.Id).Replace("{player}", player.Name).Replace("{command}", CommandInfo));
                        return;
                    }

                    if (args.Length == 1)
                    {
                        SendChatMessage(player, lang.GetMessage("Invalid Syntax Remove", this, player.Id));
                        return;
                    }

                    IPlayer Target;
                    Target = GetPlayer(args[1], player);

                    if (Target == null) return;

                    if (!PromotingInfo.IsPromoting(Target))
                    {
                        SendChatMessage(player, lang.GetMessage("Player Not Promoting", this, player.Id).Replace("{player}", Target.Name));
                        return;
                    }

                    permission.RemoveUserGroup(Target.Id, groupKey);
                    promoters.Remove(Target.Id);
                    SaveData(promoters);

                    SendChatMessage(player, lang.GetMessage("Admin Removed User", this, player.Id).Replace("{target}", Target.Name).Replace("{group}", groupKey));
                return;
                #endregion
            }
        }

        #endregion

        #region Functions

        private void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            if (!permission.GroupExists(groupKey)) return;

            var PlayerName = player.Name.ToLower();
            var PlayerNameChecker = PlayerName.Contains(promotionKey.ToLower());
            var PlayerIsPromoting = PromotingInfo.IsPromoting(player);

            if (groupAdding == true)
            {
                // Checks to see if player has already been given permissions
                if (!PlayerIsPromoting)
                {
                    if (PlayerNameChecker && !PlayerIsPromoting)
                    {
                        /// ADDING THEM SINCE THEY HAVE KEY
                        
                        permission.AddUserGroup(player.Id, groupKey);
                        promoters[player.Id] = new PromotingInfo();
                        SaveData(promoters);

                        if (informPlayer == true)
                        {
                            string message = "";
                            foreach (var thanksText in Config["Messages", "Thanks Message"] as List<object>) // TODO: Clean this mess up
                                message = message + thanksText + "\n";

                            timer.Once(messageDelay, () =>
                            {
                                if (useThanksMessage == true)
                                {
                                    SendThanksMessage(player, message.Replace("{promotionkey}", promotionKey).Replace("{player}", player.Name).Replace("{groupkey}", groupKey));
                                    return;
                                }

                                SendChatMessage(player, lang.GetMessage("Player Added Group", this, player.Id).Replace("{group}", groupKey));
                            });
                        }

                        if (printToConsole == true)
                        {
                            Puts(lang.GetMessage("Player Added Group", this, player.Id).Replace("{player}", player.Name).Replace("{group}", groupKey));
                        }

                        return;
                    }
                }

                if (removeReward == true)
                {
                    if (!PlayerNameChecker && PlayerIsPromoting)
                    {
                        /// REMOVING SINCE THEY DO NOT HAVE KEY

                        permission.RemoveUserGroup(player.Id, groupKey);
                        promoters.Remove(player.Id);
                        SaveData(promoters);

                        if (informPlayer == true)
                        {
                            timer.Once(messageDelay, () =>
                            {
                                SendChatMessage(player, lang.GetMessage("Player Removed Group", this, player.Id).Replace("{group}", groupKey).Replace("{promotionkey}", promotionKey));
                            });
                        }

                        if (printToConsole == true)
                        {
                            Puts(lang.GetMessage("Player Removed Group", this, player.Id).Replace("{group}", groupKey).Replace("{promotionkey}", promotionKey));
                        }

                        return;
                    }
                }
            }
        }

        #endregion

        #region Helpers / Usefull Functions

        #region Config
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;

            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion

        #region Player Finding
        private IPlayer GetPlayer(string nameOrID, IPlayer player)
        {
            if (nameOrID.IsSteamId() == true)
            {
                IPlayer result = players.All.ToList().Find((p) => p.Id == nameOrID);

                if (result == null)
                    SendChatMessage(player, lang.GetMessage("SteamID Not Found Chat", this, player.Id).Replace("{id}", nameOrID));

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (current.Name.ToLower() == nameOrID.ToLower())
                    return current;

                if (current.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                        SendChatMessage(player, lang.GetMessage("Player Not Found Chat", this, player.Id).Replace("{player}", nameOrID));
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    SendChatMessage(player, lang.GetMessage("Multiple Players Found Chat", this, player.Id).Replace("{matches}", string.Join(", ", names)));
                    break;
            }
            return null;
        }

        private bool IsParseableTo<T>(object s)
        {
            try
            {
                var parsed = (T)Convert.ChangeType(s, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }
        #endregion

        #region Data
        private static Dictionary<string, PromotingInfo> promoters = new Dictionary<string, PromotingInfo>();

        public class PromotingInfo
        {
            public static bool IsPromoting(IPlayer player) => promoters.ContainsKey(player.Id);

            public PromotingInfo() { }
        }

        private void LoadData<T>(ref T data, string filename = null) => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? Name);
        private void SaveData<T>(T data, string filename = null) => Core.Interface.Oxide.DataFileSystem.WriteObject(filename ?? Name, data);

        #endregion

        #endregion

        #region Messaging

        private void SendChatMessage(IPlayer player, string message)
        {
            player.Reply(message, covalence.FormatText("[" + messageColor + "]" + messagePrefix + "[/#]:"));
        }

        private void SendInfoMessage(IPlayer player, string message)
        {
            player.Reply(message, covalence.FormatText("[+18][" + messageColor + "]" + messagePrefix + "[/#][/+]\n\n"));
        }

        private void SendThanksMessage(IPlayer player, string message)
        {
            player.Reply(message);
        }

        #endregion
    }
}

// --- End of file: AngryPromotion.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-decay ---
// --- Original File Path: A/AutoDecay/AutoDecay.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Decay", "Hougan/Arainrr", "1.3.1")]
    [Description("Auto damage to objects, that are not in building zone")]
    public class AutoDecay : RustPlugin
    {
        #region Fields

        private const string PERMISSION_IGNORE = "autodecay.ignore";
        private readonly Hash<ulong, float> notifyPlayers = new Hash<ulong, float>();
        private readonly Dictionary<ulong, DecayController> decayControllers = new Dictionary<ulong, DecayController>();

        private readonly List<string> defaultDisabled = new List<string>
        {
            "small_stash_deployed",
            "sleepingbag_leather_deployed",
        };

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_IGNORE, this);
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            UpdateConfig(_config.entityS.Count <= 0);
            foreach (var baseNetworkable in BaseNetworkable.serverEntities.OfType<BaseCombatEntity>())
            {
                if (baseNetworkable != null)
                    CreateDecayController(baseNetworkable);
            }

            foreach (var entry in _config.entityS)
            {
                if (!storedData.entityShortPrefabNames.Contains(entry.Key))
                    PrintError($"\"{entry.Key}\" is an invalid combat entity short prefab name, Please get them in the data file");
            }
        }

        private void Unload()
        {
            foreach (var decayController in decayControllers.Values)
                decayController?.Destroy();

            _config = null;
        }

        private void OnEntitySpawned(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            var buildingPrivlidge = baseCombatEntity as BuildingPrivlidge;
            if (buildingPrivlidge != null)
                HandleCupboard(buildingPrivlidge, true);
            var player = baseCombatEntity.OwnerID.IsSteamId() ? BasePlayer.FindByID(baseCombatEntity.OwnerID) : null;
            CreateDecayController(baseCombatEntity, player, false);
        }

        //private void OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info) => OnEntityKill(baseCombatEntity);

        private void OnEntityKill(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            var buildingPrivlidge = baseCombatEntity as BuildingPrivlidge;
            if (buildingPrivlidge != null)
                HandleCupboard(buildingPrivlidge, false);

            DecayController decayController;
            if (decayControllers.TryGetValue(baseCombatEntity.net.ID.Value, out decayController))
            {
                decayController?.Destroy();
                decayControllers.Remove(baseCombatEntity.net.ID.Value);
            }
        }

        private void OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade)
        {
            if (buildingBlock == null || buildingBlock.net == null) return;
            var grade = buildingBlock.grade;
            NextTick(() =>
            {
                if (buildingBlock == null || buildingBlock.net == null) return;
                if (grade == buildingBlock.grade) return;
                var settings = GetBuildingBlockSettings(buildingBlock);
                if (IsDecayEnabled(settings, buildingBlock))
                {
                    DecayController decayController;
                    if (!decayControllers.TryGetValue(buildingBlock.net.ID.Value, out decayController))
                    {
                        decayController = new DecayController(buildingBlock, settings, false);
                        decayControllers.Add(buildingBlock.net.ID.Value, decayController);
                    }
                    else
                        decayController?.OnBuildingUpgrade(settings);
                }
                else
                {
                    DecayController decayController;
                    if (decayControllers.TryGetValue(buildingBlock.net.ID.Value, out decayController))
                    {
                        decayController?.Destroy();
                        decayControllers.Remove(buildingBlock.net.ID.Value);
                    }
                }
            });
        }

        #endregion Oxide Hooks

        #region Methods

        private void HandleCupboard(BuildingPrivlidge buildingPrivlidge, bool spawned)
        {
            var decayEntities = buildingPrivlidge?.GetBuilding()?.decayEntities;
            if (decayEntities != null)
            {
                //Only check the same building
                foreach (var decayEntity in decayEntities)
                {
                    if (decayEntity == null || decayEntity.net == null) continue;
                    if (decayEntity == buildingPrivlidge) continue;
                    DecayController decayController;
                    if (decayControllers.TryGetValue(decayEntity.net.ID.Value, out decayController))
                    {
                        if (spawned) decayController?.OnCupboardPlaced();
                        else decayController?.OnCupboardDestroyed();
                    }
                }
            }
        }

        private void UpdateConfig(bool newConfig)
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var prefabName = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (string.IsNullOrEmpty(prefabName)) continue;
                var baseCombatEntity = GameManager.server.FindPrefab(prefabName)?.GetComponent<BaseCombatEntity>();
                if (baseCombatEntity == null || string.IsNullOrEmpty(baseCombatEntity.ShortPrefabName)) continue;
                if (_config.entityS.ContainsKey(baseCombatEntity.ShortPrefabName)) continue;

                _config.entityS.Add(baseCombatEntity.ShortPrefabName, new DecaySettings
                {
                    enabled = newConfig && !(itemDefinition.category == ItemCategory.Food || defaultDisabled.Contains(baseCombatEntity.ShortPrefabName))
                });
            }
            UpdateData(true, _config.buildingBlockS.Count <= 0);
            SaveConfig();
        }

        private void UpdateData(bool updateConfig = false, bool newConfig = false)
        {
            var grades = new[] { BuildingGrade.Enum.Twigs, BuildingGrade.Enum.Wood, BuildingGrade.Enum.Stone, BuildingGrade.Enum.Metal, BuildingGrade.Enum.TopTier };

            storedData.entityShortPrefabNames.Clear();
            foreach (var prefab in GameManifest.Current.entities)
            {
                var baseCombatEntity = GameManager.server.FindPrefab(prefab)?.GetComponent<BaseCombatEntity>();
                if (baseCombatEntity == null || string.IsNullOrEmpty(baseCombatEntity.ShortPrefabName)) continue;
                storedData.entityShortPrefabNames.Add(baseCombatEntity.ShortPrefabName);
                if (updateConfig)
                {
                    if (baseCombatEntity is BaseVehicle)
                    {
                        if (!_config.entityS.ContainsKey(baseCombatEntity.ShortPrefabName))
                        {
                            _config.entityS.Add(baseCombatEntity.ShortPrefabName, new DecaySettings { enabled = newConfig });
                        }
                    }

                    if (baseCombatEntity is BuildingBlock)
                    {
                        _config.entityS.Remove(baseCombatEntity.ShortPrefabName);
                        Dictionary<BuildingGrade.Enum, DecaySettings> settings;
                        if (!_config.buildingBlockS.TryGetValue(baseCombatEntity.ShortPrefabName, out settings))
                        {
                            settings = new Dictionary<BuildingGrade.Enum, DecaySettings>();
                            _config.buildingBlockS.Add(baseCombatEntity.ShortPrefabName, settings);
                        }

                        foreach (var grade in grades)
                        {
                            if (!settings.ContainsKey(grade))
                            {
                                settings.Add(grade, new DecaySettings { enabled = newConfig });
                            }
                        }
                    }
                }
            }
            SaveData();
        }

        private void CreateDecayController(BaseCombatEntity baseCombatEntity, BasePlayer player = null, bool init = true)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            if (baseCombatEntity.OwnerID.IsSteamId() && permission.UserHasPermission(baseCombatEntity.OwnerID.ToString(), PERMISSION_IGNORE)) return;
            var decayEntityS = GetDecayEntitySettings(baseCombatEntity);
            if (IsDecayEnabled(decayEntityS, baseCombatEntity))
            {
                if (!decayControllers.ContainsKey(baseCombatEntity.net.ID.Value))
                {
                    decayControllers.Add(baseCombatEntity.net.ID.Value, new DecayController(baseCombatEntity, decayEntityS, init));
                    if (_config.notifyPlayer && player != null && baseCombatEntity.GetBuildingPrivilege() == null)
                        SendMessage(player, decayEntityS.delayTime + decayEntityS.destroyTime);
                }
            }
        }

        private void SendMessage(BasePlayer player, float time)
        {
            float value;
            if (notifyPlayers.TryGetValue(player.userID, out value) && Time.realtimeSinceStartup - value <= _config.notifyInterval) return;
            notifyPlayers[player.userID] = Time.realtimeSinceStartup;
            Print(player, Lang("DESTROY", player.UserIDString, TimeSpan.FromSeconds(time).ToShortString()));
        }

        private static DecaySettings GetDecayEntitySettings(BaseCombatEntity baseCombatEntity)
        {
            var buildingBlock = baseCombatEntity as BuildingBlock;
            if (buildingBlock != null)
            {
                return GetBuildingBlockSettings(buildingBlock);
            }
            DecaySettings decaySettings;
            return _config.entityS.TryGetValue(baseCombatEntity.ShortPrefabName, out decaySettings) ? decaySettings : null;
        }

        private static DecaySettings GetBuildingBlockSettings(BuildingBlock buildingBlock)
        {
            Dictionary<BuildingGrade.Enum, DecaySettings> buildingSettings;
            if (_config.buildingBlockS.TryGetValue(buildingBlock.ShortPrefabName, out buildingSettings))
            {
                DecaySettings settings;
                if (buildingSettings.TryGetValue(buildingBlock.grade, out settings))
                {
                    return settings;
                }
            }
            return null;
        }

        private static bool IsDecayEnabled(DecaySettings decaySettings, BaseEntity entity)
        {
            return decaySettings != null && decaySettings.enabled && (!decaySettings.onlyOwned || entity.OwnerID.IsSteamId());
        }

        #endregion Methods

        #region DestroyControl

        private class DecayController
        {
            private enum State
            {
                None,
                Delaying,
                Decaying,
            }

            private BaseCombatEntity entity;
            private DecaySettings decaySettings;

            private State state;
            private float tickDamage;
            private bool isCupboard;

            public DecayController(BaseCombatEntity entity, DecaySettings decaySettings, bool init)
            {
                this.entity = entity;
                this.decaySettings = decaySettings;
                isCupboard = entity is BuildingPrivlidge;
                entity.InvokeRepeating(CheckBuildingPrivilege, init ? UnityEngine.Random.Range(0f, 60f) : 1f, _config.cupboardCheckTime);
            }

            private void CheckBuildingPrivilege()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                if (isCupboard ? OnFoundation() : HasBuildingPrivilege())
                {
                    StopDamage();
                    return;
                }
                StartDelay();
            }

            private bool HasBuildingPrivilege()
            {
                var buildingPrivlidge = entity.GetBuildingPrivilege();
                if (buildingPrivlidge == null) return false;
                if (_config.checkEmptyCupboard)
                    return buildingPrivlidge.GetProtectedMinutes() > 0f;
   
                return true;

            }

            private bool OnFoundation()
            {
                RaycastHit raycastHit;
                return Physics.Raycast(entity.transform.position + Vector3.up * 0.1f, Vector3.down, out raycastHit, 0.11f, Rust.Layers.Mask.Construction) && raycastHit.GetEntity() is BuildingBlock;
            }

            private void StartDelay()
            {
                if (state != State.None) return;
                state = State.Delaying;
                entity.Invoke(StartDamage, decaySettings.delayTime);
            }

            private void StartDamage()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                state = State.Decaying;
                entity.InvokeRepeating(DoDamage, 600f, decaySettings.destroyTime / decaySettings.tickRate);
            }

            private void StopDamage()
            {
                switch (state)
                {
                    case State.Delaying:
                        state = State.None;
                        entity.CancelInvoke(StartDamage);
                        break;

                    case State.Decaying:
                        state = State.None;
                        entity.CancelInvoke(DoDamage);
                        break;
                }
            }

            private void ResetDamage()
            {
                StopDamage();
                StartDamage();
            }

            private void DoDamage()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                var currentTickDamage = entity.MaxHealth() / decaySettings.tickRate;
                if (tickDamage != currentTickDamage)
                    tickDamage = currentTickDamage;

                entity.Hurt(tickDamage, Rust.DamageType.Decay);
            }

            public void OnBuildingUpgrade(DecaySettings settings)
            {
                decaySettings = settings;
                StopDamage();
                CheckBuildingPrivilege();
            }

            public void OnCupboardPlaced()
            {
                StopDamage();
            }

            public void OnCupboardDestroyed()
            {
                StartDelay();
            }

            public void Destroy()
            {
                if (entity == null) return;
                entity.CancelInvoke(DoDamage);
                entity.CancelInvoke(StartDamage);
                entity.CancelInvoke(CheckBuildingPrivilege);
            }
        }

        #endregion DestroyControl

        #region ConfigurationFile

        private static ConfigData _config;

        private class ConfigData
        {
            [JsonProperty("Check Cupboard Interval (Seconds)")]
            public float cupboardCheckTime = 300f;

            [JsonProperty("Not Protected Cupboard = No Cupboard")]
            public bool checkEmptyCupboard;

            [JsonProperty("Notify Player That His Object Will Be Removed")]
            public bool notifyPlayer = true;

            [JsonProperty("Notify Interval")]
            public float notifyInterval = 10f;

            [JsonProperty("Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty("Building Block Settings")]
            public Dictionary<string, Dictionary<BuildingGrade.Enum, DecaySettings>> buildingBlockS = new Dictionary<string, Dictionary<BuildingGrade.Enum, DecaySettings>>();

            [JsonProperty("Other Entity Settings")]
            public Dictionary<string, DecaySettings> entityS = new Dictionary<string, DecaySettings>();

            [JsonProperty("Version")]
            public VersionNumber version;
        }

        public class ChatSettings
        {
            [JsonProperty("Chat Prefix")]
            public string prefix = "<color=#00FFFF>[AutoDecay]</color>: ";

            [JsonProperty("Chat SteamID Icon")]
            public ulong steamIDIcon = 0;
        }

        private class DecaySettings
        {
            [JsonProperty("Enabled")]
            public bool enabled;

            [JsonProperty("Only Used For Player's Entity")]
            public bool onlyOwned = true;

            [JsonProperty("Delay Time (Seconds)")]
            public float delayTime = 600f;

            [JsonProperty("Destroy Time (Seconds)")]
            public float destroyTime = 3600f;

            [JsonProperty("Tick Rate (Damage Per Tick = Max Health / This)")]
            public float tickRate = 10f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _config = new ConfigData();
            _config.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private void UpdateConfigValues()
        {
            if (_config.version < Version)
            {
                if (_config.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat prefix") && GetConfigValue(out prefixColor, "Chat prefix color"))
                    {
                        _config.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }

                    ulong steamID;
                    if (GetConfigValue(out steamID, "Chat steamID icon"))
                    {
                        _config.chatS.steamIDIcon = steamID;
                    }
                }
                if (_config.version <= new VersionNumber(1, 2, 10))
                {
                    bool enabled;
                    if (GetConfigValue(out enabled, "Check empty cupboard"))
                    {
                        _config.checkEmptyCupboard = enabled;
                    }
                    if (GetConfigValue(out enabled, "Notify player, that his object will be removed"))
                    {
                        _config.notifyPlayer = enabled;
                    }

                    float time;
                    if (GetConfigValue(out time, "Check cupboard time (seconds)"))
                    {
                        _config.cupboardCheckTime = time;
                    }
                    if (GetConfigValue(out time, "Notify player interval"))
                    {
                        _config.notifyInterval = time;
                    }

                    Dictionary<string, object> decayList;
                    if (GetConfigValue(out decayList, "Decay entity list"))
                    {
                        foreach (var entry in decayList)
                        {
                            if (!_config.entityS.ContainsKey(entry.Key))
                            {
                                var jToken = JToken.FromObject(entry.Value);
                                _config.entityS.Add(entry.Key, new DecaySettings
                                {
                                    enabled = jToken["Enabled destroy"].ToObject<bool>(),
                                    onlyOwned = jToken["Check if it is a player's entity"].ToObject<bool>(),
                                    delayTime = jToken["Delay destroy time (seconds)"].ToObject<float>(),
                                    destroyTime = jToken["Tick rate (Damage per tick = max health / this)"].ToObject<float>(),
                                    tickRate = jToken["Destroy time (seconds)"].ToObject<float>(),
                                });
                            }
                        }
                    }
                }
                _config.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue != null)
            {
                if (configValue is T)
                {
                    value = (T)configValue;
                    return true;
                }
                try
                {
                    value = Config.ConvertValue<T>(configValue);
                    return true;
                }
                catch (Exception ex)
                {
                    PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
                }
            }

            value = default(T);
            return false;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            [JsonProperty("List of short prefab names for all combat entities")]
            public HashSet<string> entityShortPrefabNames = new HashSet<string>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            finally
            {
                if (storedData == null)
                {
                    storedData = new StoredData();
                    UpdateData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, _config.chatS.prefix, _config.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DESTROY"] = "If you do not install the cupboard, the object will <color=#F4D142>be deleted</color> after {0}."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DESTROY"] = "å¦ææ¨ä¸ç´ä¸æ¾ç½®é¢å°æï¼è¯¥å®ä½å°å¨ {0} å<color=#F4D142>è¢«å é¤</color>"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoDecay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/idle-manager ---
// --- Original File Path: A/AFK/AFK.cs ---

ï»¿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("AFK", "Wulf/lukespragg", "1.1.5", ResourceId = 1922)]
    [Description("Kicks players that are AFK (away from keyboard) for too long")]

    class AFK : CovalencePlugin
    {
        // Do NOT edit this file, instead edit AFK.json in oxide/config and AFK.en.json in the oxide/lang directory,
        // or create a new language file for another language using the 'en' file as a default

        #region Initialization

        const string permExcluded = "afk.excluded";

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permExcluded, this);
        }

        void OnServerInitialized()
        {
            foreach (var player in players.Connected) AfkCheck(player);
        }

        #endregion

        #region Configuration

        int afkLimitMinutes;
        bool kickAfkPlayers;
        //bool warnBeforeKick;

        protected override void LoadDefaultConfig()
        {
            Config["AfkLimitMinutes"] = afkLimitMinutes = GetConfig("AfkLimitMinutes", 10);
            Config["KickAfkPlayers"] = kickAfkPlayers = GetConfig("KickAfkPlayers", true);
            //Config["WarnBeforeKick"] = warnBeforeKick = GetConfig("WarnBeforeKick", true);
            SaveConfig();
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["KickedForAfk"] = "You were kicked for being AFK for {0} minutes",
                //["NoLongerAfk"] = "You are no longer AFK",
                //["YouWentAfk"] = "You went AFK"
            }, this);
        }

        #endregion

        #region AFK Checking

        void OnUserConnected(IPlayer player) => AfkCheck(player);

        readonly Hash<string, GenericPosition> lastPosition = new Hash<string, GenericPosition>();
        readonly Dictionary<string, Timer> afkTimer = new Dictionary<string, Timer>();

        void AfkCheck(IPlayer player)
        {
            if (HasPermission(player.Id, permExcluded)) return;

            ResetPlayer(player.Id);
            lastPosition[player.Id] = player.Position();

            afkTimer.Add(player.Id, timer.Every(afkLimitMinutes * 60, () =>
            {
                if (!IsPlayerAfk(player)) return;

                //player.Message(Lang("YouWentAfk", player.Id));

                if (kickAfkPlayers)
                {
                    // TODO: Send timed message/warning to player before kick

                    player.Kick(Lang("KickedForAfk", player.Id, afkLimitMinutes));
                }
            }));
        }

        /// <summary>
        /// Returns if a player is currently AFK based on current and last checked position
        /// </summary>
        /// <param name="player"></param>
        /// <returns></returns>
        public bool IsPlayerAfk(IPlayer player)
        {
            var last = lastPosition[player.Id];
            var current = player.Position();

            #if DEBUG
            PrintWarning($"Last position: {last}");
            PrintWarning($"Current position: {current}");
            PrintWarning($"Positions equal: {last.X.Equals(current.X)}");
            #endif

            if (last.X.Equals(current.X)) return true;
            lastPosition[player.Id] = current;

            return false;
        }

        void OnUserDisconnected(IPlayer player) => ResetPlayer(player.Id);

        void ResetPlayer(string id)
        {
            if (afkTimer.ContainsKey(id))
            {
                afkTimer[id].Destroy();
                afkTimer.Remove(id);
            }
            if (lastPosition.ContainsKey(id)) lastPosition.Remove(id);
        }

        void Unload()
        {
            foreach (var player in players.Connected) ResetPlayer(player.Id);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion
    }
}

// --- End of file: AFK.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-bandit ---
// --- Original File Path: A/AntiBandit/AntiBandit.cs ---

ï»¿using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Anti Bandit", "Alphawar", "0.9.3")]
    [Description("Designed to assist servers with RDM (designed for RPG servers)")]
    class AntiBandit : RustPlugin
    {
        [PluginReference]
        readonly Plugin RustIOFriendListAPI;

        private List<Timer> tTimers = new List<Timer>();
        private Hash<ulong, double> PlayerCooldownList = new Hash<ulong, double>();
        private List<Vector3> ExpiredPvPZonesList = new List<Vector3>();
        private List<Vector3> ExpiredRaidZonesList = new List<Vector3>();
        private Hash<Vector3, PVPData> PvPList = new Hash<Vector3, PVPData>();
        private Hash<Vector3, RaidDetails> raidZoneList = new Hash<Vector3, RaidDetails>();

        void OnPlayerConnected(BasePlayer _player)
        {
            if (_player == null) return;
            if (ReceivingSnapshotcheck(_player) == true) return;

            CreatePlayerCooldown(_player);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (hitinfo.damageTypes.Has(Rust.DamageType.Decay)) return;
            if (purgeMode == true) return;
            if (entity == null) return;

            if (((entity is BuildingBlock) || (entity is Door)) && (hitinfo.Initiator is BasePlayer))
            {
                BasePlayer attacker = (BasePlayer)hitinfo.Initiator;
                bool ownBuildingDamage = CheckBuildingOwner(attacker, entity);
                if (ownBuildingDamage == true) return;

                DebugMessage(2, "Entity Taken Damage, Entity is building");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        bool testVar1 = ZoneCooldownCheck("raid", entry.Key);
                        bool testVar2 = CheckEntityInZone(entity, entry.Key, RaidZone2);
                        bool testVar3 = CheckPlayerInZone(attacker, entry.Key, RaidZone2);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Entity & Player In Zone");
                            return;
                        }

                        DebugMessage(2, "Not all in zone");
                        DebugMessage(2, string.Format("Entity: {0}. Player: {1}", testVar2, testVar3));
                    }
                    DebugMessage(1, "Nullifying damage");
                    NullifyDamage(hitinfo);
                }
                else
                {
                    DebugMessage(2, "No raid zones are active");
                    DebugMessage(1, "Nullifying damage");
                    NullifyDamage(hitinfo);
                }
            }
            else if (entity is BasePlayer && hitinfo.Initiator is BasePlayer) // Checks that hitinfo is a player if so continues
            {
                if (purgeMode == true) return;

                DebugMessage(2, "Entity Taken Damage, Entity is player");
                BasePlayer victim = (BasePlayer)entity;
                BasePlayer attacker = (BasePlayer)hitinfo.Initiator;
                if (attacker == victim) return;

                DebugMessage(2, "saving Baseplayers");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        bool testVar1 = ZoneCooldownCheck("raid", entry.Key);
                        bool testVar2 = CheckPlayerInZone(attacker, entry.Key, RaidZone2);
                        bool testVar3 = CheckPlayerInZone(victim, entry.Key, RaidZone2);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Players In Zone");
                            return;
                        }

                        DebugMessage(2, "Not all test variables where met for raid zone");
                        DebugMessage(2, string.Format("testVar1: {0}, testVar1: {1}, testVar1: {2}", testVar1, testVar2, testVar3));
                    }
                    DebugMessage(1, "Players did not pass the Raid Zone Check");
                }
                else DebugMessage(2, "No Active Raid zones");
                if (PvPList.Count > 0)
                {
                    DebugMessage(2, "There are active PvP zones");
                    foreach (var entry in PvPList)
                    {
                        bool testVar1 = ZoneCooldownCheck("pvp", entry.Key);
                        bool testVar2 = CheckPlayerInZone(attacker, entry.Key, PVPZone3);
                        bool testVar3 = CheckPlayerInZone(victim, entry.Key, PVPZone3);
                        bool testVar4 = CheckPlayerRegistered(attacker, entry.Key);
                        bool testVar5 = CheckPlayerRegistered(victim, entry.Key);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true) && (testVar4 == true) && (testVar5 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Players In Zone, Players Registered");
                            return;
                        }

                        DebugMessage(2, "Not all test variables where met for pvp zone");
                        DebugMessage(2, string.Format("testVar1: {0}, testVar1: {1}, testVar1: {2}, testVar1: {3}, testVar1: {4}", testVar1, testVar2, testVar3, testVar4, testVar5));
                    }
                }
                else DebugMessage(2, "No Active PvP zones");
                DebugMessage(2, "Raid and PvP Zone conditions where not meet");
                DebugMessage(1, "Nullifying damage");
                NullifyDamage(hitinfo);
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if ((entity is BuildingBlock) || (entity is Door))
            {
                DebugMessage(2, "On Entity Death, Entity is building");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = CheckEntityInZone(entity, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            raidZoneList[entry.Key].RaidEndTimer = (GetTimeStamp() + RaidTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
            }
            else if (entity is BasePlayer)
            {
                BasePlayer victim = (BasePlayer)entity;
                DebugMessage(2, "On Entity Death, Entity is Player");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = CheckPlayerInZone(victim, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            raidZoneList[entry.Key].RaidEndTimer = (GetTimeStamp() + RaidTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
                if (PvPList.Count > 0)
                {
                    DebugMessage(2, "There are active PvP zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = CheckPlayerInZone(victim, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            PvPList[entry.Key].PvPEndTimer = (GetTimeStamp() + PvPTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
            }
        }

        [ChatCommand("antibandit")]
        void ChatSettings(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAllowed(player, "antibandit.admin")){
                ChatMessageHandler(player, lang.GetMessage("MissingPermission", this, player.UserIDString), "admin");
                return;}
            if (args == null || args.Length == 0)
            {
                ChatMessageHandler(player, lang.GetMessage("MissingAdminCmD", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "debug":
                    if (!IsAllowed(player, "antibandit.debug")){
                        ChatMessageHandler(player, lang.GetMessage("MissingPermission", this, player.UserIDString), "debug");
                        return;}
                    if (args.Length == 1)
                    {
                        ChatMessageHandler(player, lang.GetMessage("DebugIncorrectCmD", this, player.UserIDString));
                        return;
                    }
                    if (args[1] == "0")
                    {
                        DebugLevel = 0;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "0");
                        return;
                    }
                    else if (args[1] == "1")
                    {
                        DebugLevel = 1;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "1");
                        return;
                    }
                    else if (args[1] == "2")
                    {
                        DebugLevel = 2;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "2");
                        return;
                    }
                    else if (args[1] == "3")
                    {
                        DebugLevel = 3;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "3");
                        return;
                    }
                    else
                    {
                        ChatMessageHandler(player, lang.GetMessage("DebugIncorrectCmD", this, player.UserIDString));
                        return;
                    }
                case "purge":
                    if (args.Length == 1)
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeInccorectCmd", this, player.UserIDString));
                        return;
                    }
                    if (args[1] == "true")
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeModeOn", this, player.UserIDString));
                        purgeMode = true;
                        return;
                    }
                    else if (args[1] == "false")
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeModeOff", this, player.UserIDString));
                        purgeMode = false;
                        return;
                    }
                    else
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeInccorectCmd", this, player.UserIDString));
                        return;
                    }
                default:
                    ChatMessageHandler(player, lang.GetMessage("InvalidCmD", this, player.UserIDString));
                    return;
            }
        }

        [ChatCommand("raid")]
        void RaidChatHandle(BasePlayer _player)
        {
            double RaidInitData = (GetTimeStamp() + RaidDelay);
            double RaidEndData = (GetTimeStamp() + RaidTimeLimit + RaidDelay);
            if (!IsAllowed(_player, "antibandit.player")){
                ChatMessageHandler(_player, lang.GetMessage("MissingPermission", this, _player.UserIDString), "player");
                return;}

            CreatePlayerCooldown(_player);
            bool _testVar1 = CheckServerPvPCooldown();
            bool _testVar2 = CheckPlayerCooldown(_player);
            if ((_testVar1 == true) && (_testVar2 == true))
            {
                Vector3 PosHashValue = (_player.transform.position);
                bool _testVar3 = GetNearbyTargetWall(PosHashValue, _player);
                if (_testVar3 == true)
                {
                    BroadcastMessageHandler(lang.GetMessage("XhasCreatedZone", this, _player.UserIDString), _player.displayName);
                    timer.Once(PvPDelay, () =>
                    {
                        BroadcastMessageHandler(lang.GetMessage("RaidZoneActive", this, _player.UserIDString));
                });
                    raidZoneList.Add(PosHashValue, new RaidDetails { RaidInitCooldown = RaidInitData, RaidEndTimer = RaidEndData });
                    serverRaidCooldownTimeStamp = GetTimeStamp() + serverRaidCooldown;
                    PlayerCooldownList[_player.userID] = GetTimeStamp() + playerCooldown;
                    DebugMessage(1, "Zone Created");
                }
            }
        }

        [ChatCommand("pvp")]
        void PvpChatHandle(BasePlayer _player, string cmd, string[] args)
        {
            if (!IsAllowed(_player, "antibandit.player")){
                ChatMessageHandler(_player, lang.GetMessage("MissingPermission", this, _player.UserIDString), "player");
                return;}

            CreatePlayerCooldown(_player);
            bool _testVar1 = CheckServerPvPCooldown();
            bool _testVar2 = CheckPlayerCooldown(_player);
            if ((_testVar1 == true) && (_testVar2 == true))
            {
                Vector3 _PosHashValue = (_player.transform.position);
                bool _testVar3 = CheckNearPlayerNotFriend(_player, _PosHashValue);
                if (_testVar3 == true)
                {
                    serverPvPCooldownTimeStamp = GetTimeStamp() + serverPvPCooldown;
                    PlayerCooldownList[_player.userID] = GetTimeStamp() + playerCooldown;
                    double PvPInitData = (GetTimeStamp() + PvPDelay);
                    double PvPEndData = (GetTimeStamp() + PvPTimeLimit + PvPDelay);
                    PvPList.Add(_PosHashValue, new PVPData { PvPInitCooldown = PvPInitData, PvPEndTimer = PvPEndData });
                    RegisterNearPlayers(_PosHashValue);
                }
            }
        }

        [ConsoleCommand("AntiBandit.Purge")]
        void PurgeToggle(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;

            if (arg.Args[0].ToLower() == "true") purgeMode = true;
            else if (arg.Args[0].ToLower() == "false") purgeMode = false;
            else Puts(lang.GetMessage("PurgeInccorectConsole", this));
        }

        bool CheckPlayerCooldown(BasePlayer _player)
        {
            if ((PlayerCooldownList[_player.userID] < GetTimeStamp()) || (IsAllowed(_player, "antibandit.nocooldown")))
            {
                return true;
            }

            return false;
        }

        bool CheckServerPvPCooldown()
        {
            if (serverPvPCooldownTimeStamp < GetTimeStamp())
            {
                return true;
            }

            return false;
        }
        bool CheckServerRaidCooldown()
        {
            if (serverRaidCooldownTimeStamp < GetTimeStamp())
            {
                return true;
            }

            return false;
        }

        bool GetNearbyTargetWall(Vector3 hashPos, BasePlayer _player)
        {
            double RaidInitData = (GetTimeStamp() + RaidDelay);
            double RaidEndData = (GetTimeStamp() + RaidTimeLimit + RaidDelay);

            List<BaseEntity> entities = new List<BaseEntity>();
            Vis.Entities(hashPos, RaidZone1, entities, wallCol);
            if (entities.Count > 0)
            {
                foreach (BaseEntity _entry in entities)
                {
                    ulong _ownerID = _entry.OwnerID;
                    if (_ownerID != 0)
                    {
                        //bool _testVar1 = false; //is player friend
                        bool _testVar2 = false; //is player
                        ulong target = _entry.OwnerID;

                        var _test = RustIOFriendListAPI?.Call("ORFriends", _player.userID, _ownerID);
                        bool _result = Convert.ToBoolean(_test);
                        if (_ownerID == _player.userID) _testVar2 = true;
                        if ((_result == false) && (_testVar2 == false))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        class PVPData
        {
            public List<ulong> playerList = new List<ulong>();
            public double PvPInitCooldown;
            public double PvPEndTimer;
        }

        class RaidDetails
        {
            public double RaidInitCooldown;
            public double RaidEndTimer;
        }

        float CalculateDistance(Vector3 playerPos, Vector3 zonePos)
        {
            var distance = (Vector3.Distance(playerPos, zonePos));
            return distance;
        }

        void LoadPermissions()
        {
            string[] Permissionarray = { "player", "debug", "admin", "nocooldown" };
            foreach (string i in Permissionarray)
            {
                string regPerm = Name.ToLower() + "." + i;
                permission.RegisterPermission(regPerm, this);
            }
        }

        private static int wallCol;
        private static int playerCol;

        private void Init()
        {
            LoadPermissions();
            LoadVariables();

            playerCol = LayerMask.GetMask(new string[] { "Player (Server)" });
            wallCol = LayerMask.GetMask(new string[] { "Construction" });
        }

        private void OnServerInitialized()
        {
            tTimers.Add(timer.Repeat(60f, 0, () =>
            {
                DebugMessage(1, "PvP timer is launching");
                DebugMessage(2, "Clearing existing items in list");
                ExpiredPvPZonesList.Clear();
                ExpiredRaidZonesList.Clear();
                foreach (var entry in PvPList)
                {
                    DebugMessage(2, "Checking a zone timestamp");
                    if (PvPList[entry.Key].PvPEndTimer < GetTimeStamp())
                    {
                        DebugMessage(2, "Adding a zone for deletion");
                        ExpiredPvPZonesList.Add(entry.Key);
                    }
                }
                foreach (var entry in raidZoneList)
                {
                    DebugMessage(2, "Checking a zone timestamp");
                    if (raidZoneList[entry.Key].RaidEndTimer < GetTimeStamp())
                    {
                        DebugMessage(2, "Adding a raid zone for deletion");
                        ExpiredRaidZonesList.Add(entry.Key);
                    }
                }

                DebugMessage(2, "Checking if anything needs to be deleted");
                if (ExpiredPvPZonesList.Count > 0)
                {
                    foreach (Vector3 zone in ExpiredPvPZonesList)
                    {
                        DebugMessage(2, "PvP Zones are needed for deletion");
                        PvPList.Remove(zone);
                    }
                }
                if (ExpiredRaidZonesList.Count > 0)
                {
                    foreach (Vector3 zone in ExpiredRaidZonesList)
                    {
                        DebugMessage(2, "Raids Zones are needed for deletion");
                        raidZoneList.Remove(zone);
                    }
                }
                ExpiredPvPZonesList.Clear();
                ExpiredRaidZonesList.Clear();
            }));
        }

        private void Unload()
        {
            DestroyTimers();
            PvPList.Clear();
            raidZoneList.Clear();
            ExpiredPvPZonesList.Clear();
            ExpiredRaidZonesList.Clear();
            tTimers.Clear();
        }

        void DestroyTimers()
        {
            foreach (Timer sTimer in tTimers)
            {
                DebugMessage(2, "Destroying a Timer now");
                sTimer.Destroy();
                DebugMessage(2, "Destroyed a Timer");
            }
            tTimers.Clear();
            DebugMessage(1, "Removed all items from the list");
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;
            return false;
        }

        double GetTimeStamp()
        {
            return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
        }

        static void NullifyDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = new DamageTypeList();
            hitinfo.DoHitEffects = false;
            hitinfo.HitMaterial = 0;
            hitinfo.PointStart = Vector3.zero;
        }

        public bool CheckEntityInZone(BaseCombatEntity _entity, Vector3 _zoneKey, int _maxDistance)
        {
            if (_entity.Distance(_zoneKey) < _maxDistance)
            {
                DebugMessage(2, string.Format("entity Distance: {0} from tested zone", _entity.Distance(_zoneKey)));
                DebugMessage(1, "Entity In zone, Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("entity Distance: {0} from tested zone", _entity.Distance(_zoneKey)));
                DebugMessage(1, "Entity out of zone, Returning False");
                return false;
            }
        }

        public bool CheckPlayerInZone(BasePlayer _player, Vector3 _zoneKey, int _maxDistance)
        {
            if (_player.Distance(_zoneKey) < _maxDistance)
            {
                DebugMessage(2, string.Format("Player Distance: {0} from tested zone", _player.Distance(_zoneKey)));
                DebugMessage(1, "Entity In zone, Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("Player Distance: {0} from tested zone", _player.Distance(_zoneKey)));
                DebugMessage(1, "Entity out of zone, Returning False");
                return false;
            }
        }

        public bool CheckPlayerRegistered(BasePlayer _player, Vector3 _zoneKey)
        {
            if (PvPList[_zoneKey].playerList.Contains(_player.userID))
            {
                DebugMessage(2, string.Format("{0} is registered to the zone", _player.displayName));
                DebugMessage(1, "Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("{0} is not registered to the zone", _player.displayName));
                DebugMessage(1, "Returning false");
                return false;
            }
        }

        bool CheckBuildingOwner(BasePlayer _player, BaseCombatEntity _entity)
        {
            BaseEntity _testEntity = _entity;
            ulong _testResult = FindOwner(_testEntity);
            if (_testResult == _player.userID) return true;
            else return false;
        }

        bool CheckNearPlayerNotFriend (BasePlayer _player, Vector3 _hashPos)
        {
            if (BasePlayer.activePlayerList.Count < 2) return false;
            foreach (BasePlayer _target in BasePlayer.activePlayerList)
            {
                if (!(_target == _player))
                {
                    float distance_between = Vector3.Distance(_hashPos, _target.transform.position);
                    if (distance_between <= PVPZone1)
                    {
                        Puts(_target.UserIDString);
                        var _test = RustIOFriendListAPI?.Call("ORFriends", _player.userID, _target.userID);
                        bool _result = Convert.ToBoolean(_test);
                        if (_result == false) return true;
                    }
                }
            }
            return false;
        }

        void RegisterNearPlayers(Vector3 _hashPos)
        {
            List<BasePlayer> _NearPlayers = new List<BasePlayer>();
            Vis.Entities(_hashPos, PVPZone2, _NearPlayers, playerCol);
            foreach (BasePlayer _entry in _NearPlayers)
            {
                PvPList[_hashPos].playerList.Add(_entry.userID);// Add to the list with this
                timer.Once(PvPDelay, () =>
                {
                    ChatMessageHandler(_entry, "PvP Enabled");
                });
                ChatMessageHandler(_entry, "Warning - A PVP zone has been created");
                ChatMessageHandler(_entry, "You are part of this event.");
                ChatMessageHandler(_entry, string.Format("It will start in {0} seconds.", PvPDelay));
            }
        }

        bool ZoneCooldownCheck(string _zoneType, Vector3 _zonekey)
        {
            DebugMessage(1, "Checking zone cooldown");
            if (_zoneType == "raid")
            {
                if (raidZoneList[_zonekey].RaidInitCooldown < GetTimeStamp()) return true;
                else return false;
            }
            else if (_zoneType == "pvp")
            {
                if (PvPList[_zonekey].PvPInitCooldown < GetTimeStamp()) return true;
                else return false;
            }
            else
            {
                DebugMessage(1, "Warning zoneCooldownCheck has failed all if statements.");
                return false;
            }
        }

        bool ZoneTimerCheck(string _zoneType, Vector3 _zonekey)
        {
            DebugMessage(1, "Checking zone end time");
            if (_zoneType == "raid")
            {
                if (raidZoneList[_zonekey].RaidEndTimer > GetTimeStamp()) return true;
                else return false;
            }
            else if (_zoneType == "pvp")
            {
                if (PvPList[_zonekey].PvPEndTimer > GetTimeStamp()) return true;
                else return false;
            }
            else
            {
                DebugMessage(1, "Warning zoneCooldownCheck has failed all if statements.");
                return false;
            }
        }

        ulong FindOwner(BaseEntity entity)
        {
            ulong ownerid = entity.OwnerID;
            return ownerid;
        }

        void CreatePlayerCooldown(BasePlayer _player)
        {
            if (!PlayerCooldownList.Keys.Contains(_player.userID))
            {
                PlayerCooldownList.Add(_player.userID, GetTimeStamp() - playerCooldown);
            }
        }

        bool ReceivingSnapshotcheck(BasePlayer _player)
        {
            if (_player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(_player));
                return true;
            }
            return false;
        }

        void DebugMessage(int _minDebuglvl, string _msg){
            if (DebugLevel >= _minDebuglvl){
                Puts(_msg);
                if (DebugLevel == 3 && _minDebuglvl == 1){
                    PrintToChat(_msg);}}}

        //////////////////////////////////////////////////////////////////////////////////////
        // MessageHandles ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void BroadcastMessageHandler(string message, params object[] args)
        {
            PrintToChat($"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }

        void ChatMessageHandler(BasePlayer player, string message, params object[] args)
        {
            PrintToChat(player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Config ////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        private string ChatPrefixColor;
        private string ChatPrefix;
        private string ChatMessageColor;
        private bool purgeMode = false;
        private float RaidZone1;
        private int DebugLevel;
        private int PVPZone1;
        private float PVPZone2;
        private int PVPZone3;
        private int PvPDelay;
        private int PvPTimeLimit;
        private int RaidZone2;
        private int RaidDelay;
        private int RaidTimeLimit;
        private double playerCooldown;
        private double serverPvPCooldown;
        private double serverRaidCooldown;
        private double serverPvPCooldownTimeStamp;
        private double serverRaidCooldownTimeStamp;

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            LoadVariables();
        }

        void LoadVariables() //Stores Default Values, calling GetConfig passing: menu, dataValue, defaultValue
        {
            //Booleans
            //PickEnabled = Convert.ToBoolean(GetConfig("Settings", "PickEnabled", false));
            //Double
            playerCooldown = Convert.ToDouble(GetConfig("Values", "playerCooldown", 90));
            serverPvPCooldown = Convert.ToDouble(GetConfig("Values", "serverPvPCooldown", 10));
            serverRaidCooldown = Convert.ToDouble(GetConfig("Values", "serverRaidCooldown", 60));
            //Floats
            PVPZone2 = Convert.ToSingle(GetConfig("Values", "PlayerAddRadius", 50.0f));
            RaidZone1 = Convert.ToSingle(GetConfig("Values", "RaidZone1", 5f));
            //Ints
            PVPZone1 = Convert.ToInt32(GetConfig("Values", "PVPZone1", 5));
            PVPZone3 = Convert.ToInt32(GetConfig("Values", "PVPZone3", 50));
            PvPDelay = Convert.ToInt32(GetConfig("Values", "PvPDelay", 30));
            PvPTimeLimit = Convert.ToInt32(GetConfig("Values", "PvPTimeLimit", 60));
            RaidZone2 = Convert.ToInt32(GetConfig("Values", "RaidZone2", 300));
            RaidDelay = Convert.ToInt32(GetConfig("Values", "RaidDelay", 30));
            RaidTimeLimit = Convert.ToInt32(GetConfig("Values", "RaidTimeLimit", 180));
            DebugLevel = Convert.ToInt32(GetConfig("Values", "DebugLevel", 0));
            //Strings
            //Targated = Convert.ToString(GetConfig("Messages", "NotAffected", "You are being targeted"));
            ChatPrefix = Convert.ToString(GetConfig("ChatSettings", "ChatPrefix", "AntiBandit"));
            ChatPrefixColor = Convert.ToString(GetConfig("ChatSettings", "ChatPrefixColor", "008800"));
            ChatMessageColor = Convert.ToString(GetConfig("ChatSettings", "ChatMessageColor", "yellow"));
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
            }
            return value;
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Lang //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"MissingPermission", "You do not have the required permission: {0}" },
                {"MissingAdminCmD", "Missing Command please use /antibandit (Debug / Purge)" },
                {"DebugIncorrectCmD", "Invalid command, please use: /antibandit Debug 0/1/2/3" },
                {"DebugMode", "Debug Mode set to {0}" },
                {"PurgeInccorectCmd", "Invalid command, please use: /antibandit purge true/false" },
                {"PurgeModeOn", "Purge Mode Has Started" },
                {"PurgeModeOff", "Purge Mode Has Ended" },
                {"InvalidCmD", "Invalid Command" },
                {"XhasCreatedZone", "{0} has created a zone." },
                {"RaidZoneActive", "A Raid zone has become active" },   //Incorrect format: true/false
                {"PurgeInccorectConsole", "Incorrect format: true/false" }
            }, this);
        }
    }
}


// --- End of file: AntiBandit.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-barricade-stacking ---
// --- Original File Path: A/AntiBarricadeStacking/AntiBarricadeStacking.cs ---

ï»¿using System.Linq;

namespace Oxide.Plugins
{
    [Info("AntiBarricadeStacking", "k1lly0u", "0.1.0", ResourceId = 0)]
    class AntiBarricadeStacking : RustPlugin
    {
        bool initialized;       
        void OnServerInitialized() => initialized = true;      
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!initialized) return;
            if (entity is Barricade)
            {
                var barricades = BaseEntity.serverEntities.Where(x => x is Barricade).Where(x => x.transform.position == entity.transform.position).ToArray();
                if (barricades.Length > 1)
                {
                    for (int i = 0; i < barricades.Length - 1; i++)
                    {
                        barricades[i].GetComponent<BaseCombatEntity>().DieInstantly();
                    }
                }
            }
        }       
    }
}

// --- End of file: AntiBarricadeStacking.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/airstrike ---
// --- Original File Path: A/Airstrike/Airstrike.cs ---

ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Airstrike", "k1lly0u", "0.3.6", ResourceId = 1489)]
    class Airstrike : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Economics, ServerRewards;

        StoredData storedData;
        private DynamicConfigFile data;

        private Dictionary<ulong, StrikeType> toggleList = new Dictionary<ulong, StrikeType>();

        private Dictionary<string, int> shortnameToId = new Dictionary<string, int>();
        private Dictionary<string, string> shortnameToDn = new Dictionary<string, string>();

        private static Airstrike ins;
        
        const string cargoPlanePrefab = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        const string basicRocket = "assets/prefabs/ammo/rocket/rocket_basic.prefab";
        const string fireRocket = "assets/prefabs/ammo/rocket/rocket_fire.prefab";

        enum StrikeType { Strike, Squad }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("airstrike_data");

            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("airstrike.signal.strike", this);
            permission.RegisterPermission("airstrike.signal.squad", this);
            permission.RegisterPermission("airstrike.purchase.strike", this);
            permission.RegisterPermission("airstrike.purchase.squad", this);
            permission.RegisterPermission("airstrike.chat.strike", this);
            permission.RegisterPermission("airstrike.chat.squad", this);
            permission.RegisterPermission("airstrike.ignorecooldown", this);
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadVariables();
            LoadData();

            shortnameToId = ItemManager.itemList.ToDictionary(x => x.shortname, y => y.itemid);
            shortnameToDn = ItemManager.itemList.ToDictionary(x => x.shortname, y => y.displayName.translated);

            CallRandomStrike();
        }

        private void Unload()
        {
            ins = null;
            SaveData();

            var objects = UnityEngine.Object.FindObjectsOfType<StrikePlane>();
            if (objects != null)
            {
                foreach (var obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }
        }

        private void OnServerSave() => SaveData();

        private void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {            
            if (toggleList.ContainsKey(player.userID) && entity is SupplySignal)
            {
                StrikeType type = toggleList[player.userID];
                toggleList.Remove(player.userID);
                AddCooldownData(player, type);

                entity.CancelInvoke((entity as SupplySignal).Explode);
                entity.Invoke(entity.KillMessage, 30f);
                timer.Once(3, () =>
                {
                    Effect.server.Run("assets/bundled/prefabs/fx/smoke_signal_full.prefab", entity, 0, new Vector3(), new Vector3());
                    Vector3 pos = entity.transform.position;
                    switch (type)
                    {
                        case StrikeType.Strike:
                            SendReply(player, string.Format(msg("strikeConfirmed", player.UserIDString), pos));
                            CallStrike(pos);
                            return;
                        case StrikeType.Squad:
                            SendReply(player, string.Format(msg("strikeConfirmed", player.UserIDString), pos));
                            CallSquad(pos);
                            return;
                    }                    
                });
            }
        }
        #endregion

        #region Plane Control
        private class StrikePlane : MonoBehaviour
        {
            private CargoPlane entity;
            private Vector3 targetPos;

            private RocketOptions rocketOptions;

            private Vector3 startPos;
            private Vector3 endPos;
            private float secondsToTake;

            private int rocketsFired;
            private float fireDistance;
            private bool isFiring;
            
            private void Awake()
            {
                entity = GetComponent<CargoPlane>();
                rocketOptions = ins.configData.Rocket;
                fireDistance = ins.configData.Plane.Distance;

                entity.dropped = true;
                enabled = false;
            }

            private void Update()
            {
                if (!isFiring && Vector3.Distance(transform.position, targetPos) <= fireDistance)
                {
                    isFiring = true;
                    FireRocketLoop();
                }
            }

            private void OnDestroy()
            {
                entity.CancelInvoke(LaunchRocket);
            }

            public void InitializeFlightPath(Vector3 targetPos)
            {                
                this.targetPos = targetPos;

                float size = TerrainMeta.Size.x;
                float highestPoint = 170f + ins.configData.Plane.Height;
                
                startPos = Vector3Ex.Range(-1f, 1f);
                startPos.y = 0f;
                startPos.Normalize();
                startPos = startPos * (size * 2f);
                startPos.y = highestPoint;
                
                endPos = startPos * -1f;
                endPos.y = startPos.y;
                startPos = startPos + targetPos;
                endPos = endPos + targetPos;
                
                secondsToTake = (Vector3.Distance(startPos, endPos) / ins.configData.Plane.Speed) * UnityEngine.Random.Range(0.95f, 1.05f);
                
                entity.transform.position = startPos;
                entity.transform.rotation = Quaternion.LookRotation(endPos - startPos);

                entity.startPos = startPos;
                entity.endPos = endPos;
                entity.dropPosition = targetPos;
                entity.secondsToTake = secondsToTake;
                
                enabled = true;
            }

            public void GetFlightData(out Vector3 startPos, out Vector3 endPos, out float secondsToTake)
            {
                startPos = this.startPos;
                endPos = this.endPos;
                secondsToTake = this.secondsToTake;
            }

            public void SetFlightData(Vector3 startPos, Vector3 endPos, Vector3 targetPos, float secondsToTake)
            {
                this.startPos = startPos;
                this.endPos = endPos;
                this.targetPos = targetPos;
                this.secondsToTake = secondsToTake;

                entity.transform.position = startPos;
                entity.transform.rotation = Quaternion.LookRotation(endPos - startPos);

                entity.startPos = startPos;
                entity.endPos = endPos;
                entity.dropPosition = targetPos;
                entity.secondsToTake = secondsToTake;

                enabled = true;
            }

            private void FireRocketLoop()
            {
                entity.InvokeRepeating(LaunchRocket, 0, rocketOptions.Interval);
            }
            
            private void LaunchRocket()
            {
                if (rocketsFired >= rocketOptions.Amount)
                {
                    entity.CancelInvoke(LaunchRocket);
                    return;
                }
                var rocketType = rocketOptions.Type == "Normal" ? basicRocket : fireRocket;
                if (rocketOptions.Mixed && UnityEngine.Random.Range(1, rocketOptions.FireChance) == 1)
                    rocketType = fireRocket;

                Vector3 launchPos = entity.transform.position;
                Vector3 newTarget = Quaternion.Euler(GetRandom(), GetRandom(), GetRandom()) * targetPos;
                                
                BaseEntity rocket = GameManager.server.CreateEntity(rocketType, launchPos, new Quaternion(), true);

                TimedExplosive rocketExplosion = rocket.GetComponent<TimedExplosive>();
                ServerProjectile rocketProjectile = rocket.GetComponent<ServerProjectile>();

                rocketProjectile.speed = rocketOptions.Speed;
                rocketProjectile.gravityModifier = 0;
                rocketExplosion.timerAmountMin = 60;
                rocketExplosion.timerAmountMax = 60;
                for (int i = 0; i < rocketExplosion.damageTypes.Count; i++)
                    rocketExplosion.damageTypes[i].amount *= rocketOptions.Damage;

                Vector3 newDirection = (newTarget - launchPos);

                rocket.SendMessage("InitializeVelocity", (newDirection));
                rocket.Spawn();
                ++rocketsFired;
            }

            private float GetRandom() => UnityEngine.Random.Range(-rocketOptions.Accuracy * 0.2f, rocketOptions.Accuracy * 0.2f);
        }
        #endregion

        #region Functions
        private void CallRandomStrike()
        {
            if (!configData.Other.RandomStrikes && !configData.Other.RandomSquads) return;

            timer.In(UnityEngine.Random.Range(configData.Other.RandomTimer[0], configData.Other.RandomTimer[1]), () =>
            {
                StrikeType type;
                if (configData.Other.RandomStrikes && configData.Other.RandomSquads)
                    type = UnityEngine.Random.Range(1, 2) == 1 ? type = StrikeType.Strike : type = StrikeType.Squad;
                else if (configData.Other.RandomStrikes)
                    type = StrikeType.Strike;
                else type = StrikeType.Squad;

                if (type == StrikeType.Strike)
                    CallStrike(GetRandomPosition());
                else CallSquad(GetRandomPosition());

                CallRandomStrike();
            });
        }
        private void CallStrike(Vector3 position)
        {
            CargoPlane entity = CreatePlane();
            entity.Spawn();

            StrikePlane plane = entity.gameObject.AddComponent<StrikePlane>();
            plane.InitializeFlightPath(position);

            if (configData.Other.Broadcast)
                PrintToChat(msg("strikeInbound"));
        }
        private void CallSquad(Vector3 position)
        {
            CargoPlane leaderEnt = CreatePlane();
            leaderEnt.Spawn();

            StrikePlane leaderPlane = leaderEnt.gameObject.AddComponent<StrikePlane>();
            leaderPlane.InitializeFlightPath(position);

            Vector3 startPos;
            Vector3 endPos;
            float secondsToTake;
            leaderPlane.GetFlightData(out startPos, out endPos, out secondsToTake);

            CargoPlane leftEnt = CreatePlane();
            leftEnt.Spawn();
            StrikePlane leftPlane = leftEnt.gameObject.AddComponent<StrikePlane>();
            Vector3 leftOffset = (leaderEnt.transform.right * 70) + (-leaderEnt.transform.forward * 80);
            leftPlane.SetFlightData(startPos + leftOffset, endPos + leftOffset, position + (leftOffset / 4), secondsToTake);

            CargoPlane rightEnt = CreatePlane();
            rightEnt.Spawn();
            StrikePlane rightPlane = rightEnt.gameObject.AddComponent<StrikePlane>();
            Vector3 rightOffset = (-leaderEnt.transform.right * 70) + (-leaderEnt.transform.forward * 80);
            rightPlane.SetFlightData(startPos + rightOffset, endPos + rightOffset, position + (rightOffset / 4), secondsToTake);

            if (configData.Other.Broadcast)
                PrintToChat(msg("squadInbound"));
        }

        private bool CanBuyStrike(BasePlayer player, StrikeType type)
        {
            Dictionary<string, int> costToBuy = type == StrikeType.Strike ? configData.Buy.StrikeCost : configData.Buy.SquadCost;
                        
            foreach(var item in costToBuy)
            {
                if (item.Key == "RP")
                {
                    if (ServerRewards)
                    {
                        if ((int)ServerRewards.Call("CheckPoints", player.userID) < item.Value)
                        {
                            SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, item.Key));
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                            return false;
                        }
                    }
                }
                if (item.Key == "Economics")
                {
                    if (Economics)
                    {
                        if ((double)Economics.Call("GetPlayerMoney", player.userID) < item.Value)
                        {
                            SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, item.Key));
                            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                            return false;
                        }
                    }
                }
                if (shortnameToId.ContainsKey(item.Key))
                {
                    if (player.inventory.GetAmount(shortnameToId[item.Key]) < item.Value)
                    {
                        SendReply(player, string.Format(msg("buyItem", player.UserIDString), item.Value, shortnameToDn[item.Key]));
                        Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.denied.prefab", player.transform.position);
                        return false;
                    }
                }
            }
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", player.transform.position);
            return true;
        }

        private void BuyStrike(BasePlayer player, StrikeType type)
        {
            Dictionary<string, int> costToBuy = type == StrikeType.Strike ? configData.Buy.StrikeCost : configData.Buy.SquadCost;

            foreach (var item in costToBuy)
            {
                if (item.Key == "RP")
                {
                    if (ServerRewards)
                        ServerRewards.Call("TakePoints", player.userID, item.Value);
                }
                if (item.Key == "Economics")
                {
                    if (Economics)                    
                        Economics.Call("Withdraw", player.userID, (double)item.Value); 
                }
                if (shortnameToId.ContainsKey(item.Key))                
                    player.inventory.Take(null, shortnameToId[item.Key], item.Value);
            }
            if (type == StrikeType.Strike)
            {
                CallStrike(player.transform.position);
                SendReply(player, string.Format(msg("strikeConfirmed", player.UserIDString), player.transform.position));
            }
            else
            {
                CallSquad(player.transform.position);
                SendReply(player, string.Format(msg("squadConfirmed", player.UserIDString), player.transform.position));
            }
        }
        #endregion

        #region Helpers
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        private CargoPlane CreatePlane() => (CargoPlane)GameManager.server.CreateEntity(cargoPlanePrefab, new Vector3(), new Quaternion(), true);
        private bool isStrikePlane(CargoPlane plane) => plane.GetComponent<StrikePlane>();
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        private Vector3 GetRandomPosition()
        {
            float mapSize = (TerrainMeta.Size.x / 2) - 600f;

            float randomX = UnityEngine.Random.Range(-mapSize, mapSize);
            float randomY = UnityEngine.Random.Range(-mapSize, mapSize);

            return new Vector3(randomX, 0f, randomY);
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }

        private void AddCooldownData(BasePlayer player, StrikeType type)
        {
            if (!configData.Cooldown.Enabled) return;

            if (!storedData.cooldowns.ContainsKey(player.userID))
                storedData.cooldowns.Add(player.userID, new CooldownData());

            if (type == StrikeType.Strike)
                storedData.cooldowns[player.userID].strikeCd = GrabCurrentTime() + configData.Cooldown.Strike;
            else storedData.cooldowns[player.userID].squadCd = GrabCurrentTime() + configData.Cooldown.Squad;
        }

        private List<BasePlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();

            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                {
                    if (player.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(player);
                        return foundPlayers;
                    }
                }
                string lowername = player.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(player);
                }
            }
            return foundPlayers;
        }
        #endregion

        #region Commands
        [ChatCommand("airstrike")]
        private void cmdAirstrike(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, string.Format("Airstrike  v.{0}", Version));
                if (HasPermission(player, "airstrike.signal.strike"))
                    SendReply(player, msg("help1", player.UserIDString));
                if (HasPermission(player, "airstrike.signal.squad"))
                    SendReply(player, msg("help2", player.UserIDString));
                if (HasPermission(player, "airstrike.purchase.strike"))
                    SendReply(player, msg("help3", player.UserIDString));
                if (HasPermission(player, "airstrike.purchase.squad"))
                    SendReply(player, msg("help4", player.UserIDString));
                if (HasPermission(player, "airstrike.chat.strike"))
                {
                    SendReply(player, msg("help5", player.UserIDString));
                    SendReply(player, msg("help6", player.UserIDString));
                    SendReply(player, msg("help7", player.UserIDString));
                }
                if (HasPermission(player, "airstrike.chat.squad"))
                {
                    SendReply(player, msg("help8", player.UserIDString));
                    SendReply(player, msg("help9", player.UserIDString));
                    SendReply(player, msg("help10", player.UserIDString));
                }
                return;
            }
            if (args.Length >= 2)
            {
                var time = GrabCurrentTime();
                StrikeType type = args[1].ToLower() == "squad" ? StrikeType.Squad : StrikeType.Strike;
                
                if (!HasPermission(player, "airstrike.ignorecooldown"))
                {
                    if (configData.Cooldown.Enabled)
                    {
                        CooldownData data;
                        if (storedData.cooldowns.TryGetValue(player.userID, out data))
                        {
                            double nextUse = type == StrikeType.Strike ? data.strikeCd : data.squadCd;
                            if (nextUse > time)
                            {
                                double remaining = nextUse - time;
                                SendReply(player, string.Format(msg("onCooldown", player.UserIDString), FormatTime(remaining)));
                                return;
                            }
                        }
                    }
                }
                switch (args[0].ToLower())
                {
                    case "signal":
                        if ((type == StrikeType.Strike && configData.Other.SignalStrike) || (type == StrikeType.Squad && configData.Other.SignalSquad))
                        {
                            if (!HasPermission(player, $"airstrike.signal.{type.ToString().ToLower()}"))
                            {
                                SendReply(player, msg("noPerms", player.UserIDString));
                                return;
                            }
                        }
                        if (toggleList.ContainsKey(player.userID))
                            toggleList[player.userID] = type;
                        else toggleList.Add(player.userID, type);
                        SendReply(player, msg("signalReady", player.UserIDString));                
                        return;
                    case "buy":
                        if ((type == StrikeType.Strike && configData.Buy.PermissionStrike) || (type == StrikeType.Squad && configData.Buy.PermissionSquad))
                        {
                            if (!HasPermission(player, $"airstrike.purchase.{type.ToString().ToLower()}"))
                            {
                                SendReply(player, msg("noPerms", player.UserIDString));
                                return;
                            }
                        }
                        if (CanBuyStrike(player, type))
                        {
                            BuyStrike(player, type);
                            AddCooldownData(player, type);
                        }
                        return;
                    case "call":
                        if (HasPermission(player, $"airstrike.chat.{type.ToString().ToLower()}"))
                        {
                            Vector3 position;
                            if (args.Length == 4)
                            {
                                float x, z;   
                                if (!float.TryParse(args[2], out x) || !float.TryParse(args[3], out z))
                                {
                                    SendReply(player, msg("invCoords", player.UserIDString));
                                    return;                                                                     
                                }
                                else position = new Vector3(x, 0, z);
                            }
                            else if (args.Length == 3)
                            {
                                var players = FindPlayer(args[2]);
                                if (players.Count > 1)
                                {
                                    SendReply(player, msg("multiplePlayers", player.UserIDString));
                                    return;
                                }
                                else if (players.Count == 0)
                                {
                                    SendReply(player, msg("noPlayers", player.UserIDString));
                                    return;
                                }
                                else position = players[0].transform.position;
                            }
                            else position = player.transform.position;
                            
                            if (type == StrikeType.Strike)
                            {
                                CallStrike(position);
                                SendReply(player, string.Format(msg("strikeConfirmed", player.UserIDString), position));
                            }
                            else
                            {
                                CallSquad(position);
                                SendReply(player, string.Format(msg("squadConfirmed", player.UserIDString), position));
                            }
                            AddCooldownData(player, type);
                        }
                        else SendReply(player, msg("noPerms", player.UserIDString));
                        return;
                    default:
                        break;
                }
            }
        }

        [ConsoleCommand("airstrike")]
        private void ccmdAirstrike(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "airstrike strike <x> <z> - Call a airstrike to the target position");
                SendReply(arg, "airstrike squad <x> <z> - Call a squadstrike to the target position");
                SendReply(arg, "airstrike strike <playername> - Call a airstrike to the target player");
                SendReply(arg, "airstrike squad <playername> - Call a squadstrike to the target player");
                SendReply(arg, "airstrike strike random - Call a random airstrike");
                SendReply(arg, "airstrike squad random - Call a random squadstrike");
                return;
            }

            StrikeType type = arg.Args[0].ToLower() == "squad" ? StrikeType.Squad : StrikeType.Strike;

            Vector3 position = Vector3.zero;
            
            if (arg.Args.Length == 3)
            {
                float x, z;
                if (!float.TryParse(arg.Args[1], out x) || !float.TryParse(arg.Args[2], out z))
                {
                    SendReply(arg, "Invalid co-ordinates set. You must enter number values for X and Z");
                    return;
                }
                else position = new Vector3(x, 0, z);
            }
            else if (arg.Args.Length == 2)
            {
                if (arg.Args[1].ToLower() == "random")
                    position = GetRandomPosition();
                else
                {
                    var players = FindPlayer(arg.Args[1]);
                    if (players.Count > 1)
                    {
                        SendReply(arg, "Multiple players found");
                        return;
                    }
                    else if (players.Count == 0)
                    {
                        SendReply(arg, "No players found");
                        return;
                    }
                    else position = players[0].transform.position;
                }
            }

            if (type == StrikeType.Strike)
            {
                CallStrike(position);
                SendReply(arg, string.Format("Airstrike confirmed at co-ordinates: {0}!", position));
            }
            else
            {
                CallSquad(position);
                SendReply(arg, string.Format("Squadstrike confirmed at co-ordinates: {0}!", position));
            }
        }
        #endregion

        #region Config 
        private ConfigData configData;
        class RocketOptions
        {
            [JsonProperty(PropertyName = "Speed of the rocket")]
            public float Speed { get; set; }
            [JsonProperty(PropertyName = "Damage modifier")]
            public float Damage { get; set; }
            [JsonProperty(PropertyName = "Accuracy of rocket (a lower number is more accurate)")]
            public float Accuracy { get; set; }
            [JsonProperty(PropertyName = "Interval between rockets (seconds)")]
            public float Interval { get; set; }
            [JsonProperty(PropertyName = "Type of rocket (Normal, Napalm)")]
            public string Type { get; set; }
            [JsonProperty(PropertyName = "Use both rocket types")]
            public bool Mixed { get; set; }
            [JsonProperty(PropertyName = "Chance of a fire rocket (when using both types)")]
            public int FireChance { get; set; }
            [JsonProperty(PropertyName = "Amount of rockets to fire")]
            public int Amount { get; set; }
        }

        class CooldownOptions
        {
            [JsonProperty(PropertyName = "Use cooldown timers")]
            public bool Enabled { get; set; }            
            [JsonProperty(PropertyName = "Strike cooldown time (seconds)")]
            public int Strike { get; set; }
            [JsonProperty(PropertyName = "Squad cooldown time (seconds)")]
            public int Squad { get; set; }
        }

        class PlaneOptions
        {
            [JsonProperty(PropertyName = "Flight speed (meters per second)")]
            public float Speed { get; set; }
            [JsonProperty(PropertyName = "Distance from target to engage")]
            public float Distance { get; set; }
            [JsonProperty(PropertyName = "Height modifier")]
            public float Height { get; set; }
        }

        class BuyOptions
        {
            [JsonProperty(PropertyName = "Can purchase standard strike")]
            public bool StrikeEnabled { get; set; }
            [JsonProperty(PropertyName = "Can purchase squad strike")]
            public bool SquadEnabled { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase strike")]
            public bool PermissionStrike { get; set; }
            [JsonProperty(PropertyName = "Require permission to purchase squad strike")]
            public bool PermissionSquad { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a standard strike (shortname, amount)")]
            public Dictionary<string, int> StrikeCost { get; set; }
            [JsonProperty(PropertyName = "Cost to purchase a squad strike (shortname, amount)")]
            public Dictionary<string, int> SquadCost { get; set; }
        }

        class OtherOptions
        {
            [JsonProperty(PropertyName = "Broadcast strikes to chat")]
            public bool Broadcast { get; set; }
            [JsonProperty(PropertyName = "Can call standard strikes using a supply signal")]
            public bool SignalStrike { get; set; }
            [JsonProperty(PropertyName = "Can call squad strikes using a supply signal")]
            public bool SignalSquad { get; set; }
            [JsonProperty(PropertyName = "Use random airstrikes")]
            public bool RandomStrikes { get; set; }
            [JsonProperty(PropertyName = "Use random squad strikes")]
            public bool RandomSquads { get; set; }
            [JsonProperty(PropertyName = "Random timer (minimum, maximum. In seconds)")]
            public int[] RandomTimer { get; set; }
        }

        class ConfigData
        {
            [JsonProperty(PropertyName = "Rocket Options")]
            public RocketOptions Rocket { get; set; }
            [JsonProperty(PropertyName = "Cooldown Options")]
            public CooldownOptions Cooldown { get; set; }
            [JsonProperty(PropertyName = "Plane Options")]
            public PlaneOptions Plane { get; set; }
            [JsonProperty(PropertyName = "Purchase Options")]
            public BuyOptions Buy { get; set; }
            [JsonProperty(PropertyName = "Other Options")]
            public OtherOptions Other { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Buy = new BuyOptions
                {
                    SquadCost = new Dictionary<string, int>
                    {
                        ["metal.refined"] = 100,
                        ["techparts"] = 50,
                        ["targeting.computer"] = 1
                    },
                    SquadEnabled = true,
                    PermissionSquad = true,
                    StrikeCost = new Dictionary<string, int>
                    {
                        ["metal.refined"] = 50,
                        ["targeting.computer"] = 1
                    },
                    StrikeEnabled = true,
                    PermissionStrike = true
                },
                Cooldown = new CooldownOptions
                {
                    Enabled = true,
                    Squad = 3600,
                    Strike = 3600
                },
                Other = new OtherOptions
                {
                    Broadcast = true,
                    SignalSquad = true,
                    SignalStrike = true,
                    RandomSquads = true,
                    RandomStrikes = true,
                    RandomTimer = new int[] { 1800, 3600 }
                },
                Plane = new PlaneOptions
                {
                    Distance = 900,
                    Speed = 105,
                    Height = 0
                },
                Rocket = new RocketOptions
                {
                    Accuracy = 1.5f,
                    Amount = 15,
                    Damage = 1.0f,
                    FireChance = 4,
                    Interval = 0.6f,
                    Mixed = true,
                    Speed = 110f,
                    Type = "Normal"
                }
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        private void SaveData() => data.WriteObject(storedData);

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        class StoredData
        {
            public Dictionary<ulong, CooldownData> cooldowns = new Dictionary<ulong, CooldownData>();
        }

        class CooldownData
        {
            public double strikeCd, squadCd;
        }
        #endregion

        #region Localization
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["strikeConfirmed"] = "Airstrike confirmed at co-ordinates: {0}",
            ["squadConfirmed"] = "Squadstrike confirmed at co-ordinates: {0}",
            ["strikeInbound"] = "Airstrike inbound!",
            ["squadInbound"] = "Squadstrike inbound!",
            ["buyItem"] = "You need another {0} {1} to buy this strike",
            ["help1"] = "/airstrike signal strike - Use a supply signal to mark a airstrike position",
            ["help2"] = "/airstrike signal squad - Use a supply signal to mark a squadstrike position",
            ["help3"] = "/airstrike buy strike - Purchase a airstrike on your position",
            ["help4"] = "/airstrike buy squad - Purchase a squadstrike on your position",
            ["help5"] = "/airstrike call strike - Call a airstrike on your position",
            ["help6"] = "/airstrike call strike <x> <z> - Call a airstrike to the target position",
            ["help7"] = "/airstrike call strike <player name> - Call a airstrike to the target player",
            ["help8"] = "/airstrike call squad - Call a squadstrike on your position",
            ["help9"] = "/airstrike call squad <x> <z> - Call a squadstrike to the target position",
            ["help10"] = "/airstrike call squad <player name> - Call a squadstrike to the target player",
            ["onCooldown"] = "You must wait another {0} before calling this type again",
            ["noPerms"] = "You do not have permission to use that strike type",
            ["signalReady"] = "Throw a supply signal to call a strike",
            ["invCoords"] = "Invalid co-ordinates set. You must enter number values for X and Z",
            ["multiplePlayers"] = "Multiple players found",
            ["noPlayers"] = "No players found"
        };
        #endregion
    }
}


// --- End of file: Airstrike.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-wounded ---
// --- Original File Path: A/AntiWounded/AntiWounded.cs ---

ï»¿// ReSharper disable UnusedMember.Local
namespace Oxide.Plugins
{
    [Info("Anti-Wounded", "Iv Misticos", "3.0.1")]
    [Description("Players will skip the wounded state before dying.")]
    class AntiWounded : RustPlugin
    {
        private const string PermUse = "antiwounded.use";
        
        private void OnServerInitialized() => permission.RegisterPermission(PermUse, this);

        private object CanBeWounded(BasePlayer player, HitInfo info)
        {
            if (permission.UserHasPermission(player.UserIDString, PermUse))
                return false;

            return null;
        }
    }
}

// --- End of file: AntiWounded.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-items ---
// --- Original File Path: A/AntiItems/AntiItems.cs ---

ï»¿using Facepunch;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("AntiItems", "Author redBDGR, Maintainer nivex", "1.0.15")]
    [Description("Remove the need for certain items in crafting and repairing")]
    class AntiItems : RustPlugin
    {
        private Dictionary<string, int> componentList = new();

        private string permissionName = "antiitems.use";

        private Configuration config;

        private void OnPlayerConnected(BasePlayer player) => timer.Once(5f, () => DoItems(player));

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!IsInvalid(player) && permission.UserHasPermission(player.UserIDString, permissionName))
            {
                RemoveItems(player);
            }
        }

        private void OnPlayerRespawned(BasePlayer player) => NextTick(() => DoItems(player));

        private void Init()
        {
            permission.RegisterPermission(permissionName, this);
            if (config.settings.useActiveRefreshing && config.settings.refreshTime > 0)
            {
                timer.Repeat(config.settings.refreshTime, 0, () =>
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        RefreshItems(player);
                    }
                });
            }
            VerifyShortnames();
        }

        private void OnGroupPermissionRevoked(string group, string perm)
        {
            if (perm != permissionName) return;
            var users = permission.GetUsersInGroup(group);
            foreach (var user in users)
            {
                var userid = user.Split('(')[0].Trim();
                var player = BasePlayer.FindAwakeOrSleeping(userid);
                if (IsInvalid(player)) continue;
                RemoveItems(player);
            }
        }

        private void OnUserPermissionRevoked(string userid, string perm)
        {
            if (perm != permissionName) return;
            var player = BasePlayer.FindAwakeOrSleeping(userid);
            if (IsInvalid(player)) return;
            RemoveItems(player);
        }

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (!IsInvalid(player) && permission.UserHasPermission(player.UserIDString, permissionName))
            {
                RemoveItems(player);
            }
        }

        private void OnItemCraftCancelled(ItemCraftTask task)
        {
            foreach (var entry in task.takenItems)
            {
                if (componentList.ContainsKey(entry.info.shortname))
                {
                    timer.Once(0.01f, () =>
                    {
                        if (entry != null)
                        {
                            entry.RemoveFromContainer();
                            entry.Remove();
                        }
                    });
                }
            }
        }

        private void RefreshItems(BasePlayer player)
        {
            if (IsInvalid(player) || !permission.UserHasPermission(player.UserIDString, permissionName) || player.IsDead()) return;
            for (var i = 0; i < componentList.Count; i++)
            {
                Item item = player.inventory.containerMain.GetSlot(24 + i);
                if (item == null) continue;
                item.RemoveFromContainer();
                item.Remove();
            }
            DoItems(player);
        }

        private void DoItems(BasePlayer player)
        {
            if (IsInvalid(player) || !permission.UserHasPermission(player.UserIDString, permissionName) || player.IsDead()) return;
            player.inventory.containerMain.capacity = 24 + componentList.Count;
            var compList = componentList.Select(key => key.Key).ToList();
            for (var i = 0; i < componentList.Count; i++)
            {
                var item = ItemManager.CreateByName(compList[i], componentList[compList[i]]);
                if (item == null)
                {
                    Puts($"{compList[i]} was not able to be created properly. Perhaps the name of it is wrong");
                    continue;
                }
                if (!item.MoveToContainer(player.inventory.containerMain, 24 + i, true, config.settings.ignoreStackLimit))
                {
                    item.Remove();
                }
            }
        }

        private void RemoveItems(BasePlayer player)
        {
            List<Item> foundComponents = Pool.GetList<Item>();
            foreach (var item in player.inventory.containerMain.itemList)
            {
                if (item != null && componentList.ContainsKey(item.info.shortname))
                {
                    foundComponents.Add(item);
                }
            }
            foreach (var key in foundComponents)
            {
                key.RemoveFromContainer();
                key.Remove(0.1f);
            }
            Pool.FreeList(ref foundComponents);
            ItemManager.DoRemoves();
        }

        private void VerifyShortnames()
        {
            foreach (var component in config.settings.componentList)
            {
                if (ItemManager.FindItemDefinition(component.Key) == null) Puts($"Error: '{component.Key}' is not a valid shortname");
                else componentList[component.Key] = component.Value;
            }
        }

        private bool IsInvalid(BasePlayer player) => !player || !player.userID.IsSteamId() || player.IsDestroyed || player.inventory == null || player.inventory.containerMain == null;

        #region Configuration

        public class Settings
        {
            [JsonProperty("Components", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> componentList = new()
            {
                { "propanetank", 1000 }, 
                { "gears", 1000 }, 
                { "metalpipe", 1000 },
                { "metalspring", 1000 }, 
                { "riflebody", 1000 }, 
                { "roadsigns", 1000 },
                { "rope", 1000 }, 
                { "semibody", 1000 }, 
                { "sewingkit", 1000 },
                { "smgbody", 1000 },
                { "tarp", 1000 }, 
                { "techparts", 1000 }, 
                { "sheetmetal", 1000 }
            };
            
            [JsonProperty("Use Active Item Refreshing")]
            public bool useActiveRefreshing = true;

            [JsonProperty("Refresh Time")]
            public float refreshTime = 600f;

            [JsonProperty("Ignore Stack Limit")]
            public bool ignoreStackLimit;
        }

        private class Configuration
        {
            [JsonProperty("Settings")]
            public Settings settings = new();

            private string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    Puts("Configuration appears to be outdated; updating and saving.");
                    SaveConfig();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }

        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

    }
}

// --- End of file: AntiItems.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-commands ---
// --- Original File Path: A/AutoCommands/AutoCommands.cs ---

ï»¿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Auto Commands", "Wulf", "2.0.1")]
    [Description("Automatically runs configured commands on player and server events")]
    public class AutoCommands : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Run commands on player connect")]
            public bool RunCommandsOnConnect = false;

            [JsonProperty("Commands on connect", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ConnectCommands = new List<string> { "examplecmd $player.id", "example.cmd" };

            [JsonProperty("Run commands on player disconnect")]
            public bool RunCommandsOnDisconnect = false;

            [JsonProperty("Commands on disconnect", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DisconnectCommands = new List<string> { "examplecmd", "example.cmd \"text example\"" };

            [JsonProperty("Run commands on server startup")]
            public bool RunCommandsOnStartup = false;

            [JsonProperty("Commands on server startup", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> StartupCommands = new List<string> { "examplecmd $server.name", "example.cmd" };

#if HURTWORLD || RUST

            [JsonProperty("Run commands on server wipe")]
            public bool RunCommandsOnWipe = false;

            [JsonProperty("Commands on server wipe", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> WipeCommands = new List<string> { "examplecmd arg", "example.cmd \"text example\"" };

#endif

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Initialization

        private void Init()
        {
            if (!config.RunCommandsOnConnect)
            {
                Unsubscribe(nameof(OnUserConnected));
            }

            if (!config.RunCommandsOnDisconnect)
            {
                Unsubscribe(nameof(OnUserDisconnected));
            }

            if (!config.RunCommandsOnStartup)
            {
                Unsubscribe(nameof(OnServerInitialized));
            }

#if HURTWORLD || RUST
            if (!config.RunCommandsOnWipe)
            {
                Unsubscribe(nameof(OnNewSave));
            }
#endif
        }

        #endregion Initialization

        #region Player Commands

        private void OnUserConnected(IPlayer player)
        {
            foreach (string command in config.ConnectCommands)
            {
                ProcessCommand(command, player);
            }
        }

        private void OnUserDisconnected(IPlayer player)
        {
            foreach (string command in config.DisconnectCommands)
            {
                ProcessCommand(command, player);
            }
        }

        #endregion Player Commands

        #region Server Commands

        private void OnServerInitialized()
        {
            foreach (string command in config.StartupCommands)
            {
                ProcessCommand(command);
            }
        }

#if HURTWORLD || RUST

        private void OnNewSave()
        {
            foreach (string command in config.WipeCommands)
            {
                ProcessCommand(command);
            }
        }

#endif

        #endregion Server Commands

        #region Helpers

        private void ProcessCommand(string command, IPlayer player = null)
        {
            if (!command.StartsWith("examplecmd") && !command.StartsWith("example.cmd"))
            {
                server.Command(ReplacePlaceholders(command, player));
            }
        }

        private string ReplacePlaceholders(string command, IPlayer player = null)
        {
            if (player != null)
            {
                command = command
                .Replace("$player.id", player.Id)
                .Replace("$player.name", player.Name)
                .Replace("$player.ip", player.Address)
                .Replace("$player.language", player.Language.TwoLetterISOLanguageName)
                .Replace("$player.ping", player.Ping.ToString())
                .Replace("$player.position", player.Position().ToString());
            }

            return command
                .Replace("$server.name", server.Name)
                .Replace("$server.ip", server.Address.ToString())
                .Replace("$server.port", server.Port.ToString())
                .Replace("$server.players", server.Players.ToString())
                .Replace("$server.language", server.Language.TwoLetterISOLanguageName)
                .Replace("$server.maxplayers", server.MaxPlayers.ToString())
                .Replace("$server.protocol", server.Protocol)
                .Replace("$server.version", server.Version);
        }

        #endregion Helpers
    }
}


// --- End of file: AutoCommands.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/arrow-raiding ---
// --- Original File Path: A/ArrowRaiding/ArrowRaiding.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Arrow Raiding", "birthdates", "2.0.1")]
    [Description("Break wooden doors with arrows like old Rust")]
    public class ArrowRaiding : RustPlugin
    {
        #region Variables
        private readonly string permission_use = "arrowraiding.use";
        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(permission_use, this);
        } 

        void OnEntityTakeDamage(Door entity, HitInfo info)
        {
            if(info.Weapon == null || !info.IsProjectile() || info.InitiatorPlayer == null || !entity.PrefabName.Contains("wood") || !info.InitiatorPlayer.IPlayer.HasPermission(permission_use)) return;
            ArrowDamage BaseDamage;
            if(!_config.ArrowDamage.TryGetValue(info.ProjectilePrefab.name, out BaseDamage)) return; 
            float Mult; 
            if(!_config.BowMultipliers.TryGetValue(info.Weapon.ShortPrefabName, out Mult)) Mult = 1;
            info.damageTypes.Set(Rust.DamageType.Arrow, Core.Random.Range(BaseDamage.MinDamage, BaseDamage.MaxDamage + 1) * Mult);
        }
        #endregion

        #region Configuration & Language
        public ConfigFile _config;

        public class ArrowDamage
        {
            [JsonProperty("Minimum Damage")]
            public float MinDamage;
            [JsonProperty("Maximum Damage")]
            public float MaxDamage;
        }

        public class ConfigFile
        {
            [JsonProperty("Arrow Damage")]
            public Dictionary<string, ArrowDamage> ArrowDamage;

            [JsonProperty("Weapon Multipliers")]
            public Dictionary<string, float> BowMultipliers;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                   ArrowDamage = new Dictionary<string, ArrowDamage>
                   {
                       {"arrow_wooden", new ArrowDamage{ MinDamage = 1f, MaxDamage = 2f}},
                       {"arrow_bone", new ArrowDamage{ MinDamage = 3f, MaxDamage = 5f}},
                       {"arrow_hv", new ArrowDamage{ MinDamage = 0.5f, MaxDamage = 1f}},
                       {"arrow_fire", new ArrowDamage{ MinDamage = 5f, MaxDamage = 6f}}
                   },
                   BowMultipliers = new Dictionary<string, float>
                   {
                       {"bow_hunting.entity", 1f},
                       {"compound_bow.entity", 1.5f},
                       {"crossbow.entity", 2f}
                   },
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if(_config == null)
            {
                LoadDefaultConfig();
            }
        }
    
        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }
    
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: ArrowRaiding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-ambush ---
// --- Original File Path: A/AntiAmbush/AntiAmbush.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiAmbush", "Cortex Network ~ Infamy", "1.0.0")]
    [Description("Notifies a player when they are being aimed at after a specified time")]

    class AntiAmbush : RustPlugin
    {
        private Dictionary<ulong, float> playerAimingTimestamps = new Dictionary<ulong, float>();
        private Dictionary<ulong, BasePlayer> aimedPlayers = new Dictionary<ulong, BasePlayer>();

        private float AimingDelay => Config.Get<float>("AimingDelay");

        protected override void LoadDefaultConfig()
        {
            Config["AimingDelay"] = 3.0f;
            SaveConfig();
        }

        private void Init()
        {
            timer.Every(0.1f, () =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    CheckPlayerAiming(player);
                }
            });
        }

        private void CheckPlayerAiming(BasePlayer player)
        {
            if (player.isMounted || player.IsDead() || player.GetHeldEntity() == null)
            {
                return;
            }

            bool isAiming = player.serverInput.IsDown(BUTTON.FIRE_SECONDARY);
            BasePlayer aimedPlayer = GetAimedPlayer(player);

            if (isAiming && aimedPlayer != null)
            {
                if (!playerAimingTimestamps.ContainsKey(player.userID))
                {
                    playerAimingTimestamps[player.userID] = Time.time;
                    aimedPlayers[player.userID] = aimedPlayer;
                }
            }

            if (playerAimingTimestamps.ContainsKey(player.userID) && Time.time - playerAimingTimestamps[player.userID] >= AimingDelay)
            {
                aimedPlayer = aimedPlayers[player.userID];
                NotifyAimedPlayer(aimedPlayer, player);
                playerAimingTimestamps.Remove(player.userID);
                aimedPlayers.Remove(player.userID);
            }
        }

        private BasePlayer GetAimedPlayer(BasePlayer player)
        {
            RaycastHit hit;
            if (Physics.Raycast(player.eyes.position, player.eyes.HeadForward(), out hit, Mathf.Infinity, LayerMask.GetMask("Player (Server)")))
            {
                BasePlayer aimedPlayer = hit.collider.GetComponentInParent<BasePlayer>();
                if (aimedPlayer != null && aimedPlayer != player)
                {
                    return aimedPlayer;
                }
            }

            return null;
        }

        private void NotifyAimedPlayer(BasePlayer aimedPlayer, BasePlayer aimer)
        {
            PrintToChat(aimedPlayer, "Warning! " + aimer.displayName + " is aiming at you!");
        }
    }
}


// --- End of file: AntiAmbush.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/automated-workcarts ---
// --- Original File Path: A/AutomatedWorkcarts/AutomatedWorkcarts.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using static BaseEntity;
using static TrainCar;
using static TrainEngine;
using static TrainTrackSpline;

namespace Oxide.Plugins
{
    [Info("Automated Workcarts", "WhiteThunder", "0.34.3")]
    [Description("Automates workcarts with NPC conductors.")]
    internal class AutomatedWorkcarts : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin CargoTrainEvent;

        private const string PermissionToggle = "automatedworkcarts.toggle";
        private const string PermissionManageTriggers = "automatedworkcarts.managetriggers";

        private const string ShopkeeperPrefab = "assets/prefabs/npc/bandit/shopkeepers/bandit_shopkeeper.prefab";
        private const string GenericMapMarkerPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string VendingMapMarkerPrefab = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string ExplosionMapMakerPrefab = "assets/prefabs/tools/map/explosionmarker.prefab";
        private const string CrateMarkerPrefab = "assets/prefabs/tools/map/cratemarker.prefab";
        private const string BradleyExplosionEffectPrefab = "assets/prefabs/npc/m2bradley/effects/bradley_explosion.prefab";

        private static readonly FieldInfo TrainCouplingIsValidField = typeof(TrainCoupling).GetField("isValid", BindingFlags.NonPublic | BindingFlags.Instance)
            ?? typeof(TrainCoupling).GetField("isValid", BindingFlags.Public | BindingFlags.Instance);

        private readonly object False = false;
        private static readonly Regex IdRegex = new("\\$id", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        private readonly BasePlayer[] _playerQueryResults = new BasePlayer[64];

        private Configuration _config;
        private StoredPluginData _data;
        private StoredTunnelData _tunnelData;
        private StoredMapData _mapData;

        private readonly SpawnedTrainCarTracker _spawnedTrainCarTracker = new();
        private readonly DisableSpawnPointManager _disableSpawnPointManager = new();
        private readonly TriggerManager _triggerManager;
        private readonly TrainManager _trainManager;
        private readonly RouteManager _routeManager;
        private readonly ColorMarkerUpdateManager _colorMarkerUpdateManager;

        private Coroutine _startupCoroutine;
        private Timer _showStatesTimer;

        public AutomatedWorkcarts()
        {
            _trainManager = new TrainManager(this, _spawnedTrainCarTracker);
            _triggerManager = new TriggerManager(this, _trainManager);
            _routeManager = new RouteManager(this);
            _colorMarkerUpdateManager = new ColorMarkerUpdateManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init();
            _data = StoredPluginData.Load();
            _tunnelData = StoredTunnelData.Load();

            permission.RegisterPermission(PermissionToggle, this);
            permission.RegisterPermission(PermissionManageTriggers, this);

            if (!_config.MapMarkers.AnyColorsEnabled)
            {
                Unsubscribe(nameof(OnPlayerConnected));
            }
        }

        private void OnServerInitialized()
        {
            _mapData = StoredMapData.Load();
            _startupCoroutine = ServerMgr.Instance.StartCoroutine(new TrackedCoroutine(this).WithEnumerator(DoStartupRoutine()));
        }

        private void Unload()
        {
            if (_startupCoroutine != null)
            {
                ServerMgr.Instance.StopCoroutine(_startupCoroutine);
            }

            OnServerSave();
            _triggerManager.DestroyAll();
            _trainManager.Unload();
            _disableSpawnPointManager.Unload();
            _routeManager.Unload();
            _colorMarkerUpdateManager.Unload();
        }

        private void OnServerSave()
        {
            if (_trainManager.UpdateTrainEngineData())
            {
                _data.Save();
            }
            else
            {
                _data.SaveIfDirty();
            }
        }

        private void OnNewSave()
        {
            _data = StoredPluginData.Clear();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            _colorMarkerUpdateManager.Restart();
        }

        private object OnTrainCarUncouple(TrainCar trainCar, BasePlayer player)
        {
            // Disallow uncoupling train cars from automated trains.
            return _trainManager.HasTrainController(trainCar)
                ? False
                : null;
        }

        #endregion

        #region Commands

        [Command("aw.toggle")]
        private void CommandAutomateTrain(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer
                || !VerifyPermission(player, PermissionToggle))
                return;

            var basePlayer = player.Object as BasePlayer;

            var trainCar = GetTrainCarWhereAiming(basePlayer);
            if (trainCar == null)
            {
                ReplyToPlayer(player, Lang.ErrorNoWorkcartFound);
                return;
            }

            var trainController = _trainManager.GetTrainController(trainCar);
            if (trainController == null)
            {
                var leadTrainEngine = GetLeadTrainEngine(trainCar);
                if (leadTrainEngine == null)
                {
                    ReplyToPlayer(player, Lang.ErrorNoWorkcart);
                    return;
                }

                if (IsTrainOwned(trainCar))
                {
                    ReplyToPlayer(player, Lang.ErrorWorkcartOwned);
                    return;
                }

                if (!_trainManager.CanHaveMoreConductors())
                {
                    ReplyToPlayer(player, Lang.ErrorMaxConductors, _trainManager.CountedConductors, _config.MaxConductors);
                    return;
                }

                TrainEngineData trainEngineData = null;

                if (args.Length > 0)
                {
                    var routeName = GetRouteNameFromArg(args[0], requirePrefix: false);
                    if (!string.IsNullOrWhiteSpace(routeName))
                    {
                        trainEngineData = new TrainEngineData { Route = routeName };
                    }
                }

                if (_trainManager.TryCreateTrainController(leadTrainEngine, trainEngineData: trainEngineData))
                {
                    var baseMessage = trainEngineData != null
                        ? GetMessage(player, Lang.ToggleOnWithRouteSuccess, trainEngineData.Route)
                        : GetMessage(player, Lang.ToggleOnSuccess);

                    player.Reply(baseMessage + " " + GetConductorCountMessage(player));

                    if (player.HasPermission(PermissionManageTriggers))
                    {
                        if (trainEngineData?.Route != null)
                        {
                            _triggerManager.SetPlayerDisplayedRoute(basePlayer, trainEngineData.Route);
                        }

                        _triggerManager.ShowAllRepeatedly(basePlayer);
                    }
                }
                else
                {
                    ReplyToPlayer(player, Lang.ErrorAutomateBlocked);
                }
            }
            else
            {
                _trainManager.KillTrainController(trainCar);
                player.Reply(GetMessage(player, Lang.ToggleOffSuccess) + " " + GetConductorCountMessage(player));
            }
        }

        [Command("aw.resetall")]
        private void CommandResetTrains(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer
                && !VerifyPermission(player, PermissionToggle))
                return;

            var trainCount = _trainManager.ResetAll();
            ReplyToPlayer(player, Lang.ResetAllSuccess, trainCount);
        }

        [Command("aw.addtrigger", "awt.add")]
        private void CommandAddTrigger(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer
                || !VerifyPermission(player, PermissionManageTriggers))
                return;

            if (!_config.EnableMapTriggers)
            {
                ReplyToPlayer(player, Lang.ErrorMapTriggersDisabled);
                return;
            }

            if (!VerifyAimingAtTrackPosition(player, out var trackPosition))
                return;

            var triggerData = new TriggerData { Position = trackPosition };
            AddTriggerShared(player, cmd, args, triggerData);
        }

        [Command("aw.addtunneltrigger", "awt.addt")]
        private void CommandAddTunnelTrigger(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer
                || !VerifyPermission(player, PermissionManageTriggers))
                return;

            if (!VerifyAimingAtTrackPosition(player, out var trackPosition)
                || !VerifySupportedNearbyTrainTunnel(player, trackPosition, out var dungeonCellWrapper))
                return;

            if (!_config.IsTunnelTypeEnabled(dungeonCellWrapper.TunnelType))
            {
                ReplyToPlayer(player, Lang.ErrorTunnelTypeDisabled, dungeonCellWrapper.TunnelType);
                return;
            }

            var triggerData = new TriggerData
            {
                TunnelType = dungeonCellWrapper.TunnelType.ToString(),
                Position = dungeonCellWrapper.InverseTransformPoint(trackPosition),
            };

            AddTriggerShared(player, cmd, args, triggerData, dungeonCellWrapper);
        }

        private void AddTriggerShared(IPlayer player, string cmd, string[] args, TriggerData triggerData, DungeonCellWrapper dungeonCellWrapper = null)
        {
            foreach (var arg in args)
            {
                if (!VerifyValidArgAndModifyTrigger(player, cmd, arg, triggerData, Lang.AddTriggerSyntax))
                    return;
            }

            if (!triggerData.IsSpawner
                && !triggerData.AddConductor
                && !triggerData.Destroy
                && triggerData.GetTrackSelectionInstruction() == null
                && triggerData.GetSpeedInstruction() == null
                && triggerData.GetDirectionInstruction() == null)
            {
                triggerData.Speed = EngineSpeeds.Zero.ToString();
            }

            var basePlayer = player.Object as BasePlayer;

            if (triggerData.IsSpawner)
            {
                var rotation = Quaternion.Euler(basePlayer.viewAngles);
                if (dungeonCellWrapper != null)
                {
                    rotation *= Quaternion.Inverse(dungeonCellWrapper.Rotation);
                }

                triggerData.RotationAngle = rotation.eulerAngles.y % 360;
            }

            _triggerManager.AddTrigger(triggerData);

            if (triggerData.Route != null)
            {
                _triggerManager.SetPlayerDisplayedRoute(basePlayer, triggerData.Route);
            }

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.AddTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.updatetrigger", "awt.update")]
        private void CommandUpdateTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.UpdateTriggerSyntax, out var triggerData, out var optionArgs))
                return;

            if (optionArgs.Length == 0)
            {
                ReplyToPlayer(player, Lang.UpdateTriggerSyntax, cmd, GetTriggerOptions(player));
                return;
            }

            var newTriggerData = triggerData.Clone();
            foreach (var arg in optionArgs)
            {
                if (!VerifyValidArgAndModifyTrigger(player, cmd, arg, newTriggerData, Lang.UpdateTriggerSyntax))
                    return;
            }

            _triggerManager.UpdateTrigger(triggerData, newTriggerData);

            var basePlayer = player.Object as BasePlayer;
            if (triggerData.Route != null)
            {
                _triggerManager.SetPlayerDisplayedRoute(basePlayer, triggerData.Route);
            }

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.replacetrigger", "awt.replace")]
        private void CommandReplaceTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.UpdateTriggerSyntax, out var triggerData, out var optionArgs))
                return;

            if (optionArgs.Length == 0)
            {
                ReplyToPlayer(player, Lang.UpdateTriggerSyntax, cmd, GetTriggerOptions(player));
                return;
            }

            var newTriggerData = new TriggerData();
            foreach (var arg in optionArgs)
            {
                if (!VerifyValidArgAndModifyTrigger(player, cmd, arg, newTriggerData, Lang.UpdateTriggerSyntax))
                    return;
            }

            _triggerManager.UpdateTrigger(triggerData, newTriggerData);

            var basePlayer = player.Object as BasePlayer;
            if (triggerData.Route != null)
            {
                _triggerManager.SetPlayerDisplayedRoute(basePlayer, triggerData.Route);
            }

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.enabletrigger", "awt.enable")]
        private void CommandEnableTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            var newTriggerData = triggerData.Clone();
            newTriggerData.Enabled = true;
            _triggerManager.UpdateTrigger(triggerData, newTriggerData);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.disabletrigger", "awt.disable")]
        private void CommandDisableTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            var newTriggerData = triggerData.Clone();
            newTriggerData.Enabled = false;
            _triggerManager.UpdateTrigger(triggerData, newTriggerData);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.movetrigger", "awt.move")]
        private void CommandMoveTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            if (!VerifyAimingAtTrackPosition(player, out var trackPosition))
                return;

            if (triggerData.TriggerType == TrainTriggerType.Tunnel)
            {
                if (!VerifySupportedNearbyTrainTunnel(player, trackPosition, out var dungeonCellWrapper))
                    return;

                if (dungeonCellWrapper.TunnelType != triggerData.GetTunnelType())
                {
                    ReplyToPlayer(player, Lang.ErrorUnsupportedTunnel);
                    return;
                }

                trackPosition = dungeonCellWrapper.InverseTransformPoint(trackPosition);
            }

            _triggerManager.MoveTrigger(triggerData, trackPosition);

            var basePlayer = player.Object as BasePlayer;
            if (triggerData.Route != null)
            {
                _triggerManager.SetPlayerDisplayedRoute(basePlayer, triggerData.Route);
            }

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.MoveTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.removetrigger", "awt.remove")]
        private void CommandRemoveTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            _triggerManager.RemoveTrigger(triggerData);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.RemoveTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.rotatetrigger", "awt.rotate")]
        private void CommandSetTriggerRotation(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            var basePlayer = player.Object as BasePlayer;
            var playerPosition = basePlayer.transform.position;

            var triggerInstance = _triggerManager.FindNearestTrigger(playerPosition, triggerData);
            var rotation = Quaternion.Euler(basePlayer.viewAngles);
            var needsRespawn = false;

            if (triggerInstance.Spline != null)
            {
                rotation = GetSplineTangentRotation(triggerInstance.Spline, triggerInstance.DistanceOnSpline, rotation);

                if (Vector3.Dot(triggerInstance.SpawnRotation * Vector3.forward, rotation * Vector3.forward) < 0)
                {
                    needsRespawn = true;
                }
            }

            if (triggerInstance is TunnelTriggerInstance tunnelTriggerInstance)
            {
                rotation *= Quaternion.Inverse(tunnelTriggerInstance.DungeonCellWrapper.Rotation);
            }

            _triggerManager.RotateTrigger(triggerData, rotation.eulerAngles.y % 360);

            if (needsRespawn)
            {
                _triggerManager.RespawnTrigger(triggerData);
            }

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.RotateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.respawntrigger", "awt.respawn")]
        private void CommandRespawnTrigger(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.SimpleTriggerSyntax, out var triggerData, out _))
                return;

            if (!triggerData.IsSpawner)
            {
                ReplyToPlayer(player, Lang.ErrorRequiresSpawnTrigger);
                return;
            }

            if (!triggerData.Enabled)
            {
                ReplyToPlayer(player, Lang.ErrorTriggerDisabled);
                return;
            }

            _triggerManager.RespawnTrigger(triggerData);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
        }

        [Command("aw.addtriggercommand", "awt.addcommand", "awt.addcmd")]
        private void CommandAddCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.AddCommandSyntax, out var triggerData, out var optionArgs))
                return;

            if (optionArgs.Length < 1)
            {
                ReplyToPlayer(player, Lang.AddCommandSyntax, cmd);
                return;
            }

            var quotedCommands = optionArgs.Select(command => command.Contains(" ") ? $"\"{command}\"" : command).ToArray();
            _triggerManager.AddTriggerCommand(triggerData, string.Join(" ", quotedCommands));

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.removetriggercommand", "awt.removecommand", "awt.removecmd")]
        private void CommandRemoveCommand(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.RemoveCommandSyntax, out var triggerData, out var optionArgs))
                return;

            if (optionArgs.Length < 1 || !int.TryParse(optionArgs[0], out var commandIndex))
            {
                ReplyToPlayer(player, Lang.RemoveCommandSyntax, cmd);
                return;
            }

            if (commandIndex < 1 || commandIndex > triggerData.Commands.Count)
            {
                ReplyToPlayer(player, Lang.RemoveCommandErrorIndex, commandIndex);
                return;
            }

            _triggerManager.RemoveTriggerCommand(triggerData, commandIndex - 1);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.settriggertrain", "awt.train")]
        private void CommandTriggerTrain(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyCanModifyTrigger(player, cmd, args, Lang.RemoveCommandSyntax, out var triggerData, out var optionArgs))
                return;

            var trainCarAliases = new List<string>();
            foreach (var arg in optionArgs)
            {
                var trainCarPrefab = TrainCarPrefab.FindPrefab(arg);
                if (trainCarPrefab == null)
                {
                    ReplyToPlayer(player, Lang.ErrorUnrecognizedTrainCar, arg);
                    return;
                }

                trainCarAliases.Add(trainCarPrefab.TrainCarAlias);
            }

            var newTriggerData =  triggerData.Clone();
            newTriggerData.TrainCars = trainCarAliases.ToArray();
            _triggerManager.UpdateTrigger(triggerData, newTriggerData);

            var basePlayer = player.Object as BasePlayer;
            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, Lang.UpdateTriggerSuccess, GetTriggerPrefix(player, triggerData), triggerData.Id);
        }

        [Command("aw.showtriggers", "awt.show")]
        private void CommandShowTriggers(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer
                || !VerifyPermission(player, PermissionManageTriggers)
                || !VerifyAnyTriggers(player))
                return;

            var duration = 60;
            string routeName = null;

            foreach (var arg in args)
            {
                if (duration == 60)
                {
                    if (int.TryParse(arg, out var argIntValue))
                    {
                        duration = argIntValue;
                        continue;
                    }
                }

                if (routeName == null)
                {
                    var routeNameArg = GetRouteNameFromArg(arg, requirePrefix: false);
                    if (!string.IsNullOrWhiteSpace(routeNameArg))
                        routeName = routeNameArg;
                }
            }

            var basePlayer = player.Object as BasePlayer;

            _triggerManager.SetPlayerDisplayedRoute(basePlayer, routeName);
            _triggerManager.ShowAllRepeatedly(basePlayer, duration);

            if (routeName != null)
            {
                ReplyToPlayer(player, Lang.ShowTriggersWithRouteSuccess, routeName, FormatTime(duration));
            }
            else
            {
                ReplyToPlayer(player, Lang.ShowTriggersSuccess, FormatTime(duration));
            }
        }

        // Debugging command, usable by one player at a time.
        [Command("aw.showstates")]
        private void CommandShowStates(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer
                || !VerifyPermission(player, PermissionManageTriggers)
                || !VerifyAnyTriggers(player))
                return;

            if (args.Length < 1 || !int.TryParse(args[0], out var duration))
            {
                duration = 60;
            }

            var drawDuration = 0.5f;
            var maxDistanceSquared = Mathf.Pow(_config.TriggerDisplayDistance, 2);
            var basePlayer = player.Object as BasePlayer;

            _showStatesTimer?.Destroy();
            _showStatesTimer = timer.Repeat(drawDuration, Mathf.RoundToInt(duration / drawDuration), () =>
            {
                if (basePlayer == null || basePlayer.IsDestroyed || !basePlayer.IsConnected)
                {
                    _showStatesTimer.Destroy();
                    _showStatesTimer = null;
                    return;
                }

                _trainManager.ShowNearbyTrainStates(basePlayer, maxDistanceSquared, drawDuration);
            });
        }

        #endregion

        #region API

        [HookMethod(nameof(API_AutomateWorkcart))]
        public bool API_AutomateWorkcart(TrainEngine trainEngine)
        {
            return _trainManager.HasTrainController(trainEngine)
                || _trainManager.TryCreateTrainController(trainEngine);
        }

        [HookMethod(nameof(API_StopAutomatingWorkcart))]
        public void API_StopAutomatingWorkcart(TrainEngine trainEngine)
        {
            _trainManager.KillTrainController(trainEngine);
        }

        [HookMethod(nameof(API_IsWorkcartAutomated))]
        public bool API_IsWorkcartAutomated(TrainEngine trainEngine)
        {
            return _trainManager.HasTrainController(trainEngine);
        }

        [HookMethod(nameof(API_GetAutomatedWorkcarts))]
        public TrainEngine[] API_GetAutomatedWorkcarts()
        {
            return _trainManager.GetAutomatedTrainEngines();
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnWorkcartAutomationStart(TrainEngine trainEngine)
            {
                return Interface.CallHook("OnWorkcartAutomationStart", trainEngine);
            }

            public static void OnWorkcartAutomationStarted(TrainEngine trainEngine)
            {
                Interface.CallHook("OnWorkcartAutomationStarted", trainEngine);
            }

            public static void OnWorkcartAutomationStopped(TrainEngine trainEngine)
            {
                Interface.CallHook("OnWorkcartAutomationStopped", trainEngine);
            }
        }

        #endregion

        #region Dependencies

        private bool IsCargoTrain(TrainEngine trainEngine)
        {
            return CargoTrainEvent?.Call("IsTrainSpecial", trainEngine.net.ID) is true;
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermission(IPlayer player, string permissionName)
        {
            if (player.HasPermission(permissionName))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoPermission);
            return false;
        }

        private bool VerifyAnyTriggers(IPlayer player)
        {
            if (_mapData.MapTriggers.Count > 0
                || _tunnelData.TunnelTriggers.Count > 0)
                return true;

            ReplyToPlayer(player, Lang.ErrorNoTriggers);
            return false;
        }

        private bool VerifyTriggerExists(IPlayer player, int triggerId, TrainTriggerType triggerType, out TriggerData triggerData)
        {
            triggerData = _triggerManager.FindTrigger(triggerId, triggerType);
            if (triggerData != null)
                return true;

            _triggerManager.ShowAllRepeatedly(player.Object as BasePlayer);
            ReplyToPlayer(player, Lang.ErrorTriggerNotFound, GetTriggerPrefix(player, triggerType), triggerId);
            return false;
        }

        private bool VerifyAimingAtTrackPosition(IPlayer player, out Vector3 trackPosition)
        {
            if (TryGetTrackPosition(player.Object as BasePlayer, out trackPosition))
                return true;

            ReplyToPlayer(player, Lang.ErrorNoTrackFound);
            return false;
        }

        private bool IsTriggerArg(IPlayer player, string arg, out int triggerId, out TrainTriggerType triggerType)
        {
            triggerType = TrainTriggerType.Map;
            triggerId = 0;

            if (arg.StartsWith("#"))
            {
                arg = arg.Substring(1);
            }

            if (arg.Length <= 1)
                return false;

            var triggerPrefix = arg.Substring(0, 1).ToLower();
            var triggerIdString = arg.Substring(1).ToLower();

            if (!int.TryParse(triggerIdString, out triggerId))
                return false;

            if (triggerPrefix == GetTriggerPrefix(player, TrainTriggerType.Tunnel).ToLower())
            {
                triggerType = TrainTriggerType.Tunnel;
                return true;
            }

            if (triggerPrefix == GetTriggerPrefix(player, TrainTriggerType.Map).ToLower())
            {
                triggerType = TrainTriggerType.Map;
                return true;
            }

            return false;
        }

        private bool VerifyTriggerWhereAiming(IPlayer player, string cmd, string[] args, string errorMessageName, out TriggerData triggerData, out string[] optionArgs)
        {
            var basePlayer = player.Object as BasePlayer;
            optionArgs = args;
            triggerData = null;

            triggerData = _triggerManager.FindNearestTriggerWhereAiming(basePlayer)?.TriggerData;
            if (triggerData != null)
                return true;

            _triggerManager.ShowAllRepeatedly(basePlayer);
            ReplyToPlayer(player, errorMessageName, cmd, GetTriggerOptions(player));
            return false;
        }

        private bool VerifyCanModifyTrigger(IPlayer player, string cmd, string[] args, string errorMessageName, out TriggerData triggerData, out string[] optionArgs)
        {
            triggerData = null;
            optionArgs = null;

            if (!VerifyPermission(player, PermissionManageTriggers)
                || !VerifyAnyTriggers(player))
                return false;

            if (args.Length > 0 && IsTriggerArg(player, args[0], out var triggerId, out var triggerType))
            {
                optionArgs = args.Skip(1).ToArray();
                return VerifyTriggerExists(player, triggerId, triggerType, out triggerData);
            }

            if (player.IsServer)
            {
                // Server commands must specify a trigger id.
                ReplyToPlayer(player, errorMessageName, cmd, GetTriggerOptions(player));
                return false;
            }

            return VerifyTriggerWhereAiming(player, cmd, args, errorMessageName, out triggerData, out optionArgs);
        }

        private bool VerifySupportedNearbyTrainTunnel(IPlayer player, Vector3 trackPosition, out DungeonCellWrapper dungeonCellWrapper)
        {
            dungeonCellWrapper = FindNearestDungeonCell(trackPosition);
            if (dungeonCellWrapper == null || dungeonCellWrapper.TunnelType == TunnelType.Unsupported)
            {
                ReplyToPlayer(player, Lang.ErrorUnsupportedTunnel);
                return false;
            }

            return true;
        }

        private bool VerifyValidArgAndModifyTrigger(IPlayer player, string cmd, string arg, TriggerData triggerData, string errorMessageName)
        {
            var argLower = arg.ToLower();
            if (argLower is "start" or "conductor")
            {
                triggerData.AddConductor = true;
                return true;
            }

            if (argLower.StartsWith("brake"))
            {
                triggerData.Brake = true;
                return true;
            }

            if (argLower.StartsWith("destroy"))
            {
                triggerData.Destroy = true;
                return true;
            }

            if (argLower.StartsWith("enable"))
            {
                triggerData.Enabled = true;
                return true;
            }

            if (argLower.StartsWith("disable"))
            {
                triggerData.Enabled = false;
                return true;
            }

            var prefab = TrainCarPrefab.FindPrefab(argLower);
            if (prefab != null)
            {
                if (triggerData.TrainCars == null)
                {
                    triggerData.TrainCars = new[] { prefab.TrainCarAlias };
                }
                else
                {
                    var length = triggerData.TrainCars.Length;
                    Array.Resize(ref triggerData.TrainCars, length + 1);
                    triggerData.TrainCars[length] = prefab.TrainCarAlias;
                }

                return true;
            }

            if (arg[^1] == '%' && float.TryParse(arg[..^1], out var percentage))
            {
                triggerData.Chance = Mathf.Clamp(percentage / 100f, 0, 1);
                return true;
            }

            if (float.TryParse(arg, out var stopDuration))
            {
                triggerData.StopDuration = stopDuration;
                return true;
            }

            var routeName = GetRouteNameFromArg(arg, requirePrefix: true);
            if (!string.IsNullOrWhiteSpace(routeName))
            {
                triggerData.Route = routeName;
                return true;
            }

            if (Enum.TryParse(arg, true, out SpeedInstruction speedInstruction))
            {
                var speedString = speedInstruction.ToString();

                // If zero speed is already set, assume this is the departure speed.
                if (triggerData.Speed == SpeedInstruction.Zero.ToString())
                {
                    triggerData.DepartureSpeed = speedString;
                }
                else
                {
                    triggerData.Speed = speedString;
                }

                return true;
            }

            if (Enum.TryParse(arg, true, out DirectionInstruction directionInstruction))
            {
                triggerData.Direction = directionInstruction.ToString();
                return true;
            }

            if (Enum.TryParse(arg, true, out TrackSelectionInstruction trackSelectionInstruction))
            {
                triggerData.TrackSelection = trackSelectionInstruction.ToString();
                return true;
            }

            ReplyToPlayer(player, errorMessageName, cmd, GetTriggerOptions(player));
            return false;
        }

        #endregion

        #region Helper Methods - Coupling

        private static void UpdateAllowedCouplings(TrainCar trainCar, bool allowFront, bool allowRear)
        {
            var coupling = trainCar.coupling;
            var frontCoupling = coupling.frontCoupling;
            var rearCoupling = coupling.rearCoupling;

            if (trainCar.frontCoupling == null || trainCar.rearCoupling == null)
            {
                // Some train cars do not allow coupling, such as the classic workcart.
                return;
            }

            if (!allowFront && frontCoupling.IsCoupled)
            {
                frontCoupling.Uncouple(reflect: true);
            }

            if (!allowRear && rearCoupling.IsCoupled)
            {
                rearCoupling.Uncouple(reflect: true);
            }

            if (frontCoupling.isValid != allowFront)
            {
                TrainCouplingIsValidField.SetValue(frontCoupling, allowFront);
            }

            if (rearCoupling.isValid != allowRear)
            {
                TrainCouplingIsValidField.SetValue(rearCoupling, allowRear);
            }
        }

        private static void DisableTrainCoupling(CompleteTrain completeTrain)
        {
            var firstTrainCar = completeTrain.trainCars.FirstOrDefault();
            var lastTrainCar = completeTrain.trainCars.LastOrDefault();
            if (firstTrainCar == null || lastTrainCar == null)
                return;

            UpdateAllowedCouplings(firstTrainCar, firstTrainCar.coupling.IsFrontCoupled, firstTrainCar.coupling.IsRearCoupled);

            if (lastTrainCar != firstTrainCar)
            {
                UpdateAllowedCouplings(lastTrainCar, lastTrainCar.coupling.IsFrontCoupled, lastTrainCar.coupling.IsRearCoupled);
            }
        }

        private static void EnableTrainCoupling(CompleteTrain completeTrain)
        {
            var firstTrainCar = completeTrain.trainCars.FirstOrDefault();
            var lastTrainCar = completeTrain.trainCars.LastOrDefault();
            if (firstTrainCar == null || lastTrainCar == null)
                return;

            UpdateAllowedCouplings(firstTrainCar, allowFront: true, allowRear: true);

            if (lastTrainCar != firstTrainCar)
            {
                UpdateAllowedCouplings(lastTrainCar, allowFront: true, allowRear: true);
            }
        }

        #endregion

        #region Helper Methods

        private static void LogError(string message) => Interface.Oxide.LogError($"[Automated Workcarts] {message}");
        private static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Automated Workcarts] {message}");

        private static int GetNextTriggerId(List<TriggerData> triggerList)
        {
            var highestTriggerId = 0;

            foreach (var triggerData in triggerList)
            {
                highestTriggerId = Math.Max(highestTriggerId, triggerData.Id);
            }

            return highestTriggerId + 1;
        }

        private static string GetRouteNameFromArg(string routeName, bool requirePrefix = true)
        {
            if (routeName.StartsWith("@"))
                return routeName[1..];

            return requirePrefix ? null : routeName;
        }

        private static float GetThrottleFraction(EngineSpeeds throttle)
        {
            switch (throttle)
            {
                case EngineSpeeds.Rev_Hi: return -1;
                case EngineSpeeds.Rev_Med: return -0.5f;
                case EngineSpeeds.Rev_Lo: return -0.2f;
                case EngineSpeeds.Fwd_Lo: return 0.2f;
                case EngineSpeeds.Fwd_Med: return 0.5f;
                case EngineSpeeds.Fwd_Hi: return 1;
                default: return 0;
            }
        }

        private static TrainEngine GetLeadTrainEngine(CompleteTrain completeTrain)
        {
            if (completeTrain.PrimaryTrainCar == completeTrain.trainCars[0])
            {
                for (var i = 0; i < completeTrain.trainCars.Count; i++)
                {
                    var trainEngine = completeTrain.trainCars[i] as TrainEngine;
                    if ((object)trainEngine != null)
                        return trainEngine;
                }
            }
            else
            {
                for (var i = completeTrain.trainCars.Count - 1; i >= 0; i--)
                {
                    var trainEngine = completeTrain.trainCars[i] as TrainEngine;
                    if ((object)trainEngine != null)
                        return trainEngine;
                }
            }

            return null;
        }

        private static TrainEngine GetLeadTrainEngine(TrainCar trainCar)
        {
            var trainEngine = trainCar as TrainEngine;
            if (trainEngine != null)
                return trainEngine;

            return GetLeadTrainEngine(trainCar.completeTrain);
        }

        private static void DetermineTrainCarOrientations(TrainCar trainCar, Vector3 forward, TrainCar otherTrainCar, out TrainCar forwardTrainCar)
        {
            var position = trainCar.transform.position;
            var otherPosition = otherTrainCar.transform.position;
            var forwardPosition = position + forward * 100f;

            forwardTrainCar = trainCar;

            if ((forwardPosition - position).sqrMagnitude > (forwardPosition - otherPosition).sqrMagnitude)
            {
                forwardTrainCar = otherTrainCar;
            }
        }

        private static Vector3 GetTrainCarForward(TrainCar trainCar)
        {
            return trainCar.GetTrackSpeed() >= 0
                ? trainCar.transform.forward
                : -trainCar.transform.forward;
        }

        private static void EnableInvincibility(TrainCar trainCar)
        {
            trainCar.initialSpawnTime = float.MaxValue;
        }

        private static void DisableInvincibility(TrainCar trainCar)
        {
            trainCar.initialSpawnTime = Time.time;
        }

        private static void EnableSavingRecursive(BaseEntity entity, bool enableSaving)
        {
            entity.EnableSaving(enableSaving);

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    continue;

                EnableSavingRecursive(child, enableSaving);
            }
        }

        private static TrainCar SpawnTrainCar(string prefabName, Vector3 position, Quaternion rotation)
        {
            var trainCar = GameManager.server.CreateEntity(prefabName, position, rotation) as TrainCar;
            if (trainCar == null)
                return null;

            // Ensure the train car does not decay for some time.
            trainCar.lastDecayTick = Time.realtimeSinceStartup;

            trainCar.limitNetworking = true;
            trainCar.EnableSaving(false);
            trainCar.Spawn();

            if (trainCar.IsDestroyed)
                return null;

            // Don't let the train kill itself if there isn't quite enough space.
            trainCar.CancelInvoke(trainCar.KillMessage);

            trainCar.Invoke(() => EnableSavingRecursive(trainCar, false), 0);

            return trainCar;
        }

        private static float GetSplineDistance(TrainTrackSpline spline, Vector3 position)
        {
            spline.GetDistance(position, 1, out var distanceOnSpline);
            return distanceOnSpline;
        }

        private static TrainCar AddTrainCar(TrainCar frontTrainCar, TrainCarPrefab frontTrainCarPrefab, TrainCarPrefab trainCarPrefab, TrackSelection trackSelection)
        {
            var rearCouplingTransform = frontTrainCarPrefab.Reverse
                ? frontTrainCar.frontCoupling
                : frontTrainCar.rearCoupling;

            if (rearCouplingTransform == null)
                return null;

            var rearWheelPos = frontTrainCarPrefab.Reverse
                ? frontTrainCar.GetFrontWheelPos()
                : frontTrainCar.GetRearWheelPos();

            var wheelToRearCouplingDistance = Math.Abs(rearWheelPos.z - rearCouplingTransform.position.z);

            var rearSpline = frontTrainCarPrefab.Reverse
                ? frontTrainCar.FrontTrackSection
                : frontTrainCar.RearTrackSection;

            var rearWheelDistanceOnSpline = GetSplineDistance(rearSpline, rearWheelPos);

            var frontTrainCarForward = frontTrainCarPrefab.Reverse
                ? -frontTrainCar.transform.forward
                : frontTrainCar.transform.forward;

            var askerIsForward = rearSpline.IsForward(frontTrainCarForward, rearWheelDistanceOnSpline);
            var splineInfo = new SplineInfo
            {
                Spline = rearSpline,
                Distance = rearWheelDistanceOnSpline,
                Ascending = !askerIsForward,
                IsForward = askerIsForward,
            };

            // Spawn the train slightly farther away so it has space. It will be moved forward after spawn.
            var spawnDistanceOffset = 2;

            var finalDistance = wheelToRearCouplingDistance + GetTrainCarFrontCouplingOffsetZ(trainCarPrefab);

            var finalPosition = GetPositionAlongTrack(splineInfo, finalDistance, trackSelection, out var finalSplineInfo);

            var resultPosition = GetPositionAlongTrack(finalSplineInfo, spawnDistanceOffset, trackSelection, out var spawnSplineInfo);
            var resultRotation = GetSplineTangentRotation(spawnSplineInfo.Spline, spawnSplineInfo.Distance, frontTrainCar.transform.rotation);

            if (trainCarPrefab.Reverse != frontTrainCarPrefab.Reverse)
            {
                resultRotation = Quaternion.LookRotation(resultRotation * -Vector3.forward);
            }

            // TODO: Fix issue where workcarts jump on start, when first two are both reverse

            var rearTrainCar = SpawnTrainCar(trainCarPrefab.PrefabPath, resultPosition, resultRotation);
            if (rearTrainCar != null)
            {
                if (rearTrainCar.FrontTrackSection == null)
                {
                    rearTrainCar.Kill();
                    return null;
                }

                rearTrainCar.MoveFrontWheelsAlongTrackSpline(
                    rearTrainCar.FrontTrackSection,
                    rearTrainCar.FrontWheelSplineDist,
                    spawnDistanceOffset,
                    rearTrainCar.RearTrackSection != rearTrainCar.FrontTrackSection ? rearTrainCar.RearTrackSection : null,
                    trackSelection
                );

                rearTrainCar.transform.position = finalPosition;

                var frontCoupling = frontTrainCarPrefab.Reverse
                    ? frontTrainCar.coupling.frontCoupling
                    : frontTrainCar.coupling.rearCoupling;

                var rearCoupling = trainCarPrefab.Reverse
                    ? rearTrainCar.coupling.rearCoupling
                    : rearTrainCar.coupling.frontCoupling;

                frontCoupling.TryCouple(rearCoupling, reflect: true);
            }

            return rearTrainCar;
        }

        private static float GetTrainCarFrontCouplingOffsetZ(TrainCarPrefab trainCarPrefab)
        {
            var prefab = GameManager.server.FindPrefab(trainCarPrefab.PrefabPath)?.GetComponent<TrainCar>();
            if (prefab == null)
                return 0;

            return trainCarPrefab.Reverse
                ? prefab.rearCoupling.localPosition.z
                : prefab.frontCoupling.localPosition.z;
        }

        private static ConnectedTrackInfo GetAdjacentTrackInfo(TrainTrackSpline spline, TrackSelection selection, bool isAscending = true, bool askerIsForward = true)
        {
            var trackOptions = isAscending
                ? spline.nextTracks
                : spline.prevTracks;

            if (trackOptions.Count == 0)
                return null;

            if (trackOptions.Count == 1)
                return trackOptions[0];

            switch (selection)
            {
                case TrackSelection.Left:
                    return isAscending == askerIsForward
                        ? trackOptions.FirstOrDefault()
                        : trackOptions.LastOrDefault();

                case TrackSelection.Right:
                    return isAscending == askerIsForward
                        ? trackOptions.LastOrDefault()
                        : trackOptions.FirstOrDefault();

                default:
                    return trackOptions[isAscending ? spline.straightestNextIndex : spline.straightestPrevIndex];
            }
        }

        private static Quaternion GetSplineTangentRotation(TrainTrackSpline spline, float distanceOnSpline, Quaternion approximateRotation)
        {
            spline.GetPositionAndTangent(distanceOnSpline, approximateRotation * Vector3.forward, out var tangentDirection);
            return Quaternion.LookRotation(tangentDirection);
        }

        private static int CompareVectors(Vector3 a, Vector3 b)
        {
            var result = a.y.CompareTo(b.y);
            if (result != 0)
                return result;

            result = a.x.CompareTo(b.x);
            if (result != 0)
                return result;

            return a.z.CompareTo(b.z);
        }

        private IEnumerator DoStartupRoutine()
        {
            if (_config.DisableDefaultTunnelWorkcartSpawnPoints)
                yield return _disableSpawnPointManager.DisableSpawnPointsRoutine();

            yield return _triggerManager.CreateAll();

            var foundTrainEngineIds = new HashSet<ulong>();
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var trainEngine = entity as TrainEngine;
                if (trainEngine == null)
                    continue;

                var trainEngineData = _data.GetTrainEngineData(trainEngine.net.ID.Value);
                if (trainEngineData != null)
                {
                    foundTrainEngineIds.Add(trainEngine.net.ID.Value);

                    var trainEngine2 = trainEngine;
                    var trainEngineData2 = trainEngineData;
                    timer.Once(UnityEngine.Random.Range(0, 1f), () =>
                    {
                        if (trainEngine2 != null
                            && !IsTrainOwned(trainEngine2)
                            && _trainManager.CanHaveMoreConductors()
                            && !_trainManager.HasTrainController(trainEngine2))
                        {
                            _trainManager.TryCreateTrainController(trainEngine2, trainEngineData: trainEngineData2);
                        }
                    });
                }
            }

            _data.TrimToTrainEngineIds(foundTrainEngineIds);
        }

        private bool AutomationWasBlocked(TrainEngine trainEngine)
        {
            if (ExposedHooks.OnWorkcartAutomationStart(trainEngine) is false)
                return true;

            if (IsCargoTrain(trainEngine))
                return true;

            return false;
        }

        private static Vector3 GetPositionAlongTrack(SplineInfo splineInfo, float desiredDistance, TrackSelection trackSelection, out SplineInfo resultSplineInfo, out float remainingDistance)
        {
            resultSplineInfo = splineInfo;
            remainingDistance = desiredDistance;

            var i = 0;

            while (remainingDistance > 0)
            {
                if (i++ > 1000)
                {
                    LogError("Something is wrong. Please contact the plugin developer.");
                    return Vector3.zero;
                }

                var splineLength = resultSplineInfo.Spline.GetLength();
                var newDistanceOnSpline = resultSplineInfo.Ascending
                    ? resultSplineInfo.Distance + remainingDistance
                    : resultSplineInfo.Distance - remainingDistance;

                remainingDistance -= resultSplineInfo.Ascending
                    ? splineLength - resultSplineInfo.Distance
                    : resultSplineInfo.Distance;

                if (newDistanceOnSpline >= 0 && newDistanceOnSpline <= splineLength)
                {
                    // Reached desired distance.
                    resultSplineInfo.Distance = newDistanceOnSpline;
                    return resultSplineInfo.Spline.GetPosition(resultSplineInfo.Distance);
                }

                var adjacentTrackInfo = GetAdjacentTrackInfo(resultSplineInfo.Spline, trackSelection, resultSplineInfo.Ascending, resultSplineInfo.IsForward);
                if (adjacentTrackInfo == null)
                {
                    // Track is a dead end.
                    resultSplineInfo.Distance = resultSplineInfo.Ascending ? splineLength : 0;
                    return resultSplineInfo.Spline.GetPosition(resultSplineInfo.Distance);
                }

                if (adjacentTrackInfo.orientation == TrackOrientation.Reverse)
                {
                    resultSplineInfo.Ascending = !resultSplineInfo.Ascending;
                    resultSplineInfo.IsForward = !resultSplineInfo.IsForward;
                }

                resultSplineInfo.Spline = adjacentTrackInfo.track;
                resultSplineInfo.Distance = resultSplineInfo.Ascending ? 0 : resultSplineInfo.Spline.GetLength();
            }

            return Vector3.zero;
        }

        private static Vector3 GetPositionAlongTrack(SplineInfo splineInfo, float desiredDistance, TrackSelection trackSelection, out SplineInfo resultSplineInfo)
        {
            return GetPositionAlongTrack(splineInfo, desiredDistance, trackSelection, out resultSplineInfo, out var remainingDistance);
        }

        private static bool IsTrainOwned(TrainCar trainCar)
        {
            foreach (var car in trainCar.completeTrain.trainCars)
            {
                if (car.OwnerID != 0)
                    return true;
            }

            return false;
        }

        private static string GetShortName(string prefabName)
        {
            var slashIndex = prefabName.LastIndexOf("/");
            var baseName = (slashIndex == -1) ? prefabName : prefabName.Substring(slashIndex + 1);
            return baseName.Replace(".prefab", "");
        }

        private static bool TryParseEngineSpeed(string speedName, out EngineSpeeds engineSpeed)
        {
            if (Enum.TryParse(speedName, true, out engineSpeed))
                return true;

            engineSpeed = EngineSpeeds.Zero;
            LogError($"Unrecognized engine speed: {speedName}");
            return false;
        }

        private static bool TryParseTrackSelection(string selectionName, out TrackSelection trackSelection)
        {
            if (Enum.TryParse(selectionName, true, out trackSelection))
                return true;

            LogError($"Unrecognized track selection: {selectionName}");
            trackSelection = TrackSelection.Default;
            return false;
        }

        private static string FormatOptions(ICollection<string> optionNames, string delimiter = " | ")
        {
            var formattedOptionNames = new string[optionNames.Count];

            var i = 0;
            foreach (var optionName in optionNames)
            {
                formattedOptionNames[i] = $"<color=#fd4>{optionName}</color>";
                i++;
            }

            return string.Join(delimiter, formattedOptionNames);
        }

        private static string GetEnumOptions<T>()
        {
            return FormatOptions(Enum.GetNames(typeof(T)));
        }

        private static bool TryGetHitPosition(BasePlayer player, out Vector3 position, float maxDistance)
        {
            if (Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, Layers.Solid, QueryTriggerInteraction.Ignore))
            {
                position = hit.point;
                return true;
            }

            position = Vector3.zero;
            return false;
        }

        private static bool TryGetTrackPosition(BasePlayer player, out Vector3 trackPosition, float maxDistance = 30)
        {
            if (!TryGetHitPosition(player, out var hitPosition, maxDistance))
            {
                trackPosition = Vector3.zero;
                return false;
            }

            if (!TryFindTrackNear(hitPosition, 5, out var spline, out var distanceResult))
            {
                trackPosition = Vector3.zero;
                return false;
            }

            trackPosition = spline.GetPosition(distanceResult);
            return true;
        }

        private static TrainTrigger GetHitTrigger(BasePlayer player, float maxDistance = 30)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, 1 << TrainTrigger.TriggerLayer, QueryTriggerInteraction.Collide)
                ? hit.collider.GetComponent<TrainTrigger>()
                : null;
        }

        private static DungeonCellWrapper FindNearestDungeonCell(Vector3 position)
        {
            DungeonGridCell closestDungeon = null;
            var shortestSqrDistance = float.MaxValue;

            foreach (var dungeon in TerrainMeta.Path.DungeonGridCells)
            {
                var dungeonCellWrapper = new DungeonCellWrapper(dungeon);
                if (dungeonCellWrapper.TunnelType == TunnelType.Unsupported)
                    continue;

                if (!dungeonCellWrapper.IsInBounds(position))
                    continue;

                var sqrDistance = (dungeon.transform.position - position).sqrMagnitude;
                if (sqrDistance < shortestSqrDistance)
                {
                    shortestSqrDistance = sqrDistance;
                    closestDungeon = dungeon;
                }
            }

            return closestDungeon == null ? null : new DungeonCellWrapper(closestDungeon);
        }

        private static List<DungeonCellWrapper> FindAllTunnelsOfType(TunnelType tunnelType)
        {
            var dungeonCellList = new List<DungeonCellWrapper>();

            foreach (var dungeonCell in TerrainMeta.Path.DungeonGridCells)
            {
                if (DungeonCellWrapper.GetTunnelType(dungeonCell) == tunnelType)
                {
                    dungeonCellList.Add(new DungeonCellWrapper(dungeonCell));
                }
            }

            return dungeonCellList;
        }

        private static BaseEntity GetLookEntity(BasePlayer player, int layerMask = Physics.DefaultRaycastLayers, float maxDistance = 20)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out var hit, maxDistance, layerMask, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static TrainCar GetTrainCarWhereAiming(BasePlayer player)
        {
            return GetLookEntity(player, Layers.Mask.Vehicle_Detailed) as TrainCar;
        }

        private static void DestroyTrainCarCinematically(TrainCar trainCar)
        {
            if (trainCar.IsDestroyed)
                return;

            if (trainCar.CarType != TrainCarType.Engine)
            {
                Effect.server.Run(BradleyExplosionEffectPrefab, trainCar.GetExplosionPos(), Vector3.up, sourceConnection: null, broadcast: true);
            }

            var hitInfo = new HitInfo(null, trainCar, DamageType.Explosion, float.MaxValue, trainCar.transform.position)
            {
                UseProtection = false,
            };
            trainCar.Die(hitInfo);
        }

        private static void ScheduleDestroyTrainCarCinematically(TrainCar trainCar)
        {
            trainCar.Invoke(() => DestroyTrainCarCinematically(trainCar), 0);
        }

        private static bool CollectionsEqual<T>(ICollection<T> collectionA, ICollection<T> collectionB)
        {
            var countA = collectionA?.Count ?? 0;
            var countB = collectionB?.Count ?? 0;

            if (countA != countB)
                return false;

            if (countA == 0 && countB == 0)
                return true;

            return collectionA?.SequenceEqual(collectionB) ?? false;
        }

        private static string FormatTime(double seconds)
        {
            return TimeSpan.FromSeconds(seconds).ToString("g");
        }

        #endregion

        #region Utilities

        private class TrackedCoroutine : IEnumerator
        {
            private readonly Plugin _plugin;
            private IEnumerator _inner;
            private TrackedCoroutine _innerTracked;

            public TrackedCoroutine(Plugin plugin, IEnumerator inner = null)
            {
                _plugin = plugin;
                _inner = inner;
            }

            public object Current
            {
                get
                {
                    return _inner.Current switch
                    {
                        TrackedCoroutine => _inner.Current,
                        IEnumerator enumerator => GetTrackedCoroutine(enumerator),
                        _ => _inner.Current,
                    };
                }
            }

            public bool MoveNext()
            {
                bool result;
                _plugin.TrackStart();

                try
                {
                    result = _inner.MoveNext();
                }
                finally
                {
                    _plugin.TrackEnd();
                }

                return result;
            }

            public void Reset()
            {
                throw new NotImplementedException();
            }

            public TrackedCoroutine WithEnumerator(IEnumerator inner)
            {
                _inner = inner;
                return this;
            }

            private TrackedCoroutine GetTrackedCoroutine(IEnumerator enumerator)
            {
                _innerTracked ??= new TrackedCoroutine(_plugin);
                return _innerTracked.WithEnumerator(enumerator);
            }
        }

        private static class EntityUtils
        {
            public static T CreateEntity<T>(string prefabPath, Vector3 position = default, Quaternion rotation = default) where T : BaseEntity
            {
                var entity = GameManager.server.CreateEntity(prefabPath, position, rotation);
                if (entity == null)
                    return null;

                if (entity is T entityOfType)
                    return entityOfType;

                UnityEngine.Object.Destroy(entity.gameObject);
                return null;
            }

            public static bool KillEntity(BaseEntity entity, BaseNetworkable.DestroyMode destroyMode = BaseNetworkable.DestroyMode.None)
            {
                if (entity == null || entity.IsDestroyed)
                    return false;

                entity.Kill(destroyMode);
                return true;
            }

            public static bool MoveEntity(BaseEntity entity, Vector3 position)
            {
                var transform = entity.transform;
                if (transform.position == position)
                    return false;

                transform.position = position;

                if (!entity.syncPosition)
                {
                    entity.InvalidateNetworkCache();
                    entity.SendNetworkUpdate_Position();
                }

                return true;
            }
        }

        private static class MarkerUtils
        {
            public static MapMarkerGenericRadius CreateColorMarker(Vector3 position, Color color, float radius, float alpha = 1)
            {
                var colorMarker = EntityUtils.CreateEntity<MapMarkerGenericRadius>(GenericMapMarkerPrefab, position);
                if (colorMarker == null)
                    return null;

                colorMarker.EnableSaving(false);
                colorMarker.EnableGlobalBroadcast(true);
                colorMarker.syncPosition = false;
                colorMarker.Spawn();

                colorMarker.color1 = color;
                colorMarker.color2 = color;
                colorMarker.alpha = alpha;
                colorMarker.radius = radius;
                colorMarker.SendUpdate();

                return colorMarker;
            }

            public static MapMarkerGenericRadius CreateColorMarker(ColorMarkerOptions markerOptions, Vector3 position, Color? colorOverride = null)
            {
                return CreateColorMarker(position, colorOverride ?? markerOptions.Color, markerOptions.Radius, markerOptions.Alpha);
            }

            public static VendingMachineMapMarker CreateVendingMarker(VendingMarkerOptions markerOptions, Vector3 position)
            {
                var vendingMarker = EntityUtils.CreateEntity<VendingMachineMapMarker>(VendingMapMarkerPrefab, position);
                if (vendingMarker == null)
                    return null;

                vendingMarker.markerShopName = markerOptions.Name;
                vendingMarker.EnableSaving(false);
                vendingMarker.EnableGlobalBroadcast(true);
                vendingMarker.syncPosition = false;
                vendingMarker.Spawn();

                return vendingMarker;
            }

            public static bool ResendMarkerColor(MapMarkerGenericRadius colorMarker)
            {
                if (colorMarker == null || colorMarker.IsDestroyed)
                    return false;

                colorMarker.SendUpdate();
                return true;
            }

            public static bool UpdateMarkerColor(MapMarkerGenericRadius colorMarker, Color color)
            {
                if (colorMarker == null || colorMarker.IsDestroyed || colorMarker.color1 == color)
                    return false;

                colorMarker.color1 = color;
                colorMarker.color2 = color;
                colorMarker.SendUpdate();
                return true;
            }
        }

        private struct SplineInfo
        {
            public TrainTrackSpline Spline;
            public float Distance;
            public bool Ascending;
            public bool IsForward;

            public override string ToString()
            {
                return $"{nameof(SplineInfo)}(Distance: {Distance}, Ascending: {Ascending}, IsForward: {IsForward})";
            }
        }

        private struct SplineIterator
        {
            public SplineInfo SplineInfo;
            public EngineSpeeds Throttle;
            public TrackSelection TrackSelection;
            public readonly string RouteName;
            private readonly TriggerManager _triggerManager;

            public SplineIterator(SplineInfo splineInfo, EngineSpeeds throttle, TrackSelection trackSelection, string routeName, TriggerManager triggerManager)
            {
                SplineInfo = splineInfo;
                Throttle = throttle;
                TrackSelection = trackSelection;
                RouteName = routeName;
                _triggerManager = triggerManager;
            }

            public bool MoveNext(HashSet<BaseTriggerInstance> visitedTriggers)
            {
                var triggerList = _triggerManager.GetTriggersForSpline(SplineInfo.Spline);
                if (triggerList != null)
                {
                    if (SplineInfo.Ascending)
                    {
                        foreach (var triggerInstance in triggerList)
                        {
                            if (triggerInstance.DistanceOnSpline < SplineInfo.Distance
                                || !triggerInstance.TriggerData.MatchesRoute(RouteName))
                                continue;

                            visitedTriggers.Add(triggerInstance);
                            HandleTrigger(triggerInstance);
                        }
                    }
                    else
                    {
                        for (var i = triggerList.Count - 1; i >= 0; i--)
                        {
                            var triggerInstance = triggerList[i];
                            if (triggerInstance.DistanceOnSpline > SplineInfo.Distance
                                || !triggerInstance.TriggerData.MatchesRoute(RouteName))
                                continue;

                            visitedTriggers.Add(triggerInstance);
                            HandleTrigger(triggerInstance);
                        }
                    }
                }

                var adjacentTrackInfo = GetAdjacentTrackInfo(SplineInfo.Spline, TrackSelection, SplineInfo.Ascending, SplineInfo.IsForward);
                if (adjacentTrackInfo == null)
                    return false;

                if (adjacentTrackInfo.orientation == TrackOrientation.Reverse)
                {
                    SplineInfo.Ascending = !SplineInfo.Ascending;
                    SplineInfo.IsForward = !SplineInfo.IsForward;
                }

                SplineInfo.Spline = adjacentTrackInfo.track;
                SplineInfo.Distance = SplineInfo.Ascending ? 0 : SplineInfo.Spline.GetLength();

                return true;
            }

            private void HandleTrigger(BaseTriggerInstance triggerInstance)
            {
                TrackSelection = ApplyTrackSelection(TrackSelection, triggerInstance.TriggerData.GetTrackSelectionInstruction());

                var directionInstruction = triggerInstance.TriggerData.GetDirectionInstruction();
                if (directionInstruction == null)
                    return;

                var throttleNumber = EngineThrottleToNumber(Throttle);
                Throttle = ApplyDirection(Throttle, directionInstruction);

                var newThrottleNumber = EngineThrottleToNumber(Throttle);
                if ((throttleNumber ^ newThrottleNumber) < 0)
                {
                    SplineInfo.Ascending = !SplineInfo.Ascending;
                }
            }
        }

        #endregion

        #region Route Manager

        private class Route
        {
            public readonly List<BaseTriggerInstance> TriggerList;
            public readonly List<TrainController> TrainControllerList = new();
            public Color Color { get; private set; }

            public Route(List<BaseTriggerInstance> triggerList)
            {
                TriggerList = triggerList;
            }

            public bool Matches(List<BaseTriggerInstance> triggerList)
            {
                return triggerList.SequenceEqual(TriggerList);
            }

            public void SetColor(Color color)
            {
                Color = color;
            }
        }

        private class RouteManager
        {
            private readonly AutomatedWorkcarts _plugin;
            private readonly TrackedCoroutine _trackedCoroutine;
            private readonly WaitForSeconds _shortDelay = new(TrainController.ConductorTriggerMaxDelay);
            private List<Route> _allRoutes = new();
            private Dictionary<TrainController, Route> _trainControllerToRoute = new();
            private Dictionary<BaseTriggerInstance, Route> _triggerInstanceToRoute = new();
            private Coroutine _determineRoutesRoutine;

            private HashSet<TrainTrackSpline> _reusableSplineList = new();
            private HashSet<BaseTriggerInstance> _reusableTriggerList = new();
            private HashSet<BaseTriggerInstance> _reusableTriggerListForSpline = new();

            private Configuration _config => _plugin._config;
            private TrainManager _trainManager => _plugin._trainManager;
            private TriggerManager _triggerManager => _plugin._triggerManager;

            public RouteManager(AutomatedWorkcarts plugin)
            {
                _plugin = plugin;
                _trackedCoroutine = new TrackedCoroutine(_plugin);
            }

            public void Unload()
            {
                StopRoutine();
            }

            public void RecomputeRoutes()
            {
                if (!_config.MapMarkers.AnyDynamicMarkers)
                    return;

                StopRoutine();
                _determineRoutesRoutine = ServerMgr.Instance.StartCoroutine(_trackedCoroutine.WithEnumerator(DetermineAllRoutes()));
            }

            public Route GetRoute(TrainController trainController)
            {
                return _trainControllerToRoute.TryGetValue(trainController, out var route)
                    ? route
                    : null;
            }

            public Route GetRoute(BaseTriggerInstance triggerInstance)
            {
                return _triggerInstanceToRoute.TryGetValue(triggerInstance, out var route)
                    ? route
                    : null;
            }

            private void StopRoutine()
            {
                if (_determineRoutesRoutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_determineRoutesRoutine);
                }
            }

            private List<BaseTriggerInstance> DetermineRoute(SplineInfo splineInfo, EngineSpeeds throttle, TrackSelection trackSelection, string routeName)
            {
                var debug = _config.DebugDynamicRoutes;
                if (debug)
                {
                    LogWarning($"[Dynamic Routes] Starting analysis: {splineInfo}");
                }

                _reusableSplineList.Clear();
                _reusableSplineList.Add(splineInfo.Spline);
                _reusableTriggerList.Clear();

                var iterator = new SplineIterator(splineInfo, throttle, trackSelection, routeName, _triggerManager);

                for (var i = 0; i < 1000; i++)
                {
                    _reusableTriggerListForSpline.Clear();

                    if (!iterator.MoveNext(_reusableTriggerListForSpline))
                    {
                        if (debug)
                        {
                            LogWarning($"[Dynamic Routes] Failed to get next spline info at iteration {i} after {_reusableSplineList.Count} splines and {_reusableTriggerList.Count} triggers");
                        }

                        break;
                    }

                    _reusableSplineList.Add(iterator.SplineInfo.Spline);

                    foreach (var visitedTrigger in _reusableTriggerListForSpline)
                    {
                        if (_reusableTriggerList.Add(visitedTrigger))
                            continue;

                        // Found a repeat trigger
                        var triggerForClosure = visitedTrigger;
                        var finalTriggerList = _reusableTriggerList
                            .SkipWhile(t => t != triggerForClosure)
                            .OrderBy(t => t.WorldPosition.y)
                            .ThenBy(t => t.WorldPosition.x)
                            .ThenBy(t => t.WorldPosition.z)
                            .ToList();

                        if (debug)
                        {
                            LogWarning($"[Dynamic Routes] Found circular route after {_reusableSplineList.Count} splines and {_reusableTriggerList.Count} triggers ({finalTriggerList.Count} unique).");
                        }

                        return finalTriggerList;
                    }
                }

                if (debug)
                {
                    LogWarning($"[Dynamic Routes] Failed to find circular route for train after visiting {_reusableSplineList.Count} splines and {_reusableTriggerList.Count} triggers.");

                    foreach (var triggerInstance in _reusableTriggerList)
                    {
                        var marker = MarkerUtils.CreateColorMarker(triggerInstance.WorldPosition, Color.magenta, 0.1f);
                        marker.Invoke(() => marker.Kill(), 10);
                    }
                }

                return null;
            }

            private List<BaseTriggerInstance> DetermineRoute(TrainController trainController)
            {
                var primaryTrainEngine = trainController.PrimaryTrainEngine;
                var distanceOnSpline = primaryTrainEngine.FrontWheelSplineDist;
                var spline = primaryTrainEngine.FrontTrackSection;
                var throttle = trainController.DepartureThrottle;

                var splineInfo = new SplineInfo
                {
                    Spline = spline,
                    Ascending = spline.IsForward(trainController.Forward, distanceOnSpline),
                    Distance = distanceOnSpline,
                    IsForward = EngineThrottleToNumber(throttle) >= 0,
                };

                return DetermineRoute(splineInfo, throttle, primaryTrainEngine.localTrackSelection, trainController.RouteName);
            }

            private IEnumerator DetermineAllRoutes()
            {
                // Don't waste time computing routes if the routine is frequently restarting due to changes.
                yield return _shortDelay;

                _allRoutes.Clear();
                _trainControllerToRoute.Clear();
                _triggerInstanceToRoute.Clear();

                var trainControllerList = _trainManager.GetAllTrainControllers();

                foreach (var trainController in trainControllerList)
                {
                    var triggerList = DetermineRoute(trainController);
                    if (triggerList != null)
                    {
                        var route = FindMatchingRoute(triggerList);
                        if (route == null)
                        {
                            route = new Route(triggerList);
                            _allRoutes.Add(route);

                            foreach (var triggerInstance in triggerList)
                            {
                                // It's possible to have multiple routes touching a trigger.
                                // For now, the first one will win, which isn't very deterministic.
                                _triggerInstanceToRoute.TryAdd(triggerInstance, route);
                            }
                        }

                        route.TrainControllerList.Add(trainController);
                        _trainControllerToRoute[trainController] = route;
                    }

                    yield return null;
                }

                if (_config.DebugDynamicRoutes && trainControllerList.Count > 0)
                {
                    LogWarning($"[Dynamic Routes] Found {_allRoutes.Count} distinct routes");
                }

                if (_config.MapMarkers.AnyDynamicColors)
                {
                    SortRoutes();
                    AssignRouteColors();

                    if (_config.MapMarkers.Train.ColorMarker.Enabled)
                    {
                        foreach (var trainController in trainControllerList)
                        {
                            if (trainController.UpdateMarkerColor())
                                yield return null;
                        }
                    }
                }

                if (_config.MapMarkers.Stop.AnyDynamicMarkers)
                    yield return _triggerManager.HandleChangesRoutine();
            }

            private void SortRoutes()
            {
                _allRoutes.Sort((a, b) =>
                {
                    for (var i = 0; i < a.TriggerList.Count && i < b.TriggerList.Count; i++)
                    {
                        var result = CompareVectors(a.TriggerList[i].WorldPosition, b.TriggerList[i].WorldPosition);
                        if (result != 0)
                            return result;
                    }

                    return a.TriggerList.Count.CompareTo(b.TriggerList.Count);
                });
            }

            private void AssignRouteColors()
            {
                var colors = _config.MapMarkers.ValidDynamicColors;
                if (colors.Length == 0)
                    return;

                var i = 0;

                foreach (var route in _allRoutes)
                {
                    route.SetColor(colors[i++]);

                    if (i >= colors.Length)
                    {
                        i = 0;
                    }
                }
            }

            private Route FindMatchingRoute(List<BaseTriggerInstance> triggerList)
            {
                foreach (var route in _allRoutes)
                {
                    if (route.Matches(triggerList))
                        return route;
                }

                return null;
            }
        }

        #endregion

        #region Train Car Prefabs

        private class TrainCarPrefab
        {
            public const string WorkcartAlias = "Workcart";

            public const string ClassicWorkcartPrefab = "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
            private const string LocomotivePrefab = "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab";
            private const string SedanPrefab = "assets/content/vehicles/sedan_a/sedanrail.entity.prefab";
            private const string WorkcartPrefab = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
            private const string WorkcartCoveredPrefab = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
            private const string WagonAPrefab = "assets/content/vehicles/trains/wagons/trainwagona.entity.prefab";
            private const string WagonBPrefab = "assets/content/vehicles/trains/wagons/trainwagonb.entity.prefab";
            private const string WagonCPrefab = "assets/content/vehicles/trains/wagons/trainwagonc.entity.prefab";
            private const string WagonFuelPrefab = "assets/content/vehicles/trains/wagons/trainwagonunloadablefuel.entity.prefab";
            private const string WagonLootPrefab = "assets/content/vehicles/trains/wagons/trainwagonunloadableloot.entity.prefab";
            private const string WagonResourcePrefab = "assets/content/vehicles/trains/wagons/trainwagonunloadable.entity.prefab";
            private const string CaboosePrefab = "assets/content/vehicles/trains/caboose/traincaboose.entity.prefab";

            private static readonly Dictionary<string, TrainCarPrefab> AllowedPrefabs = new(StringComparer.InvariantCultureIgnoreCase)
            {
                ["Locomotive"] = new TrainCarPrefab("Locomotive", LocomotivePrefab),
                ["Sedan"] = new TrainCarPrefab("Sedan", SedanPrefab),
                [WorkcartAlias] = new TrainCarPrefab(WorkcartAlias, WorkcartPrefab),
                ["WorkcartCovered"] = new TrainCarPrefab("WorkcartCovered", WorkcartCoveredPrefab),
                ["WagonA"] = new TrainCarPrefab("WagonA", WagonAPrefab),
                ["WagonB"] = new TrainCarPrefab("WagonB", WagonBPrefab),
                ["WagonC"] = new TrainCarPrefab("WagonC", WagonCPrefab),
                ["WagonFuel"] = new TrainCarPrefab("WagonFuel", WagonFuelPrefab),
                ["WagonLoot"] = new TrainCarPrefab("WagonLoot", WagonLootPrefab),
                ["WagonResource"] = new TrainCarPrefab("WagonResource", WagonResourcePrefab),
                ["Caboose"] = new TrainCarPrefab("Caboose", CaboosePrefab),

                ["Locomotive_R"] = new TrainCarPrefab("Locomotive_R", LocomotivePrefab, reverse: true),
                ["Sedan_R"] = new TrainCarPrefab("Sedan", SedanPrefab),
                [$"{WorkcartAlias}_R"] = new TrainCarPrefab($"{WorkcartAlias}_R", WorkcartPrefab, reverse: true),
                ["WorkcartCovered_R"] = new TrainCarPrefab("WorkcartCovered_R", WorkcartCoveredPrefab, reverse: true),
                ["WagonA_R"] = new TrainCarPrefab("WagonA_R", WagonAPrefab, reverse: true),
                ["WagonB_R"] = new TrainCarPrefab("WagonB_R", WagonBPrefab, reverse: true),
                ["WagonC_R"] = new TrainCarPrefab("WagonC_R", WagonCPrefab, reverse: true),
                ["WagonFuel_R"] = new TrainCarPrefab("WagonFuel_R", WagonFuelPrefab, reverse: true),
                ["WagonLoot_R"] = new TrainCarPrefab("WagonLoot_R", WagonLootPrefab, reverse: true),
                ["WagonResource_R"] = new TrainCarPrefab("WagonResource_R", WagonResourcePrefab, reverse: true),
                ["Caboose_R"] = new TrainCarPrefab("Caboose_R", CaboosePrefab, reverse: true),
            };

            public static TrainCarPrefab FindPrefab(string trainCarAlias)
            {
                return AllowedPrefabs.TryGetValue(trainCarAlias, out var trainCarPrefab)
                    ? trainCarPrefab
                    : null;
            }

            public static ICollection<string> GetAliases()
            {
                return AllowedPrefabs.Keys;
            }

            public string TrainCarAlias;
            public string PrefabPath;
            public bool Reverse;

            public TrainCarPrefab(string trainCarAlias, string prefabPath, bool reverse = false)
            {
                TrainCarAlias = trainCarAlias;
                PrefabPath = prefabPath;
                Reverse = reverse;
            }
        }

        #endregion

        #region Disable Spawn Point Manager

        private class DisableSpawnPointManager
        {
            private Dictionary<SpawnGroup, int> _disabledSpawnGroups = new();

            public IEnumerator DisableSpawnPointsRoutine()
            {
                foreach (var dungeonCell in TerrainMeta.Path.DungeonGridCells)
                {
                    if (DungeonCellWrapper.GetTunnelType(dungeonCell) != TunnelType.TrainStation)
                        continue;

                    var spawnGroupList = dungeonCell.GetComponentsInChildren<SpawnGroup>();
                    if (spawnGroupList.Length != 0)
                    {
                        foreach (var spawnGroup in spawnGroupList)
                        {
                            foreach (var spawnEntry in spawnGroup.prefabs)
                            {
                                if (spawnEntry.prefab.Get()?.GetComponent<TrainEngine>() == null)
                                    continue;

                                _disabledSpawnGroups[spawnGroup] = spawnGroup.maxPopulation;
                                spawnGroup.maxPopulation = 0;

                                for (var i = spawnGroup.spawnInstances.Count - 1; i >= 0; i--)
                                {
                                    spawnGroup.spawnInstances[i].GetComponent<TrainEngine>()?.Kill();
                                    yield return null;
                                }
                            }
                        }
                    }

                    yield return null;
                }
            }

            public void Unload()
            {
                foreach (var (spawnGroup, maxPopulation) in _disabledSpawnGroups)
                {
                    spawnGroup.maxPopulation = maxPopulation;
                }
            }
        }

        #endregion

        #region Color Marker Update Manager

        private class ColorMarkerUpdateManager
        {
            private readonly AutomatedWorkcarts _plugin;
            private readonly TrackedCoroutine _trackedCoroutine;
            private Coroutine _coroutine;

            private readonly List<MapMarkerGenericRadius> _colorMarkerList = new();

            private Configuration _config => _plugin._config;
            private TrainManager _trainManager => _plugin._trainManager;
            private TriggerManager _triggerManager => _plugin._triggerManager;

            public ColorMarkerUpdateManager(AutomatedWorkcarts plugin)
            {
                _plugin = plugin;
                _trackedCoroutine = new TrackedCoroutine(plugin);
            }

            public void Restart()
            {
                StopCoroutine();
                _coroutine = ServerMgr.Instance.StartCoroutine(_trackedCoroutine.WithEnumerator(ResendColorMarkersRoutine()));
            }

            public void Unload()
            {
                StopCoroutine();
            }

            private void StopCoroutine()
            {
                if (_coroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_coroutine);
                }
            }

            private IEnumerator ResendColorMarkersRoutine()
            {
                _colorMarkerList.Clear();

                if (_config.MapMarkers.Train.ColorMarker.Enabled)
                {
                    _trainManager.GetAllColorMarkers(_colorMarkerList);
                }

                if (_config.MapMarkers.Stop.ColorMarker.Enabled)
                {
                    _triggerManager.GetAllColorMarkers(_colorMarkerList);
                }

                foreach (var mapMarker in _colorMarkerList)
                {
                    if (MarkerUtils.ResendMarkerColor(mapMarker))
                        yield return null;
                }

                _colorMarkerList.Clear();
            }
        }

        #endregion

        #region Dungeon Cells

        private enum TunnelType
        {
            // Don't rename these since the names are persisted in data files.
            TrainStation,
            BarricadeTunnel,
            LootTunnel,
            Intersection,
            VerticalIntersection,
            LargeIntersection,
            Unsupported
        }

        private static readonly Dictionary<string, Quaternion> DungeonRotations = new()
        {
            ["station-sn-0"] = Quaternion.Euler(0, 180, 0),
            ["station-sn-1"] = Quaternion.identity,
            ["station-sn-2"] = Quaternion.Euler(0, 180, 0),
            ["station-sn-3"] = Quaternion.identity,
            ["station-we-0"] = Quaternion.Euler(0, 90, 0),
            ["station-we-1"] = Quaternion.Euler(0, -90, 0),
            ["station-we-2"] = Quaternion.Euler(0, 90, 0),
            ["station-we-3"] = Quaternion.Euler(0, -90, 0),

            ["straight-sn-0"] = Quaternion.identity,
            ["straight-sn-1"] = Quaternion.Euler(0, 180, 0),
            ["straight-we-0"] = Quaternion.Euler(0, -90, 0),
            ["straight-we-1"] = Quaternion.Euler(0, 90, 0),

            ["straight-sn-4"] = Quaternion.identity,
            ["straight-sn-5"] = Quaternion.Euler(0, 180, 0),
            ["straight-we-4"] = Quaternion.Euler(0, -90, 0),
            ["straight-we-5"] = Quaternion.Euler(0, 90, 0),

            ["intersection-n"] = Quaternion.identity,
            ["intersection-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-w"] = Quaternion.Euler(0, -90, 0),

            ["intersection"] = Quaternion.identity,

            ["intersection-b1-n"] = Quaternion.identity,
            ["intersection-b1-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b1-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b1-w"] = Quaternion.Euler(0, 270, 0),

            ["intersection-b2-n"] = Quaternion.identity,
            ["intersection-b2-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b2-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b2-w"] = Quaternion.Euler(0, 270, 0),

            ["intersection-b3-n"] = Quaternion.identity,
            ["intersection-b3-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b3-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b3-w"] = Quaternion.Euler(0, 270, 0),

            ["intersection-b4-n"] = Quaternion.identity,
            ["intersection-b4-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b4-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b4-w"] = Quaternion.Euler(0, 270, 0),

            ["intersection-b5-n"] = Quaternion.identity,
            ["intersection-b5-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b5-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b5-w"] = Quaternion.Euler(0, 270, 0),

            ["intersection-b6-n"] = Quaternion.identity,
            ["intersection-b6-e"] = Quaternion.Euler(0, 90, 0),
            ["intersection-b6-s"] = Quaternion.Euler(0, 180, 0),
            ["intersection-b6-w"] = Quaternion.Euler(0, 270, 0),
        };

        private static readonly Dictionary<string, TunnelType> DungeonCellTypes = new()
        {
            ["station-sn-0"] = TunnelType.TrainStation,
            ["station-sn-1"] = TunnelType.TrainStation,
            ["station-sn-2"] = TunnelType.TrainStation,
            ["station-sn-3"] = TunnelType.TrainStation,
            ["station-we-0"] = TunnelType.TrainStation,
            ["station-we-1"] = TunnelType.TrainStation,
            ["station-we-2"] = TunnelType.TrainStation,
            ["station-we-3"] = TunnelType.TrainStation,

            ["straight-sn-0"] = TunnelType.LootTunnel,
            ["straight-sn-1"] = TunnelType.LootTunnel,
            ["straight-we-0"] = TunnelType.LootTunnel,
            ["straight-we-1"] = TunnelType.LootTunnel,

            ["straight-sn-4"] = TunnelType.BarricadeTunnel,
            ["straight-sn-5"] = TunnelType.BarricadeTunnel,
            ["straight-we-4"] = TunnelType.BarricadeTunnel,
            ["straight-we-5"] = TunnelType.BarricadeTunnel,

            ["intersection-n"] = TunnelType.Intersection,
            ["intersection-e"] = TunnelType.Intersection,
            ["intersection-s"] = TunnelType.Intersection,
            ["intersection-w"] = TunnelType.Intersection,

            ["intersection"] = TunnelType.LargeIntersection,

            ["intersection-b1-n"] = TunnelType.VerticalIntersection,
            ["intersection-b1-e"] = TunnelType.VerticalIntersection,
            ["intersection-b1-s"] = TunnelType.VerticalIntersection,
            ["intersection-b1-w"] = TunnelType.VerticalIntersection,

            ["intersection-b2-n"] = TunnelType.VerticalIntersection,
            ["intersection-b2-e"] = TunnelType.VerticalIntersection,
            ["intersection-b2-s"] = TunnelType.VerticalIntersection,
            ["intersection-b2-w"] = TunnelType.VerticalIntersection,

            ["intersection-b3-n"] = TunnelType.VerticalIntersection,
            ["intersection-b3-e"] = TunnelType.VerticalIntersection,
            ["intersection-b3-s"] = TunnelType.VerticalIntersection,
            ["intersection-b3-w"] = TunnelType.VerticalIntersection,

            ["intersection-b4-n"] = TunnelType.VerticalIntersection,
            ["intersection-b4-e"] = TunnelType.VerticalIntersection,
            ["intersection-b4-s"] = TunnelType.VerticalIntersection,
            ["intersection-b4-w"] = TunnelType.VerticalIntersection,

            ["intersection-b5-n"] = TunnelType.VerticalIntersection,
            ["intersection-b5-e"] = TunnelType.VerticalIntersection,
            ["intersection-b5-s"] = TunnelType.VerticalIntersection,
            ["intersection-b5-w"] = TunnelType.VerticalIntersection,

            ["intersection-b6-n"] = TunnelType.VerticalIntersection,
            ["intersection-b6-e"] = TunnelType.VerticalIntersection,
            ["intersection-b6-s"] = TunnelType.VerticalIntersection,
            ["intersection-b6-w"] = TunnelType.VerticalIntersection,
        };

        private static readonly Dictionary<TunnelType, Vector3> DungeonCellDimensions = new()
        {
            [TunnelType.TrainStation] = new Vector3(108, 8.5f, 216),
            [TunnelType.BarricadeTunnel] = new Vector3(16.5f, 8.5f, 216),
            [TunnelType.LootTunnel] = new Vector3(16.5f, 8.5f, 216),
            [TunnelType.Intersection] = new Vector3(216, 8.5f, 216),
            [TunnelType.LargeIntersection] = new Vector3(216, 8.5f, 216),
            [TunnelType.VerticalIntersection] = new Vector3(216, 8.5f, 216),
        };

        private class DungeonCellWrapper
        {
            public static TunnelType GetTunnelType(DungeonGridCell dungeonCell)
            {
                return GetTunnelType(GetShortName(dungeonCell.name));
            }

            private static TunnelType GetTunnelType(string shortName)
            {
                return DungeonCellTypes.TryGetValue(shortName, out var tunnelType)
                    ? tunnelType
                    : TunnelType.Unsupported;
            }

            public static Quaternion GetRotation(string shortName)
            {
                return DungeonRotations.TryGetValue(shortName, out var rotation)
                    ? rotation
                    : Quaternion.identity;
            }

            public string ShortName { get; }
            public TunnelType TunnelType { get; }
            public Vector3 Position { get; }
            public Quaternion Rotation { get; }

            private OBB _boundingBox;

            public DungeonCellWrapper(DungeonGridCell dungeonCell)
            {
                ShortName = GetShortName(dungeonCell.name);
                TunnelType = GetTunnelType(ShortName);
                Position = dungeonCell.transform.position;
                Rotation = GetRotation(ShortName);

                if (DungeonCellDimensions.TryGetValue(TunnelType, out var dimensions))
                {
                    _boundingBox = new OBB(Position + new Vector3(0, dimensions.y / 2, 0), dimensions, Rotation);
                }
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return Quaternion.Inverse(Rotation) * (worldPosition - Position);
            }

            public Vector3 TransformPoint(Vector3 localPosition)
            {
                return Position + Rotation * localPosition;
            }

            public bool IsInBounds(Vector3 position) => _boundingBox.Contains(position);
        }

        #endregion

        #region Train Triggers

        private enum SpeedInstruction
        {
            // Don't rename these since the names are persisted in data files.
            Zero = 0,
            Lo = 1,
            Med = 2,
            Hi = 3,
        }

        private enum DirectionInstruction
        {
            // Don't rename these since the names are persisted in data files.
            Fwd,
            Rev,
            Invert,
        }

        private enum TrackSelectionInstruction
        {
            // Don't rename these since the names are persisted in data files.
            Default,
            Left,
            Right,
            Swap,
        }

        private static int EngineThrottleToNumber(EngineSpeeds throttle)
        {
            switch (throttle)
            {
                case EngineSpeeds.Fwd_Hi: return 3;
                case EngineSpeeds.Fwd_Med: return 2;
                case EngineSpeeds.Fwd_Lo: return 1;
                case EngineSpeeds.Rev_Lo: return -1;
                case EngineSpeeds.Rev_Med: return -2;
                case EngineSpeeds.Rev_Hi: return -3;
                default: return 0;
            }
        }

        private static EngineSpeeds EngineThrottleFromNumber(int speedNumber)
        {
            switch (speedNumber)
            {
                case 3: return EngineSpeeds.Fwd_Hi;
                case 2: return EngineSpeeds.Fwd_Med;
                case 1: return EngineSpeeds.Fwd_Lo;
                case -1: return EngineSpeeds.Rev_Lo;
                case -2: return EngineSpeeds.Rev_Med;
                case -3: return EngineSpeeds.Rev_Hi;
                default: return EngineSpeeds.Zero;
            }
        }

        private static int ApplySpeed(int throttle, SpeedInstruction? speedInstruction)
        {
            if (speedInstruction == null)
                return throttle;

            var sign = throttle >= 0 ? 1 : -1;
            return sign * (int)speedInstruction.Value;
        }

        private static int ApplyDirection(int throttle, DirectionInstruction? directionInstruction)
        {
            switch (directionInstruction)
            {
                case DirectionInstruction.Fwd:
                    return Math.Abs(throttle);
                case DirectionInstruction.Rev:
                    return -Math.Abs(throttle);
                case DirectionInstruction.Invert:
                    return -throttle;
                default:
                    return throttle;
            }
        }

        private static EngineSpeeds ApplyDirection(EngineSpeeds throttle, DirectionInstruction? directionInstruction)
        {
            return EngineThrottleFromNumber(ApplyDirection(EngineThrottleToNumber(throttle), directionInstruction));
        }

        private static EngineSpeeds ApplySpeedAndDirection(EngineSpeeds currentThrottle, SpeedInstruction? speedInstruction, DirectionInstruction? directionInstruction)
        {
            var throttleNumber = EngineThrottleToNumber(currentThrottle);
            throttleNumber = ApplySpeed(throttleNumber, speedInstruction);
            throttleNumber = ApplyDirection(throttleNumber, directionInstruction);
            return EngineThrottleFromNumber(throttleNumber);
        }

        private static TrackSelection ApplyTrackSelection(TrackSelection trackSelection, TrackSelectionInstruction? trackSelectionInstruction)
        {
            switch (trackSelectionInstruction)
            {
                case TrackSelectionInstruction.Default:
                    return TrackSelection.Default;

                case TrackSelectionInstruction.Left:
                    return TrackSelection.Left;

                case TrackSelectionInstruction.Right:
                    return TrackSelection.Right;

                case TrackSelectionInstruction.Swap:
                    return trackSelection == TrackSelection.Left
                        ? TrackSelection.Right
                        : trackSelection == TrackSelection.Right
                        ? TrackSelection.Left
                        : trackSelection;

                default:
                    return trackSelection;
            }
        }

        private enum TrainTriggerType { Map, Tunnel }

        private class TrainTrigger : TriggerBase
        {
            public static TrainTrigger AddToGameObject(AutomatedWorkcarts plugin, GameObject gameObject, TrainManager trainManager, TriggerData triggerData, BaseTriggerInstance triggerInstance)
            {
                var trainTrigger = gameObject.AddComponent<TrainTrigger>();
                trainTrigger._plugin = plugin;
                trainTrigger._trainManager = trainManager;
                trainTrigger.TriggerInstance = triggerInstance;
                trainTrigger.TriggerData = triggerData;
                trainTrigger.interestLayers = Layers.Mask.Vehicle_World;
                return trainTrigger;
            }

            public const int TriggerLayer = 6;
            public const float TriggerRadius = 1f;

            public TriggerData TriggerData { get; private set; }
            public BaseTriggerInstance TriggerInstance { get; private set; }
            private AutomatedWorkcarts _plugin;
            private TrainManager _trainManager;

            public override void OnEntityEnter(BaseEntity entity)
            {
                _plugin.TrackStart();
                var trainCar = entity as TrainCar;
                if (trainCar != null)
                {
                    HandleTrainCar(trainCar);
                }

                _plugin.TrackEnd();
            }

            private bool ShouldAutomateTrain(TrainCar trainCar, out bool shouldCount)
            {
                shouldCount = true;

                if (TriggerData.IsSpawner)
                {
                    // Hybrid Spawner/Conductor triggers should only automate trains spawned by the same trigger.
                    if (!TriggerInstance.DidSpawnTrain(trainCar))
                        return false;

                    // Trains spawned by hybrid Spawner/Conductor triggers may be exempt from conductor limits.
                    shouldCount = _plugin._config.SpawnTriggersRespectConductorLimit;
                    if (!shouldCount)
                        return true;
                }

                // Don't add a conductor if the limit is reached, unless the train was spawned by this trigger.
                return _trainManager.CanHaveMoreConductors();
            }

            private void HandleTrainCar(TrainCar trainCar)
            {
                entityContents ??= new HashSet<BaseEntity>();

                // Ignore the trigger if the train car is already colliding with it.
                if (!entityContents.Add(trainCar))
                    return;

                var trainController = _trainManager.GetTrainController(trainCar);
                if (trainController == null)
                {
                    // If there is no train controller, we only care about conductor triggers.
                    if (!TriggerData.AddConductor)
                        return;

                    // Don't handle conductor triggers that are also destroy triggers since that indicates an incorrect setup.
                    if (TriggerData.Destroy)
                        return;

                    // Make sure the train has at least one train engine.
                    var leadTrainEngine = GetLeadTrainEngine(trainCar);
                    if (leadTrainEngine == null)
                        return;

                    // Don't automate a train if any of the train cars are player-owned.
                    // Not sure if this is the correct decision, but we'll see.
                    if (IsTrainOwned(trainCar))
                        return;

                    if (!ShouldAutomateTrain(trainCar, out var shouldCount))
                        return;

                    _trainManager.TryCreateTrainController(leadTrainEngine, TriggerData, countsTowardConductorLimit: shouldCount);
                    return;
                }

                // The PrimaryTrainCar always refers to the train car at the front of the direction being traveled.
                if (trainCar != trainCar.completeTrain.PrimaryTrainCar)
                    return;

                trainController.HandleTrigger(TriggerData);
            }
        }

        private class TriggerData
        {
            [JsonProperty("Id")]
            public int Id;

            [JsonProperty("Position")]
            public Vector3 Position;

            [JsonProperty("Enabled", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool Enabled = true;

            [JsonProperty("Route", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Route;

            [JsonProperty("TunnelType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string TunnelType;

            [JsonProperty("AddConductor", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool AddConductor;

            [JsonProperty("Brake", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Brake;

            [JsonProperty("Destroy", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool Destroy;

            [JsonProperty("Direction", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Direction;

            [JsonProperty("Speed", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Speed;

            [JsonProperty("TrackSelection", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string TrackSelection;

            [JsonProperty("StopDuration", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float StopDuration;

            [JsonProperty("DepartureSpeed", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DepartureSpeed;

            [JsonProperty("Chance", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float Chance;

            [JsonProperty("Commands", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<string> Commands;

            [JsonProperty("RotationAngle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float RotationAngle;

            [JsonProperty("TrainCars", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string[] TrainCars;

            [JsonProperty("Spawner", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private bool DeprecatedSpawner
            {
                set
                {
                    if (value && TrainCars == null)
                    {
                        TrainCars = new[] { TrainCarPrefab.WorkcartAlias };
                    }
                }
            }

            [JsonProperty("Wagons", DefaultValueHandling = DefaultValueHandling.Ignore)]
            private string[] DeprecatedWagons
            {
                set
                {
                    if ((value?.Length ?? 0) == 0)
                        return;

                    TrainCars = TrainCars?.Concat(value).ToArray();
                }
            }

            [JsonIgnore]
            public bool IsSpawner => TrainCars?.Length > 0;

            [JsonIgnore]
            public bool IsStop => GetSpeedInstruction() == SpeedInstruction.Zero;

            [JsonIgnore]
            public TrainTriggerType TriggerType => TunnelType != null ? TrainTriggerType.Tunnel : TrainTriggerType.Map;

            public float GetChance()
            {
                return Mathf.Clamp(Chance, 0, 1);
            }

            public float GetStopDuration()
            {
                return StopDuration > 0
                    ? StopDuration
                    : 30;
            }

            private TunnelType? _tunnelType;
            public TunnelType GetTunnelType()
            {
                if (_tunnelType != null)
                    return (TunnelType)_tunnelType;

                _tunnelType = AutomatedWorkcarts.TunnelType.Unsupported;

                if (!string.IsNullOrWhiteSpace(TunnelType))
                {
                    if (Enum.TryParse(TunnelType, out TunnelType tunnelType))
                    {
                        _tunnelType = tunnelType;
                    }
                }

                return (TunnelType)_tunnelType;
            }

            private SpeedInstruction? _speedInstruction;
            public SpeedInstruction? GetSpeedInstruction()
            {
                if (_speedInstruction == null && !string.IsNullOrWhiteSpace(Speed))
                {
                    if (Enum.TryParse(Speed, out SpeedInstruction speed))
                    {
                        _speedInstruction = speed;
                    }
                }

                // Ensure there is a target speed when braking.
                return Brake ? _speedInstruction ?? SpeedInstruction.Zero : _speedInstruction;
            }

            public SpeedInstruction GetSpeedInstructionOrZero()
            {
                return GetSpeedInstruction() ?? SpeedInstruction.Zero;
            }

            private DirectionInstruction? _directionInstruction;
            public DirectionInstruction? GetDirectionInstruction()
            {
                if (_directionInstruction == null && !string.IsNullOrWhiteSpace(Direction))
                {
                    if (Enum.TryParse(Direction, out DirectionInstruction direction))
                    {
                        _directionInstruction = direction;
                    }
                }

                return _directionInstruction;
            }

            private TrackSelectionInstruction? _trackSelectionInstruction;
            public TrackSelectionInstruction? GetTrackSelectionInstruction()
            {
                if (_trackSelectionInstruction == null && !string.IsNullOrWhiteSpace(TrackSelection))
                {
                    if (Enum.TryParse(TrackSelection, out TrackSelectionInstruction trackSelection))
                    {
                        _trackSelectionInstruction = trackSelection;
                    }
                }

                return _trackSelectionInstruction;
            }

            private SpeedInstruction? _departureSpeedInstruction;
            public SpeedInstruction GetDepartureSpeedInstruction()
            {
                if (_departureSpeedInstruction == null && !string.IsNullOrWhiteSpace(Speed))
                {
                    if (Enum.TryParse(DepartureSpeed, out SpeedInstruction speed))
                    {
                        _departureSpeedInstruction = speed;
                    }
                }

                return _departureSpeedInstruction ?? SpeedInstruction.Med;
            }

            public bool MatchesRoute(string routeName)
            {
                if (string.IsNullOrWhiteSpace(Route))
                {
                    // Trigger has no specified route so it applies to all trains.
                    return true;
                }

                return routeName?.ToLower() == Route.ToLower();
            }

            public void InvalidateCache()
            {
                _speedInstruction = null;
                _directionInstruction = null;
                _trackSelectionInstruction = null;
                _departureSpeedInstruction = null;
            }

            public void CopyFrom(TriggerData triggerData)
            {
                Enabled = triggerData.Enabled;
                Route = triggerData.Route;
                AddConductor = triggerData.AddConductor;
                Brake = triggerData.Brake;
                Destroy = triggerData.Destroy;
                Speed = triggerData.Speed;
                DepartureSpeed = triggerData.DepartureSpeed;
                Direction = triggerData.Direction;
                TrackSelection = triggerData.TrackSelection;
                StopDuration = triggerData.StopDuration;
                Chance = triggerData.Chance;
                TrainCars = triggerData.TrainCars;
                Commands = triggerData.Commands;
            }

            public TriggerData Clone()
            {
                var triggerData = new TriggerData();
                triggerData.CopyFrom(this);
                return triggerData;
            }

            public Color GetColor(string routeName)
            {
                if (!Enabled || !MatchesRoute(routeName))
                    return Color.grey;

                if (Destroy)
                    return Color.red;

                if (IsSpawner)
                    return new Color(0, 1, 0.75f);

                if (AddConductor)
                    return Color.cyan;

                var speedInstruction = GetSpeedInstruction();
                var directionInstruction = GetDirectionInstruction();
                var trackSelectionInstruction = GetTrackSelectionInstruction();

                float saturation;

                if (Brake)
                {
                    var brakeSpeedInstruction = GetSpeedInstructionOrZero();

                    // Orange
                    saturation = brakeSpeedInstruction == SpeedInstruction.Zero ? 1
                        : brakeSpeedInstruction == SpeedInstruction.Lo ? 0.8f
                        : 0.6f;
                    return Color.HSVToRGB(0.5f/6f, saturation, 1);
                }

                if (speedInstruction == SpeedInstruction.Zero)
                    return Color.white;

                if (speedInstruction == null && directionInstruction == null && trackSelectionInstruction != null)
                    return Color.magenta;

                var hue = directionInstruction == DirectionInstruction.Fwd
                    ? 1/3f // Green
                    : directionInstruction == DirectionInstruction.Rev
                        ? 0 // Red
                        : directionInstruction == DirectionInstruction.Invert
                            ? 0.5f/6f // Orange
                            : 1/6f; // Yellow

                saturation = speedInstruction == SpeedInstruction.Hi
                    ? 1
                    : speedInstruction == SpeedInstruction.Med
                    ? 0.8f
                    : speedInstruction == SpeedInstruction.Lo
                    ? 0.6f
                    : 1;

                return Color.HSVToRGB(hue, saturation, 1);
            }
        }

        #endregion

        #region Spawned Train Car Tracker

        private class SpawnedTrainCarTracker
        {
            private HashSet<TrainCar> _spawnedTrainCars = new();

            public bool ContainsTrainCar(TrainCar trainCar)
            {
                return _spawnedTrainCars.Contains(trainCar);
            }

            public void RegisterTrainCar(TrainCar trainCar)
            {
                _spawnedTrainCars.Add(trainCar);
            }

            public void UnregisterTrainCar(TrainCar trainCar)
            {
                _spawnedTrainCars.Remove(trainCar);
            }
        }

        private class SpawnedTrainCarComponent : FacepunchBehaviour
        {
            public static void AddToEntity(TrainCar trainCar, BaseTriggerInstance triggerInstance)
            {
                var component = trainCar.gameObject.AddComponent<SpawnedTrainCarComponent>();
                component._trainCar = trainCar;
                component._triggerInstance = triggerInstance;
                triggerInstance.TrainManager.SpawnedTrainCarTracker.RegisterTrainCar(trainCar);
            }

            private TrainCar _trainCar;
            private BaseTriggerInstance _triggerInstance;

            private void OnDestroy()
            {
                _triggerInstance.HandleTrainCarKilled(_trainCar);
                _triggerInstance.TrainManager.SpawnedTrainCarTracker.UnregisterTrainCar(_trainCar);
            }
        }

        #endregion

        #region Trigger Instances

        private abstract class BaseTriggerInstance
        {
            private const int MaxSpawnedTrains = 1;
            private const float TimeBetweenSpawns = 30;

            protected static readonly Vector3 TriggerOffset = new(0, 0.9f, 0);

            public TrainManager TrainManager { get; }
            public TriggerData TriggerData { get; }
            public TrainTrackSpline Spline { get; private set; }
            public float DistanceOnSpline { get; private set; }
            public MapMarkerGenericRadius ColorMarker { get; private set; }

            public abstract Vector3 WorldPosition { get; }
            protected abstract Quaternion WorldRotation { get; }

            public Vector3 TriggerPosition => WorldPosition + TriggerOffset;
            public Quaternion SpawnRotation =>
                Spline != null
                    ? GetSplineTangentRotation(Spline, DistanceOnSpline, WorldRotation)
                    : WorldRotation;

            private AutomatedWorkcarts _plugin;
            private GameObject _gameObject;
            private TrainTrigger _trainTrigger;
            private List<TrainCar> _spawnedTrains;
            private VendingMachineMapMarker _vendingMarker;
            private Action _spawnTrainTracked;

            private Configuration _config => _plugin._config;
            private TriggerManager _triggerManager => _plugin._triggerManager;
            private RouteManager _routeManager => _plugin._routeManager;

            protected BaseTriggerInstance(AutomatedWorkcarts plugin, TrainManager trainManager, TriggerData triggerData)
            {
                _plugin = plugin;
                TrainManager = trainManager;
                TriggerData = triggerData;
            }

            public bool HandleChanges()
            {
                if (!TriggerData.Enabled)
                    return Destroy();

                var changed = EnsureTriggerCreated();

                var transform = _gameObject.transform;
                if (transform.position != TriggerPosition)
                {
                    Move();
                    changed = true;
                }
                else if (transform.rotation != WorldRotation)
                {
                    transform.rotation = WorldRotation;
                    changed = true;
                }

                if (TriggerData.IsSpawner)
                {
                    changed |= StartSpawningTrains();
                }
                else
                {
                    changed |= KillTrains();
                    changed |= StopSpawningTrains();
                }

                if (IsMapMarkerEligible())
                {
                    changed |= CreateOrUpdateColorMarkerIfNeeded();
                    changed |= CreateOrUpdateVendingMarkerIfNeeded();
                }
                else
                {
                    changed |= EntityUtils.KillEntity(ColorMarker);
                    changed |= EntityUtils.KillEntity(_vendingMarker);
                }

                return changed;
            }

            public bool Respawn()
            {
                if (!TriggerData.IsSpawner || !TriggerData.Enabled)
                    return false;

                return KillTrains() | SpawnTrain();
            }

            public void HandleTrainCarKilled(TrainCar trainCar)
            {
                _spawnedTrains?.Remove(trainCar);
            }

            public bool Destroy()
            {
                if (_gameObject == null)
                    return false;

                UnregisterSpline();
                KillTrains();
                StopSpawningTrains();
                EntityUtils.KillEntity(ColorMarker);
                EntityUtils.KillEntity(_vendingMarker);
                UnityEngine.Object.Destroy(_gameObject);
                _gameObject = null;
                Spline = null;
                return true;
            }

            public bool DidSpawnTrain(TrainCar trainCar)
            {
                return _spawnedTrains?.Contains(trainCar) ?? false;
            }

            private bool IsMapMarkerEligible()
            {
                if (!TriggerData.IsStop)
                    return false;

                if (_config.MapMarkers.Stop.DisplayOnlyWhileStopIsReachable && _routeManager.GetRoute(this) == null)
                    return false;

                return true;
            }

            private Color DetermineMarkerColor()
            {
                if (!_config.MapMarkers.Stop.ColorMarker.UseDynamicColor)
                    return _config.MapMarkers.Stop.ColorMarker.Color;

                return _routeManager.GetRoute(this)?.Color ?? _config.MapMarkers.Stop.ColorMarker.Color;
            }

            private bool EnsureTriggerCreated()
            {
                if (_gameObject != null)
                    return false;

                _gameObject = new GameObject();
                Move();

                var sphereCollider = _gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = TrainTrigger.TriggerRadius;
                sphereCollider.gameObject.layer = TrainTrigger.TriggerLayer;

                _trainTrigger = TrainTrigger.AddToGameObject(_plugin, _gameObject, TrainManager, TriggerData, this);
                return true;
            }

            private void RegisterSpline()
            {
                if (Spline == null)
                    return;

                _triggerManager.RegisterTriggerWithSpline(this, Spline);
            }

            private void UnregisterSpline()
            {
                if (Spline == null)
                    return;

                _triggerManager.UnregisterTriggerFromSpline(this, Spline);
            }

            private void Move()
            {
                UnregisterSpline();

                _gameObject.transform.SetPositionAndRotation(TriggerPosition, WorldRotation);

                if (TryFindTrackNear(WorldPosition, 2, out var spline, out var distanceOnSpline))
                {
                    Spline = spline;
                    DistanceOnSpline = distanceOnSpline;
                    RegisterSpline();
                }
                else
                {
                    Spline = null;
                    DistanceOnSpline = 0;
                }
            }

            private bool StartSpawningTrains()
            {
                _spawnedTrains ??= new List<TrainCar>(MaxSpawnedTrains);
                _spawnTrainTracked ??= SpawnTrainTracked;

                if (_trainTrigger.IsInvoking(_spawnTrainTracked))
                    return false;

                _trainTrigger.InvokeRepeating(_spawnTrainTracked, UnityEngine.Random.Range(0f, 1f), TimeBetweenSpawns);
                return true;
            }

            private bool StopSpawningTrains()
            {
                _spawnTrainTracked ??= SpawnTrainTracked;

                if (!_trainTrigger.IsInvoking(_spawnTrainTracked))
                    return false;

                _trainTrigger.CancelInvoke(_spawnTrainTracked);
                return true;
            }

            private bool SpawnTrain()
            {
                if (_spawnedTrains.Count >= MaxSpawnedTrains)
                    return false;

                if (Spline == null)
                    return false;

                var trackSelection = ApplyTrackSelection(TrackSelection.Default, TriggerData.GetTrackSelectionInstruction());

                TrainCar previousTrainCar = null;
                TrainCarPrefab previousTrainCarPrefab = null;

                foreach (var trainCarAlias in TriggerData.TrainCars)
                {
                    var trainCarPrefab = TrainCarPrefab.FindPrefab(trainCarAlias);
                    if (trainCarPrefab == null)
                        continue;

                    if (previousTrainCar == null)
                    {
                        var worldPosition = WorldPosition;
                        var trainEnginePrefab = trainCarPrefab.PrefabPath;

                        if (trainCarPrefab.TrainCarAlias == TrainCarPrefab.WorkcartAlias && TriggerData.TrainCars.Length == 1)
                        {
                            var terrainHeight = TerrainMeta.HeightMap.GetHeight(worldPosition);
                            if (worldPosition.y - terrainHeight < -1)
                            {
                                trainEnginePrefab = TrainCarPrefab.ClassicWorkcartPrefab;
                            }
                        }

                        var rotation = SpawnRotation;
                        if (trainCarPrefab.Reverse)
                        {
                            rotation = Quaternion.LookRotation(rotation * -Vector3.forward);
                        }

                        var nextTrainCar = SpawnTrainCar(trainEnginePrefab, worldPosition, rotation);
                        if (nextTrainCar == null)
                            break;

                        previousTrainCar = nextTrainCar;
                    }
                    else
                    {
                        var nextTrainCar = AddTrainCar(previousTrainCar, previousTrainCarPrefab, trainCarPrefab, trackSelection);
                        if (nextTrainCar == null)
                            break;

                        previousTrainCar = nextTrainCar;
                    }

                    previousTrainCarPrefab = trainCarPrefab;

                    _spawnedTrains.Add(previousTrainCar);
                    SpawnedTrainCarComponent.AddToEntity(previousTrainCar, this);
                }

                if ((object)previousTrainCar != null)
                {
                    previousTrainCar.Invoke(() =>
                    {
                        var trainCars = previousTrainCar.completeTrain.trainCars;
                        for (var i = trainCars.Count - 1; i >= 0; i--)
                        {
                            trainCars[i].limitNetworking = false;
                        }
                    }, 0.1f);
                }

                return true;
            }

            private void SpawnTrainTracked()
            {
                _plugin.TrackStart();
                SpawnTrain();
                _plugin.TrackEnd();
            }

            private bool KillTrains()
            {
                if (_spawnedTrains == null)
                    return false;

                for (var i = _spawnedTrains.Count - 1; i >= 0; i--)
                {
                    EntityUtils.KillEntity(_spawnedTrains[i]);
                    _spawnedTrains.RemoveAt(i);
                }

                return true;
            }

            private bool CreateOrUpdateColorMarkerIfNeeded()
            {
                if (!_config.MapMarkers.Stop.ColorMarker.Enabled)
                    return false;

                var color = DetermineMarkerColor();
                if (ColorMarker == null)
                {
                    ColorMarker = MarkerUtils.CreateColorMarker(_config.MapMarkers.Stop.ColorMarker, WorldPosition, color);
                    return true;
                }

                return EntityUtils.MoveEntity(ColorMarker, WorldPosition) | MarkerUtils.UpdateMarkerColor(ColorMarker, color);
            }

            private bool CreateOrUpdateVendingMarkerIfNeeded()
            {
                if (!_config.MapMarkers.Stop.VendingMarker.Enabled)
                    return false;

                if (_vendingMarker == null)
                {
                    _vendingMarker = MarkerUtils.CreateVendingMarker(_config.MapMarkers.Stop.VendingMarker, WorldPosition);
                    return true;
                }

                return EntityUtils.MoveEntity(_vendingMarker, WorldPosition);
            }
        }

        private class MapTriggerInstance : BaseTriggerInstance
        {
            public override Vector3 WorldPosition => TriggerData.Position;
            protected override Quaternion WorldRotation => Quaternion.Euler(0, TriggerData.RotationAngle, 0);

            public MapTriggerInstance(AutomatedWorkcarts plugin, TrainManager trainManager, TriggerData triggerData)
                : base(plugin, trainManager, triggerData) {}
        }

        private class TunnelTriggerInstance : BaseTriggerInstance
        {
            public DungeonCellWrapper DungeonCellWrapper { get; }

            public override Vector3 WorldPosition => DungeonCellWrapper.TransformPoint(TriggerData.Position);
            protected override Quaternion WorldRotation => DungeonCellWrapper.Rotation * Quaternion.Euler(0, TriggerData.RotationAngle, 0);

            public TunnelTriggerInstance(AutomatedWorkcarts plugin, TrainManager trainManager, TriggerData triggerData, DungeonCellWrapper dungeonCellWrapper)
                : base(plugin, trainManager, triggerData)
            {
                DungeonCellWrapper = dungeonCellWrapper;
            }
        }

        #endregion

        #region Trigger Controllers

        private abstract class BaseTriggerController
        {
            protected TriggerData TriggerData { get; }
            public BaseTriggerInstance[] TriggerInstanceList { get; protected set; }

            protected TrainManager _trainManager;

            protected BaseTriggerController(TrainManager trainManager, TriggerData triggerData)
            {
                _trainManager = trainManager;
                TriggerData = triggerData;
            }

            public IEnumerator HandleChangesRoutine()
            {
                foreach (var triggerInstance in TriggerInstanceList)
                {
                    if (triggerInstance.HandleChanges())
                        yield return null;
                }
            }

            public void HandleChanges()
            {
                foreach (var triggerInstance in TriggerInstanceList)
                {
                    triggerInstance.HandleChanges();
                }
            }

            public void Respawn()
            {
                foreach (var triggerInstance in TriggerInstanceList)
                {
                    triggerInstance.Respawn();
                }
            }

            public void Destroy()
            {
                if (TriggerInstanceList == null)
                    return;

                foreach (var triggerInstance in TriggerInstanceList)
                {
                    triggerInstance.Destroy();
                }
            }

            public void GetAllColorMarkers(List<MapMarkerGenericRadius> markerList)
            {
                if (TriggerInstanceList == null || !TriggerData.IsStop)
                    return;

                foreach (var triggerInstance in TriggerInstanceList)
                {
                    if (triggerInstance.ColorMarker != null)
                    {
                        markerList.Add(triggerInstance.ColorMarker);
                    }
                }
            }

            public BaseTriggerInstance FindNearest(Vector3 position, float maxDistanceSquared, out float closestDistanceSquared)
            {
                BaseTriggerInstance closestTrigger = null;
                closestDistanceSquared = float.MaxValue;

                foreach (var triggerInstance in TriggerInstanceList)
                {
                    var distanceSquared = (position - triggerInstance.WorldPosition).sqrMagnitude;
                    if (distanceSquared < closestDistanceSquared && distanceSquared <= maxDistanceSquared)
                    {
                        closestTrigger = triggerInstance;
                        closestDistanceSquared = distanceSquared;
                    }
                }

                return closestTrigger;
            }
        }

        private sealed class MapTriggerController : BaseTriggerController
        {
            public MapTriggerController(TrainManager trainManager, TriggerData triggerData)
                : base(trainManager, triggerData) {}

            public void Create(AutomatedWorkcarts plugin)
            {
                var triggerInstance = new MapTriggerInstance(plugin, _trainManager, TriggerData);
                TriggerInstanceList = new BaseTriggerInstance[] { triggerInstance };
                triggerInstance.HandleChanges();
            }
        }

        private sealed class TunnelTriggerController : BaseTriggerController
        {
            public TunnelTriggerController(TrainManager trainManager, TriggerData triggerData)
                : base(trainManager, triggerData) {}

            public void Create(AutomatedWorkcarts plugin)
            {
                var matchingDungeonCells = FindAllTunnelsOfType(TriggerData.GetTunnelType());
                TriggerInstanceList = new BaseTriggerInstance[matchingDungeonCells.Count];

                for (var i = 0; i < matchingDungeonCells.Count; i++)
                {
                    var triggerInstance = new TunnelTriggerInstance(plugin, _trainManager, TriggerData, matchingDungeonCells[i]);
                    TriggerInstanceList[i] = triggerInstance;
                    triggerInstance.HandleChanges();
                }
            }
        }

        #endregion

        #region Trigger Manager

        private class TriggerManager
        {
            private class PlayerInfo
            {
                public Timer Timer;
                public string RouteName;
            }

            private const float TriggerDisplayDuration = 1f;
            private const float TriggerDisplayRadius = TrainTrigger.TriggerRadius;

            private AutomatedWorkcarts _plugin;
            private TrainManager _trainManager;
            private Dictionary<TriggerData, BaseTriggerController> _triggerControllers = new();
            private Dictionary<TrainTrackSpline, List<BaseTriggerInstance>> _splinesToTriggers = new();
            private Dictionary<ulong, PlayerInfo> _playerInfo = new();

            private Configuration _config => _plugin._config;
            private StoredTunnelData _tunnelData => _plugin._tunnelData;
            private StoredMapData _mapData => _plugin._mapData;
            private RouteManager _routeManager => _plugin._routeManager;
            private float TriggerDisplayDistanceSquared => _config.TriggerDisplayDistance * _config.TriggerDisplayDistance;

            public TriggerManager(AutomatedWorkcarts plugin, TrainManager trainManager)
            {
                _plugin = plugin;
                _trainManager = trainManager;
            }

            public void RegisterTriggerWithSpline(BaseTriggerInstance triggerInstance, TrainTrackSpline spline)
            {
                if (!_splinesToTriggers.TryGetValue(spline, out var triggerInstanceList))
                {
                    triggerInstanceList = new List<BaseTriggerInstance>();
                    _splinesToTriggers[spline] = triggerInstanceList;
                }

                if (triggerInstanceList.Contains(triggerInstance))
                    return;

                triggerInstanceList.Add(triggerInstance);
                triggerInstanceList.Sort((a, b) => a.DistanceOnSpline.CompareTo(b.DistanceOnSpline));
            }

            public void UnregisterTriggerFromSpline(BaseTriggerInstance triggerInstance, TrainTrackSpline spline)
            {
                if (!_splinesToTriggers.TryGetValue(spline, out var triggerInstanceList))
                    return;

                triggerInstanceList.Remove(triggerInstance);
                if (triggerInstanceList.Count == 0)
                {
                    _splinesToTriggers.Remove(spline);
                }
            }

            public List<BaseTriggerInstance> GetTriggersForSpline(TrainTrackSpline spline)
            {
                return _splinesToTriggers.TryGetValue(spline, out var triggerList)
                    ? triggerList
                    : null;
            }

            public TriggerData FindTrigger(int triggerId, TrainTriggerType triggerType)
            {
                foreach (var triggerData in _triggerControllers.Keys)
                {
                    if (triggerData.TriggerType == triggerType && triggerData.Id == triggerId)
                        return triggerData;
                }

                return null;
            }

            public void AddTrigger(TriggerData triggerData)
            {
                if (triggerData.TriggerType == TrainTriggerType.Tunnel)
                {
                    if (triggerData.Id == 0)
                    {
                        triggerData.Id = GetNextTriggerId(_tunnelData.TunnelTriggers);
                    }

                    CreateTunnelTriggerController(triggerData);
                    _tunnelData.AddTrigger(triggerData);
                }
                else
                {
                    if (triggerData.Id == 0)
                    {
                        triggerData.Id = GetNextTriggerId(_mapData.MapTriggers);
                    }

                    CreateMapTriggerController(triggerData);
                    _mapData.AddTrigger(triggerData);
                }

                _routeManager.RecomputeRoutes();
            }

            public IEnumerator HandleChangesRoutine()
            {
                foreach (var triggerController in _triggerControllers.Values)
                {
                    yield return triggerController.HandleChangesRoutine();
                }
            }

            private void SaveTrigger(TriggerData triggerData)
            {
                if (triggerData.TriggerType == TrainTriggerType.Tunnel)
                {
                    _tunnelData.Save();
                }
                else
                {
                    _mapData.Save();
                }
            }

            private BaseTriggerController GetTriggerController(TriggerData triggerData)
            {
                return _triggerControllers.TryGetValue(triggerData, out var triggerController)
                    ? triggerController
                    : null;
            }

            public void UpdateTrigger(TriggerData triggerData, TriggerData newTriggerData)
            {
                var triggerController = GetTriggerController(triggerData);
                if (triggerController == null)
                    return;

                var trainCarsChanged = !CollectionsEqual(triggerData.TrainCars, newTriggerData.TrainCars);

                triggerData.CopyFrom(newTriggerData);
                triggerData.InvalidateCache();

                triggerController.HandleChanges();

                if (trainCarsChanged)
                {
                    triggerController.Respawn();
                }

                SaveTrigger(triggerData);
                _routeManager.RecomputeRoutes();
            }

            public void MoveTrigger(TriggerData triggerData, Vector3 position)
            {
                var triggerController = GetTriggerController(triggerData);
                if (triggerController == null)
                    return;

                triggerData.Position = position;
                triggerController.HandleChanges();
                SaveTrigger(triggerData);
                _routeManager.RecomputeRoutes();
            }

            public void RotateTrigger(TriggerData triggerData, float rotationAngle)
            {
                var triggerController = GetTriggerController(triggerData);
                if (triggerController == null)
                    return;

                triggerData.RotationAngle = rotationAngle;
                triggerController.HandleChanges();
                SaveTrigger(triggerData);
                _routeManager.RecomputeRoutes();
            }

            public void RespawnTrigger(TriggerData triggerData)
            {
                GetTriggerController(triggerData)?.Respawn();
            }

            public void AddTriggerCommand(TriggerData triggerData, string command)
            {
                triggerData.Commands ??= new List<string>();

                if (triggerData.Commands.Contains(command, StringComparer.InvariantCultureIgnoreCase))
                    return;

                triggerData.Commands.Add(command);
                SaveTrigger(triggerData);
            }

            public void RemoveTriggerCommand(TriggerData triggerData, int index)
            {
                triggerData.Commands.RemoveAt(index);
                SaveTrigger(triggerData);
            }

            private void DestroyTriggerController(BaseTriggerController triggerController)
            {
                triggerController.Destroy();
            }

            public void RemoveTrigger(TriggerData triggerData)
            {
                var triggerController = GetTriggerController(triggerData);
                if (triggerController == null)
                    return;

                DestroyTriggerController(triggerController);
                _triggerControllers.Remove(triggerData);

                if (triggerData.TriggerType == TrainTriggerType.Tunnel)
                {
                    _tunnelData.RemoveTrigger(triggerData);
                }
                else
                {
                    _mapData.RemoveTrigger(triggerData);
                }

                _routeManager.RecomputeRoutes();
            }

            public void GetAllColorMarkers(List<MapMarkerGenericRadius> markerList)
            {
                foreach (var triggerController in _triggerControllers.Values)
                {
                    triggerController.GetAllColorMarkers(markerList);
                }
            }

            private void CreateMapTriggerController(TriggerData triggerData)
            {
                var triggerController = new MapTriggerController(_trainManager, triggerData);
                triggerController.Create(_plugin);
                _triggerControllers[triggerData] = triggerController;
            }

            private void CreateTunnelTriggerController(TriggerData triggerData)
            {
                var triggerController = new TunnelTriggerController(_trainManager, triggerData);
                triggerController.Create(_plugin);
                _triggerControllers[triggerData] = triggerController;
            }

            public IEnumerator CreateAll()
            {
                if (_config.EnableMapTriggers)
                {
                    foreach (var triggerData in _mapData.MapTriggers)
                    {
                        CreateMapTriggerController(triggerData);
                        yield return null;
                    }
                }

                foreach (var triggerData in _tunnelData.TunnelTriggers)
                {
                    var tunnelType = triggerData.GetTunnelType();
                    if (tunnelType == TunnelType.Unsupported || !_config.IsTunnelTypeEnabled(tunnelType))
                        continue;

                    CreateTunnelTriggerController(triggerData);
                    yield return null;
                }
            }

            public void DestroyAll()
            {
                foreach (var triggerController in _triggerControllers.Values)
                {
                    DestroyTriggerController(triggerController);
                }

                _triggerControllers.Clear();
                _splinesToTriggers.Clear();
            }

            private PlayerInfo GetOrCreatePlayerInfo(BasePlayer player)
            {
                if (!_playerInfo.TryGetValue(player.userID, out var playerInfo))
                {
                    playerInfo = new PlayerInfo();
                    _playerInfo[player.userID] = playerInfo;
                }

                return playerInfo;
            }

            public void SetPlayerDisplayedRoute(BasePlayer player, string routeName)
            {
                GetOrCreatePlayerInfo(player).RouteName = routeName;
            }

            public void ShowAllRepeatedly(BasePlayer player, int duration = -1)
            {
                // Some commands can be run from the server, in which case the BasePlayer will be null.
                if (player == null)
                    return;

                var playerInfo = GetOrCreatePlayerInfo(player);

                ShowNearbyTriggers(player, player.transform.position, playerInfo.RouteName);

                if (playerInfo.Timer is { Destroyed: false })
                {
                    var newDuration = duration >= 0 ? duration : Math.Max(playerInfo.Timer.Repetitions, 60);
                    playerInfo.Timer.Reset(delay: -1, repetitions: newDuration);
                    return;
                }

                if (duration == -1)
                    duration = 60;

                playerInfo.Timer = _plugin.timer.Repeat(TriggerDisplayDuration - 0.2f, duration, () =>
                {
                    ShowNearbyTriggers(player, player.transform.position, playerInfo.RouteName);
                });
            }

            private void ShowNearbyTriggers(BasePlayer player, Vector3 playerPosition, string routeName)
            {
                var isAdmin = player.IsAdmin;
                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    player.SendNetworkUpdateImmediate();
                }

                foreach (var triggerController in _triggerControllers.Values)
                {
                    foreach (var triggerInstance in triggerController.TriggerInstanceList)
                    {
                        if ((playerPosition - triggerInstance.WorldPosition).sqrMagnitude <= TriggerDisplayDistanceSquared)
                        {
                            ShowTrigger(player, triggerInstance, routeName, triggerController.TriggerInstanceList.Length);
                        }
                    }
                }

                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private void ShowTrigger(BasePlayer player, BaseTriggerInstance trigger, string routeName, int count = 1)
            {
                var triggerData = trigger.TriggerData;
                var color = triggerData.GetColor(routeName);

                var spherePosition = trigger.TriggerPosition;
                player.SendConsoleCommand("ddraw.sphere", TriggerDisplayDuration, color, spherePosition, TriggerDisplayRadius);

                var triggerPrefix = _plugin.GetTriggerPrefix(player, triggerData);
                var infoLines = new List<string>();

                if (!triggerData.Enabled)
                {
                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerDisabled));
                }

                infoLines.Add(_plugin.GetMessage(player, Lang.InfoTrigger, triggerPrefix, triggerData.Id));

                if (triggerData.TriggerType == TrainTriggerType.Tunnel)
                {
                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerTunnel, triggerData.TunnelType, count));
                }
                else
                {
                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerMap, triggerData.Id));
                }

                if (!string.IsNullOrWhiteSpace(triggerData.Route))
                {
                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerRoute, triggerData.Route));
                }

                if (triggerData.Destroy)
                {
                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerDestroy));
                }
                else
                {
                    if (triggerData.IsSpawner)
                    {
                        var sb = new StringBuilder();
                        if (triggerData.TrainCars.Length > 10)
                        {
                            sb.AppendLine();
                        }

                        for (var i = 0; i < triggerData.TrainCars.Length; i++)
                        {
                            var trainCarPrefab = TrainCarPrefab.FindPrefab(triggerData.TrainCars[i]);
                            if (trainCarPrefab != null)
                            {
                                // Show at most 10 train cars per line.
                                if (i > 0 && i % 10 == 0)
                                {
                                    sb.AppendLine();
                                }
                                else
                                {
                                    sb.Append(" ");
                                    sb.Append(trainCarPrefab.TrainCarAlias);
                                }
                            }
                        }

                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerSpawner, sb.ToString()));

                        var spawnRotation = trigger.SpawnRotation;
                        var arrowBack = spherePosition + Vector3.up + spawnRotation * Vector3.back * 1.5f;
                        var arrowForward = spherePosition + Vector3.up + spawnRotation * Vector3.forward * 1.5f;
                        player.SendConsoleCommand("ddraw.arrow", TriggerDisplayDuration, color, arrowBack, arrowForward, 0.5f);
                    }

                    if (triggerData.AddConductor)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerAddConductor));
                    }

                    if (triggerData.Chance != 0)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerChance, triggerData.GetChance() * 100));
                    }

                    var directionInstruction = triggerData.GetDirectionInstruction();
                    var speedInstruction = triggerData.GetSpeedInstruction();

                    // When speed is zero, departure direction will be shown instead of direction.
                    if (directionInstruction != null && speedInstruction != SpeedInstruction.Zero)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerDirection, directionInstruction));
                    }

                    if (triggerData.Brake)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerBrakeToSpeed, triggerData.GetSpeedInstructionOrZero()));
                    }
                    else if (speedInstruction != null)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerSpeed, speedInstruction));
                    }

                    if (speedInstruction == SpeedInstruction.Zero)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerStopDuration, triggerData.GetStopDuration()));
                    }

                    var trackSelectionInstruction = triggerData.GetTrackSelectionInstruction();
                    if (trackSelectionInstruction != null)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerTrackSelection, trackSelectionInstruction));
                    }

                    if (directionInstruction != null && speedInstruction == SpeedInstruction.Zero)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerDepartureDirection, directionInstruction));
                    }

                    var departureSpeedInstruction = triggerData.GetDepartureSpeedInstruction();
                    if (speedInstruction == SpeedInstruction.Zero)
                    {
                        infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerDepartureSpeed, departureSpeedInstruction));
                    }
                }

                if (triggerData.Commands is { Count: > 0 })
                {
                    var commandList = "";
                    for (var i = 0; i < triggerData.Commands.Count; i++)
                    {
                        commandList += $"\n({i+1}): {triggerData.Commands[i]}";
                    }

                    infoLines.Add(_plugin.GetMessage(player, Lang.InfoTriggerCommands, commandList));
                }

                var textPosition = trigger.TriggerPosition + new Vector3(0, 1.5f + infoLines.Count * 0.075f, 0);
                player.SendConsoleCommand("ddraw.text", TriggerDisplayDuration, color, textPosition, string.Join("\n", infoLines));
            }

            public BaseTriggerInstance FindNearestTrigger(Vector3 position, float maxDistanceSquared = 9)
            {
                BaseTriggerInstance closestTriggerInstance = null;
                var closestDistanceSquared = float.MaxValue;

                foreach (var triggerController in _triggerControllers.Values)
                {
                    var triggerInstance = triggerController.FindNearest(position, maxDistanceSquared, out var distanceSquared);

                    if (distanceSquared < closestDistanceSquared && distanceSquared <= maxDistanceSquared)
                    {
                        closestTriggerInstance = triggerInstance;
                        closestDistanceSquared = distanceSquared;
                    }
                }

                return closestTriggerInstance;
            }

            public BaseTriggerInstance FindNearestTrigger(Vector3 position, TriggerData triggerData, float maxDistanceSquared = float.MaxValue)
            {
                return GetTriggerController(triggerData)?.FindNearest(position, maxDistanceSquared, out _);
            }

            public BaseTriggerInstance FindNearestTriggerWhereAiming(BasePlayer player, float maxDistanceSquared = 9)
            {
                var trainTrigger = GetHitTrigger(player);
                if (trainTrigger != null)
                    return trainTrigger.TriggerInstance;

                if (!TryGetTrackPosition(player, out var trackPosition))
                    return null;

                return FindNearestTrigger(trackPosition, maxDistanceSquared);
            }
        }

        #endregion

        #region Train Manager

        private class TrainManager
        {
            public SpawnedTrainCarTracker SpawnedTrainCarTracker { get; }

            private AutomatedWorkcarts _plugin;
            private HashSet<TrainController> _trainControllers = new();
            private Dictionary<TrainCar, ITrainCarComponent> _trainCarComponents = new();
            private bool _isUnloading;

            public int TrainCount => _trainControllers.Count;

            public int CountedConductors
            {
                get
                {
                    var count = 0;

                    foreach (var trainController in _trainControllers)
                    {
                        if (trainController.CountsTowardConductorLimit)
                        {
                            count++;
                        }
                    }

                    return count;
                }
            }

            private Configuration _config => _plugin._config;
            private StoredPluginData _data => _plugin._data;
            private RouteManager _routeManager => _plugin._routeManager;

            public TrainEngine[] GetAutomatedTrainEngines()
            {
                var trainEngineList = new List<TrainEngine>();

                foreach (var trainController in _trainControllers)
                {
                    trainController.GetTrainEngines(trainEngineList);
                }

                return trainEngineList.ToArray();
            }

            public TrainManager(AutomatedWorkcarts plugin, SpawnedTrainCarTracker spawnedTrainCarTracker)
            {
                _plugin = plugin;
                SpawnedTrainCarTracker = spawnedTrainCarTracker;
            }

            public bool CanHaveMoreConductors()
            {
                if (_config.MaxConductors < 0)
                    return true;

                return CountedConductors < _config.MaxConductors;
            }

            public List<TrainController> GetAllTrainControllers()
            {
                return _trainControllers.ToList();
            }

            public TrainController GetTrainController(TrainCar trainCar)
            {
                return _trainCarComponents.TryGetValue(trainCar, out var trainCarComponent)
                    ? trainCarComponent.TrainController
                    : null;
            }

            public bool HasTrainController(TrainCar trainCar)
            {
                return GetTrainController(trainCar) != null;
            }

            public bool TryCreateTrainController(TrainEngine primaryTrainEngine, TriggerData triggerData = null, TrainEngineData trainEngineData = null, bool countsTowardConductorLimit = true)
            {
                foreach (var trainCar in primaryTrainEngine.completeTrain.trainCars)
                {
                    if (_trainCarComponents.ContainsKey(trainCar))
                        return false;

                    var trainEngine = trainCar as TrainEngine;
                    if ((object)trainEngine != null && _plugin.AutomationWasBlocked(trainEngine))
                        return false;
                }

                trainEngineData ??= new TrainEngineData
                {
                    Route = triggerData?.Route,
                };

                var trainController = new TrainController(_plugin, this, trainEngineData, countsTowardConductorLimit);
                _trainControllers.Add(trainController);
                _routeManager.RecomputeRoutes();

                var primaryTrainEngineController = TrainEngineController.AddToEntity(_plugin, primaryTrainEngine, trainController);
                trainController.AddTrainCarComponent(primaryTrainEngineController);
                _trainCarComponents[primaryTrainEngine] = primaryTrainEngineController;

                if (!SpawnedTrainCarTracker.ContainsTrainCar(primaryTrainEngine))
                {
                    _data.AddTrainEngineId(primaryTrainEngine.net.ID.Value, trainEngineData);
                }

                var primaryForward = primaryTrainEngine.transform.forward;

                foreach (var trainCar in primaryTrainEngine.completeTrain.trainCars)
                {
                    var trainEngine = trainCar as TrainEngine;
                    if ((object)trainEngine != null)
                    {
                        if (trainEngine == primaryTrainEngine)
                            continue;

                        // This approach will need to be updated if people have long trains and/or tight corners.
                        var isReverse = Vector3.Dot(primaryForward, trainEngine.transform.forward) < 0;

                        var trainEngineController = TrainEngineController.AddToEntity(_plugin, trainEngine, trainController, isReverse);
                        _trainCarComponents[trainEngine] = trainEngineController;
                        trainController.AddTrainCarComponent(trainEngineController);
                    }
                    else
                    {
                        var trainCarComponent = TrainCarComponent.AddToEntity(trainCar, trainController);
                        _trainCarComponents[trainCar] = trainCarComponent;
                        trainController.AddTrainCarComponent(trainCarComponent);
                    }

                }

                trainController.StartTrain();

                if (triggerData != null)
                {
                    trainController.HandleConductorTrigger(triggerData);
                }

                if (_config.DebugEnableGlobalBroadcast)
                {
                    primaryTrainEngine.EnableGlobalBroadcast(true);
                }

                return true;
            }

            public void UnregisterTrainCarComponent(ITrainCarComponent trainCarComponent)
            {
                _trainCarComponents.Remove(trainCarComponent.TrainCar);

                if (!_isUnloading)
                {
                    var trainEngineController = trainCarComponent as TrainEngineController;
                    if ((object)trainEngineController != null)
                    {
                        _data.RemoveTrainEngineId(trainEngineController.NetId);
                    }
                }
            }

            public void UnregisterTrainController(TrainController trainController)
            {
                _trainControllers.Remove(trainController);
                _plugin._routeManager.RecomputeRoutes();
            }

            public void KillTrainController(TrainCar trainCar)
            {
                GetTrainController(trainCar)?.Kill();
            }

            public int ResetAll()
            {
                var trainCount = TrainCount;

                foreach (var trainController in _trainControllers.ToArray())
                {
                    // Don't reset conductors that are on spawned by conductor triggers.
                    if (!trainController.CountsTowardConductorLimit)
                        continue;

                    trainController.Kill();
                }

                return trainCount;
            }

            public void Unload()
            {
                _isUnloading = true;

                ResetAll();
            }

            public void GetAllColorMarkers(List<MapMarkerGenericRadius> markerList)
            {
                foreach (var trainController in _trainControllers)
                {
                    if (trainController == null)
                        continue;

                    if (trainController.ColorMarker != null)
                    {
                        markerList.Add(trainController.ColorMarker);
                    }
                }
            }

            public bool UpdateTrainEngineData()
            {
                var changed = false;

                foreach (var trainController in _trainControllers)
                {
                    if (trainController.UpdateTrainEngineData())
                    {
                        changed = true;
                    }
                }

                return changed;
            }

            public void ShowNearbyTrainStates(BasePlayer player, float maxDistanceSquared, float duration)
            {
                var playerPosition = player.transform.position;

                foreach (var trainController in _trainControllers)
                {
                    var primaryController = trainController.PrimaryTrainEngineController;
                    var primaryTrainPosition = primaryController.transform.position;
                    if ((playerPosition - primaryTrainPosition).sqrMagnitude > maxDistanceSquared)
                        continue;

                    var drawColor = trainController.TrainState?.Color ?? Color.grey;
                    var drawPosition = primaryTrainPosition + Vector3.up;
                    player.SendConsoleCommand("ddraw.text", duration, drawColor, drawPosition, trainController.ToString());
                }
            }
        }

        #endregion

        #region Train State

        private abstract class TrainState
        {
            protected TrainController _trainController;

            public abstract void Enter();
            public abstract void Exit();
            public abstract Color Color { get; }

            protected TrainState(TrainController trainController)
            {
                _trainController = trainController;
            }
        }

        private class DrivingState : TrainState
        {
            public override Color Color => Color.green;

            public EngineSpeeds Throttle;

            public DrivingState(TrainController trainController, EngineSpeeds throttle) : base(trainController)
            {
                Throttle = throttle;
            }

            public override void Enter()
            {
                _trainController.SetThrottle(Throttle);
            }

            public override void Exit() {}

            public override string ToString()
            {
                return $"{nameof(DrivingState)}: {Throttle}";
            }
        }

        private abstract class TransitionState : TrainState
        {
            public override Color Color => Color.grey;

            protected readonly TrainState NextState;

            protected TransitionState(TrainController trainController, TrainState nextState) : base(trainController)
            {
                _trainController = trainController;
                NextState = nextState;
            }

            public T GetNextStateOfType<T>(bool includingSelf = false) where T : TrainState
            {
                return (includingSelf ? this as T : null)
                       ?? NextState as T
                       ?? (NextState as TransitionState)?.GetNextStateOfType<T>();
            }

            public void SwitchToNextStateOfType<T>() where T : TrainState
            {
                _trainController.SwitchState(GetNextStateOfType<T>());
            }

            protected void SwitchToNextState()
            {
                _trainController.SwitchState(NextState);
            }
        }

        private class BrakingState : TransitionState
        {
            public override Color Color => Color.HSVToRGB(0.5f/6f, 1, 1);

            public EngineSpeeds TargetThrottle;
            public bool IsStopping => TargetThrottle == EngineSpeeds.Zero;

            public BrakingState(TrainController trainController, TrainState nextState, EngineSpeeds targetThrottle)
                : base(trainController, nextState)
            {
                TargetThrottle = targetThrottle;
            }

            public override void Enter()
            {
                var brakeThrottle = ApplySpeedAndDirection(_trainController.DepartureThrottle, SpeedInstruction.Lo, DirectionInstruction.Invert);
                _trainController.SetThrottle(brakeThrottle);
                _trainController.PrimaryTrainEngineController.InvokeRepeatingFixedTime(BrakeUpdate);
            }

            public override void Exit()
            {
                _trainController.PrimaryTrainEngineController.CancelInvokeFixedTime(BrakeUpdate);
            }

            private bool IsNearSpeed(EngineSpeeds desiredThrottle, float leeway = 0.1f)
            {
                var trainEngine = _trainController.PrimaryTrainEngine;

                var currentSpeed = Vector3.Dot(_trainController.PrimaryTrainEngineController.Transform.forward, trainEngine.GetLocalVelocity());
                var desiredSpeed = trainEngine.maxSpeed * GetThrottleFraction(desiredThrottle);

                // If desiring negative speed, current speed is expected to increase while braking (e.g., -10 to -5).
                // If desiring positive speed, current speed is expected to decrease while braking (e.g., 10 to 5).
                // If desiring zero speed, the direction depends on the throttle being applied (e.g., if positive, -10 to -5).
                return desiredSpeed < 0 || (desiredSpeed == 0 && GetThrottleFraction(trainEngine.CurThrottleSetting) > 0)
                    ? currentSpeed + leeway >= desiredSpeed
                    : currentSpeed - leeway <= desiredSpeed;
            }

            private void BrakeUpdate()
            {
                if (IsNearSpeed(TargetThrottle))
                {
                    SwitchToNextState();
                }
            }

            public override string ToString()
            {
                return $"{nameof(BrakingState)}: {TargetThrottle}\n{NextState}";
            }
        }

        private class IdleState : TransitionState
        {
            private const float MaxDelayMultiplier = 2f;

            public override Color Color => _isIdleDueToCollision ? Color.red : Color.white;

            private float _durationSeconds;
            private readonly bool _isIdleDueToCollision;
            private float _startTime;

            public float TimeRemaining => _startTime == 0 ? _durationSeconds : Mathf.Max(_startTime + _durationSeconds - Time.time, 0);
            public float CumulativeTimeRemaining => TimeRemaining + (GetNextStateOfType<IdleState>()?.CumulativeTimeRemaining ?? 0);
            public float TimeElapsed => _isIdleDueToCollision || _startTime == 0 ? 0 : Time.time - _startTime;

            public IdleState(TrainController trainController, TrainState nextState, float durationSeconds, bool isIdleDueToCollision = false)
                : base(trainController, nextState)
            {
                _durationSeconds = durationSeconds;
                _isIdleDueToCollision = isIdleDueToCollision;
            }

            public override void Enter()
            {
                if (!_isIdleDueToCollision && _trainController.DelaySeconds > 0)
                {
                    _durationSeconds = Mathf.Min(_durationSeconds * MaxDelayMultiplier, _durationSeconds + _trainController.DelaySeconds);
                }

                _startTime = Time.time;
                _trainController.SetThrottle(EngineSpeeds.Zero);
                _trainController.PrimaryTrainEngineController.Invoke(StopIdling, _durationSeconds);
            }

            public override void Exit()
            {
                _trainController.PrimaryTrainEngineController.CancelInvoke(StopIdling);

                if (!_isIdleDueToCollision)
                {
                    _trainController.ReduceDelay(TimeElapsed);
                }
            }

            private void StopIdling()
            {
                SwitchToNextState();
            }

            public override string ToString()
            {
                return $"{nameof(IdleState)}: {TimeRemaining:f1}{(_isIdleDueToCollision ? "*" : "")}s\n{NextState}";
            }
        }

        #endregion

        #region Train Controller

        private class TrainController
        {
            public const float ConductorTriggerMaxDelay = 1f;
            private const float CollisionIdleSeconds = 5f;

            public TrainManager TrainManager { get; }
            public TrainEngineController PrimaryTrainEngineController { get; private set; }
            public TrainState TrainState { get; private set; }
            public bool IsDestroying { get; private set; }
            public bool CountsTowardConductorLimit { get; }
            public float DelaySeconds { get; private set; }
            public MapMarkerGenericRadius ColorMarker { get; private set; }

            public TrainEngine PrimaryTrainEngine => PrimaryTrainEngineController.TrainEngine;
            public string RouteName => _trainEngineData.Route;

            private Configuration _config => _plugin._config;
            private RouteManager _routeManager => _plugin._routeManager;

            public Vector3 Forward => EngineThrottleToNumber(DepartureThrottle) >= 0
                ? PrimaryTrainEngine.transform.forward
                : -PrimaryTrainEngine.transform.forward;

            private bool _isStopped => TrainState is IdleState;
            private bool _isStopping => (TrainState as BrakingState)?.IsStopping ?? false;

            private SpawnedTrainCarTracker _spawnedTrainCarTracker => TrainManager.SpawnedTrainCarTracker;

            private DrivingState _nextDrivingState =>
                TrainState as DrivingState ?? (TrainState as TransitionState)?.GetNextStateOfType<DrivingState>();

            private IdleState _idleState =>
                (TrainState as TransitionState)?.GetNextStateOfType<IdleState>(includingSelf: true);

            private float _cumulativeTimeRemaining => _idleState?.CumulativeTimeRemaining ?? 0;
            private float _timeElapsed => _idleState?.TimeElapsed ?? 0;

            private AutomatedWorkcarts _plugin;
            private readonly List<TrainEngineController> _trainEngineControllers = new();
            private readonly List<ITrainCarComponent> _trainCarComponents = new();

            private TrainEngineData _trainEngineData;

            private Func<BasePlayer, bool> _nearbyPlayerFilter;
            private TrainCollisionTrigger _collisionTriggerA;
            private TrainCollisionTrigger _collisionTriggerB;
            private VendingMachineMapMarker _vendingMarker;
            private MapMarker _crateMarker;
            private bool _isDestroyed;

            // Desired velocity, ignoring circumstances like stopping/braking/chilling.
            public EngineSpeeds DepartureThrottle =>
                _nextDrivingState?.Throttle ?? PrimaryTrainEngine.CurThrottleSetting;

            public TrainController(AutomatedWorkcarts plugin, TrainManager trainManager, TrainEngineData workcartData, bool countsTowardConductorLimit)
            {
                _plugin = plugin;
                TrainManager = trainManager;
                _trainEngineData = workcartData;
                _nearbyPlayerFilter = NearbyPlayerFilter;
                CountsTowardConductorLimit = countsTowardConductorLimit;
            }

            public override string ToString()
            {
                var adjustment = DelaySeconds - _timeElapsed;
                var delayInfo = adjustment > 0 ? $" | {adjustment:+#.#}s" : "";
                return $"{PrimaryTrainEngine.CurThrottleSetting} | {PrimaryTrainEngine.localTrackSelection}{delayInfo}\n{TrainState?.ToString() ?? "No state"}";
            }

            public void ScheduleCinematicDestruction()
            {
                IsDestroying = true;
                PrimaryTrainEngineController.Invoke(DestroyCinematically, 0);
            }

            public void AddTrainCarComponent(ITrainCarComponent trainCarComponent)
            {
                _trainCarComponents.Add(trainCarComponent);

                var trainEngineController = trainCarComponent as TrainEngineController;
                if ((object)trainEngineController != null)
                {
                    _trainEngineControllers.Add(trainEngineController);

                    if ((object)PrimaryTrainEngineController == null)
                    {
                        PrimaryTrainEngineController = trainEngineController;
                    }
                }
            }

            public void HandleTrainCarDestroyed(ITrainCarComponent trainCarComponent)
            {
                _trainCarComponents.Remove(trainCarComponent);
                TrainManager.UnregisterTrainCarComponent(trainCarComponent);

                // Any train car removal should disable automation of the entire train.
                Kill();
            }

            public void GetTrainEngines(List<TrainEngine> trainEngineList)
            {
                foreach (var trainEngineController in _trainEngineControllers)
                {
                    trainEngineList.Add(trainEngineController.TrainEngine);
                }
            }

            public void StartTrain()
            {
                MaybeAddMapMarkers();
                SetupCollisionTriggers();

                DisableTrainCoupling(PrimaryTrainEngine.completeTrain);
                EnableInvincibility();

                var throttle = _trainEngineData.Throttle ?? EngineSpeeds.Zero;
                if (throttle == EngineSpeeds.Zero)
                {
                    throttle = _config.GetDefaultSpeed();
                }

                SwitchState(new DrivingState(this, throttle));
                SetTrackSelection(_trainEngineData.TrackSelection ?? _config.GetDefaultTrackSelection());

                if (_config.PlayHornForNearbyPlayersInRadius > 0)
                {
                    PrimaryTrainEngineController.InvokeRandomized(MaybeToggleHorn, 1f, 1f, 0.15f);
                }
            }

            public void SetThrottle(EngineSpeeds throttle)
            {
                foreach (var trainEngineController in _trainEngineControllers)
                {
                    trainEngineController.SetThrottle(throttle);
                }
            }

            public void SetTrackSelection(TrackSelection trackSelection)
            {
                foreach (var trainEngineController in _trainEngineControllers)
                {
                    trainEngineController.SetTrackSelection(trackSelection);
                }
            }

            public void HandleTrigger(TriggerData triggerData)
            {
                if (!triggerData.MatchesRoute(_trainEngineData.Route))
                    return;

                var chance = triggerData.GetChance();
                if (chance != 0 && UnityEngine.Random.Range(0f, 1f) >= chance)
                    return;

                if (triggerData.Commands is { Count: > 0 })
                {
                    foreach (var command in triggerData.Commands)
                    {
                        var fullCommand = IdRegex.Replace(command, PrimaryTrainEngineController.NetIdString);
                        if (!string.IsNullOrWhiteSpace(fullCommand))
                        {
                            _plugin.server.Command(fullCommand);
                        }
                    }
                }

                if (triggerData.Destroy)
                {
                    PrimaryTrainEngineController.Invoke(() =>
                    {
                        foreach (var trainCarComponent in _trainCarComponents.ToArray())
                        {
                            EntityUtils.KillEntity(trainCarComponent.TrainCar, BaseNetworkable.DestroyMode.Gib);
                        }
                    }, 0);

                    return;
                }

                SetTrackSelection(
                    ApplyTrackSelection(PrimaryTrainEngine.localTrackSelection, triggerData.GetTrackSelectionInstruction())
                );

                var directionInstruction = triggerData.GetDirectionInstruction();
                var departureSpeedInstruction = triggerData.GetDepartureSpeedInstruction();

                var currentDepartureThrottle = DepartureThrottle;
                var newDepartureThrottle = ApplySpeedAndDirection(currentDepartureThrottle, departureSpeedInstruction, directionInstruction);

                if (triggerData.Brake)
                {
                    var brakeSpeedInstruction = triggerData.GetSpeedInstructionOrZero();
                    if (brakeSpeedInstruction == SpeedInstruction.Zero)
                    {
                        var finalState = new DrivingState(this, newDepartureThrottle);
                        var nextState = new IdleState(this, finalState, triggerData.GetStopDuration());
                        SwitchState(new BrakingState(this, nextState, EngineSpeeds.Zero));
                        return;
                    }

                    var brakeUntilVelocity = ApplySpeedAndDirection(currentDepartureThrottle, brakeSpeedInstruction, directionInstruction);
                    SwitchState(new BrakingState(this, new DrivingState(this, brakeUntilVelocity), brakeUntilVelocity));
                    return;
                }

                var speedInstruction = triggerData.GetSpeedInstruction();
                if (speedInstruction == SpeedInstruction.Zero)
                {
                    if (TrainState is BrakingState brakingState)
                    {
                        // Update brake-to speed.
                        brakingState.TargetThrottle = EngineSpeeds.Zero;
                        return;
                    }

                    // Trigger with speed Zero, but no braking.
                    SwitchState(new IdleState(this, new DrivingState(this, newDepartureThrottle), triggerData.GetStopDuration()));
                    return;
                }

                var nextThrottle = ApplySpeedAndDirection(currentDepartureThrottle, speedInstruction, directionInstruction);

                if (TrainState is DrivingState drivingState)
                {
                    drivingState.Throttle = nextThrottle;
                }
                else
                {
                    SwitchState(new DrivingState(this, nextThrottle));
                }

                SetThrottle(nextThrottle);
            }

            public bool UpdateMarkerColor()
            {
                return MarkerUtils.UpdateMarkerColor(ColorMarker, DetermineMarkerColor());
            }

            public void PauseEngine(float scheduleAdjustment = 0)
            {
                if (TrainState is IdleState)
                    return;

                DelaySeconds = Mathf.Max(scheduleAdjustment, DelaySeconds);
                SwitchState(new IdleState(this, TrainState, CollisionIdleSeconds, isIdleDueToCollision: true));
            }

            public void ReduceDelay(float amount)
            {
                DelaySeconds = Mathf.Max(DelaySeconds - amount, 0);
            }

            public float DepartEarlyIfStoppedOrStopping()
            {
                if (TrainState is not TransitionState transitionState)
                    return DelaySeconds;

                var timeRemaining = _cumulativeTimeRemaining;
                transitionState.SwitchToNextStateOfType<DrivingState>();
                DelaySeconds = Mathf.Max(timeRemaining, DelaySeconds);
                return DelaySeconds;
            }

            public void SwitchState(TrainState nextState)
            {
                TrainState?.Exit();
                TrainState = nextState;
                nextState?.Enter();
            }

            public void HandleConductorTrigger(TriggerData triggerData)
            {
                SetThrottle(EngineSpeeds.Zero);

                // Delay a random interval to spread out load.
                PrimaryTrainEngineController.Invoke(() =>
                {
                    HandleTrigger(triggerData);
                }, UnityEngine.Random.Range(0f, ConductorTriggerMaxDelay));
            }

            public bool UpdateTrainEngineData()
            {
                if (_spawnedTrainCarTracker.ContainsTrainCar(PrimaryTrainEngine))
                    return false;

                return _trainEngineData.UpdateData(DepartureThrottle, PrimaryTrainEngine.localTrackSelection);
            }

            public void Kill()
            {
                if (_isDestroyed)
                    return;

                _isDestroyed = true;

                UnityEngine.Object.DestroyImmediate(_collisionTriggerA);
                UnityEngine.Object.DestroyImmediate(_collisionTriggerB);

                DisableInvincibility();

                foreach (var trainCarComponent in _trainCarComponents)
                {
                    UpdateAllowedCouplings(trainCarComponent.TrainCar, allowFront: true, allowRear: true);
                }

                EntityUtils.KillEntity(ColorMarker);
                EntityUtils.KillEntity(_vendingMarker);
                EntityUtils.KillEntity(_crateMarker);

                for (var i = _trainCarComponents.Count - 1; i >= 0; i--)
                {
                    UnityEngine.Object.DestroyImmediate(_trainCarComponents[i] as FacepunchBehaviour);
                }

                TrainManager.UnregisterTrainController(this);

                if (_config.DebugEnableGlobalBroadcast)
                {
                    PrimaryTrainEngine.EnableGlobalBroadcast(false);
                }
            }

            private Color DetermineMarkerColor()
            {
                if (!_config.MapMarkers.Train.ColorMarker.UseDynamicColor)
                    return _config.MapMarkers.Train.ColorMarker.Color;

                return _routeManager.GetRoute(this)?.Color ?? _config.MapMarkers.Train.ColorMarker.Color;
            }

            private bool IsPlayerOnboardTrain(BasePlayer player)
            {
                var trainCar = player.GetParentEntity() as TrainCar
                    ?? player.GetMountedVehicle() as TrainCar;

                if ((object)trainCar == null)
                    return false;

                return TrainManager.GetTrainController(trainCar) == this;
            }

            private bool NearbyPlayerFilter(BasePlayer player)
            {
                if (player.IsDestroyed || !player.IsConnected || !player.userID.IsSteamId() || player.IsDead() || player.IsSleeping() || player.IsSpectating())
                    return false;

                if (IsPlayerOnboardTrain(player))
                    return false;

                return true;
            }

            private bool ShouldPlayHorn()
            {
                if (_isStopped || _isStopping)
                    return false;

                return Query.Server.GetPlayersInSphere(
                    PrimaryTrainEngineController.Position,
                    _config.PlayHornForNearbyPlayersInRadius,
                    _plugin._playerQueryResults,
                    _nearbyPlayerFilter
                ) > 0;
            }

            private void MaybeToggleHorn()
            {
                _plugin.TrackStart();
                PrimaryTrainEngine.SetFlag(Flag_Horn, ShouldPlayHorn());
                _plugin.TrackEnd();
            }

            private void MaybeAddMapMarkers()
            {
                var trainMarkerConfig = _config.MapMarkers.Train;
                if (trainMarkerConfig.ColorMarker.Enabled)
                {
                    ColorMarker = MarkerUtils.CreateColorMarker(trainMarkerConfig.ColorMarker, PrimaryTrainEngineController.Position, DetermineMarkerColor());
                }

                if (trainMarkerConfig.VendingMarker.Enabled)
                {
                    _vendingMarker = MarkerUtils.CreateVendingMarker(trainMarkerConfig.VendingMarker, PrimaryTrainEngineController.Position);
                }

                if (_config.DebugShowCrateMarkers)
                {
                    _crateMarker = GameManager.server.CreateEntity(CrateMarkerPrefab) as MapMarker;
                    if (_crateMarker != null)
                    {
                        _crateMarker.EnableSaving(false);
                        _crateMarker.SetParent(PrimaryTrainEngine);
                        _crateMarker.Spawn();
                    }
                }

                if (ColorMarker == null && _vendingMarker == null)
                    return;

                // Periodically update the marker positions since they aren't parented to the train engines.
                // We could parent them to the train engines, but then they would only appear to players in network radius,
                // and enabling global broadcast for lots of train engines would significantly reduce client FPS.
                PrimaryTrainEngineController.InvokeRandomized(() =>
                {
                    _plugin.TrackStart();

                    if (ColorMarker != null)
                    {
                        ColorMarker.transform.position = PrimaryTrainEngineController.Position;
                        ColorMarker.InvalidateNetworkCache();
                        ColorMarker.SendNetworkUpdate_Position();
                    }

                    if (_vendingMarker != null)
                    {
                        _vendingMarker.transform.position = PrimaryTrainEngineController.Position;
                        _vendingMarker.InvalidateNetworkCache();
                        _vendingMarker.SendNetworkUpdate_Position();
                    }

                    _plugin.TrackEnd();
                }, 0, trainMarkerConfig.UpdateIntervalSeconds, trainMarkerConfig.UpdateIntervalSeconds * 0.1f);
            }

            private void EnableInvincibility()
            {
                foreach (var trainCarComponent in _trainCarComponents)
                {
                    AutomatedWorkcarts.EnableInvincibility(trainCarComponent.TrainCar);
                }
            }

            private void DisableInvincibility()
            {
                foreach (var trainCarComponent in _trainCarComponents)
                {
                    AutomatedWorkcarts.DisableInvincibility(trainCarComponent.TrainCar);
                }
            }

            private void SetupCollisionTriggers()
            {
                var completeTrain = PrimaryTrainEngine.completeTrain;
                var frontTrigger = completeTrain.frontCollisionTrigger;
                var rearTrigger = completeTrain.rearCollisionTrigger;

                _collisionTriggerA = TrainCollisionTrigger.AddToTrigger(_plugin, frontTrigger, frontTrigger.owner, this);
                _collisionTriggerB = TrainCollisionTrigger.AddToTrigger(_plugin, rearTrigger, rearTrigger.owner, this);
            }

            private void DestroyCinematically()
            {
                foreach (var trainCarComponent in _trainCarComponents.ToArray())
                {
                    DestroyTrainCarCinematically(trainCarComponent.TrainCar);
                }
            }
        }

        private class TrainCollisionTrigger : TriggerBase
        {
            public static TrainCollisionTrigger AddToTrigger(AutomatedWorkcarts plugin, TriggerBase hostTrigger, TrainCar trainCar, TrainController trainController)
            {
                var component = hostTrigger.gameObject.AddComponent<TrainCollisionTrigger>();
                component._plugin = plugin;
                component.interestLayers = hostTrigger.interestLayers;
                component.TrainController = trainController;
                component.TrainCar = trainCar;
                return component;
            }

            public TrainController TrainController { get; private set; }
            public TrainCar TrainCar { get; private set; }
            private AutomatedWorkcarts _plugin;
            private Configuration _config => _plugin._config;

            public override void OnEntityEnter(BaseEntity entity)
            {
                _plugin.TrackStart();
                HandleEntityCollision(entity);
                _plugin.TrackEnd();
            }

            private void HandleEntityCollision(BaseEntity entity)
            {
                switch (entity)
                {
                    case TrainCar trainCar:
                    {
                        HandleTrainCar(trainCar);
                        break;
                    }
                    case JunkPile or LootContainer:
                    {
                        var entity2 = entity;
                        entity.Invoke(() =>
                        {
                            if (entity2.IsDestroyed)
                                return;

                            entity2.Kill();
                            LogWarning($"Automated train destroyed entity '{entity2.ShortPrefabName}' in its path at {transform.position}.");
                        }, 0);
                        break;
                    }
                    case BaseCombatEntity:
                    {
                        if (_config.DestroyBarricadesInstantly && entity.GetComponent<HittableByTrains>() != null)
                        {
                            var entity2 = entity;
                            entity.Invoke(() =>
                            {
                                if (entity2.IsDestroyed)
                                    return;

                                entity2.Kill();
                            }, 0);
                        }

                        break;
                    }
                }
            }

            private void HandleTrainCar(TrainCar otherTrainCar)
            {
                entityContents ??= new HashSet<BaseEntity>();

                // Ignore if already colliding with that train car.
                if (!entityContents.Add(otherTrainCar))
                    return;

                if (_config.DebugShowCollisionsMarkers)
                {
                    var explosionMarker = GameManager.server.CreateEntity(ExplosionMapMakerPrefab, transform.position) as MapMarker;
                    if (explosionMarker != null)
                    {
                        explosionMarker.EnableSaving(false);
                        explosionMarker.EnableGlobalBroadcast(true);
                        explosionMarker.Spawn();
                        explosionMarker.Invoke(() => explosionMarker.Kill(), 30f);
                    }
                }

                var otherController = TrainController.TrainManager.GetTrainController(otherTrainCar);

                var forward = TrainController.Forward;
                var otherForward = otherController?.Forward ?? GetTrainCarForward(otherTrainCar);

                if (Vector3.Dot(forward, otherForward) >= 0.01f)
                {
                    // Going same direction.
                    DetermineTrainCarOrientations(TrainCar, forward, otherTrainCar, out var forwardTrainCar);

                    var forwardController = TrainController;
                    var backwardController = otherController;

                    if (forwardTrainCar == otherTrainCar)
                    {
                        forwardController = otherController;
                        backwardController = TrainController;
                    }

                    var scheduleAdjustment = 0f;
                    if (forwardController != null)
                    {
                        scheduleAdjustment = forwardController.DepartEarlyIfStoppedOrStopping();
                    }
                    else if (_config.BulldozeOffendingWorkcarts)
                    {
                        LogWarning($"Destroying non-automated train due to blocking an automated train.");
                        ScheduleDestroyTrainCarCinematically(forwardTrainCar);
                        return;
                    }

                    backwardController?.PauseEngine(scheduleAdjustment);
                }
                else
                {
                    // Going opposite directions or perpendicular.
                    if (otherController == null)
                    {
                        if (_config.BulldozeOffendingWorkcarts)
                        {
                            LogWarning($"Destroying non-automated train due to head-on collision with an automated train.");
                            ScheduleDestroyTrainCarCinematically(otherTrainCar);
                        }
                        else
                        {
                            TrainController.PauseEngine();
                        }

                        return;
                    }

                    // Don't destroy both, since the collision event can happen for both trains in the same frame.
                    if (TrainController.IsDestroying)
                        return;

                    LogWarning($"Destroying automated train due to head-on collision with another.");
                    if (TrainCar.GetTrackSpeed() < otherTrainCar.GetTrackSpeed())
                    {
                        TrainController.ScheduleCinematicDestruction();
                    }
                    else
                    {
                        otherController.ScheduleCinematicDestruction();
                    }
                }
            }
        }

        private interface ITrainCarComponent
        {
            TrainController TrainController { get; }
            TrainCar TrainCar { get; }
        }

        private class TrainCarComponent : FacepunchBehaviour, ITrainCarComponent
        {
            public static TrainCarComponent AddToEntity(TrainCar trainCar, TrainController trainController)
            {
                var component = trainCar.gameObject.AddComponent<TrainCarComponent>();
                component.TrainController = trainController;
                component.TrainCar = trainCar;
                return component;
            }

            public TrainController TrainController { get; private set; }
            public TrainCar TrainCar { get; private set; }

            private void OnDestroy()
            {
                TrainController.HandleTrainCarDestroyed(this);
            }
        }

        private class TrainEngineController : FacepunchBehaviour, ITrainCarComponent
        {
            public static TrainEngineController AddToEntity(AutomatedWorkcarts plugin, TrainEngine trainEngine, TrainController trainController, bool isReverse = false)
            {
                var trainEngineController = trainEngine.gameObject.AddComponent<TrainEngineController>();
                trainEngineController.Init(plugin, trainEngine, trainController, isReverse);
                return trainEngineController;
            }

            public TrainController TrainController { get; private set; }
            public TrainEngine TrainEngine { get; private set; }
            public Transform Transform { get; private set; }
            public NPCShopKeeper Conductor { get; private set; }
            public ulong NetId { get; private set; }
            public string NetIdString { get; private set; }
            private AutomatedWorkcarts _plugin;
            private bool _isReverse;

            public TrainCar TrainCar => TrainEngine;
            public Vector3 Position => Transform.position;
            private Configuration _config => _plugin._config;

            public void Init(AutomatedWorkcarts plugin, TrainEngine trainEngine, TrainController trainController, bool isReverse)
            {
                _plugin = plugin;
                TrainController = trainController;
                TrainEngine = trainEngine;
                Transform = trainEngine.transform;
                NetId = trainEngine.net.ID.Value;
                NetIdString = NetId.ToString();

                _isReverse = isReverse;

                trainEngine.SetHealth(trainEngine.MaxHealth());

                AddConductor();
                EnableUnlimitedFuel();

                TrainEngine.engineController.TryStartEngine(Conductor);

                // Delay disabling hazard checks since starting the engine is not immediate.
                Invoke(DisableHazardChecks, 1f);

                ExposedHooks.OnWorkcartAutomationStarted(trainEngine);
            }

            public void SetThrottle(EngineSpeeds throttle)
            {
                if (_isReverse && throttle != EngineSpeeds.Zero)
                {
                    throttle = ApplyDirection(throttle, DirectionInstruction.Invert);
                }

                TrainEngine.SetThrottle(throttle);
            }

            public void SetTrackSelection(TrackSelection trackSelection)
            {
                if (_isReverse)
                {
                    trackSelection = ApplyTrackSelection(trackSelection, TrackSelectionInstruction.Swap);
                }

                TrainEngine.SetTrackSelection(trackSelection);
            }

            private BaseMountable GetDriverSeat()
            {
                foreach (var mountPoint in TrainEngine.mountPoints)
                {
                    if (mountPoint.isDriver)
                        return mountPoint.mountable;
                }

                return null;
            }

            private void AddOutfit()
            {
                Conductor.inventory.Strip();

                foreach (var itemInfo in _config.ConductorOutfit)
                {
                    var itemDefinition = itemInfo.ItemDefinition;
                    if (itemDefinition != null)
                    {
                        Conductor.inventory.containerWear.AddItem(itemDefinition, 1, itemInfo.SkinId);
                    }
                }

                Conductor.SendNetworkUpdate();
            }

            private void AddConductor()
            {
                TrainEngine.DismountAllPlayers();

                var driverSeat = GetDriverSeat();
                if (driverSeat == null)
                    return;

                Conductor = GameManager.server.CreateEntity(ShopkeeperPrefab, driverSeat.transform.position) as NPCShopKeeper;
                if (Conductor == null)
                    return;

                Conductor.EnableSaving(false);
                Conductor.Spawn();

                Conductor.CancelInvoke(Conductor.Greeting);
                Conductor.CancelInvoke(Conductor.TickMovement);

                // Simple and performant way to prevent NPCs and turrets from targeting the conductor.
                Conductor.DisablePlayerCollider();
                Query.Server.RemovePlayer(Conductor);
                Conductor.transform.localScale = Vector3.zero;

                AddOutfit();
                driverSeat.AttemptMount(Conductor, doMountChecks: false);
            }

            private void DisableHazardChecks()
            {
                TrainEngine.SetFlag(Flag_HazardAhead, false);
                TrainEngine.CancelInvoke(TrainEngine.CheckForHazards);
            }

            private void EnableHazardChecks()
            {
                if (TrainEngine.IsOn() && !TrainEngine.IsInvoking(TrainEngine.CheckForHazards))
                {
                    TrainEngine.InvokeRandomized(TrainEngine.CheckForHazards, 0f, 1f, 0.1f);
                }
            }

            private void EnableUnlimitedFuel()
            {
                if (TrainEngine.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                    return;

                fuelSystem.cachedHasFuel = true;
                fuelSystem.nextFuelCheckTime = float.MaxValue;
            }

            private void DisableUnlimitedFuel()
            {
                if (TrainEngine.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                    return;

                fuelSystem.nextFuelCheckTime = 0;
            }

            private void OnDestroy()
            {
                TrainController.HandleTrainCarDestroyed(this);

                if (Conductor != null && !Conductor.IsDestroyed)
                {
                    Conductor.EnsureDismounted();
                    Conductor.Kill();
                }

                if (TrainEngine != null && !TrainEngine.IsDestroyed)
                {
                    DisableUnlimitedFuel();
                    EnableHazardChecks();
                    EnableTrainCoupling(TrainEngine.completeTrain);
                    ExposedHooks.OnWorkcartAutomationStopped(TrainEngine);
                }
            }
        }

        #endregion

        #region Data

        [JsonObject(MemberSerialization.OptIn)]
        private class TrainEngineData
        {
            [JsonProperty("Route", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Route;

            [JsonProperty("Throttle", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(StringEnumConverter))]
            public EngineSpeeds? Throttle { get; private set; }

            [JsonProperty("TrackSelection", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [JsonConverter(typeof(StringEnumConverter))]
            public TrackSelection? TrackSelection { get; private set; }

            public bool UpdateData(EngineSpeeds throttle, TrackSelection trackSelection)
            {
                var changed = false;

                if (Throttle != throttle)
                {
                    Throttle = throttle;
                    changed = true;
                }

                if (TrackSelection != trackSelection)
                {
                    TrackSelection = trackSelection;
                    changed = true;
                }

                return changed;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class StoredPluginData
        {
            public static StoredPluginData Clear()
            {
                var data = new StoredPluginData();
                data.Save();
                return data;
            }

            [JsonProperty("AutomatedWorkcardIds", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public HashSet<ulong> AutomatedWorkcartIds;

            [JsonProperty("AutomatedWorkcarts")]
            public Dictionary<ulong, TrainEngineData> AutomatedTrainEngines = new();

            [JsonIgnore]
            private bool _isDirty;

            public static string Filename => nameof(AutomatedTrainEngines);

            public static StoredPluginData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<StoredPluginData>(Filename) ?? new StoredPluginData();

                // Migrate from the legacy `AutomatedWorkcartIds` to `AutomatedWorkcarts` which supports data.
                if (data.AutomatedWorkcartIds != null)
                {
                    foreach (var trainEngineId in data.AutomatedWorkcartIds)
                    {
                        data.AutomatedTrainEngines[trainEngineId] = new TrainEngineData();
                    }

                    data.AutomatedWorkcartIds = null;
                }

                return data;
            }

            public void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
            }

            public void SaveIfDirty()
            {
                if (_isDirty)
                {
                    Save();
                }
            }

            public TrainEngineData GetTrainEngineData(ulong trainCarId)
            {
                return AutomatedTrainEngines.TryGetValue(trainCarId, out var trainEngineData)
                    ? trainEngineData
                    : null;
            }

            public void AddTrainEngineId(ulong trainEngineId, TrainEngineData trainEngineData)
            {
                if (AutomatedTrainEngines.ContainsKey(trainEngineId))
                    return;

                AutomatedTrainEngines[trainEngineId] = trainEngineData;
                _isDirty = true;
            }

            public void RemoveTrainEngineId(ulong trainEngineId)
            {
                if (AutomatedTrainEngines.Remove(trainEngineId))
                {
                    _isDirty = true;
                }
            }

            public void TrimToTrainEngineIds(HashSet<ulong> foundTrainEngineIds)
            {
                foreach (var trainEngineId in AutomatedTrainEngines.Keys.ToArray())
                {
                    if (!foundTrainEngineIds.Contains(trainEngineId))
                    {
                        RemoveTrainEngineId(trainEngineId);
                    }
                }

                SaveIfDirty();
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class StoredMapData
        {
            [JsonProperty("MapTriggers")]
            public List<TriggerData> MapTriggers = new();

            // Return example: proceduralmap.1500.548423.212
            private static string GetPerWipeSaveName()
            {
                return World.SaveFileName.Substring(0, World.SaveFileName.LastIndexOf("."));
            }

            // Return example: proceduralmap.1500.548423
            private static string GetCrossWipeSaveName()
            {
                var saveName = GetPerWipeSaveName();
                return saveName[..saveName.LastIndexOf(".")];
            }

            private static bool IsProcedural() => World.SaveFileName.StartsWith("proceduralmap");

            private static string GetPerWipeFilePath() => $"{nameof(AutomatedWorkcarts)}/{GetPerWipeSaveName()}";
            private static string GetCrossWipeFilePath() => $"{nameof(AutomatedWorkcarts)}/{GetCrossWipeSaveName()}";
            private static string GetFilepath() => IsProcedural() ? GetPerWipeFilePath() : GetCrossWipeFilePath();

            public static StoredMapData Load()
            {
                var filepath = GetFilepath();

                if (Interface.Oxide.DataFileSystem.ExistsDatafile(filepath))
                    return Interface.Oxide.DataFileSystem.ReadObject<StoredMapData>(filepath) ?? new StoredMapData();

                if (!IsProcedural())
                {
                    var perWipeFilepath = GetPerWipeFilePath();
                    if (Interface.Oxide.DataFileSystem.ExistsDatafile(perWipeFilepath))
                    {
                        var data = Interface.Oxide.DataFileSystem.ReadObject<StoredMapData>(perWipeFilepath);
                        if (data != null)
                        {
                            LogWarning($"Migrating map data file from '{perWipeFilepath}.json' to '{filepath}.json'");
                            data.Save();
                            return data;
                        }
                    }
                }

                return new StoredMapData();
            }

            public StoredMapData Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(GetFilepath(), this);
                return this;
            }

            public void AddTrigger(TriggerData customTrigger)
            {
                MapTriggers.Add(customTrigger);
                Save();
            }

            public void RemoveTrigger(TriggerData triggerData)
            {
                MapTriggers.Remove(triggerData);
                Save();
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class StoredTunnelData
        {
            private const float DefaultStationStopDuration = 15;
            private const float DefaultQuickStopDuration = 5;
            private const float DefaultTriggerHeight = 0.29f;

            public static string Filename => $"{nameof(AutomatedWorkcarts)}/TunnelTriggers";

            public static StoredTunnelData Load()
            {
                var dataExists = Interface.Oxide.DataFileSystem.ExistsDatafile(Filename);
                var data = dataExists
                    ? Interface.Oxide.DataFileSystem.ReadObject<StoredTunnelData>(Filename) ?? GetDefaultData()
                    : GetDefaultData();

                if (MigrateToLatest(data) && dataExists)
                {
                    data.Save();
                }

                return data;
            }

            private static bool MigrateToLatest(StoredTunnelData data)
            {
                return MigrateTriggersToMaintenanceTunnels(data)
                     | MigrateV0ToV1(data);
            }

            private static bool MigrateTriggersToMaintenanceTunnels(StoredTunnelData data)
            {
                var changed = false;

                foreach (var triggerData in data.TunnelTriggers)
                {
                    var tunnelType = triggerData.GetTunnelType();
                    if (tunnelType == TunnelType.TrainStation)
                    {
                        if (triggerData.Position == new Vector3(0, DefaultTriggerHeight, -84))
                        {
                            triggerData.Position = new Vector3(45, DefaultTriggerHeight, 18);
                            changed = true;
                            continue;
                        }

                        if (triggerData.Position == new Vector3(0, DefaultTriggerHeight, 84))
                        {
                            triggerData.Position = new Vector3(-45, DefaultTriggerHeight, -18);
                            changed = true;
                            continue;
                        }
                    }
                }

                return changed;
            }

            private static bool MigrateV0ToV1(StoredTunnelData data)
            {
                if (data.DataFileVersion != 0)
                    return false;

                data.DataFileVersion++;

                // Add VerticalIntersection triggers.
                data.TunnelTriggers.Add(new TriggerData
                {
                    Id = GetNextTriggerId(data.TunnelTriggers),
                    Position = new Vector3(-85, DefaultTriggerHeight, 3.0f),
                    TunnelType = TunnelType.VerticalIntersection.ToString(),
                    TrackSelection = TrackSelectionInstruction.Default.ToString(),
                });

                data.TunnelTriggers.Add(new TriggerData
                {
                    Id = GetNextTriggerId(data.TunnelTriggers),
                    Position = new Vector3(0, DefaultTriggerHeight, 3.0f),
                    TunnelType = TunnelType.VerticalIntersection.ToString(),
                    TrackSelection = TrackSelectionInstruction.Left.ToString(),
                });

                return true;
            }

            [JsonProperty("DataFileVersion", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public float DataFileVersion;

            [JsonProperty("TunnelTriggers")]
            public List<TriggerData> TunnelTriggers = new();

            public StoredTunnelData Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(Filename, this);
                return this;
            }

            public void AddTrigger(TriggerData triggerData)
            {
                TunnelTriggers.Add(triggerData);
                Save();
            }

            public void RemoveTrigger(TriggerData triggerData)
            {
                TunnelTriggers.Remove(triggerData);
                Save();
            }

            public static StoredTunnelData GetDefaultData()
            {
                return new StoredTunnelData
                {
                    TunnelTriggers =
                    {
                        new TriggerData
                        {
                            Id = 1,
                            Position = new Vector3(4.5f, DefaultTriggerHeight, 52),
                            TunnelType = TunnelType.TrainStation.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = DefaultStationStopDuration,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 2,
                            Position = new Vector3(45, DefaultTriggerHeight, 18),
                            TunnelType = TunnelType.TrainStation.ToString(),
                            AddConductor = true,
                            Direction = DirectionInstruction.Fwd.ToString(),
                            Speed = SpeedInstruction.Hi.ToString(),
                            TrackSelection = TrackSelectionInstruction.Left.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 3,
                            Position = new Vector3(-4.5f, DefaultTriggerHeight, -11),
                            TunnelType = TunnelType.TrainStation.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = DefaultStationStopDuration,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 4,
                            Position = new Vector3(-45, DefaultTriggerHeight, -18),
                            TunnelType = TunnelType.TrainStation.ToString(),
                            AddConductor = true,
                            Direction = DirectionInstruction.Fwd.ToString(),
                            Speed = SpeedInstruction.Hi.ToString(),
                            TrackSelection = TrackSelectionInstruction.Left.ToString(),
                        },

                        new TriggerData
                        {
                            Id = 5,
                            Position = new Vector3(-4.45f, DefaultTriggerHeight, -31),
                            TunnelType = TunnelType.BarricadeTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Med.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 6,
                            Position = new Vector3(-4.5f, DefaultTriggerHeight, -1f),
                            TunnelType = TunnelType.BarricadeTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = 5,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 7,
                            Position = new Vector3(4.45f, DefaultTriggerHeight, 39),
                            TunnelType = TunnelType.BarricadeTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Med.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 8,
                            Position = new Vector3(4.5f, DefaultTriggerHeight, 9f),
                            TunnelType = TunnelType.BarricadeTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = 5,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },

                        new TriggerData
                        {
                            Id = 9,
                            Position = new Vector3(3, DefaultTriggerHeight, 35f),
                            TunnelType = TunnelType.LootTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = DefaultQuickStopDuration,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },
                        new TriggerData
                        {
                            Id = 10,
                            Position = new Vector3(-3, DefaultTriggerHeight, -35f),
                            TunnelType = TunnelType.LootTunnel.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = DefaultQuickStopDuration,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },

                        new TriggerData
                        {
                            Id = 11,
                            Position = new Vector3(35, DefaultTriggerHeight, -3.0f),
                            TunnelType = TunnelType.Intersection.ToString(),
                            Brake = true,
                            Speed = SpeedInstruction.Zero.ToString(),
                            StopDuration = DefaultQuickStopDuration,
                            DepartureSpeed = SpeedInstruction.Hi.ToString(),
                        },
                    }
                };
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class ItemInfo
        {
            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("Skin")]
            public ulong SkinId;

            [JsonIgnore]
            public ItemDefinition ItemDefinition;

            public void Init()
            {
                var itemDefinition = ItemManager.FindItemDefinition(ShortName);
                if (itemDefinition != null)
                {
                    ItemDefinition = itemDefinition;
                }
                else
                {
                    LogError($"Invalid item short name in config: '{ShortName}'");
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class ColorMarkerOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Color")]
            public string HexColor = "#00ff00";

            [JsonProperty("Alpha")]
            public float Alpha = 1;

            [JsonProperty("Radius")]
            public float Radius;

            [JsonProperty("Use dynamic route color")]
            public bool UseDynamicColor;

            [JsonIgnore]
            public Color Color;

            public bool EnabledAndDynamic => Enabled && UseDynamicColor;

            public void Init()
            {
                if (ColorUtility.TryParseHtmlString(HexColor, out var color))
                {
                    Color = color;
                }
                else
                {
                    LogError($"Invalid HTML color code in config: {HexColor}");
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingMarkerOptions
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Name")]
            public string Name;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class TrainMarkerOptions
        {
            [JsonProperty("Map marker update interval seconds")]
            public float UpdateIntervalSeconds = 5.0f;

            [JsonProperty("Colored map marker")]
            public ColorMarkerOptions ColorMarker = new() { Radius = 0.05f };

            [JsonProperty("Vending map marker")]
            public VendingMarkerOptions VendingMarker = new() { Name = "Automated Train" };

            public void Init()
            {
                ColorMarker?.Init();
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class StopMarkerOptions
        {
            [JsonProperty("Display only while stop is reachable")]
            public bool DisplayOnlyWhileStopIsReachable;

            [JsonProperty("Colored map marker")]
            public ColorMarkerOptions ColorMarker = new()
            {
                Radius = 0.1f,
                HexColor = "#ff9900",
            };

            [JsonProperty("Vending map marker")]
            public VendingMarkerOptions VendingMarker = new() { Name = "Train Stop" };

            [JsonIgnore]
            private bool AnyMarkersEnabled => ColorMarker is { Enabled: true } || VendingMarker is { Enabled: true };

            [JsonIgnore]
            public bool AnyDynamicMarkers => AnyMarkersEnabled && (DisplayOnlyWhileStopIsReachable || ColorMarker.UseDynamicColor);

            public void Init()
            {
                ColorMarker?.Init();
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class MarkerOptions
        {
            [JsonProperty("Train map markers")]
            public TrainMarkerOptions Train = new();

            [JsonProperty("Train stop map markers")]
            public StopMarkerOptions Stop = new();

            [JsonProperty("Dynamic route colors")]
            public string[] RouteColors =
            {
                "#ff0000",
                "#ff9900",
                "#ffff00",
                "#00ff00",
                "#0099ff",
                "#cc00ff",
                "#ffffff",
                "#777777",
            };

            [JsonIgnore]
            public Color[] ValidDynamicColors;

            [JsonIgnore]
            public bool AnyColorsEnabled => Train is { ColorMarker.Enabled: true } || Stop is { ColorMarker.Enabled: true };

            [JsonIgnore]
            public bool AnyDynamicColors => Train is { ColorMarker.EnabledAndDynamic: true } || Stop is { ColorMarker.EnabledAndDynamic: true };

            [JsonIgnore]
            public bool AnyDynamicMarkers => AnyDynamicColors || Stop is { AnyDynamicMarkers: true };

            public void Init()
            {
                Train?.Init();
                Stop?.Init();

                var validColors = new List<Color>();

                foreach (var hexColor in RouteColors)
                {
                    if (ColorUtility.TryParseHtmlString(hexColor, out var color))
                    {
                        validColors.Add(color);
                    }
                    else
                    {
                        LogError($"Invalid HTML color code in config: {color}");
                    }
                }

                ValidDynamicColors = validColors.ToArray();
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("PlayHornForNearbyPlayersInRadius")]
            private float DeprecatedPlayHornForNearbyPlayersInRadius { set => PlayHornForNearbyPlayersInRadius = value; }

            [JsonProperty("Play horn for nearby players in radius")]
            public float PlayHornForNearbyPlayersInRadius = 0f;

            [JsonProperty("DefaultSpeed")]
            private string DeprecatedDefaultSpeed { set => DefaultSpeed = value; }

            [JsonProperty("Default speed")]
            public string DefaultSpeed = EngineSpeeds.Fwd_Hi.ToString();

            [JsonProperty("DefaultTrackSelection")]
            private string DeprecatedDefaultTrackSelection { set => DefaultTrackSelection = value; }

            [JsonProperty("Default track selection")]
            public string DefaultTrackSelection = TrackSelection.Left.ToString();

            [JsonProperty("BulldozeOffendingWorkcarts")]
            private bool DeprecatedBulldozeOffendingWorkcarts { set => BulldozeOffendingWorkcarts = value; }

            [JsonProperty("Bulldoze offending workcarts")]
            public bool BulldozeOffendingWorkcarts = false;

            [JsonProperty("DestroyBarricadesInstantly")]
            private bool DeprecatedDestroyBarricadesInstantly { set => DestroyBarricadesInstantly = value; }

            [JsonProperty("Destroy barricades instantly")]
            public bool DestroyBarricadesInstantly = false;

            [JsonProperty("EnableMapTriggers")]
            private bool DeprecatedEnableMapTriggers { set => EnableMapTriggers = value; }

            [JsonProperty("Enable map triggers")]
            public bool EnableMapTriggers = true;

            [JsonProperty("EnableTunnelTriggers")]
            private Dictionary<string, bool> DeprecatedEnableTunnelTriggers { set => EnableTunnelTriggers = value; }

            [JsonProperty("Enable tunnel triggers")]
            public Dictionary<string, bool> EnableTunnelTriggers = new()
            {
                [TunnelType.TrainStation.ToString()] = false,
                [TunnelType.BarricadeTunnel.ToString()] = false,
                [TunnelType.LootTunnel.ToString()] = false,
                [TunnelType.Intersection.ToString()] = false,
                [TunnelType.LargeIntersection.ToString()] = false,
                [TunnelType.VerticalIntersection.ToString()] = false,
            };

            [JsonProperty("MaxConductors")]
            private int DeprecatedMaxConductors { set => MaxConductors = value; }

            [JsonProperty("Max conductors")]
            public int MaxConductors = -1;

            [JsonProperty("SpawnTriggersRespectConductorLimit")]
            private bool DeprecatedSpawnTriggersRespectConductorLimit { set => SpawnTriggersRespectConductorLimit = value; }

            [JsonProperty("Spawn triggers respect conductor limit")]
            public bool SpawnTriggersRespectConductorLimit;

            [JsonProperty("DisableDefaultTunnelWorkcartSpawnPoints")]
            private bool DeprecatedDisableDefaultTunnelWorkcartSpawnPoints { set => DisableDefaultTunnelWorkcartSpawnPoints = value; }

            [JsonProperty("Disable default tunnel workcart spawn points")]
            public bool DisableDefaultTunnelWorkcartSpawnPoints;

            [JsonProperty("Trigger display distance")]
            public float TriggerDisplayDistance = 150;

            [JsonProperty("Debug show crate markers", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool DebugShowCrateMarkers;

            [JsonProperty("Debug show collisions markers", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool DebugShowCollisionsMarkers;

            [JsonProperty("Debug enable global broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool DebugEnableGlobalBroadcast;

            [JsonProperty("Debug dynamic routes", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool DebugDynamicRoutes;

            [JsonProperty("ConductorOutfit")]
            private ItemInfo[] DeprecatedConductorOutfit { set => ConductorOutfit = value; }

            [JsonProperty("Conductor outfit")]
            public ItemInfo[] ConductorOutfit =
            {
                new() { ShortName = "jumpsuit.suit" },
                new() { ShortName = "sunglasses03chrome" },
                new() { ShortName = "hat.boonie" },
            };

            [JsonProperty("ColoredMapMarker")]
            private ColorMarkerOptions DeprecatedColorMapMarker { set => MapMarkers.Train.ColorMarker = value; }

            [JsonProperty("VendingMapMarker")]
            private VendingMarkerOptions DeprecatedVendingMapMarker { set => MapMarkers.Train.VendingMarker = value; }

            [JsonProperty("MapMarkerUpdateInveralSeconds")]
            private float DeprecatedMapMarkerUpdateInteralSeconds { set => MapMarkers.Train.UpdateIntervalSeconds = value; }

            [JsonProperty("MapMarkerUpdateIntervalSeconds")]
            private float DeprecatedMapMarkerUpdateIntervalSeconds { set => MapMarkers.Train.UpdateIntervalSeconds = value; }

            [JsonProperty("Map markers")]
            public MarkerOptions MapMarkers = new();

            [JsonProperty("TriggerDisplayDistance")]
            private float DeprecatedTriggerDisplayDistance { set => TriggerDisplayDistance = value; }

            public void Init()
            {
                MapMarkers?.Init();

                if (ConductorOutfit != null)
                {
                    foreach (var itemInfo in ConductorOutfit)
                    {
                        itemInfo.Init();
                    }
                }
            }

            public bool IsTunnelTypeEnabled(TunnelType tunnelType)
            {
                return EnableTunnelTriggers.TryGetValue(tunnelType.ToString(), out var enabled) && enabled;
            }

            private EngineSpeeds? _defaultSpeed;
            public EngineSpeeds GetDefaultSpeed()
            {
                if (_defaultSpeed != null)
                    return (EngineSpeeds)_defaultSpeed;

                if (TryParseEngineSpeed(DefaultSpeed, out var engineSpeed))
                {
                    _defaultSpeed = engineSpeed;
                    return engineSpeed;
                }

                return EngineSpeeds.Fwd_Hi;
            }

            private TrackSelection? _defaultTrackSelection;
            public TrackSelection GetDefaultTrackSelection()
            {
                if (_defaultTrackSelection != null)
                    return (TrackSelection)_defaultTrackSelection;

                if (TryParseTrackSelection(DefaultTrackSelection, out var trackSelection))
                {
                    _defaultTrackSelection = trackSelection;
                    return trackSelection;
                }

                return TrackSelection.Left;
            }
        }

        private Configuration GetDefaultConfig() => new();

        #endregion

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #region Localization

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player.IPlayer, messageName), args));

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetTriggerOptions(IPlayer player)
        {
            var speedOptions = GetMessage(player, Lang.HelpSpeedOptions, GetEnumOptions<SpeedInstruction>());
            var directionOptions = GetMessage(player, Lang.HelpDirectionOptions, GetEnumOptions<DirectionInstruction>());
            var trackSelectionOptions = GetMessage(player, Lang.HelpTrackSelectionOptions, GetEnumOptions<TrackSelectionInstruction>());
            var trainCarOptions = GetMessage(player, Lang.HelpTrainCarOptions, FormatOptions(TrainCarPrefab.GetAliases()));
            var otherOptions = GetMessage(player, Lang.HelpOtherOptions);

            return $"{speedOptions}\n{directionOptions}\n{trackSelectionOptions}\n{trainCarOptions}\n{otherOptions}";
        }

        private string GetTriggerPrefix(IPlayer player, TrainTriggerType triggerType) =>
            GetMessage(player, triggerType == TrainTriggerType.Tunnel ? Lang.InfoTriggerTunnelPrefix : Lang.InfoTriggerMapPrefix);

        private string GetTriggerPrefix(IPlayer player, TriggerData triggerData) =>
            GetTriggerPrefix(player, triggerData.TriggerType);

        private string GetTriggerPrefix(BasePlayer player, TrainTriggerType triggerType) =>
            GetTriggerPrefix(player.IPlayer, triggerType);

        private string GetTriggerPrefix(BasePlayer player, TriggerData triggerData) =>
            GetTriggerPrefix(player.IPlayer, triggerData.TriggerType);

        private string GetConductorCountMessage(IPlayer player)
        {
            return _config.MaxConductors >= 0
                ? GetMessage(player, Lang.InfoConductorCountLimited, _trainManager.CountedConductors,
                    _config.MaxConductors)
                : GetMessage(player, Lang.InfoConductorCountUnlimited, _trainManager.CountedConductors);
        }

        private static class Lang
        {
            public const string ErrorNoPermission = "Error.NoPermission";
            public const string ErrorNoTriggers = "Error.NoTriggers";
            public const string ErrorTriggerNotFound = "Error.TriggerNotFound";
            public const string ErrorNoTrackFound = "Error.ErrorNoTrackFound";
            public const string ErrorNoWorkcartFound = "Error.NoWorkcartFound";
            public const string ErrorNoWorkcart = "Error.NoWorkcart";
            public const string ErrorAutomateBlocked = "Error.AutomateBlocked";
            public const string ErrorUnsupportedTunnel = "Error.UnsupportedTunnel";
            public const string ErrorTunnelTypeDisabled = "Error.TunnelTypeDisabled";
            public const string ErrorMapTriggersDisabled = "Error.MapTriggersDisabled";
            public const string ErrorMaxConductors = "Error.MaxConductors";
            public const string ErrorWorkcartOwned = "Error.WorkcartOwned";
            public const string ErrorNoAutomatedWorkcarts = "Error.NoAutomatedWorkcarts";
            public const string ErrorRequiresSpawnTrigger = "Error.RequiresSpawnTrigger";
            public const string ErrorTriggerDisabled = "Error.TriggerDisabled";
            public const string ErrorUnrecognizedTrainCar = "Error.UnrecognizedTrainCar";

            public const string ToggleOnSuccess = "Toggle.Success.On";
            public const string ToggleOnWithRouteSuccess = "Toggle.Success.On.WithRoute";
            public const string ToggleOffSuccess = "Toggle.Success.Off";
            public const string ResetAllSuccess = "ResetAll.Success";
            public const string ShowTriggersSuccess = "ShowTriggers.Success";
            public const string ShowTriggersWithRouteSuccess = "ShowTriggers.WithRoute.Success";

            public const string AddTriggerSyntax = "AddTrigger.Syntax";
            public const string AddTriggerSuccess = "AddTrigger.Success";
            public const string MoveTriggerSuccess = "MoveTrigger.Success";
            public const string RotateTriggerSuccess = "RotateTrigger.Success";
            public const string UpdateTriggerSyntax = "UpdateTrigger.Syntax";
            public const string UpdateTriggerSuccess = "UpdateTrigger.Success";
            public const string SimpleTriggerSyntax = "Trigger.SimpleSyntax";
            public const string RemoveTriggerSuccess = "RemoveTrigger.Success";

            public const string AddCommandSyntax = "AddCommand.Syntax";
            public const string RemoveCommandSyntax = "RemoveCommand.Syntax";
            public const string RemoveCommandErrorIndex = "RemoveCommand.Error.Index";

            public const string InfoConductorCountLimited = "Info.ConductorCount.Limited";
            public const string InfoConductorCountUnlimited = "Info.ConductorCount.Unlimited";

            public const string HelpSpeedOptions = "Help.SpeedOptions";
            public const string HelpDirectionOptions = "Help.DirectionOptions";
            public const string HelpTrackSelectionOptions = "Help.TrackSelectionOptions";
            public const string HelpTrainCarOptions = "Help.HelpTrainCarOptions";
            public const string HelpOtherOptions = "Help.OtherOptions3";

            public const string InfoTrigger = "Info.Trigger";
            public const string InfoTriggerMapPrefix = "Info.Trigger.Prefix.Map";
            public const string InfoTriggerTunnelPrefix = "Info.Trigger.Prefix.Tunnel";

            public const string InfoTriggerDisabled = "Info.Trigger.Disabled";
            public const string InfoTriggerMap = "Info.Trigger.Map";
            public const string InfoTriggerRoute = "Info.Trigger.Route";
            public const string InfoTriggerTunnel = "Info.Trigger.Tunnel";
            public const string InfoTriggerSpawner = "Info.Trigger.Spawner2";
            public const string InfoTriggerAddConductor = "Info.Trigger.Conductor";
            public const string InfoTriggerDestroy = "Info.Trigger.Destroy";
            public const string InfoTriggerStopDuration = "Info.Trigger.StopDuration";
            public const string InfoTriggerChance = "Info.Trigger.Chance";

            public const string InfoTriggerSpeed = "Info.Trigger.Speed";
            public const string InfoTriggerBrakeToSpeed = "Info.Trigger.BrakeToSpeed";
            public const string InfoTriggerDepartureSpeed = "Info.Trigger.DepartureSpeed";
            public const string InfoTriggerDirection = "Info.Trigger.Direction";
            public const string InfoTriggerDepartureDirection = "Info.Trigger.DepartureDirection";
            public const string InfoTriggerTrackSelection = "Info.Trigger.TrackSelection";
            public const string InfoTriggerCommands = "Info.Trigger.Command";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.ErrorNoTriggers] = "There are no workcart triggers on this map.",
                [Lang.ErrorTriggerNotFound] = "Error: Trigger id #<color=#fd4>{0}{1}</color> not found.",
                [Lang.ErrorNoTrackFound] = "Error: No track found nearby.",
                [Lang.ErrorNoWorkcartFound] = "Error: No workcart found.",
                [Lang.ErrorNoWorkcart] = "Error: That train has no workcarts.",
                [Lang.ErrorAutomateBlocked] = "Error: Another plugin blocked automating that workcart.",
                [Lang.ErrorUnsupportedTunnel] = "Error: Not a supported train tunnel.",
                [Lang.ErrorTunnelTypeDisabled] = "Error: Tunnel type <color=#fd4>{0}</color> is currently disabled.",
                [Lang.ErrorMapTriggersDisabled] = "Error: Map triggers are disabled.",
                [Lang.ErrorMaxConductors] = "Error: There are already <color=#fd4>{0}</color> out of <color=#fd4>{1}</color> conductors.",
                [Lang.ErrorWorkcartOwned] = "Error: That workcart has an owner.",
                [Lang.ErrorNoAutomatedWorkcarts] = "Error: There are no automated workcarts.",
                [Lang.ErrorRequiresSpawnTrigger] = "Error: That is not a spawn trigger.",
                [Lang.ErrorTriggerDisabled] = "Error: That trigger is disabled.",
                [Lang.ErrorUnrecognizedTrainCar] = "Error: Unrecognized train car: {0}.",

                [Lang.ToggleOnSuccess] = "That workcart is now automated.",
                [Lang.ToggleOnWithRouteSuccess] = "That workcart is now automated with route <color=#fd4>@{0}</color>.",
                [Lang.ToggleOffSuccess] = "That workcart is no longer automated.",
                [Lang.ResetAllSuccess] = "All {0} conductors have been removed.",
                [Lang.ShowTriggersSuccess] = "Showing all triggers for <color=#fd4>{0}</color>.",
                [Lang.ShowTriggersWithRouteSuccess] = "Showing all triggers for route <color=#fd4>@{0}</color> for <color=#fd4>{1}</color>",

                [Lang.AddTriggerSyntax] = "Syntax: <color=#fd4>{0} <option1> <option2> ...</color>\n{1}",
                [Lang.AddTriggerSuccess] = "Successfully added trigger #<color=#fd4>{0}{1}</color>.",
                [Lang.UpdateTriggerSyntax] = "Syntax: <color=#fd4>{0} <id> <option1> <option2> ...</color>\n{1}",
                [Lang.UpdateTriggerSuccess] = "Successfully updated trigger #<color=#fd4>{0}{1}</color>",
                [Lang.MoveTriggerSuccess] = "Successfully moved trigger #<color=#fd4>{0}{1}</color>",
                [Lang.RotateTriggerSuccess] = "Successfully rotated trigger #<color=#fd4>{0}{1}</color>",
                [Lang.SimpleTriggerSyntax] = "Syntax: <color=#fd4>{0} <id></color>",
                [Lang.RemoveTriggerSuccess] = "Trigger #<color=#fd4>{0}{1}</color> successfully removed.",

                [Lang.AddCommandSyntax] = "Syntax: <color=#fd4>{0} <id> <command></color>",
                [Lang.RemoveCommandSyntax] = "Syntax: <color=#fd4>{0} <id> <number></color>",
                [Lang.RemoveCommandErrorIndex] = "Error: Invalid command index <color=#fd4>{0}</color>.",

                [Lang.InfoConductorCountLimited] = "Total conductors: <color=#fd4>{0}/{1}</color>.",
                [Lang.InfoConductorCountUnlimited] = "Total conductors: <color=#fd4>{0}</color>.",

                [Lang.HelpSpeedOptions] = "Speeds: {0}",
                [Lang.HelpDirectionOptions] = "Directions: {0}",
                [Lang.HelpTrackSelectionOptions] = "Track selection: {0}",
                [Lang.HelpTrainCarOptions] = "Train car options: {0}",
                [Lang.HelpOtherOptions] = "Other options: <color=#fd4>Conductor</color> | <color=#fd4>Brake</color> | <color=#fd4>Destroy</color> | <color=#fd4>@ROUTE_NAME</color> | <color=#fd4>Enabled</color> | <color=#fd4>Disabled</color>",

                [Lang.InfoTrigger] = "Workcart Trigger #{0}{1}",
                [Lang.InfoTriggerMapPrefix] = "M",
                [Lang.InfoTriggerTunnelPrefix] = "T",

                [Lang.InfoTriggerDisabled] = "DISABLED",
                [Lang.InfoTriggerMap] = "Map-specific",
                [Lang.InfoTriggerRoute] = "Route: @{0}",
                [Lang.InfoTriggerTunnel] = "Tunnel type: {0} (x{1})",
                [Lang.InfoTriggerSpawner] = "Spawns: {0}",
                [Lang.InfoTriggerAddConductor] = "Adds Conductor",
                [Lang.InfoTriggerDestroy] = "Destroys workcart",
                [Lang.InfoTriggerStopDuration] = "Stop duration: {0}s",
                [Lang.InfoTriggerChance] = "Chance: {0}%",

                [Lang.InfoTriggerSpeed] = "Speed: {0}",
                [Lang.InfoTriggerBrakeToSpeed] = "Brake to speed: {0}",
                [Lang.InfoTriggerDepartureSpeed] = "Departure speed: {0}",
                [Lang.InfoTriggerDirection] = "Direction: {0}",
                [Lang.InfoTriggerDepartureDirection] = "Departure direction: {0}",
                [Lang.InfoTriggerTrackSelection] = "Track selection: {0}",
                [Lang.InfoTriggerCommands] = "Commands: {0}",
            }, this, "en");

            // Brazilian Portuguese
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "VocÃª nÃ£o tem permissÃ£o para fazer isso.",
                [Lang.ErrorNoTriggers] = "NÃ£o hÃ¡ gatilhos de carrinho de trabalho neste mapa.",
                [Lang.ErrorTriggerNotFound] = "Erro: Trigger id #<color=#fd4>{0}{1}</color> nÃ£o encontrado.",
                [Lang.ErrorNoTrackFound] = "Erro: nenhuma trilha encontrada nas proximidades.",
                [Lang.ErrorNoWorkcartFound] = "Erro: Nenhum carrinho de trabalho encontrado.",
                [Lang.ErrorNoWorkcart] = "Erro: esse trem nÃ£o tem carrinhos de trabalho",
                [Lang.ErrorAutomateBlocked] = "Erro: outro plug-in bloqueado automatizando esse carrinho de trabalho.",
                [Lang.ErrorUnsupportedTunnel] = "Erro: nÃ£o Ã© um tÃºnel ferroviÃ¡rio compatÃ­vel.",
                [Lang.ErrorTunnelTypeDisabled] = "Erro: o tipo de tÃºnel <color=#fd4>{0}</color> estÃ¡ atualmente desativado.",
                [Lang.ErrorMapTriggersDisabled] = "Erro: os gatilhos do mapa estÃ£o desativados.",
                [Lang.ErrorMaxConductors] = "Erro: jÃ¡ existem <color=#fd4>{0}</color> de <color=#fd4>{1}</color>condutores.",
                [Lang.ErrorWorkcartOwned] = "Erro: esse carrinho de trabalho tem um proprietÃ¡rio.",
                [Lang.ErrorNoAutomatedWorkcarts] = "Erro: nÃ£o hÃ¡ carrinhos de trabalho automatizados.",
                [Lang.ErrorRequiresSpawnTrigger] = "Erro: Isso nÃ£o Ã© um gatilho de desova.",
                [Lang.ErrorTriggerDisabled] = "Erro: esse gatilho estÃ¡ desativado.",
                [Lang.ErrorUnrecognizedTrainCar] = "Erro: VagÃ£o de trem nÃ£o reconhecido: {0}.",

                [Lang.ToggleOnSuccess] = "Esse carrinho de trabalho agora Ã© automatizado.",
                [Lang.ToggleOnWithRouteSuccess] = "Esse carrinho de trabalho agora Ã© automatizado com rota <color=#fd4>@{0}</color>.",
                [Lang.ToggleOffSuccess] = "Esse carrinho de trabalho nÃ£o Ã© mais automatizado.",
                [Lang.ResetAllSuccess] = "Todos os {0} condutores foram removidos.",
                [Lang.ShowTriggersSuccess] = "Mostrando todos os gatilhos para <color=#fd4>{0}</color>.",
                [Lang.ShowTriggersWithRouteSuccess] = "Mostrando todos os gatilhos para a rota <color=#fd4>@{0}</color> para <color=#fd4>{1}</color>",

                [Lang.AddTriggerSyntax] = "Syntax: <color=#fd4>{0} <option1> <option2> ...</color>\n{1}",
                [Lang.AddTriggerSuccess] = "Gatilho adicionado com sucesso #<color=#fd4>{0}{1}</color>.",
                [Lang.UpdateTriggerSyntax] = "Syntax: <color=#fd4>{0} <id> <option1> <option2> ...</color>\n{1}",
                [Lang.UpdateTriggerSuccess] = "Gatilho atualizado com sucesso #<color=#fd4>{0}{1}</color>",
                [Lang.MoveTriggerSuccess] = "Gatilho movido com sucesso #<color=#fd4>{0}{1}</color>",
                [Lang.RotateTriggerSuccess] = "Gatilho girado com sucesso #<color=#fd4>{0}{1}</color>",
                [Lang.SimpleTriggerSyntax] = "Syntax: <color=#fd4>{0} <id></color>",
                [Lang.RemoveTriggerSuccess] = "Trigger #<color=#fd4>{0}{1}</color> removido com sucesso.",

                [Lang.AddCommandSyntax] = "Syntax: <color=#fd4>{0} <id> <comando></color>",
                [Lang.RemoveCommandSyntax] = "Syntax: <color=#fd4>{0} <id> <nÃºmero></color>",
                [Lang.RemoveCommandErrorIndex] = "Erro: Ã­ndice de comando invÃ¡lido <color=#fd4>{0}</color>.",

                [Lang.InfoConductorCountLimited] = "Condutores totais: <color=#fd4>{0}/{1}</color>.",
                [Lang.InfoConductorCountUnlimited] = "Condutores totais: <color=#fd4>{0}</color>.",

                [Lang.HelpSpeedOptions] = "Velocidades: {0}",
                [Lang.HelpDirectionOptions] = "DireÃ§Ãµes: {0}",
                [Lang.HelpTrackSelectionOptions] = "SeleÃ§Ã£o de faixa: {0}",
                [Lang.HelpTrainCarOptions] = "OpÃ§Ãµes de vagÃµes: {0}",
                [Lang.HelpOtherOptions] = "Outras opÃ§Ãµes: <color=#fd4>Conductor</color> | <color=#fd4>Brake</color> | <color=#fd4>Destroy</color> | <color=#fd4>@ROUTE_NAME</color> | <color=#fd4>Enabled</color> | <color=#fd4>Disabled</color>",

                [Lang.InfoTrigger] = "Acionador de carrinho de trabalho #{0}{1}",
                [Lang.InfoTriggerMapPrefix] = "M",
                [Lang.InfoTriggerTunnelPrefix] = "T",

                [Lang.InfoTriggerDisabled] = "DESATIVADO",
                [Lang.InfoTriggerMap] = "EspecÃ­fico do mapa",
                [Lang.InfoTriggerRoute] = "Rota: @{0}",
                [Lang.InfoTriggerTunnel] = "Tipo de tÃºnel: {0} (x{1})",
                [Lang.InfoTriggerSpawner] = "Gera {0}",
                [Lang.InfoTriggerAddConductor] = "Adiciona Condutor",
                [Lang.InfoTriggerDestroy] = "DestrÃ³i o carrinho de trabalho",
                [Lang.InfoTriggerStopDuration] = "DuraÃ§Ã£o da parada: {0}s",
                [Lang.InfoTriggerChance] = "Chance: {0}%",

                [Lang.InfoTriggerSpeed] = "Velocidade: {0}",
                [Lang.InfoTriggerBrakeToSpeed] = "Freie para aumentar a velocidade: {0}",
                [Lang.InfoTriggerDepartureSpeed] = "Velocidade de partida: {0}",
                [Lang.InfoTriggerDirection] = "DireÃ§Ã£o: {0}",
                [Lang.InfoTriggerDepartureDirection] = "DireÃ§Ã£o de partida: {0}",
                [Lang.InfoTriggerTrackSelection] = "SeleÃ§Ã£o de faixa: {0}",
                [Lang.InfoTriggerCommands] = "Eventos: {0}",
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: AutomatedWorkcarts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/automated-events ---
// --- Original File Path: A/AutomatedEvents/AutomatedEvents.cs ---

ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Automated Events", "k1lly0u/mspeedie/Arainrr", "1.0.12")]
    internal class AutomatedEvents : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin GUIAnnouncements;

        private const string PERMISSION_USE = "automatedevents.allowed";
        private const string PERMISSION_NEXT = "automatedevents.next";

        private const string PREFAB_APC = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";
        private const string PREFAB_PLANE = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string PREFAB_CHINOOK = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        private const string PREFAB_HELI = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
        private const string PREFAB_SHIP = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string PREFAB_SLEIGH = "assets/prefabs/misc/xmas/sleigh/santasleigh.prefab";
        private const string PREFAB_EASTER = "assets/prefabs/misc/easter/egghunt.prefab";
        private const string PREFAB_HALLOWEEN = "assets/prefabs/misc/halloween/halloweenhunt.prefab";
        private const string PREFAB_CHRISTMAS = "assets/prefabs/misc/xmas/xmasrefill.prefab";

        private static AutomatedEvents instance;
        private Dictionary<BaseEntity, EventType> _eventEntities;
        private readonly Dictionary<EventType, Timer> _eventTimers = new Dictionary<EventType, Timer>();
        private readonly Dictionary<EventSchedule, EventType> _disabledVanillaEvents = new Dictionary<EventSchedule, EventType>();

        private readonly Dictionary<string, EventType> _eventSchedulePrefabShortNames = new Dictionary<string, EventType>
        {
            ["event_airdrop"] = EventType.CargoPlane,
            ["event_cargoship"] = EventType.CargoShip,
            ["event_cargoheli"] = EventType.Chinook,
            ["event_helicopter"] = EventType.Helicopter,
            ["event_xmas"] = EventType.Christmas,
            ["event_easter"] = EventType.Easter,
            ["event_halloween"] = EventType.Halloween,
        };

        private enum EventType
        {
            None,
            Bradley,
            CargoPlane,
            CargoShip,
            Chinook,
            Helicopter,
            SantaSleigh,
            Christmas,
            Easter,
            Halloween
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            instance = this;
            permission.RegisterPermission(PERMISSION_USE, this);
            permission.RegisterPermission(PERMISSION_NEXT, this);

            AddCovalenceCommand(configData.Chat.NextEventCommand, nameof(CmdNextEvent));
            AddCovalenceCommand(configData.Chat.RunEventCommand, nameof(CmdRunEvent));
            AddCovalenceCommand(configData.Chat.KillEventCommand, nameof(CmdKillEvent));

            var eventTypes = new List<EventType>(Enum.GetValues(typeof(EventType)).Cast<EventType>());
            if (!eventTypes.Any(x =>
            {
                if (x == EventType.None) return false;
                var baseEvent = GetBaseEvent(x);
                return baseEvent.Enabled && baseEvent.RestartTimerOnKill;
            }))
            {
                Unsubscribe(nameof(OnEntityKill));
            }
            else
            {
                _eventEntities = new Dictionary<BaseEntity, EventType>();
            }
        }

        private void OnServerInitialized(bool initial)
        {
            if (initial)
            {
                timer.Once(30f, InitializeEvents);
            }
            else
            {
                InitializeEvents();
            }
        }

        private void InitializeEvents()
        {
            ClearExistingEvents();
            foreach (EventType eventType in Enum.GetValues(typeof(EventType)))
            {
                if (eventType == EventType.None) continue;
                var baseEvent = GetBaseEvent(eventType);
                switch (eventType)
                {
                    case EventType.Bradley:
                        {
                            var bradleySpawner = BradleySpawner.singleton;
                            if (bradleySpawner != null)
                            {
                                if (baseEvent.DisableVanillaEvent)
                                {
                                    ConVar.Bradley.enabled = false;
                                    bradleySpawner.enabled = false;
                                    bradleySpawner.CancelInvoke(nameof(bradleySpawner.DelayedStart));
                                    bradleySpawner.CancelInvoke(nameof(bradleySpawner.CheckIfRespawnNeeded));
                                    PrintDebug($"The vanilla {eventType} event is disabled");
                                }
                            }
                            else if (baseEvent.Enabled)
                            {
                                PrintError("There is no Bradley Spawner on your server, so the Bradley event is disabled");
                                continue;
                            }
                        }
                        break;
                }
                if (baseEvent.Enabled)
                {
                    _eventTimers[eventType] = timer.Once(5f, () => StartEventTimer(eventType, configData.Global.AnnounceOnLoaded));
                }
            }
        }

        private void Unload()
        {
            foreach (EventType eventType in Enum.GetValues(typeof(EventType)))
            {
                switch (eventType)
                {
                    case EventType.Bradley:
                        {
                            var baseEvent = GetBaseEvent(eventType);
                            var bradleySpawner = BradleySpawner.singleton;
                            if (bradleySpawner != null && baseEvent.DisableVanillaEvent)
                            {
                                ConVar.Bradley.enabled = true;
                                bradleySpawner.enabled = true;
                                bradleySpawner.InvokeRepeating(nameof(bradleySpawner.CheckIfRespawnNeeded), 0f, 5f);
                                PrintDebug($"The vanilla {eventType} event is enabled");
                            }
                        }
                        continue;
                }
            }

            foreach (var entry in _disabledVanillaEvents)
            {
                entry.Key.enabled = true;
                PrintDebug($"The vanilla {entry.Value} event is enabled");
            }
            foreach (var value in _eventTimers.Values)
            {
                value?.Destroy();
            }
            instance = null;
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity == null) return;
            EventType eventType;
            if (!_eventEntities.TryGetValue(entity, out eventType)) return;
            StartEventTimer(eventType, onKill: true);
        }

        private object OnEventTrigger(TriggeredEventPrefab eventPrefab)
        {
            if (eventPrefab == null) return null;
            var prefabShortName = GetPrefabShortName(eventPrefab.name);
            if (string.IsNullOrEmpty(prefabShortName))
            {
                PrintError($"Failed to get prefab short name ({eventPrefab.name}). Please notify the plugin developer");
                return null;
            }
            EventType eventType;
            if (_eventSchedulePrefabShortNames.TryGetValue(prefabShortName, out eventType))
            {
                var baseEvent = GetBaseEvent(eventType);
                if (baseEvent.DisableVanillaEvent)
                {
                    var eventSchedule = eventPrefab.GetComponent<EventSchedule>();
                    if (eventSchedule == null)
                    {
                        PrintError($"{eventPrefab.name} has no EventSchedule component. Please notify the plugin developer");
                        return null;
                    }
                    eventSchedule.enabled = false;
                    _disabledVanillaEvents.Add(eventSchedule, eventType);
                    PrintDebug($"The vanilla {eventType} event is disabled", true);
                    return false;
                }
                if (!baseEvent.Enabled) return null;
                switch (eventType)
                {
                    case EventType.CargoPlane:
                        if (!CanRunEvent<CargoPlane>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.CargoShip:
                        if (!CanRunEvent<CargoShip>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.Chinook:
                        if (!CanRunEvent<CH47HelicopterAIController>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.Helicopter:
                        if (!CanRunEvent<PatrolHelicopter>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.Christmas:
                        if (!CanRunEvent<XMasRefill>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.Easter:
                        if (!CanRunHuntEvent<EggHuntEvent>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    case EventType.Halloween:
                        if (!CanRunHuntEvent<HalloweenHunt>(eventType, baseEvent))
                        {
                            return false;
                        }
                        break;

                    default:
                        PrintError($"The vanilla {eventType} event was triggered, but not handled. Please notify the plugin developer");
                        return null;
                }
                if (configData.Global.AnnounceEventTriggered)
                {
                    SendEventTriggeredMessage(eventType.ToString());
                }
                return null;
            }
            PrintError($"Unknown Vanilla Event Schedule: {eventPrefab.name} ({prefabShortName})");
            return null;
        }

        #endregion Oxide Hooks

        #region Methods

        private void ClearExistingEvents()
        {
            var eventTypes = new Dictionary<EventType, bool>();
            foreach (EventType eventType in Enum.GetValues(typeof(EventType)))
            {
                if (eventType == EventType.None) continue;
                var baseEvent = GetBaseEvent(eventType);
                if (baseEvent.Enabled && baseEvent.KillEventOnLoaded)
                {
                    var excludePlayerEntity = (baseEvent as CoexistEvent)?.ExcludePlayerEntity ?? false;
                    eventTypes.Add(eventType, excludePlayerEntity);
                }
            }

            if (eventTypes.Count <= 0) return;
            foreach (var baseEntity in BaseNetworkable.serverEntities.OfType<BaseEntity>().ToArray())
            {
                var eventType = GetEventTypeFromEntity(baseEntity);
                if (eventType == EventType.None) continue;
                bool excludePlayerEntity;
                if (eventTypes.TryGetValue(eventType, out excludePlayerEntity))
                {
                    if (excludePlayerEntity && baseEntity.OwnerID.IsSteamId()) continue;
                    PrintDebug($"Killing a {eventType}");
                    baseEntity.Kill();
                }
            }
        }

        private void StartEventTimer(EventType eventType, bool announce = true, float timeOverride = 0f, bool onKill = false)
        {
            if (eventType == EventType.None) return;
            var baseEvent = GetBaseEvent(eventType);
            if (!baseEvent.Enabled)
            {
                PrintDebug($"Unable to running {eventType} event, because the event is disabled");
                return;
            }
            var randomTime = timeOverride <= 0f
                ? baseEvent.MinimumTimeBetween <= baseEvent.MaximumTimeBetween
                    ? UnityEngine.Random.Range(baseEvent.MinimumTimeBetween, baseEvent.MaximumTimeBetween)
                    : UnityEngine.Random.Range(baseEvent.MaximumTimeBetween, baseEvent.MinimumTimeBetween)
                : timeOverride;
            randomTime += baseEvent.StartOffset;
            var nextDateTime = DateTime.UtcNow.AddMinutes(randomTime);
            baseEvent.NextRunTime = Facepunch.Math.Epoch.FromDateTime(nextDateTime);

            Timer value;
            if (_eventTimers.TryGetValue(eventType, out value))
            {
                value?.Destroy();
            }
            _eventTimers[eventType] = timer.Once(randomTime * 60f, () => RunEvent(eventType));

            if (onKill || !baseEvent.RestartTimerOnKill)
            {
                var timeLeft = TimeSpan.FromSeconds(baseEvent.NextRunTime - Facepunch.Math.Epoch.Current).ToShortString();
                PrintDebug($"Next {eventType} event will be ran after {timeLeft}");
                if (announce && baseEvent.AnnounceNext)
                {
                    SendEventNextRunMessage(eventType, timeLeft);
                }
            }
        }

        private void RunEvent(EventType eventType, bool runOnce = false, bool bypass = false)
        {
            if (eventType == EventType.None) return;
            BaseEntity eventEntity = null;
            string eventTypeStr = null;
            var baseEvent = GetBaseEvent(eventType);
            switch (eventType)
            {
                case EventType.Bradley:
                    {
                        if (bypass || CanRunEvent<BradleyAPC>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                var bradleySpawner = BradleySpawner.singleton;
                                if (bradleySpawner == null || bradleySpawner.path?.interestZones == null)
                                {
                                    PrintError("There is no Bradley Spawner on your server, so you cannot spawn a Bradley");
                                    return;
                                }
                                PrintDebug("Spawning Bradley");
                                var bradley = GameManager.server.CreateEntity(PREFAB_APC) as BradleyAPC;
                                if (bradley == null)
                                {
                                    goto NotifyDeveloper;
                                }
                                bradley.Spawn();
                                eventEntity = bradley;
                                eventTypeStr = eventType.ToString();

                                var position = bradleySpawner.path.interestZones[UnityEngine.Random.Range(0, bradleySpawner.path.interestZones.Count)].transform.position;
                                bradley.transform.position = position;
                                bradley.DoAI = true;
                                bradley.InstallPatrolPath(bradleySpawner.path);
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.CargoPlane:
                    {
                        if (bypass || CanRunEvent<CargoPlane>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Spawning Cargo Plane");
                                var plane = GameManager.server.CreateEntity(PREFAB_PLANE) as CargoPlane;
                                if (plane == null)
                                {
                                    goto NotifyDeveloper;
                                }
                                plane.Spawn();
                                eventEntity = plane;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.CargoShip:
                    {
                        if (bypass || CanRunEvent<CargoShip>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Spawning Cargo Ship");
                                var ship = GameManager.server.CreateEntity(PREFAB_SHIP) as CargoShip;
                                if (ship == null)
                                {
                                    goto NotifyDeveloper;
                                }
                                ship.TriggeredEventSpawn();
                                ship.Spawn();
                                eventEntity = ship;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.Chinook:
                    {
                        if (bypass || CanRunEvent<CH47HelicopterAIController>(eventType, baseEvent, false, entity => entity.landingTarget == Vector3.zero))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Spawning Chinook");
                                var chinook = GameManager.server.CreateEntity(PREFAB_CHINOOK) as CH47HelicopterAIController;
                                if (chinook == null)
                                {
                                    goto NotifyDeveloper;
                                }

                                chinook.TriggeredEventSpawn();
                                chinook.Spawn();
                                eventEntity = chinook;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.Helicopter:
                    {
                        if (bypass || CanRunEvent<PatrolHelicopter>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Spawning Helicopter");
                                var helicopter = GameManager.server.CreateEntity(PREFAB_HELI) as PatrolHelicopter;
                                if (helicopter == null)
                                {
                                    goto NotifyDeveloper;
                                }
                                helicopter.Spawn();
                                eventEntity = helicopter;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.SantaSleigh:
                    {
                        if (bypass || CanRunEvent<SantaSleigh>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Santa Sleigh is coming, have you been good?");
                                var santaSleigh = GameManager.server.CreateEntity(PREFAB_SLEIGH) as SantaSleigh;
                                if (santaSleigh == null)
                                {
                                    goto NotifyDeveloper;
                                }

                                santaSleigh.Spawn();
                                eventEntity = santaSleigh;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.Christmas:
                    {
                        if (bypass || CanRunEvent<XMasRefill>(eventType, baseEvent, false))
                        {
                            var eventWeight = baseEvent.GetRandomEventWeight();
                            if (eventWeight == null || eventWeight.IsNormalEvent)
                            {
                                PrintDebug("Christmas Refill is occurring");
                                var xMasRefill = GameManager.server.CreateEntity(PREFAB_CHRISTMAS) as XMasRefill;
                                if (xMasRefill == null)
                                {
                                    goto NotifyDeveloper;
                                }

                                bool temp = ConVar.XMas.enabled;
                                ConVar.XMas.enabled = true;
                                xMasRefill.Spawn();
                                ConVar.XMas.enabled = temp;
                                eventEntity = xMasRefill;
                                eventTypeStr = eventType.ToString();
                            }
                            else
                            {
                                PrintDebug($"Spawning {eventWeight.Name}");
                                eventWeight.RunCustomEvent();
                                eventTypeStr = eventWeight.Name;
                            }
                        }
                    }
                    break;

                case EventType.Easter:
                    {
                        if (bypass || CanRunHuntEvent<EggHuntEvent>(eventType, baseEvent, false))
                        {
                            if (EggHuntEvent.serverEvent != null) //EggHuntEvent.serverEvent.IsEventActive()
                            {
                                var timeLeft = EggHuntEvent.durationSeconds - EggHuntEvent.serverEvent.timeAlive + EggHuntEvent.serverEvent.warmupTime + 60f;
                                PrintDebug($"There is an {(EggHuntEvent.serverEvent.ShortPrefabName == "egghunt" ? eventType : EventType.Halloween)} event running, so the {eventType} event will be delayed until {Mathf.RoundToInt(timeLeft)} seconds later", true);
                                if (!runOnce)
                                {
                                    StartEventTimer(eventType, timeOverride: timeLeft / 60f);
                                }

                                return;
                            }

                            PrintDebug("Happy Easter Egg Hunt is occurring");
                            var eggHuntEvent = GameManager.server.CreateEntity(PREFAB_EASTER) as EggHuntEvent;
                            if (eggHuntEvent == null)
                            {
                                goto NotifyDeveloper;
                            }

                            eggHuntEvent.Spawn();
                            eventEntity = eggHuntEvent;
                            eventTypeStr = eventType.ToString();
                        }
                    }
                    break;

                case EventType.Halloween:
                    {
                        if (bypass || CanRunHuntEvent<HalloweenHunt>(eventType, baseEvent, false))
                        {
                            if (EggHuntEvent.serverEvent != null) //EggHuntEvent.serverEvent.IsEventActive()
                            {
                                var timeLeft = EggHuntEvent.durationSeconds - EggHuntEvent.serverEvent.timeAlive + EggHuntEvent.serverEvent.warmupTime + 60f;
                                PrintDebug($"There is an {(EggHuntEvent.serverEvent.ShortPrefabName == "egghunt" ? EventType.Easter : eventType)} event running, so the {eventType} event will be delayed until {Mathf.RoundToInt(timeLeft)} seconds later", true);
                                if (!runOnce)
                                {
                                    StartEventTimer(eventType, timeOverride: timeLeft / 60f);
                                }

                                return;
                            }

                            PrintDebug("Spooky Halloween Hunt is occurring");
                            var halloweenHunt = GameManager.server.CreateEntity(PREFAB_HALLOWEEN) as HalloweenHunt;
                            if (halloweenHunt == null)
                            {
                                goto NotifyDeveloper;
                            }

                            halloweenHunt.Spawn();
                            eventEntity = halloweenHunt;
                            eventTypeStr = eventType.ToString();
                        }
                    }
                    break;

                default:
                    PrintError($"RunEvent: Unknown EventType: {eventType}");
                    return;
            }

            if (eventEntity != null && baseEvent.Enabled && baseEvent.RestartTimerOnKill)
            {
                foreach (var entry in _eventEntities.ToArray())
                {
                    if (entry.Value == eventType)
                    {
                        _eventEntities.Remove(entry.Key);
                    }
                }
                _eventEntities.Add(eventEntity, eventType);
            }
            if (!string.IsNullOrEmpty(eventTypeStr))
            {
                if (configData.Global.AnnounceEventTriggered)
                {
                    SendEventTriggeredMessage(eventTypeStr);
                }
                Interface.CallHook("OnAutoEventTriggered", eventTypeStr, eventEntity, runOnce);
            }
            if (!runOnce)
            {
                StartEventTimer(eventType);
            }
            return;
        NotifyDeveloper:
            {
                PrintError($"{eventType} prefab does not exist. Please notify the plugin developer");
            }
        }

        private void KillEvent(EventType eventType)
        {
            var baseEvent = GetBaseEvent(eventType);
            switch (eventType)
            {
                case EventType.Bradley:
                    foreach (var bradley in GetEventEntities<BradleyAPC>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Bradley");
                        bradley.Kill();
                    }
                    return;

                case EventType.CargoPlane:
                    foreach (var cargoPlane in GetEventEntities<CargoPlane>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Cargo Plane");
                        cargoPlane.Kill();
                    }
                    return;

                case EventType.CargoShip:
                    foreach (var cargoShip in GetEventEntities<CargoShip>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Cargo Ship");
                        cargoShip.Kill();
                    }
                    return;

                case EventType.Chinook:
                    foreach (var ch47Helicopter in GetEventEntities<CH47HelicopterAIController>(baseEvent, entity => entity.landingTarget == Vector3.zero).ToArray())
                    {
                        PrintDebug("Killing a Chinook (CH47)");
                        ch47Helicopter.Kill();
                    }
                    return;

                case EventType.Helicopter:
                    foreach (var helicopter in GetEventEntities<PatrolHelicopter>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Helicopter");
                        helicopter.Kill();
                    }
                    return;

                case EventType.SantaSleigh:
                    foreach (var santaSleigh in GetEventEntities<SantaSleigh>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Santa Sleigh");
                        santaSleigh.Kill();
                    }
                    return;

                case EventType.Christmas:
                    foreach (var christmas in GetEventEntities<XMasRefill>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Christmas");
                        christmas.Kill();
                    }
                    return;

                case EventType.Easter:
                    foreach (var easter in GetEventEntities<EggHuntEvent>(baseEvent, entity => entity.ShortPrefabName == "egghunt").ToArray())
                    {
                        PrintDebug("Killing a Easter");
                        easter.Kill();
                    }
                    return;

                case EventType.Halloween:
                    foreach (var halloween in GetEventEntities<HalloweenHunt>(baseEvent).ToArray())
                    {
                        PrintDebug("Killing a Halloween");
                        halloween.Kill();
                    }
                    return;

                default:
                    PrintError($"KillEvent: Unknown EventType: {eventType}");
                    return;
            }
        }

        private bool GetNextEventRunTime(IPlayer iPlayer, EventType eventType, out string nextTime)
        {
            var baseEvent = GetBaseEvent(eventType);
            if (!baseEvent.Enabled || baseEvent.NextRunTime <= 0)
            {
                nextTime = Lang("NotSet", iPlayer.Id, baseEvent.DisplayName);
                return false;
            }
            var timeLeft = TimeSpan.FromSeconds(baseEvent.NextRunTime - Facepunch.Math.Epoch.Current).ToShortString();
            nextTime = Lang("NextRunTime", iPlayer.Id, baseEvent.DisplayName, timeLeft);
            return true;
        }

        private BaseEvent GetBaseEvent(EventType eventType)
        {
            switch (eventType)
            {
                case EventType.Bradley: return configData.Events.Bradley;
                case EventType.CargoPlane: return configData.Events.Plane;
                case EventType.CargoShip: return configData.Events.Ship;
                case EventType.Chinook: return configData.Events.Chinook;
                case EventType.Helicopter: return configData.Events.Helicopter;
                case EventType.SantaSleigh: return configData.Events.SantaSleigh;
                case EventType.Christmas: return configData.Events.Christmas;
                case EventType.Easter: return configData.Events.Easter;
                case EventType.Halloween: return configData.Events.Halloween;
                default: PrintError($"GetBaseEventS: Unknown EventType: {eventType}"); return null;
            }
        }

        private string GetEventTypeDisplayName(EventType eventType)
        {
            if (eventType == EventType.None) return "None";
            var baseEvent = GetBaseEvent(eventType);
            return baseEvent.DisplayName;
        }

        private void SendEventNextRunMessage(EventType eventType, string timeLeft)
        {
            if (configData.Global.UseGuiAnnouncements && GUIAnnouncements != null)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    GUIAnnouncements.Call("CreateAnnouncement", Lang("NextRunTime", player.UserIDString, GetEventTypeDisplayName(eventType), timeLeft), "Purple", "White", player);
                }
            }
            else
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    Print(player, Lang("NextRunTime", player.UserIDString, GetEventTypeDisplayName(eventType), timeLeft));
                }
            }
        }

        private void SendEventTriggeredMessage(string eventTypeStr)
        {
            if (configData.Global.UseGuiAnnouncements && GUIAnnouncements != null)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var message = Lang(eventTypeStr, player.UserIDString);
                    if (!string.IsNullOrWhiteSpace(message))
                    {
                        GUIAnnouncements.Call("CreateAnnouncement", message, "Purple", "White", player);
                    }
                }
            }
            else
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var message = Lang(eventTypeStr, player.UserIDString);
                    if (!string.IsNullOrWhiteSpace(message))
                    {
                        Print(player, message);
                    }
                }
            }
        }

        #endregion Methods

        #region Commands

        private void CmdNextEvent(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.IsAdmin && !iPlayer.HasPermission(PERMISSION_NEXT))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (args == null || args.Length < 1)
            {
                Print(iPlayer, Lang("BlankEvent", iPlayer.Id));
                return;
            }

            var argString = args[0].ToLower();
            switch (argString)
            {
                case "*":
                case "all":
                    {
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.AppendLine();
                        foreach (EventType eventType in Enum.GetValues(typeof(EventType)))
                        {
                            if (eventType == EventType.None) continue;
                            string result;
                            if (GetNextEventRunTime(iPlayer, eventType, out result))
                            {
                                stringBuilder.AppendLine(result);
                            }
                        }
                        Print(iPlayer, stringBuilder.ToString());
                    }
                    return;

                default:
                    {
                        var eventType = GetEventTypeFromStr(argString);
                        if (eventType == EventType.None)
                        {
                            Print(iPlayer, Lang("UnknownEvent", iPlayer.Id, args[0]));
                            return;
                        }
                        string result;
                        GetNextEventRunTime(iPlayer, eventType, out result);
                        Print(iPlayer, result);
                    }
                    return;
            }
        }

        private void CmdRunEvent(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.IsAdmin && !iPlayer.HasPermission(PERMISSION_USE))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (args == null || args.Length < 1)
            {
                Print(iPlayer, Lang("BlankEvent", iPlayer.Id));
                return;
            }

            var eventType = GetEventTypeFromStr(args[0].ToLower());
            if (eventType == EventType.None)
            {
                Print(iPlayer, Lang("UnknownEvent", iPlayer.Id, args[0]));
                return;
            }
            RunEvent(eventType, true, true);
            Print(iPlayer, Lang("Running", iPlayer.Id, iPlayer.Name, GetEventTypeDisplayName(eventType)));
        }

        private void CmdKillEvent(IPlayer iPlayer, string command, string[] args)
        {
            if (!iPlayer.IsAdmin && !iPlayer.HasPermission(PERMISSION_USE))
            {
                Print(iPlayer, Lang("NotAllowed", iPlayer.Id, command));
                return;
            }
            if (args == null || args.Length < 1)
            {
                Print(iPlayer, Lang("BlankEvent", iPlayer.Id));
                return;
            }

            var eventType = GetEventTypeFromStr(args[0].ToLower());
            if (eventType == EventType.None)
            {
                Print(iPlayer, Lang("UnknownEvent", iPlayer.Id, args[0]));
                return;
            }
            KillEvent(eventType);
            Print(iPlayer, Lang("Removing", iPlayer.Id, iPlayer.Name, GetEventTypeDisplayName(eventType)));
        }

        #endregion Commands

        #region Helpers

        private static string GetPrefabShortName(string prefabName) => Utility.GetFileNameWithoutExtension(prefabName);

        private static EventType GetEventTypeFromStr(string eventTypeStr)
        {
            if (eventTypeStr.Contains("brad"))
                return EventType.Bradley;
            if (eventTypeStr.Contains("heli") || eventTypeStr.Contains("copter"))
                return EventType.Helicopter;
            if (eventTypeStr.Contains("plane"))
                return EventType.CargoPlane;
            if (eventTypeStr.Contains("ship"))
                return EventType.CargoShip;
            if (eventTypeStr.Contains("ch47") || eventTypeStr.Contains("chin"))
                return EventType.Chinook;
            if (eventTypeStr.Contains("xmas") || eventTypeStr.Contains("chris") || eventTypeStr.Contains("yule"))
                return EventType.Christmas;
            if (eventTypeStr.Contains("santa") || eventTypeStr.Contains("nick") || eventTypeStr.Contains("wodan"))
                return EventType.SantaSleigh;
            if (eventTypeStr.Contains("easter") || eventTypeStr.Contains("egg") || eventTypeStr.Contains("bunny"))
                return EventType.Easter;
            if (eventTypeStr.Contains("hall") || eventTypeStr.Contains("spooky") || eventTypeStr.Contains("candy") || eventTypeStr.Contains("samhain"))
                return EventType.Halloween;
            return EventType.None;
        }

        private static EventType GetEventTypeFromEntity(BaseEntity baseEntity)
        {
            if (baseEntity is BradleyAPC) return EventType.Bradley;
            if (baseEntity is CargoPlane) return EventType.CargoPlane;
            if (baseEntity is CargoShip) return EventType.CargoShip;
            if (baseEntity is PatrolHelicopter) return EventType.Helicopter;
            if (baseEntity is SantaSleigh) return EventType.SantaSleigh;
            if (baseEntity is XMasRefill) return EventType.Christmas;
            if (baseEntity is HalloweenHunt) return EventType.Halloween;
            if (baseEntity is EggHuntEvent) return EventType.Easter;
            var ch47HelicopterAiController = baseEntity as CH47HelicopterAIController;
            if (ch47HelicopterAiController != null && ch47HelicopterAiController.landingTarget == Vector3.zero) return EventType.Chinook;
            return EventType.None;
        }

        private static int GetEventIndexFromWeight(Dictionary<int, float> weightDict)
        {
            if (weightDict.Count <= 0) return 0;
            if (weightDict.Count == 1) return weightDict.Keys.FirstOrDefault();
            var sum = weightDict.Sum(x => x.Value);
            var rand = UnityEngine.Random.Range(0f, sum);
            foreach (var entry in weightDict)
            {
                if ((rand -= entry.Value) <= 0f)
                {
                    return entry.Key;
                }
            }
            return 0;
        }

        private static IEnumerable<T> GetEventEntities<T>(BaseEvent baseEvent, Func<T, bool> filter = null) where T : BaseEntity
        {
            var excludePlayerEntity = (baseEvent as CoexistEvent)?.ExcludePlayerEntity ?? false;
            foreach (var serverEntity in BaseNetworkable.serverEntities)
            {
                var entity = serverEntity as T;
                if (entity == null) continue;
                if (excludePlayerEntity && entity.OwnerID.IsSteamId()) continue;
                if (filter != null && !filter(entity)) continue;
                yield return entity;
            }
        }

        private static bool CanRunEvent<T>(EventType eventType, BaseEvent baseEvent, bool vanilla = true, Func<T, bool> filter = null) where T : BaseEntity
        {
            return CheckOnlinePlayers(eventType, baseEvent, vanilla) && CanRunCoexistEvent(eventType, baseEvent, vanilla, filter);
        }

        private static bool CheckOnlinePlayers(EventType eventType, BaseEvent baseEvent, bool vanilla = true)
        {
            var onlinePlayers = BasePlayer.activePlayerList.Count;
            if (baseEvent.MinimumOnlinePlayers > 0 && onlinePlayers < baseEvent.MinimumOnlinePlayers)
            {
                instance?.PrintDebug($"The online players is less than {baseEvent.MinimumOnlinePlayers}, so the {eventType} {(vanilla ? "vanilla" : "auto")} event cannot run", true);
                return false;
            }
            if (baseEvent.MaximumOnlinePlayers > 0 && onlinePlayers > baseEvent.MaximumOnlinePlayers)
            {
                instance?.PrintDebug($"The online players is greater than {baseEvent.MaximumOnlinePlayers}, so the {eventType} {(vanilla ? "vanilla" : "auto")} event cannot run", true);
                return false;
            }
            return true;
        }

        private static bool CanRunCoexistEvent<T>(EventType eventType, BaseEvent baseEvent, bool vanilla = true, Func<T, bool> filter = null) where T : BaseEntity
        {
            var coexistEventS = baseEvent as CoexistEvent;
            if (coexistEventS != null && coexistEventS.ServerMaximumNumber > 0)
            {
                if (BaseNetworkable.serverEntities.Count(x =>
                {
                    var entity = x as T;
                    if (entity == null) return false;
                    if (filter != null && !filter(entity)) return false;
                    return !coexistEventS.ExcludePlayerEntity || !entity.OwnerID.IsSteamId();
                }) >= coexistEventS.ServerMaximumNumber)
                {
                    instance?.PrintDebug($"The number of {eventType} {(vanilla ? "vanilla" : "auto")} events has reached the limit of {coexistEventS.ServerMaximumNumber}", true);
                    return false;
                }
            }
            return true;
        }

        private static bool CanRunHuntEvent<T>(EventType eventType, BaseEvent baseEvent, bool vanilla = true) where T : EggHuntEvent
        {
            if (!CheckOnlinePlayers(eventType, baseEvent, vanilla)) return false;
            return true;
        }

        #endregion Helpers

        #region Debug

        private void PrintDebug(string message, bool warning = false)
        {
            if (configData.Global.DebugEnabled)
            {
                if (warning) PrintWarning(message);
                else Puts(message);
            }
        }

        #endregion Debug

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings Global { get; set; } = new Settings();

            public class Settings
            {
                [JsonProperty(PropertyName = "Enable Debug Mode")]
                public bool DebugEnabled { get; set; } = true;

                [JsonProperty(PropertyName = "Announce On Plugin Loaded")]
                public bool AnnounceOnLoaded { get; set; }

                [JsonProperty(PropertyName = "Announce On Event Triggered")]
                public bool AnnounceEventTriggered { get; set; }

                [JsonProperty(PropertyName = "Use GUIAnnouncements Plugin")]
                public bool UseGuiAnnouncements { get; set; }
            }

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings Chat { get; set; } = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Next Event Command")]
                public string NextEventCommand { get; set; } = "nextevent";

                [JsonProperty(PropertyName = "Run Event Command")]
                public string RunEventCommand { get; set; } = "runevent";

                [JsonProperty(PropertyName = "Kill Event Command")]
                public string KillEventCommand { get; set; } = "killevent";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string Prefix { get; set; } = "[AutomatedEvents]: ";

                [JsonProperty(PropertyName = "Chat Prefix Color")]
                public string PrefixColor { get; set; } = "#00FFFF";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong SteamIdIcon { get; set; } = 0;
            }

            [JsonProperty(PropertyName = "Event Settings")]
            public EventSettings Events { get; set; } = new EventSettings();

            public class EventSettings
            {
                [JsonProperty(PropertyName = "Bradley Event")]
                public CoexistEvent Bradley { get; set; } = new CoexistEvent
                {
                    DisplayName = "Bradley",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 45,
                };

                [JsonProperty(PropertyName = "Cargo Plane Event")]
                public CoexistEvent Plane { get; set; } = new CoexistEvent
                {
                    DisplayName = "Cargo Plane",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 45,
                    EventWeights = new List<EventWeight>
                    {
                        new EventWeight {Weight = 60},
                        new EventWeight
                        {
                            Name = "FancyDrop",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> { "ad.random" }
                        },
                        new EventWeight
                        {
                            Name = "PlaneCrash",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> { "callcrash" }
                        }
                    }
                };

                [JsonProperty(PropertyName = "Cargo Ship Event")]
                public CoexistEvent Ship { get; set; } = new CoexistEvent
                {
                    DisplayName = "Cargo Ship",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 45,
                    EventWeights = new List<EventWeight>
                    {
                        new EventWeight {Weight = 80},
                        new EventWeight
                        {
                            Name = "RustTanic",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> { "calltitanic" }
                        }
                    }
                };

                [JsonProperty(PropertyName = "Chinook (CH47) Event")]
                public CoexistEvent Chinook { get; set; } = new CoexistEvent
                {
                    DisplayName = "Chinook",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 45
                };

                [JsonProperty(PropertyName = "Helicopter Event")]
                public CoexistEvent Helicopter { get; set; } = new CoexistEvent
                {
                    DisplayName = "Helicopter",
                    MinimumTimeBetween = 45,
                    MaximumTimeBetween = 60,
                    EventWeights = new List<EventWeight>
                    {
                        new EventWeight {Weight = 60},
                        new EventWeight
                        {
                            Name = "HeliRefuel",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> { "pe call" }
                        },
                        new EventWeight
                        {
                            Name = "PilotEject",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> { "hr call" }
                        }
                    }
                };

                [JsonProperty(PropertyName = "Santa Sleigh Event")]
                public CoexistEvent SantaSleigh { get; set; } = new CoexistEvent
                {
                    DisplayName = "Santa Sleigh",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 60
                };

                [JsonProperty(PropertyName = "Christmas Event")]
                public CoexistEvent Christmas { get; set; } = new CoexistEvent
                {
                    DisplayName = "Christmas",
                    MinimumTimeBetween = 60,
                    MaximumTimeBetween = 120,
                    EventWeights = new List<EventWeight>
                    {
                        new EventWeight {Weight = 80},
                        new EventWeight
                        {
                            Name = "AlphaChristmas",
                            Weight = 20,
                            ArgType = ArgumentType.Command,
                            Args = new List<string> {"alphachristmas.refill"}
                        }
                    }
                };

                [JsonProperty(PropertyName = "Easter Event")]
                public BaseEvent Easter { get; set; } = new BaseEvent
                {
                    DisplayName = "Easter",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 60
                };

                [JsonProperty(PropertyName = "Halloween Event")]
                public BaseEvent Halloween { get; set; } = new BaseEvent
                {
                    DisplayName = "Halloween",
                    MinimumTimeBetween = 30,
                    MaximumTimeBetween = 60
                };
            }
        }

        private class BaseEvent
        {
            [JsonProperty(PropertyName = "Enabled", Order = 1)]
            public bool Enabled { get; set; }

            [JsonProperty(PropertyName = "Display Name", Order = 2)]
            public string DisplayName { get; set; }

            [JsonProperty(PropertyName = "Disable Vanilla Event", Order = 3)]
            public bool DisableVanillaEvent { get; set; }

            [JsonProperty(PropertyName = "Event Start Offset (Minutes)", Order = 4)]
            public float StartOffset { get; set; }

            [JsonProperty(PropertyName = "Minimum Time Between (Minutes)", Order = 5)]
            public float MinimumTimeBetween { get; set; }

            [JsonProperty(PropertyName = "Maximum Time Between (Minutes)", Order = 6)]
            public float MaximumTimeBetween { get; set; }

            [JsonProperty(PropertyName = "Minimum Online Players Required (0 = Disabled)", Order = 7)]
            public int MinimumOnlinePlayers { get; set; } = 0;

            [JsonProperty(PropertyName = "Maximum Online Players Required (0 = Disabled)", Order = 8)]
            public int MaximumOnlinePlayers { get; set; } = 0;

            [JsonProperty(PropertyName = "Announce Next Run Time", Order = 9)]
            public bool AnnounceNext { get; set; }

            [JsonProperty(PropertyName = "Restart Timer On Entity Kill", Order = 10)]
            public bool RestartTimerOnKill { get; set; } = true;

            [JsonProperty(PropertyName = "Kill Existing Event On Plugin Loaded", Order = 11)]
            public bool KillEventOnLoaded { get; set; }

            [JsonIgnore]
            public double NextRunTime { get; set; }

            public virtual EventWeight GetRandomEventWeight()
            {
                return null;
            }
        }

        private class CoexistEvent : BaseEvent
        {
            [JsonProperty(PropertyName = "Maximum Number On Server", Order = 19)]
            public int ServerMaximumNumber { get; set; } = 1;

            [JsonProperty(PropertyName = "Exclude Player's Entity", Order = 20)]
            public bool ExcludePlayerEntity { get; set; } = true;

            [JsonProperty(PropertyName = "Event Weights", Order = 21, ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<EventWeight> EventWeights { get; set; } = new List<EventWeight>();

            [JsonIgnore]
            private readonly List<EventWeight> _validEventWeights = new List<EventWeight>();

            public override EventWeight GetRandomEventWeight()
            {
                if (EventWeights.Count <= 0)
                {
                    return null;
                }
                _validEventWeights.Clear();
                _validEventWeights.AddRange(EventWeights.Where(x => x.IsValid()));
                if (_validEventWeights.Count <= 0)
                {
                    return null;
                }

                int totalWeight = 0;
                foreach (var eventWeight in _validEventWeights)
                {
                    totalWeight += eventWeight.Weight;
                }

                int random = UnityEngine.Random.Range(0, totalWeight);
                foreach (var eventWeight in _validEventWeights)
                {
                    if ((random -= eventWeight.Weight) < 0)
                    {
                        return eventWeight;
                    }
                }

                return null;
            }
        }

        private enum ArgumentType
        {
            Command,
            CallHook,
        }

        private class EventWeight
        {
            [JsonProperty(PropertyName = "Weight")]
            public int Weight { get; set; }

            [JsonProperty(PropertyName = "Name")]
            public string Name { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty(PropertyName = "Argument Type (Command or CallHook)")]
            public ArgumentType? ArgType { get; set; }

            [JsonProperty(PropertyName = "Arguments")]
            public List<string> Args { get; set; }

            [JsonIgnore] public bool IsNormalEvent => string.IsNullOrEmpty(Name);

            public bool IsValid()
            {
                if (Weight <= 0)
                {
                    return false;
                }
                if (IsNormalEvent)
                {
                    return true;
                }
                if (!ArgType.HasValue)
                {
                    return false;
                }
                if (ArgType.Value == ArgumentType.CallHook)
                {
                    if (Args.Count >= 2)
                    {
                        var plugin = instance.Manager.GetPlugin(Args[0]);
                        if (plugin != null)
                        {
                            return true;
                        }
                    }
                }
                else if (ArgType.Value == ArgumentType.Command)
                {
                    if (Args.Count >= 1)
                    {
                        return true;
                    }
                }

                return false;
            }

            public void RunCustomEvent()
            {
                if (Weight <= 0 || IsNormalEvent || !ArgType.HasValue)
                {
                    return;
                }
                if (ArgType.Value == ArgumentType.CallHook)
                {
                    var pluginName = Args[0];
                    var hookName = Args[1];
                    var plugin = instance.Manager.GetPlugin(pluginName);
                    if (plugin != null)
                    {
                        var args = Args.Skip(2);
                        plugin.Call(hookName, args.Select(x => (object)x).ToArray());
                    }
                }
                else if (ArgType.Value == ArgumentType.Command)
                {
                    var command = Args[0];
                    var args = Args.Skip(1) ;
                    ConsoleSystem.Run(ConsoleSystem.Option.Server, command, args.Select(x => (object)x).ToArray());
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message,
                string.IsNullOrEmpty(configData.Chat.Prefix)
                    ? string.Empty
                    : $"<color={configData.Chat.PrefixColor}>{configData.Chat.Prefix}</color>",
                configData.Chat.SteamIdIcon);
        }

        private void Print(IPlayer iPlayer, string message)
        {
            iPlayer.Reply(message,
                iPlayer.Id == "server_console"
                    ? $"{configData.Chat.Prefix}"
                    : $"<color={configData.Chat.PrefixColor}>{configData.Chat.Prefix}</color>");
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["BlankEvent"] = "You need to specify an event",
                ["UnknownEvent"] = "'{0}' is an unknown event type",
                ["NotSet"] = "'{0}' is not set to run via Automated Events",
                ["NextRunTime"] = "Next '{0}' event will be ran after {1}",
                ["Running"] = "'{0}' attempting to run automated event: {1}",
                ["Removing"] = "'{0}' attempting to remove any current running event: {1}",

                ["Bradley"] = "Bradley event has been triggered",
                ["CargoPlane"] = "CargoPlane event has been triggered",
                ["FancyDrop"] = "FancyDrop event has been triggered",
                ["PlaneCrash"] = "PlaneCrash event has been triggered",
                ["CargoShip"] = "CargoShip event has been triggered",
                ["RustTanic"] = "RustTanic event has been triggered",
                ["Chinook"] = "Chinook event has been triggered",
                ["Helicopter"] = "Helicopter event has been triggered",
                ["PilotEject"] = "PilotEject event has been triggered",
                ["HeliRefuel"] = "HeliRefuel event has been triggered",
                ["SantaSleigh"] = "SantaSleigh event has been triggered",
                ["Christmas"] = "Christmas event has been triggered",
                ["AlphaChristmas"] = "AlphaChristmas event has been triggered",
                ["Easter"] = "Easter event has been triggered",
                ["Halloween"] = "Halloween event has been triggered",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "æ¨æ²¡æä½¿ç¨ '{0}' å½ä»¤çæé",
                ["BlankEvent"] = "æ¨éè¦æå®ä¸ä¸ªäºä»¶çç±»å",
                ["UnknownEvent"] = "'{0}' æ¯ä¸ä¸ªæªç¥çäºä»¶ç±»å",
                ["NotSet"] = "'{0}' äºä»¶æ²¡æå¯ç¨",
                ["NextRunTime"] = "ä¸æ¬¡ '{0}' äºä»¶å°å¨ {1} åè¿è¡",
                ["Running"] = "'{0}' éè¿å½ä»¤è¿è¡äº {1} äºä»¶",
                ["Removing"] = "'{0}' éè¿å½ä»¤å é¤äº {1} äºä»¶",

                ["Bradley"] = "å¦ååºæ¥è£é¼äº",
                ["CargoPlane"] = "è´§æºäºä»¶è§¦åäº",
                ["FancyDrop"] = "è´§æºäºä»¶è§¦åäº",
                ["PlaneCrash"] = "è´§æºå æ¯äºä»¶è§¦åäº",
                ["CargoShip"] = "è´§è¹äºä»¶è§¦åäº",
                ["RustTanic"] = "å°å±±è´§è¹äºä»¶è§¦åäº",
                ["Chinook"] = "åèºæé£æºæ¥å¯",
                ["Helicopter"] = "æ­¦ç´åºæ¥è£é¼äº",
                ["PilotEject"] = "æ­¦ç´é©¾é©¶åå¼¹åºäºä»¶è§¦åäº",
                ["HeliRefuel"] = "æ­¦ç´å æ²¹äºä»¶è§¦åäº",
                ["SantaSleigh"] = "å£è¯èäººéªçå®çéªæ©æ¥éç¤¼ç©å¯",
                ["Christmas"] = "å£è¯èäºä»¶è§¦åäºï¼å¿«ç¹å»ççæ¨é£è­è¢å­",
                ["AlphaChristmas"] = "å£è¯èäºä»¶è§¦åäºï¼å¿«ç¹å»ççæ¨é£è­è¢å­",
                ["Easter"] = "å¤æ´»èäºä»¶è§¦åäºï¼å¿«ç¹å»æ¡å½©èå",
                ["Halloween"] = "ä¸å£èäºä»¶è§¦åäºï¼å¿«ç¹å»æ¡ç³æå§",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutomatedEvents.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/alias-system ---
// --- Original File Path: A/AliasSystem/AliasSystem.cs ---

ï»¿using System.Collections.Generic;
using Oxide.Game.Rust.Libraries;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Alias System", "LaserHydra", "2.1.3", ResourceId = 1307)]
    [Description("Setup alias for chat and console commands")]
    class AliasSystem : RustPlugin
    {
		const string permadmin = "aliassystem.admin";
		const string permuse = "aliassystem.use";

		class Alias
		{
			public string original;
			public string alias;
			public string originaltype;
			public string aliastype;
			public string permission = permuse;
			
			public Alias(string aliasname, string Original)
			{
				original = Original;
				alias = aliasname;
				
				if(aliasname.StartsWith("/")) aliastype = "chat";
				else if(!aliasname.StartsWith("/")) aliastype = "console";
				
				if(Original.StartsWith("/")) originaltype = "chat";
				else if(!Original.StartsWith("/")) originaltype = "console";
			}
			
			public Alias()
			{
			}
		}
		
		class Data
		{
			public List<Alias> alias = new List<Alias>();
			
			public Data()
			{
			}
		}
		
		Data data;
		
		Data LoadData() 
		{
			return Interface.Oxide.DataFileSystem.ReadObject<Data>("AliasSystem_Data");
		}
		
		void SaveData()
		{
			Interface.Oxide.DataFileSystem.WriteObject("AliasSystem_Data", data);
		}
		
		void Loaded()
		{	
			data = LoadData();
			LoadConfig();
			
			permission.RegisterPermission(permadmin, this);
			permission.RegisterPermission(permuse, this);

            foreach(Alias current in data.alias)
            {
				if(current.aliastype == "chat")
				{
					cmd.AddChatCommand(current.alias.Substring(1, current.alias.Length - 1), this, "ChatAlias");
				}
				else if(current.aliastype == "console")
				{
					cmd.AddConsoleCommand("global." + current.alias, this, "ConsoleAlias");
				}
            }
		}
		
		void LoadConfig()
		{
		}
		
		void LoadDefaultConfig()
		{
			Puts("Generating new config file...");
			LoadConfig();
		}
		
		void ChatAlias(BasePlayer player, string command, string[] args)
		{
			if(GetAliasByName("/" + command) == null) return;
			
			Alias alias = GetAliasByName("/" + command);
			
			if(!permission.UserHasPermission(player.userID.ToString(), alias.permission)) 
			{
				SendChatMessage(player, "Command Alias", "You have no permission to use this command.");
				return;
			}
			
			if(alias.originaltype == "chat")
				RunChatCommand(player, command, ListToString(args.ToList(), 0, " "));
			else if(alias.originaltype == "console")
				RunConsoleCommand(player, command, ListToString(args.ToList(), 0, " "));
		}
		
		void ConsoleAlias(ConsoleSystem.Arg arg)
		{
			BasePlayer player = (BasePlayer)arg?.Connection?.player ?? null;
			if(player == null) return;
			
			string command = arg?.cmd?.FullName?.Replace("global.", "") ?? "";
			
			if(GetAliasByName(command) == null) return;
			
			Alias alias = GetAliasByName(command);
			
			if(!permission.UserHasPermission(player.userID.ToString(), alias.permission)) 
			{
				SendChatMessage(player, "Command Alias", "You have no permission to use this command.");
				return;
			}
			
			if(alias.originaltype == "chat")
				RunChatCommand(player, command, ArgToString(arg, 0, " "));
			else if(alias.originaltype == "console")
				RunConsoleCommand(player, command, ArgToString(arg, 0, " "));
		}
		
		[ChatCommand("alias")]
		void cmdAlias(BasePlayer player, string command, string[] args)
		{
			if(!permission.UserHasPermission(player.userID.ToString(), permadmin)) 
			{
				SendChatMessage(player, "Command Alias", "You have no permission to use this command.");
				return;
			}
			
			if(args.Length < 1)
			{
				SendChatMessage(player, "Command Alias", "\n/alias add <alias> <command>\n/alias remove <alias>");
				return;
			}
			
			switch(args[0])
			{
				case "add":
					
					if(args.Length < 3)
					{
						SendChatMessage(player, "Command Alias", "Syntax: /alias add <alias> <original>");
						return;
					}
					
					data.alias.Add(new Alias(args[1], args[2]));
					SaveData();
					
					if(args[1].StartsWith("/")) cmd.AddChatCommand(args[1].Substring(1, args[1].Length - 1), this, "ChatAlias");
					else cmd.AddConsoleCommand("global." + args[1], this, "ConsoleAlias");
					
					SendChatMessage(player, "Command Alias", $"Alias {args[1]} successfuly set for command {args[2]}");
					
					break;
					
				case "remove":
				
					if(args.Length < 2)
					{
						SendChatMessage(player, "Command Alias", "Syntax: /alias remove <alias>");
						return;
					}
					
					Alias alias = GetAliasByName(args[1]);
					
					if(data.alias.Contains(alias))
					{
						data.alias.Remove(alias);
						SaveData();
					
						SendChatMessage(player, "Command Alias", $"Alias {args[1]} successfuly removed.");	
					}
					else SendChatMessage(player, "Command Alias", $"Alias {args[1]} does not exist.");
					
					break;
					
				default:
					break;
			}
		}
		
		Alias GetAliasByName(string aliasname)
		{
			foreach(Alias current in data.alias)
            {
				if(current.alias == aliasname) return current;
            }
			
			return null;
		}
		
		void RunChatCommand(BasePlayer player, string command, string args)
		{
			Alias alias = GetAliasByName(command);
			if(alias == null) alias = GetAliasByName("/" + command);
			
			player.SendConsoleCommand("chat.say", "/" + $"{alias.original.Substring(1, alias.original.Length - 1).Replace("'", "\"")} {args.Replace("'", "\"")}");
		}
		
		void RunConsoleCommand(BasePlayer player, string command, string args)
		{
			Alias alias = GetAliasByName(command);
			if(alias == null) alias = GetAliasByName("/" + command);
			
			player.SendConsoleCommand(alias.original.Replace("'", "\""), args.Replace("'", "\""));
		}
		
        #region UsefulMethods
        //--------------------------->   Player finding   <---------------------------//

		BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();
            
			foreach(BasePlayer player in BasePlayer.activePlayerList)
			{
				if(player.displayName.ToLower().Contains(searchedLower)) foundPlayers.Add(player.displayName);
			}
			
			switch(foundPlayers.Count)
			{
				case 0:
					SendChatMessage(executer, prefix, "The Player can not be found.");
					break;
					
				case 1:
					targetPlayer = BasePlayer.Find(foundPlayers[0]);
					break;
				
				default:
					string players = ListToString(foundPlayers, 0, ", ");
					SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
					break;
			}
			
            return targetPlayer;
        }

        //---------------------------->   Converting   <----------------------------//

        string ListToString(List<string> list, int first, string seperator)
		{
			return String.Join(seperator, list.Skip(first).ToArray());
		}
		
		string ArgToString(ConsoleSystem.Arg arg, int first, string seperator)
		{
			if(arg.Args == null || arg.Args.Count() < 1) return string.Empty;
			return ListToString(arg.Args.ToList(), first, seperator);
		}

        //------------------------------>   Config   <------------------------------//

        void SetConfig(string Arg1, object Arg2, object Arg3 = null, object Arg4 = null)
		{
			if(Arg4 == null)
			{
				Config[Arg1, Arg2.ToString()] = Config[Arg1, Arg2.ToString()] ?? Arg3;
			}
			else if(Arg3 == null)
			{
				Config[Arg1] = Config[Arg1] ?? Arg2;
			}
			else
			{
				Config[Arg1, Arg2.ToString(), Arg3.ToString()] = Config[Arg1, Arg2.ToString(), Arg3.ToString()] ?? Arg4;
			}
		}

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        //---------------------------------------------------------------------------//
        #endregion
    }
}

// --- End of file: AliasSystem.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/anti-code-raid ---
// --- Original File Path: A/AntiCodeRaid/AntiCodeRaid.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Anti Code Raid", "kwamaking", "1.1.1")]
    [Description("Prevents players from code raiding if they're not on your team, TC authed, or the owner.")]
    class AntiCodeRaid : RustPlugin
    {
        private AntiCodeRaidConfiguration pluginConfiguration { get; set; }
        private const string UsePermission = "anticoderaid.enabled";
        private const string DefaultPrefixColor = "#FF0000";
        private const ulong DefaultChatIconId = 0;

        #region Oxide Hooks

        protected override void LoadDefaultConfig() => pluginConfiguration = new AntiCodeRaidConfiguration();

        private void Init()
        {
            try
            {
                base.LoadConfig();
                permission.RegisterPermission(UsePermission, this);
                pluginConfiguration = Config.ReadObject<AntiCodeRaidConfiguration>();
            }
            catch (Exception e)
            {
                base.LoadConfig();
                Puts($"Failed to load plugin configuration, using default configuration: {e.Message} {e.StackTrace}");
            }
        }


        protected override void SaveConfig() => Config.WriteObject(pluginConfiguration);

        private object CanUnlock(BasePlayer player, BaseLock baseLock)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePermission))
                return null;

            if (IsPlayerOwner(player, baseLock) || IsPlayerOnTeam(player, baseLock) || IsPlayerTCAuthed(player))
                return null;

            SendMessage(player, "CannotUnlock");

            return false;
        }

        private bool IsPlayerOwner(BasePlayer player, BaseLock baseLock)
        {
            return player.userID == baseLock.GetParentEntity()?.OwnerID;
        }

        private bool IsPlayerOnTeam(BasePlayer player, BaseLock baseLock)
        {
            var lockEntity = baseLock.GetParentEntity();
            if (pluginConfiguration.allowTeamMembers && null != lockEntity && null != player.Team)
                return player.Team.members.Contains(lockEntity.OwnerID);

            return false;
        }

        private bool IsPlayerTCAuthed(BasePlayer player)
        {
            return pluginConfiguration.allowTCAuthed && player.IsBuildingAuthed();
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    { "CannotUnlock", "You are not allowed to unlock this lock." }
                }, this, "en");
        }

        private void SendMessage(BasePlayer player, string messageKey, params object[] args)
        {
            var prefix = String.Format("[<color={0}>AntiCodeRaid</color>]", pluginConfiguration.pluginPrefixColor);
            var message = lang.GetMessage(messageKey, this, player.UserIDString);

            Player.Message(player, message, prefix, pluginConfiguration.chatIconId, args);
        }

        #endregion

        #region Configuration

        private class AntiCodeRaidConfiguration
        {
            [JsonProperty("allowTeamMembers")]
            public bool allowTeamMembers { get; private set; } = true;
            [JsonProperty("allowTCAuthed")]
            public bool allowTCAuthed { get; private set; } = true;
            [JsonProperty("pluginPrefixColor")]
            public string pluginPrefixColor { get; private set; } = DefaultPrefixColor;
            [JsonProperty("chatIconId")]
            public ulong chatIconId { get; private set; } = DefaultChatIconId;
        }

        #endregion
    }
}


// --- End of file: AntiCodeRaid.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/air-loot-supply ---
// --- Original File Path: A/AirLootSupply/AirLootSupply.cs ---

ï»¿namespace Oxide.Plugins
{
    [Info("Air Loot Supply", "Arainrr", "1.0.0")]
    [Description("Allow supply to be loot when it's dropping")]
    public class AirLootSupply : RustPlugin
    {
        private void OnServerInitialized()
        {
            foreach (var supplyDrop in UnityEngine.Object.FindObjectsOfType<SupplyDrop>())
                OnEntitySpawned(supplyDrop);
        }

        private void OnEntitySpawned(SupplyDrop supplyDrop)
        {
            if (supplyDrop == null) return;
            supplyDrop.MakeLootable();
        }
    }
}

// --- End of file: AirLootSupply.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/admin-deep-cover ---
// --- Original File Path: A/AdminDeepCover/AdminDeepCover.cs ---

using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Admin Deep Cover", "Dana", "2.2.8")]
    [Description("Hides the original identity of admins by masking their steam profiles")]

    public class AdminDeepCover : RustPlugin
    {
        #region Plugin References
        [PluginReference] Plugin BetterChat;
        #endregion

        #region Fields and Properties
        private DynamicConfigFile _pluginData;
        private AdminDeepCoverData _adminDeepCoverData;
        Configuration config;
        private const string Perm = "admindeepcover.use";


        #endregion

        #region Oxide Hooks
        private void Init()
        {
            RegisterPermissions();
            _pluginData = Interface.Oxide.DataFileSystem.GetFile("AdminDeepCover");
            _adminDeepCoverData = new AdminDeepCoverData();
            LoadData();
            PrintWarning("Initialized");
        }
        protected override void LoadDefaultMessages()
        {

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [PluginMessages.NoPermission] = "<size=12>You don't have permission to use this command</size>",
                [PluginMessages.NoProfilePermission] = "<size=12>You don't have permission to use this profile</size>",
                [PluginMessages.DeepCoverEnabled] = "<size=12>Admin deep cover has been <color=#00fa9a>Enabled</color></size>",
                [PluginMessages.DeepCoverDisabled] = "<size=12>Admin deep cover has been <color=#00fa9a>Disabled</color></size>",
                [PluginMessages.DeepCoverChanged] = "<size=12>Fake identity has changed to <color=#00fa9a>{0}</color></size>",
                [PluginMessages.RequestedFakeIdentifyNotFound] = "<size=12>Requested fake identity is not found</size>",
                [PluginMessages.NoFakeIdentitiesAvailable] = "<size=12>No fake identities available</size></size>",
                [PluginMessages.FakeIdentifyNotFound] = "<size=12>Fake identity is not found</size>",
                [PluginMessages.DataCorruptedUp] = "<size=12>Data is corrupt</size>",
            }, this);
        }
        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var identify = GetIdentify(player);
                if (identify == null)
                    return;

                RemoveFakeIdentity(player, identify);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (config.ReconnectDeepCover)
            {
                OnPlayerRespawned(player);
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var identify = GetIdentify(player);
            if (identify == null)
                return;
            RemoveFakeIdentity(player, identify, config.ReconnectDeepCover);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            var identify = GetIdentify(player);
            if (identify == null)
                return;
            if (!identify.IsEnabled)
            {
                if (IsIdentifyAvailable(identify) && SetFakeIdentity(player, identify)) 
                { 
                    player.ChatMessage(Lang(PluginMessages.DeepCoverEnabled, player.UserIDString));
                }
                else
                {
                    Identify newIdentify;
                    if (config.ChangeIdentityInOrder)
                    {
                        newIdentify = GetAvailableIdentities().OrderBy(x => x.Profile).FirstOrDefault();
                    }
                    else
                    {
                        newIdentify = GetAvailableIdentities().GetRandom();
                    }
                    if (newIdentify == null || !SetFakeIdentity(player, newIdentify))
                    {
                        player.ChatMessage(Lang(PluginMessages.DeepCoverDisabled, player.UserIDString));
                        return;
                    }
                    player.ChatMessage(Lang(PluginMessages.DeepCoverChanged, player.UserIDString, newIdentify.Name));
                }
            }
            else
            {
                SetFakeIdentity(player, identify);
            }

        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (info == null || info.Initiator == null)
                return;

            var attacker = info.Initiator.ToPlayer();
            if (attacker == null)
                return;

            var identify = GetIdentify(attacker);
            if (identify == null)
                return;

            attacker.userID = identify.UserId;
            timer.Once(0.2f, () =>
            {
                if (attacker != null)
                    attacker.userID = identify.RestoreUserId;
            });
        }

        #region Chat Hooks
        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (plugins.Exists(nameof(BetterChat)))
                return null;

            var identify = GetIdentify(player);
            if (identify == null)
                return null;
            if (channel == Chat.ChatChannel.Team)
            {
                var userId = identify.RestoreUserId;
                var userName = identify.RestoreName;
                if (config.TeamChatRemainsDeepCover)
                {
                    userId = identify.UserId;
                    userName = identify.Name;
                }
                var formattedMessage = $"<color=#55aaff>{userName}</color>: <color=#ffffff>{message}</color>";
                RelationshipManager.PlayerTeam team = player.Team;
                if (team == null || team.members.Count == 0)
                {
                    return true;
                }

                team.BroadcastTeamChat(userId, userName, formattedMessage, "white");

                var onlineMemberConnections = team.GetOnlineMemberConnections();
                if (onlineMemberConnections != null)
                {
                    ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add", (int)channel, userId, formattedMessage);
                }
            }
            else
            {
                Server.Broadcast(message, $"<color=#5af>{identify.Name}</color>", identify.UserId);
            }
            return true;
        }

        private object OnUserChat(IPlayer player, string message)
        {
            if (!plugins.Exists(nameof(BetterChat)))
                return null;
            return IsDeepCovered(Convert.ToUInt64(player.Id)) ? true : (object)null;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            object channel;
            if (!data.TryGetValue("ChatChannel", out channel) || !(channel is Chat.ChatChannel))
                return null;

            var chatChannel = (Chat.ChatChannel)channel;

            object player;
            if (!data.TryGetValue("Player", out player) || !(player is IPlayer))
                return null;

            var basePlayer = (BasePlayer)((IPlayer)player).Object;
            var identify = GetIdentify(basePlayer);
            if (identify == null)
                return null;

            object message;
            if (!data.TryGetValue("Message", out message) || message == null)
                return null;
            var formattedMessage = message.ToString();

            object username;
            if (!data.TryGetValue("UsernameSettings", out username) || !(username is Dictionary<string, object>))
                return null;
            var usernameSetting = (Dictionary<string, object>)username;

            object color;
            var usernameColor = "#55aaff";
            if (usernameSetting.TryGetValue("Color", out color) && color != null)
                usernameColor = color.ToString();

            var chatMessage = BetterChat?.Call("API_GetFormattedMessage", player, formattedMessage)?.ToString() ?? "";
            var consoleMessage = BetterChat?.Call("API_GetFormattedMessage", player, formattedMessage, true)?.ToString() ?? "";

            var userId = identify.UserId;
            var userName = identify.Name;
            if (chatChannel == Chat.ChatChannel.Team)
            {
                if (!config.TeamChatRemainsDeepCover)
                {
                    userId = identify.RestoreUserId;
                    userName = identify.RestoreName;

                    RemoveFakeIdentity(basePlayer, identify, true);
                    chatMessage = BetterChat?.Call("API_GetFormattedMessage", player, formattedMessage)?.ToString() ?? "";
                    consoleMessage = BetterChat?.Call("API_GetFormattedMessage", player, formattedMessage, true)?.ToString() ?? "";
                    SetFakeIdentity(basePlayer, identify);
                }
                RelationshipManager.PlayerTeam team = basePlayer.Team;
                if (team == null || team.members.Count == 0)
                    return null;

                team.BroadcastTeamChat(userId, userName, formattedMessage, usernameColor);

                List<Network.Connection> onlineMemberConnections = team.GetOnlineMemberConnections();
                if (onlineMemberConnections != null)
                {
                    ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add", new object[] { (int)chatChannel, userId.ToString(), chatMessage });
                }
            }
            else
            {
                object blocked;
                var blockedIds = new List<string>();
                if (data.TryGetValue("BlockedReceivers", out blocked) && blocked is List<string>)
                    blockedIds = (List<string>)blocked;

                foreach (BasePlayer p in BasePlayer.activePlayerList.Where(p => !blockedIds.Contains(p.UserIDString)))
                    p.SendConsoleCommand("chat.add", new object[] { (int)chatChannel, userId.ToString(), chatMessage });
            }

            Puts($"[{chatChannel}] {consoleMessage}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Channel = chatChannel,
                Message = consoleMessage,
                UserId = userId.ToString(),
                Username = userName,
                Color = usernameColor,
                Time = Epoch.Current
            });

            return true;
        }
        #endregion

        #endregion

        #region Commands
        [ConsoleCommand("deepcover")]
        private void ccmdDeepCover(ConsoleSystem.Arg arg)
            => cmdDeepCover((BasePlayer)arg.Connection.player, arg.cmd.FullName, arg.Args);

        [ChatCommand("deepcover")]
        private void cmdDeepCover(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, Perm))
            {
                player.ChatMessage(Lang(PluginMessages.NoPermission, player.UserIDString));
                return;
            }

            string profileString = null;
            int? profile = null;
            if (args.Length == 1)
            {
                profileString = args[0];
                if (!string.IsNullOrWhiteSpace(profileString))
                {
                    int output;
                    if (int.TryParse(profileString, out output))
                        profile = output;
                }
            }

            if (!IsDeepCovered(player.userID))
            {
                Identify identify = null;
                if (!config.ChangeIdentityInOrder && !profile.HasValue)
                {
                    identify = GetAvailableIdentities().GetRandom();
                }
                else
                {
                    if (profile.HasValue)
                    {
                        identify = GetAvailableIdentities().FirstOrDefault(x => x.Profile == profile);
                        if (identify == null)
                        {
                            player.ChatMessage(Lang(PluginMessages.RequestedFakeIdentifyNotFound, player.UserIDString));
                            return;
                        }
                    }
                    else
                    {
                        identify = GetAvailableIdentities().OrderBy(x => x.Profile).FirstOrDefault();
                        if (identify == null)
                        {
                            player.ChatMessage(Lang(PluginMessages.NoFakeIdentitiesAvailable, player.UserIDString));
                            return;
                        }
                    }
                }

                if (identify == null)
                {
                    player.ChatMessage(Lang(PluginMessages.FakeIdentifyNotFound, player.UserIDString));
                    return;
                }
                if (SetFakeIdentity(player, identify, false, true))
                {
                    player.ChatMessage(Lang(PluginMessages.DeepCoverEnabled, player.UserIDString));
                }
            }
            else
            {
                if (profile.HasValue)
                {
                    var identify = GetAvailableIdentities().FirstOrDefault(x => x.Profile == profile);
                    if (identify == null)
                    {
                        player.ChatMessage(Lang(PluginMessages.RequestedFakeIdentifyNotFound, player.UserIDString));
                        return;
                    }

                    if (SetFakeIdentity(player, identify, true, true))
                    {
                        player.ChatMessage(Lang(PluginMessages.DeepCoverChanged, player.UserIDString, identify.Name));
                    }
                }
                else
                {
                    var identify = GetIdentify(player);
                    RemoveFakeIdentity(player, identify);
                    player.ChatMessage(Lang(PluginMessages.DeepCoverDisabled, player.UserIDString));
                }
            }
        }
        #endregion

        #region Methods
        private RestoreInfo GetIdentify(BasePlayer player)
        {
            RestoreInfo identify;
            if (_adminDeepCoverData.PlayerData.TryGetValue(player.userID, out identify) && identify != null && !identify.IsRemoved)
                return identify;

            return null;
        }

        private bool SetFakeIdentity(BasePlayer player, Identify identify, bool isChange = false, bool sendDiscordNotification = false)
        {
            if (!string.IsNullOrEmpty(identify.Permission) && !HasPermission(player, identify.Permission))
            {
                player.ChatMessage(Lang(PluginMessages.NoProfilePermission, player.UserIDString));
                return false;
            }

            var playerId = player.userID;
            var playerName = player.displayName;
            var wasAdmin = player.IsAdmin;
            var currentGroups = permission.GetUserGroups(player.UserIDString);
            Player.Rename(player, identify.Name);

            if (player.IsAdmin && config.RemoveAdminFlag && !isChange)
            {
                ServerUsers.Set(player.userID, ServerUsers.UserGroup.None, "", "");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.Connection.authLevel = 0;
            }
            if (config.IsDiscordEnabled && sendDiscordNotification)
            {
                SendDiscordMessage(player.userID, playerName, identify.UserId, identify.Name, GetGrid(player.ServerPosition));
            }

            RestoreInfo restoreInfo;
            if (!_adminDeepCoverData.PlayerData.TryGetValue(player.userID, out restoreInfo) || restoreInfo == null)
            {
                _adminDeepCoverData.PlayerData.Add(player.userID, new RestoreInfo
                {
                    IsEnabled = true,
                    IsRemoved = false,
                    Profile = identify.Profile,
                    RestoreName = playerName,
                    RestoreUserId = playerId,
                    WasAdmin = wasAdmin,
                    ChatGroup = identify.ChatGroup,
                    Groups = currentGroups,
                    Name = identify.Name,
                    UserId = identify.UserId,
                });
            }
            else
            {
                restoreInfo.IsEnabled = true;
                restoreInfo.IsRemoved = false;
                restoreInfo.Profile = identify.Profile;
                restoreInfo.Name = identify.Name;
                restoreInfo.UserId = identify.UserId;
                restoreInfo.ChatGroup = identify.ChatGroup;
                if (!isChange)
                {
                    restoreInfo.WasAdmin = wasAdmin;
                    restoreInfo.Groups = currentGroups;
                }
            }

            if (currentGroups != null)
                foreach (var oldGroup in currentGroups)
                {
                    permission.RemoveUserGroup(player.UserIDString, oldGroup);
                }
            permission.AddUserGroup(player.UserIDString, identify.ChatGroup);

            player.SendNetworkUpdateImmediate();
            SaveData();
            return true;
        }

        private void RemoveFakeIdentity(BasePlayer player, RestoreInfo restoreInfo, bool tempRemove = false)
        {
            Player.Rename(player, restoreInfo.RestoreName);
            if (restoreInfo.WasAdmin)
            {
                ServerUsers.Set(player.userID, ServerUsers.UserGroup.Owner, "", "");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                player.Connection.authLevel = 2;
            }

            if (tempRemove)
                restoreInfo.IsEnabled = false;
            else
                restoreInfo.IsRemoved = true;

            permission.RemoveUserGroup(player.UserIDString, restoreInfo.ChatGroup);
            if (restoreInfo.Groups != null)
                foreach (var oldGroup in restoreInfo.Groups)
                {
                    permission.AddUserGroup(player.UserIDString, oldGroup);
                }
            player.SendNetworkUpdateImmediate();
            SaveData();
        }

        private List<Identify> GetAvailableIdentities()
        {
            var identities = config.Identifies;
            var usedIdentities = _adminDeepCoverData.PlayerData.Where(x => x.Value != null && x.Value.IsEnabled && !x.Value.IsRemoved)
                .Select(x => x.Value).ToList();
            return identities.Where(x => usedIdentities.All(m => m.Profile != x.Profile)).ToList();
        }

        private bool IsIdentifyAvailable(RestoreInfo restoreInfo)
        {
            var usedIdentities = _adminDeepCoverData.PlayerData.Where(x => x.Value != null && x.Value.IsEnabled && !x.Value.IsRemoved)
                .Select(x => x.Value).ToList();
            return usedIdentities.All(x => x.Profile != restoreInfo.Profile);
        }
        private string GetGrid(Vector3 pos)
        {
            char letter = 'A';
            var x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            var count = Mathf.Floor(Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) / 26);
            var z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f)) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(letter + x);
            var secondLetter = count <= 0 ? string.Empty : ((char)('A' + (count - 1))).ToString();
            return $"{secondLetter}{letter}{z - 1}";
        }
        private void SendDiscordMessage(ulong playerId, string playerName, ulong fakeId, string fakeName, string grid)
        {
            if (string.IsNullOrWhiteSpace(config.DiscordWebHookUrl))
                return;

            var hexColorNumber = config.DiscordEmbedColor?.Replace("x", string.Empty);
            int color;
            if (!int.TryParse(hexColorNumber, NumberStyles.HexNumber, null, out color))
                color = 3092790;

            var mentions = "";
            if (config.DiscordRolesToMention != null)
                foreach (var roleId in config.DiscordRolesToMention)
                {
                    mentions += $"<@&{roleId}> ";
                }

            var contentBody = new WebHookContentBody
            {
                Content = $"{mentions}{config.DiscordMessage}"
            };
            var body = new WebHookEmbedBody
            {
                Embeds = new[]
                {
                    new WebHookEmbed
                    {
                        Description = string.Format(config.DiscordEmbedDescription, playerName, $"[{playerId}](https://steamcommunity.com/profiles/{playerId})" , fakeName, $"[{fakeId}](https://steamcommunity.com/profiles/{fakeId})" , grid),
                        Color = color
                    }
                }
            };
            webrequest.Enqueue(config.DiscordWebHookUrl, JsonConvert.SerializeObject(contentBody, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
                (headerCode, headerResult) =>
                {
                    if (headerCode >= 200 && headerCode <= 204)
                    {
                        webrequest.Enqueue(config.DiscordWebHookUrl, JsonConvert.SerializeObject(body, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }),
                            (code, result) => { }, this, RequestMethod.POST,
                            new Dictionary<string, string> { { "Content-Type", "application/json" } });
                    }
                }, this, RequestMethod.POST,
                new Dictionary<string, string> { { "Content-Type", "application/json" } });
        }

        private bool IsDeepCovered(ulong playerId)
        {
            RestoreInfo restoreInfo;
            if (!_adminDeepCoverData.PlayerData.TryGetValue(playerId, out restoreInfo) || restoreInfo == null)
            {
                return false;
            }
            return restoreInfo.IsEnabled && !restoreInfo.IsRemoved;
        }
        #endregion

        #region API
        private bool API_IsDeepCovered(BasePlayer player) => IsDeepCovered(player.userID);

        #endregion

        #region Helpers
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);
        private void SaveData()
        {
            _pluginData.WriteObject(_adminDeepCoverData);
        }

        private void LoadData()
        {
            try
            {
                _adminDeepCoverData = _pluginData.ReadObject<AdminDeepCoverData>();
                Puts("Data File Loaded");
            }
            catch
            {
                Puts("Couldn't load admin deep cover data, creating new datafile");
                _adminDeepCoverData = new AdminDeepCoverData();
                SaveData();
            }
        }

        private void RegisterPermissions()
        {
            foreach (var identify in config.Identifies)
            {
                string reqPerm = identify.Permission;

                if (!string.IsNullOrEmpty(reqPerm))
                {
                    if (!reqPerm.StartsWith($"{Name}.", StringComparison.OrdinalIgnoreCase))
                    {
                        Puts("Please change required permission name from {0} to {1}", reqPerm, reqPerm = $"{Name.ToLower()}.{reqPerm}");
                    }
                    if (!permission.PermissionExists(reqPerm))
                    {
                        permission.RegisterPermission(reqPerm, this);
                    }
                }
            }
            permission.RegisterPermission(Perm, this);
        }

        #endregion

        #region Classes
        private static class PluginMessages
        {
            public const string NoPermission = "No Permission";
            public const string NoProfilePermission = "No Profile Permission";
            public const string DeepCoverEnabled = "Deep Cover Enabled";
            public const string DeepCoverDisabled = "Deep Cover Disabled";
            public const string DeepCoverChanged = "Deep Cover Changed";
            public const string RequestedFakeIdentifyNotFound = "Requested Fake Identify Not Found";
            public const string NoFakeIdentitiesAvailable = "No Fake Identities Available";
            public const string FakeIdentifyNotFound = "Fake Identify Not Found";
            public const string DataCorruptedUp = "Data Corrupted Up";
        }
        private class AdminDeepCoverData
        {
            public Dictionary<ulong, RestoreInfo> PlayerData { get; set; } = new Dictionary<ulong, RestoreInfo>();
        }
        public class Identify
        {
            public int Profile { get; set; }
            public string Name { get; set; }
            public ulong UserId { get; set; }
            [JsonProperty("Better Chat Group")]
            public string ChatGroup { get; set; }
            [JsonProperty("Required Permission")]
            public string Permission { get; set; } = Perm;
        }
        public class RestoreInfo : Identify
        {
            public bool IsEnabled { get; set; }
            public bool IsRemoved { get; set; }
            public bool WasAdmin { get; set; }
            public string[] Groups { get; set; }
            public string RestoreName { get; set; }
            public ulong RestoreUserId { get; set; }
        }
        private class Configuration
        {
            [JsonProperty("Change Identity In Order")]
            public bool ChangeIdentityInOrder { get; set; } = true;

            [JsonProperty("Remain Deep Covered After Reconnect")]
            public bool ReconnectDeepCover { get; set; } = true;

            [JsonProperty("Remain Deep Covered In Team Chat")]
            public bool TeamChatRemainsDeepCover { get; set; } = false;

            [JsonProperty("Remove Admin Flag When Deep Covered")]
            public bool RemoveAdminFlag { get; set; } = false;

            [JsonProperty(PropertyName = "Discord - Enabled")]
            public bool IsDiscordEnabled { get; set; } = false;

            [JsonProperty(PropertyName = "Discord - Webhook URL")]
            public string DiscordWebHookUrl { get; set; }

            [JsonProperty(PropertyName = "Discord - Embed Color")]
            public string DiscordEmbedColor { get; set; } = "#2F3136";

            [JsonProperty(PropertyName = "Discord - Message")]
            public string DiscordMessage { get; set; } = "Admin Deep Cover";

            [JsonProperty(PropertyName = "Discord - Embed - Description")]
            public string DiscordEmbedDescription { get; set; } =
                "{0} {1} has become deep covered\n\nIdentity Used\n{2} {3}\n\nLocation\n{4}";

            [JsonProperty(PropertyName = "Discord - Roles To Mention")]
            public List<string> DiscordRolesToMention { get; set; } = new List<string>();

            [JsonProperty("Fake Identities", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Identify> Identifies { get; set; } = new List<Identify>
            {
                new Identify
                {
                    Profile = 1,
                    Name = "garry",
                    UserId = 76561197960279927,
                    ChatGroup = "default",
                    Permission = Perm
                },
                new Identify
                {
                    Profile = 2,
                    Name = "Alistair",
                    UserId = 76561198240345356,
                    ChatGroup = "default",
                    Permission = Perm
                },
                new Identify
                {
                    Profile = 3,
                    Name = "Helk",
                    UserId = 76561197992746895,
                    ChatGroup = "default",
                    Permission = Perm
                },
                new Identify
                {
                    Profile = 4,
                    Name = "Holmzy",
                    UserId = 76561198002789398,
                    ChatGroup = "default",
                    Permission = Perm
                }
            };
        }

        private class WebHookEmbedBody
        {
            [JsonProperty(PropertyName = "embeds")]
            public WebHookEmbed[] Embeds;
        }

        private class WebHookContentBody
        {
            [JsonProperty(PropertyName = "content")]
            public string Content;
        }

        private class WebHookEmbed
        {
            [JsonProperty(PropertyName = "title")]
            public string Title;

            [JsonProperty(PropertyName = "type")]
            public string Type = "rich";

            [JsonProperty(PropertyName = "description")]
            public string Description;

            [JsonProperty(PropertyName = "color")]
            public int Color;

            [JsonProperty(PropertyName = "author")]
            public WebHookAuthor Author;

            [JsonProperty(PropertyName = "image")]
            public WebHookImage Image;

            [JsonProperty(PropertyName = "fields")]
            public List<WebHookField> Fields;

            [JsonProperty(PropertyName = "footer")]
            public WebHookFooter Footer;
        }
        private class WebHookAuthor
        {
            [JsonProperty(PropertyName = "name")]
            public string Name;

            [JsonProperty(PropertyName = "url")]
            public string AuthorUrl;

            [JsonProperty(PropertyName = "icon_url")]
            public string AuthorIconUrl;
        }
        private class WebHookImage
        {
            [JsonProperty(PropertyName = "proxy_url")]
            public string ProxyUrl;

            [JsonProperty(PropertyName = "url")]
            public string Url;

            [JsonProperty(PropertyName = "height")]
            public int? Height;

            [JsonProperty(PropertyName = "width")]
            public int? Width;
        }
        private class WebHookField
        {
            [JsonProperty(PropertyName = "name")]
            public string Name;

            [JsonProperty(PropertyName = "value")]
            public string Value;

            [JsonProperty(PropertyName = "inline")]
            public bool Inline;
        }
        private class WebHookFooter
        {
            [JsonProperty(PropertyName = "text")]
            public string Text;

            [JsonProperty(PropertyName = "icon_url")]
            public string IconUrl;

            [JsonProperty(PropertyName = "proxy_icon_url")]
            public string ProxyIconUrl;
        }

        #endregion
    }
}

// --- End of file: AdminDeepCover.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-flip-drones ---
// --- Original File Path: A/AutoFlipDrones/AutoFlipDrones.cs ---

ï»¿using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Flip Drones", "WhiteThunder", "1.1.0")]
    [Description("Automatically flips upside-down RC drones when hit with a hammer or taken control of at a computer station.")]
    internal class AutoFlipDrones : CovalencePlugin
    {
        [PluginReference]
        private Plugin DroneScaleManager;

        private const string PermissionUse = "autoflipdrones.use";

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        private void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, Drone drone)
        {
            MaybeFlipDrone(player, drone);
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            var drone = info.HitEntity as Drone;
            if (drone == null)
                return;

            MaybeFlipDrone(player, drone);
        }

        private bool AutoFlipWasBlocked(Drone drone, BasePlayer player)
        {
            object hookResult = Interface.CallHook("OnDroneAutoFlip", drone, player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private BaseEntity GetRootEntity(Drone drone)
        {
            return drone.HasParent()
                ? DroneScaleManager?.Call("API_GetRootEntity", drone) as BaseEntity ?? drone
                : drone;
        }

        private void MaybeFlipDrone(BasePlayer player, Drone drone)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
                return;

            var rootEntity = GetRootEntity(drone);
            var rootTransform = rootEntity.transform;

            if (Vector3.Dot(Vector3.up, rootTransform.up) > 0.1f)
                return;

            if (AutoFlipWasBlocked(drone, player))
                return;

            if (drone != rootEntity)
            {
                // Special handling for resized drones.
                rootTransform.position -= rootTransform.InverseTransformPoint(drone.transform.position) * 2;
            }
            rootTransform.rotation = Quaternion.identity;
        }
    }
}


// --- End of file: AutoFlipDrones.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/ammo-hud ---
// --- Original File Path: A/AmmoHUD/AmmoHUD.cs ---

using System;
using System.Globalization;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

/*1.2.1
 * Added: "Show Throwables" to config which shows hud for throwable weapons (grenades, c4, etc.)
 * Added: "Show Individual Ammo Icons" to config which shows the ammo image instead of a generic icon
 * Added: "Show Text Outline" to config
 */

namespace Oxide.Plugins
{
    [Info("Ammo HUD", "beee", "1.2.1")]
    [Description("Allows players to show an Ammo HUD.")]
    public class AmmoHUD : RustPlugin
    {
        public static AmmoHUD _plugin;
        private static PluginConfig _config;
        
        [PluginReference]
        private Plugin ImageLibrary;

        public PlayersData pData;

        public const string PREFIX_SHORT = "ahud.";
        public const string PREFIX_LONG = "ammohud.";

        public const string PERM_ADMIN = PREFIX_LONG + "admin";
        public const string PERM_USE = PREFIX_LONG + "use";
        
        #region Config

        private class PluginConfig
        {
            public Oxide.Core.VersionNumber Version;

            [JsonProperty("General Settings")]
            public GeneralConfigSettings GeneralSettings { get; set; }

            [JsonProperty("Position Settings")]
            public PositionConfigSettings PositionSettings { get; set; }

            #region GeneralConfigSettings
            internal class GeneralConfigSettings
            {
                [JsonProperty("Show Text Outline")]
                public bool ShowOutline { get; set; }

                [JsonProperty("Show Individual Ammo Icons")]
                public bool ShowAmmoIcons { get; set; }

                [JsonProperty("Show Throwables")]
                public bool ShowThrowables { get; set; }
            }
            #endregion

            #region PositionConfigSettings
            internal class PositionConfigSettings
            {
                [JsonProperty("Default State (true = on, false = off)")]
                public bool DefaultState { get; set; }

                [JsonProperty(
                    "Position (Top, TopLeft, TopRight, Left, Right, Bottom, BottomLeft, BottomRight)"
                )]
                public string Position { get; set; }

                [JsonProperty("Custom Position")]
                public CustomPositionConfigSettings CustomPositionSettings { get; set; }

                #region CustomPositionConfigSettings
                internal class CustomPositionConfigSettings
                {
                    [JsonProperty("Enabled")]
                    public bool Enabled { get; set; }

                    [JsonProperty("Custom Position")]
                    public PositionPreset CustomPosition { get; set; }
                }
                #endregion
            }
            #endregion
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        private PluginConfig GetDefaultConfig()
        {
            PluginConfig result = new PluginConfig
            {
                Version = Version,
                GeneralSettings = new PluginConfig.GeneralConfigSettings()
                {
                    ShowOutline = true,
                    ShowAmmoIcons = false,
                    ShowThrowables = false
                },
                PositionSettings = new PluginConfig.PositionConfigSettings()
                {
                    DefaultState = true,
                    Position = "Right",
                    CustomPositionSettings =
                        new PluginConfig.PositionConfigSettings.CustomPositionConfigSettings()
                        {
                            Enabled = false,
                            CustomPosition = new PositionPreset()
                            {
                                Position = PositionEnum.Right,
                                ParentPosition = new PositionParams()
                                {
                                    Enabled = true,
                                    AnchorMin = "1 0.5",
                                    AnchorMax = "1 0.5",
                                    OffsetMin = "-155 -32",
                                    OffsetMax = "-15 33"
                                },
                                WeaponAmmoFontSize = 36,
                                WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                                WeaponAmmoPosition = new PositionParams()
                                {
                                    Enabled = true,
                                    AnchorMin = "0 0",
                                    AnchorMax = "0.79 0.70",
                                    OffsetMin = "0 0",
                                    OffsetMax = "0 0"
                                },
                                TotalAmmoFontSize = 22,
                                TotalAmmoTextAlignment = TextAnchor.LowerRight,
                                TotalAmmoPosition = new PositionParams()
                                {
                                    Enabled = true,
                                    AnchorMin = "0 0.55",
                                    AnchorMax = "1 1",
                                    OffsetMin = "0 0",
                                    OffsetMax = "0 0"
                                },
                                IconPosition = new PositionParams()
                                {
                                    Enabled = true,
                                    AnchorMin = "1 0.13",
                                    AnchorMax = "1 0.13",
                                    OffsetMin = "-30 0",
                                    OffsetMax = "0 30"
                                }
                            }
                        }
                }
            };

            return result;
        }

        private void CheckForConfigUpdates()
        {
            bool changes = false;

            if (
                _config == null
                || _config.PositionSettings == null
                || _config.PositionSettings.CustomPositionSettings == null
                || _config.PositionSettings.CustomPositionSettings.CustomPosition == null
            )
            {
                PluginConfig tmpDefaultConfig = GetDefaultConfig();
                _config = tmpDefaultConfig;
                changes = true;
            }

            //1.2.1 update
            if (_config.Version == null || _config.Version < new VersionNumber(1, 2, 1))
            {
                PluginConfig tmpDefaultConfig = GetDefaultConfig();
                _config.GeneralSettings = tmpDefaultConfig.GeneralSettings;
                changes = true;
            }

            if(_config.Version != Version)
            {
                changes = true;
            }

            if (changes)
            {
                _config.Version = Version;

                PrintWarning("Config updated");
                SaveConfig();
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            CheckForConfigUpdates();

            LoadColors();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        #endregion

        void OnServerInitialized()
        {
            if(!_config.GeneralSettings.ShowAmmoIcons)
            {
                if (!ImageLibrary)
                {
                    PrintError("The plugin is not installed on the server [ImageLibrary]");
                }
                else
                {
                    ImageLibrary.Call("AddImage", "https://www.dropbox.com/s/6y817vyw3je75ya/DvgPtiW.png?dl=1", "genammo");
                }
            }

            RegisterMessages();
            //permission.RegisterPermission(PERM_ADMIN, this);
            permission.RegisterPermission(PERM_USE, this);
        }

        void Loaded()
        {
            _plugin = this;

            LoadDefaultPresets();
            pData = PlayersData.Load();
        }

        void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer + "." + uisuffix);
            }
            _plugin = null;
            _config = null;
        }

        void RegisterMessages() => lang.RegisterMessages(messages, this);

        #region Data

        private void OnServerSave() => SaveData();

        private bool wiped { get; set; }

        private void OnNewSave(string filename) => wiped = true;

        private void SaveData()
        {
            if (pData != null)
                pData.Save();
        }

        public class PlayersData
        {
            public Dictionary<ulong, PlayerInfo> Players = new Dictionary<ulong, PlayerInfo>();

            public static PlayersData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<PlayersData>(nameof(AmmoHUD));
                if (data == null || _plugin.wiped)
                {
                    _plugin.PrintWarning("No player data found! Creating a new data file");
                    data = new PlayersData();
                    data.Save();
                }
                return data;
            }

            public void Save()
            {
                Interface.Oxide.DataFileSystem.WriteObject(nameof(AmmoHUD), this);
            }

            public bool ToggleHUDActive(ulong playerid)
            {
                PlayerInfo playerInfo;
                if (!Players.TryGetValue(playerid, out playerInfo))
                {
                    Players.Add(
                        playerid,
                        playerInfo = new PlayerInfo() { HUDActive = false, Position = "Default" }
                    );
                }
                else
                {
                    playerInfo.HUDActive = !playerInfo.HUDActive;
                }
                return playerInfo.HUDActive;
            }

            public bool IsActive(ulong playerid)
            {
                PlayerInfo playerInfo;
                if (!Players.TryGetValue(playerid, out playerInfo))
                {
                    return true;
                }
                else
                {
                    return playerInfo.HUDActive;
                }
            }

            public void SetWeaponActive(ulong playerid, bool active)
            {
                PlayerInfo playerInfo;
                if (!Players.TryGetValue(playerid, out playerInfo))
                {
                    Players.Add(
                        playerid,
                        playerInfo = new PlayerInfo()
                        {
                            HUDActive = _config.PositionSettings.DefaultState,
                            WeaponActive = active,
                            Position = "Default"
                        }
                    );
                }
                else
                {
                    playerInfo.WeaponActive = active;
                }
            }

            public bool IsWeaponActive(ulong playerid)
            {
                PlayerInfo playerInfo;
                if (!Players.TryGetValue(playerid, out playerInfo))
                {
                    return false;
                }
                else
                {
                    return playerInfo.WeaponActive;
                }
            }

            public PositionPreset GetPosition(ulong playerid)
            {
                PlayerInfo playerInfo;
                if (Players.TryGetValue(playerid, out playerInfo))
                {
                    var position = _plugin.GetPreset(playerInfo.Position);
                    if (position != null)
                        return position;
                }

                return _plugin.GetConfigPosition();
            }

            public void SetPosition(ulong playerid, string position)
            {
                PlayerInfo playerInfo;
                if (!Players.TryGetValue(playerid, out playerInfo))
                {
                    Players.Add(
                        playerid,
                        playerInfo = new PlayerInfo() { HUDActive = true, Position = position }
                    );
                }
                else
                {
                    playerInfo.Position = position;
                }
            }
        }

        public class PlayerInfo
        {
            public bool HUDActive = true;
            public string Position = "Default";

            [JsonIgnore]
            public bool WeaponActive = false;
        }

        #endregion

        #region Commands

        [ChatCommand("ammohud")]
        void AmmoHUDChatCMD(BasePlayer player, string command, string[] args)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            if (args.Length == 0)
            {
                BroadcastCommands(player);
                return;
            }

            string argument = args[0].ToLower().Trim();

            if (argument == "toggle")
            {
                bool isActive = pData.ToggleHUDActive(player.userID);
                UpdateUI(player, player.GetHeldEntity() as AttackEntity);

                if (isActive)
                    Reply(player, lang.GetMessage("toggle_enabled", this, player.UserIDString));
                else
                    Reply(player, lang.GetMessage("toggle_disabled", this, player.UserIDString));
            }
            else if (argument.ToLower() == "default")
            {
                pData.SetPosition(player.userID, argument);
                UpdateUI(player, player.GetHeldEntity() as AttackEntity);

                Reply(player, string.Format(lang.GetMessage("positionsetto", this, player.UserIDString), "Default"));
            }
            else
            {
                var preset = GetPreset(argument);

                if (preset != null)
                {
                    pData.SetPosition(player.userID, argument);
                    UpdateUI(player, player.GetHeldEntity() as AttackEntity);

                    Reply(player, string.Format(lang.GetMessage("positionsetto", this, player.UserIDString), preset.Position.ToString()));
                }
            }
        }

        public void BroadcastCommands(BasePlayer player)
        {
            string msg = string.Format(lang.GetMessage("commands", this, player.UserIDString), fontColor1);

            SendReply(player, msg);
        }

        #endregion

        #region Hooks

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            if (newItem == null || newItem.info.itemid == 550753330)
            {
                UpdateUI(player, null);
                return;
            }

            bool statechanged = false;
            if (newItem != null && (newItem.GetHeldEntity() is BaseProjectile || (newItem.GetHeldEntity() is ThrownWeapon && _config.GeneralSettings.ShowThrowables)))
            {
                if (!pData.IsWeaponActive(player.userID))
                {
                    statechanged = true;
                    pData.SetWeaponActive(player.userID, true);
                }
            }
            else
            {
                if (pData.IsWeaponActive(player.userID))
                {
                    statechanged = true;
                    pData.SetWeaponActive(player.userID, false);
                }
            }

            if (statechanged || oldItem != newItem)
                UpdateUI(player, newItem.GetHeldEntity() as AttackEntity);
        }

        void OnWeaponFired(
            BaseProjectile projectile,
            BasePlayer player,
            ItemModProjectile mod,
            ProtoBuf.ProjectileShoot projectiles
        )
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            if (projectile != null && !projectile.ShortPrefabName.Contains("snowballgun"))
                UpdateUI(player, projectile, UpdateEnum.WeaponAmmo);
        }

        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            var projectile = player.GetHeldEntity() as BaseProjectile;

            if (projectile != null)
            {
                UpdateUI(player, projectile, UpdateEnum.WeaponAmmo);
            }
        }

        object OnAmmoUnload(BaseProjectile weapon, Item item, BasePlayer player)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return null;

            NextTick(() =>
            {
                if (player == null)
                    return;

                var projectile = player.GetHeldEntity() as BaseProjectile;
                if (projectile != null)
                    UpdateUI(player, projectile, UpdateEnum.AllAmmo);
            });

            return null;
        }

        object OnMagazineReload(BaseProjectile weapon, IAmmoContainer ammoSource, BasePlayer player)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return null;

            NextTick(() =>
            {
                UpdateUI(player, weapon, UpdateEnum.All);
            });

            return null;
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if(container == null || item == null || item.info == null)
                return;
                
            var player = container?.playerOwner as BasePlayer;
            if (player == null || player.UserIDString == null || !permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            var attackEntity = player.GetHeldEntity() as AttackEntity;

            if (attackEntity != null)
            {
                UpdateUI(player, attackEntity, UpdateEnum.AllAmmo);
            }
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item) => OnItemAddedToContainer(container, item);

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (!_config.GeneralSettings.ShowThrowables || player == null || !permission.UserHasPermission(player.UserIDString, PERM_USE) || entity is SupplySignal)
                return;

            NextTick(() =>
            {
                var ThrownWeapon = player.GetHeldEntity() as ThrownWeapon;
                
                if (ThrownWeapon != null)
                {
                    UpdateUI(player, ThrownWeapon, UpdateEnum.WeaponAmmo);
                }
            });
        }

        void OnExplosiveDropped(BasePlayer player, BaseEntity entity) => OnExplosiveThrown(player, entity);

        #endregion

        #region UI

        string defaultAmmoColor,
            redAmmoColor,
            orangeAmmoColor = "";

        string defaultIconColor,
            blueIconColor,
            redIconColor,
            blackIconColor,
            greyIconColor,
            greenIconColor = "";

        public void LoadColors()
        {
            defaultAmmoColor = GetColorFromHex("#ffffff", 80);
            redAmmoColor = GetColorFromHex("#ff3737", 80);
            orangeAmmoColor = GetColorFromHex("#ffa749", 80);

            defaultIconColor = GetColorFromHex("#ba9a51", 50);
            blueIconColor = GetColorFromHex("#3564c3", 50);
            redIconColor = GetColorFromHex("#d43224", 50);
            blackIconColor = GetColorFromHex("#1e1e1e", 50);
            greyIconColor = GetColorFromHex("#a1a1a1", 50);
            greenIconColor = GetColorFromHex("#57a14f", 50);
        }

        private enum UpdateEnum
        {
            All,
            WeaponAmmo,
            AvailableAmmo,
            AllAmmo,
            Icon
        }

        public string Layer = "Under";
        public string uisuffix = "wui";

        private void UpdateUI(
            BasePlayer player,
            AttackEntity item,
            UpdateEnum uiToUpdate = UpdateEnum.All
        )
        {
            if (player == null)
                return;

            if (item == null
                || !pData.IsActive(player.userID)
                || !pData.IsWeaponActive(player.userID)
                || (item is ThrownWeapon && (!_config.GeneralSettings.ShowThrowables || item.ShortPrefabName == "supplysignal.weapon")))
            {
                CuiHelper.DestroyUi(player, Layer + "." + uisuffix);
                return;
            }

            PositionPreset position = pData.GetPosition(player.userID);

            if (!position.ParentPosition.Enabled)
            {
                CuiHelper.DestroyUi(player, Layer + "." + uisuffix);
                return;
            }

            if (uiToUpdate == UpdateEnum.All)
                CuiHelper.DestroyUi(player, Layer + "." + uisuffix);


            ///Calc Amounts

            int currAmmo = 0;
            int availableAmmo = 0;

            ulong skin = 0;
            
            BaseProjectile projectile = item as BaseProjectile;
            ItemDefinition ammoItemDefinition = null;

            if(projectile != null)
            {
                currAmmo = projectile.primaryMagazine.contents;
                availableAmmo = projectile.GetAvailableAmmo();

                ammoItemDefinition = projectile.primaryMagazine.ammoType;
            }
            else
            {
                ThrownWeapon thrownWeapon = item as ThrownWeapon;
                Item cachedItem = item.GetCachedItem();

                if(thrownWeapon == null || cachedItem == null)
                    return;

                currAmmo = cachedItem.amount;
                availableAmmo = player.inventory.GetAmount(cachedItem.info) - currAmmo;

                if(availableAmmo <= 0)
                    availableAmmo = -1;

                skin = cachedItem.skin;

                ammoItemDefinition = cachedItem.info;
            }

            ///

            var cont = new CuiElementContainer();

            bool onlyUpdateText = true;

            if (uiToUpdate == UpdateEnum.All)
            {
                onlyUpdateText = false;

                cont.Add(
                    new CuiPanel
                    {
                        CursorEnabled = false,
                        RectTransform =
                        {
                            AnchorMin = position.ParentPosition.AnchorMin,
                            AnchorMax = position.ParentPosition.AnchorMax,
                            OffsetMin = position.ParentPosition.OffsetMin,
                            OffsetMax = position.ParentPosition.OffsetMax
                        },
                        Image = { Color = "0 0 1 0" }
                    },
                    Layer,
                    Layer + "." + uisuffix
                );
            }

            float outlineOpacity = 0;

            if(_config.GeneralSettings.ShowOutline)
                outlineOpacity = 0.3f;

            if (
                (
                    uiToUpdate == UpdateEnum.All
                    || uiToUpdate == UpdateEnum.AvailableAmmo
                    || uiToUpdate == UpdateEnum.AllAmmo
                ) && position.TotalAmmoPosition.Enabled
            )
            {
                // if (uiToUpdate == UpdateEnum.AvailableAmmo || uiToUpdate == UpdateEnum.AllAmmo)
                //     CuiHelper.DestroyUi(player, "." + uisuffix + "totammo");

                string availableAmmoTxt = "";

                if(availableAmmo >= 0)
                {
                    availableAmmoTxt = string.Format("{0:n0}", availableAmmo);

                    cont.Add(
                        new CuiElement
                        {
                            Parent = Layer + "." + uisuffix,
                            Name = "." + uisuffix + "totammo",
                            Components =
                            {
                                new CuiTextComponent()
                                {
                                    Color = GetColorFromHex("#ffffff", 50),
                                    Text = availableAmmoTxt,
                                    FontSize = position.TotalAmmoFontSize,
                                    Align = position.TotalAmmoTextAlignment,
                                    Font = "robotocondensed-bold.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = position.TotalAmmoPosition.AnchorMin,
                                    AnchorMax = position.TotalAmmoPosition.AnchorMax,
                                    OffsetMin = position.TotalAmmoPosition.OffsetMin,
                                    OffsetMax = position.TotalAmmoPosition.OffsetMax
                                },
                                new CuiOutlineComponent { Color = $"0 0 0 {outlineOpacity}", Distance = "1 -1" }
                            }, 
                            Update = onlyUpdateText
                        }
                    );
                }
            }

            if (
                (
                    uiToUpdate == UpdateEnum.All
                    || uiToUpdate == UpdateEnum.WeaponAmmo
                    || uiToUpdate == UpdateEnum.AllAmmo
                ) && position.WeaponAmmoPosition.Enabled
            )
            {
                // if (uiToUpdate == UpdateEnum.WeaponAmmo || uiToUpdate == UpdateEnum.AllAmmo)
                //     CuiHelper.DestroyUi(player, "." + uisuffix + "currammo");

                string ammoColor = defaultAmmoColor;

                bool dangerzone = false;

                if(projectile != null)
                {
                    int magCapacity = projectile.primaryMagazine.capacity;
                    float ammoRatio = (float)currAmmo / (float)magCapacity;

                    if (ammoRatio < 0.6f)
                        ammoColor = orangeAmmoColor;
                    if (ammoRatio < 0.3f)
                        ammoColor = redAmmoColor;
                }

                cont.Add(
                    new CuiElement
                    {
                        Parent = Layer + "." + uisuffix,
                        Name = "." + uisuffix + "currammo",
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Color = ammoColor,
                                Text = $"{currAmmo}",
                                FontSize = position.WeaponAmmoFontSize,
                                Align = position.WeaponAmmoTextAlignment,
                                Font = "robotocondensed-bold.ttf"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = position.WeaponAmmoPosition.AnchorMin,
                                AnchorMax = position.WeaponAmmoPosition.AnchorMax,
                                OffsetMin = position.WeaponAmmoPosition.OffsetMin,
                                OffsetMax = position.WeaponAmmoPosition.OffsetMax
                            },
                            new CuiOutlineComponent { Color = $"0 0 0 {outlineOpacity}", Distance = "1 -1" }
                        }, 
                        Update = onlyUpdateText
                    }
                );
            }

            if (
                (uiToUpdate == UpdateEnum.All || uiToUpdate == UpdateEnum.Icon)
                && position.IconPosition.Enabled
            )
            {
                if (uiToUpdate == UpdateEnum.Icon)
                    CuiHelper.DestroyUi(player, "." + uisuffix + "icon");

                string iconColor = defaultIconColor;
                
                if(_config.GeneralSettings.ShowAmmoIcons)
                {
                    cont.Add(
                        new CuiPanel
                        {
                            CursorEnabled = false,
                            RectTransform =
                            {
                                AnchorMin = position.IconPosition.AnchorMin,
                                AnchorMax = position.IconPosition.AnchorMax,
                                OffsetMin = position.IconPosition.OffsetMin,
                                OffsetMax = position.IconPosition.OffsetMax
                            },
                            Image = { Color = GetColorFromHex("#ffffff", 20)}
                        },
                        Layer + "." + uisuffix,
                        "." + uisuffix + "icon"
                    );

                    cont.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.1 0.1",
                            AnchorMax = "0.9 0.9"
                        },
                        Image = { ItemId = ammoItemDefinition.itemid, SkinId = skin }
                    },
                    "." + uisuffix + "icon",
                    "." + uisuffix + "iconimage");
                }
                else
                {
                    if (ammoItemDefinition.shortname.Contains(".hv") || ammoItemDefinition.shortname.Contains("shotgun.fire"))
                    {
                        iconColor = blueIconColor;
                    }
                    else if (
                        ammoItemDefinition.shortname.Contains("incen")
                        || ammoItemDefinition.shortname.Contains("fire")
                        || ammoItemDefinition.shortname == "ammo.shotgun"
                        || ammoItemDefinition.shortname.Contains("buckshot")
                    )
                    {
                        iconColor = redIconColor;
                    }
                    else if (ammoItemDefinition.shortname.Contains("explo") || ammoItemDefinition.shortname.Contains("grenadelauncher.he"))
                    {
                        iconColor = blackIconColor;
                    }
                    else if (ammoItemDefinition.shortname.Contains("smoke"))
                    {
                        iconColor = greyIconColor;
                    }
                    else if (ammoItemDefinition.shortname.Contains("slug"))
                    {
                        iconColor = greenIconColor;
                    }

                    cont.Add(
                        new CuiElement
                        {
                            Parent = Layer + "." + uisuffix,
                            Name = "." + uisuffix + "icon",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Color = iconColor,
                                    Png = GetImg("genammo")
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = position.IconPosition.AnchorMin,
                                    AnchorMax = position.IconPosition.AnchorMax,
                                    OffsetMin = position.IconPosition.OffsetMin,
                                    OffsetMax = position.IconPosition.OffsetMax
                                }
                            }
                        }
                    );
                }
            }
            CuiHelper.AddUi(player, cont);
        }

        #endregion

        #region Helpers


        private string GetColorFromHex(string hex, double alpha)
        {
            if (string.IsNullOrEmpty(hex))
                hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6)
                throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100}";
        }

        private string GetImg(string name)
        {
            return (string)ImageLibrary?.Call("GetImage", name) ?? "";
        }

        public void Reply(BasePlayer player, string msg)
        {
            BroadcastToPlayer(player, msg);
        }

        static string fontColor1 = "<color=orange>";
        static string fontColor2 = "<color=white>";

        private void BroadcastToAll(string msg) =>
            PrintToChat(fontColor1 + "[AmmoHUD]" + " </color>" + fontColor2 + msg + "</color>");

        private void BroadcastToPlayer(BasePlayer player, string msg) =>
            SendReply(
                player,
                fontColor1 + "[AmmoHUD]" + " </color>" + fontColor2 + msg + "</color>"
            );

        #endregion

        #region Lang
        Dictionary<string, string> messages = new Dictionary<string, string>() 
        {
            {"commands", "{0}Ammo HUD Available Commands:</color>\n"
                + "/ammohud toggle\t\tToggles on/off\n"
                + "/ammohud [position]\t\tRepositions on screen\n\n"
                + "{0}Available Positions:</color>\nDefault, Top, Bottom, Right, Left,\n"
                + "BottomRight, BottomLeft, TopRight, TopLeft"},
            {"toggle_enabled", "HUD enabled."},
            {"toggle_disabled", "HUD disabled."},
            {"positionsetto", "HUD position set to {0}."}
        };
        #endregion

        #region PositionPresets

        public PositionPreset GetConfigPosition()
        {
            if (_config.PositionSettings.CustomPositionSettings.Enabled)
            {
                return _config.PositionSettings.CustomPositionSettings.CustomPosition;
            }
            else
            {
                return GetPreset(_config.PositionSettings.Position);
            }
        }

        public PositionPreset GetPreset(string position)
        {
            return PositionPresets.Find(s => s.Position.ToString().ToLower() == position.ToLower());
        }

        public void LoadDefaultPresets()
        {
            PositionPresets = new List<PositionPreset>()
            {
                new PositionPreset()
                {
                    Position = PositionEnum.Right,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.5",
                        AnchorMax = "1 0.5",
                        OffsetMin = "-165 -35",
                        OffsetMax = "-15 35"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "0 1",
                        OffsetMax = "-35 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerRight,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.13",
                        AnchorMax = "1 0.13",
                        OffsetMin = "-30 0",
                        OffsetMax = "0 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.BottomRight,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0",
                        AnchorMax = "1 0",
                        OffsetMin = "-355 25",
                        OffsetMax = "-215 90"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "0 1",
                        OffsetMax = "-35 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerRight,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.13",
                        AnchorMax = "1 0.13",
                        OffsetMin = "-30 0",
                        OffsetMax = "0 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.Bottom,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0.5 0",
                        AnchorMax = "0.5 0",
                        OffsetMin = "-120 80",
                        OffsetMax = "20 145"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "0 1",
                        OffsetMax = "-35 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerRight,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.13",
                        AnchorMax = "1 0.13",
                        OffsetMin = "-30 0",
                        OffsetMax = "0 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.BottomLeft,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = "15 60",
                        OffsetMax = "155 125"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerLeft,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "35 0",
                        OffsetMax = "0 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerLeft,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.12",
                        AnchorMax = "0 0.12",
                        OffsetMin = "0 0",
                        OffsetMax = "30 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.Left,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.5",
                        AnchorMax = "0 0.5",
                        OffsetMin = "15 -32",
                        OffsetMax = "155 33"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerLeft,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "35 0",
                        OffsetMax = "0 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerLeft,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.12",
                        AnchorMax = "0 0.12",
                        OffsetMin = "0 0",
                        OffsetMax = "30 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.TopLeft,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = "15 -95",
                        OffsetMax = "155 -30"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerLeft,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "35 0",
                        OffsetMax = "0 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerLeft,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.12",
                        AnchorMax = "0 0.12",
                        OffsetMin = "0 0",
                        OffsetMax = "30 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.Top,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0.5 1",
                        AnchorMax = "0.5 1",
                        OffsetMin = "-110 -95",
                        OffsetMax = "30 -30"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "0 1",
                        OffsetMax = "-35 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerRight,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.13",
                        AnchorMax = "1 0.13",
                        OffsetMin = "-30 0",
                        OffsetMax = "0 30"
                    }
                },
                new PositionPreset()
                {
                    Position = PositionEnum.TopRight,
                    ParentPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = "-155 -95",
                        OffsetMax = "-15 -30"
                    },
                    WeaponAmmoFontSize = 36,
                    WeaponAmmoTextAlignment = TextAnchor.LowerRight,
                    WeaponAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.70",
                        OffsetMin = "0 1",
                        OffsetMax = "-35 0"
                    },
                    TotalAmmoFontSize = 22,
                    TotalAmmoTextAlignment = TextAnchor.LowerRight,
                    TotalAmmoPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "0 0.55",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0"
                    },
                    IconPosition = new PositionParams()
                    {
                        Enabled = true,
                        AnchorMin = "1 0.13",
                        AnchorMax = "1 0.13",
                        OffsetMin = "-30 0",
                        OffsetMax = "0 30"
                    }
                }
            };
        }

        public List<PositionPreset> PositionPresets;

        public class PositionPreset
        {
            [JsonIgnore]
            public PositionEnum Position { get; set; }
            public PositionParams ParentPosition { get; set; }
            public PositionParams WeaponAmmoPosition { get; set; }
            public int WeaponAmmoFontSize { get; set; }
            public TextAnchor WeaponAmmoTextAlignment { get; set; }
            public PositionParams TotalAmmoPosition { get; set; }
            public int TotalAmmoFontSize { get; set; }
            public TextAnchor TotalAmmoTextAlignment { get; set; }
            public PositionParams IconPosition { get; set; }
        }

        public class PositionParams
        {
            public bool Enabled { get; set; }
            public string AnchorMin { get; set; }
            public string AnchorMax { get; set; }
            public string OffsetMin { get; set; }
            public string OffsetMax { get; set; }
        }

        public enum PositionEnum
        {
            Top,
            TopLeft,
            TopRight,
            Left,
            Right,
            Bottom,
            BottomLeft,
            BottomRight
        }

        #endregion
    }
}


// --- End of file: AmmoHUD.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/advance-gather ---
// --- Original File Path: A/AdvancedGather/AdvancedGather.cs ---

ï»¿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Random = UnityEngine.Random;
using Oxide.Plugins.AdvancedGatherEx;
using UnityEngine;
using System;
using Oxide.Core.Plugins;

/*
 * This is a full re-write 2.0.2
 * More features in the works/pending.
 * Added direct inventory drop toggle request.
 * Added random item drops list for trees.
 * Added simple value updater method.
 *
 * This update 2.0.3
 * Added clone support
 * fixed a few default values not being generated.
 *
 * This update 2.0.4
 * Added PopupNotifications support for tree drops
 * Added Chat message support for tree drops
 */

namespace Oxide.Plugins
{
    [Info("AdvancedGather", "Khan", "2.0.4")]
    [Description("Custom gathering with some action's and extension drop")]
    public class AdvancedGather : CovalencePlugin
    {
        #region Refrences
        
        [PluginReference] 
        private Plugin PopupNotifications;

        #endregion
        
        #region Fields
        
        private const string UsePerm = "advancedgather.use";
        private PluginConfig _config;
        private IPlayer _player;

        #endregion

        #region Config
        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new Exception();
                }
                
                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }
        }
        
        protected override void SaveConfig() => Config.WriteObject(_config, true);
        
        private class PluginConfig
        {
            #region 
            
            [JsonProperty("ChatPrefix")]
            public string ChatPrefix = "<color=#32CD32>AdvancedGather</color>: ";
            
            [JsonProperty(PropertyName = "Drop Sound Effect")]
            public string DropSoundEffect;

            [JsonProperty(PropertyName = "Enable Berry Drops from Hemp")]
            public bool EnableBerries;
            
            [JsonProperty(PropertyName = "Enable Random Tree drop Items?")]
            public bool RandomItems;
            
            [JsonProperty(PropertyName = "Switch to direct inventory Drops?")]
            public bool DirectInventory;
            
            [JsonProperty(PropertyName = "List of all chance modifiers")]
            public ChanceModifier ChanceModifiers;

            [JsonProperty(PropertyName = "Random Item drops from Trees")]
            public List<RandomConfig> RandomConfigs;
            
            [JsonProperty(PropertyName = "Get apples from Trees")]
            public AppleConfig AppleConfigs;

            [JsonProperty(PropertyName = "Berry types from Hemp")]
            public List<BerryConfig> BerryConfigs;
            
            [JsonProperty(PropertyName = "Biofuel options")]
            public BioFuelConfig BioFuelConfigs;

            [JsonProperty(PropertyName = "Set times for optimal farming")]
            public List<TimeConfig> TimeConfigs;
            
            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());

            #endregion
            public BerryConfig GetRandomBerry()
            {
                List<BerryConfig> berries = new List<BerryConfig>();

                foreach (BerryConfig berryConfig in BerryConfigs)
                {
                    if (Random.Range(1, 100) <= berryConfig.Rarity)
                        berries.Add(berryConfig);
                }

                return berries.Count > 0 ? berries[0] : BerryConfigs.GetRandom();
            }
            
            public RandomConfig GetRandomTreeItem()
            {
                List<RandomConfig> items = new List<RandomConfig>();

                foreach (RandomConfig randomConfig in RandomConfigs)
                {
                    if (Random.Range(1, 100) <= randomConfig.Rarity)
                        items.Add(randomConfig);
                }

                return items.Count > 0 ? items[0] : RandomConfigs.GetRandom();
            }

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    DropSoundEffect = "assets/bundled/prefabs/fx/notice/loot.drag.itemdrop.fx.prefab",
                    EnableBerries = true,
                    RandomItems = false,
                    DirectInventory = false,

                    ChanceModifiers = new ChanceModifier
                    {
                        EnableDefaultDropChance = true,
                        DefaultDropChance = 70,
                        TimeModifier = false,
                        ToolModifier = false,
                        ToolModifierBonus = 10,
                        ToolItem1 = "jackhammer",
                        ToolItem2 = "axe.salvaged",
                        ToolItem3 = "rock",
                        AttireModifier = false,
                        AttireModifierBonus = 10,
                        AttireBonousID = -23994173,
                        ItemModifier = false,
                        ItemModifierBonus = 10,
                        ItemBonusID = -1651220691,
                    },
                    RandomConfigs = new List<RandomConfig>
                    {
                        new RandomConfig
                        {
                            DisplayName = "Horse Poop",
                            Shortname = "horsedung",
                            SkinID = 0,
                            RandomAmountMin = 1,
                            RandomAmountMax = 3,
                            Rarity = 50
                        },
                        new RandomConfig
                        {
                            DisplayName = "Poop Rock",
                            Shortname = "rock",
                            SkinID = 2039847176,
                            RandomAmountMin = 1,
                            RandomAmountMax = 3,
                            Rarity = 50
                        },
                    },
                    AppleConfigs = new AppleConfig
                    {
                        Enable = true,
                        GoodApple = 30,
                        BadApple = 20,
                        MinAmount = 1,
                        MaxAmount = 3
                    },
                    BerryConfigs = new List<BerryConfig>
                    {
                        new BerryConfig
                        {
                            DisplayName = "Red Berry",
                            Shortname = "red.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 15
                        },
                        new BerryConfig
                        {
                            DisplayName = "Blue Berry",
                            Shortname = "blue.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 15
                        },
                        new BerryConfig
                        {
                            DisplayName = "Green Berry",
                            Shortname = "green.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 14
                        },
                        new BerryConfig
                        {
                            DisplayName = "Yellow Berry",
                            Shortname = "yellow.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 14
                        },
                        new BerryConfig
                        {
                            DisplayName = "White Berry",
                            Shortname = "white.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 14
                        },
                        new BerryConfig
                        {
                            DisplayName = "Black Berry",
                            Shortname = "black.berry",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 14
                        },
                        new BerryConfig
                        {
                            DisplayName = "Black Raspberries",
                            Shortname = "black.raspberries",
                            SkinID = 0,
                            BerryAmountMin = 1,
                            BerryAmountMax = 3,
                            Rarity = 14
                        },
                        
                    },
                    BioFuelConfigs = new BioFuelConfig
                    {
                        EnableBioFuel = true,
                        DisplayName = "Biofuel",
                        Shortname = "lowgradefuel",
                        SkinID = 2501207890,
                        Pumpkins = new Pumpkin
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 5,
                            Rarity = 20
                        },
                        PumpkinClones = new PumpkinClone
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 3,
                            Rarity = 20
                        },
                        Potatos = new Potato
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 8,
                            Rarity = 20
                        },
                        PotatoClones = new PotatoClone
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 5,
                            Rarity = 20
                        },
                        Corns = new Corn
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 10,
                            Rarity = 10
                        },
                        CornClones = new CornClone
                        {
                            BioFuelMinAmount = 1,
                            BioFuelMaxAmount = 8,
                            Rarity = 10
                        },
                    },
                    TimeConfigs = new List<TimeConfig>
                    {
                        new TimeConfig
                        {
                            After = 0f,
                            Before = 4f,
                            DropChanceBonous = 3,
                        },
                        new TimeConfig
                        {
                            After = 8f,
                            Before = 12f,
                            DropChanceBonous = 5,
                        },
                        new TimeConfig
                        {
                            After = 16f,
                            Before = 20f,
                            DropChanceBonous = 7,
                        },
                        new TimeConfig
                        {
                            After = 20f,
                            Before = 24f,
                            DropChanceBonous = 10,
                        },
                    }
                };
            }
        }
        private class ChanceModifier
        {
            [JsonProperty(PropertyName = "Enable Global Default Drop Chance?")]
            public bool EnableDefaultDropChance;
            
            [JsonProperty(PropertyName = "Global Default Drop Chance Value")]
            public int DefaultDropChance;
            
            [JsonProperty(PropertyName = "Enable Time Modifier feature?")]
            public bool TimeModifier;
            
            [JsonProperty(PropertyName = "Enable Tool Modifier feature?")]
            public bool ToolModifier;
            
            [JsonProperty(PropertyName = "Tool Modifier bonous chance")]
            public int ToolModifierBonus;
            
            [JsonProperty(PropertyName = "Tool Item 1 shortname")]
            public string ToolItem1;
            
            [JsonProperty(PropertyName = "Tool Item 2 shortname")]
            public string ToolItem2;
            
            [JsonProperty(PropertyName = "Tool Item 3 shortname")]
            public string ToolItem3;
            
            [JsonProperty(PropertyName = "Enable Attire Modifier feature?")]
            public bool AttireModifier;
            
            [JsonProperty(PropertyName = "Attire Modifier bonous chance")]
            public int AttireModifierBonus;
            
            [JsonProperty(PropertyName = "Attire Modifier Item ID")]
            public int AttireBonousID;
            
            [JsonProperty(PropertyName = "Enable Item Modifier feature?")]
            public bool ItemModifier;
            
            [JsonProperty(PropertyName = "Item Modifier bonous chance")]
            public int ItemModifierBonus;
            
            [JsonProperty(PropertyName = "Item Modifier Item ID")]
            public int ItemBonusID;
        }
        private class RandomConfig
        {
            [JsonProperty(PropertyName = "Set Custom DisplayName")]
            public string DisplayName;
            
            public string Shortname;
            
            [JsonProperty(PropertyName = "Set Custom Skin Id")]
            public ulong SkinID;
            
            [JsonProperty(PropertyName = "Minimum amount of random items to drop")]
            public int RandomAmountMin;
            
            [JsonProperty(PropertyName = "Max amount of random items to drop")]
            public int RandomAmountMax;
            
            public float Rarity;

            public bool GiveItem(BasePlayer player, int amount)
            {
                Item item = ItemManager.CreateByName(Shortname, amount, SkinID);
                item.name = DisplayName;
                item.skin = SkinID;
                item.MarkDirty();

                return player.inventory.GiveItem(item);
            }
        }
        private class AppleConfig
        {
            [JsonProperty(PropertyName = "Enable Apple Drops?")]
            public bool Enable;
            
            [JsonProperty(PropertyName = "Enable Messages for Tree Drops?")]
            public bool AppleMsg;
            
            [JsonProperty(PropertyName = "Use Popup Message for Apple Drops?")]
            public bool UsePopup;
            
            [JsonProperty(PropertyName = "Chance to drop any apples per hit")]
            public int GoodApple;
            
            [JsonProperty(PropertyName = "Chance it drops rotten apples")]
            public int BadApple;

            [JsonProperty(PropertyName = "Minimum amount of Apples")]
            public int MinAmount;
            
            [JsonProperty(PropertyName = "Max amount of Apples")]
            public int MaxAmount;
        }
        private class BerryConfig
        {
            [JsonProperty(PropertyName = "Set Custom DisplayName")]
            public string DisplayName;
            
            public string Shortname;
            
            [JsonProperty(PropertyName = "Set Custom Skin Id")]
            public ulong SkinID;
            
            [JsonProperty(PropertyName = "Minimum amount of Berries to drop")]
            public int BerryAmountMin;
            
            [JsonProperty(PropertyName = "Max amount of Berries to drop")]
            public int BerryAmountMax;
            
            public float Rarity;

            public bool GiveItem(BasePlayer player, int amount)
            {
                Item item = ItemManager.CreateByName(Shortname, amount, SkinID);
                item.name = DisplayName;
                item.skin = SkinID;
                item.MarkDirty();

                return player.inventory.GiveItem(item);
            }
        }
        public class BioFuelConfig
        {
            [JsonProperty(PropertyName = "Enable Biofuel")]
            public bool EnableBioFuel;
            
            [JsonProperty(PropertyName = "Biofuel Custom Name")]
            public string DisplayName;
            
            [JsonProperty(PropertyName = "Biofuel shortname")]
            public string Shortname;
            
            [JsonProperty(PropertyName = "Set Custom Skin Id")]
            public ulong SkinID;
            public Pumpkin Pumpkins { get; set; }
            
            public PumpkinClone PumpkinClones { get; set; }
            public Potato Potatos { get; set; }
            
            public PotatoClone PotatoClones { get; set; }
            public Corn Corns { get; set; }
            
            public CornClone CornClones { get; set; }

            public bool GiveItem(BasePlayer player, int amount)
            {
                Item item = ItemManager.CreateByName(Shortname, amount, SkinID);
                item.skin = SkinID;
                item.name = DisplayName;
                item.MarkDirty();

                return player.inventory.GiveItem(item);
            }
        }
        public class Pumpkin
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        public class PumpkinClone
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        public class Potato
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        public class PotatoClone
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        public class Corn
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        public class CornClone
        {
            [JsonProperty(PropertyName = "Minimum amount of biofuel to drop")]
            public int BioFuelMinAmount;
            
            [JsonProperty(PropertyName = "Max amount of biofuel to drop")]
            public int BioFuelMaxAmount;
            
            [JsonProperty(PropertyName = "Sets the chance of it dropping")]
            public float Rarity;
        }
        private class TimeConfig
        {
            public float After;
            public float Before;
            public int DropChanceBonous;
        }

        #endregion

        #region Oxide

        private void OnServerInitialized()
        {
            permission.RegisterPermission(UsePerm, this);
        }

        //Get apple from Tree and nodes such as mining rocks
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if(player == null || dispenser == null || entity == null || item == null || !_config.AppleConfigs.Enable) return;
            if (!permission.UserHasPermission(player.UserIDString, UsePerm) || !(dispenser.GetComponent<BaseEntity>() is TreeEntity)) return;

            if (_config.DirectInventory)
            {
                player.inventory.GiveItem(AppleChanceRoll(player));
                player.RunEffect(_config.DropSoundEffect);
                return;
            }
            
            AppleChanceRoll(player)?.DropAndTossUpwards(entity.GetDropPosition());

            player.RunEffect(_config.DropSoundEffect);
        }

	    //Natural plants & random stumps 
        private void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (player == null || item == null || !permission.UserHasPermission(player.UserIDString, UsePerm)) return;
            
            //Get berry from hemp
            if (_config.EnableBerries && item.info.shortname.Contains("cloth"))
            {
                BerryDropChanceRoll(player);
            }

            //Get Lowgrade from planted corn
            if (item.info.shortname.Contains("corn") && !item.info.shortname.Contains("seed.corn"))
            {
                BioFuelDropChanceRoll(player, "corn");
            }
            
            if (item.info.shortname.Contains("clone.corn") && !item.info.shortname.Contains("seed.corn"))
            {
                BioFuelDropChanceRoll(player, "clone.corn");
            }
            
            //Get lowgrade from planted potato's
            if (item.info.shortname.Contains("potato") && !item.info.shortname.Contains("seed.potato"))
            {
                BioFuelDropChanceRoll(player, "potato");
            }
            
            if (item.info.shortname.Contains("clone.potato") && !item.info.shortname.Contains("seed.potato"))
            {
                BioFuelDropChanceRoll(player, "clone.potato");
            }

            //Get Lowgrade from planted pumpkin
            if (item.info.shortname.Contains("pumpkin") && !item.info.shortname.Contains("seed.pumpkin"))
            {
                BioFuelDropChanceRoll(player, "pumpkin");
            }
            
            if (item.info.shortname.Contains("clone.pumpkin") && !item.info.shortname.Contains("seed.pumpkin"))
            {
                BioFuelDropChanceRoll(player, "clone.pumpkin");
            }
        }

	    //Planted plants & cloned plants done.
        private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
        {
            if (player == null || growable == null || item == null || !permission.UserHasPermission(player.UserIDString, UsePerm)) return;
            
            //Get berry from planted hemp
            if (_config.EnableBerries && item.info.shortname.Contains("cloth"))
            {
                BerryDropChanceRoll(player);
            }

            //Get Lowgrade from planted corn
            if (item.info.shortname.Contains("corn") && !item.info.shortname.Contains("seed.corn"))
            {
                BioFuelDropChanceRoll(player, "corn");
            }
            
            if (item.info.shortname.Contains("clone.corn") && !item.info.shortname.Contains("seed.corn"))
            {
                BioFuelDropChanceRoll(player, "clone.corn");
            }
            
            //Get lowgrade from planted potato's
            if (item.info.shortname.Contains("potato") && !item.info.shortname.Contains("seed.potato"))
            {
                BioFuelDropChanceRoll(player, "potato");
            }
            
            if (item.info.shortname.Contains("clone.potato") && !item.info.shortname.Contains("seed.potato"))
            {
                BioFuelDropChanceRoll(player, "clone.potato");
            }

            //Get Lowgrade from planted pumpkin
            if (item.info.shortname.Contains("pumpkin") && !item.info.shortname.Contains("seed.pumpkin"))
            {
                BioFuelDropChanceRoll(player, "pumpkin");
            }
            
            if (item.info.shortname.Contains("clone.pumpkin") && !item.info.shortname.Contains("seed.pumpkin"))
            {
                BioFuelDropChanceRoll(player, "clone.pumpkin");
            }
        }

        #endregion
        
        #region Drop Process
        
        private bool RollRandomItemChance()
        {
            var roll = Random.Range(1, 6);
            return roll == 1;
        }
        private bool RollBadOrGood()
        {
            var roll = Random.Range(1, 6);
            return roll == 1;
        }
        public Item AppleChanceRoll(BasePlayer player)
        {
            int totalchance = DropModifier(player);
            if (totalchance > 100)
            {
                PrintError("Total Apple Roll chance cannot exceed 100");
                return null;
            }

            int roll = Random.Range(1, 100);
            
            int amount = Core.Random.Range(_config.AppleConfigs.MinAmount, _config.AppleConfigs.MaxAmount + 1);

            if (roll <= totalchance)
            {
                if (_config.AppleConfigs.Enable && RollBadOrGood())
                {
                    if (_config.AppleConfigs.AppleMsg)
                    {
                        PopupMessageArgs(player, "AppleDrops", "Rotten Apple");
                    }
                    // Bad
                    player.Command("note.inv",352130972, amount.ToString());
                    return ItemManager.CreateByName("apple.spoiled", amount);
                }
                // good
                if (_config.AppleConfigs.AppleMsg)
                {
                    PopupMessageArgs(player, "AppleDrops", "Tasty Apple");
                }
                player.Command("note.inv",1548091822, amount.ToString());
                return ItemManager.CreateByName("apple", amount);
            }
            
            if (_config.RandomItems && RollRandomItemChance())
            {
                // Chance of getting random item 
                RandomItemRoll(player);
            }

            return null;
            // nothing
        }
        private void RandomItemRoll(BasePlayer player)
        {
            RandomConfig randomConfig = _config.GetRandomTreeItem();

            int amount = Core.Random.Range(randomConfig.RandomAmountMin, randomConfig.RandomAmountMax + 1);
            randomConfig.GiveItem(player, amount);
            if (_config.AppleConfigs.AppleMsg)
            {
                PopupMessageArgs(player, "AppleDrops", randomConfig.DisplayName);
            }
            player.Command("note.inv", randomConfig.Shortname, amount.ToString(), randomConfig.DisplayName);
        }
        public void BioFuelDropChanceRoll(BasePlayer player, string shortname)
        {
            int totalchance = DropModifier(player);
            if (totalchance > 100)
            {
                return;
            }

            int roll = Random.Range(1, 100);

            if (shortname == "corn")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.Corns.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.Corns.BioFuelMinAmount, _config.BioFuelConfigs.Corns.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName);
                }
            }
            
            if (shortname == "clone.corn")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.CornClones.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.CornClones.BioFuelMinAmount, _config.BioFuelConfigs.CornClones.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName);
                }
            }
            
            if (shortname == "potato")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.Potatos.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.Potatos.BioFuelMinAmount, _config.BioFuelConfigs.Potatos.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName);
                }
            }
            
            if (shortname == "clone.potato")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.PotatoClones.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.PotatoClones.BioFuelMinAmount, _config.BioFuelConfigs.PotatoClones.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName); 
                }
            }
            
            if (shortname == "pumpkin")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.Pumpkins.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.Pumpkins.BioFuelMinAmount, _config.BioFuelConfigs.Pumpkins.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName);
                }
            }
            
            if (shortname == "clone.pumpkin")
            {
                if (roll <= totalchance + _config.BioFuelConfigs.PumpkinClones.Rarity)
                {
                    int amount = Core.Random.Range(_config.BioFuelConfigs.PumpkinClones.BioFuelMinAmount, _config.BioFuelConfigs.PumpkinClones.BioFuelMaxAmount + 1);
                    _config.BioFuelConfigs.GiveItem(player, amount);
                    //player.RunEffect(_config.DropSoundEffect);
                    player.Command("note.inv",-946369541, amount.ToString(), _config.BioFuelConfigs.DisplayName);
                }
            }

            // Received nothing 
        }
        public void BerryDropChanceRoll(BasePlayer player)
        {
            int totalchance = DropModifier(player);
            if (totalchance > 100)
            {
                //PopupMessageArgs(player, "Warning");
                return;
            }

            int roll = Random.Range(1, 100);

            if (roll <= totalchance)
            {
                BerryTypeRoll(player);
            }

            // Received nothing 
        }
        private void BerryTypeRoll(BasePlayer player)
        {
            BerryConfig berryConfig = _config.GetRandomBerry();

            int amount = Core.Random.Range(berryConfig.BerryAmountMin, berryConfig.BerryAmountMax + 1);
            berryConfig.GiveItem(player, amount);
            //player.RunEffect(_config.DropSoundEffect);
            player.Command("note.inv", berryConfig.Shortname, amount.ToString(), berryConfig.DisplayName);
        }
        private int DropModifier(BasePlayer player)
        {
            int chances = new int();
            if (_config.ChanceModifiers.ToolModifier)
            {
                Item activeItem = player.GetActiveItem();
                if (activeItem != null)
                {
                    if (activeItem.info.shortname == _config.ChanceModifiers.ToolItem1 || activeItem.info.shortname == _config.ChanceModifiers.ToolItem2 || activeItem.info.shortname == _config.ChanceModifiers.ToolItem3)
                    {
                        chances += _config.ChanceModifiers.ToolModifierBonus;
                    }
                }
            }

            if (_config.ChanceModifiers.AttireModifier)
            {
                int hasBoonieOn = player.inventory.containerWear.GetAmount(_config.ChanceModifiers.AttireBonousID, true);
                if (hasBoonieOn > 0) chances += _config.ChanceModifiers.AttireModifierBonus;
            }

            if (_config.ChanceModifiers.ItemModifier)
            {
                int hasPookie = player.inventory.containerMain.GetAmount(_config.ChanceModifiers.ItemBonusID, true);
                if (hasPookie > 0) chances += _config.ChanceModifiers.ItemModifierBonus;
            }

            if (_config.ChanceModifiers.TimeModifier)
            {
                var currenttime = TOD_Sky.Instance.Cycle.Hour;
                TimeConfig timeConfig = _config.TimeConfigs.FirstOrDefault(x => currenttime < x.Before && currenttime > x.After);

                if (timeConfig != null)
                {
                    chances += timeConfig.DropChanceBonous;
                }
            }

            int ddc = 0;
            if (_config.ChanceModifiers.EnableDefaultDropChance)
            {
                ddc = _config.ChanceModifiers.DefaultDropChance;
            }

            int totalchance = chances + ddc;
            return totalchance;
        }

        #endregion

        #region Lang System
        public void PopupMessageArgs(BasePlayer player, string key, params object[] args)
        {
            if (_config.AppleConfigs.UsePopup)
            {
                PopupNotifications?.Call("CreatePopupNotification", _config.ChatPrefix + Lang(key, player.UserIDString, args), player);
            }
            else
            {
                player.ChatMessage(_config.ChatPrefix + Lang(key, player.UserIDString, args));
            }
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AppleDrops"] = "A {0} has fallen from the tree",
            }, this);
        }
        
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
    #region Extension Methods

    namespace AdvancedGatherEx
    {
        public static class PlayerEx
        {
            public static void RunEffect(this BasePlayer player, string prefab)
            {
                Effect effect = new Effect();
                effect.Init(Effect.Type.Generic, player.ServerPosition, Vector3.zero);
                effect.pooledString = prefab;
                EffectNetwork.Send(effect, player.Connection);
            }
        }
    }    

    #endregion
}

// --- End of file: AdvancedGather.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/auto-code ---
// --- Original File Path: A/AutoCode/AutoCode.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Libraries;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
  [Info("Auto Code", "BlueBeka", "1.6.0")]
  [Description("Automatically sets the code on code locks when placed.")]
  public class AutoCode : RustPlugin
  {
    [PluginReference("NoEscape")]
    private Plugin pluginNoEscape;

    private AutoCodeConfig config;
    private Commands commands;
    private Data data;
    private Dictionary<BasePlayer, TempCodeLockInfo> tempCodeLocks;

    private const string HiddenCode = "****";

    #region Hooks

    private void Init()
    {
      config = new AutoCodeConfig(this);
      data = new Data(this);
      commands = new Commands(this);
      tempCodeLocks = new Dictionary<BasePlayer, TempCodeLockInfo>();

      config.Load();
      data.Load();
      Permissions.Register(this);
      commands.Register();
    }

    protected override void LoadDefaultConfig()
    {
      Interface.Oxide.LogInfo("New configuration file created.");
    }

    private void OnServerSave()
    {
      data.Save();
    }

    private void Unload()
    {
      RemoveAllTempCodeLocks();
      data.Save();
    }

    private object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
    {
      // Not one of our temporary code locks?
      if (player == null || !tempCodeLocks.ContainsKey(player) || tempCodeLocks[player].CodeLock != codeLock)
      {
        UnsubscribeFromUnneededHooks();
        return null;
      }

      // Destroy the temporary code lock as soon as it's ok to do so.
      timer.In(0, () =>
      {
        DestroyTempCodeLock(player);
      });

      SetCode(player, code, tempCodeLocks[player].Guest);
      Effect.server.Run(codeLock.effectCodeChanged.resourcePath, player.transform.position);
      return false;
    }

    private void OnItemDeployed(Deployer deployer, BaseEntity lockable, CodeLock codeLock)
    {
      // Code already set?
      if (codeLock.hasCode && codeLock.hasGuestCode)
      {
        return;
      }

      BasePlayer player = BasePlayer.FindByID(codeLock.OwnerID);

      // No player or the player doesn't have permission?
      if (player == null || !permission.UserHasPermission(player.UserIDString, Permissions.Use))
      {
        return;
      }

      // No data for player.
      if (!data.Inst.playerSettings.ContainsKey(player.userID))
      {
        return;
      }

      // NoEscape blocked.
      if (pluginNoEscape != null)
      {
        if (
          config.Options.PluginIntegration.NoEscape.BlockRaid &&
          pluginNoEscape.Call<bool>("HasPerm", player.UserIDString, "raid.buildblock") &&
          pluginNoEscape.Call<bool>("IsRaidBlocked", player.UserIDString)
        )
        {
          Message(player, lang.GetMessage("NoEscape.RaidBlocked", this, player.UserIDString));
          return;
        }

        if (
          config.Options.PluginIntegration.NoEscape.BlockCombat &&
          pluginNoEscape.Call<bool>("HasPerm", player.UserIDString, "combat.buildblock") &&
          pluginNoEscape.Call<bool>("IsCombatBlocked", player.UserIDString)
        )
        {
          Message(player, lang.GetMessage("NoEscape.CombatBlocked", this, player.UserIDString));
          return;
        }
      }

      Data.Structure.PlayerSettings settings = data.Inst.playerSettings[player.userID];

      // Player doesn't have a code?
      if (settings == null || settings.code == null)
      {
        return;
      }

      // Set the main code.
      codeLock.code = settings.code;
      codeLock.hasCode = true;
      codeLock.whitelistPlayers.Add(player.userID);

      // Set the guest code.
      if (settings.guestCode != null)
      {
        codeLock.guestCode = settings.guestCode;
        codeLock.hasGuestCode = true;
        codeLock.guestPlayers.Add(player.userID);
      }

      // Lock the lock.
      codeLock.SetFlag(BaseEntity.Flags.Locked, true);

      if (!settings.quietMode)
      {
        Message(
          player,
          string.Format(
            lang.GetMessage(
              codeLock.hasGuestCode ? "CodeAutoLockedWithGuest" : "CodeAutoLocked",
              this,
              player.UserIDString),
            Formatter.Value(Utils.ShouldHideCode(player, settings) ? HiddenCode : codeLock.code),
            Formatter.Value(Utils.ShouldHideCode(player, settings) ? HiddenCode : codeLock.guestCode)
          )
        );
      }
    }

    private object CanUseLockedEntity(BasePlayer player, CodeLock codeLock)
    {
      // Is a player that has permission and lock is locked?
      if (
        player != null &&
        codeLock.hasCode &&
        codeLock.HasFlag(BaseEntity.Flags.Locked) &&
        permission.UserHasPermission(player.UserIDString, Permissions.Use) &&
        permission.UserHasPermission(player.UserIDString, Permissions.Try) &&
        data.Inst.playerSettings.ContainsKey(player.userID)
      )
      {
        Data.Structure.PlayerSettings settings = data.Inst.playerSettings[player.userID];

        // Player has the code?
        if (settings != null && codeLock.code == settings.code)
        {
          // Auth the player.
          codeLock.whitelistPlayers.Add(player.userID);
        }
      }

      // Use default behavior.
      return null;
    }

    protected override void LoadDefaultMessages()
    {
      lang.RegisterMessages(new Dictionary<string, string>
      {
        { "Help", "Usage:\n{0}" },
        { "Description", "Automatically set the code on code locks you place." },
        { "Info", "Code: {0}\nGuest Code: {1}\nQuiet Mode: {2}" },
        { "NoPermission", "You don't have permission." },
        { "CodeAutoLocked", "Code lock placed with code {0}." },
        { "CodeAutoLockedWithGuest", "Code lock placed with code {0} and guest code {1}." },
        { "CodeUpdated", "Your auto-code has changed to {0}." },
        { "CodeUpdatedHidden", "New auto-code set." },
        { "GuestCodeUpdated", "Your guest auto-code has changed to {0}." },
        { "GuestCodeUpdatedHidden", "New guest auto-code set." },
        { "CodeRemoved", "Your auto-code has been removed." },
        { "GuestCodeRemoved", "Your guest auto-code has been removed." },
        { "InvalidArgsTooMany", "Too many arguments supplied." },
        { "NotSet", "Not set" },
        { "SyntaxError", "Syntax Error: expected command in the form:\n{0}" },
        { "SpamPrevention", "Too many recent auto-code sets. Please wait {0} and try again." },
        { "InvalidArguments", "Invalid arguments supplied." },
        { "ErrorNoPlayerFound", "Error: No player found." },
        { "ErrorMoreThanOnePlayerFound", "Error: More than one player found." },
        { "ResettingAllLockOuts", "Resetting lock outs for all players." },
        { "ResettingLockOut", "Resetting lock outs for {0}." },
        { "QuietModeEnable", "Quiet mode now enabled." },
        { "QuietModeDisable", "Quiet mode now disabled." },
        { "Enabled", "Enabled" },
        { "Disabled", "Disabled" },
        { "HelpExtendedCoreCommands", "Core Commands:" },
        { "HelpExtendedOtherCommands", "Other Commands:" },
        { "HelpExtendedInfo", "Show your settings:\n{0}" },
        { "HelpExtendedSetCode", "Set your auto-code to 1234:\n{0}" },
        { "HelpExtendedRandomCode", "Set your auto-code to a randomly generated code:\n{0}" },
        { "HelpExtendedRemoveCode", "Remove your set auto-code:\n{0}" },
        { "HelpExtendedCoreGuestCommands", "Each core command is also available in a guest code version. e.g.\n{0}" },
        { "HelpExtendedQuietMode", "Toggles on/off quiet mode:\n{0}" },
        { "HelpExtendedQuietModeDetails", "Less messages will be shown and your auto-code will be hidden." },
        { "HelpExtendedHelp", "Displays this help message:\n{0}" },
        { "NoLongerSupportedPick", "\"{0}\" is no longer supported, please use \"{1}\" instead." },
        { "NoEscape.RaidBlocked", "Auto-code disabled due to raid block." },
        { "NoEscape.CombatBlocked", "Auto-code disabled due to combat block." },
      }, this);
    }

    #endregion Hooks

    #region API

    [ObsoleteAttribute("This method is deprecated. Call GetCode instead.", false)]
    public string GetPlayerCode(BasePlayer player) => GetCode(player);

    /// <summary>
    /// Get the code for the given player.
    /// </summary>
    /// <param name="player">The player to get the code for.</param>
    /// <param name="guest">If true, the guest code will be returned instead of the main code.</param>
    /// <returns>A string of the player's code or null if the player doesn't have a code.</returns>
    public string GetCode(BasePlayer player, bool guest = false)
    {
      if (data.Inst.playerSettings.ContainsKey(player.userID))
      {
        return guest
          ? data.Inst.playerSettings[player.userID].guestCode
          : data.Inst.playerSettings[player.userID].code;
      }

      return null;
    }

    /// <summary>
    /// Set the code for the given player.
    /// </summary>
    /// <param name="player">The player to set the code for.</param>
    /// <param name="code">The code to set for the given player.</param>
    /// <param name="guest">If true, the guest code will be set instead of the main code.</param>
    /// <param name="quiet">If true, no output message will be shown to the player.</param>
    /// <param name="hideCode">If true, the new code won't be displayed to the user. Has no effect if quiet is true.</param>
    public void SetCode(BasePlayer player, string code, bool guest = false, bool quiet = false, bool hideCode = false)
    {
      if (!data.Inst.playerSettings.ContainsKey(player.userID))
      {
        data.Inst.playerSettings.Add(player.userID, new Data.Structure.PlayerSettings());
      }

      // Load the player's settings
      Data.Structure.PlayerSettings settings = data.Inst.playerSettings[player.userID];

      double currentTime = Utils.CurrentTime();

      if (config.Options.SpamPrevention.Enabled)
      {
        double timePassed = currentTime - settings.lastSet;
        bool lockedOut = currentTime < settings.lockedOutUntil;
        double lockOutFor = config.Options.SpamPrevention.LockOutTime * Math.Pow(2, (config.Options.SpamPrevention.UseExponentialLockOutTime ? settings.lockedOutTimes : 0));

        if (!lockedOut)
        {
          // Called again within spam window time?
          if (timePassed < config.Options.SpamPrevention.WindowTime)
          {
            settings.timesSetInSpamWindow++;
          }
          else
          {
            settings.timesSetInSpamWindow = 1;
          }

          // Too many recent changes?
          if (settings.timesSetInSpamWindow > config.Options.SpamPrevention.Attempts)
          {
            // Locked them out.
            settings.lockedOutUntil = currentTime + lockOutFor;
            settings.lastLockedOut = currentTime;
            settings.lockedOutTimes++;
            settings.timesSetInSpamWindow = 0;
            lockedOut = true;
          }
        }

        // Locked out?
        if (lockedOut)
        {
          if (!quiet)
          {
            Message(
              player,
              string.Format(
                lang.GetMessage("SpamPrevention", this, player.UserIDString),
                TimeSpan.FromSeconds(Math.Ceiling(settings.lockedOutUntil - currentTime)).ToString(@"d\d\ h\h\ mm\m\ ss\s").TrimStart(' ', 'd', 'h', 'm', 's', '0'),
                config.Options.SpamPrevention.LockOutTime,
                config.Options.SpamPrevention.WindowTime
              )
            );
          }
          return;
        }

        // Haven't been locked out for a long time?
        if (currentTime > settings.lastLockedOut + config.Options.SpamPrevention.LockOutResetFactor * lockOutFor)
        {
          // Reset their lockOuts.
          settings.lockedOutTimes = 0;
        }
      }

      if (guest)
      {
        settings.guestCode = code;
      }
      else
      {
        settings.code = code;
      }

      settings.lastSet = currentTime;

      if (!quiet)
      {
        hideCode = hideCode || Utils.ShouldHideCode(player, settings);

        Message(
          player,
          hideCode
            ? lang.GetMessage(guest ? "GuestCodeUpdatedHidden" : "CodeUpdatedHidden", this, player.UserIDString)
            : string.Format(
                lang.GetMessage(guest ? "GuestCodeUpdated" : "CodeUpdated", this, player.UserIDString),
                Formatter.Value(code)
              )
        );
      }
    }

    /// <summary>
    /// This method will only toggle off, not on.
    /// </summary>
    /// <param name="player"></param>
    [ObsoleteAttribute("This method is deprecated.", true)]
    public void ToggleEnabled(BasePlayer player)
    {
      RemoveCode(player);
    }

    /// <summary>
    /// Remove the given player's the code.
    /// </summary>
    /// <param name="player">The player to remove the code of.</param>
    /// <param name="guest">If true, the guest code will be removed instead of the main code.</param>
    /// <param name="quiet">If true, no output message will be shown to the player.</param>
    public void RemoveCode(BasePlayer player, bool guest = false, bool quiet = false)
    {
      if (!data.Inst.playerSettings.ContainsKey(player.userID))
      {
        return;
      }

      // Load the player's settings.
      Data.Structure.PlayerSettings settings = data.Inst.playerSettings[player.userID];

      if (!guest)
      {
        settings.code = null;
      }

      // Remove the guest code both then removing the main code and when just removing the guest code.
      settings.guestCode = null;

      if (!quiet)
      {
        Message(
          player,
          lang.GetMessage(guest ? "GuestCodeRemoved" : "CodeRemoved", this, player.UserIDString)
        );
      }
    }

    [ObsoleteAttribute("This method is deprecated. Call IsValidCode instead.", false)]
    public bool ValidCode(string codeString) => ValidCode(codeString);

    /// <summary>
    /// Is the given string a valid code?
    /// </summary>
    /// <param name="code">The code to test.</param>
    /// <returns>True if it's valid, otherwise false.</returns>
    public bool IsValidCode(string codeString)
    {
      if (codeString == null)
      {
        return false;
      }

      int code;
      if (codeString.Length == 4 && int.TryParse(codeString, out code))
      {
        if (code >= 0 && code < 10000)
        {
          return true;
        }
      }

      return false;
    }

    [ObsoleteAttribute("This method is deprecated. Call GenerateRandomCode instead.", false)]
    public static string GetRandomCode()
    {
      return Core.Random.Range(0, 10000).ToString("0000");
    }

    /// <summary>
    /// Generate a random code.
    /// </summary>
    /// <returns></returns>
    public string GenerateRandomCode()
    {
      return Core.Random.Range(0, 10000).ToString("0000");
    }

    /// <summary>
    /// Remove all lock outs caused by spam protection.
    /// </summary>
    /// <param name="player">The player to toggle quiet mode for.</param>
    /// <param name="quiet">If true, no output message will be shown to the player.</param>
    public void ToggleQuietMode(BasePlayer player, bool quiet = false)
    {
      // Load the player's settings.
      Data.Structure.PlayerSettings settings = data.Inst.playerSettings[player.userID];

      settings.quietMode = !settings.quietMode;

      if (!quiet)
      {
        if (settings.quietMode)
        {
          Message(
            player,
            string.Format(
              "{0}\n" + Formatter.SmallLineGap + "{1}",
              lang.GetMessage("QuietModeEnable", this, player.UserIDString),
              lang.GetMessage("HelpExtendedQuietModeDetails", this, player.UserIDString)
            )
          );
        }
        else
        {
          Message(
            player,
            lang.GetMessage("QuietModeDisable", this, player.UserIDString)
          );
        }
      }
    }

    /// <summary>
    /// Reset (remove) all lock outs caused by spam protection.
    /// </summary>
    public void ResetAllLockOuts()
    {
      foreach (ulong userID in data.Inst.playerSettings.Keys)
      {
        ResetLockOut(userID);
      }
    }

    /// <summary>
    /// Reset (remove) the lock out caused by spam protection for the given player.
    /// </summary>
    /// <param name="player"></param>
    public void ResetLockOut(BasePlayer player)
    {
      ResetLockOut(player.userID);
    }

    /// <summary>
    /// Reset (remove) the lock out caused by spam protection for the given user id.
    /// </summary>
    /// <param name="userID"></param>
    public void ResetLockOut(ulong userID)
    {
      if (!data.Inst.playerSettings.ContainsKey(userID))
      {
        return;
      }

      Data.Structure.PlayerSettings settings = data.Inst.playerSettings[userID];
      settings.lockedOutTimes = 0;
      settings.lockedOutUntil = 0;
    }

    #endregion API

    /// <summary>
    /// Destroy the temporary code lock for the given player.
    /// </summary>
    /// <param name="player"></param>
    private void DestroyTempCodeLock(BasePlayer player)
    {
      // Code lock for player exists? Remove it.
      if (tempCodeLocks.ContainsKey(player))
      {
        // Code lock exists? Destroy it.
        if (!tempCodeLocks[player].CodeLock.IsDestroyed)
        {
          tempCodeLocks[player].CodeLock.Kill();
        }
        tempCodeLocks.Remove(player);
      }
      UnsubscribeFromUnneededHooks();
    }

    /// <summary>
    /// Remove all the temporary code locks.
    /// </summary>
    private void RemoveAllTempCodeLocks()
    {
      // Remove all temp code locks - we don't want to save them.
      foreach (TempCodeLockInfo codeLockInfo in tempCodeLocks.Values)
      {
        if (!codeLockInfo.CodeLock.IsDestroyed)
        {
          codeLockInfo.CodeLock.Kill();
        }
      }
      tempCodeLocks.Clear();
      UnsubscribeFromUnneededHooks();
    }

    /// <summary>
    /// Unsubscribe from things that there is not point currently being subscribed to.
    /// </summary>
    private void UnsubscribeFromUnneededHooks()
    {
      // No point listing for code lock codes if we aren't expecting any.
      if (tempCodeLocks.Count < 1)
      {
        Unsubscribe("OnCodeEntered");
      }
    }

    /// <summary>
    /// Message the given player via the in-game chat.
    /// </summary>
    private void Message(BasePlayer player, string message)
    {
      if (string.IsNullOrEmpty(message) || !player.IsConnected)
        return;

      player.SendConsoleCommand(
        "chat.add",
        2,
        config.Commands.ChatIconId,
        message
      );
    }

    /// <summary>
    /// The Config for this plugin.
    /// </summary>
    private class AutoCodeConfig
    {
      // The plugin.
      private readonly AutoCode plugin;

      // The oxide DynamicConfigFile instance.
      public readonly DynamicConfigFile OxideConfig;

      // Meta.
      private bool UnsavedChanges = false;

      public AutoCodeConfig()
      {
      }

      public AutoCodeConfig(AutoCode plugin)
      {
        this.plugin = plugin;
        OxideConfig = plugin.Config;
      }

      public CommandsDef Commands = new CommandsDef();

      public class CommandsDef
      {
        public string Use = "code";
        public ulong ChatIconId = 76561199143387303u;
      };

      public OptionsDef Options = new OptionsDef();

      public class OptionsDef
      {
        public bool DisplayPermissionErrors = true;

        public SpamPreventionDef SpamPrevention = new SpamPreventionDef();

        public PluginIntegrationDef PluginIntegration = new PluginIntegrationDef();

        public class SpamPreventionDef
        {
          public bool Enabled = true;
          public int Attempts = 5;
          public double LockOutTime = 5.0;
          public double WindowTime = 30.0;
          public bool UseExponentialLockOutTime = true;
          public double LockOutResetFactor = 5.0;
        };

        public class PluginIntegrationDef
        {
          public NoEscapeDef NoEscape = new NoEscapeDef();

          public class NoEscapeDef
          {
            public bool BlockRaid = false;
            public bool BlockCombat = false;
          };
        };
      };

      /// <summary>
      /// Save the changes to the config file.
      /// </summary>
      public void Save(bool force = false)
      {
        if (UnsavedChanges || force)
        {
          plugin.SaveConfig();
        }
      }

      /// <summary>
      /// Load config values.
      /// </summary>
      public void Load()
      {
        // Options.
        Options.DisplayPermissionErrors = GetConfigValue(
          new string[] { "Options", "Display Permission Errors" },
          GetConfigValue(new string[] { "Options", "displayPermissionErrors" }, true, true)
        );
        RemoveConfigValue(new string[] { "Options", "displayPermissionErrors" }); // Remove deprecated version.

        // Spam prevention.
        Options.SpamPrevention.Enabled = GetConfigValue(new string[] { "Options", "Spam Prevention", "Enable" }, true);
        Options.SpamPrevention.Attempts = GetConfigValue(new string[] { "Options", "Spam Prevention", "Attempts" }, 5);
        Options.SpamPrevention.LockOutTime = GetConfigValue(new string[] { "Options", "Spam Prevention", "Lock Out Time" }, 5.0);
        Options.SpamPrevention.WindowTime = GetConfigValue(new string[] { "Options", "Spam Prevention", "Window Time" }, 30.0);
        Options.SpamPrevention.LockOutResetFactor = GetConfigValue(new string[] { "Options", "Spam Prevention", "Lock Out Reset Factor" }, 5.0);

        Options.SpamPrevention.UseExponentialLockOutTime = GetConfigValue(
          new string[] { "Options", "Spam Prevention", "Exponential Lock Out Time" },
          GetConfigValue(new string[] { "Options", "Spam Prevention", "Use Exponential Lock Out Time" }, true, true)
        );
        RemoveConfigValue(new string[] { "Options", "Spam Prevention", "Exponential Lock Out Time" }); // Remove deprecated version.

        // Plugin integration - No Escape.
        Options.PluginIntegration.NoEscape.BlockCombat = GetConfigValue(new string[] { "Options", "Plugin Integration", "No Escape", "Block Combat" }, false);
        Options.PluginIntegration.NoEscape.BlockRaid = GetConfigValue(new string[] { "Options", "Plugin Integration", "No Escape", "Block Raid" }, true);

        // Commands.
        plugin.commands.Use = GetConfigValue(new string[] { "Commands", "Use" }, plugin.commands.Use);

        Save();
      }

      /// <summary>
      /// Get the config value for the given settings.
      /// </summary>
      private T GetConfigValue<T>(string[] settingPath, T defaultValue, bool deprecated = false)
      {
        object value = OxideConfig.Get(settingPath);
        if (value == null)
        {
          if (!deprecated)
          {
            SetConfigValue(settingPath, defaultValue);
          }
          return defaultValue;
        }

        return OxideConfig.ConvertValue<T>(value);
      }

      /// <summary>
      /// Set the config value for the given settings.
      /// </summary>
      private void SetConfigValue<T>(string[] settingPath, T newValue)
      {
        List<object> pathAndTrailingValue = new List<object>();
        foreach (var segment in settingPath)
        {
          pathAndTrailingValue.Add(segment);
        }
        pathAndTrailingValue.Add(newValue);

        OxideConfig.Set(pathAndTrailingValue.ToArray());
        UnsavedChanges = true;
      }

      /// <summary>
      /// Remove the config value for the given setting.
      /// </summary>
      private void RemoveConfigValue(string[] settingPath)
      {
        if (settingPath.Length == 1)
        {
          OxideConfig.Remove(settingPath[0]);
          return;
        }

        List<string> parentPath = new List<string>();
        for (int i = 0; i < settingPath.Length - 1; i++)
        {
          parentPath.Add(settingPath[i]);
        }

        Dictionary<string, object> parent = OxideConfig.Get(parentPath.ToArray()) as Dictionary<string, object>;
        parent.Remove(settingPath[settingPath.Length - 1]);
      }
    }

    /// <summary>
    /// Everything related to the data the plugin needs to save.
    /// </summary>
    private class Data
    {
      // The plugin.
      private readonly string Filename;

      // The actual data.
      public Structure Inst { private set; get; }

      public Data(AutoCode plugin)
      {
        Filename = plugin.Name;
      }

      /// <summary>
      /// Save the data.
      /// </summary>
      public void Save()
      {
        Interface.Oxide.DataFileSystem.WriteObject(Filename, Inst);
      }

      /// <summary>
      /// Load the data.
      /// </summary>
      public void Load()
      {
        Inst = Interface.Oxide.DataFileSystem.ReadObject<Structure>(Filename);
      }

      /// <summary>
      /// The data this plugin needs to save.
      /// </summary>
      public class Structure
      {
        public Dictionary<ulong, PlayerSettings> playerSettings = new Dictionary<ulong, PlayerSettings>();

        /// <summary>
        /// The settings saved for each player.
        /// </summary>
        public class PlayerSettings
        {
          public string code = null;
          public string guestCode = null;
          public bool quietMode = false;
          public double lastSet = 0;
          public int timesSetInSpamWindow = 0;
          public double lockedOutUntil = 0;
          public double lastLockedOut = 0;
          public int lockedOutTimes = 0;
        }
      }
    }

    /// <summary>
    /// The permissions this plugin uses.
    /// </summary>
    private static class Permissions
    {
      // Permissions.
      public const string Use = "autocode.use";

      public const string Try = "autocode.try";
      public const string Admin = "autocode.admin";

      /// <summary>
      /// Register the permissions.
      /// </summary>
      public static void Register(AutoCode plugin)
      {
        plugin.permission.RegisterPermission(Use, plugin);
        plugin.permission.RegisterPermission(Try, plugin);
        plugin.permission.RegisterPermission(Admin, plugin);
      }
    }

    /// <summary>
    /// Everything related to commands.
    /// </summary>
    private class Commands
    {
      // The plugin.
      private readonly AutoCode plugin;

      // The rust command instance.
      public readonly Command Rust;

      // Console Commands.
      public string ResetLockOut = "autocode.resetlockout";

      // Chat Commands.
      public string Use = "code";

      // Chat Command Arguments.

      public string Guest = "guest";
      public string PickCode = "pick";
      public string RandomCode = "random";
      public string RemoveCode = "remove";
      public string SetCode = "set";
      public string QuietMode = "quiet";
      public string Help = "help";

      public Commands(AutoCode plugin)
      {
        this.plugin = plugin;
        Rust = plugin.cmd;
      }

      /// <summary>
      /// Register this command.
      /// </summary>
      public void Register()
      {
        Rust.AddConsoleCommand(ResetLockOut, plugin, HandleResetLockOut);
        Rust.AddChatCommand(Use, plugin, HandleUse);
      }

      /// <summary>
      /// Reset lock out.
      /// </summary>
      /// <returns></returns>
      private bool HandleResetLockOut(ConsoleSystem.Arg arg)
      {
        BasePlayer player = arg.Player();

        // Not admin?
        if (!plugin.permission.UserHasPermission(player.UserIDString, Permissions.Admin))
        {
          if (plugin.config.Options.DisplayPermissionErrors)
          {
            arg.ReplyWith(plugin.lang.GetMessage("NoPermission", plugin, player?.UserIDString));
          }

          return false;
        }

        // Incorrect number of args given.
        if (!arg.HasArgs(1) || arg.HasArgs(2))
        {
          arg.ReplyWith(plugin.lang.GetMessage("InvalidArguments", plugin, player?.UserIDString));
          return false;
        }

        string resetForString = arg.GetString(0).ToLower();

        // Reset all?
        if (resetForString == "*")
        {
          arg.ReplyWith(plugin.lang.GetMessage("ResettingAllLockOuts", plugin, player?.UserIDString));
          plugin.ResetAllLockOuts();
          return true;
        }

        // Find the player to reset for.
        List<BasePlayer> resetForList = new List<BasePlayer>();
        foreach (BasePlayer p in BasePlayer.allPlayerList)
        {
          if (p == null || string.IsNullOrEmpty(p.displayName))
          {
            continue;
          }

          if (p.UserIDString == resetForString || p.displayName.Contains(resetForString, CompareOptions.OrdinalIgnoreCase))
          {
            resetForList.Add(p);
          }
        }

        // No player found?
        if (resetForList.Count == 0)
        {
          arg.ReplyWith(plugin.lang.GetMessage("ErrorNoPlayerFound", plugin, player?.UserIDString));
          return false;
        }

        // Too many players found?
        if (resetForList.Count > 1)
        {
          arg.ReplyWith(plugin.lang.GetMessage("ErrorMoreThanOnePlayerFound", plugin, player?.UserIDString));
          return false;
        }

        // Rest for player.
        arg.ReplyWith(
          string.Format(
            plugin.lang.GetMessage("ResettingLockOut", plugin, player?.UserIDString),
            resetForList[0].displayName
          )
        );
        plugin.ResetLockOut(resetForList[0]);
        return true;
      }

      /// <summary>
      /// The "use" chat command.
      /// </summary>
      private void HandleUse(BasePlayer player, string label, string[] args)
      {
        // Allowed to use this command?
        if (!plugin.permission.UserHasPermission(player.UserIDString, Permissions.Use))
        {
          if (plugin.config.Options.DisplayPermissionErrors)
          {
            plugin.Message(
              player,
              plugin.lang.GetMessage("NoPermission", plugin, player.UserIDString)
            );
          }
          return;
        }

        if (args.Length == 0)
        {
          ShowInfo(player, label, args);
          return;
        }

        // Create settings for user if they don't already have any settings.
        if (!plugin.data.Inst.playerSettings.ContainsKey(player.userID))
        {
          plugin.data.Inst.playerSettings.Add(player.userID, new Data.Structure.PlayerSettings());
        }

        int nextArg = 0;
        int argsRemainingCount = args.Length;

        string operation = args[nextArg++].ToLower();
        argsRemainingCount--;

        bool guest = false;

        if (operation == Guest)
        {
          if (argsRemainingCount < 1)
          {
            SyntaxError(player, label, args);
            return;
          }

          guest = true;
          operation = args[nextArg++].ToLower();
          argsRemainingCount--;
        }

        if (operation == SetCode)
        {
          if (argsRemainingCount < 1)
          {
            SyntaxError(player, label, args);
            return;
          }

          operation = args[nextArg++].ToLower();
          argsRemainingCount--;
        }

        // Help.
        if (operation == Help)
        {
          plugin.Message(player, GetHelpExtended(player, label));
          return;
        }

        // Pick code.
        if (operation == PickCode)
        {
          plugin.Message(
            player,
            string.Format(plugin.lang.GetMessage("NoLongerSupportedPick", plugin, player.UserIDString), PickCode, SetCode)
          );
          return;
        }

        // Toggle quiet mode.
        if (operation == QuietMode)
        {
          if (guest)
          {
            SyntaxError(player, label, args);
            return;
          }
          if (argsRemainingCount > 0)
          {
            plugin.Message(
              player,
              string.Format(plugin.lang.GetMessage("InvalidArgsTooMany", plugin, player.UserIDString), label)
            );
            return;
          }

          plugin.ToggleQuietMode(player);
          return;
        }

        // Remove?
        if (operation == RemoveCode)
        {
          if (argsRemainingCount > 0)
          {
            plugin.Message(
              player,
              string.Format(plugin.lang.GetMessage("InvalidArgsTooMany", plugin, player.UserIDString), label)
            );
            return;
          }

          plugin.RemoveCode(player, guest);
          return;
        }

        // Use random code?
        if (operation == RandomCode)
        {
          if (argsRemainingCount > 0)
          {
            plugin.Message(
              player,
              string.Format(plugin.lang.GetMessage("InvalidArgsTooMany", plugin, player.UserIDString), label)
            );
            return;
          }

          var hideCode = false;
          if (plugin.data.Inst.playerSettings.ContainsKey(player.userID))
          {
            Data.Structure.PlayerSettings settings = plugin.data.Inst.playerSettings[player.userID];
            hideCode = settings.quietMode;
          }

          plugin.SetCode(player, plugin.GenerateRandomCode(), guest, false, hideCode);
          return;
        }

        // Use given code?
        if (plugin.IsValidCode(operation))
        {
          if (argsRemainingCount > 0)
          {
            plugin.Message(
              player,
              string.Format(plugin.lang.GetMessage("InvalidArgsTooMany", plugin, player.UserIDString), label)
            );
            return;
          }

          plugin.SetCode(player, operation, guest);
          return;
        }

        SyntaxError(player, label, args);
      }

      /// <summary>
      /// Show the player their info.
      /// </summary>
      private void ShowInfo(BasePlayer player, string label, string[] args)
      {
        string code = null;
        string guestCode = null;
        bool quietMode = false;

        if (plugin.data.Inst.playerSettings.ContainsKey(player.userID))
        {
          Data.Structure.PlayerSettings settings = plugin.data.Inst.playerSettings[player.userID];
          code = settings.code;
          guestCode = settings.guestCode;
          quietMode = settings.quietMode;

          if (Utils.ShouldHideCode(player, settings))
          {
            code = code == null ? null : HiddenCode;
            guestCode = guestCode == null ? null : HiddenCode;
          }
        }

        plugin.Message(
          player,
          string.Format(
            "{0}\n" + Formatter.SmallLineGap + "{1}\n" + Formatter.SmallLineGap + "{2}",
            Formatter.H2(plugin.lang.GetMessage("Description", plugin, player.UserIDString)),
            string.Format(
              plugin.lang.GetMessage("Info", plugin, player.UserIDString),
              code != null ? Formatter.Value(code) : Formatter.NoValue(plugin.lang.GetMessage("NotSet", plugin, player.UserIDString)),
              guestCode != null ? Formatter.Value(guestCode) : Formatter.NoValue(plugin.lang.GetMessage("NotSet", plugin, player.UserIDString)),
              quietMode ? Formatter.Value(plugin.lang.GetMessage("Enabled", plugin, player.UserIDString)) : Formatter.NoValue(plugin.lang.GetMessage("Disabled", plugin, player.UserIDString))
            ),
            GetHelp(player, label)
          )
        );
      }

      /// <summary>
      /// Notify the player that they entered a syntax error in their "use" chat command.
      /// </summary>
      private void SyntaxError(BasePlayer player, string label, string[] args)
      {
        plugin.Message(
          player,
          string.Format(
            plugin.lang.GetMessage("SyntaxError", plugin, player.UserIDString),
            GetUsage(label)
          )
        );
      }

      /// <summary>
      /// Get help for the "use" command.
      /// </summary>
      public string GetHelp(BasePlayer player, string label)
      {
        return string.Format(
          plugin.lang.GetMessage("Help", plugin, player.UserIDString),
          GetUsage(label)
        );
      }

      /// <summary>
      /// Show how to use the "use" command.
      /// </summary>
      /// <returns></returns>
      private string GetUsage(string label)
      {
        return Formatter.Command(
          string.Format(
            "{0} [<{1}>]",
            label,
            string.Join("|", new string[] {
              string.Format(
                "[{0}] <{1}>",
                Guest,
                string.Join("|", new string[] {
                  string.Format(
                    "[{0}] {1}",
                    SetCode,
                    "1234"
                  ),
                  RandomCode,
                  RemoveCode
                })
              ),
              QuietMode,
              Help
            })
          )
        );
      }

      /// <summary>
      /// Display an extended help message to the player.
      /// </summary>
      public string GetHelpExtended(BasePlayer player, string label)
      {
        return string.Format(
          "{0}",
          string.Join(
            "\n" + Formatter.SmallLineGap,
            string.Join(
              "\n" + Formatter.SmallLineGap,
              Formatter.H2(plugin.lang.GetMessage("HelpExtendedCoreCommands", plugin, player.UserIDString)),
              Formatter.UL(
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedInfo", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0}", label)))
                ),
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedSetCode", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0} {1}", label, "1234")))
                ),
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedRandomCode", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0} {1}", label, RandomCode)))
                ),
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedRemoveCode", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0} {1}", label, RemoveCode)))
                )
              ),
              string.Format(
                plugin.lang.GetMessage("HelpExtendedCoreGuestCommands", plugin, player.UserIDString),
                Formatter.Indent(Formatter.Command(string.Format("{0} {1} {2}", label, Guest, "5678")))
              )
            ),
            string.Join(
              "\n" + Formatter.SmallLineGap,
              Formatter.H2(plugin.lang.GetMessage("HelpExtendedOtherCommands", plugin, player.UserIDString)),
              Formatter.UL(
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedQuietMode", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0} {1}", label, QuietMode)))
                ),
                string.Format(
                  plugin.lang.GetMessage("HelpExtendedHelp", plugin, player.UserIDString),
                  Formatter.Indent(Formatter.Command(string.Format("{0} {1}", label, Help)))
                )
              )
            )
          )
        );
      }
    }

    /// <summary>
    /// Utility functions.
    /// </summary>
    private static class Utils
    {
      /// <summary>
      /// Get the current time.
      /// </summary>
      /// <returns>The number of seconds that have passed since 1970-01-01.</returns>
      public static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

      /// <summary>
      /// Should the code for the given player be hidden in messages?
      /// </summary>
      public static bool ShouldHideCode(BasePlayer player, Data.Structure.PlayerSettings settings)
      {
        return settings.quietMode || player.net.connection.info.GetBool("global.streamermode");
      }
    }

    /// <summary>
    /// Text formatting functions for in-game chat.
    /// </summary>
    private static class Formatter
    {
      /// <summary>
      /// A line break in a very small font.
      /// </summary>
      public const string SmallestLineGap = "<size=6>\n</size>";

      /// <summary>
      /// A line break in a small font.
      /// </summary>
      public const string SmallLineGap = "<size=9>\n</size>";

      /// <summary>
      /// Format the given text as a header level 1.
      /// </summary>
      public static string H1(string text)
      {
        return string.Format("<size=20>{0}</size>", text);
      }

      /// <summary>
      /// Format the given text as a header level 2.
      /// </summary>
      public static string H2(string text)
      {
        return string.Format("<size=16>{0}</size>", text);
      }

      /// <summary>
      /// Small text.
      /// </summary>
      public static string Small(string text)
      {
        return string.Format("<size=12>{0}</size>", text);
      }

      /// <summary>
      /// Format the items as an unordered list.
      /// </summary>
      public static string UL(params string[] items)
      {
        return string.Join(
          "\n" + SmallestLineGap,
          items.Select(item => string.Format(" - {0}", item))
        );
      }

      /// <summary>
      /// Indent the given text.
      /// </summary>
      public static string Indent(string text)
      {
        return string.Format("    {0}", text);
      }

      /// <summary>
      /// Format the given text as a command.
      /// </summary>
      public static string Command(string text)
      {
        return string.Format("<color=#e0e0e0>{0}</color>", text);
      }

      public static string Value(string text)
      {
        return string.Format("<color=#bfff75>{0}</color>", text);
      }

      public static string NoValue(string text)
      {
        return string.Format("<color=#ff7771>{0}</color>", text);
      }
    }

    /// <summary>
    /// The data stored for temp code locks.
    /// </summary>
    private class TempCodeLockInfo
    {
      public readonly CodeLock CodeLock;
      public readonly bool Guest;

      public TempCodeLockInfo(CodeLock CodeLock, bool Guest = false)
      {
        this.CodeLock = CodeLock;
        this.Guest = Guest;
      }
    }
  }
}


// --- End of file: AutoCode.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/analytics ---
// --- Original File Path: A/Analytics/Analytics.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;

namespace Oxide.Plugins
{
    [Info("Analytics", "Wulf/lukespragg", "1.1.2")]
    [Description("Real-time collection and reporting of server events to Google Analytics")]
    public class Analytics : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Google tracking ID (ex. UA-XXXXXXXX-Y)")]
            public string TrackingId { get; set; } = "";

            [JsonProperty(PropertyName = "Track connections (true/false)")]
            public bool TrackConnections { get; set; } = true;

            [JsonProperty(PropertyName = "Track disconnections (true/false)")]
            public bool TrackDisconnections { get; set; } = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            LogWarning($"Could not load a valid configuration file, creating a new configuration file at {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Google Analytics

        private static readonly Dictionary<string, string> Headers = new Dictionary<string, string>
        {
            ["User-Agent"] = $"Oxide/{OxideMod.Version} ({Environment.OSVersion}; {Environment.OSVersion.Platform})"
        };

        private void Collect(IPlayer player, string session)
        {
            if (string.IsNullOrEmpty(config.TrackingId))
            {
                LogWarning("Google tracking ID is not set, analytics will not be collected." +
                           "If you do not have one, see https://support.google.com/analytics/answer/7476135?hl=en#trackingID");
                return;
            }

            string data = $"v=1&tid={config.TrackingId}&sc={session}&t=screenview&cd={server.Name}" +
                          $"&an={covalence.Game}&av={covalence.Game}+v{server.Version}+({server.Protocol})" +
                          $"&cid={player.Id}&ul={player.Language}&uip={player.Address}";

            webrequest.Enqueue("https://www.google-analytics.com/collect", Uri.EscapeUriString(data), (code, response) =>
            {
                if (code != 200 || response == null)
                {
                    LogWarning($"Data: {data}");
                    LogWarning($"HTTP code: {code}");
                    LogWarning($"Response: {response}");
                }
            }, this, RequestMethod.POST, Headers);
        }

        #endregion Google Analytics

        #region Event Collection

        private void CollectAll(string session)
        {
            foreach (IPlayer player in players.Connected)
            {
                Collect(player, session);
            }
        }

        private void OnServerInitialized() => CollectAll("start");

        private void OnServerSave() => CollectAll("start");

        private void OnServerShutdown() => CollectAll("end");

        private void OnUserConnected(IPlayer player) => Collect(player, "start");

        private void OnUserDisconnected(IPlayer player) => Collect(player, "end");

        #endregion Event Collection
    }
}


// --- End of file: Analytics.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-craft ---
// --- Original File Path: Q/QuarryCraft/QuarryCraft.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Quarry Craft", "Vlad-00003", "1.0.2")]
    [Description("Allow players with permissions craft quarry")]
    class QuarryCraft : RustPlugin
    {
        #region Vars

        private PluginConfig config;
        private ItemBlueprint bp;
        private ItemDefinition def;
        #endregion

        #region Config
        private class PluginConfig
        {
            [JsonProperty("Crafting price")]
            public Dictionary<string, int> Price;
            [JsonProperty("Workbench level required")]
            public int Workbench = 2;
            [JsonProperty("Crafting time")]
            public float Time = 200f;
            [JsonProperty("Amount to create")]
            public int Amount = 1;
            [JsonProperty("Permission to craft")]
            public string Permission = "quarrycraft.use";
            [JsonProperty("Command to craft")]
            public string Command = "/quarry";
        }
        #endregion

        #region ConfigInitialization and quiting

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig()
            {
                Price = new Dictionary<string, int>()
                {
                    ["wood"] = 10000,
                    ["metal.fragments"] = 1750,
                    ["cloth"] = 500
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            var defs = ItemManager.GetItemDefinitions();
            var ingridients = new List<ItemAmount>();
            foreach (var item in config.Price)
            {
                def = defs.FirstOrDefault(x =>
                    x.displayName.english == item.Key || x.shortname == item.Key || x.itemid.ToString() == item.Key);
                if (!def)
                {
                    PrintWarning(GetMsg("Nodef",null, item.Key));
                    continue;
                }
                ingridients.Add(new ItemAmount(def,item.Value));
            }

            def = ItemManager.FindItemDefinition("mining.quarry");
            if (!def)
            {
                PrintError("Unable to find the quarry defenition! The plugin can't work at all.\nPlease contact the developer - Vlad-00003 at oxide.");
                Interface.Oxide.UnloadPlugin(Title);
            }
            bp = def.Blueprint;
            if (bp == null)
            {
                bp = def.gameObject.AddComponent<ItemBlueprint>();
                bp.ingredients = ingridients;
                bp.defaultBlueprint = false;
                bp.userCraftable = true;
                bp.isResearchable = true;
                bp.workbenchLevelRequired = config.Workbench;
                bp.amountToCreate = config.Amount;
                bp.time = config.Time;
                bp.scrapRequired = 750;
                bp.blueprintStackSize = 1000;
            }
            cmd.AddChatCommand(config.Command.Replace("/", string.Empty), this,CmdCraft);
            permission.RegisterPermission(config.Permission,this);
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        void Unload()
        {
            UnityEngine.Object.Destroy(bp);
        }
        #endregion

        #region Localization

        private string GetMsg(string langkey, BasePlayer player, params object[] args)
        {
            string msg = lang.GetMessage(langkey, this, player?.UserIDString);
            if (args.Length > 0)
                msg = string.Format(msg, args);
            return msg;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["Nodef"] = "No defenition found for item {0}. It won't be used as the price for the craft.",
                ["Noingridient"] = "Not enought ingidients! Required to craft:\n{0}",
                ["EnoughtIngridient"] = "{0} - <color=#53f442>{1}</color>/{2}",
                ["NotEnoughtIngridient"] = "{0} - <color=#f44141>{1}</color>/{2}",
                ["Workbench"] = "Your current crafting level is too low. Required crafting level {0}",
                ["NoPermission"] = "You don't have the required permission"
        },this);
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["Nodef"] = "ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¿ÑÐµÐ´Ð¼ÐµÑÐ° {0}. ÐÐ½ Ð½Ðµ Ð±ÑÐ´ÐµÑ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½ Ðº ÑÐµÐ½Ðµ ÐºÑÐ°ÑÑÐ°.",
                ["Noingridient"] = "ÐÐµÐ´Ð¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ Ð¸Ð½Ð³ÑÐ¸Ð´Ð¸ÐµÐ½ÑÐ¾Ð². ÐÐ° ÐºÑÐ°ÑÑ Ð½ÑÐ¶Ð½Ð¾:\n{0}",
                ["EnoughtIngridient"] = "{0} - <color=#53f442>{1}</color>/{2}",
                ["NotEnoughtIngridient"] = "{0} - <color=#f44141>{1}</color>/{2}",
                ["Workbench"] = "ÐÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ Ð²ÐµÑÑÑÐ°Ðº ÑÑÐ¾Ð²Ð½Ñ {0}",
                ["NoPermission"] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ð¹ Ð¿ÑÐ¸Ð²Ð¸Ð»ÐµÐ³Ð¸Ð¸"
            },this,"ru");
    }

        #endregion

        #region Main
        private void CmdCraft(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, config.Permission))
            {
                player.ChatMessage(GetMsg("NoPermission",player));
                return;
            }
            if (player.currentCraftLevel < config.Workbench)
            {
                player.ChatMessage(GetMsg("Workbench",player,config.Workbench));
                return;
            }
            foreach (var ingredient in bp.ingredients)
            {
                var playeram = player.inventory.GetAmount(ingredient.itemDef.itemid);
                if (playeram >= ingredient.amount) continue;
                var reply = bp.ingredients.Select(x =>
                    GetMsg(player.inventory.GetAmount(x.itemDef.itemid) >= x.amount
                            ? "EnoughtIngridient"
                            : "NotEnoughtIngridient"
                        , player, x.itemDef.displayName.translated, player.inventory.GetAmount(x.itemDef.itemid),
                        x.amount)).ToArray();
                player.ChatMessage(GetMsg("Noingridient",player,string.Join("\n",reply)));
                return;
            }
            ItemCrafter itemCrafter = player.inventory.crafting;
            if (!itemCrafter.CanCraft(bp))
                return;
            ++itemCrafter.taskUID;
            ItemCraftTask task = Facepunch.Pool.Get<ItemCraftTask>();
            task.blueprint = bp;
            List<Item> items = new List<Item>();
            foreach (var ingridient in bp.ingredients)
            {
                var amount = (int)ingridient.amount;
                foreach (var container in itemCrafter.containers)
                {
                    amount -= container.Take(items, ingridient.itemid, amount);
                    if(amount > 0)
                        continue;
                    break;
                }
            }
            task.potentialOwners = new List<ulong>();
            foreach (var item in items)
            {
                item.CollectedForCrafting(player);
                if (task.potentialOwners.Contains(player.userID))
                    continue;
                task.potentialOwners.Add(player.userID);
            }
            task.takenItems = items;
            task.endTime = 0.0f;
            task.taskUID = itemCrafter.taskUID;
            task.owner = player;
            task.instanceData = null;
            task.amount = 1;
            task.skinID = 0;
            object obj = Interface.CallHook("OnItemCraft", task, player, null);
            if (obj is bool)
            {
                return;
            }
            itemCrafter.queue.AddLast(task);
            if (task.owner != null && task.blueprint?.targetItem != null)
                player.Command("note.craft_add", task.taskUID, task.blueprint.targetItem.itemid, 1 );
        }
        #endregion
    }
}

// --- End of file: QuarryCraft.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quick-sort ---
// --- Original File Path: Q/QuickSort/QuickSort.cs ---

using System;
using System.Collections.Generic;

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

using Pool = Facepunch.Pool;

/*
7. Use offsets instead of anchors for all the child UI elements (my preference).
8. Is it necessary to use OnEntityDeath / OnEntityKill / OnPlayerSleep?
Nowadays I think the loot hooks are sufficiently comprehensive.
Do need OnPlayerLootEnd and possibly OnLootEntityEnd (for edge cases).
*/

namespace Oxide.Plugins
{
    [Info("Quick Sort", "MON@H", "1.8.2")]
    [Description("Adds a GUI that allows players to quickly sort items into containers")]
    public class QuickSort : RustPlugin
    {
        #region Variables

        private const string GUIPanelName = "QuickSortUI";
        private const string PermissionAutoLootAll = "quicksort.autolootall";
        private const string PermissionLootAll = "quicksort.lootall";
        private const string PermissionUse = "quicksort.use";

        private readonly Hash<int, string> _cacheUiJson = new Hash<int, string>();
        private readonly Hash<string, int> _cacheLanguageIDs = new Hash<string, int>();
        private readonly HashSet<uint> _cacheContainersExcluded = new HashSet<uint>();
        // Keep track of UI viewers to reduce unnecessary calls to destroy the UI.
        private readonly HashSet<ulong> _uiViewers = new HashSet<ulong>();

        private object[] _noteInv = new object[2];
        // When players do not have data, use this shared object to avoid unnecessary heap allocations.
        private PlayerData _defaultPlayerData;

        #endregion Variables

        #region Initialization

        private void Init()
        {
            UnsubscribeHooks();
            RegisterPermissions();
            AddCommands();
        }

        private void OnServerInitialized()
        {
            CreateCache();
            LoadData();
            SubscribeHooks();
        }

        private void Unload()
        {
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                UiDestroy(activePlayer);
            }
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalConfiguration GlobalSettings = new GlobalConfiguration();

            [JsonProperty(PropertyName = "Custom UI Settings")]
            public UiConfiguration CustomUISettings = new UiConfiguration();

            public class GlobalConfiguration
            {
                [JsonProperty(PropertyName = "Default enabled")]
                public bool DefaultEnabled = true;

                [JsonProperty(PropertyName = "Default UI style (center, lite, right, custom)")]
                public string DefaultUiStyle = "right";

                [JsonProperty(PropertyName = "Loot all delay in seconds (0 to disable)")]
                public int LootAllDelay = 0;

                [JsonProperty(PropertyName = "Enable loot all on the sleepers")]
                public bool LootSleepers = false;

                [JsonProperty(PropertyName = "Auto loot all enabled by default")]
                public bool AutoLootAll = false;

                [JsonProperty(PropertyName = "Default enabled container types")]
                public PlayerContainers Containers = new PlayerContainers();

                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong SteamIDIcon = 0;

                [JsonProperty(PropertyName = "Chat command")]
                public string[] Commands = new[] { "qs", "quicksort" };

                [JsonProperty(PropertyName = "Excluded containers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> ContainersExcluded = new List<string>()
                {
                    "assets/prefabs/deployable/single shot trap/guntrap.deployed.prefab",
                    "assets/prefabs/npc/autoturret/autoturret_deployed.prefab",
                    "assets/prefabs/npc/flame turret/flameturret.deployed.prefab",
                    "assets/prefabs/npc/sam_site_turret/sam_site_turret_deployed.prefab",
                    "assets/prefabs/npc/sam_site_turret/sam_static.prefab",
                };
            }

            public class UiConfiguration
            {
                public string AnchorsMin = "0.5 1.0";
                public string AnchorsMax = "0.5 1.0";
                public string OffsetsMin = "192 -137";
                public string OffsetsMax = "573 0";
                public string Color = "0.5 0.5 0.5 0.33";
                public string ButtonsColor = "0.75 0.43 0.18 0.8";
                public string LootAllColor = "0.41 0.50 0.25 0.8";
                public string TextColor = "0.77 0.92 0.67 0.8";
                public int TextSize = 16;
                public int CategoriesTextSize = 14;
            }
        }

        public class PlayerContainers
        {
            public bool Belt = false;
            public bool Main = true;
            public bool Wear = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Hash<ulong, PlayerData> PlayerData = new Hash<ulong, PlayerData>();
        }

        public class PlayerData
        {
            public bool Enabled;
            public bool AutoLootAll;
            public string UiStyle;
            public PlayerContainers Containers;
        }

        public void LoadData()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            List<ulong> toRemove = Pool.GetList<ulong>();
            foreach (KeyValuePair<ulong, PlayerData> playerData in _storedData.PlayerData)
            {
                if (!playerData.Value.AutoLootAll.Equals(_defaultPlayerData.AutoLootAll))
                {
                    continue;
                }
                if (!playerData.Value.Enabled.Equals(_defaultPlayerData.Enabled))
                {
                    continue;
                }
                if (!playerData.Value.UiStyle.Equals(_defaultPlayerData.UiStyle))
                {
                    continue;
                }
                if (!playerData.Value.Containers.Belt.Equals(_defaultPlayerData.Containers.Belt))
                {
                    continue;
                }
                if (!playerData.Value.Containers.Main.Equals(_defaultPlayerData.Containers.Main))
                {
                    continue;
                }
                if (!playerData.Value.Containers.Wear.Equals(_defaultPlayerData.Containers.Wear))
                {
                    continue;
                }
                toRemove.Add(playerData.Key);
            }

            if (toRemove.Count > 0)
            {
                for (int i = 0; i < toRemove.Count; i++)
                {
                    _storedData.PlayerData.Remove(toRemove[i]);
                }
                Puts($"Removed {toRemove.Count} players with default settings from datafile.");
                SaveData();
            }

            Pool.FreeList(ref toRemove);
        }

        public void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        public PlayerData GetPlayerData(ulong userID)
        {
            return _storedData.PlayerData[userID] ?? _defaultPlayerData;
        }

        #endregion DataFile

        #region Localization

        public string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Error
            {
                private const string Base = nameof(Error) + ".";
                public const string NoPermission = Base + nameof(NoPermission);
                public const string Syntax = Base + nameof(Syntax);
            }

            public static class Info
            {
                private const string Base = nameof(Info) + ".";
                public const string QuickSort = Base + nameof(QuickSort);
                public const string Style = Base + nameof(Style);
                public const string AutoLootAll = Base + nameof(AutoLootAll);
                public const string ContainerType = Base + nameof(ContainerType);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string All = Base + nameof(All);
                public const string Ammo = Base + nameof(Ammo);
                public const string Attire = Base + nameof(Attire);
                public const string Components = Base + nameof(Components);
                public const string Construction = Base + nameof(Construction);
                public const string Deployables = Base + nameof(Deployables);
                public const string Deposit = Base + nameof(Deposit);
                public const string Disabled = Base + nameof(Disabled);
                public const string Electrical = Base + nameof(Electrical);
                public const string Enabled = Base + nameof(Enabled);
                public const string Existing = Base + nameof(Existing);
                public const string Food = Base + nameof(Food);
                public const string LootAll = Base + nameof(LootAll);
                public const string Medical = Base + nameof(Medical);
                public const string Misc = Base + nameof(Misc);
                public const string Prefix = Base + nameof(Prefix);
                public const string Resources = Base + nameof(Resources);
                public const string Tools = Base + nameof(Tools);
                public const string Traps = Base + nameof(Traps);
                public const string Weapons = Base + nameof(Weapons);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "You do not have permission to use this command!",
                [LangKeys.Format.All] = "All",
                [LangKeys.Format.Ammo] = "Ammo",
                [LangKeys.Format.Attire] = "Attire",
                [LangKeys.Format.Components] = "Components",
                [LangKeys.Format.Construction] = "Construction",
                [LangKeys.Format.Deployables] = "Deployables",
                [LangKeys.Format.Deposit] = "Deposit",
                [LangKeys.Format.Disabled] = "<color=#B22222>Disabled</color>",
                [LangKeys.Format.Electrical] = "Electrical",
                [LangKeys.Format.Enabled] = "<color=#228B22>Enabled</color>",
                [LangKeys.Format.Existing] = "Existing",
                [LangKeys.Format.Food] = "Food",
                [LangKeys.Format.LootAll] = "Loot All",
                [LangKeys.Format.Medical] = "Medical",
                [LangKeys.Format.Misc] = "Misc",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[Quick Sort]</color>: ",
                [LangKeys.Format.Resources] = "Resources",
                [LangKeys.Format.Tools] = "Tools",
                [LangKeys.Format.Traps] = "Traps",
                [LangKeys.Format.Weapons] = "Weapons",
                [LangKeys.Info.AutoLootAll] = "Automated looting is now {0}",
                [LangKeys.Info.ContainerType] = "Quick Sort for container type {0} is now {1}",
                [LangKeys.Info.QuickSort] = "Quick Sort GUI is now {0}",
                [LangKeys.Info.Style] = "Quick Sort GUI style is now {0}",

                [LangKeys.Error.Syntax] = "List Commands:\n" +
                "<color=#FFFF00>/{0} on</color> - Enable GUI\n" +
                "<color=#FFFF00>/{0} off</color> - Disable GUI\n" +
                "<color=#FFFF00>/{0} auto</color> - Enable/Disable automated looting\n" +
                "<color=#FFFF00>/{0} <s | style> <center | lite | right | custom></color> - change GUI style\n" +
                "<color=#FFFF00>/{0} <c | conatiner> <main | wear | belt></color> - add/remove container type from the sort",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Error.NoPermission] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ñ Ð½Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ!",
                [LangKeys.Format.All] = "ÐÑÑ",
                [LangKeys.Format.Ammo] = "ÐÐ°ÑÑÐ¾Ð½Ñ",
                [LangKeys.Format.Attire] = "ÐÐ´ÐµÐ¶Ð´Ð°",
                [LangKeys.Format.Components] = "ÐÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½ÑÑ",
                [LangKeys.Format.Construction] = "ÐÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¸",
                [LangKeys.Format.Deployables] = "Ð Ð°Ð·Ð²ÐµÑÑÑÐ²Ð°ÐµÐ¼ÑÐµ",
                [LangKeys.Format.Deposit] = "ÐÐ¾Ð»Ð¾Ð¶Ð¸ÑÑ",
                [LangKeys.Format.Disabled] = "<color=#B22222>ÐÑÐºÐ»ÑÑÐµÐ½Ð°</color>",
                [LangKeys.Format.Electrical] = "Ð­Ð»ÐµÐºÑÑÐ¸ÑÐµÑÑÐ²Ð¾",
                [LangKeys.Format.Enabled] = "<color=#228B22>ÐÐºÐ»ÑÑÐµÐ½Ð°</color>",
                [LangKeys.Format.Existing] = "Ð¡ÑÑÐµÑÑÐ²ÑÑÑÐ¸Ðµ",
                [LangKeys.Format.Food] = "ÐÐ´Ð°",
                [LangKeys.Format.LootAll] = "ÐÐ°Ð±ÑÐ°ÑÑ Ð²ÑÑ",
                [LangKeys.Format.Medical] = "ÐÐµÐ´Ð¸ÐºÐ°Ð¼ÐµÐ½ÑÑ",
                [LangKeys.Format.Misc] = "Ð Ð°Ð·Ð½Ð¾Ðµ",
                [LangKeys.Format.Prefix] = "<color=#00FF00>[ÐÑÑÑÑÐ°Ñ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ°]</color>: ",
                [LangKeys.Format.Resources] = "Ð ÐµÑÑÑÑÑ",
                [LangKeys.Format.Tools] = "ÐÐ½ÑÑÑÑÐ¼ÐµÐ½ÑÑ",
                [LangKeys.Format.Traps] = "ÐÐ¾Ð²ÑÑÐºÐ¸",
                [LangKeys.Format.Weapons] = "ÐÑÑÐ¶Ð¸Ðµ",
                [LangKeys.Info.AutoLootAll] = "ÐÐ°Ð±Ð¸ÑÐ°ÑÑ Ð²ÑÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐµÐ¿ÐµÑÑ {0}",
                [LangKeys.Info.ContainerType] = "ÐÑÑÑÑÐ°Ñ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð´Ð»Ñ ÑÐ¸Ð¿Ð° ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑÐ° {0} ÑÐµÐ¿ÐµÑÑ {1}",
                [LangKeys.Info.QuickSort] = "GUI Ð±ÑÑÑÑÐ¾Ð¹ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ ÑÐµÐ¿ÐµÑÑ {0}",
                [LangKeys.Info.Style] = "Ð¡ÑÐ¸Ð»Ñ GUI Ð±ÑÑÑÑÐ¾Ð¹ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ ÑÐµÐ¿ÐµÑÑ {0}",

                [LangKeys.Error.Syntax] = "Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´:\n" +
                "<color=#FFFF00>/{0} on</color> - ÐÐºÐ»ÑÑÐ¸ÑÑ GUI\n" +
                "<color=#FFFF00>/{0} off</color> - ÐÑÐºÐ»ÑÑÐ¸ÑÑ GUI\n" +
                "<color=#FFFF00>/{0} auto</color> - ÐÐºÐ»ÑÑÐ¸ÑÑ/ÐÑÐºÐ»ÑÑÐ¸ÑÑ Ð·Ð°Ð±Ð¸ÑÐ°ÑÑ Ð²ÑÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸.\n" +
                "<color=#FFFF00>/{0} <s | style> <center | lite | right | custom></color> - Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ ÑÑÐ¸Ð»Ñ GUI Ð±ÑÑÑÑÐ¾Ð¹ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸.\n" +
                "<color=#FFFF00>/{0} <c | conatiner> <main | wear | belt></color> - Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ/ÑÐ´Ð°Ð»Ð¸ÑÑ ÑÐ¸Ð¿ ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑÐ° Ð´Ð»Ñ ÑÐ¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸.",
            }, this, "ru");
        }

        #endregion Localization

        #region Oxide Hooks

        private void OnLootPlayer(BasePlayer player) => UiCreate(player);

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity.IsValid() && !IsContainerExcluded(player, entity))
            {
                HandleLootEntity(player);
            }
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            BasePlayer player = inventory.baseEntity;

            if (player.IsValid())
            {
                UiDestroy(player);
            }
        }

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (player.IsValid() && !player.IsNpc && player.userID.IsSteamId())
            {
                UiDestroy(player);
            }
        }

        private void OnEntityKill(BasePlayer player)
        {
            if (player.IsValid() && !player.IsNpc && player.userID.IsSteamId())
            {
                UiDestroy(player);
            }
        }

        private void OnPlayerSleep(BasePlayer player) => UiDestroy(player);

        #endregion Oxide Hooks

        #region Commands

        private void CmdQuickSort(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                PlayerSendMessage(player, Lang(LangKeys.Error.NoPermission, player.UserIDString));
                return;
            }

            if (args == null || args.Length == 0)
            {
                PlayerSendMessage(player, Lang(LangKeys.Error.Syntax, player.UserIDString, _configData.GlobalSettings.Commands[0]));
                return;
            }

            PlayerData playerData = _storedData.PlayerData[player.userID];

            if (playerData == null)
            {
                playerData = new PlayerData()
                {
                    Enabled = _configData.GlobalSettings.DefaultEnabled,
                    AutoLootAll = _configData.GlobalSettings.AutoLootAll,
                    UiStyle = _configData.GlobalSettings.DefaultUiStyle,
                    Containers = _configData.GlobalSettings.Containers,
                };
                _storedData.PlayerData[player.userID] = playerData;
            }

            switch (args[0].ToLower())
            {
                case "on":
                    if (!playerData.Enabled)
                    {
                        playerData.Enabled = true;
                        SaveData();
                    }
                    PlayerSendMessage(player, Lang(LangKeys.Info.QuickSort, player.UserIDString, Lang(LangKeys.Format.Enabled, player.UserIDString)));
                    return;
                case "off":
                    if (playerData.Enabled)
                    {
                        playerData.Enabled = false;
                        SaveData();
                    }
                    PlayerSendMessage(player, Lang(LangKeys.Info.QuickSort, player.UserIDString, Lang(LangKeys.Format.Disabled, player.UserIDString)));
                    return;
                case "auto":
                    playerData.AutoLootAll = !playerData.AutoLootAll;
                    SaveData();
                    PlayerSendMessage(player, Lang(LangKeys.Info.AutoLootAll, player.UserIDString, playerData.AutoLootAll ? Lang(LangKeys.Format.Enabled, player.UserIDString) : Lang(LangKeys.Format.Disabled, player.UserIDString)));
                    return;
                case "s":
                case "style":
                    {
                        if (args.Length > 1)
                        {
                            switch (args[1].ToLower())
                            {
                                case "center":
                                case "lite":
                                case "right":
                                case "custom":
                                    {
                                        playerData.UiStyle = args[1].ToLower();
                                        SaveData();
                                        PlayerSendMessage(player, Lang(LangKeys.Info.Style, player.UserIDString, args[1].ToLower()));
                                        return;
                                    }
                            }
                        }
                        break;
                    }
                case "c":
                case "container":
                    {
                        if (args.Length > 1)
                        {
                            switch (args[1].ToLower())
                            {
                                case "main":
                                    {
                                        bool flag = false;
                                        if (args.Length > 2 && bool.TryParse(args[2], out flag))
                                        {
                                            playerData.Containers.Main = flag;
                                        }
                                        else
                                        {
                                            playerData.Containers.Main = !playerData.Containers.Main;
                                        }
                                        SaveData();

                                        PlayerSendMessage(player, Lang(LangKeys.Info.ContainerType, player.UserIDString, "main", playerData.Containers.Main ? Lang(LangKeys.Format.Enabled, player.UserIDString) : Lang(LangKeys.Format.Disabled, player.UserIDString)));
                                        return;
                                    }
                                case "wear":
                                    {
                                        bool flag = false;
                                        if (args.Length > 2 && bool.TryParse(args[2], out flag))
                                        {
                                            playerData.Containers.Wear = flag;
                                        }
                                        else
                                        {
                                            playerData.Containers.Wear = !playerData.Containers.Wear;
                                        }
                                        SaveData();

                                        PlayerSendMessage(player, Lang(LangKeys.Info.ContainerType, player.UserIDString, "wear", playerData.Containers.Wear ? Lang(LangKeys.Format.Enabled, player.UserIDString) : Lang(LangKeys.Format.Disabled, player.UserIDString)));
                                        return;
                                    }
                                case "belt":
                                    {
                                        bool flag = false;
                                        if (args.Length > 2 && bool.TryParse(args[2], out flag))
                                        {
                                            playerData.Containers.Belt = flag;
                                        }
                                        else
                                        {
                                            playerData.Containers.Belt = !playerData.Containers.Belt;
                                        }
                                        SaveData();

                                        PlayerSendMessage(player, Lang(LangKeys.Info.ContainerType, player.UserIDString, "belt", playerData.Containers.Belt ? Lang(LangKeys.Format.Enabled, player.UserIDString) : Lang(LangKeys.Format.Disabled, player.UserIDString)));
                                        return;
                                    }
                            }
                        }
                        break;
                    }
            }

            PlayerSendMessage(player, Lang(LangKeys.Error.Syntax, player.UserIDString, _configData.GlobalSettings.Commands[0]));
        }

        [ConsoleCommand("quicksortgui")]
        private void SortCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player.IsValid() && permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                try
                {
                    SortItems(player, arg.Args);
                }
                catch { }
            }
        }

        [ConsoleCommand("quicksortgui.lootall")]
        private void LootAllCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player.IsValid() && permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                timer.Once(_configData.GlobalSettings.LootAllDelay, () => LootAll(player));
            }
        }

        [ConsoleCommand("quicksortgui.lootdelay")]
        private void LootDelayCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player.IsValid() && player.IsAdmin)
            {
                int x;
                if (int.TryParse(arg.Args[0], out x))
                {
                    _configData.GlobalSettings.LootAllDelay = x;
                    SaveConfig();
                }
            }
        }

        #endregion Commands

        #region Loot Handling

        public void HandleLootEntity(BasePlayer player)
        {//We need this to wait for container initialization
            NextTick(() =>
            {
                if (permission.UserHasPermission(player.UserIDString, PermissionAutoLootAll)
                && AutoLootAll(player))
                {
                    return;
                }

                UiCreate(player);
            });
        }

        public bool AutoLootAll(BasePlayer player)
        {
            PlayerData playerData = GetPlayerData(player.userID);

            if (!playerData.AutoLootAll)
            {
                return false;
            }

            List<ItemContainer> containers = GetLootedInventory(player);

            if (containers == null)
            {
                return false;
            }

            int fullyLooted = 0;
            foreach (ItemContainer itemContainer in containers)
            {
                if (itemContainer.HasFlag(ItemContainer.Flag.NoItemInput))
                {
                    LootAll(player);
                    if (itemContainer.IsEmpty())
                    {
                        fullyLooted++;
                    }
                }
            }

            if (fullyLooted > 0 && fullyLooted == containers.Count)
            {
                player.EndLooting();
                // HACK: Send empty respawn information to fully close the player inventory (toggle backpack closed)
                player.ClientRPCPlayer(null, player, "OnRespawnInformation");
                return true;
            }

            return false;
        }

        public void LootAll(BasePlayer player)
        {
            List<ItemContainer> containers = GetLootedInventory(player);

            if (containers == null)
            {
                return;
            }

            if (!_configData.GlobalSettings.LootSleepers && IsOwnerSleeper(containers[0]))
            {
                return;
            }

            List<Item> itemsSelected = Pool.GetList<Item>();

            foreach (ItemContainer itemContainer in containers)
            {
                for (int i = 0; i < itemContainer.itemList.Count; i++)
                {
                    itemsSelected.Add(itemContainer.itemList[i]);
                }
            }

            itemsSelected.Sort((item1, item2) => item2.info.itemid.CompareTo(item1.info.itemid));

            foreach (Item item in itemsSelected)
            {
                int amount = item.amount;

                if (item.MoveToContainer(player.inventory.containerMain))
                {
                    _noteInv[0] = item.info.itemid;
                    _noteInv[1] = amount;
                    player.Command("note.inv", _noteInv);
                    continue;
                }

                if (item.MoveToContainer(player.inventory.containerBelt))
                {
                    _noteInv[0] = item.info.itemid;
                    _noteInv[1] = amount;
                    player.Command("note.inv", _noteInv);
                    continue;
                }

                int movedAmount = amount - item.amount;

                if (movedAmount > 0)
                {
                    _noteInv[0] = item.info.itemid;
                    _noteInv[1] = movedAmount;
                    player.Command("note.inv", _noteInv);
                }
            }

            Pool.FreeList(ref itemsSelected);
        }

        public void SortItems(BasePlayer player, string[] args)
        {
            if (!player.IsValid())
            {
                return;
            }

            PlayerContainers type = GetPlayerData(player.userID).Containers;
            ItemContainer container = GetLootedInventory(player)[0];
            ItemContainer playerMain = player.inventory?.containerMain;
            ItemContainer playerWear = player.inventory?.containerWear;
            ItemContainer playerBelt = player.inventory?.containerBelt;

            if (container == null || playerMain == null || container.HasFlag(ItemContainer.Flag.NoItemInput))
            {
                return;
            }

            List<Item> itemsSelected = Pool.GetList<Item>();

            if (args == null)
            {
                if (_configData.GlobalSettings.Containers.Main && (type == null || type.Main))
                {
                    for (int i = 0; i < playerMain.itemList.Count; i++)
                    {
                        itemsSelected.Add(playerMain.itemList[i]);
                    }
                }

                if (playerWear != null && _configData.GlobalSettings.Containers.Wear && type != null && type.Wear)
                {
                    for (int i = 0; i < playerWear.itemList.Count; i++)
                    {
                        itemsSelected.Add(playerWear.itemList[i]);
                    }
                }

                if (playerBelt != null && _configData.GlobalSettings.Containers.Belt && type != null && type.Belt)
                {
                    for (int i = 0; i < playerBelt.itemList.Count; i++)
                    {
                        itemsSelected.Add(playerBelt.itemList[i]);
                    }
                }
            }
            else
            {
                if (args[0].Equals("existing"))
                {
                    if (_configData.GlobalSettings.Containers.Main && (type == null || type.Main))
                    {
                        AddExistingItems(itemsSelected, playerMain, container);
                    }

                    if (playerWear != null && _configData.GlobalSettings.Containers.Wear && type != null && type.Wear)
                    {
                        AddExistingItems(itemsSelected, playerWear, container);
                    }

                    if (playerBelt != null && _configData.GlobalSettings.Containers.Belt && type != null && type.Belt)
                    {
                        AddExistingItems(itemsSelected, playerBelt, container);
                    }
                }
                else
                {
                    ItemCategory category = StringToItemCategory(args[0]);
                    if (_configData.GlobalSettings.Containers.Main && (type == null || type.Main))
                    {
                        AddItemsOfType(itemsSelected, playerMain, category);
                    }

                    if (playerWear != null && _configData.GlobalSettings.Containers.Wear && type != null && type.Wear)
                    {
                        AddItemsOfType(itemsSelected, playerWear, category);
                    }

                    if (playerBelt != null && _configData.GlobalSettings.Containers.Belt && type != null && type.Belt)
                    {
                        AddItemsOfType(itemsSelected, playerBelt, category);
                    }
                }
            }

            itemsSelected.Sort((item1, item2) => item2.info.itemid.CompareTo(item1.info.itemid));

            MoveItems(itemsSelected, container);

            Pool.FreeList(ref itemsSelected);
        }

        public void AddExistingItems(List<Item> list, ItemContainer primary, ItemContainer secondary)
        {
            if (primary == null || secondary == null)
            {
                return;
            }

            foreach (Item primaryItem in primary.itemList)
            {
                foreach (Item secondaryItem in secondary.itemList)
                {
                    if (primaryItem.info.itemid == secondaryItem.info.itemid)
                    {
                        list.Add(primaryItem);
                        break;
                    }
                }
            }
        }

        public void AddItemsOfType(List<Item> list, ItemContainer container, ItemCategory category)
        {
            foreach (Item item in container.itemList)
            {
                if (item.info.category == category)
                {
                    list.Add(item);
                }
            }
        }

        public List<ItemContainer> GetLootedInventory(BasePlayer player)
        {
            PlayerLoot playerLoot = player.inventory.loot;

            if (playerLoot != null && playerLoot.IsLooting())
            {
                List<ItemContainer> containers = playerLoot.containers;

                foreach (ItemContainer container in containers)
                {
                    BaseEntity entity = container.entityOwner;

                    if (entity.IsValid() && IsContainerExcluded(player, entity))
                    {
                        return null;
                    }
                }

                return containers;
            }

            return null;
        }

        public void MoveItems(IEnumerable<Item> items, ItemContainer to)
        {
            foreach (Item item in items)
            {
                item.MoveToContainer(to);
            }
        }

        public ItemCategory StringToItemCategory(string categoryName)
        {
            string[] categoryNames = Enum.GetNames(typeof(ItemCategory));

            for (int i = 0; i < categoryNames.Length; i++)
            {
                if (categoryName.ToLower().Equals(categoryNames[i].ToLower()))
                {
                    return (ItemCategory)i;
                }
            }

            return (ItemCategory)categoryNames.Length;
        }

        public bool IsContainerExcluded(BasePlayer player, BaseEntity entity)
        {
            if (entity is ShopFront || entity is BigWheelBettingTerminal || entity is NPCVendingMachine)
            {
                return true;
            }

            if (entity is VendingMachine)
            {
                VendingMachine vendingMachine = (VendingMachine)entity;

                if (!vendingMachine.PlayerBehind(player))
                {
                    return true;
                }
            }

            if (entity is DropBox)
            {
                DropBox dropBox = (DropBox)entity;

                if (!dropBox.PlayerBehind(player))
                {
                    return true;
                }
            }

            if (entity is IItemContainerEntity)
            {
                IItemContainerEntity container = (IItemContainerEntity)entity;

                if (container.inventory.IsLocked())
                {
                    return true;
                }
            }

            if (_cacheContainersExcluded.Contains(entity.prefabID))
            {
                return true;
            }

            if (Interface.CallHook("QuickSortExcluded", player, entity) != null)
            {
                return true;
            }

            return false;
        }

        public static bool IsOwnerSleeper(ItemContainer container)
        {
            BasePlayer playerOwner = container.playerOwner;
            if ((object)playerOwner == null || !IsPlayerContainer(container, playerOwner))
                return false;

            return playerOwner.IsSleeping();
        }

        public static bool IsPlayerContainer(ItemContainer container, BasePlayer player)
        {
            return player.inventory.containerMain == container
                || player.inventory.containerBelt == container
                || player.inventory.containerWear == container;
        }

        #endregion Loot Handling

        #region Helpers

        public void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnLootEntity));
            Unsubscribe(nameof(OnLootPlayer));
            Unsubscribe(nameof(OnPlayerLootEnd));
            Unsubscribe(nameof(OnPlayerSleep));
        }

        public void SubscribeHooks()
        {
            //Subscribe(nameof(OnEntityDeath));
            //Subscribe(nameof(OnEntityKill));
            Subscribe(nameof(OnLootEntity));
            Subscribe(nameof(OnLootPlayer));
            Subscribe(nameof(OnPlayerLootEnd));
            //Subscribe(nameof(OnPlayerSleep));
        }

        public void RegisterPermissions()
        {
            permission.RegisterPermission(PermissionAutoLootAll, this);
            permission.RegisterPermission(PermissionLootAll, this);
            permission.RegisterPermission(PermissionUse, this);
        }

        public void AddCommands()
        {
            if (_configData.GlobalSettings.Commands.Length == 0)
            {
                _configData.GlobalSettings.Commands = new[] { "qs" };
                SaveConfig();
            }

            foreach (string command in _configData.GlobalSettings.Commands)
            {
                cmd.AddChatCommand(command, this, nameof(CmdQuickSort));
            }
        }

        public void CreateCache()
        {
            _defaultPlayerData = new PlayerData()
            {
                Enabled = _configData.GlobalSettings.DefaultEnabled,
                AutoLootAll = _configData.GlobalSettings.AutoLootAll,
                UiStyle = _configData.GlobalSettings.DefaultUiStyle,
                Containers = _configData.GlobalSettings.Containers,
            };

            foreach (string container in _configData.GlobalSettings.ContainersExcluded)
            {
                _cacheContainersExcluded.Add(StringPool.Get(container));
            }

            int id = 0;
            foreach (string language in lang.GetLanguages(this))
            {
                _cacheLanguageIDs[language] = ++id;
            }
        }

        public void PlayerSendMessage(BasePlayer player, string message)
        {
            player.SendConsoleCommand("chat.add", 2, _configData.GlobalSettings.SteamIDIcon, string.IsNullOrEmpty(Lang(LangKeys.Format.Prefix, player.UserIDString)) ? message : Lang(LangKeys.Format.Prefix, player.UserIDString) + message);
        }

        public int GetUiId(BasePlayer player, PlayerData playerData)
        {
            int id = 0;
            switch (playerData.UiStyle)
            {
                case "center":
                    id += 1;
                    break;
                case "lite":
                    id += 2;
                    break;
                case "right":
                    id += 3;
                    break;
                case "custom":
                    id += 4;
                    break;
            }
            //Max. value = 2
            id *= 10;
            if (permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                id += 1;
            }
            //Max. value = 7117
            id *= 10000;
            id += _cacheLanguageIDs[lang.GetLanguage(player.UserIDString)];

            return id;
        }

        #endregion Helpers

        #region User Interface

        public void UiCreate(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                return;
            }

            PlayerData playerData = GetPlayerData(player.userID);

            if (!playerData.Enabled)
            {
                return;
            }

            UiDestroy(player);

            if (!_uiViewers.Add(player.userID))
            {
                return;
            }

            int uiId = GetUiId(player, playerData);
            string cachedJson = _cacheUiJson[uiId];

            if (string.IsNullOrWhiteSpace(cachedJson))
            {
                switch (playerData.UiStyle)
                {
                    case "center":
                        cachedJson = UiGetJsonCenter(player);
                        break;
                    case "lite":
                        cachedJson = UiGetJsonLite(player);
                        break;
                    case "right":
                        cachedJson = UiGetJsonRight(player);
                        break;
                    case "custom":
                        cachedJson = UiGetJsonCustom(player);
                        break;
                }
                _cacheUiJson[uiId] = cachedJson;
            }

            CuiHelper.AddUi(player, cachedJson);
        }

        public void UiDestroy(BasePlayer player)
        {
            if (!_uiViewers.Remove(player.userID))
                return;

            CuiHelper.DestroyUi(player, GUIPanelName);
        }

        #region UI Custom

        public string UiGetJsonCustom(BasePlayer player)
        {
            CuiElementContainer elements = new CuiElementContainer();
            ConfigData.UiConfiguration customUISettings = _configData.CustomUISettings;

            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = customUISettings.Color },
                RectTransform = {
                    AnchorMin = customUISettings.AnchorsMin,
                    AnchorMax = customUISettings.AnchorsMax,
                    OffsetMin = customUISettings.OffsetsMin,
                    OffsetMax = customUISettings.OffsetsMax
                }
            }, "Hud.Menu", GUIPanelName);

            //left
            elements.Add(new CuiLabel
            {
                Text = { Text = Lang(LangKeys.Format.Deposit, player.UserIDString), FontSize = customUISettings.TextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor },
                RectTransform = { AnchorMin = "0.02 0.8", AnchorMax = "0.35 1" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui existing", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.02 0.6", AnchorMax = "0.35 0.8" },
                Text = { Text = Lang(LangKeys.Format.Existing, player.UserIDString), FontSize = customUISettings.TextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.02 0.35", AnchorMax = "0.35 0.55" },
                Text = { Text = Lang(LangKeys.Format.All, player.UserIDString), FontSize = customUISettings.TextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            if (permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                elements.Add(new CuiButton
                {
                    Button = { Command = "quicksortgui.lootall", Color = customUISettings.LootAllColor },
                    RectTransform = { AnchorMin = "0.02 0.05", AnchorMax = "0.35 0.3" },
                    Text = { Text = Lang(LangKeys.Format.LootAll, player.UserIDString), FontSize = customUISettings.TextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
                }, panel);
            }

            //center
            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui weapon", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.818", AnchorMax = "0.65 0.949" },
                Text = { Text = Lang(LangKeys.Format.Weapons, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui ammunition", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.664", AnchorMax = "0.65 0.796" },
                Text = { Text = Lang(LangKeys.Format.Ammo, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui medical", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.511", AnchorMax = "0.65 0.642" },
                Text = { Text = Lang(LangKeys.Format.Medical, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui attire", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.358", AnchorMax = "0.65 0.489" },
                Text = { Text = Lang(LangKeys.Format.Attire, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui resources", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.204", AnchorMax = "0.65 0.336" },
                Text = { Text = Lang(LangKeys.Format.Resources, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui component", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.37 0.051", AnchorMax = "0.65 0.182" },
                Text = { Text = Lang(LangKeys.Format.Components, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            //right
            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui construction", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.818", AnchorMax = "0.98 0.949" },
                Text = { Text = Lang(LangKeys.Format.Construction, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui items", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.664", AnchorMax = "0.98 0.796" },
                Text = { Text = Lang(LangKeys.Format.Deployables, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui tool", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.511", AnchorMax = "0.98 0.642" },
                Text = { Text = Lang(LangKeys.Format.Tools, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui food", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.358", AnchorMax = "0.82 0.489" },
                Text = { Text = Lang(LangKeys.Format.Food, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui misc", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.83 0.358", AnchorMax = "0.98 0.489" },
                Text = { Text = Lang(LangKeys.Format.Misc, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui traps", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.204", AnchorMax = "0.98 0.336" },
                Text = { Text = Lang(LangKeys.Format.Traps, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui electrical", Color = customUISettings.ButtonsColor },
                RectTransform = { AnchorMin = "0.67 0.051", AnchorMax = "0.98 0.182" },
                Text = { Text = Lang(LangKeys.Format.Electrical, player.UserIDString), FontSize = customUISettings.CategoriesTextSize, Align = TextAnchor.MiddleCenter, Color = customUISettings.TextColor }
            }, panel);

            return CuiHelper.ToJson(elements);
        }

        #endregion UI Custom

        #region UI Center

        public string UiGetJsonCenter(BasePlayer player)
        {
            CuiElementContainer elements = new CuiElementContainer();

            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.33" },
                RectTransform = {
                    AnchorMin = "0.5 0.0",
                    AnchorMax = "0.5 0.0",
                    OffsetMin = "-198 472",
                    OffsetMax = "182 626"
                }
            }, "Hud.Menu", GUIPanelName);

            //left
            elements.Add(new CuiLabel
            {
                Text = { Text = Lang(LangKeys.Format.Deposit, player.UserIDString), FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" },
                RectTransform = { AnchorMin = "0.02 0.8", AnchorMax = "0.35 1" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui existing", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.02 0.6", AnchorMax = "0.35 0.8" },
                Text = { Text = Lang(LangKeys.Format.Existing, player.UserIDString), FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.02 0.35", AnchorMax = "0.35 0.55" },
                Text = { Text = Lang(LangKeys.Format.All, player.UserIDString), FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            if (permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                elements.Add(new CuiButton
                {
                    Button = { Command = "quicksortgui.lootall", Color = "0.41 0.50 0.25 0.8" },
                    RectTransform = { AnchorMin = "0.02 0.05", AnchorMax = "0.35 0.3" },
                    Text = { Text = Lang(LangKeys.Format.LootAll, player.UserIDString), FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
                }, panel);
            }

            //center
            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui weapon", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.818", AnchorMax = "0.65 0.949" },
                Text = { Text = Lang(LangKeys.Format.Weapons, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui ammunition", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.664", AnchorMax = "0.65 0.796" },
                Text = { Text = Lang(LangKeys.Format.Ammo, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui medical", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.511", AnchorMax = "0.65 0.642" },
                Text = { Text = Lang(LangKeys.Format.Medical, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui attire", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.358", AnchorMax = "0.65 0.489" },
                Text = { Text = Lang(LangKeys.Format.Attire, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui resources", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.204", AnchorMax = "0.65 0.336" },
                Text = { Text = Lang(LangKeys.Format.Resources, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui component", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.37 0.051", AnchorMax = "0.65 0.182" },
                Text = { Text = Lang(LangKeys.Format.Components, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            //right
            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui construction", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.818", AnchorMax = "0.98 0.949" },
                Text = { Text = Lang(LangKeys.Format.Construction, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui items", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.664", AnchorMax = "0.98 0.796" },
                Text = { Text = Lang(LangKeys.Format.Deployables, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui tool", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.511", AnchorMax = "0.98 0.642" },
                Text = { Text = Lang(LangKeys.Format.Tools, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui food", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.358", AnchorMax = "0.82 0.489" },
                Text = { Text = Lang(LangKeys.Format.Food, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui misc", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.83 0.358", AnchorMax = "0.98 0.489" },
                Text = { Text = Lang(LangKeys.Format.Misc, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui traps", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.204", AnchorMax = "0.98 0.336" },
                Text = { Text = Lang(LangKeys.Format.Traps, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui electrical", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.67 0.051", AnchorMax = "0.98 0.182" },
                Text = { Text = Lang(LangKeys.Format.Electrical, player.UserIDString), FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            return CuiHelper.ToJson(elements);
        }

        #endregion UI Center

        #region UI Lite

        public string UiGetJsonLite(BasePlayer player)
        {
            CuiElementContainer elements = new CuiElementContainer();

            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = {
                    AnchorMin = "0.5 0.0",
                    AnchorMax = "0.5 0.0",
                    OffsetMin = "-56 340",
                    OffsetMax = "179 359"
                }
            }, "Hud.Menu", GUIPanelName);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui existing", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.44 1" },
                Text = { Text = Lang(LangKeys.Format.Existing, player.UserIDString), FontSize = 13, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.46 0", AnchorMax = "0.60 1" },
                Text = { Text = Lang(LangKeys.Format.All, player.UserIDString), FontSize = 13, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            if (permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                elements.Add(new CuiButton
                {
                    Button = { Command = "quicksortgui.lootall", Color = "0.41 0.50 0.25 0.8" },
                    RectTransform = { AnchorMin = "0.62 0", AnchorMax = "1 1" },
                    Text = { Text = Lang(LangKeys.Format.LootAll, player.UserIDString), FontSize = 13, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
                }, panel);
            }

            return CuiHelper.ToJson(elements);
        }

        #endregion UI Lite

        #region UI Right

        public string UiGetJsonRight(BasePlayer player)
        {
            CuiElementContainer elements = new CuiElementContainer();

            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.3 0.3 0.3 1" },
                RectTransform = {
                    AnchorMin = "0.5 1.0",
                    AnchorMax = "0.5 1.0",
                    OffsetMin = "192.5 -88.7",
                    OffsetMax = "572.5 0"
                }
            }, "Hud.Menu", GUIPanelName);

            /*left
            elements.Add(new CuiLabel
            {
                Text = { Text = Lang(LangKeys.Format.Deposit, player.UserIDString), FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" },
                RectTransform = { AnchorMin = "0.02 0.8", AnchorMax = "0.35 1" }
            }, panel);*/

            //First column
            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui weapon", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.0 0.765", AnchorMax = "0.239 0.98" },
                Text = { Text = Lang(LangKeys.Format.Weapons, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui existing", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.0 0.51", AnchorMax = "0.239 0.725" },
                Text = { Text = Lang(LangKeys.Format.Existing, player.UserIDString), FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.0 0.255", AnchorMax = "0.239 0.47" },
                Text = { Text = Lang(LangKeys.Format.All, player.UserIDString), FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            if (permission.UserHasPermission(player.UserIDString, PermissionLootAll))
            {
                elements.Add(new CuiButton
                {
                    Button = { Command = "quicksortgui.lootall", Color = "0.41 0.50 0.25 1" },
                    RectTransform = { AnchorMin = "0.0 0.0", AnchorMax = "0.239 0.215" },
                    Text = { Text = Lang(LangKeys.Format.LootAll, player.UserIDString), FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
                }, panel);
            }

            //Second column

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui ammunition", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.249 0.765", AnchorMax = "0.488 0.98" },
                Text = { Text = Lang(LangKeys.Format.Ammo, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui medical", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.249 0.51", AnchorMax = "0.488 0.725" },
                Text = { Text = Lang(LangKeys.Format.Medical, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui attire", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.249 0.255", AnchorMax = "0.488 0.47" },
                Text = { Text = Lang(LangKeys.Format.Attire, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui resources", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.249 0.0", AnchorMax = "0.488 0.215" },
                Text = { Text = Lang(LangKeys.Format.Resources, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            //Third column

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui component", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.498 0.765", AnchorMax = "0.737 0.98" },
                Text = { Text = Lang(LangKeys.Format.Components, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui construction", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.498 0.51", AnchorMax = "0.737 0.725" },
                Text = { Text = Lang(LangKeys.Format.Construction, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui items", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.498 0.255", AnchorMax = "0.737 0.47" },
                Text = { Text = Lang(LangKeys.Format.Deployables, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui tool", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.498 0.0", AnchorMax = "0.737 0.215" },
                Text = { Text = Lang(LangKeys.Format.Tools, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            //Fourth column

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui food", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.747 0.765", AnchorMax = "0.997 0.98" },
                Text = { Text = Lang(LangKeys.Format.Food, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui misc", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.747 0.51", AnchorMax = "0.997 0.725" },
                Text = { Text = Lang(LangKeys.Format.Misc, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui traps", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.747 0.255", AnchorMax = "0.997 0.47" },
                Text = { Text = Lang(LangKeys.Format.Traps, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            elements.Add(new CuiButton
            {
                Button = { Command = "quicksortgui electrical", Color = "0.75 0.43 0.18 0.8" },
                RectTransform = { AnchorMin = "0.747 0.0", AnchorMax = "0.997 0.215" },
                Text = { Text = Lang(LangKeys.Format.Electrical, player.UserIDString), FontSize = 10, Align = TextAnchor.MiddleCenter, Color = "0.77 0.92 0.67 0.8" }
            }, panel);

            return CuiHelper.ToJson(elements);
        }

        #endregion UI Right

        #endregion User Interface
    }
}

// --- End of file: QuickSort.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quick-smelt ---
// --- Original File Path: Q/QuickSmelt/QuickSmelt.cs ---

ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Quick Smelt", "misticos", "5.1.5")]
    [Description("Increases the speed of the furnace smelting")]
    class QuickSmelt : RustPlugin
    {
        #region Variables

        private static QuickSmelt _instance;

        private const string PermissionUse = "quicksmelt.use";

        #endregion

        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Use Permission")]
            public bool UsePermission = true;

            [JsonProperty(PropertyName = "Speed Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> SpeedMultipliers = new Dictionary<string, float>
            {
                { "global", 1.0f },
                { "furnace.shortname", 1.0f }
            };

            [JsonProperty(PropertyName = "Fuel Usage Speed Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> FuelSpeedMultipliers = new Dictionary<string, float>
            {
                { "global", 1.0f },
                { "furnace.shortname", 1.0f }
            };

            [JsonProperty(PropertyName = "Fuel Usage Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> FuelUsageMultipliers = new Dictionary<string, int>
            {
                { "global", 1 },
                { "furnace.shortname", 1 }
            };

            [JsonProperty(PropertyName = "Output Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, Dictionary<string, float>> OutputMultipliers =
                new Dictionary<string, Dictionary<string, float>>
                {
                    {
                        "global", new Dictionary<string, float>
                        {
                            { "global", 1.0f }
                        }
                    },
                    {
                        "furnace.shortname", new Dictionary<string, float>
                        {
                            { "item.shortname", 1.0f }
                        }
                    }
                };

            [JsonProperty(PropertyName = "Whitelist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<string>> Whitelist = new Dictionary<string, List<string>>
            {
                {
                    "global", new List<string>
                    {
                        "item.shortname"
                    }
                },
                {
                    "furnace.shortname", new List<string>
                    {
                        "item.shortname"
                    }
                }
            };

            [JsonProperty(PropertyName = "Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, List<string>> Blacklist = new Dictionary<string, List<string>>
            {
                {
                    "global", new List<string>
                    {
                        "item.shortname"
                    }
                },
                {
                    "furnace.shortname", new List<string>
                    {
                        "item.shortname"
                    }
                }
            };

            [JsonProperty(PropertyName = "Smelting Frequencies (Smelt items every N smelting ticks)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> SmeltingFrequencies = new Dictionary<string, int>
            {
                { "global", 1 },
                { "furnace.shortname", 1 }
            };

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void Unload()
        {
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
            PrintDebug($"Processing BaseOven(s).. Amount: {ovens.Length}.");

            for (var i = 0; i < ovens.Length; i++)
            {
                var oven = ovens[i];
                var component = oven.GetComponent<FurnaceController>();

                if (oven.IsOn())
                {
                    PrintDebug("Oven is on. Restarted cooking");
                    component.StopCooking();
                    oven.StartCooking();
                }

                UnityEngine.Object.Destroy(component);
            }

            PrintDebug("Done.");
        }

        private void OnServerInitialized()
        {
            _instance = this;
            permission.RegisterPermission(PermissionUse, this);

            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
            PrintDebug($"Processing BaseOven(s).. Amount: {ovens.Length}.");

            for (var i = 0; i < ovens.Length; i++)
            {
                var oven = ovens[i];

                OnEntitySpawned(oven);
            }

            timer.Once(1f, () =>
            {
                for (var i = 0; i < ovens.Length; i++)
                {
                    var oven = ovens[i];
                    if (oven == null)
                    {
                        continue;
                    }

                    var component = oven.gameObject.GetComponent<FurnaceController>();

                    if (oven.IsDestroyed || !oven.IsOn() || !CanUse(oven.OwnerID))
                        continue;

                    component.StartCooking();
                }
            });
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            var oven = entity as BaseOven;
            if (oven == null)
                return;

            oven.gameObject.AddComponent<FurnaceController>();
        }

        private object OnOvenToggle(StorageContainer oven, BasePlayer player)
        {
            if (oven is BaseFuelLightSource || oven.needsBuildingPrivilegeToUse && !player.CanBuild())
                return null;

            PrintDebug("OnOvenToggle called");
            var component = oven.gameObject.GetComponent<FurnaceController>();
            var canUse = CanUse(oven.OwnerID) || CanUse(player.userID);
            if (oven.IsOn())
            {
                component.StopCooking();
            }
            else
            {
                if (canUse)
                    component.StartCooking();
                else
                {
                    PrintDebug($"No permission ({player.userID})");
                    return null;
                }
            }

            return false;
        }

        #endregion

        #region Helpers

        private bool CanUse(ulong id) =>
            !_config.UsePermission || permission.UserHasPermission(id.ToString(), PermissionUse);

        private static void PrintDebug(string message)
        {
            if (_config.Debug)
                Debug.Log($"DEBUG ({_instance.Name}) > " + message);
        }

        #endregion

        #region Controller

        public class FurnaceController : FacepunchBehaviour
        {
            private int _ticks;

            private BaseOven _oven;

            private BaseOven Furnace
            {
                get
                {
                    if (_oven == null)
                        _oven = GetComponent<BaseOven>();

                    return _oven;
                }
            }

            private float _speedMultiplier;

            private float _fuelSpeedMultiplier;

            private int _fuelUsageMultiplier;

            private int _smeltingFrequency;

            private Dictionary<string, float> _outputModifiers;

            private float OutputMultiplier(string shortname)
            {
                float modifier;
                if (_outputModifiers == null || !_outputModifiers.TryGetValue(shortname, out modifier) &&
                    !_outputModifiers.TryGetValue("global", out modifier))
                    modifier = 1.0f;

                PrintDebug($"{shortname} modifier: {modifier}");
                return modifier;
            }

            private List<string> _blacklist;
            private List<string> _whitelist;

            private bool? IsAllowed(string shortname)
            {
                if (_blacklist != null && _blacklist.Contains(shortname))
                    return false;

                if (_whitelist != null && _whitelist.Contains(shortname))
                    return true;

                return null;
            }

            private void Awake()
            {
                // Well, sorry for my complicated code. But that should work faster! :)

                float modifierF; // float modifier
                int modifierI; // int modifier

                if (!_config.SpeedMultipliers.TryGetValue(Furnace.ShortPrefabName, out modifierF) &&
                    !_config.SpeedMultipliers.TryGetValue("global", out modifierF))
                    modifierF = 1.0f;

                _speedMultiplier = 0.5f / modifierF;

                if (!_config.FuelSpeedMultipliers.TryGetValue(Furnace.ShortPrefabName, out modifierF) &&
                    !_config.FuelSpeedMultipliers.TryGetValue("global", out modifierF))
                    modifierF = 1.0f;

                _fuelSpeedMultiplier = modifierF;

                if (!_config.FuelUsageMultipliers.TryGetValue(Furnace.ShortPrefabName, out modifierI) &&
                    !_config.FuelUsageMultipliers.TryGetValue("global", out modifierI))
                    modifierI = 1;

                _fuelUsageMultiplier = modifierI;

                if (!_config.SmeltingFrequencies.TryGetValue(Furnace.ShortPrefabName, out modifierI) &&
                    !_config.SmeltingFrequencies.TryGetValue("global", out modifierI))
                    modifierI = 1;

                _smeltingFrequency = modifierI;

                if (!_config.OutputMultipliers.TryGetValue(Furnace.ShortPrefabName, out _outputModifiers) &&
                    !_config.OutputMultipliers.TryGetValue("global", out _outputModifiers))
                {
                    // ignored
                }

                if ((!_config.Blacklist.TryGetValue(Furnace.ShortPrefabName, out _blacklist) &&
                     !_config.Blacklist.TryGetValue("global", out _blacklist)) &
                    (!_config.Whitelist.TryGetValue(Furnace.ShortPrefabName, out _whitelist) &&
                     !_config.Whitelist.TryGetValue("global", out _whitelist)))
                {
                    // ignored
                }
            }

            private Item FindBurnable()
            {
                if (Furnace.inventory == null)
                    return null;

                var burnable = Interface.Call<Item>("OnFindBurnable", _oven);
                if (burnable != null)
                {
                    return burnable;
                }

                foreach (var item in Furnace.inventory.itemList)
                {
                    if (!_oven.IsBurnableItem(item))
                        continue;

                    return item;
                }

                return null;
            }

            public void Cook()
            {
                var itemBurnable = FindBurnable();
                if (Interface.CallHook("OnOvenCook", this, itemBurnable) != null)
                {
                    return;
                }

                if (itemBurnable == null)
                {
                    StopCooking();
                    return;
                }

                SmeltItems();

                foreach (var itemCooking in _oven.inventory.itemList)
                {
                    if (itemCooking.position >= _oven._inputSlotIndex &&
                        itemCooking.position < _oven._inputSlotIndex + _oven.inputSlots &&
                        !itemCooking.HasFlag(global::Item.Flag.Cooking))
                    {
                        itemCooking.SetFlag(global::Item.Flag.Cooking, true);
                        itemCooking.MarkDirty();
                    }
                }

                var slot = Furnace.GetSlot(BaseEntity.Slot.FireMod);
                if (slot)
                {
                    slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
                }

                var burnable = itemBurnable.info.GetComponent<ItemModBurnable>();
                itemBurnable.fuel -= 0.5f * (Furnace.cookingTemperature / 200f) * _fuelSpeedMultiplier;

                if (!itemBurnable.HasFlag(global::Item.Flag.OnFire))
                {
                    itemBurnable.SetFlag(global::Item.Flag.OnFire, true);
                    itemBurnable.MarkDirty();
                }

                if (itemBurnable.fuel <= 0f)
                {
                    ConsumeFuel(itemBurnable, burnable);
                }

                _ticks++;

                Interface.CallHook("OnOvenCooked", this, itemBurnable, slot);
            }

            private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (Interface.CallHook("OnFuelConsume", _oven, fuel, burnable) != null)
                {
                    return;
                }

                if (Furnace.allowByproductCreation && burnable.byproductItem != null &&
                    Random.Range(0f, 1f) > burnable.byproductChance)
                {
                    var def = burnable.byproductItem;
                    var item = ItemManager.Create(def,
                        (int)(burnable.byproductAmount * OutputMultiplier(def.shortname))); // It's fuel multiplier

                    if (!item.MoveToContainer(Furnace.inventory))
                    {
                        StopCooking();
                        item.Drop(Furnace.inventory.dropPosition, Furnace.inventory.dropVelocity);
                    }
                }

                if (fuel.amount <= _fuelUsageMultiplier)
                {
                    fuel.Remove();
                    return;
                }

                fuel.UseItem(_fuelUsageMultiplier);
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();

                Interface.CallHook("OnFuelConsumed", _oven, fuel, burnable);
            }

            private void SmeltItems()
            {
                if (_ticks % _smeltingFrequency != 0)
                    return;

                for (var i = 0; i < Furnace.inventory.itemList.Count; i++)
                {
                    var item = Furnace.inventory.itemList[i];
                    if (item == null || !item.IsValid())
                        continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null)
                        continue;

                    var isAllowed = IsAllowed(item.info.shortname);
                    if (isAllowed != null &&
                        !isAllowed.Value) // Allowed is false? Okay, no problem. Don't cook this item
                        continue;

                    var temperature = item.temperature;
                    if (!cookable.CanBeCookedByAtTemperature(temperature) && isAllowed == null)
                    {
                        if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking))
                            continue;

                        item.SetFlag(global::Item.Flag.Cooking, false);
                        item.MarkDirty();
                        continue;
                    }

                    if (cookable.cookTime > 0 && _ticks * 1f / _smeltingFrequency % cookable.cookTime > 0)
                        continue;

                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }

                    // var targetPosition = item.position + 1;
                    var amountConsumed = (int)_oven.GetSmeltingSpeed();
                    amountConsumed = Math.Min(amountConsumed, item.amount);
                    if (item.amount > amountConsumed)
                    {
                        item.amount -= amountConsumed;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                    }

                    if (cookable.becomeOnCooked == null)
                        continue;

                    var itemProduced = ItemManager.Create(cookable.becomeOnCooked,
                        (int)(cookable.amountOfBecome * amountConsumed *
                              OutputMultiplier(cookable.becomeOnCooked.shortname)));

                    if (itemProduced == null || itemProduced.MoveToContainer(item.parent))
                        continue;

                    itemProduced.Drop(item.parent.dropPosition, item.parent.dropVelocity);

                    StopCooking();
                }
            }

            public void StartCooking()
            {
                if (FindBurnable() == null)
                {
                    PrintDebug("No burnable.");
                    return;
                }

                StopCooking();

                PrintDebug("Starting cooking..");
                Furnace.inventory.temperature = Furnace.cookingTemperature;
                Furnace.UpdateAttachmentTemperature();

                PrintDebug($"Speed Multiplier: {_speedMultiplier}");
                Furnace.InvokeRepeating(Cook, _speedMultiplier, _speedMultiplier);
                Furnace.SetFlag(BaseEntity.Flags.On, true);
            }

            public void StopCooking()
            {
                PrintDebug("Stopping cooking..");
                Furnace.CancelInvoke(Cook);
                Furnace.StopCooking();
            }
        }

        #endregion
    }
}

// --- End of file: QuickSmelt.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quarry-stop-checker ---
// --- Original File Path: Q/QuarryStopChecker/QuarryStopChecker.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Quarry Stop Checker", "OldGuyWoody", "1.0.2")]
    [Description("Stop degenerates from turning off quarries they don't have access to")]
    public class QuarryStopChecker: RustPlugin
    {
        #region Fields
        [PluginReference] private readonly Plugin Slap;
        private PluginConfig config;
        
        #endregion

        #region Hooks
        
        private void OnServerInitialized()
        {
            config = Config.ReadObject<PluginConfig>();
            if (config.EnableSlapOnCaught && Slap == null)
                PrintError("Slap is not loaded, get it at https://umod.org/plugins/slap");
        }

        private void OnQuarryToggled(MiningQuarry quarry)
        {
            if (quarry.IsEngineOn())
                return;

            var codelock = quarry.GetComponentInChildren<CodeLock>();
            if (codelock == null)
                return;

            var owner = covalence.Players.FindPlayerById(quarry.OwnerID.ToString())?.Name ?? "unknown";
            var position = quarry.ServerPosition;
            BaseEntity[] results = new BaseEntity[25];
            var by = BaseEntity.Query.Server.GetInSphere(position, 0.75f, results,
                entity =>
                {
                    BasePlayer player = entity as BasePlayer;
                    return player != null;
                });

            var near = "";
            var i = 0;
            var whitelisted = false;
            var nearbyPlayers = new List<BasePlayer>();

            while (results[i] != null)
            {
                var player = (BasePlayer)results[i++];
                near += (player.displayName + " ");
                if (codelock.whitelistPlayers.Contains(player.userID))
                {
                    whitelisted = true;
                }
                else
                {
                    nearbyPlayers.Add(player);
                }

            }

            if (config.EnableServerLog)
            {
                Puts("Quarry owned by " + owner + " at " + position + " turned off. Whitelisted player nearby? " + whitelisted + ". Nearby players: " + near);
            }

            if (!whitelisted)
            {
                if (config.EnableSlapOnCaught && Slap != null)
                {
                    nearbyPlayers.ForEach(
                        p =>
                        {
                            Slap?.Call("SlapPlayer", p.IPlayer);
                            Message(p, "SlapMessage");
                        });
                }

                quarry.EngineSwitch(true);
                if (config.EnableChatOnCaught)
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        Message(player, "NoStopWarn", near, owner);
                    }
                }
            }
        }

        #endregion

        #region Localization 1.1.1

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NoStopWarn",  "{0}tried to turn off quarry belonging to {1}" },
                { "SlapMessage", "Don't turn off other people's quarries. Slap you in the face" }
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }
        
        #endregion

        #region Configuration
        
        private class PluginConfig
        {
            public bool EnableChatOnCaught;
            public bool EnableSlapOnCaught;
            public bool EnableServerLog;
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                EnableChatOnCaught = false,
                EnableSlapOnCaught = false,
                EnableServerLog = true
            };
        }
    }
    
    #endregion
}

// --- End of file: QuarryStopChecker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quick-loadouts ---
// --- Original File Path: Q/QuickLoadouts/QuickLoadouts.cs ---

ï»¿using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("QuickLoadouts", "carny666", "1.0.1", ResourceId = 2731)]
    class QuickLoadouts : RustPlugin
    {
        const string adminPermission = "QuickLoadouts.admin";
        const string allPermission = "QuickLoadouts.all";
        const string loadoutFileName = "QuickLoadouts.loadouts";

        const string AdminCommandChatConsole = "quickloadout";
        const string UseCommandChatConsole = "useloadout";

        Loadouts loadouts = new Loadouts();

        void Init()
        {
            try
            {
                loadouts = Interface.Oxide.DataFileSystem.ReadObject<Loadouts>(loadoutFileName);

                permission.RegisterPermission(adminPermission, this);

                foreach (var l in loadouts.loadouts)
                    permission.RegisterPermission($"QuickLoadouts.{l.name}", this);
            }
            catch (Exception ex)
            {
                throw new Exception($"Error in Loaded {ex.Message}");
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
                {
                    { "listreply", "Listing Loadouts:" },
                    { "nolistreply", "There are no loadouts." },
                    { "removeusagereply", "usage:  /loadout rem LoadoutName" },
                    { "removereply", "'{name}' Removed." },
                    { "addusagereply", "usage:  /loadout add LoadoutName" },
                    { "addreply", "Added '{name}'. You have to supply the proper permissions to use this loadout. " },
                    { "usereply", "Loadout supplied." },
                    { "clearreply", "Loadouts all cleared." },
                    { "loadoutnotfoundreply", "Loadouts not found." },
                    { "loadoutnoexistreply", "Loadout not found." }
                }, this, "en");
        }

        #region classes 
        class Loadouts
        {
            public List<Loadout> loadouts;

            public Loadouts()
            {
                loadouts = new List<Loadout>();
            }

            public bool AddPlayersLoadout(BasePlayer player, string Name)
            {
                try
                {
                    loadouts.Add(new Loadout(player) { name = Name.ToLower() });
                    return true;
                }
                catch (Exception ex)
                {
                    throw new Exception("Loadouts Error: AddPlayersLoadout:" + ex.StackTrace);
                }
            }

            public bool ReplacePlayersLoadout(BasePlayer player, string Name)
            {
                try
                {
                    if (loadouts.Any(x => x.name.ToString() == Name))
                    {
                        var index = loadouts.IndexOf(loadouts.First(x => x.name.ToString().ToLower() == Name.ToLower()));
                        loadouts.RemoveAt(index);
                        loadouts.Insert(index, new Loadout(player) { name = Name.ToLower() });
                        return true;
                    }
                    return false;
                }
                catch (Exception ex)
                {
                    throw new Exception("Loadouts Error: AddPlayersLoadout:" + ex.StackTrace);
                }
            }

            public bool LoadoutExistByName(string Name)
            {
                return (loadouts.Any(x => x.name.ToString().ToLower() == Name.ToLower()));
            }

        }

        class Loadout
        {
            public object name { get; set; }
            public List<ModItem> containerWear = new List<ModItem>();
            public List<ModItem> containerBelt = new List<ModItem>();
            public List<ModItem> containerMain = new List<ModItem>();

            public Loadout()
            {
                name = "";
                containerWear = new List<ModItem>();
                containerBelt = new List<ModItem>();
                containerMain = new List<ModItem>();
            }

            public Loadout(object packName)
            {
                if (packName != null)
                    name = packName.ToString().ToLower();
                else
                    name = "";

                containerWear = new List<ModItem>();
                containerBelt = new List<ModItem>();
                containerMain = new List<ModItem>();
            }

            public Loadout(BasePlayer player)
            {
                try
                {
                    containerWear = new List<ModItem>();
                    containerBelt = new List<ModItem>();
                    containerMain = new List<ModItem>();

                    foreach (var i in player.inventory.containerWear.itemList)
                    {
                        containerWear.Add(new ModItem(i));
                        player.SendNetworkUpdate();
                    }

                    foreach (var i in player.inventory.containerMain.itemList)
                    {
                        containerMain.Add(new ModItem(i));
                        player.SendNetworkUpdate();
                    }

                    foreach (var i in player.inventory.containerBelt.itemList)
                    {
                        containerBelt.Add(new ModItem(i));
                        player.SendNetworkUpdate();
                    }

                }
                catch (Exception ex)
                {
                    throw new Exception("Error PlayerLoadout:", ex);
                }
            }

            public void SupplyLoadout(BasePlayer Player, bool clearInventory = false)
            {
                try
                {
                    if (clearInventory)
                    {
                        foreach (Item i in Player.inventory.AllItems())
                            i.Remove(0f);
                        Player.SendNetworkUpdate();
                    }

                    Player.inventory.containerMain.Clear();
                    Player.inventory.containerWear.Clear();
                    Player.inventory.containerBelt.Clear();

                    foreach (ModItem e in containerWear)
                        if (e.Item() != null)
                            Player.inventory.GiveItem(e.Item(), Player.inventory.containerWear);


                    foreach (ModItem e in containerMain)
                        if (e.Item() != null)
                            Player.inventory.GiveItem(e.Item(), Player.inventory.containerMain);

                    foreach (ModItem e in containerBelt)
                        if (e.Item() != null)
                            Player.inventory.GiveItem(e.Item(), Player.inventory.containerBelt);

                    Player.SendNetworkUpdate();
                }
                catch (Exception ex)
                {
                    throw new Exception("Error ArenaPlayer:SupplyLoadout:", ex);
                }
            }

        }

        class ModItem
        {
            public string equipName;
            public int amount;
            public ulong skinId;

            public ModItemType etype;

            public List<string> addons = new List<string>();

            public ModItem()
            {
                equipName = "";
                amount = 0;
                skinId = 0;
                addons = new List<string>();
            }

            public ModItem(string EquipName, ModItemType type, int Amount = 1)
            {
                equipName = EquipName;
                amount = Amount;
                etype = type;
                addons = new List<string>();
            }

            public ModItem(string EquipName, string[] Addons, int AmmoAmount = -1)
            {
                equipName = EquipName;
                amount = 1;
                etype = ModItem.ModItemType.Weapon;
                addons = new List<string>();
                foreach (string s in Addons)
                    addons.Add(s);
            }

            public ModItem(Item item)
            {
                try
                {
                    var id = ItemManager.FindItemDefinition(item.info.itemid);
                    equipName = id.shortname;
                    amount = item.amount;
                    skinId = item.skin;

                    if (item.contents != null)
                    {
                        foreach (Item i in item.contents.itemList)
                        {
                            var iid = ItemManager.FindItemDefinition(i.info.itemid);
                            addons.Add(iid.shortname);
                        }
                    }
                }
                catch (Exception ex)
                {
                    throw new Exception("Error ModItem:", ex);
                }

            }

            public Item Item()
            {
                try
                {
                    var definition = ItemManager.FindItemDefinition(this.equipName);
                    if (definition != null)
                    {
                        Item item = ItemManager.CreateByItemID((int)definition.itemid, this.amount, skinId);
                        if (item != null)
                        {
                            if (this.etype == ModItem.ModItemType.Weapon)
                            {
                                // If weapon fill magazine to capacity
                                var weapon = item.GetHeldEntity() as BaseProjectile;
                                if (weapon != null)
                                {
                                    (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.primaryMagazine.capacity;
                                }

                                foreach (var a in this.addons)
                                {
                                    var addonDef = ItemManager.FindItemDefinition(a);
                                    Item addonItem = ItemManager.CreateByItemID((int)addonDef.itemid, 1);
                                    item.contents.AddItem(addonItem.info, 1);
                                }
                            }
                            return item;
                        }
                    }
                    return null;
                }
                catch (Exception ex)
                {
                    throw new Exception("Error ModItem:Item", ex);
                }
            }
            public enum ModItemType
            {
                Weapon,
                Item
            }

        }
        #endregion

        void UseLoadout(BasePlayer player, string LoaoutName)
        {
            var lo = (loadouts.loadouts.Any(x => x.name.ToString() == LoaoutName)) ? loadouts.loadouts.First(x => x.name.ToString() == LoaoutName) : null;
            if (lo == null)
            {
                PrintToChat(player, lang.GetMessage("loadoutnotfoundreply", this, player.UserIDString));
                return;
            }
            UseLoadout(player, lo);

        }

        void UseLoadout(BasePlayer player, Loadout l)
        {
            if (permission.UserHasPermission(player.UserIDString, allPermission)
                ||
                permission.UserHasPermission(player.UserIDString, "QuickLoadouts." + l.name))
            {
                l.SupplyLoadout(player);
                PrintToChat(player, lang.GetMessage("usereply", this, player.UserIDString));
            }
        }

        [ChatCommand(UseCommandChatConsole)]
        void chatCommandUseLoadout(BasePlayer player, string command, string[] args)
        {
            try
            {
                if (args.Length < 1) return;
                UseLoadout(player, args[0]);
            }
            catch (Exception ex)
            {
                throw new Exception("Error consoleCommandUseLoadout.", ex);
            }
        }

        [ConsoleCommand(UseCommandChatConsole)]
        void consoleCommandUseLoadout(ConsoleSystem.Arg arg)
        {
            try
            {
                if (arg.Args.Length < 1) return;
                if (arg.Player() == null) return;
                BasePlayer player = arg.Player();
                UseLoadout(player, arg.Args[0]);
            }
            catch (Exception ex)
            {
                throw new Exception("Error consoleCommandUseLoadout.", ex);
            }
        }

        [ChatCommand(AdminCommandChatConsole)]
        void chatCommandquickloadout(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, adminPermission))
                return;

            #region  List
            if (args.Length == 0) // list loadouts
            {
                int ii = 0;
                if (loadouts.loadouts.Count() > 0)
                {
                    PrintToChat(player, lang.GetMessage("listreply", this, player.UserIDString));
                    foreach (var l in loadouts.loadouts)
                        PrintToChat(player, $"{(++ii).ToString()} {l.name}");
                }
                else
                    PrintToChat(player, lang.GetMessage("nolistreply", this, player.UserIDString));
                return;
            }
            #endregion

            switch (args[0].ToLower())
            {
                case "rem":
                case "remove":
                    if (args.Count() < 2)
                        PrintToChat(player, lang.GetMessage("removeusagereply", this, player.UserIDString));
                    else
                    {

                        if (loadouts.loadouts.Any(x => x.name.ToString().ToLower() == args[1].ToLower().ToString()))
                        {
                            loadouts.loadouts.Remove(loadouts.loadouts.First(x => x.name.ToString().ToLower() == args[1].ToLower().ToString()));
                            Interface.Oxide.DataFileSystem.WriteObject(loadoutFileName, loadouts);
                            PrintToChat(player, lang.GetMessage("removereply", this, player.UserIDString).Replace("{name}", args[1].ToString()));
                        }
                    }
                    break;

                case "add":
                    if (args.Count() < 2)
                        PrintToChat(player, lang.GetMessage("addusagereply", this, player.UserIDString));
                    else
                    {
                        string Name = "";
                        foreach (var s in args)
                            if (s != "add") Name += " " + s;
                        var name = Name.Replace("'", "").Trim();

                        if (loadouts.LoadoutExistByName(name))
                            loadouts.ReplacePlayersLoadout(player, name);
                        else
                            loadouts.AddPlayersLoadout(player, name);

                        permission.RegisterPermission($"QuickLoadouts.{name}", this);
                        Interface.Oxide.DataFileSystem.WriteObject(loadoutFileName, loadouts);

                        PrintToChat(player, lang.GetMessage("addreply", this, player.UserIDString).Replace("{name}", name));
                    }
                    break;

                case "use":
                    var l = (loadouts.loadouts.Any(x => x.name.ToString().ToLower() == args[1].ToLower().ToString())) ? loadouts.loadouts.First(x => x.name.ToString().ToLower() == args[1].ToLower().ToString()) : null;
                    if (l != null)
                    {
                        l.SupplyLoadout(player);
                        PrintToChat(player, lang.GetMessage("usereply", this, player.UserIDString));
                    }
                    else
                        PrintToChat(player, lang.GetMessage("loadoutnoexistreply", this, player.UserIDString));
                    break;

                case "clear":
                    loadouts.loadouts.Clear();
                    Interface.Oxide.DataFileSystem.WriteObject(loadoutFileName, loadouts);
                    PrintToChat(player, lang.GetMessage("clearreply", this, player.UserIDString));

                    break;
                default:
                    break;
            }

        }

    }
}

// --- End of file: QuickLoadouts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/quests ---
// --- Original File Path: Q/Quests/Quests.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

// ToDo: ZLevels integration (waiting for ZLevels api implementation)
// ToDo: Add Cooldown option for Delivery

namespace Oxide.Plugins
{
    [Info("Quests", "Gonzi", "2.4.3")]
    [Description("Creates quests for players to go on to earn rewards, complete with a GUI menu")]
    public class Quests : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin HumanNPC;
        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin Economics;
        [PluginReference] Plugin LustyMap;
        [PluginReference] Plugin EventManager;
        [PluginReference] Plugin HuntRPG;
        [PluginReference] Plugin PlayerChallenges;
        [PluginReference] Plugin BetterChat;

        ConfigData configData;

        QuestData questData;
        PlayerData playerData;
        NPCData vendors;
        ItemNames itemNames;
        private DynamicConfigFile Quest_Data;
        private DynamicConfigFile Player_Data;
        private DynamicConfigFile Quest_Vendors;
        private DynamicConfigFile Item_Names;

        private Dictionary<ulong, PlayerQuestData> PlayerProgress;
        private Dictionary<QuestType, Dictionary<string, QuestEntry>> Quest;

        private Dictionary<string, ItemDefinition> ItemDefs;
        private Dictionary<string, string> DisplayNames = new Dictionary<string, string>();

        private Dictionary<ulong, QuestCreator> ActiveCreations = new Dictionary<ulong, QuestCreator>();
        private Dictionary<ulong, QuestCreator> ActiveEditors = new Dictionary<ulong, QuestCreator>();

        private Dictionary<ulong, bool> AddVendor = new Dictionary<ulong, bool>();

        private Dictionary<QuestType, List<string>> AllObjectives = new Dictionary<QuestType, List<string>>();
        private Dictionary<NetworkableId, Dictionary<ulong, int>> HeliAttackers = new Dictionary<NetworkableId, Dictionary<ulong, int>>();

        private Dictionary<ulong, List<string>> OpenUI = new Dictionary<ulong, List<string>>();
        private Dictionary<ItemId, ulong> Looters = new Dictionary<ItemId, ulong>();

        private List<ulong> StatsMenu = new List<ulong>();
        private List<ulong> OpenMenuBind = new List<ulong>();

        static string UIMain = "UIMain";
        static string UIPanel = "UIPanel";
        static string UIEntry = "UIEntry";

        static string permission_manage = "quests.manage";
        static string permission_use = "quests.use";

        private string textPrimary;
        private string textSecondary;
        #endregion

        #region Classes

        class PlayerQuestData
        {
            public Dictionary<string, PlayerQuestInfo> Quests = new Dictionary<string, PlayerQuestInfo>();
            public List<QuestInfo> RequiredItems = new List<QuestInfo>();
            public ActiveDelivery CurrentDelivery = new ActiveDelivery();
        }

        class PlayerQuestInfo
        {
            public QuestStatus Status;
            public QuestType Type;
            public int AmountCollected = 0;
            public bool RewardClaimed = false;
            public double ResetTime = 0;
        }

        class QuestEntry
        {
            public string QuestName;
            public string Description;
            public string Objective;
            public string ObjectiveName;
            public int AmountRequired;
            public int Cooldown;
            public bool ItemDeduction;
            public List<RewardItem> Rewards;
        }

        class NPCInfo
        {
            public float x;
            public float z;
            public string ID;
            public string Name;
        }

        class DeliveryInfo
        {
            public string Description;
            public NPCInfo Info;
            public RewardItem Reward;
            public float Multiplier;
        }

        class ActiveDelivery
        {
            public string VendorID;
            public string TargetID;
            public float Distance;
        }

        class QuestInfo
        {
            public string ShortName;
            public QuestType Type;
        }

        class RewardItem
        {
            public bool isRP = false;
            public bool isCoins = false;
            public bool isHuntXP = false;
            public string DisplayName;
            public string ShortName;
            public int ID;
            public float Amount;
            public bool BP;
            public ulong Skin;
        }

        class QuestCreator
        {
            public QuestType type;
            public QuestEntry entry;
            public DeliveryInfo deliveryInfo;
            public RewardItem item;
            public string oldEntry;
            public int partNum;
        }

        class ItemNames
        {
            public Dictionary<string, string> DisplayNames = new Dictionary<string, string>();
        }

        enum QuestType
        {
            Kill,
            Craft,
            Gather,
            Loot,
            Delivery
        }

        enum QuestStatus
        {
            Pending,
            Completed,
            Open
        }

        #endregion

        #region UI Creation

        class QUI
        {
            public static bool disableFade;

            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = cursor
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return NewElement;
            }

            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }

            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (disableFade)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (disableFade)
                    fadein = 0;
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = fadein },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png},
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax}
                    }
                });
            }

            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                if (disableFade)
                    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        #endregion

        #region Oxide Hooks

        void Loaded()
        {
            permission.RegisterPermission(permission_use, this);
            permission.RegisterPermission(permission_manage, this);
            Quest_Data = Interface.Oxide.DataFileSystem.GetFile("Quests/quests_data");
            Player_Data = Interface.Oxide.DataFileSystem.GetFile("Quests/quests_players");
            Quest_Vendors = Interface.Oxide.DataFileSystem.GetFile("Quests/quests_vendors");
            Item_Names = Interface.Oxide.DataFileSystem.GetFile("Quests/quests_itemnames");
            lang.RegisterMessages(Localization, this);
        }

        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();

            QUI.disableFade = configData.DisableUI_FadeIn;
            textPrimary = $"<color={configData.Colors.TextColor_Primary}>";
            textSecondary = $"<color={configData.Colors.TextColor_Secondary}>";

            ItemDefs = ItemManager.itemList.ToDictionary(i => i.shortname);
            FillObjectiveList();
            AddMapIcons();
            timer.Once(900, () => SaveLoop());
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
            SavePlayerData();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (configData.KeybindOptions.Autoset_KeyBind)
            {
                if (!string.IsNullOrEmpty(configData.KeybindOptions.KeyBind_Key))
                {
                    player.Command("bind " + configData.KeybindOptions.KeyBind_Key + " QUI_OpenQuestMenu");
                }
            }
        }

        #region Objective Hooks

        //Kill
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || info == null) return;
                string entname = entity?.ShortPrefabName;
                if (entname == "testridablehorse")
                {
                    entname = "horse";
                }

                if ((entname.Contains("scientist")) && (!entname.Contains("corpse")))
                {
                    entname = "scientist";
                }

                BasePlayer player = null;

                if (info.InitiatorPlayer != null)
                    player = info.InitiatorPlayer;
                else if (entity.GetComponent<BaseHelicopter>() != null)
                    player = BasePlayer.FindByID(GetLastAttacker(entity.net.ID));

                if (player != null)
                {
                    if (entity.ToPlayer() != null && entity.ToPlayer() == player) return;
                    if (isPlaying(player)) return;
                    if (hasQuests(player.userID) && isQuestItem(player.userID, entname, QuestType.Kill))
                        ProcessProgress(player, QuestType.Kill, entname);
                }
            }
            catch (Exception ex)
            {
                PrintWarning("Error at hook OnEntityDeath:\n" + ex);
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo info)
        {
            if (victim.GetComponent<BaseHelicopter>() != null && info?.Initiator?.ToPlayer() != null)
            {
                var heli = victim.GetComponent<BaseHelicopter>();
                var player = info.Initiator.ToPlayer();
                if (isPlaying(player)) return;
                NextTick(() =>
                {
                    if (heli == null) return;
                    if (!HeliAttackers.ContainsKey(heli.net.ID))
                        HeliAttackers.Add(heli.net.ID, new Dictionary<ulong, int>());
                    if (!HeliAttackers[heli.net.ID].ContainsKey(player.userID))
                        HeliAttackers[heli.net.ID].Add(player.userID, 0);
                    HeliAttackers[heli.net.ID][player.userID]++;
                });
            }
        }

        // Gather
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity?.ToPlayer();
            if (player != null)
                if (hasQuests(player.userID) && isQuestItem(player.userID, item.info.shortname, QuestType.Gather))
                    ProcessProgress(player, QuestType.Gather, item.info.shortname, item.amount);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnDispenserGather(dispenser, entity, item);

        void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player)
        {
            if (player != null)
                if (hasQuests(player.userID) && isQuestItem(player.userID, item.info.shortname, QuestType.Gather))
                    ProcessProgress(player, QuestType.Gather, item.info.shortname, item.amount);
        }

        void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
            if (player != null)
                foreach (ItemAmount itemAmount in collectible.itemList)
                    if (hasQuests(player.userID) && isQuestItem(player.userID, itemAmount.itemDef.shortname, QuestType.Gather))
                        ProcessProgress(player, QuestType.Gather, itemAmount.itemDef.shortname, (int)itemAmount.amount);
        }

        //Craft
        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            var player = task.owner;
            if (player != null)
                if (hasQuests(player.userID) && isQuestItem(player.userID, item.info.shortname, QuestType.Craft))
                    ProcessProgress(player, QuestType.Craft, item.info.shortname, item.amount);
        }

        //Loot
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (Looters.ContainsKey(item.uid))
            {
                if (container.playerOwner != null)
                {
                    if (Looters[item.uid] != container.playerOwner.userID)
                    {
                        if (hasQuests(container.playerOwner.userID) && isQuestItem(container.playerOwner.userID, item.info.shortname, QuestType.Loot))
                        {
                            ProcessProgress(container.playerOwner, QuestType.Loot, item.info.shortname, item.amount);
                            Looters.Remove(item.uid);
                        }
                    }
                }
            }
            else if (container.playerOwner != null) Looters.Add(item.uid, container.playerOwner.userID);
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            ulong id = 0U;
            if (container.entityOwner != null)
                id = container.entityOwner.OwnerID;
            else if (container.playerOwner != null)
                id = container.playerOwner.userID;

            if (!Looters.ContainsKey(item.uid))
                Looters.Add(item.uid, id);
        }

        // Delivery and Vendors
        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (player == null || npc == null) return;
            CheckPlayerEntry(player);
            var npcID = npc.UserIDString;
            if (vendors.QuestVendors.ContainsKey(npcID) && configData.UseNPCVendors)
            {
                CreateMenu(player);
                return;
            }

            if (vendors.DeliveryVendors.ContainsKey(npcID))
            {
                if (hasQuests(player.userID) && PlayerProgress[player.userID].CurrentDelivery.TargetID == npc.UserIDString)
                    AcceptDelivery(player, npcID, 1);

                if (hasQuests(player.userID) && string.IsNullOrEmpty(PlayerProgress[player.userID].CurrentDelivery.TargetID))
                    AcceptDelivery(player, npcID);
                else SendMSG(player, LA("delInprog", player.UserIDString), LA("Quests", player.UserIDString));
            }
        }

        #endregion

        object OnPlayerChat(BasePlayer player, string message)
        {
            if (BetterChat) return null;
            if (player == null) return null;

            if (ActiveEditors.ContainsKey(player.userID) || ActiveCreations.ContainsKey(player.userID) || AddVendor.ContainsKey(player.userID))
            {
                QuestChat(player, message.Split(' '));
                return false;
            }

            return null;
        }

        object OnBetterChat(Dictionary<string, object> dict)
        {
            var player = (dict["Player"] as IPlayer).Object as BasePlayer;
            if (player == null) return null;
            string message = dict["Message"].ToString();
            if (ActiveEditors.ContainsKey(player.userID) || ActiveCreations.ContainsKey(player.userID) || AddVendor.ContainsKey(player.userID))
            {
                QuestChat(player, message.Split(' '));
                dict["CancelOption"] = 2;
                return dict;
            }

            return dict;
        }

        void QuestChat(BasePlayer player, string[] arg)
        {
            bool isEditing = false;
            bool isCreating = false;
            QuestCreator Creator = new QuestCreator();
            QuestEntry Quest = new QuestEntry();

            // remove all html codes from the message (needed for colored chat messages)
            System.Text.RegularExpressions.Regex rmHTML = new System.Text.RegularExpressions.Regex("<[^>]*>");
            var args = rmHTML.Replace(string.Join(" ", arg), "");
            var argsForNumbers = rmHTML.Replace(arg[0], "");

            if (ActiveEditors.ContainsKey(player.userID))
            {
                isEditing = true;
                Creator = ActiveEditors[player.userID];
                Quest = Creator.entry;
            }
            else if (ActiveCreations.ContainsKey(player.userID))
            {
                isCreating = true;
                Creator = ActiveCreations[player.userID];
                Quest = Creator.entry;
            }

            if (AddVendor.ContainsKey(player.userID) && string.Join(" ", arg).Contains("exit"))
            {
                ExitQuest(player, true);
                return;
            }

            if (!isEditing && !isCreating)
                return;

            if (args.Contains("exit"))
            {
                ExitQuest(player, isCreating);
                return;
            }

            if (args.Contains("quest item"))
            {
                var item = GetItem(player);
                if (item != null)
                {
                    if (Creator.type != QuestType.Delivery)
                    {
                        Quest.Rewards.Add(item);
                        Creator.partNum++;
                        if (isCreating)
                            CreationHelp(player, 7);
                        else if (isEditing)
                        {
                            SaveRewardsEdit(player);
                            CreationHelp(player, 10);
                        }
                    }
                    else
                    {
                        Creator.deliveryInfo.Reward = item;
                        DeliveryHelp(player, 4);
                    }
                }
                else SendMSG(player, $"{LA("noAItem", player.UserIDString)}'quest item'", LA("QC", player.UserIDString));

                return;
            }

            switch (Creator.partNum)
            {
                case 0:
                    foreach (var type in questData.Quest)
                    {
                        if (type.Value.ContainsKey(args))
                        {
                            SendMSG(player, LA("nameExists", player.UserIDString), LA("QC", player.UserIDString));
                            return;
                        }
                    }

                    Quest.QuestName = args;
                    SendMSG(player, args, "Name:");
                    Creator.partNum++;
                    if (isCreating)
                        CreationHelp(player, 1);
                    else CreationHelp(player, 6);
                    return;
                case 2:
                    {
                        int amount;
                        if (!int.TryParse(argsForNumbers, out amount))
                        {
                            SendMSG(player, LA("objAmount", player.UserIDString), LA("QC", player.UserIDString));
                            return;
                        }

                        Quest.AmountRequired = amount;
                        SendMSG(player, argsForNumbers, LA("OA", player.UserIDString));
                        Creator.partNum++;
                        if (isCreating)
                            CreationHelp(player, 3);
                        else CreationHelp(player, 6);
                    }
                    return;
                case 3:
                    {
                        if (Creator.type == QuestType.Delivery)
                        {
                            Creator.deliveryInfo.Description = args;
                            SendMSG(player, args, LA("Desc", player.UserIDString));
                            DeliveryHelp(player, 6);
                            return;
                        }

                        Quest.Description = args;
                        SendMSG(player, args, LA("Desc", player.UserIDString));
                        Creator.partNum++;
                        if (isCreating)
                            CreationHelp(player, 4);
                        else CreationHelp(player, 6);
                    }
                    return;
                case 5:
                    {
                        if (Creator.type == QuestType.Delivery)
                        {
                            float amount;
                            if (!float.TryParse(argsForNumbers, out amount))
                            {
                                SendMSG(player, LA("noRM", player.UserIDString), LA("QC", player.UserIDString));
                                return;
                            }

                            Creator.deliveryInfo.Multiplier = amount;

                            SendMSG(player, argsForNumbers, LA("RM", player.UserIDString));
                            Creator.partNum++;
                            DeliveryHelp(player, 5);
                        }
                        else
                        {
                            int amount;
                            if (!int.TryParse(argsForNumbers, out amount))
                            {
                                SendMSG(player, LA("noRA", player.UserIDString), LA("QC", player.UserIDString));
                                return;
                            }

                            Creator.item.Amount = amount;
                            Quest.Rewards.Add(Creator.item);
                            Creator.item = new RewardItem();
                            SendMSG(player, argsForNumbers, LA("RA", player.UserIDString));
                            Creator.partNum++;
                            if (isCreating)
                                CreationHelp(player, 7);
                            else if (isEditing)
                            {
                                SaveRewardsEdit(player);
                            }
                        }

                        return;
                    }
                case 6:
                    {
                        int amount;
                        if (!int.TryParse(argsForNumbers, out amount))
                        {
                            SendMSG(player, LA("noCD", player.UserIDString), LA("QC", player.UserIDString));
                            return;
                        }

                        Creator.entry.Cooldown = amount;
                        SendMSG(player, argsForNumbers, LA("CD1", player.UserIDString));
                        CreationHelp(player, 6);
                    }
                    return;
                default:
                    break;
            }
        }

        #endregion

        #region External Calls

        private bool isPlaying(BasePlayer player)
        {
            if (EventManager)
            {
                var inEvent = EventManager?.Call("isPlaying", player);
                if (inEvent is bool && (bool)inEvent)
                    return true;
            }

            return false;
        }

        private void CloseMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("DisableMaps", player);
            }
        }

        private void OpenMap(BasePlayer player)
        {
            if (LustyMap)
            {
                LustyMap.Call("EnableMaps", player);
            }
        }

        private void AddMapMarker(float x, float z, string name, string icon = "special", float r = 0)
        {
            if (LustyMap)
                LustyMap.Call("AddMarker", x, z, name, icon);
        }

        private void RemoveMapMarker(string name)
        {
            if (LustyMap)
                LustyMap.Call("RemoveMarker", name);
        }

        private object CanTeleport(BasePlayer player)
        {
            if (!PlayerProgress.ContainsKey(player.userID)) return null;

            if (!string.IsNullOrEmpty(PlayerProgress[player.userID].CurrentDelivery.TargetID))
            {
                return LA("NoTP", player.UserIDString);
            }
            else
                return null;
        }

        #endregion

        #region Objective Lists

        private void FillObjectiveList()
        {
            AllObjectives.Add(QuestType.Loot, new List<string>());
            AllObjectives.Add(QuestType.Craft, new List<string>());
            AllObjectives.Add(QuestType.Kill, new List<string>());
            AllObjectives.Add(QuestType.Gather, new List<string>());
            AllObjectives.Add(QuestType.Delivery, new List<string>());
            GetAllCraftables();
            GetAllItems();
            GetAllKillables();
            GetAllResources();
            foreach (var category in AllObjectives)
                category.Value.Sort();

            if (itemNames.DisplayNames == null || itemNames.DisplayNames.Count < 1)
            {
                foreach (var item in ItemDefs)
                {
                    if (!DisplayNames.ContainsKey(item.Key))
                        DisplayNames.Add(item.Key, item.Value.displayName.translated);
                }

                SaveDisplayNames();
            }
            else DisplayNames = itemNames.DisplayNames;
        }

        private void GetAllItems()
        {
            foreach (var item in ItemManager.itemList)
                AllObjectives[QuestType.Loot].Add(item.shortname);
        }

        private void GetAllCraftables()
        {
            foreach (var bp in ItemManager.bpList)
                if (bp.userCraftable)
                    AllObjectives[QuestType.Craft].Add(bp.targetItem.shortname);
        }

        private void GetAllResources()
        {
            AllObjectives[QuestType.Gather] = new List<string>
            {
                "wood",
                "stones",
                "metal.ore",
                "hq.metal.ore",
                "sulfur.ore",
                "cloth",
                "bone.fragments",
                "crude.oil",
                "fat.animal",
                "leather",
                "skull.wolf",
                "skull.human",
                "chicken.raw",
                "mushroom",
                "meat.boar",
                "bearmeat",
                "humanmeat.raw",
                "wolfmeat.raw"
            };
        }

        private void GetAllKillables()
        {
            AllObjectives[QuestType.Kill] = new List<string>
            {
                "bear",
                "boar",
                "bradleyapc",
                "chicken",
                "horse",
                "stag",
                "wolf",
                "autoturret_deployed",
                "patrolhelicopter",
                "player",
                "scientist",
                "murderer",
                "tunneldweller",
                "underwaterdweller",
                "scarecrow",
                "simpleshark"
            };
            DisplayNames.Add("bear", "Bear");
            DisplayNames.Add("boar", "Boar");
            DisplayNames.Add("bradleyapc", "BradleyAPC");
            DisplayNames.Add("chicken", "Chicken");
            DisplayNames.Add("horse", "Horse");
            DisplayNames.Add("stag", "Stag");
            DisplayNames.Add("wolf", "Wolf");
            DisplayNames.Add("autoturret_deployed", "Auto-Turret");
            DisplayNames.Add("patrolhelicopter", "Helicopter");
            DisplayNames.Add("player", "Player");
            DisplayNames.Add("scientist", "Scientist");
            DisplayNames.Add("murderer", "Murderer");
            DisplayNames.Add("tunneldweller", "Tunneldweller");
            DisplayNames.Add("underwaterdweller", "Underwater Dweller");
            DisplayNames.Add("scarecrow", "Scarecrow");
            DisplayNames.Add("simpleshark", "Shark");
        }

        #endregion

        #region Functions

        private bool isAdmin(BasePlayer player)
        {
            if (configData.UseOxidePermissions == true && permission.UserHasPermission(player.UserIDString, permission_manage) || player.IsAdmin && configData.UsePlayerIsAdmin == true) return true;
            else return false;
        }

        void AddMapIcons()
        {
            int deliveryCount = 1;
            foreach (var vendor in vendors.DeliveryVendors)
            {
                AddMapMarker(vendor.Value.Info.x, vendor.Value.Info.z, vendor.Value.Info.Name, $"{configData.LustyMapIntegration.Icon_Delivery}_{deliveryCount}.png");
                ++deliveryCount;
            }

            foreach (var vendor in vendors.QuestVendors)
            {
                AddMapMarker(vendor.Value.x, vendor.Value.z, vendor.Value.Name, $"{configData.LustyMapIntegration.Icon_Vendor}.png");
            }
        }

        private void ProcessProgress(BasePlayer player, QuestType questType, string type, int amount = 0)
        {
            if (string.IsNullOrEmpty(type)) return;
            var data = PlayerProgress[player.userID];
            if (data.RequiredItems.Count > 0)
            {
                foreach (var entry in data.Quests.Where(x => x.Value.Status == QuestStatus.Pending))
                {
                    var quest = GetQuest(entry.Key);
                    if (quest != null)
                    {
                        if (type == quest.Objective)
                        {
                            if (amount > 0)
                            {
                                var amountRequired = quest.AmountRequired - entry.Value.AmountCollected;
                                if (amount > amountRequired)
                                    amount = amountRequired;
                                entry.Value.AmountCollected += amount;

                                if (quest.ItemDeduction)
                                    TakeQuestItem(player, type, amount);
                            }
                            else entry.Value.AmountCollected++;

                            if (entry.Value.AmountCollected >= quest.AmountRequired)
                                CompleteQuest(player, entry.Key);
                            return;
                        }
                    }
                }
            }
        }

        private void TakeQuestItem(BasePlayer player, string item, int amount)
        {
            if (ItemDefs.ContainsKey(item))
            {
                var itemDef = ItemDefs[item];
                NextTick(() => player.inventory.Take(null, itemDef.itemid, amount));
            }
            else PrintWarning($"Unable to find definition for: {item}.");
        }

        private void CompleteQuest(BasePlayer player, string questName)
        {
            var data = PlayerProgress[player.userID].Quests[questName];
            var items = PlayerProgress[player.userID].RequiredItems;
            var quest = GetQuest(questName);
            if (quest != null)
            {
                data.Status = QuestStatus.Completed;
                data.ResetTime = GrabCurrentTime() + (quest.Cooldown * 60);

                for (int i = 0; i < items.Count; i++)
                {
                    if (items[i].ShortName == quest.Objective && items[i].Type == data.Type)
                    {
                        items.Remove(items[i]);
                        break;
                    }
                }

                SendMSG(player, "", $"{LA("qComple", player.UserIDString)} {questName}. {LA("claRew", player.UserIDString)}");
                PlayerChallenges?.Call("CompletedQuest", player);
            }
        }

        private ItemDefinition FindItemDefinition(string shortname)
        {
            ItemDefinition itemDefinition;
            return ItemDefs.TryGetValue(shortname, out itemDefinition) ? itemDefinition : null;
        }

        private string GetRewardString(List<RewardItem> entry)
        {
            var rewards = "";
            int i = 1;
            foreach (var item in entry)
            {
                rewards = rewards + $"{(int)item.Amount}x {item.DisplayName}";
                if (i < entry.Count)
                    rewards = rewards + ", ";
                i++;
            }

            return rewards;
        }

        private bool GiveReward(BasePlayer player, List<RewardItem> rewards)
        {
            foreach (var reward in rewards)
            {
                if (reward.isCoins && Economics)
                {
                    Economics.Call("Deposit", player.UserIDString, (double)reward.Amount);
                }
                else if (reward.isRP && ServerRewards)
                {
                    ServerRewards.Call("AddPoints", player.userID, (int)reward.Amount);
                }
                else if (reward.isHuntXP)
                {
                    HuntRPG?.Call("GiveEXP", player, (int)reward.Amount);
                }
                else
                {
                    if (string.IsNullOrEmpty(reward.ShortName)) return true;
                    var definition = FindItemDefinition(reward.ShortName);
                    if (definition != null)
                    {
                        if (player.inventory.AllItems().Count() >= 30) return false;
                        var item = ItemManager.Create(definition, (int)reward.Amount, reward.Skin);
                        if (item != null)
                        {
                            player.inventory.GiveItem(item, player.inventory.containerMain);
                        }
                    }
                    else PrintWarning($"Quests: Error building item {reward.ShortName} for {player.displayName}");
                }
            }

            return true;
        }

        private void ReturnItems(BasePlayer player, string itemname, int amount)
        {
            if (amount > 0)
            {
                var definition = FindItemDefinition(itemname);
                if (definition != null)
                {
                    var item = ItemManager.Create(definition, amount);
                    if (item != null)
                    {
                        player.inventory.GiveItem(item);
                        PopupMessage(player, $"{LA("qCancel", player.UserIDString)} {item.amount}x {item.info.displayName.translated} {LA("rewRet", player.UserIDString)}");
                    }
                }
            }
        }

        private RewardItem GetItem(BasePlayer player)
        {
            Item item = player.GetActiveItem();
            if (item == null) return null;
            var newItem = new RewardItem
            {
                Amount = item.amount,
                DisplayName = DisplayNames[item.info.shortname],
                ID = item.info.itemid,
                ShortName = item.info.shortname,
                Skin = item.skin
            };
            return newItem;
        }

        private bool hasQuests(ulong player)
        {
            try
            {
                if (player.IsSteamId() && PlayerProgress.ContainsKey(player))
                {
                    return true;
                }

                return false;
            }
            catch
            {
                Puts($"Error checking quests for {player}");
                return false;
            }
        }

        private bool isQuestItem(ulong player, string name, QuestType type)
        {
            var data = PlayerProgress[player].RequiredItems;
            for (int i = 0; i < data.Count; i++)
            {
                if (data[i].ShortName == name && data[i].Type == type)
                    return true;
            }

            return false;
        }

        private void CheckPlayerEntry(BasePlayer player)
        {
            if (!PlayerProgress.ContainsKey(player.userID))
                PlayerProgress.Add(player.userID, new PlayerQuestData());
        }

        private object GetQuestType(string name)
        {
            foreach (var entry in Quest)
                if (entry.Value.ContainsKey(name))
                    return entry.Key;
            return null;
        }

        private QuestEntry GetQuest(string name)
        {
            var type = GetQuestType(name);
            if (type != null)
            {
                foreach (var entry in questData.Quest[(QuestType)type])
                {
                    if (entry.Key == name)
                        return entry.Value;
                }
            }

            PrintWarning($"Error retrieving quest info for: {name}");
            return null;
        }

        private void SaveQuest(BasePlayer player, bool isCreating)
        {
            QuestCreator Creator;
            QuestEntry Quest;

            if (isCreating)
                Creator = ActiveCreations[player.userID];
            else Creator = ActiveEditors[player.userID];
            Quest = Creator.entry;

            if (isCreating)
            {
                if (Creator.type == QuestType.Delivery)
                {
                    var npc = BasePlayer.FindByID(ulong.Parse(Creator.deliveryInfo.Info.ID));
                    if (npc != null)
                    {
                        npc.displayName = Creator.deliveryInfo.Info.Name;
                        npc.SendNetworkUpdateImmediate();
                    }

                    vendors.DeliveryVendors.Add(Creator.deliveryInfo.Info.ID, Creator.deliveryInfo);
                    AddMapMarker(Creator.deliveryInfo.Info.x, Creator.deliveryInfo.Info.z, Creator.deliveryInfo.Info.Name, $"{configData.LustyMapIntegration.Icon_Delivery}_{vendors.DeliveryVendors.Count}.png");
                    AddVendor.Remove(player.userID);
                    SaveVendorData();
                    DestroyUI(player);
                    if (vendors.DeliveryVendors.Count < 2)
                        PopupMessage(player, LA("minDV", player.UserIDString));
                    SendMSG(player, LA("DVSucc", player.UserIDString), LA("QC", player.UserIDString));
                    OpenMap(player);
                    return;
                }
                else questData.Quest[Creator.type].Add(Quest.QuestName, Quest);

                ActiveCreations.Remove(player.userID);
            }
            else
            {
                questData.Quest[Creator.type].Remove(Creator.oldEntry);
                questData.Quest[Creator.type].Add(Quest.QuestName, Quest);
                ActiveEditors.Remove(player.userID);
            }

            DestroyUI(player);
            SaveQuestData();
            SendMSG(player, $"{LA("saveQ", player.UserIDString)} {Quest.QuestName}", LA("QC", player.UserIDString));
        }

        private void SaveRewardsEdit(BasePlayer player)
        {
            QuestCreator Creator = ActiveEditors[player.userID];
            QuestEntry Quest = Creator.entry;
            questData.Quest[Creator.type].Remove(Creator.entry.QuestName);
            questData.Quest[Creator.type].Add(Quest.QuestName, Quest);

            DestroyUI(player);
            SaveQuestData();
            CreationHelp(player, 10);
            SendMSG(player, $"{LA("saveQ", player.UserIDString)} {Quest.QuestName}", LA("QC", player.UserIDString));
        }

        private void ExitQuest(BasePlayer player, bool isCreating)
        {
            if (isCreating)
                ActiveCreations.Remove(player.userID);
            else ActiveEditors.Remove(player.userID);

            SendMSG(player, LA("QCCancel", player.UserIDString), LA("QC", player.UserIDString));
            DestroyUI(player);
        }

        private void RemoveQuest(string questName)
        {
            var Quest = GetQuest(questName);
            if (Quest == null) return;
            var Type = (QuestType)GetQuestType(questName);
            questData.Quest[Type].Remove(questName);

            foreach (var player in PlayerProgress)
            {
                if (player.Value.Quests.ContainsKey(questName))
                    player.Value.Quests.Remove(questName);
            }

            if (vendors.DeliveryVendors.ContainsKey(Quest.Objective))
                vendors.DeliveryVendors.Remove(Quest.Objective);
            if (vendors.QuestVendors.ContainsKey(Quest.Objective))
                vendors.QuestVendors.Remove(Quest.Objective);
